[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nusing namespace std;\n\nstring s;\nint n, m, l[N], r[N], sum[N], cnt[N];\nint pset[N];\n\nint findset(int i){return ((pset[i] == i) ? i : pset[i] = findset(pset[i]));}\n\nvoid dsu(int i, int j){\n    i = findset(i); j = findset(j);\n    if (i == j) return;\n    pset[j] = i;\n    sum[i] = (sum[i] + sum[j]) % 26;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s;\n    n = s.size();\n    s = '.' + s;\n    cin >> m;\n    for (int i = 1; i <= m; i++){\n        cin >> l[i] >> r[i];\n        if (r[i] < n + 1 - r[i]) continue;\n        if (l[i] > n + 1 - l[i]){\n            l[i] = n + 1 - l[i];\n            r[i] = n + 1 - r[i];\n            continue;\n        }\n        r[i] = n + 1 - r[i];\n        if (l[i] <= r[i]) r[i]--;\n        else l[i]--, swap(l[i], r[i]);\n    }\n\n    for (int i = 1; i <= n/2; i++){\n        cnt[i] = (s[n+1-i] - s[i] + 26) % 26;\n    }\n\n    sum[n/2+1] = (26 - cnt[n/2]) % 26;\n    for (int i = n/2; i >= 1; i--) {\n        sum[i] = (cnt[i] - cnt[i-1] + 26) % 26;\n    }\n\n    for (int i = 1; i <= n/2+1; i++) pset[i] = i;\n    for (int i = 1; i <= m; i++) dsu(l[i], r[i]+1);\n\n    for (int i = 1; i <= n/2+1; i++) {\n        if (pset[i] == i && sum[i] != 0) return cout << \"NO\", 0;\n    }\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint L[110000],R[110000];\nint n,m,A[110000],len,a[110000];\nchar ch[110000];\nstruct atom{\n\tint l,r;\n};\nint operator < (atom k1,atom k2){\n\treturn k1.r>k2.r||(k1.r==k2.r&&k1.l>k2.l);\n}\npriority_queue<atom>Q;\nint main(){\n\tscanf(\"%s\",ch+1); len=strlen(ch+1); n=len/2;\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&L[i],&R[i]);\n\tfor (int i=1;i<=n;i++) A[i]=(ch[len-i+1]-ch[i]+26)%26;\n\tfor (int i=1;i<=m;i++){\n\t\tint k1=L[i],k2=R[i];\n\t\tif (k2*2<=len+1) Q.push((atom){k1,k2});\n\t\telse if (k1*2>=len+1){\n\t\t\tQ.push((atom){len-k2+1,len-k1+1});\n\t\t} else if (len-L[i]+2<=R[i])\n\t\t\tQ.push((atom){len-R[i]+1,L[i]-1});\n\t\telse if (len-R[i]>=L[i])\n\t\t\tQ.push((atom){L[i],len-R[i]});\n\t}\n\tmemset(a,0x00,sizeof a);\n\twhile (!Q.empty()){\n\t\tatom k=Q.top(); Q.pop();\n\t//\tcout<<k.l<<\" \"<<k.r<<endl;\n\t\tif (a[k.l]==0){\n\t\t\ta[k.l]=k.r; continue;\n\t\t}\n\t\tif (a[k.l]<k.r) Q.push((atom){a[k.l]+1,k.r});\n\t}\n\t//for (int i=1;i<=n;i++) cout<<a[i]<<\" \"; cout<<endl;\n\tfor (int i=n;i;i--) A[i]=(A[i]-A[i-1]+26)%26;\n\t//for (int i=1;i<=n;i++) cout<<A[i]<<\" \"; cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]==0&&A[i]){\n\t\t\tprintf(\"NO\\n\"); return 0;\n\t\t}\n\t\tint num=A[i];\n\t\tif (num) A[a[i]+1]=(A[a[i]+1]+num+26)%26;\n\t}\n\tprintf(\"YES\\n\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tint m = s.size() / 2;\n\t\tif (l == m && r == m) continue;\n\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t\tif (l >= m) l--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tm = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\twhile (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvector<ll> v;\n\t\t\tfor (auto cur : st[i]) {\n\t\t\t\tv.push_back(cur);\n\t\t\t}\n\t\t\tll vl = v[rand() % v.size()];\n\t\t\tadd[vl + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector <int> V[101010], G[101010], T[101010];\nint K[101010], D[101010], F[101010];\nchar str[101010];\nbool chk[101010];\nint n, m, cnt;\n\nvoid die() { printf(\"NO\\n\"); exit(0); }\n\nvoid dfs(int p)\n{\n\tchk[p] = 1;\n\tK[cnt] = (K[cnt] + D[p]) % 26;\n\tT[cnt].push_back(p);\n\t\n\tfor(int &t: V[p]){\n\t\tif(!chk[t]) dfs(t);\n\t}\n}\n\nint check(int p)\n{\n\tint ret = K[p];\n\tchk[p] = 1;\n\t\n\tfor(int &t: G[p]){\n\t\tif(!chk[t]) ret = (ret + check(t)) % 26;\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint i, a, b, p, k;\n\t\n\tscanf(\"%s\", str);\n\t\n\tn = strlen(str);\n\t\n\tD[0] = str[0] - 'a';\n\tD[n] = (26 + 'a' - str[n-1]) % 26;\n\t\n\tfor(i=1; i<n; i++){\n\t\tD[i] = (26 + str[i] - str[i-1]) % 26;\n\t}\n\t\n\tscanf(\"%d\", &m);\n\t\n\tfor(i=1; i<=m; i++){\n\t\tscanf(\"%d%d\", &a, &b); a --;\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\t\n\tfor(i=0; i<=n; i++){\n\t\tif(!chk[i]){\n\t\t\tcnt ++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\tfor(i=1; i<=cnt; i++){\n\t\tchk[i] = 0;\n\t\t\n\t\tsort(T[i].begin(), T[i].end());\n\t\t\n\t\tfor(int &t: T[i]){\n\t\t\tif((~n & 1) && t == (n >> 1)) continue;\n\t\t\telse if(*lower_bound(T[i].begin(), T[i].end(), n - t) == n - t) continue;\n\t\t\tif(F[n - t]){\n\t\t\t\tG[i].push_back(F[n - t]);\n\t\t\t\tG[F[n - t]].push_back(i);\n\t\t\t}\n\t\t\telse F[t] = i;\n\t\t}\n\t}\n\t\n\tfor(i=1; i<=cnt; i++){\n\t\tif(!chk[i] && check(i)) die();\n\t}\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nusing ui = uint32_t;\n\nconst int maxn = 50100;\nui _q[4000 * maxn];\nui* q[maxn];\nint qmem[maxn];\nint m;\n\nvoid qset(int x, int y, bool val = true) {\n  assert((m - y) / 32 < qmem[x]);\n  q[x][(m - y) / 32] |= (ui(1) << ((m - y) % 32));\n  if (!val) {\n    q[x][(m - y) / 32] ^= (ui(1) << ((m - y) % 32));\n  }\n}\n\nbool qget(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  return q[x][(m - y) / 32] & (ui(1) << ((m - y) % 32));\n}\n\nvoid qor(int x, int y) {\n  assert(x > y);\n  for (int i = 0; i < qmem[x]; ++i) {\n    q[x][i] |= q[y][i];\n  }\n}\n\nint qfind_first(int x) {\n  for (int i = qmem[x] - 1; i >= 0; --i) {\n    if (!q[x][i]) {\n      continue;\n    }\n    for (int j = 31; j >= 0; --j) {\n      int c = m - (i * 32 + j);\n      if (c <= x) {\n        continue;\n      }\n      if (qget(x, c)) {\n        return c;\n      }\n    }\n  }\n  return maxn;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  m = n / 2;\n  int OFF = 0;\n  for (int i = m; i >= 0; --i) {\n    int mem = (m - i + 1 + 31) / 32;\n    q[i] = _q + OFF;\n    qmem[i] = mem;\n    OFF += mem;\n  }\n\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      qset(nl, nr);\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = qfind_first(i);\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      qor(to, i);\n      //q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (y != f[y]) {\n    f[x] = find(y);\n    d[x] = (d[y] + d[x]) % 26;\n  }\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return d[x] == (diff + d[y]) % 26;\n  f[ry] = rx;\n  d[ry] = (d[x] - d[y] + diff) % 26;\n  if (d[ry] < 0) d[ry] += 26;\n  return true;\n}\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[n - 1 - i] - s[i] + 26) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  // for (int i = 0; i < n; ++i) {\n  //   int u = label[i];\n  //   find(u);\n  //   trace(i, u, d[u], (s[i] - 'a' + d[u]) % 26);\n  // }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e6+5;\nint lowbit(int x){return x&(-x);}\nint arr[MAXN];\ninline int sum(int x){int res=0;while(x)res+=arr[x],x-=lowbit(x);return res;}\ninline void add(int x,int n){while(x<MAXN)arr[x]+=n,x+=lowbit(x);}\ninline int update(int x,int y,int n){add(x,n);add(y+1,-n);}\nstruct node{\n    int a,b;\n    bool operator < (const node&p)const{\n        return a==p.a ? b > p.b : a > p.a;\n    }\n};\npriority_queue<node> q;\n\nint f[MAXN];\nstring s;\n//char s[MAXN];\nint a[MAXN];\nint main()\n{\n    memset(f,-1,sizeof f);\n    int x,n,l,r;\n    cin>>s;\n    s=\"0\"+s;\n    //scanf(\"%s\",&s+1);\n    int len = s.length();\n\n    //printf(\"%s\\n\",s);\n    //cout<<s<<endl;\n    //cout<<\"len:\"<<len<<endl;\n    for(int i=1;i<=len/2;i++){\n        update(i,i,s[i] - s[len-i]);\n    }\n    cin>>n;\n    int ll = len / 2;\n    //cout<<\"ll: \"<<ll<<endl;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        //cout<<l<<\"|\"<<r<<endl;\n        if(r <= ll)\n            q.push(node{l,r});\n        else if(l <= ll){\n            //l += ll - l + 1;\n            if(l+r == len)continue;\n            if(abs(ll-l)>abs(r-ll))\n            {\n                q.push(node{l,len-r-1});\n            }\n            else\n                q.push(node{len-r,l-1});\n\n            //q.push(node{ll - max(abs(ll-l),abs(ll-r)), ll - min(abs(ll-l),abs(ll-r))});\n        }\n        else{\n            q.push(node{len-r,len-l});\n        }\n    }\n    /*while(!q.empty()){\n        node now = q.top();\n        //qq.push(now);\n        cout<<now.a<<\"-\"<<now.b<<endl;\n        q.pop();\n    }*/\n    node now,pre = q.top();\n    //qq.push(pre);\n    while(!q.empty()){\n        now = q.top();\n        //cout<<now.a<<\" | \"<<now.b<<endl;\n        if(pre.a < now.a){\n            if(pre.a>0 && pre.b>0)\n            f[pre.a] = pre.b;\n            pre = now;\n            continue;\n        }\n        q.pop();\n        if(pre.b == now.b)continue;\n        else{\n            q.push(node{pre.b+1, now.b});\n        }\n    }\n    f[pre.a] = pre.b;\n    //qq.push(pre);\n    /*while(!qq.empty()){\n        node now = qq.front();\n        qqq.push(now);\n        cout<<now.a<<\" \"<<now.b<<endl;\n        qq.pop();\n    }*/\n    bool flag = 1;\n    if(len%2==0)len--;\n    for(int i=1;i<=len/2;i++){\n\n        //now = qq.front();\n        x = sum(i) - sum(i-1);\n        x%=26;\n        //cout<<\"*\"<<x<<\"  \"<<i<<\" \"<<f[i]<<endl;\n        if(x == 0)continue;\n        if(f[i] != -1){\n            //qq.pop();\n            update(i,f[i], -x);\n        }\n        else{\n            flag = 0;\n            break;\n        }\n        //cout<<\"**\"<<sum(i) - sum(i-1)<<endl;\n    }\n    if(flag)\n        cout<<\"YES\\n\";\n    else\n        cout<<\"NO\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 1e5 + 10;\nvi d;\nvi adj[N];\n\nbool vis[N];\nint dfs(int u) {\n    if (vis[u]) return 0;\n    vis[u] = 1;\n    int res = d[u];\n    for (int v : adj[u]) {\n        res += dfs(v);\n        if (res >= 26) res -= 26;\n    }\n    return res%26;\n}\n\n\nint main() {\n    string s; cin >> s;\n    int len = si(s);\n    s = \"a\" + s + \"a\";\n    d.resize(len+1);\n    forn(i,len+1) d[i] = (int(s[i+1])-s[i]+26)%26;\n    for (int i = 0, j = len; i < j; i++, j--) {\n        adj[i].pb(j);\n        adj[j].pb(i);\n    }\n\n    int n; cin >> n;\n    while (n--) {\n        int l,r; cin >> l >> r; l--;\n        adj[l].pb(r);\n        adj[r].pb(l);\n    }\n\n    bool ok = 1;\n    forn(i,len+1) if (!vis[i]) {\n        auto sum = dfs(i);\n        ok &= sum == 0;\n    }\n    cout << (ok ? \"YES\" : \"NO\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\ntypedef long long LL;\n\nLL fa[100005],siz[100005];\nLL c[100005] = {0},d[100005],m,n;\nLL l[100005],r[100005];\nstring s;\n\nvoid init(){\n\tfor(LL i = 1;i <= (m >> 1);i ++) c[i] = (s[m + 1 - i] - s[i] + 26) % 26;\n//\tfor(LL i = 1;i <= (m >> 1);i ++) cout << c[i] << (i == (m >> 1) ? '\\n' : ' ');\n\tfor(LL i = 0;i <= (m >> 1);i ++) d[i + 1] = (c[i + 1] - c[i] + 26) % 26;\n\tfor(LL i = 1;i <= (m >> 1) + 1;i ++){\n\t\tfa[i] = i;\n\t\tsiz[i] = d[i];\n\t}\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(l[i] > (m >> 1) && r[i] > (m >> 1)){\n\t\t\tswap(l[i],r[i]);\n\t\t\tl[i] = m + 1 - l[i];\n\t\t\tr[i] = m + 1 - r[i];\n\t\t}\n\t\telse if(r[i] > (m >> 1)){\n\t\t\tLL tor = m + 1 - r[i];\n\t\t\tif(tor < l[i]){\n\t\t\t\tr[i] = l[i] - 1;\n\t\t\t\tl[i] = tor;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr[i] = tor - 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nLL getf(LL x){\n\tif(fa[x] == x) return x;\n\treturn fa[x] = getf(fa[x]);\n}\n\nvoid unionn(LL x,LL y){\n\tx = getf(x); y = getf(y);\n\tif(x == y) return;\n\tfa[x] = y; siz[y] += siz[x];\n}\n\nint main(){\n\tcin >> s; cin >> n;\n\tfor(LL i = 1;i <= n;i ++) cin >> l[i] >> r[i];\n\tm = s.length(); s = ' ' + s;\n\tinit();\n\t\n//\tfor(LL i = 1;i <= (m >> 1) + 1;i ++) cout << d[i] << ' '; cout << endl;\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tr[i] ++;\n\t\tunionn(l[i],r[i]);\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(siz[fa[i]] % 26){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n//         cout << mid1 << ' ' << mid2 << ' ' << l << ' ' << r << endl;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            tie(l, r) = make_pair(min(max(-1, mid1 - l), max(-1, r - mid2)) + 1, max(max(-1, mid1 - l), max(-1, r - mid2)));\n//             l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n//             r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[mid1 - i] - s[mid2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= minr) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            deladd[minr + 1] %= 26;\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nsigned main(){\n\tstring s;\n\tcin>>s;\n\ts=\"a\"+s+\"a\";\n\tint n=s.size()-1;\n\tvi t(n);\n\trep(i,n)t[i]=(26+s[i+1]-s[i])%26;\n\tUnionFind uf(n);\n\trep(i,n)uf.unionSet(i,n-i-1);\n\tint m;\n\tcin>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tuf.unionSet(a-1,b);\n\t}\n\tvi sum(n);\n\trep(i,n)sum[uf.root(i)]+=t[i];\n\tbool h=true;\n\trep(i,n)if(sum[i]%26)h=false;\n\tif(h)cout<<\"YES\"<<endl;\n\telse cout<<\"NO\"<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include<bits/stdc++.h>\n//#include<cstdio>\n//#include<iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n//#include<string>//\"reverse(s's it,s's it)\"\n//#include<functional>//\"greater<T>\" \"sort(a,a+n,greater<int>());\"\"\n//#include<cmath>//\"abs\" \"sqrt\"\n//#include<numeric>//\"accumulate(inputit,inputit,init,(optional) object)\"\n//#include<algorithm>//\"lower_bound(it,it,v)\" \"next_permutation(a,a+n)\"\n//\"reverse(v's it,v's it)\"(v: vector)\n//#include<cassert>//\"assert(cond);\": error if cond doesn't hold.\nusing namespace std;\n#define pb push_back//also for STRING\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert//also use as v.is(v's it,w's it,w's it);\n#define ps push//TMP//stack,(priority) queue,\n#define fr front//TMP//queue//for priority, use top().\ntypedef long long ll;//not necessarily\ntypedef pair<int,int> pii;\n//Add other types in the same way.\n\nstruct unionfind{\n\tvector<int> par,rk;\n\n\tunionfind(const int n){\n\t\tpar.resize(n);\n\t\trk.resize(n);\n\t\tfor(int i=0;i<n;++i) par[i]=i;\n\t\tfill(rk.begin(),rk.end(),0);\n\t}\n\n\tint find(int x){\n\t\tif(par[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y){\n\t\t\treturn;\n\t\t}else if(rk[x]<rk[y]){\n\t\t\tpar[x]=y;\n\t\t}else{\n\t\t\tpar[y]=x;\n\t\t\tif(rk[x]==rk[y]){\n\t\t\t\t++rk[x];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\n\n#define MAX 100000\n\nint main(){\n\tint a[MAX+2],sm[MAX+2];\n\tstring s;\n\tcin>>s;\n\ts=\"a\"+s;\n\ts+=\"a\";\n\t//cout<<s<<endl;\n\tconst int m=s.size()-1;\n\tfor(int i=0;i<m;++i) a[i]=s[i+1]-s[i];\n\t//for(int i=0;i<m;++i) printf(\"i=%d, a[i]=%d\\n\",i,a[i]);\n\tunionfind u(m);\n\tfor(int i=0;i<m-1-i;++i) u.unite(i,m-1-i);\n\tint n;\n\tcin>>n;\n\twhile((n--)>0){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tu.unite(l-1,r);\n\t}\n\tfill(sm,sm+m,0);\n\tfor(int i=0;i<m;++i){\n//\t\tprintf(\"i=%d,grp is %d\\n\",i,u.find(i));\n\t\tsm[u.find(i)]+=a[i];\n\t}\n\tfor(int i=0;i<m;++i) if(sm[i]%26!=0){\n\t\tcout<<\"NO\"<<endl;\n\t\treturn 0;\n\t}\n\tcout<<\"YES\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint n,q,l,r,pset[100007];\nint it[400007];\nset <int> query[100007];\nvoid upd(int k,int l,int r,int L,int R,int val){\n\tif(l>R || r<L || L>R) return;\n\tif(l>=L && r<=R){\n\t\tit[k]+=val;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tupd(k*2,l,mid,L,R,val);\n\tupd(k*2+1,mid+1,r,L,R,val);\n}\nint get(int k,int l,int r,int pos){\n\tif(l==r && l==pos) return it[k];\n\tint mid=(l+r)/2;\n\tif(pos<=mid) return it[k]+get(k*2,l,mid,pos);\n\telse return it[k]+get(k*2+1,mid+1,r,pos);\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>s;\n\tn=(int)s.length();\n\tcin>>q;\n\tfor(int i=1;i<=q;i++){\n\t\tcin>>l>>r;\n\t\tif(l<=(n+1)/2 && r>=(n+1)/2){\n\t\t\tr=n-r+1;\n\t\t\tif(l>r) swap(l,r);\n\t\t\tif(l==r) continue;\n\t\t\tr--;\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse if(l<=(n+1)/2){\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse{\n\t\t\tquery[n-r+1].insert(n-l+1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) pset[i]=i;\n\tfor(int i=1;i<=n/2;i++){\n\t\t//cout<<(s[i-1]-s[n-i]+26)%26<<endl;\n\t\tint cal=((s[i-1]-s[n-i]+26)%26-get(1,1,n,i)+26)%26;\n\t\t//cout<<i<<\" \"<<cal<<endl;\n\t\tif(cal!=0 && query[pset[i]].empty()){\n\t\t\tcout<<\"NO\";\n\t\t\treturn 0;\n\t\t}\n\t\tif(i==n/2) continue;\n\t\tif(!query[pset[i]].empty()){\n\t\t\tint cur=pset[i];\n\t\t\tauto it=query[cur].begin();\n\t\t\tint x=*it;\n\t\t\tquery[cur].erase(it);\n\t\t\tupd(1,1,n,i,x,cal);\n\t\t\tint nxt=pset[x+1];\n\t\t\tif(query[cur].size()<query[nxt].size()){\n\t\t\t\tpset[i]=nxt;\n\t\t\t\tfor(auto jt=query[cur].begin();jt!=query[cur].end();jt++){\n\t\t\t\t\tquery[nxt].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpset[x+1]=cur;\n\t\t\t\tfor(auto jt=query[nxt].begin();jt!=query[nxt].end();jt++){\n\t\t\t\t\tquery[cur].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define fi first\n#define se second\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define FORW(a, b, c) for(int a = b; a >= c; --a)\n#define pb push_back\n#define SZ(a) ((int)a.size())\n#define int long long\n//#define TEST\n \nconst int oo = 1e9;\nconst int Maxn = 1e6;\nconst int N = 1e5 + 100;\nconst double PI = (-2.00) * asin(-1);\n \ntypedef pair<int, pair<int, int> > iii;\n\nstruct Dict {\n    int pr, sum;\n    Dict(int pr = 0, int sum = 0) : pr(pr), sum(sum) {\n        // add some commands if necessary here\n        // such as assign or something similar\n    } \n}id[N];\n\nstring s;\nint n, m;\nint L[N], R[N], tmpArr[N];\n\n// 0 = A\n// 1 = B\n\nint find(int u) { return (id[u].pr == u) ? u : (id[u].pr = find(id[u].pr)); }\n\nvoid merge(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if(u == v) return;\n    id[u].sum += id[v].sum;\n    id[v].pr = u;\n}\n\nsigned main()\n{\n    #ifdef TEST\n        freopen(\"test.inp\", \"r\", stdin);\n    #endif // TEST  \n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> s; m = s.length();\n    cin >> n;\n    FOR(i, 1, n) cin >> L[i] >> R[i];\n\n    tmpArr[1] = 0 - (s[0] - 'a');\n    FOR(i, 2, m) tmpArr[i] = s[i - 2] - 'a' - (s[i - 1] - 'a');\n    tmpArr[m + 1] = s[m - 1] - 'a';\n\n    FOR(i, 1, m + 1) id[i] = {i, tmpArr[i]};\n    FOR(i, 1, (m + 1) / 2) merge(i, (m + 1) - i + 1);\n    FOR(i, 1, n) merge(L[i], R[i] + 1);\n\n    bool flag = 1;\n    FOR(i, 1, m + 1) {\n        int pu = find(i);\n        if(id[pu].sum % 26 != 0) return cout << \"NO\", 0;\n    }\n    cout << \"YES\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]==kk);\n\t\t\telse if(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i] = a[i+1]-a[i];\n\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t}\n\tbool f = true;\n\tvector<vector<int> > v(n2+1);\n\trep(i, n2+1) v[uf.find(i)].push_back(i);\n\trep(i, n2){\n\t\tif(v[i].empty()) continue;\n\t\tll x = 0;\n\t\tbool g = false;\n\t\trep(j, v[i].size()){\n\t\t\tx += t[v[i][j]];\n\t\t\tif(v[i][j]==n2) g = true;\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nstring s;\nint n, l[N], r[N], a[N];\n\nstruct Dsu {\n    int pset[N], szset[N], val[N];\n    void init() {\n        for (int i = 0; i < N; ++i) pset[i] = i, szset[i] = 1, val[i] = a[i];\n    }\n    int findset(int i) { return i == pset[i] ? i : pset[i] = findset(pset[i]); }\n    bool sameset(int i, int j) { return findset(i) == findset(j); }\n    void unionset(int i, int j) {\n        if(sameset(i, j) ) return ;\n        i = findset(i); j = findset(j);\n        if(szset[i] > szset[j]) swap(i, j);\n        val[j] = (val[i] + val[j]) % 26;\n        szset[j] += szset[i];\n        pset[i] = j;\n    }\n} dsu;\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> s >> n;\n    s = 'a' + s; s += 'a';\n    for (int i = 1; i <= n; ++i) cin >> l[i] >> r[i];\n    for (int i = 0; i < s.size() - 1; ++i) a[i] = (s[i + 1] - s[i] + 26) % 26;\n\n    dsu.init();\n    for (int i = 1; i <= n; ++i) {\n        dsu.unionset(l[i] - 1, r[i]);\n    }\n    for (int i = 0; i < s.size() - 1; ++i) dsu.unionset(i, s.size() - 2 - i);\n\n    for (int i = 0; i < N; ++i) if(dsu.val[dsu.findset(i)]) return cout << \"NO\", 0;\n\n    cout << \"YES\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,LL>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A;\n\t\tA = A * A;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, 0}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tLL total4 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(7703, id);\n\t\t\tLL po3 = fast(1277, id);\n\t\t\tLL po4 = fast(2927, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3, total4 += po4;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total3 -= po3, total4 += po4;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, total3}) == ms.end()) ms[{total, total3}] = i;\n\t\tpar[i] = ms[{total, total3}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) {string s; ist >> s; return ist;}\nbool Inside(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* E mondai*/\n\nstring s;\nint N;\nint L[100000], R[100000];\nvector<IntMod<26>> ss;\n\nvoid Add(int i, int j, IntMod<26> val) {\n\tss[i] += val;\n\tss[j] -= val;\n}\n\nint main() {\n\tcin >> s >> N;\n\tREP(i, 0, N) {\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t\tif (L[i] > s.size() / 2) L[i] = s.size() - L[i];\n\t\tif (R[i] > s.size() / 2) R[i] = s.size() - R[i];\n\t\tif (L[i] > R[i]) swap(L[i], R[i]);\n\t}\n\n\tREP(i, 0, s.size() / 2) {\n\t\tss.push_back(s[s.size() - i - 1] - s[i]);\n\t}\n\tss.push_back(0);\n\tadjacent_difference(ss.begin(), ss.end(), ss.begin());\n\n\tmap<int, vector<int>> m;\n\tREP(i, 0, N) {\n\t\tm[L[i]].push_back(R[i]);\n\t}\n\n\tPriorityQ<PP> Q;\n\tfor(auto&& p : m){\n\t\tvector<int>& v = p.second;\n\t\tsort(v.begin(), v.end());\n\t\tQ.push(PP(p.first, v[0]));\n\t\tREP(i, 0, v.size() - 1) {\n\t\t\tQ.push(PP(v[i], v[i + 1]));\n\t\t}\n\t}\n\n\tPP prev(-1, 0);\n\twhile (!Q.empty()) {\n\t\tPP p = Q.top(); Q.pop();\n\t\tif (p.first == p.second) continue;\n\t\tif (prev.first == p.first) {\n\t\t\tQ.push(PP(prev.second, p.second));\n\t\t\tcontinue;\n\t\t}\n\t\tAdd(p.first, p.second, -ss[p.first]);\n\t\tprev = p;\n\t}\n\tYESNO(all_of(ss.begin(), ss.end(), [](IntMod<26> i) {return i == 0; }));\n\treturn 0;\n}\n\n/*-------------------------*/\n/*-----    二分探索   -----*/\n/*-------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\nint faster_in(){int r=0,c;for(c=getchar();c<=32;c=getchar());if(c=='-') return -faster_in();for(;c>32;r=(r<<1)+(r<<3)+c-'0',c=getchar());return r;}\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<int, int>  ii;\ntypedef vector<int>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst int INF = int(1e9 + 7);\n\nconst int tam = 100010;\n\nvector<int> G[tam];\nint val[tam];\nbool vis[tam];\n\nint sum;\nvoid dfs(int v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (int u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    s = \"a\" + s + \"a\";\n/*\n    cout << s << endl;\n\tfor (int i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n*/\n    for (int i = 0; i < n; i++)\n    {\n    \tval[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \tval[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = false;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!!"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define pb push_back\n# define fr first\n# define sc second\n# define mk make_pair\n\nusing namespace std;\n\nconst int inf = 1e9 + 7;\nconst int N = 1e6 + 5;\n\ntypedef long long ll;\n\nstring s;\nint n, l[N], r[N], a[N], b[N], mid, sz;\nint aa[N], ab[N];\n\nint main()\n{\n      cin >> s;\n\n      sz = s.size();\n      s = ' ' + s;\n\n      cin >> n;\n\n      for(int i = 1; i <= n; i ++)\n      {\n            cin >> l[i] >> r[i];\n            if(l[i] > ((sz + 1) / 2)) continue;\n            if(r[i] <= ((sz + 1) / 2)) continue;\n            if(l[i] == (sz - r[i] + 1))\n            {\n                  l[i] = r[i] = 0;\n                  continue;\n            }\n            if(l[i] > (sz - r[i] + 1))\n                  l[i] = sz - (l[i] - 1) + 1;\n            else\n                  r[i] = (sz - r[i] + 1) - 1;\n      }\n\n      for(int i = 1; i <= n; i ++)\n      {\n            if(r[i] <= (sz + 1) / 2)\n                  a[i] = 1;\n            else\n            {\n                  a[i] = -1;\n                  int dd = r[i];\n                  r[i] = sz - l[i] + 1;\n                  l[i] = sz - dd + 1;\n            }\n      }\n\n      for(int i = 1; i <= sz / 2; i ++)\n            b[i] =s[i] - s[sz - i + 1];\n\n      for(int i = 1; i <= n; i ++)\n      {\n            if(a[i] == 1)\n                  aa[l[i]] ++, aa[r[i] + 1] --;\n            else\n                  ab[l[i]] ++, ab[r[i] + 1] --;\n      }\n\n      for(int i = 1; i <= sz / 2; i ++)\n            aa[i] += aa[i - 1], ab[i] += ab[i - 1];\n\n      for(int i = 1; i <= sz / 2; i ++)\n      {\n            if(!aa[i] && !ab[i] && b[i])\n            {\n                  cout << \"NO\" << endl;\n                  return 0;\n            }\n      }\n\n      cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,pair<LL,LL> >, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nconst LL MOD =  1e9 + 7;\nconst LL MOD2 = 1e9 + 9;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\tLL init = A;\n\twhile(B) {\n\t\tif(init != 13) {\n\t\t\tif(B & 1) res = res * A % MOD;\n\t\t\tA = A * A % MOD;\n\t\t\tB /= 2;\t\t\t\n\t\t} else {\n\t\t\tif(B & 1) res = res * A % MOD2;\n\t\t\tA = A * A % MOD2;\n\t\t\tB /= 2;\t\t\t\t\t\t\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, {0, 0}}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tLL total4 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(3, id);\n\t\t\tLL po3 = fast(13, id);\n\t\t\tLL po4 = fast(2927, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3, total4 += po4;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total3 -= po3, total4 += po4;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, {total3, total4}}) == ms.end()) ms[{total, {total3, total4}}] = i;\n\t\tpar[i] = ms[{total, {total3, total4}}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nint f[N];\nint ss[N];\nchar str[N];\nint get(int k)\n{\n    return k == f[k] ? k : f[k] = get(f[k]);\n}\nint main(void)\n{\n    cin>>(str + 1);\n    int n = strlen(str + 1);\n    str[0] = str[++n] = 'a';\n    for (int i = 1;i <= n;++i)\n        ss[i] = str[i] - str[i - 1],f[i] = i;\n    for (int i = 1;i+i <= n;++i)\n    {\n        f[n - i + 1] = i;\n        ss[i] += ss[n - i + 1];\n    }\n    int m;\n    cin>>m;\n    while (m --)\n    {\n        int l,r;\n        cin>>l>>r;\n        ++r;\n        l = get(l);r = get(r);\n        if (l == r) continue;\n        f[r] = l;\n        ss[l] += ss[r];\n    }\n    for (int i = 1;i <= n;++i)\n        if ((ss[i] % 26) && i == get(i))\n            return puts(\"NO\") * 0;\n    puts(\"YES\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstring st;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {  cin >> st;\n\tbool flag = false;\n\tif (st.size() % 2) {\n\t\tst.erase(st.begin() + st.size() / 2);\n\t\tflag = true;\n\t}\n\tassert(st.size() % 2 == 0);\n\tint N; cin >> N;\n\tvector<int>nums(st.size() + 1);\n\tnums[0] = st[0] - 'a';\n\tfor (int i = 1; i < st.size(); ++i) {\n\t\tnums[i] = (26+st[i] - st[i - 1])%26;\n\t}\n\tnums[st.size()] = 26 - (st[st.size() - 1]-'a');\n\tvector<pair<int, int>>edges;\n\tvector<long long int>nodes(st.size() + 1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint l, r; cin >> l >> r;\n\t\tl--;\n\t\tif (flag) {\n\t\t\tif (l > st.size() / 2) {\n\t\t\t\tl--;\n\t\t\t}\n\t\t\tif (r>st.size()/2) {\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t\tif (l > st.size()/2) {\n\t\t\tl = st.size() - l;\n\t\t}\n\t\tif(r>st.size()/2){\n\t\t\tr = st.size() - r;\n\t\t}\n\t\tedges.push_back(make_pair(l, r));\n\t}\n\tvector<int>flags(st.size() / 2 + 1);\n\n\tUnionFind uf(st.size() / 2 + 1);\n\tfor (auto e : edges) {\n\t\tif (e.first == e.second)flags[e.first] = true;\n\t\telse {\n\t\t\tuf.unionSet(e.first, e.second);\n\t\t}\n\n\t}\n\tfor (int i = 0; i < st.size() / 2; ++i) {\n\t\tnums[i] += nums[st.size() - i];\n\t}\n\tset<int>roots;\n\tmap<int, pair<long long int, bool>>mp;\n\tvector<long long int >sums(st.size() / 2 + 1);\n\tfor (int i = 0; i < st.size() / 2 + 1; ++i) {\n\t\tmp[uf.root(i)].first += nums[i];\n\t\tif (flags[i])mp[uf.root(i)].second = true;\n\t}\n\tbool ok = true;\n\tfor (auto m : mp) {\n\t\tm.second.first %= 26;\n\t\tif (m.second.second) {\n\t\t\tif (m.second.first % 2)ok = false;\n\t\t}\n\t\telse {\n\t\t\tif (m.second.first)ok = false;\n\t\t}\n\t}\n\tif (ok)cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, q;\nstring s;\nint l[N], r[N], f[N], par[N];\n\nint anc(int u) { return par[u] == u ? u : par[u] = anc(par[u]); }\nvoid join(int u,int v) {\n\tu = anc(u), v = anc(v);\n\tif (u == v) return;\n\tpar[v] = u; f[u] += f[v];\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> s >> q; n = s.size(); s = '~' + s;\n\tfor (int i = 1; i <= q; ++i) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (r[i] < n + 1 - r[i]) continue;\n\t\telse if (l[i] > n + 1 - l[i]) {\n\t\t\tl[i] = n + 1 - l[i];\n\t\t\tr[i] = n + 1 - r[i];\n\t\t\tswap(l[i], r[i]);\n\t\t}\n\t\telse {\n\t\t\tr[i] = n + 1 - r[i];\n\t\t\tif (l[i] <= r[i]) r[i]--;\n\t\t\telse l[i]--, swap(l[i], r[i]);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n / 2; ++i) f[i] = s[n + 1 - i] - s[i];\n\tfor (int i = n / 2 + 1; i >= 1; --i) f[i] -= f[i - 1], par[i] = i;\n\tfor (int i = 1; i <= q; ++i) join(l[i], r[i] + 1);\n\tfor (int i = 1; i <= n / 2; ++i) if (anc(i) == i) {\n\t\tif (f[i] % 26) return cout << \"NO\" << '\\n',0;\n\t}\n\tcout << \"YES\" << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nint main(){\n  char s[SIZE];\n  int n,m;\n  int l[SIZE],r[SIZE];\n  vector<int> cc[SIZE];\n  \n  scanf(\"%s%d\",s,&m);\n  n = strlen(s);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",l+i,r+i);\n    l[i]--; r[i]--;\n    \n    if(n%2 == 0){\n      if(l[i] <= n/2-1 && n/2 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - (n/2 - 1);\n        \n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if (a > b){\n          l[i] = n/2 - a;\n          r[i] = n/2 - b - 1;\n        }else{\n          l[i] = n/2 - b;\n          r[i] = n/2 - a - 1;\n        }\n      }\n    }else{\n      if(l[i] == r[i] && l[i] == n/2){\n        l[i] = -1; r[i] = -1;\n      }else if(l[i] == n/2){\n        l[i] += 1;\n      }else if(r[i] == n/2){\n        r[i] -= 1;\n      }else if(l[i] <= n/2-1 && n/2+1 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - n/2;\n\n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if(a > b){\n          l[i] = n/2-1 - a;\n          r[i] = n/2-1 - b - 1;\n        }else{\n          l[i] = n/2-1 - b;\n          r[i] = n/2-1 - a - 1;\n        }\n      }\n    }\n\n    if(l[i] != -1){\n      if((n+1)/2 <= l[i]){\n        l[i] = n - l[i] - 1;\n        r[i] = n - r[i] - 1;\n        swap(l[i], r[i]);\n      }\n\n      assert(l[i] < n/2 && r[i] < n/2);\n      cc[l[i]].push_back(r[i]);\n    }\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size() > 1)\n      sort(cc[i].begin(),cc[i].end());\n\n    for(int j=cc[i].size()-2;j>=0;j--){\n      if(cc[i][j] != cc[i][j+1])\n        cc[cc[i][j]+1].push_back(cc[i][j+1]);\n    }\n  }\n\n  SegTree seg(n);\n  \n  for(int i=0;i<n/2;i++){\n    seg.add(i, i, 26 + s[n-i-1] - s[i]);\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size()){\n      int q = seg.query(i,i);\n      seg.add(i, cc[i][0], 26-q%26);\n    }\n\n    if(seg.query(i,i)%26 != 0){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n\n  puts(\"YES\");\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]==kk);\n\t\t\telse if(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i] = a[i+1]-a[i];\n\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t}\n\tbool f = true;\n\tvector<vector<int> > v(n2+1);\n\trep(i, n2+1) v[uf.find(i)].push_back(i);\n\trep(i, n2){\n\t\tif(v[i].empty()) continue;\n\t\tll x = 0;\n\t\tbool g = false;\n\t\trep(j, v[i].size()){\n\t\t\tx += t[v[i][j]];\n\t\t\tif(v[i][j]==n2) g = true;\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  for(int i = 0; i < st.size(); i++) {\n\n    map< int, int > mp;\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(mp.count(ind[other])) {\n          if((S[other] - S[idx] + 26) % 26 != mp[ind[other]]) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        } else {\n          mp[ind[other]] = (S[other] - S[idx] + 26) % 26;\n        }\n      }\n    }\n\n  }\n\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=400002;\nint n,m,i,a,b,c[N],vis[N],sum,tmp;\nchar s[N];\nvector<int>e[N];\nvoid Link(int x,int y){\n\te[x].push_back(y);\n\te[y].push_back(x);\n}\nvoid init(){\n\tscanf(\"%s%d\",s+1,&m);\n\tn=strlen(s+1);\n\tfor(i=0;i<=n;i++)\n\t\tc[i]=s[i+1]-s[i];\n\tfor(i=0;i<n-i;i++)\n\t\tLink(i,n-i);\n\twhile(m--){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tLink(a-1,b);\n\t}\t\n}\nvoid dfs(int i){\n\tvis[i]=1;\n\tsum+=c[i];\n\tfor(int j=0;j<e[i].size();j++)\n\t\tif(!vis[e[i][j]])\n\t\t\tdfs(e[i][j]);\n}\nvoid work(){\n\ttmp=1;\n\tdfs(0);\n\tsum=0;\n\tfor(i=1;i<n;i++)\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t\tif(sum%26)\n\t\t\t\ttmp=0;\n\t\t}\n\tprintf(\"%s\\n\",tmp?\"YES\":\"NO\");\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nchar S_[101010];\nint N, L[101010], R[101010];\nint S[101010];\nint D[101010];\n\nconst int W = 26;\n\nint uf[101010];\nint root(int p)\n{\n\treturn uf[p] < 0 ? p : (uf[p] = root(uf[p]));\n}\nvoid join(int p, int q)\n{\n\tp = root(p); q = root(q);\n\tif (p == q) return;\n\tuf[p] += uf[q];\n\tuf[q] = p;\n}\n\nvector<int> grps[101010];\n\nstruct data\n{\n\tint sum;\n\tset<int> *pos, *neg;\n\n\tint toppos() const {\n\t\tif (pos->empty()) return 1000000;\n\t\treturn *(pos->begin());\n\t}\n\tint topneg() const {\n\t\tif (neg->empty()) return 1000000;\n\t\treturn *(neg->begin());\n\t}\n\tint top() const {\n\t\treturn min(toppos(), topneg());\n\t}\n\tint size() const {\n\t\treturn pos->size() + neg->size();\n\t}\n\tbool isneg() const {\n\t\tint a = toppos();\n\t\tint b = topneg();\n\t\treturn a > b;\n\t}\n\tdata(int sum, set<int> *pos, set<int> *neg) : sum(sum), pos(pos), neg(neg) {}\n};\n\ninline bool operator<(const data& a, const data& b) {\n\treturn a.top() < b.top() || (a.top() == b.top() && (i64)a.pos < (i64)b.pos);\n}\n\nset<data> eqs;\n\nvoid waf(set<int> *pos, set<int> *neg, int v)\n{\n\t// add v as positive\n\tif (neg->count(v)) {\n\t\tneg->erase(v);\n\t} else {\n\t\tpos->insert(v);\n\t}\n}\n\ndata mgr(data a, data b)\n{\n\tif (a.size() < b.size()) swap(a, b);\n\tbool an = a.isneg(), bn = b.isneg();\n\tbool neg = an == bn;\n\tif (neg) {\n\t\ta.sum = (a.sum + W - b.sum) % W;\n\t\tfor (int p : *b.neg) {\n\t\t\twaf(a.pos, a.neg, p);\n\t\t}\n\t\tfor (int p : *b.pos) {\n\t\t\twaf(a.neg, a.pos, p);\n\t\t}\n\t} else {\n\t\ta.sum = (a.sum + b.sum) % W;\n\t\tfor (int p : *b.pos) {\n\t\t\twaf(a.pos, a.neg, p);\n\t\t}\n\t\tfor (int p : *b.neg) {\n\t\t\twaf(a.neg, a.pos, p);\n\t\t}\n\t}\n\treturn a;\n}\n\nvoid show(const data& d) {\n\tprintf(\"s=%d pos=\", d.sum);\n\tfor (int p : *d.pos) printf(\"%d,\", p);\n\tprintf(\" neg=\");\n\tfor (int p : *d.neg) printf(\"%d,\", p);\n\tputs(\"\");\n}\n\nint main()\n{\n\tscanf(\"%s%d\", S_, &N);\n\tint M = strlen(S_);\n\tfor (int i = 0; i < M + 3; ++i) uf[i] = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\t--L[i];\n\n\t\tjoin(L[i], R[i]);\n\t}\n\tS[0] = S[M + 2] = 0;\n\tfor (int i = 0; i < M; ++i) S[i + 1] = S_[i] - 'a';\n\n\tfor (int i = 0; i <= M; ++i) {\n\t\tD[i] = (S[i + 1] - S[i] + W) % W;\n\t}\n\tM += 1;\n\tfor (int i = 0; i < M; ++i) {\n\t//\tprintf(\"%d\\n\", D[i]);\n\t\tgrps[root(i)].push_back(i);\n\t}\n\tfor (int i = 0; i < M; ++i) if (grps[i].size() > 0) {\n\t\tint sum = 0;\n\t\tset<int> *pos = new set<int>, *neg = new set<int>;\n\t\tfor (int p : grps[i]) {\n\t\t\tif (p * 2 + 1 == M) {\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p >= M / 2) {\n\t\t\t\twaf(neg, pos, M - 1 - p);\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaf(pos, neg, p);\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t}\n\t\t}\n\t//\tshow(data(sum, pos, neg));\n\t\teqs.insert(data(sum, pos, neg));\n\t}\n\twhile (!eqs.empty()) {\n\t\tdata top = *(eqs.begin());\n\t\teqs.erase(eqs.begin());\n\n\t\tif (top.top() == 1000000) {\n\t\t\tif (top.sum != 0) {\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (eqs.empty()) break;\n\n\t\tif (eqs.begin()->top() != top.top()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata top2 = *(eqs.begin());\n\t\teqs.erase(eqs.begin());\n\t\tdata nw = mgr(top, top2);\n\t\teqs.insert(nw);\n\t}\n\n\tputs(\"YES\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[101000];\nint l,n,T,a[101000],x,y,used[101000];\nvector<int>G[55555];\n\nint dfs(int x){\n\tused[x]=1;\n\tint res=a[x];\n\tfor (auto y:G[x]) if (!used[y])\n\t\tres+=dfs(y);\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%s\",s+1); l=strlen(s+1); n=l>>1;\n\tfor (int i=1;i<=n;++i) a[i]=s[i]-s[l-i+1];\n\tfor (int i=n+1;i;--i) a[i]-=a[i-1];\n\tfor (cin>>T;T--;){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>n){\n\t\t\tx=l+1-x;\n\t\t\ty=l+1-y;\n\t\t\tswap(x,y);\n\t\t}else if (y>n){\n\t\t\ty=l+1-y;\n\t\t\tif (x>y) swap(x,y);\n\t\t\t--y;\n\t\t}\n\t\tif (x>n||x>y) continue;\n\t\ty=min(y,n);\n\t\tG[x].push_back(y+1);\n\t\tG[y+1].push_back(x);\n\t}\n\tfor (int i=1;i<=n+1;++i) if (!used[i]){\n\t\tif (dfs(i)%26) return !puts(\"NO\");\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <math.h>\n#include <set>\n#include <iomanip>\n#include <time.h>\n#include <list>\n#include <stdio.h>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <assert.h>\n#include <memory.h>\n\n#define mk make_pair\n#define sc second\n#define fr first\n#define pb emplace_back\n#define all(s) s.begin(), s.end()\n#define sz(s) ( (int)s.size() )\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nchar s[N];\n\nint n, ar[N], sz[N], p[N], sum[N];\n\nint get (int v)\n{\n    return v == p[v] ? v : p[v] = get(p[v]);\n}\n\nvoid unite (int a, int b)\n{\n    a = get(a);\n    b = get(b);\n\n    if (a == b) return;\n\n    if (sz[a] > sz[b])\n        swap(a, b);\n\n    sum[b] += sum[a];\n    sum[b] %= 26;\n\n    sz[b] += sz[a];\n    p[a] = b;\n}\n\nmain ()\n{\n    scanf(\"%s\", s + 1);\n    s[0] = 'a';\n    n = strlen(s);\n    s[n] = 'a';\n    for (int i = 0; i < n; i++)\n    {\n        sz[i] = 1;\n        p[i] = i;\n\n        ar[i] = s[i + 1] - s[i];\n\n        if (ar[i] < 0)\n            ar[i] += 26;\n\n        sum[i] = ar[i];\n    }\n    for (int i = 0; i < n; i++)\n        unite(i, n - i - 1);\n\n    int m, a, b;\n    cin >> m;\n    while (m--)\n    {\n        scanf(\"%d%d\", &a, &b);\n        unite(a - 1, b);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] == i && sum[i] != 0)\n        {\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tint m = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk[N];\nll ha[N];\nint len;\n\nbool check(ll K)\n{\n    for (int i = 0; i < N / 2; i++) ha[i] = 0;\n    degk[0] = 1;\n    for (int i = 1; i < N; i++) degk[i] = degk[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degk[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degk[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    //for (int i = 0; i < len; i++) cout << x[i] << \" \"; cout << \"\\n\";\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) return 0;\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) return 0;\n    return 1;\n}\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    if (check(2)) cout << \"YES\\n\", exit(0);\n    if (check(3)) cout << \"YES\\n\", exit(0);\n    if (check(5)) cout << \"YES\\n\", exit(0);\n    else cout << \"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk[N];\nll ha[N];\nint len;\n\nbool check(ll K)\n{\n    for (int i = 0; i < N / 2; i++) ha[i] = 0;\n    degk[0] = 1;\n    for (int i = 1; i < N; i++) degk[i] = degk[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degk[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degk[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    //for (int i = 0; i < len; i++) cout << x[i] << \" \"; cout << \"\\n\";\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) return 0;\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) return 0;\n    return 1;\n}\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    if (check(2)) cout << \"YES\\n\";\n    if (check(3)) cout << \"YES\\n\";\n    if (check(5)) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nconst int N=1e5+10;\nchar s[N];\nint n,f[N],a[N],sum[N];\nint find(int x){\n\treturn x==f[x]?x:f[x]=find(f[x]);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&n);\n\tint m=strlen(s+1);\n\tfor(int i=1;i<=m+1;i++){\n\t\ta[i]=s[i]-s[i-1];\n\t\tf[i]=i;\n\t}\n\tfor(int i=1;i<=m+1;i++)\n\t\tf[find(i)]=find(m+1-i+1);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tf[find(l)]=find(r+1);\n\t}\n\tfor(int i=1;i<=m+1;i++)\n\t\tsum[find(i)]=(sum[find(i)]+a[i]%26+26)%26;\n\t\n\tint flag=1;\n\tfor(int i=1;i<=m+1&&flag;i++){\n\t\tif(sum[find(i)])flag=0;\n\t}\n\t\t\n\tif(flag)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint gcd(int x, int y) {\n    while (1) {\n\tif (x) y %= x; else return y;\n\tif (y) x %= y; else return x;\n    }\n}\nint lcm(int x, int y) {\n    return x / gcd(x, y) * y;\n}\n\nint N;\nchar S[100011];\nint L[100011], R[100011];\nint La[100011], Ra[100011];\nint D[100011];\nVI G[100011];\n\nvoid MAIN() {\n    scanf(\"%s%d\", S, &N);\n    int LEN = strlen(S);\n    REP (i, N) scanf(\"%d%d\", L+i, R+i), L[i]--;\n\n    int M = LEN/2;\n    REP (i, LEN-1) {\n\tint d = (int)S[i+1] - (int)S[i];\n\tif (i*2+2 == LEN) {\n\t    D[i] += d+d;\n\t} else if (i >= M) {\n\t    D[LEN-2-i] += d;\n\t} else {\n\t    D[i] += d;\n\t}\n    }\n\n    REP (i, N) {\n\tL[i]--;\n\tLa[i] = 1;\n\n\tR[i]--;\n\tRa[i] = -1;\n\n\tif (M <= L[i]) {\n\t    L[i] = LEN-2-L[i];\n\t    La[i] = -La[i];\n\t}\n\tif (L[i]*2+2 == LEN) La[i] += La[i];\n\n\tif (M <= R[i]) {\n\t    R[i] = LEN-2-R[i];\n\t    Ra[i] = -Ra[i];\n\t}\n\tif (R[i]*2+2 == LEN) Ra[i] += Ra[i];\n\n\tif (L[i] > R[i]) {\n\t    swap(L[i], R[i]);\n\t    swap(La[i], Ra[i]);\n\t}\n\tif (R[i] >= 0) G[R[i]].push_back(i);\n    }\n\n    for (int t=M; t--;) {\n\tD[t] %= 26;\n\tD[t] += 26;\n\tD[t] %= 26;\n\n\tEACH (e, G[t]) {\n\t    assert(R[*e] == t);\n\t    if (D[t] == 0) break;\n\t    if (D[t] % 2 == 1 && Ra[*e] % 2 == 0) continue;\n\t    while (D[t] % abs(Ra[*e])) D[t] += 26;\n\t    int m = D[t] / Ra[*e];\n\t    D[t] -= Ra[*e] * m;\n\t    if (0 <= L[*e]) D[L[*e]] -= La[*e] * m;\n\t}\n\n\tif (D[t]) {\n\t    puts(\"NO\");\n\t    return;\n\t}\n\n\tif (G[t].size() >= 2u) {\n\t    int idx = 0;\n\t    for (int i=1; i<(int)G[t].size(); i++) {\n\t\tif (L[G[t][idx]] > L[G[t][i]]) idx = i;\n\t    }\n\t    REP (i_, G[t].size()) if (i_ != idx) {\n\t\tint i = G[t][i_];\n\t\tint j = G[t][idx];\n\t\tint l = lcm(abs(Ra[i]), abs(Ra[j]));\n\n\t\tR[i] = L[j];\n\t\tRa[i] = l / La[j] * La[j];\n\t\tLa[i] = l / La[i] * La[i] * (-1);\n\t\tif (L[i] > R[i]) {\n\t\t    swap(L[i], R[i]);\n\t\t    swap(La[i], Ra[i]);\n\t\t}\n\t\tRa[i] %= 26;\n\t\tif (Ra[i] && 0 <= R[i] && R[i] < t) G[R[i]].push_back(i);\n\t    }\n\t}\n    }\n\n    puts(\"YES\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<string>\n#include<iostream>\nusing namespace std;\n#define SIZE 262144\nclass segtree\n{\npublic:\n\tint seg[SIZE * 2];\n\tvoid update(int beg, int end, int node, int lb, int ub, int num)\n\t{\n\t\tif (ub < beg || end < lb)return;\n\t\tif (beg <= lb&&ub <= end)\n\t\t{\n\t\t\tseg[node] += num;\n\t\t\treturn;\n\t\t}\n\t\tupdate(beg, end, node * 2, lb, (lb + ub) / 2, num);\n\t\tupdate(beg, end, node * 2 + 1, (lb + ub) / 2 + 1, ub, num);\n\t}\n\tint get(int pl, int node, int lb, int ub)\n\t{\n\t\tif (lb == ub)return seg[node];\n\t\tif (pl <= (lb + ub) / 2)return seg[node] + get(pl, node * 2, lb, (lb + ub) / 2);\n\t\telse return seg[node] + get(pl, node * 2 + 1, (lb + ub) / 2 + 1, ub);\n\t}\n};\nsegtree tree;\nset<int>se[100000];\nint to[100000];\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tif (za <= (s.size() - 1) / 2 && zb >= s.size() / 2)\n\t\t{\n\t\t\tif (za < s.size() - 1 - zb)se[za].insert(s.size() - 1 - zb - 1);\n\t\t\telse if (za > s.size() - 1 - zb)se[s.size() - 1 - zb].insert(za - 1);\n\t\t}\n\t\telse if (za <= (s.size() - 1) / 2)se[za].insert(zb);\n\t\telse se[s.size() - 1 - zb].insert(s.size() - 1 - za);\n\t}\n\tfor (int i = 0; i < s.size(); i++)to[i] = i;\n\tfor (int i = 0; i < s.size() / 2; i++)\n\t{\n\t\tint t = (s[s.size() - 1 - i] + 52 - s[i] - tree.get(i, 1, 0, SIZE - 1) % 26) % 26;\n\t\tif (t != 0 && se[to[i]].size() == 0)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (se[to[i]].size() != 0)\n\t\t{\n\t\t\tset<int>::iterator it = se[to[i]].begin();\n\t\t\tint x = *it;\n\t\t\tse[to[i]].erase(it);\n\t\t\ttree.update(i, x, 1, 0, SIZE - 1, t);\n\t\t\tint y = to[i], z = to[x + 1];\n\t\t\tif (se[y].size() > se[z].size())\n\t\t\t{\n\t\t\t\tto[x + 1] = y;\n\t\t\t\tit = se[z].begin();\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\tif (it == se[z].end())break;\n\t\t\t\t\tse[y].insert(*it);\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tto[i] = z;\n\t\t\t\tit = se[y].begin();\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\tif (it == se[y].end())break;\n\t\t\t\t\tse[z].insert(*it);\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+5;\nint lowbit(int x){return x&(-x);}\nint arr[MAXN];\ninline int sum(int x){int res=0;while(x)res+=arr[x],x-=lowbit(x);return res;}\ninline void add(int x,int n){while(x<MAXN)arr[x]+=n,x+=lowbit(x);}\ninline int update(int x,int y,int n){add(x,n);add(y+1,-n);}\nstruct node{\n    int a,b;\n    bool operator < (const node&p)const{\n        return a==p.a ? b > p.b : a > p.a;\n    }\n};\npriority_queue<node> q;\nqueue<node> qq,qqq;\nint f[MAXN];\nstring s;\n//char s[MAXN];\nint a[MAXN];\nint main()\n{\n    memset(f,-1,sizeof f);\n    int x,n,l,r;\n    cin>>s;\n    s=\"0\"+s;\n    //scanf(\"%s\",&s+1);\n    int len = s.length();\n\n    //printf(\"%s\\n\",s);\n    //cout<<s<<endl;\n    //cout<<\"len:\"<<len<<endl;\n    for(int i=1;i<=len/2;i++){\n        update(i,i,s[i] - s[len-i]);\n    }\n    cin>>n;\n    int ll = len / 2;\n    //cout<<\"ll: \"<<ll<<endl;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        //cout<<l<<\"|\"<<r<<endl;\n        if(r <= ll)\n            q.push(node{l,r});\n        else if(l <= ll){\n            //l += ll - l + 1;\n            if(l+r == len)continue;\n            if(abs(ll-l)>abs(r-ll))\n            {\n                q.push(node{l,len-r-1});\n            }\n            else\n                q.push(node{len-r,l-1});\n\n            //q.push(node{ll - max(abs(ll-l),abs(ll-r)), ll - min(abs(ll-l),abs(ll-r))});\n        }\n        else{\n            q.push(node{len-r,len-l});\n        }\n    }\n    /*while(!q.empty()){\n        node now = q.top();\n        //qq.push(now);\n        cout<<now.a<<\"-\"<<now.b<<endl;\n        q.pop();\n    }*/\n    node now,pre = q.top();\n    //qq.push(pre);\n    while(!q.empty()){\n        now = q.top();\n        //cout<<now.a<<\" | \"<<now.b<<endl;\n        if(pre.a < now.a){\n            f[pre.a] = pre.b;\n            pre = now;\n            continue;\n        }\n        q.pop();\n        if(pre.b == now.b)continue;\n        else{\n            q.push(node{pre.b+1, now.b});\n        }\n    }\n    f[pre.a] = pre.b;\n    //qq.push(pre);\n    /*while(!qq.empty()){\n        node now = qq.front();\n        qqq.push(now);\n        cout<<now.a<<\" \"<<now.b<<endl;\n        qq.pop();\n    }*/\n    bool flag = 1;\n    if(len%2==0)len--;\n    for(int i=1;i<=len/2;i++){\n\n        //now = qq.front();\n        x = sum(i) - sum(i-1);\n        //cout<<\"*\"<<x<<\"  \"<<i<<\" \"<<f[i]<<endl;\n        if(x == 0)continue;\n        if(f[i] != -1){\n            //qq.pop();\n            update(i,f[i], -x);\n        }\n        else{\n            flag = 0;\n            break;\n        }\n        //cout<<\"**\"<<sum(i) - sum(i-1)<<endl;\n    }\n    if(flag)\n        cout<<\"YES\\n\";\n    else\n        cout<<\"NO\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass UF {\nprivate:\n    int sz;\npublic:\n    vector<int> kind;   //所属しているグループ番号\n    vector<vector<int> > inc;   //グループのメンバー\n    UF(){}\n    UF(int node_size){ sz = node_size; kind.resize(sz),inc.resize(sz); rep(i,sz){ kind[i] = i; inc[i].pb(i); } }\n    bool same(int a,int b){ return kind[a] == kind[b]; }\n    void unite(int a,int b)\n    { if(same(a,b)) return; if(inc[kind[a]].size() < inc[kind[b]].size()) swap(a,b);\n        int ga = kind[a],gb = kind[b]; rep(i,inc[gb].size()) kind[inc[gb][i]] = ga;\n        inc[ga].insert(inc[ga].end(),inc[gb].begin(),inc[gb].end()); inc[gb].clear(); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    s = 'a' + s + 'a';\n    vi vec(n+1);\n    rep(i,n+1){\n        vec[i] = ((int)(s[i+1]-s[i])+26)%26;\n    }\n    UF uf(n+1);\n    rep(i,n){\n        int l, r;\n        cin >> l >> r;\n        --l;\n        uf.unite(l, r);\n    }\n    rep(i,(n+1)/2){\n        uf.unite(i, n-i);\n    }\n    if((n+1)%2){\n        rep(i,n+1){\n            if(uf.inc[i].empty()) continue;\n            int ch = 0;\n            bool flag = false;\n            each(j, uf.inc[i]){\n                ch += vec[j];\n                flag |= (j == n/2);\n            }\n            if(ch % 26 != 0 && !flag){\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n    }else{\n        rep(i,n+1){\n            if(uf.inc[i].empty()) continue;\n            int ch = 0;\n            each(j, uf.inc[i]){\n                ch += vec[j];\n            }\n            if(ch % 26 != 0){\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int BIT_MAX = 100010;\n\ntemplate <class T> class BIT{\n\tT x[BIT_MAX + 1];\n\t\npublic:\n\t\n\tBIT(){\n\t\tfill(x,x+BIT_MAX+1,0);\n\t}\n\t\n\tvoid add(int a , T b){\n\t\t++a;\n\t\tfor(; a <= BIT_MAX ; a += a & -a) x[a] += b;\n\t}\n\t\n\tT get(int a){\n\t\t++a;\n\t\tT b = 0;\n\t\tfor(; a > 0 ; a -= a & -a) b += x[a];\n\t\treturn b;\n\t}\n};\n\nconst int MC = 100010;\nstring S;\nint a[MC];\nint N,M;\nint b[MC];\nvector<int> V[MC];\nBIT<int> bit;\n\nint main(){\n\tcin >> S;\n\tM = S.size();\n\trepp(i,0,M){\n\t\ta[i] = S[i] - 'a';\n\t}\n\tcin >> N;\n\trepp(i,0,N){\n\t\tint L,R;\n\t\tcin >> L >> R;\n\t\t--L; --R;\n\t\tif(M-1-L*2 < R*2-M+1){\n\t\t\tV[R].PB(L);\n\t\t} else if(M-1-L*2 > R*2-M+1){\n\t\t\tV[L].PB(R);\n\t\t}\n\t}\n\trepp(l,0,(M+1)/2){\n\t\tint r = M-1-l;\n\t\ta[l] = (a[l]+bit.get(l)) % 26;\n\t\ta[r] = (a[r]+bit.get(r)) % 26;\n\t\tint c = (a[r]-a[l]+26) % 26;\n\t\tif((int)V[l].size()==0 && (int)V[r].size()==0 && c){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(V[l].size()){\n\t\t\tsort(V[l].begin(),V[l].end());\n\t\t\tint x = V[l][0] + 1;\n\t\t\tbit.add(l,c);\n\t\t\tbit.add(x,-c);\n\t\t\tc = 0;\n\t\t\trepp(k,1,V[l].size()){\n\t\t\t\tint y = V[l][k];\n\t\t\t\tif(x > y) continue;\n\t\t\t\tif(M-1-x*2 < y*2-M+1){\n\t\t\t\t\tV[y].PB(x);\n\t\t\t\t} else if(M-1-x*2 > y*2-M+1){\n\t\t\t\t\tV[x].PB(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(V[r].size()){\n\t\t\tsort(V[r].begin(),V[r].end(),greater<int>());\n\t\t\tint y = V[r][0];\n\t\t\tif(c){\n\t\t\t\tbit.add(y,26-c);\n\t\t\t\tbit.add(r+1,c-26);\n\t\t\t}\n\t\t\t--y;\n\t\t\trepp(k,1,V[r].size()){\n\t\t\t\tint x = V[r][k];\n\t\t\t\tif(x > y) continue;\n\t\t\t\tif(M/2-x < y-M/2){\n\t\t\t\t\tV[y].PB(x);\n\t\t\t\t} else if(M-1-x*2 > y*2-M-1){\n\t\t\t\t\tV[x].PB(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  for(int i = 0; i < st.size(); i++) {\n\n    map< int, int > mp;\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(mp.count(ind[other])) {\n          if((S[other] - S[idx] + 26) % 26 != mp[ind[other]]) {\n            throw (0);\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        } else {\n          mp[ind[other]] = (S[other] - S[idx] + 26) % 26;\n        }\n      }\n    }\n\n  }\n\n  throw (0);\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\treturn b - a;\n}\n\nset<int> st;\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB({1, i});\n\t\tvec[r[i] + 1].PB({-1, i});\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t\tif(x == -1) st.erase(id);\n\t\t\telse st.insert(id);\n\t\t}\n\t\ttot[i] = totnow;\n\t\tif(tot[i] == 0) par[i] = 0;\n\t\telse {\n\t\t\tif(ms[st] == 0) ms[st] = i;\n\t\t\tpar[i] = ms[st];\n\t\t}\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(find(i) == find(n - i + 1)) {\n\t\t\tif(s[i - 1] != s[n - i]) bisa = false;\n\t\t}\n\t\telse {\n\t\t\tint pr = find(i);\n\t\t\tint rev = n - pr + 1;\n\t\t\tif(find(n - i) == find(rev)) {\n\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\tbisa = false;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int N = (int) 1e5 + 100;\nchar str[N];\nint d[N], dd[N];\nint len;\nint gt[N];\n\nvector <int> g[N];\n\nvoid addSeg(int l, int r)\n{\n    l = max(l, 0);\n    r = min(r, len - 1);\n    if (l > r) return;\n    r++;\n    g[l].push_back(r);\n    g[r].push_back(l);\n}\n\nbool used[N];\nint sum;\n\nvoid dfs(int v)\n{\n    used[v] = true;\n    sum += dd[v];\n    for (int to : g[v] )\n        if (!used[to] )\n            dfs(to);\n}\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    scanf(\"%s\", str);\n    int n = strlen(str);\n    len = n / 2;\n    for (int i = 0; i < len; i++)\n        d[i] = (26 + str[i] - str[n - 1 - i] ) % 26;\n    \n    int prv = 0;\n    for (int i = 0; i <= len; i++)\n    {\n        dd[i] = d[i] - prv;\n        prv = d[i];\n    }\n    int q;\n\n    for (int i = 0; i < len; i++)\n        eprintf(\"%d \", d[i] );\n    eprintf(\"\\n\");\n    for (int i = 0; i <= len; i++)\n        eprintf(\"%d \", dd[i] );\n    eprintf(\"\\n\");\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--;\n        r--;\n        if (l < n / 2 && r >= n / 2)\n        {\n            r = n - 1 - r;\n            if (l == r) continue;\n            if (l < r)\n                addSeg(l, r - 1);\n            else\n                addSeg(r, l - 1);\n        }\n        else if (r < n / 2)\n            addSeg(l, r);\n        else\n            addSeg(n - 1 - r, n - 1 - l);\n    }\n\n    for (int i = 0; i <= len; i++)\n    {\n        if (used[i] ) continue;\n        sum = 0;\n        dfs(i);\n        if (sum % 26 != 0)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n\");\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n  int len = s.size();\n  int n;\n  cin>>n;\n  vector<vector<int>> ranges(len);\n  REP(i,n) {\n    int l, r;\n    cin>>l>>r;\n    --l;--r;\n    int a, b;\n    if (r >= len/2) {\n      if (l >= len/2) {\n        a = len-r-1;\n        b = len-l-1;\n      } else if (l-1 >= len-r-1) {\n        a = len-r-1;\n        b = l-1;\n      } else {\n        a = l;\n        b = len-r-1-1;\n      }\n    } else {\n      a = l;\n      b = r;\n    }\n    if (a <= b) {\n      ranges[a].push_back(b);\n    }\n  }\n  REP(i,len) {\n    if (ranges[i].size() > 1) {\n      sort(ALL(ranges[i]));\n      ranges[i].erase(unique(ALL(ranges[i])), end(ranges[i]));\n      int m = ranges[i].size();\n      REP(j,m-1) {\n        ranges[ranges[i][j]].push_back(ranges[i][j+1]);\n      }\n      ranges[i].erase(begin(ranges[i])+1, end(ranges[i]));\n    }\n  }\n  using T = pair<int,int>;\n  priority_queue<T, vector<T>, greater<T>> q;\n  int sum = 0;\n  vector<int> t(len);\n  REP(i,len) {\n    t[i] = s[i] - 'a';\n  }\n  bool ok = true;\n  REP(i,len/2) {\n    if ((t[i]+sum)%26 != t[len-i-1]) {\n      if (ranges[i].empty()) {\n        ok = false;\n        break;\n      }\n      int diff = (t[len-i-1] + 26 - (t[i]+sum)%26)%26;\n      sum += diff;\n      q.emplace(ranges[i][0], diff);\n    }\n    while (!q.empty() && q.top().first == i) {\n      sum -= q.top().second;\n      q.pop();\n    }\n  }\n  if (ok) {\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nusing ld = long double;\nll INF = LLONG_MAX;\n\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid print() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); \n\t}\n}\n\nusing namespace output;\n\ntemplate<class T> struct Seg { \n\tconst T ID = 0; // comb(ID,b) must equal b\n\tT combine(T a, T b) { return (a+b)%26;} \n\tint n; vector<T> seg;\n\tvoid init(int _n) { n = _n; seg.assign(2*n,ID);}\n\n\tvoid update(int p, T value) {\t// set value at position p\n\t\tseg[p += n] += value;\n\t\tfor (p /= 2; p; p /= 2) seg[p] = combine(seg[2*p], seg[2*p+1]);\n\t}\n    \n\tT query(int l, int r) {\t // sum on interval [l, r]\n\t\tT ra = ID, rb = ID; \n\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {\n\t\t\tif (l&1) ra = combine(ra,seg[l++]);\n\t\t\tif (r&1) rb = combine(seg[--r],rb);\n\t\t}\n\t\treturn combine(ra,rb);\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring S; cin >> S;\n\tint N; cin >> N;\n\tvector<vi> startsAt (S.size()+1);\n\tvector<vi> endsAt (S.size()+1);\n\tF0R(i, N) {\n\t\tint l, r; cin >> l >> r; --l; --r;\n\t\tstartsAt[l].push_back(r+1); // orig\n\t\tif (l+1 == S.size()-r) {\n\n\t\t} else if (l+1 < S.size()-r) {\n\t\t\tstartsAt[r+1].push_back(S.size()-l);\n\t\t} else {\n\t\t\tstartsAt[S.size()-r-1].push_back(l);\n\t\t}\n\t}\n\n\tF0R(i, S.size()+1) {\n\t\tsort(startsAt[i].begin(), startsAt[i].end());\n\t\tstartsAt[i].erase(unique(startsAt[i].begin(), startsAt[i].end()), startsAt[i].end());\n\n\t\tfor (int j = 1; j < startsAt[i].size(); ++j) {\n\t\t\tif (startsAt[i][j] != startsAt[i][j-1]) startsAt[startsAt[i][j-1]].push_back(startsAt[i][j]);\n\t\t}\n\t\tif (startsAt[i].size()) startsAt[i] = vi {startsAt[i][0]};\n\t\tfor (int j : startsAt[i]) endsAt[j].push_back(i);\n\t}\n\n\tstartsAt.assign(S.size() + 1, vi {});\n\n\tR0F(i, S.size()+1) {\n\t\tsort(endsAt[i].begin(), endsAt[i].end());\n\t\tendsAt[i].erase(unique(endsAt[i].begin(), endsAt[i].end()), endsAt[i].end());\n\n\t\tfor (int j = 0; j+1 < endsAt[i].size(); ++j) {\n\t\t\tif (endsAt[i][j] != endsAt[i][j+1]) endsAt[endsAt[i][j+1]].push_back(endsAt[i][j]);\n\t\t}\n\t\tif (endsAt[i].size()) endsAt[i] = vi {endsAt[i].back()};\n\t\tfor (int j : endsAt[i]) startsAt[j].push_back(i);\n\t}\n\n\tSeg<int> seg; seg.init(S.size());\n\tint sum = 0;\n\tF0R(i, S.size()) {\n\t\tseg.update(i, S[i]-'a');\n\t}\n\n\t// print(startsAt);\n\n\tfor (int l = 0; l < S.size() / 2; ++l) {\n\t\tint lc = seg.query(0, l) - ((l != 0) ? seg.query(0, l-1) : 0); lc = (lc + 26) % 26;\n\t\tint rc = seg.query(0, S.size()-l-1) - seg.query(0, S.size()-l-2); rc = (rc + 26) % 26;\n\t\tif (rc != lc) {\n\t\t\tif (startsAt[l].size() && (startsAt[l][0] <= S.size()-l-1)) {\n\t\t\t\tint cycle = (rc - lc + 26) % 26;\n\t\t\t\tseg.update(l, cycle);\n\t\t\t\tseg.update(startsAt[l][0], -cycle);\n\t\t\t} else {\n\t\t\t\tprint(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\n\t}\n\tprint(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nset<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tP u = *vec[k].begin();\n\tif(u.fr == k){\n\t\tset<P>::iterator itr = vec[k].begin();\n\t\t++itr;\n\t\tfor(;itr != vec[k].end() ; ++itr){\n\t\t//for(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tP v = *itr;\n\t\t\tif(v.fr == k){\n\t\t\t\tP p = P(u.sc,v.sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].insert(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(u.sc,v.fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].insert(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n//S[k] += d;\n//if(S[k] > 'z')S[k] -= 26;\n\t\tif(u.sc < S.size()/2){\n\t\t\tif(u.sc+1 < S.size()/2){\n\t\t\t\tadd[u.sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[u.sc] +=d ;\n\t}\n\telse {\n\t\tset<P>::iterator itr = vec[k].begin();\n\t\t++itr;\n\t\tfor(;itr != vec[k].end() ; ++itr){\n\t\t//for(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tP v = *itr;\n\t\t\tif(v.fr == k){\n\t\t\t\tP p = P(v.sc,u.fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].insert(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(u.fr,v.fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].insert(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n//S[S.size()-1-k] += d;\n//if(S[S.size()-1-k] > 'z')S[S.size()-1-k] -= 26;\n\t\tif(u.fr < S.size()/2)add[u.fr] += d;\n\t\telse{\n\t\t\tif(u.fr-1 > S.size()/2){\n\t\t\t\tadd[u.fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tif(l[i] != S.size()-1-r[i])vec[min(l[i],(int)(S.size())-1-r[i])].insert(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100100;\n\nint N;\nint n, qn;\nchar s[maxn + 5];\n\nint dif[maxn + 5];\n\nint fa[maxn + 5];\n\nint get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }\n\nint sum[maxn + 5];\n\nint where[maxn + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tstatic char tmp[maxn + 5];\n\tscanf(\"%s\", tmp);\n\tn = strlen(tmp);\n\tint cur = 0;\n\ts[cur++] = '#';\n\tREP(i, 0, n)\n\t{\n\t\tif ((i << 1) == n) s[cur++] = '#';\n\t\twhere[i] = cur;\n\t\ts[cur++] = tmp[i];\n\t}\n\ts[cur++] = '#';\n\tn = cur;\n\tint mid = n >> 1;\n\tN = mid;\n\tREP(i, 0, N)\n\t{\n\t\tdif[i] = (s[n - (N - i) - 1] - s[n - (N - i)]) - (s[N - i] - s[N - i - 1]);\n\t}\n\tREP(i, 0, N) fa[i] = i;\n\tscanf(\"%d\", &qn);\n\tREP(i, 0, qn)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y), --x, --y;\n\t\tx = where[x];\n\t\ty = where[y];\n\t\tif (y < mid)\n\t\t{\n\t\t\tx = mid - x;\n\t\t\ty = mid - y - 1;\n\t\t}\n\t\telse if (x > mid)\n\t\t{\n\t\t\tx = x - mid - 1;\n\t\t\ty = y - mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx = mid - x;\n\t\t\ty = y - mid;\n\t\t}\n\t\tfa[get(x)] = get(y);\n\t}\n\tREP(i, 0, N) (sum[get(i)] += dif[i]) %= 26;\n\tREP(i, 0, N) if (fa[i] == i && sum[i])\n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nstring s;\nint n, l[N], r[N], a[N];\n\nstruct Dsu {\n    int pset[N], szset[N], val[N];\n    void init() {\n        for (int i = 0; i < N; ++i) pset[i] = i, szset[i] = 1, val[i] = a[i];\n    }\n    int findset(int i) { return i == pset[i] ? i : pset[i] = findset(pset[i]); }\n    bool sameset(int i, int j) { return findset(i) == findset(j); }\n    void unionset(int i, int j) {\n        if(sameset(i, j) ) return ;\n        i = findset(i); j = findset(j);\n        if(szset[i] > szset[j]) swap(i, j);\n        val[j] = (val[i] + val[j]) % 26;\n        szset[j] += szset[i];\n        pset[i] = j;\n    }\n} dsu;\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> s >> n;\n    s = 'a' + s; s += 'a';\n    for (int i = 1; i <= n; ++i) cin >> l[i] >> r[i];\n    for (int i = 0; i < s.size() - 1; ++i) a[i] = (s[i + 1] - s[i] + 26) % 26;\n    for (int i = 0; i <= 3; ++i) cout << a[i] << ' '; cout << '\\n';\n\n    dsu.init();\n    for (int i = 1; i <= n; ++i) {\n        dsu.unionset(l[i] - 1, r[i]);\n    }\n    for (int i = 0; i <= (s.size() - 2) / 2; ++i) dsu.unionset(i, s.size() - 2 - i);\n\n    for (int i = 0; i < N; ++i) if(dsu.val[dsu.findset(i)]) return cout << \"NO\", 0;\n\n    cout << \"YES\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, m;\nint par[N], sum[N], a[N], d[N];\nstring s;\n\nint find(int x) {\n\treturn (x == par[x]) ? x : par[x] = find(par[x]);\n}\n\nvoid join(int x, int y) {\n\tx = find(x), y = find(y);\n\tif (x == y) return;\n\tsum[x] += sum[y], sum[y] = 0, sum[x] %= 26, par[y] = x;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> s, s = 'a' + s + 'a';\n\tn = s.size();\n\tfor (int i = 1; i < n; ++i) {\n\t\ta[i] = s[i] - 'a';\n\t\td[i] = a[i] - a[i - 1];\n\t\tif (d[i] < 0) d[i] += 26;\n\t}\n\tfor (int i = 1; i < n; ++i) par[i] = i, sum[i] = d[i];\n\tfor (int i = 1; i < n; ++i) join(i, n - i);\n\tcin >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint l, r; cin >> l >> r; join(l, r + 1);\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (sum[find(i)]) {\n\t\t\tcout << \"NO\"; return 0;\n\t\t}\n\t}\n\tcout << \"YES\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+1;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+1) {puts(\"NO\");return 0;}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mod = 'z' - 'a' + 1;\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\n\tint m;\n\tcin >> m;\n\tvector<vector<int>> graph(n/2 + 1);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a;\n\t\ta = min(a, n-a);\n\t\tb = min(b, n-b);\n\t\tif(a != b) {\n\t\t\tgraph[a].push_back(b);\n\t\t\tgraph[b].push_back(a);\n\t\t}\n\t}\n\n\tvector<int> vec(n/2);\n\tfor(int i = 0; i < n/2; ++i) {\n\t\tvec[i] = int(s[i]) - int(s[n-1-i]);\n\t\tvec[i] %= mod;\n\t\tvec[i] += mod;\n\t\tvec[i] %= mod;\n\t}\n\n\tn  = n/2+1;\n\n\tvector<bool> seen(n, false);\n\tfunction<void(int, vector<int>&)> dfs = [&](int node, vector<int> &comp) {\n\t\tif(seen[node]) return;\n\t\tseen[node] = true;\n\t\tcomp.push_back(node);\n\t\tfor(int ch : graph[node]) dfs(ch, comp);\n\t};\n\n\tvector<int> finish(n, -1);\n\tvector<int> start(n, -1);\n\tvector<int> total;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(!seen[i]) {\n\t\t\tvector<int> comp;\n\t\t\tsort(comp.begin(), comp.end());\n\t\t\tdfs(i, comp);\n\t\t\tfor(int j = 1; j < comp.size(); ++j) {\n\t\t\t\tstart[comp[j-1]] = total.size();\n\t\t\t\tfinish[comp[j]] = total.size();\n\t\t\t\ttotal.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint sum = 0;\n\tbool can = true;\n\tfor(int i = 0; i < n-1; ++i) {\n\t\tassert(vec[i] >= 0);\n\t\tassert(sum >= 0);\n\t\tvec[i] += sum;\n\t\tvec[i] %= mod;\n\t\tif(vec[i] != 0) {\n\t\t\tif(start[i] == -1) can = false;\n\t\t\telse {\n\t\t\t\tsum += mod - vec[i];\n\t\t\t\tsum %= mod;\n\t\t\t\ttotal[start[i]] = (mod - vec[i]) % mod;\n\t\t\t}\n\t\t}\n\t\tif(finish[i+1] != -1) {\n\t\t\tsum += mod - total[finish[i+1]];\n\t\t\tsum %= mod;\n\t\t}\n\t}\n\n\tif(can) {\n\t\tcout << \"YES\" << endl;\n\t} else {\n\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define N 100010\nstring s;\nint n;\nint m;\nint a[N];\nint b[N];\nint c[N];\nint f[N];\nint fa(int x) {\n\tif (x == f[x]) return x;\n\treturn f[x] = fa(f[x]);\n}\n\nvoid add(int x, int y) {\n\tf[fa(x)] = fa(y);\n}\n\nint main() {\n\tcin >> s;\n\tm = (int) s.length();\n\tbool er = false;\n\tif (m%2 == 1) {\n\t\ts = s.substr(0, m/2) + s.substr(m/2+1);\n\t\ter = true;\n\t\tm--;\n\t}\n\t// now m is even\n\tfor (int i = 0; i < m/2; i ++) {\n\t\ta[i] = ((s[i] - s[m-1-i])%26+26)%26;\n\t\t//cout << a[i] << endl;\n\t}\n\tfor (int i = 0, la = 0; i < m/2; i ++) {\n\t\tb[i] = a[i] - la;\n\t\tla = a[i];\n\t\t//cout << b[i] << endl;\n\t}\n\tfor (int i = 0; i <= m/2; i ++) f[i] = i;\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i ++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\t\n\t\tif (er && x == m/2) x++;\n\t\tif (er && y == m/2) y--;\n\t\tif (x >= m/2+1 && er) x--;\n\t\tif (y >= m/2+1 && er) y--;\n\t\tif (x > y) continue;\n\t\t\n\t\tif (x >= m/2) {\n\t\t\tswap(x, y);\n\t\t\tx = m-1-x;\n\t\t\ty = m-1-y;\n\t\t}\n\t\t\n\t\tif (y >= m/2) {\n\t\t\tif (y-m/2 == m/2-1-x) continue;\n\t\t\tif (y-m/2 > m/2-1-x) {\n\t\t\t\tswap(x, y);\n\t\t\t\tx = m-1-x;\n\t\t\t\ty = m-1-y;\n\t\t\t}\n\t\t\ty = m/2-2-(y-m/2);\n\t\t}\n\t\t// do something\n\t\t//cout << x << \" \" << y << endl;\n\t\tadd(x, y+1);\n\t}\n\t\n\tfor (int i = 0; i < m/2; i ++)\n\t\tc[fa(i)] += b[i];\n\tbool F = true;\n\tfor (int i = 0; i < m/2; i ++)\n\t\tif (i != fa(m/2) && c[i]%26 != 0) F = false;\n\tputs (F?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\t//S[k] += a;\n\t//S[S.size()-1-k] += b;\n\tif(S.size()-1-k <= k)return true;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tvec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// {{{ DJS\nstruct DJS {\n    vector<int> fa, sz;\n    void init(int n) {\n        n++; // be nice for 1-index usage\n        fa.resize(n);\n        sz.resize(n);\n        for (int i = 0; i < n; i++) {\n            fa[i] = i;\n            sz[i] = 1;\n        }\n    }\n    int f(int x) {\n        return x == fa[x] ? x : fa[x] = f(fa[x]);\n    }\n    void u(int a, int b) {\n        a = f(a);\n        b = f(b);\n        if (a == b) return;\n        if (sz[a] > sz[b]) swap(a, b);\n        fa[a] = b;\n        sz[b] += sz[a];\n    }\n    bool is_root(int x) {\n        return x == fa[x];\n    }\n    bool same(int a, int b) {\n        return f(a) == f(b);\n    }\n};\n// }}}\n// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nusing mint = ModInt<26>;\n\nconst int N=1e5+10;\nint n,m,l[N],r[N],a[N];\nchar s[N];\nVI cc[N];\nvoid main() {\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    R(m);\n    REP(i,m) R(l[i],r[i]);\n    REP1(i,1,n/2) {\n        a[i]=s[i]-s[n-i+1];\n    }\n    DJS djs;\n    djs.init(n/2+1);\n    for ( int i=n/2; i>=1; i-- ) a[i]-=a[i-1];\n    REP(i,m) {\n        int ll,rr;\n        if ( r[i]<=n/2 ) {\n            ll=l[i];\n            rr=r[i];\n        } else if ( l[i]>n/2 ) {\n            ll=n-r[i]+1;\n            rr=n-l[i]+1;\n        } else {\n            assert(l[i]<=n/2 && r[i]>n/2);\n            int l1=l[i],r1=n-r[i]+1;\n            int l2=n-l[i]+1,r2=r[i];\n            if ( l1<=r1 ) {\n                ll=l1;\n                rr=r1-1;\n            } else if ( l2<=r2 ) {\n                ll=n-r2+1;\n                rr=n-l2;\n            } else {\n                assert(0);\n            }\n        }\n        dump(i,l[i],r[i],ll,rr);\n        if ( rr==n/2+1 ) rr--;\n        assert(ll<=rr+1);\n        djs.u(ll,rr+1);\n    }\n    REP1(i,1,n/2) cc[djs.f(i)].PB(i);\n    int sp=djs.f(n/2+1);\n    REP1(i,1,n/2) if ( !cc[i].empty() && i!=sp ) {\n        auto &v=cc[i];\n        mint sa=0;\n        for ( auto j:v ) sa+=a[j];\n        if ( sa!=0 ) {\n            W(\"NO\");\n            return;\n        }\n    }\n    W(\"YES\");\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define out(x) cerr << #x << \" = \" << x << \"\\n\"\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar();bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\n// Sub the Seq. and then Add Edge\n// Note How Palind. Works\nconst int N = 3e5 + 10, mod = 26;\nchar s[N];\nint pre[N], a[N], n, Q, sum[N];\n\ninline int find(int u) {\n  return pre[u] == u ? u : pre[u] = find(pre[u]);\n}\n\ninline void Merge(int x, int y);\ninline void init() {\n  for(int i = 1; i <= n; i ++) s[i] -= 'a';\n  for(int i = 1; i <= n + 1; i ++) {\n    a[i] = (s[i] - s[i - 1]) % mod;\n    sum[i] = a[i];\n    pre[i] = i;\n  }\n  for(int i = 1; i <= n + 1; i ++) {\n    Merge(i, n + 1 - i + 1);\n  }\n}\n\ninline void Merge(int x, int y) {\n  int u = find(x), v = find(y);\n  if(u == v) return ;\n  (sum[u] += sum[v]) %= mod; sum[v] = 0;\n  pre[v] = u;\n}\n\nmain() {\n  scanf(\"%s\", s + 1); n = strlen(s + 1);\n  init();\n  read(Q);\n  for(int i = 1; i <= Q; i ++) {\n    int x, y;\n    read(x), read(y); ++ y;\n    Merge(x, y);\n  }\n  // for(int i = 1; i <= n + 1; i ++) cout << a[i] << ' '; putchar('\\n');\n  // for(int i = 1; i <= n + 1; i ++) cout << sum[i] << ' '; putchar('\\n');\n\n  for(int i = 1; i <= n + 1; i ++) if(pre[i] == i) {\n      if(sum[i]) return cout << \"NO\\n\", 0;\n    }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nusing namespace std;\n\nstring s;\nint n, m, l[N], r[N], sum[N];\nint pset[N];\n\nint findset(int i){return ((pset[i] == i) ? i : pset[i] = findset(pset[i]));}\n\nvoid dsu(int i, int j){\n    i = findset(i); j = findset(j);\n    if (i == j) return;\n    pset[j] = i;\n    sum[i] += sum[j];\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s;\n    n = s.size();\n    s = '.' + s;\n    cin >> m;\n    for (int i = 1; i <= m; i++){\n        cin >> l[i] >> r[i];\n        if (r[i] < n + 1 - r[i]) continue;\n        if (l[i] > n + 1 - l[i]){\n            l[i] = n + 1 - l[i];\n            r[i] = n + 1 - r[i];\n            continue;\n        }\n        r[i] = n + 1 - r[i];\n        if (l[i] <= r[i]) r[i]--;\n        else l[i]--, swap(l[i], r[i]);\n    }\n\n    for (int i = 1; i <= n/2; i++) sum[i] = s[n+1-i] - s[i];\n    for (int i = n/2+1; i >= 1; i--) sum[i] -= sum[i-1];\n\n    for (int i = 1; i <= n; i++) pset[i] = i;\n    for (int i = 1; i <= m; i++) {\n        assert(l[i] <= n + 1 - l[i]);\n        assert(r[i] < n + 1 - r[i]);\n        dsu(l[i], r[i]+1);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (pset[i] == i && sum[i] % 26 != 0) return cout << \"NO\", 0;\n    }\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN], sum[MAXN];\nbool mark[MAXN];\nstring S, T;\nvector<int> G[MAXN];\n\nvoid add(int l, int r){\n\tG[l].pb(r+1);\n\tG[r+1].pb(l);\n}\n\nint dfs(int node){\n\tmark[node]=1;\n\tfor (int v:G[node]) if (!mark[v]) sum[node]+=dfs(v);\n//\tdebug2(node, sum[node])\n\treturn sum[node];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>S>>m;\n\tint len=S.size();\n\tn=len/2;\n\tfor (int i=0; i<n; i++) T+=S.back(), S.pop_back();\n\tif (len&1) S.pop_back();\n\tdebug(S)\n\tdebug(T)\n\t\n\tfor (int i=1; i<=n; i++) A[i]=S[i-1]-T[i-1];\n\tfor (int i=1; i<=n+1; i++) sum[i]=A[i]-A[i-1];\n//\tfor (int i=1; i<=n; i++) cerr<<A[i]<<\" \\n\"[i==n];\n//\tfor (int i=1; i<=n+1; i++) cerr<<sum[i]<<\" \\n\"[i==n+1];\n\twhile (m--){\n\t\tcin>>x>>y;\n\t\tif (len%2){\n\t\t\tif (x==n+1 && y==n+1) continue ;\n\t\t\tif (x==n+1) x++;\n\t\t\tif (y==n+1) y--;\n\t\t\tif (x>n) x--;\n\t\t\tif (y>n) y--;\n\t\t}\n\t\tif (x<=n && y<=n) x=n-x+1, y=n-y+1, swap(x, y);\n\t\telse if (x>n && y>n) x-=n, y-=n;\n\t\telse{\n\t\t\tx=n-x+1;\n\t\t\ty-=n;\n\t\t\tif (x>y) swap(x, y);\n\t\t\tx++;\n\t\t}\n//\t\tdebug2(x, y)\n\t\tadd(x, y);\n\t}\n\tfor (int i=1; i<=n+1; i++) if (!mark[i] && dfs(i)%26) kill(\"NO\")\n\tkill(\"YES\")\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k) R[i]--;\n\t\tif(L[i] >= k) L[i]--;\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1.1e5;\nint par[MAXN];\nint getpar(int a) {\n\treturn par[a] < 0 ? a : (par[a] = getpar(par[a]));\n}\nbool merge(int a, int b) {\n\ta = getpar(a);\n\tb = getpar(b);\n\tif (a == b) return false;\n\tif (-par[a] < -par[b]) swap(a, b);\n\tpar[a] += par[b];\n\tpar[b] = a;\n\treturn true;\n}\n\nint diffs[MAXN];\nint tots[MAXN];\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tstring S; cin >> S;\n\tint N = int(S.size());\n\tS = \"a\" + S + \"a\";\n\tfor (int i = 0; i <= N; i++) {\n\t\tdiffs[i] = (S[i+1] - S[i]);\n\t}\n\n\tfor (int i = 0; i <= N; i++) {\n\t\tpar[i] = -1;\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tmerge(i, N-i);\n\t}\n\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tint l, r; cin >> l >> r; l--;\n\t\tmerge(l, r);\n\t}\n\n\tfor (int i = 0; i <= N; i++) {\n\t\ttots[getpar(i)] += diffs[i];\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tif (tots[i] % 26 != 0) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\texit(0);\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"NO\"); exit(0); }\nvoid fg(vector<int> G[], int a, int b) { G[a].eb(b); G[b].eb(a); }\n\nconst bool debug = 0;\nconst int MAXN = 200055;\nconst int MAXK = 200055;\n\nvector<int> G[MAXN];\nbitset<MAXN> chk;\n\nint D[MAXN], E[MAXN];\n\nint B[MAXK], C[MAXK];\nchar A[MAXN];\n\nint N, K;\n\nint f(int i) {\n\tint ret = E[i]; chk[i] = true;\n\tfor(int v : G[i]) if(!chk[v]) {\n\t\tret = (ret + f(v)) % 26;\n\t}\n\treturn ((ret % 26) + 26) % 26;\n}\n\nint main() {\n\tscanf(\" %s\", A+1);\n\tN = int(strlen(A+1));\n\tscanf(\"%d\", &K);\n\tfor(int i = 1; i <= K; i++) scanf(\"%d%d\", &B[i], &C[i]);\n\n\tif(N&1) {\n\t\tN++;\n\t\tfor(int i = N-1; N/2 <= i; i--) A[i+1] = A[i];\n\t\tA[N/2] = A[N/2+1];\n\t\tfor(int i = 1; i <= K; i++) {\n\t\t\tif(N/2 < B[i]) B[i]++;\n\t\t\tif(N/2 <= C[i]) C[i]++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= K; i++) {\n\t\tif(C[i] <= N/2) continue;\n\t\tif(N/2 < B[i]) {\n\t\t\tB[i] = N+1-B[i];\n\t\t\tC[i] = N+1-C[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint l = N/2-B[i]+1, r = C[i]-N/2;\n\t\tif(l > r) swap(l, r);\n\t\tB[i] = N/2-r+1;\n\t\tC[i] = N/2-l;\n\t}\n\n\tif(debug) {\n\t\tprintf(\"N=%d, K=%d\\n\", N, K);\n\t\tfor(int i = 1; i <= N; i++) putchar(A[i]); puts(\"\");\n\t\tfor(int i = 1; i <= K; i++)\n\t\t\tprintf(\"%d ; %d %d\\n\", i, B[i], C[i]);\n\t}\n\n\tN /= 2;\n\tfor(int i = 1; i <= N; i++)\n\t\tD[i] = (A[N*2+1-i] - A[i] + 26) % 26;\n\tfor(int i = 1; i <= N+1; i++)\n\t\tE[i] = ((D[i] - D[i-1] + 26) % 26 + 26) % 26;\n\tfor(int i = 1; i <= K; i++) C[i]++;\n\tN++;\n\n\tfor(int i = 1; i <= K; i++) if(B[i] < C[i]) fg(G, B[i], C[i]);\n\tfor(int i = 1; i <= N; i++) if(!chk[i]) {\n\t\tint t = f(i);\n\t\tif(t) fuk();\n\t}\n\n\tputs(\"NO\");\n\treturn 0;\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[101000];\nint l,n,T,a[101000],x,y,used[101000];\nvector<int>G[505555];\n\nint dfs(int x){\n\tused[x]=1;\n\tint res=a[x];\n\tfor (auto y:G[x]) if (!used[y])\n\t\tres+=dfs(y);\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%s\",s+1); l=strlen(s+1); n=l>>1;\n\tfor (int i=1;i<=n;++i) a[i]=s[i]-s[l-i+1];\n\tfor (int i=n+1;i;--i) a[i]-=a[i-1];\n\tfor (cin>>T;T--;){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>n){\n\t\t\tx=l+1-x;\n\t\t\ty=l+1-y;\n\t\t\tswap(x,y);\n\t\t}else if (y>n){\n\t\t\ty=l+1-y;\n\t\t\tif (x==y) continue;\n\t\t\tif (x>y) swap(x,y);\n\t\t\t--y;\n\t\t}\n\t\tG[x].push_back(y+1);\n\t}\n\tfor (int i=1;i<=n+1;++i) if (!used[i]){\n\t\tif (dfs(i)%26) return !puts(\"NO\");\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string S;\n  cin >> S;\n  int M = SZ(S);\n  VI ds(M+1);\n  ds[0] = S[0] - 'a';\n  for(int i=1;i<M;++i){\n\tint b = S[i] - 'a';\n\tint a = S[i-1] - 'a';\n\tds[i] = (b - a + 26) % 26;\n  }\n  ds[M] = (26 - (int)(S.back() - 'a')) % 26;\n  \n  VVI G(M+1);\n  for(int i=0;i<(M+1)/2;++i){\n\tG[i].PB(M - i);\n\tG[M-i].PB(i);\n  }\n\n  int N;\n  cin >> N;\n  REP(i,N){\n\tint l, r;\n\tcin >> l >> r;\n\t--l;\n\tG[l].PB(r);\n\tG[r].PB(l);\n  }\n\n  vector<bool> vis(M+1);\n  function<int(int)> dfs = [&](int u){\n\tint res = ds[u];\n\tvis[u] = true;\n\tfor(int to: G[u]){\n\t  if(vis[to]) continue;\n\t  res += dfs(to);\n\t}\n\treturn res;\n  };\n\n  bool ng = false;\n  REP(i,M+1){\n\tif(vis[i]) continue;\n\tif(dfs(i) % 26 != 0){\n\t  ng = true;\n\t  break;\n\t}\n  }\n  cout << (ng? \"NO\": \"YES\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\ntypedef long long LL;\n\nLL fa[100005],siz[100005];\nLL c[100005] = {0},d[100005],m,n;\nLL l[100005],r[100005];\nstring s;\n\nvoid init(){\n\tfor(LL i = 1;i <= (m >> 1);i ++) c[i] = (s[m + 1 - i] - s[i] + 26) % 26;\n//\tfor(LL i = 1;i <= (m >> 1);i ++) cout << c[i] << (i == (m >> 1) ? '\\n' : ' ');\n\tfor(LL i = 0;i <= (m >> 1);i ++) d[i + 1] = (c[i + 1] - c[i] + 26) % 26;\n\tfor(LL i = 1;i <= (m >> 1) + 1;i ++){\n\t\tfa[i] = i;\n\t\tsiz[i] = d[i];\n\t}\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(l[i] > (m >> 1) && r[i] > (m >> 1)){\n\t\t\tswap(l[i],r[i]);\n\t\t\tl[i] = m + 1 - l[i];\n\t\t\tr[i] = m + 1 - r[i];\n\t\t}\n\t\telse if(r[i] > (m >> 1)){\n\t\t\tLL tor = m + 1 - r[i];\n\t\t\tif(tor < l[i]){\n\t\t\t\tr[i] = l[i] - 1;\n\t\t\t\tl[i] = tor;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr[i] = tor - 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nLL getf(LL x){\n\tif(fa[x] == x) return x;\n\treturn fa[x] = getf(fa[x]);\n}\n\nvoid unionn(LL x,LL y){\n\tx = getf(x); y = getf(y);\n\tif(x == y) return;\n\tfa[x] = y; siz[y] += siz[x];\n}\n\nint main(){\n\tcin >> s; cin >> n;\n\tfor(LL i = 1;i <= n;i ++) cin >> l[i] >> r[i];\n\tm = s.length(); s = ' ' + s;\n\tinit();\n\t\n//\tfor(LL i = 1;i <= (m >> 1) + 1;i ++) cout << d[i] << ' '; cout << endl;\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tr[i] ++;\n\t\tunionn(l[i],r[i]);\n\t}\n\tfor(LL i = 1;i <= (m >> 1) + 1;i ++){\n\t\tif(siz[getf(i)] % 26){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    vector<set<int> > st;\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n        st.resize(node_size);\n        rep(i,node_size){\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n        for(auto p:st[y]){\n            st[x].insert(p);\n        }\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n==1){\n        cout <<\"YES\" << endl;\n        return 0;\n    }\n    vector<int> a(n/2);\n    rep(i,n/2){\n        a[i] = (26+s[n-1-i]-s[i])%26;\n    }\n    // rep(i,n/2)cerr << a[i] << \" \";\n    // cerr << endl;\n    int m;\n    cin >> m;\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > p;\n    rep(i,m){\n        int l,r;\n        cin >> l >> r;\n        l--;r--;\n        if(n%2==1){\n            if(l==n/2&&r==n/2)continue;\n            if(l==n/2)l++;\n            if(r==n/2)r--;\n        }\n        if(l==r){\n            if(l>=n/2){\n                l = n-1-l;\n                p.push(MP(l,l));\n            }else{\n                p.push(MP(l,l));\n            }\n        }else{\n            if(l<n/2&&r<n/2){\n                p.push(MP(l,r));\n            }else if(l<n/2){\n                r = n-1-r;\n                if(l<r){\n                    p.push(MP(l,r-1));\n                }else if(l>r){\n                    p.push(MP(r,l-1));\n                }\n            }else if(r>=n/2){\n                l = n-1-l;\n                r = n-1-r;\n                p.push(MP(min(l,r),max(l,r)));\n            }\n        }\n    }\n    UnionFind uf(n/2+1);\n    vector<int> nxt(n/2,-1);\n    while(!p.empty()){\n        auto x = p.top();\n        p.pop();\n        int a = x.first;\n        int b = x.second;\n        if(nxt[a]==-1){\n            nxt[a] = b;\n            uf.unite(a,b+1);\n        }else{\n            if(nxt[a]>b){\n                int x = nxt[a];\n                nxt[a] = b;\n                uf.unite(a,b+1);\n                if(uf.same(b+1,x+1))continue;\n                if(nxt[b+1]==-1){\n                    nxt[b+1] = x;\n                    uf.unite(b+1,x);\n                }else{\n                    auto zz = (uf.st[uf.find(b+1)].upper_bound(x));\n                    zz--;\n                    int k = *zz;\n                    nxt[x] = nxt[k];\n                    nxt[k] = x-1;\n                    uf.unite(b+1,x);\n                }\n            }else if(nxt[a]<b){\n                if(nxt[nxt[a]+1]==-1){\n                    nxt[nxt[a]+1] = b;\n                    uf.unite(nxt[a]+1,b);\n                }else{\n                    int x = b;\n                    auto zz = (uf.st[uf.find(nxt[a]+1)].upper_bound(x));\n                    zz--;\n                    int k = *zz;\n                    nxt[x] = nxt[k];\n                    nxt[k] = x-1;\n                    uf.unite(nxt[a]+1,x);\n                }\n            }\n        }\n    }\n    vector<int> res(n/2);\n    vector<int> ss(n/2+1);\n    int tmp = 0;\n\n    rep(i,n/2){\n        tmp -= ss[i];\n        res[i] += tmp;\n        res[i] %= 26;\n        if(res[i]!=a[i]){\n            if(nxt[i]!=-1){\n                int c = (26+a[i]-res[i])%26;\n                tmp += c;\n                ss[nxt[i]+1] += c;\n                res[i] = a[i];\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << res[i] << \" \";\n    // }\n    // cerr << endl;\n    rep(i,n/2){\n        if(res[i]!=a[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  trace(label);\n  map<int64, int> d;\n  bool found = false;\n  for (int i = 0; i < n / 2; ++i) {\n    int j = n - 1 - i;\n    int diff = (s[j] - s[i] + 26) % 26;\n    int u = label[i], v = label[j];\n    trace(i, j, u, v, diff);\n    if (u == v && diff) {\n      found = true;\n      break;\n    }\n    if (!d.count(u) && !d.count(v)) {\n      d[u] = diff;\n      d[v] = 0;\n    } else if (!d.count(u)) {\n      d[u] = (d[v] + diff) % 26;\n    } else if (!d.count(v)) {\n      d[v] = (d[u] + 26 - diff) % 26;\n    } else {\n      if ((d[u] - d[v] + 26) % 26 != diff) {\n        found = true;\n        break;\n      }\n    }\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tvector<P> _vec;\n\trep(i,vec[k].size()){\n\t\tif(vec[k][i].fr == k && vec[k][i].sc == S.size()-1-k){}\n\t\telse _vec.pb(vec[k][i]);\n\t}\n\tvec = _vec;\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n//S[k] += d;\n//if(S[k] > 'z')S[k] -= 26;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n//S[S.size()-1-k] += d;\n//if(S[S.size()-1-k] > 'z')S[S.size()-1-k] -= 26;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tvec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,LL>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A;\n\t\tA = A * A;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, 0}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(5, id);\n\t\t\tLL po3 = fast(3, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total3 -= po3;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, total3}) == ms.end()) ms[{total, total3}] = i;\n\t\tpar[i] = ms[{total, total3}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mod = 'z' - 'a' + 1;\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\n\tint m;\n\tcin >> m;\n\tvector<vector<int>> graph(n/2 + 1);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a;\n\t\ta = min(a, n-a);\n\t\tb = min(b, n-b);\n\t\tif(a != b) {\n\t\t\tgraph[a].push_back(b);\n\t\t\tgraph[b].push_back(a);\n\t\t}\n\t}\n\n\tvector<int> vec(s.size()/2);\n\tfor(int i = 0; i < n/2; ++i) {\n\t\tvec[i] = int(s[i]) - int(s[n-1-i]);\n\t\tvec[i] %= mod;\n\t\tvec[i] += mod;\n\t\tvec[i] %= mod;\n\t}\n\n\tn  = n/2+1;\n\n\tvector<bool> seen(n, false);\n\tfunction<void(int, vector<int>&)> dfs = [&](int node, vector<int> &comp) {\n\t\tif(seen[node]) return;\n\t\tseen[node] = true;\n\t\tcomp.push_back(node);\n\t\tfor(int ch : graph[node]) dfs(ch, comp);\n\t};\n\n\tvector<int> finish(n, -1);\n\tvector<int> start(n, -1);\n\tvector<int> total;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(!seen[i]) {\n\t\t\tvector<int> comp;\n\t\t\tdfs(i, comp);\n\t\t\tfor(int j = 1; j < comp.size(); ++j) {\n\t\t\t\tstart[comp[j-1]] = total.size();\n\t\t\t\tfinish[comp[j]] = total.size();\n\t\t\t\ttotal.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint sum = 0;\n\tbool can = true;\n\tfor(int i = 0; i < n-1; ++i) {\n\t\tvec[i] += sum;\n\t\tvec[i] %= mod;\n\t\tif(vec[i] != 0) {\n\t\t\tif(start[i] == -1) can = false;\n\t\t\telse {\n\t\t\t\tsum += mod - vec[i];\n\t\t\t\tsum %= mod;\n\t\t\t\ttotal[start[i]] = (mod - vec[i]) % mod;\n\t\t\t}\n\t\t}\n\t\tif(finish[i+1] != -1) {\n\t\t\tsum += mod - total[finish[i+1]];\n\t\t\tsum %= mod;\n\t\t}\n\t}\n\n\tif(can) {\n\t\tcout << \"YES\" << endl;\n\t} else {\n\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint n,q,l,r,pset[100007];\nint it[400007];\nset <int> query[100007];\nvoid upd(int k,int l,int r,int L,int R,int val){\n\tif(l>R || r<L || L>R) return;\n\tif(l>=L && r<=R){\n\t\tit[k]+=val;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tupd(k*2,l,mid,L,R,val);\n\tupd(k*2+1,mid+1,r,L,R,val);\n}\nint get(int k,int l,int r,int pos){\n\tif(l==r && l==pos) return it[k];\n\tint mid=(l+r)/2;\n\tif(pos<=mid) return it[k]+get(k*2,l,mid,pos);\n\telse return it[k]+get(k*2+1,mid+1,r,pos);\n}\nint fset(int x){\n\tif(pset[x]==x) return x;\n\treturn pset[x]=fset(pset[x]);\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>s;\n\tn=(int)s.length();\n\tcin>>q;\n\tfor(int i=1;i<=q;i++){\n\t\tcin>>l>>r;\n\t\tif(l<=(n+1)/2 && r>=(n+1)/2){\n\t\t\tr=n-r+1;\n\t\t\tif(l>r) swap(l,r);\n\t\t\tif(l==r) continue;\n\t\t\tr--;\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse if(l<=(n+1)/2){\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse{\n\t\t\tquery[n-r+1].insert(n-l+1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) pset[i]=i;\n\tfor(int i=1;i<=n/2;i++){\n\t\t//cout<<(s[i-1]-s[n-i]+26)%26<<endl;\n\t\tint cal=((s[i-1]-s[n-i]+26)%26-get(1,1,n/2,i)+26)%26;\n\t\t//cout<<i<<\" \"<<cal<<endl;\n\t\tif(cal!=0 && query[fset(i)].empty()){\n\t\t\tcout<<\"NO\";\n\t\t\treturn 0;\n\t\t}\n\t\telse if(i==n/2) continue;\n\t\telse{\n\t\t\tint cur=fset(i);\n\t\t\tauto it=query[cur].begin();\n\t\t\tquery[cur].erase(it);\n\t\t\tupd(1,1,n/2,i,*it,cal);\n\t\t\tint nxt=fset(*it+1);\n\t\t\tif(query[cur].size()<query[nxt].size()){\n\t\t\t\tpset[cur]=nxt;\n\t\t\t\tfor(auto jt=query[cur].begin();jt!=query[cur].end();jt++){\n\t\t\t\t\tquery[nxt].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpset[nxt]=cur;\n\t\t\t\tfor(auto jt=query[nxt].begin();jt!=query[nxt].end();jt++){\n\t\t\t\t\tquery[cur].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s; cin >> s;\n    int m = s.size();\n    int n; cin >> n;\n    vector<int> l(n), r(n);\n    vector<vector<int>> sg(m);\n    for (int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n        --l[i], --r[i];\n        if (m % 2 == 0) {\n            if (l[i] < m / 2 && r[i] >= m / 2) {\n                int g = min(m / 2 - l[i], r[i] - m / 2 + 1);\n                int tl = m / 2 - g, tr = m / 2 + g - 1;\n                if (tl == l[i] && tr == r[i]) continue;\n                if (tl == l[i]) l[i] = tr + 1;\n                else r[i] = tl - 1;\n            }\n        } else {\n            if (l[i] <= m / 2 && r[i] >= m / 2) {\n                int g = min(m / 2 - l[i], r[i] - m / 2);\n                int tl = m / 2 - g, tr = m / 2 + g;\n                if (tl == l[i] && tr == r[i]) continue;\n                if (tl == l[i]) l[i] = tr + 1;\n                else r[i] = tl - 1;\n            }\n        }\n        // printf(\"l = %d r = %d\\n\", l[i], r[i]);\n        if (r[i] < m / 2) sg[l[i]].push_back(r[i]);\n        else sg[m - 1 - r[i]].push_back(m - 1 - l[i]);\n    }\n    for (int i = 0; i < m / 2; ++i) {\n        if (sg[i].empty()) continue;\n        sort(sg[i].begin(), sg[i].end());\n        sg[i].resize(unique(sg[i].begin(), sg[i].end()) - sg[i].begin());\n        int r = sg[i][0];\n        for (int j = 1; j < sg[i].size(); ++j) sg[r + 1].push_back(sg[i][j]);\n        sg[i].resize(1);\n    }\n    vector<int> t(m + 1);\n    int sum = 0;\n    for (int i = 0; i < m / 2; ++i) {\n        sum += t[i];\n        int ch = ((((s[i] - 'a') + sum) % 26) + 26) % 26;\n        int diff = ((s[m - 1 - i] - 'a') - ch + 26) % 26;\n        // printf(\"i = %d diff = %d\\n\", i, diff);\n        if (diff != 0 && sg[i].empty()) {\n            puts(\"NO\");\n            return 0;\n        }\n        if (diff != 0) {\n            sum += diff;\n            t[sg[i][0] + 1] += 26 - diff;\n        }\n    }\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) {string s; ist >> s; return ist;}\nbool Inside(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* E mondai*/\n\nstring s;\nint N;\nint L[100000], R[100000];\nvector<IntMod<26>> ss;\n\nvoid Add(int i, int j, IntMod<26> val) {\n\tss[i] += val;\n\tss[j] -= val;\n}\n\nint main() {\n\tcin >> s >> N;\n\tREP(i, 0, N) {\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t\tif (L[i] > s.size() / 2) L[i] = s.size() - L[i];\n\t\tif (R[i] > s.size() / 2) R[i] = s.size() - R[i];\n\t\tif (L[i] > R[i]) swap(L[i], R[i]);\n\t}\n\n\tREP(i, 0, s.size() / 2) {\n\t\tss.push_back(s[s.size() - i - 1] - s[i]);\n\t}\n\tss.push_back(0);\n\tadjacent_difference(ss.begin(), ss.end(), ss.begin());\n\n\tPriorityQ<PP> Q;\n\tREP(i, 0, N) {\n\t\tQ.push(PP(L[i], R[i]));\n\t}\n\t\n\tPP prev(-1, 0);\n\twhile (!Q.empty()) {\n\t\tPP p = Q.top(); Q.pop();\n\t\tif (p.first == p.second) continue;\n\t\tif (prev.first == p.first) {\n\t\t\tQ.push(PP(prev.second, p.second));\n\t\t\tcontinue;\n\t\t}\n\t\tAdd(p.first, p.second, -ss[p.first]);\n\t\tprev = p;\n\t}\n\tYESNO(all_of(ss.begin(), ss.end(), [](IntMod<26> i) {return i == 0; }));\n\treturn 0;\n}\n\n/*-------------------------*/\n/*-----    二分探索   -----*/\n/*-------------------------*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      (ws[x] += ws[p[x]]) %= 26;\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    w += 26;\n    w %= 26;\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    w += 26;\n    w %= 26;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return (weight(y) - weight(x) + 26) % 26;\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1p\n      if(idx > other) continue;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          int diff2 = (S[other] - S[idx] + 26) % 26;\n          if(diff != diff2) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tint m = s.size() / 2;\n\t\tif (l == m && r == m) continue;\n\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t\tif (l >= m) l--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tm = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvector<ll> v;\n\t\t\tfor (auto cur : st[i]) {\n\t\t\t\tv.push_back(cur);\n\t\t\t}\n\t\t\tll vl = v[rand() % v.size()];\n\t\t\tadd[vl + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint L[110000],R[110000];\nint n,m,A[110000],len,a[110000];\nchar ch[110000];\nstruct tree{\n\tint w,l,r,d;\n}t[110000];\nint merge(int k1,int k2){\n\tif (k1==0||k2==0) return k1+k2;\n\tif (t[k1].w>t[k2].w) swap(k1,k2);\n\tt[k1].r=merge(k2,t[k1].r);\n\tif (t[t[k1].l].d<t[t[k1].r].d) swap(t[k1].l,t[k1].r);\n\tt[k1].d=t[t[k1].r].d+1;\n\treturn k1;\n}\nint LL;\nint root[110000];\nvoid add(int k1,int k2){\n\tLL++; t[LL]=(tree){k2,0,0,0};\n\troot[k1]=merge(root[k1],LL);\n}\nint main(){\n\tscanf(\"%s\",ch+1); len=strlen(ch+1); n=len/2;\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&L[i],&R[i]);\n\tfor (int i=1;i<=n;i++) A[i]=(ch[len-i+1]-ch[i]+26)%26;\n\tfor (int i=1;i<=m;i++){\n\t\tint k1=L[i],k2=R[i];\n\t\tif (k2*2<=len+1) add(k1,k2);\n\t\telse if (k1*2>=len+1){\n\t\t\tadd(len-k2+1,len-k1+1);\n\t\t} else if (len-L[i]+2<=R[i])\n\t\t\tadd(len-R[i]+1,L[i]-1);\n\t\telse if (len-R[i]>=L[i])\n\t\t\tadd(L[i],len-R[i]);\n\t}\n\tmemset(a,0x00,sizeof a);\n\tfor (int i=1;i<=n;i++){\n\t\twhile (root[i]&&t[root[i]].w<i) root[i]=merge(t[root[i]].l,t[root[i]].r);\n\t\tif (root[i]){\n\t\t\ta[i]=t[root[i]].w;\n\t\t\troot[a[i]+1]=merge(merge(root[a[i]+1],t[root[i]].l),t[root[i]].r);\n\t\t}\n\t}\n\tfor (int i=n;i;i--) A[i]=(A[i]-A[i-1]+26)%26;\n\t//for (int i=1;i<=n;i++) cout<<A[i]<<\" \"; cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]==0&&A[i]){\n\t\t\tprintf(\"NO\\n\"); return 0;\n\t\t}\n\t\tint num=A[i];\n\t\tif (num) A[a[i]+1]=(A[a[i]+1]+num+26)%26;\n\t}\n\tprintf(\"YES\\n\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nstring s;\n\n\nstatic const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n\nll all[2 * MAX_SIZE - 1], part[2 * MAX_SIZE - 1]; // segment tree\n\n//区間[a, b)に値xを加算する.\nvoid add(int a, int b, ll x, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (a <= l && r <= b){ //[l, r)が[a, b)に完全に内包されていれば\n        all[k] += x; //[l, r)の全ての区間が持つ値としてxを足す.\n    }\n    else if (l < b && a < r){ //[l, r)と[a, b)が交差していれば\n        part[k] += (min(b, r) - max(a, l)) * x;  //交差している分の値を, 部分的な和を持つノードに加算する.\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子でも同じ処理を行う.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃.\n    }\n}\n\nll sum(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (b <= l || r <= a){ //[a, b)と[l, r)が全く交差しない場合\n        return (0);\n    }\n    else if (a <= l && r <= b){ //完全に内包されていれば\n        return (all[k] * (r - l) + part[k]);\n    }\n    else { //[l, r)と[a, b)が交差していれば\n        ll res;\n        res = (min(b, r) - max(a, l)) * all[k]; //そのノードの全ての要素が持つ値のうち, [a, b)に属すものの分だけを加算する.\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2); //子ノードで和を求める.\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r); //〃\n        return (res);\n    }\n}\n\n\nvoid update(map<int,int> &ma1, map<int,int> &ma2, pii x){\n\tint a = x.fi;\n\tint b = x.se;\n\tif(ma1[a]==-1){\n\t\tma1[a] = b;\n\t\tma2[b] = a;\n\t\treturn;\n\t}\n\tpii y = minmax(a, ma1[a]);\n\tint c = y.fi;\n\tint d = y.se;\n\tif(x==y) return;\n\tif(c==a){\n\t\tif(b<d){\n\t\t\tma2[d] = -1;\n\t\t\tma1[a] = b;\n\t\t\tma2[b] = a;\n\t\t\tupdate(ma1, ma2, pii(b+1,d));\n\t\t}\n\t\telse{\n\t\t\tupdate(ma1, ma2, pii(d+1,b));\n\t\t}\n\t}\n\telse{\n\t\tassert(d==b);\n\t\tif(a<c){\n\t\t\tupdate(ma1, ma2, pii(a, c-1));\n\t\t}\n\t\telse{\n\t\t\tma1[a] = b;\n\t\t\tma2[b] = a;\n\t\t\tma1[c] = -1;\n\t\t\tupdate(ma1, ma2, pii(c,a-1));\n\t\t}\n\t}\n}\n\nint ch(int x){\n\tint ret = s[x]-'a';\n\tret += sum(x, x+1);\n\treturn ret%26;\n}\n\nvoid func(int l, int r, pii a){\n\twhile(ch(l) != ch(r)){\n\t\tadd(a.fi, a.se+1,1);\n\t}\n}\n\n\nbool mainmain(){\n\tcin>>s;\n\tint n = s.size();\n\tmap<int,int> l1;\n\tmap<int,int> l2;\n\tmap<int,int> r1;\n\tmap<int,int> r2;\n\trep(i,n){\n\t\tl1[i] = -1;\n\t\tl2[i] = -1;\n\t\tr1[i] = -1;\n\t\tr2[i] = -1;\n\t}\n\tint m;\n\tcin>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\t// if(a==0&&b==n-1) continue;\n\t\tif(a == n-1-b) continue;\n\t\tint aa = a;\n\t\tint bb = n-1-b;\n\t\tint c,d;\n\t\tif(aa>bb){\n\t\t\tc = bb;\n\t\t\td = a-1;\n\t\t}\n\t\telse{\n\t\t\tc = b+1;\n\t\t\td = n-1-aa;\n\t\t}\n\t\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t\tif(b-a<d-c){\n\t\t\tif(a<c) update(l1, l2,pii(a,b));\n\t\t\telse update(r1, r2,pii(a,b));\n\t\t}\n\t\telse if(b-a==d-c){\n\t\t\tif(a<c){\n\t\t\t\tupdate(l1, l2,pii(a,b));\n\t\t\t\tupdate(r1, r2,pii(c,d));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tupdate(r1, r2,pii(a,b));\n\t\t\t\tupdate(l1, l2,pii(c,d));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(c<a) update(l1, l2,pii(c,d));\n\t\t\telse update(r1, r2, pii(c,d));\n\t\t}\n\t\t// rep(j,n){\n\t\t// \tif(l1[j]!=-1) cout<<\"l \"<<j<<\" \"<<l1[j]<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t}\n\t// rep(j,n){\n\t// \tif(l1[j]!=-1) cout<<\"l \"<<j<<\" \"<<l1[j]<<endl;\n\t// }\n\t// cout<<endl;\n\t// rep(j,n){\n\t// \tif(r1[j]!=-1) cout<<\"r \"<<j<<\" \"<<r1[j]<<endl;\n\t// }\n\t// cout<<endl;\n\tint ll = 0;\n\tint rr = n-1;\n\twhile(ll<rr){\n\t\tif(l1[ll]==-1){\n\t\t\tif(r2[rr]==-1){\n\t\t\t\t// cout<<1<<endl;\n\t\t\t\tif(ch(ll) != ch(rr)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// cout<<2<<endl;\n\t\t\t\tfunc(ll,rr,minmax(r2[rr],rr));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(r2[rr]==-1){\n\t\t\t\t// cout<<3<<endl;\n\t\t\t\tfunc(ll,rr,minmax(ll,l1[ll]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// cout<<4<<endl;\n\t\t\t\tif(l1[ll]-ll < rr-r2[rr]){\n\t\t\t\t\tfunc(ll,rr,minmax(ll,l1[ll]));\n\t\t\t\t\tupdate(r1,r2,pii(r2[rr], r2[rr]+l1[ll]-ll));\n\t\t\t\t}\n\t\t\t\telse if(l1[ll]-ll > rr-r2[rr]){\n\t\t\t\t\tfunc(ll,rr,minmax(r2[rr],rr));\n\t\t\t\t\tupdate(l1,l2,pii(l1[ll]-(rr-r2[rr]), l1[ll]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfunc(ll,rr,minmax(r2[rr],rr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout<<ll<<\" \"<<ch(ll)<<\" \"<<rr<<\" \"<<ch(rr)<<endl;\n\t\tll++;\n\t\trr--;\n\t}\n\treturn true;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    cout<<(mainmain()?\"YES\":\"NO\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"NO\"); exit(0); }\nvoid fg(vector<int> G[], int a, int b) { G[a].eb(b); G[b].eb(a); }\n\nconst int MAXN = 100005;\nconst int MAXK = 100005;\n\nvector<int> G[MAXN];\nbitset<MAXN> chk;\n\nint D[MAXN], E[MAXN];\n\nint B[MAXK], C[MAXK];\nchar A[MAXN];\n\nint N, K;\n\nint f(int i) {\n\tint ret = E[i]; chk[i] = true;\n\tfor(int v : G[i]) if(!chk[v]) {\n\t\tret = (ret + f(v)) % 26;\n\t}\n\treturn ((ret % 26) + 26) % 26;\n}\n\nint main() {\n\tscanf(\" %s\", A+1);\n\tN = int(strlen(A+1));\n\tscanf(\"%d\", &K);\n\tfor(int i = 1; i <= K; i++) scanf(\"%d%d\", &B[i], &C[i]);\n\n\tif(N&1) {\n\t\tN++;\n\t\tfor(int i = N-1; N/2 <= i; i--) A[i+1] = A[i];\n\t\tA[N/2] = A[N/2+1];\n\t\tfor(int i = 1; i <= K; i++) {\n\t\t\tif(N/2 < B[i]) B[i]++;\n\t\t\tif(N/2 < C[i]) C[i]++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= K; i++) {\n\t\tif(C[i] <= N/2) continue;\n\t\tif(N/2 < B[i]) {\n\t\t\tB[i] = N+1-B[i];\n\t\t\tC[i] = N+1-C[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint l = N/2-B[i]+1, r = C[i]-N/2;\n\t\tif(l > r) swap(l, r);\n\t\tB[i] = N/2-r+1;\n\t\tC[i] = N/2-l;\n\t}\n\n\tN /= 2;\n\tfor(int i = 1; i <= N; i++)\n\t\tD[i] = (A[N*2+1-i] - A[i] + 26) % 26;\n\tfor(int i = 1; i <= N+1; i++)\n\t\tE[i] = (D[i] - D[i-1] + 26) % 26;\n\tfor(int i = 1; i <= K; i++) C[i]++;\n\tN++;\n\n\tfor(int i = 1; i <= K; i++) if(B[i] < C[i]) fg(G, B[i], C[i]);\n\tfor(int i = 1; i <= N; i++) if(!chk[i]) {\n\t\tint t = f(i);\n\t\tif(t) fuk();\n\t}\n\n\tfor(int i = 1; i <= N; i++) if(!chk[i] && E[i]) fuk();\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\n#define N 100010\nvector<ll> g[N];\nll c[N],d[N];\nbool vis[N];\nll dfs(ll x){\n  if(vis[x])return 0;\n  vis[x]=1;\n  ll res=d[x];\n  for(auto y:g[x]){\n    res+=dfs(y);\n  }\n  return res;\n}\nint main(){\n  ll n,m;string s;\n  cin>>s>>m; n=s.size();\n  for(int i=0;i<n/2;i++){\n    c[i+1]=s[n-1-i]-s[i];\n  }c[0]=c[n/2+1]=0;\n  for(int i=0;i<n/2+2;i++){\n    d[i]=c[i+1]-c[i];\n    vis[i]=0;\n    //cout<<d[i]<<\" \";\n  }//cout<<endl;\n  for(int i=0;i<m;i++){\n    ll l,r;cin>>l>>r;\n    ll cl=(n+1)/2,cr=(n+2)/2;\n    bool flag=(l<=cl)&(cr<=r);\n    if(l<=cl)l=cl-l; else l=l-cr;\n    if(r<=cl)r=cl-r; else r=r-cr;\n    //cout<<l<<\" \"<<r<<endl;\n    if(l<r)swap(l,r);\n    l=(n+1)/2-l,r=(n+1)/2-r;\n    if(flag)r--; l--;\n    //cout<<l<<\" \"<<r<<endl;\n    g[l].push_back(r);\n    g[r].push_back(l);\n  }\n  bool ok=1;\n  for(int i=0;i<n/2+2;i++){\n    if(dfs(i)%26!=0)ok=0;\n  }\n  cout<<(ok?\"YES\":\"NO\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"NO\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 200005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// Union find\nstruct uf {\n  vi d;\n  uf(){}\n  uf(int mx):d(mx,-1){}\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x); y = root(y);\n    if(x == y) return false;\n    if(d[x] > d[y]) swap(x,y);\n    d[x] += d[y]; d[y] = x;\n    return true;\n  }\n  int size(int x) { return -d[root(x)];}\n};\n//\n\n\nint main() {\n  string s;\n  cin>>s;\n  s += 'a';\n  int n = sz(s);\n  char pre = 'a';\n  vi d;\n  rep(i,n) {\n    d.pb((s[i]-pre+26)%26);\n    pre = s[i];\n  }\n  int pn = n;\n  n = (n+1)/2;\n  srep(i,n,pn) {\n    d[pn-1-i] += d[i];\n  }\n\n  int m;\n  scanf(\"%d\",&m);\n  auto f = [&](int v) {\n    if (v < n) return v;\n    return pn-1-v;\n  };\n  uf t(n);\n  rep(i,m) {\n    int l,r;\n    scanf(\"%d%d\",&l,&r);\n    --l;\n    l = f(l);\n    r = f(r);\n    t.unite(l,r);\n  }\n  vi sum(n);\n  rep(i,n) sum[t.root(i)] += d[i];\n  rep(i,n) if (sum[i]%26) dame;\n  cout<<\"YES\"<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n \nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n \nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\tvec[k].clear();\n\treturn solve(k+1,a,b);\n}\n \n \nint main(){\n\tstatic int n;\n\tint l,r;\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tl --;\n\t\tr --;\n\t\tif(l > r)swap(l,r);\n\t\tif(l != S.size()-1-r)vec[min(l,(int)(S.size())-1-r)].pb(P(l,r));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#define N 100005\n\nchar str[N]; int len, mid;\nstd::pair<int, int> ops[N]; int opscnt;\n\ninline void merge_ops()\n{\n\tstatic std::set<int> rs[N];\n\tfor(int i = 0; i < opscnt; ++i)\n\t\trs[ops[i].first].insert(ops[i].second);\n\n\topscnt = 0;\n\tfor(int l = 1; l <= mid; ++l)\n\t{\n\t\tstd::set<int> &cur = rs[l];\n\t\tif(cur.empty()) continue;\n\n\t\tint r = *cur.begin();\n\t\tops[opscnt++] = std::make_pair(l, r);\n\t\t//printf(\"f->%d %d\\n\", l, r);\n\t\tcur.erase(cur.begin());\n\n\t\tstd::set<int> &dest = rs[r + 1];\n\t\tif(cur.size() < dest.size())\n\t\t\tfor(int i: cur) dest.insert(i);\n\t\telse\n\t\t{\n\t\t\tfor(int i: dest) cur.insert(i);\n\t\t\tdest.swap(cur);\n\t\t}\n\t}\n}\n\ninline bool solve()\n{\n\tstatic int pre[N];\n\tpre[0] = 0;\n\tpre[1] = str[1] - 'a';\n\tfor(int i = 2; i <= mid; ++i)\n\t{\n\t\tpre[i] = str[i] - str[i - 1];\n\t\tpre[i] = (pre[i] + 26) % 26;\n\t}\n\n\tint k = 1;\n\tfor(int o = 0; o < opscnt; ++o)\n\t{\n\t\tconst std::pair<int, int> &cur = ops[o];\n\t\tfor(; k <= cur.first; ++k)\n\t\t{\n\t\t\tpre[k] += pre[k - 1];\n\t\t\tpre[k] = (pre[k] + 26) % 26;\n\t\t}\n\t\tint d = int(str[len - cur.first + 1]) - pre[cur.first] - 'a';\n\t\tpre[cur.first] += d;\n\t\tpre[cur.first] = (pre[cur.first] + 26) % 26;\n\t\tpre[cur.second + 1] -= d;\n\t\tpre[cur.second + 1] = (pre[cur.second + 1] + 26) % 26;\n\t}\n\tfor(; k <= mid; ++k)\n\t{\n\t\tpre[k] += pre[k - 1];\n\t\tpre[k] = (pre[k] + 26) % 26;\n\t}\n\n\tfor(int i = 1; i <= mid; ++i)\n\t{\n\t\tif(pre[i] != str[len - i + 1] - 'a')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint _;\n\tscanf(\"%s%d\", str + 1, &_);\n\tlen = strlen(str + 1);\n\tmid = len >> 1;\n\n\topscnt = 0;\n\tfor(int i = 0; i < _; ++i)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif(l - 1 > (len - r))\n\t\t{\n\t\t\tl = len - l + 1;\n\t\t\tr = len - r + 1;\n\t\t\tstd::swap(l, r);\n\t\t}\n\t\tif(r > mid) r = len - r;\n\n\t\tif(l <= r)\n\t\t\tops[opscnt++] = std::make_pair(l, r);\n\t}\n\n\tmerge_ops();\n\n\tif(solve()) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nstring s;\nint n, sz;\nint a[N];\nint par[N];\nint sum[N];\n\nint find(int p) { return p == par[p] ? p : par[p] = find(par[p]); }\nvoid join(int p, int q) {\n\tp = find(p); q = find(q);\n\tif (p == q) return;\n\tpar[p] = q;\n\tsum[q] += sum[p]; sum[q] %= 26; sum[p] = 0;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> s;\n\tsz = s.size();\n\ta[1] = s[0] - 'a';\n\tfor (int i = 2; i <= sz; ++i) a[i] = s[i-1] - s[i-2];\n\ta[sz + 1] = 'a' - s[sz-1];\n\t++sz;\n\n\tfor (int i = 1; i <= sz; ++i) a[i] = (a[i] + 26) % 26;\n\tfor (int i = 1; i <= sz; ++i) par[i] = i, sum[i] = a[i];\n\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint l, r; cin >> l >> r; ++r;\n\t\tjoin(l, r);\n\t}\n\n\tfor (int i = 1; i <= sz / 2; ++i) join(i, sz + 1 - i);\n\n\tfor (int i = 1; i <= sz; ++i) if (i == find(i)) {\n\t\tif (sum[i] != 0) return cout << \"NO\\n\", 0;\n\t}\n\tcout << \"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n\nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=n/2+1) {a[++m0].l=n-r+1;a[m0].r=n-max(l,n/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+35;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+35) {puts(\"NO\");return 0;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==1 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\t//printf(\"%d %d %d\\n\",i,a[i].l,a[i].r);\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\t//printf(\"%d\\n\",fa[5]);\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\t//printf(\"%d %d\\n\",head[i],d[i]);\n\t\tif (head[i]==0&&d[i]) {puts(\"NO\");return 0;}\n\t\tif (!head[i]) continue;\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;//printf(\"%d\\n\",find(5));\n\t\tfa[i+m0*2+1]=x+m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X first\n#define Y second\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\nconst int N = 100010;\nchar s[N];\nint n,a[N];\nint fa[N],S[N];\nint find(int x){\n\tif(fa[x]==x) return x;\n\treturn fa[x] = find(fa[x]);\n}\ninline void merge(int x,int y){\n\tx=find(x),y=find(y);\n\tfa[x]=y;\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tint len = strlen(s+1);\n\tint m = len/2;\n\tfor(int i =1;i<=m;i++) a[i] = (s[i]-s[len-i+1]+26)%26;\n\tfor(int i =m+1;i>=2;i--) a[i] = (a[i]-a[i-1]+26)%26;\n\tfor(int i =1;i<=m+2;i++) fa[i] = i;\n\tscanf(\"%d\",&n);\n\tint l,r;\n\tfor(int i = 1;i<=n;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(r<=m) merge(l,r+1);\n\t\telse if(l>m) merge(len-r+1,min(m+1,len-l+1+1));\n\t\telse {\n\t\t\t//merge(1,2);\n\t\t\tr  = len-r+1;\n\t\t\t//cout<<l<<' '<<r<<endl;\n\t\t\tif(r<l) merge(r,l);\n\t\t\telse if(r>l) merge(l,r);\n\t\t\t//merge(min(l,len-r+1),max(l,len-r+1)+1);\n\t\t}\n\t}\n\tfor(int i = 1;i<=m+1;i++)  (S[find(i)]+=a[i])%=26;\n\t//for(int i =1;i<=m+1;i++) cout<<find(i)<<endl;\n\tS[find(m+1)] = 0;\n\tbool flag = true;\n\tfor(int i =1;i<=m;i++) if(S[find(i)]!=0) flag = false;\n\tif(flag) puts(\"YES\"); else puts(\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define all(v) begin(v), end(v)\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\nint a[MAXN];\n\nstd::vector<int> G[MAXN];\n\nvoid change(int L, int R, int v) {\n    //cout << L << '-'<<R<<\"\\n\";\n    (a[L] += v) %= 26;\n    (a[R + 1] -= v) %= 26;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            x = n - x + 1;\n            y = n - y + 1;\n            std::swap(x, y);\n        }\n        if (x <=mm && y >mm) {\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        if (x > y) continue;\n        G[x].push_back(y);\n    }\n    for (int i = 1; i + i <= n; ++i) {\n        if (!G[i].empty()) {\n            std::sort(all(G[i]));\n            G[i].erase(std::unique(all(G[i])), end(G[i]));\n            int k = G[i].size();\n            change(i, G[i][0], -a[i]);\n            for (int j = 1; j < k; ++j) {\n                G[G[i][j - 1] + 1].push_back(G[i][j]);\n            }\n        }\n        if (a[i] != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s; cin >> s;\n    int sz = s.size();\n    int n; cin >> n;\n    int l[n], r[n];\n    for (int i = 0; i < n; i++) {\n        cin >> l[i] >> r[i]; l[i]--;\n        if (r[i] <= (sz+1)/2) continue;\n        if (l[i] <= (sz+1)/2) {\n            r[i] = sz - r[i];\n            if (r[i] < l[i]) swap(l[i], r[i]);\n        } else {\n            l[i] = sz - l[i];\n            r[i] = sz - r[i];\n            swap(l[i], r[i]);\n        }\n    }\n\n    int m = sz/2+1;\n    int diff[m];\n    for (int i = 0; i <= sz/2; i++) {\n        s[i] -= s[sz-i-1]; s[sz-i-1] = 0;\n        if (!i) diff[i] = s[i];\n        else diff[i] = (s[i] - s[i-1] + 52) % 26;\n    }\n\n    set<int> e[m];\n    for (int i = 0; i < n; i++) {\n        if (r[i] * 2 > sz) r[i]--;\n        if (l[i] != r[i]) {\n            e[l[i]].emplace(r[i]);\n            e[r[i]].emplace(l[i]);\n        }\n    }\n    vector<bool> vis(m, 0);\n    auto dfs = [&vis, &diff, &e](auto f, int curr) -> int {\n        int ret = 0;\n        vis[curr] = 1;\n        for (auto &to: e[curr]) {\n            if (vis[to]) continue;\n            ret += f(f, to);\n        }\n        return ret + diff[curr];\n    };\n    bool ok = true;\n    for (int i = 0; i < m; i++) {\n        if (!vis[i]) ok &= (dfs(dfs, i) % 26 == 0);\n    }\n    if (ok) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 1e5 + 7;\nstring s;\nint q, l[N], r[N], sum[N], d[N];\nvector <int> g[N];\nbool used[N];\nint n;\n\nbool have = 0;\nint dfs(int u) {\n    have |= u == 1;\n    have |= u > n;\n    int ans = d[u];\n    used[u] = 1;\n    for (int v : g[u]) {\n        if (!used[v]) {\n            ans += dfs(v);\n        }   \n    }\n    return ans;\n}   \n\nint get(int i) {\n    return (s[i] - s[i - 1] + 26) % 26;\n}\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    cin >> s;\n    n = s.size();\n    s = \"a\" + s + \"a\";\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> l[i] >> r[i];\n        ++r[i];\n        g[l[i]].app(r[i]);\n        g[r[i]].app(l[i]);\n\n        //cout << \"edge \" << l[i] << ' ' << r[i] << endl;\n\n    }    \n    for (int i = 1; i <= n / 2; ++i) {\n        int a = get(i + 1), b = get(n - i + 1);\n\n        //cout << \"edge \" << i + 1 << ' ' << n - i + 1 << endl;\n\n        g[i + 1].app(n - i + 1);\n        g[n - i + 1].app(i + 1);\n        d[i + 1] = a;\n        d[n - i + 1] = b;\n    }   \n    /*\n    for (int i = 1; i <= n; ++i) {\n        cout << d[i] << ' ';\n    }   \n    cout << endl;\n    */\n    for (int i = 0; i < N; ++i) {\n        if (!used[i]) {\n            have = 0;\n            int s = dfs(i);\n            if (s % 26 && !have) {\n                cout << \"NO\" << endl;\n                //cout << i << ' ' << s << endl;\n                exit(0);\n            }   \n        }   \n    }\n    cout << \"YES\" << endl;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=100010;\nchar s[N];\nint fa[N],v[N],c[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main() {\n    int n,m,p;\n    scanf(\"%s%d\",s+1,&m);\n    n=strlen(s+1),p=n/2+1;\n    for(int i=1;i<p;i++) fa[i]=i,s[i]-=s[n-i+1],c[i]=s[i]-s[i-1];\n    fa[p]=p,c[p]=-s[p-1];\n    while(m--) {\n\tint l=gi(),r=gi(),t=1;\n\tif(n&1) {\n\t    if(l==p&&r==p) continue;\n\t    if(l==p) ++l;\n\t    if(r==p) --r;\n\t}\n\tif(l<p&&r>=p) r=n-r+1,t=0;\n\telse if(l>=p) l=n-l+1,r=n-r+1;\n\tif(l>r) swap(l,r);\n\tfa[find(l)]=find(r+t);\n    }\n    for(int i=1;i<=p;i++) v[find(i)]+=c[i];\n    for(int i=1;i<=p;i++)\n\tif(i==find(i)&&v[i]%26) return puts(\"NO\"),0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\ntemplate <class OperatorMonoid>\nstruct dual_segment_tree {\n    typedef OperatorMonoid monoid_type;\n    typedef typename OperatorMonoid::underlying_type operator_type;\n    typedef typename OperatorMonoid::target_type underlying_type;\n    int n;\n    vector<operator_type> f;\n    vector<underlying_type> a;\n    OperatorMonoid op;\n    dual_segment_tree() = default;\n    dual_segment_tree(int a_n, underlying_type initial_value, OperatorMonoid const & a_op = OperatorMonoid()) : op(a_op) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(n, initial_value);\n        f.resize(n-1, op.unit());\n    }\n    underlying_type point_get(int i) { // 0-based\n        underlying_type acc = a[i];\n        for (i = (i+n)/2; i > 0; i /= 2) { // 1-based\n            acc = op.apply(f[i-1], acc);\n        }\n        return acc;\n    }\n    void range_apply(int l, int r, operator_type z) { // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply(0, 0, n, l, r, z);\n    }\n    void range_apply(int i, int il, int ir, int l, int r, operator_type z) {\n        if (l <= il and ir <= r) { // 0-based\n            if (i < f.size()) {\n                f[i] = op.append(z, f[i]);\n            } else {\n                a[i-n+1] = op.apply(z, a[i-n+1]);\n            }\n        } else if (ir <= l or r <= il) {\n            // nop\n        } else {\n            range_apply(2*i+1, il, (il+ir)/2, 0, n, f[i]);\n            range_apply(2*i+2, (il+ir)/2, ir, 0, n, f[i]);\n            f[i] = op.unit();\n            range_apply(2*i+1, il, (il+ir)/2, l, r, z);\n            range_apply(2*i+2, (il+ir)/2, ir, l, r, z);\n        }\n    }\n};\ntemplate <int mod>\nstruct modplus_operator_t {\n    typedef int underlying_type;\n    typedef int target_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return (a + b) % mod; }\n    int apply(int a, int b) const { return (a + b) % mod; }\n};\n\nbool solve(string s, vector<pair<int, int> > const & lrs) {\n    int n = s.length();\n    dual_segment_tree<modplus_operator_t<26> > segtree(n, 0);\n    repeat (i, n) {\n        segtree.range_apply(i, i + 1, s[i] - 'a');\n    }\n    vector<vector<pair<int, int> > > xlrs(n / 2 + 3);\n    auto push = [&](int l, int r) {\n        assert (0 <= l and l <= r and r <= n);\n        if (l == r) return;\n        xlrs[min(l, n - r)].emplace_back(l, r);\n    };\n    for (auto lr : lrs) {\n        int l, r; tie(l, r) = lr;\n        push(l, r);\n    }\n    repeat (k, n / 2) {\n        int l = k, r = n - k;\n        bool complemented = count(whole(xlrs[k]), make_pair(l, r));\n        if (complemented) {\n            xlrs[k].erase(remove(whole(xlrs[k]), make_pair(l, r)), xlrs[k].end());\n            int n = xlrs[k].size();\n            repeat (i, n) {\n                int l1, r1; tie(l1, r1) = xlrs[k][i];\n                if (l == l1) xlrs[k].emplace_back(r1, r);\n                if (r == r1) xlrs[k].emplace_back(l, l1);\n            }\n        }\n        sort(whole(xlrs[k]));\n        xlrs[k].erase(unique(whole(xlrs[k])), xlrs[k].end());\n        if (xlrs[k].empty()) {\n            if (segtree.point_get(l) != segtree.point_get(r - 1)) return false;\n            continue;\n        }\n        repeat (i, xlrs[k].size() - 1) {\n            int l1, r1; tie(l1, r1) = xlrs[k][i];\n            int l2, r2; tie(l2, r2) = xlrs[k][i + 1];\n            if (l == l1 and l == l2) push(r1, r2);\n            if (r == r1 and r == r2) push(l1, l2);\n            if (l == l1 and r == r2 and l2 < r1) push(l2, r1);\n        }\n        int lm = r, rm = l;\n        for (auto lr : xlrs[k]) {\n            int l1, r1; tie(l1, r1) = lr;\n            if (l == l1) setmin(lm, r1);\n            if (r == r1) setmax(rm, l1);\n        }\n        if (lm == r) {\n            segtree.range_apply(rm, r, (segtree.point_get(l) - segtree.point_get(r - 1) + 26) % 26);\n        } else {\n            segtree.range_apply(l, lm, (segtree.point_get(r - 1) - segtree.point_get(l) + 26) % 26);\n        }\n        if (l < lm and lm < rm and rm < r) {\n            push(lm, rm);\n        }\n    }\n    return true;\n}\n\nint main() {\n    string s; int n; cin >> s >> n;\n    vector<pair<int, int> > lrs(n);\n    repeat (i, n) {\n        int l, r; cin >> l >> r; -- l;\n        lrs[i] = { l, r };\n    }\n    bool result = solve(s, lrs);\n    cout << (result ? \"YES\" : \"NO\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD=26;\nclass BIT{\n    int n;\n    vector<int> dat;\n    public:\n    BIT(int n):n(n),dat(n,0){};\n    void add(int pos,int x){\n        pos++;\n        while(pos<=n){\n            dat[pos-1]=(dat[pos-1]+x)%MOD;\n            pos+=(pos & -pos);\n        }\n    }\n    int sum(int pos){\n        pos++;\n        int res=0;\n        while(pos>0){\n            res=res+dat[pos-1];\n            pos-=(pos & -pos);\n        }\n        return (res%MOD+MOD)%MOD;\n    }\n    void debug(){\n        cerr<<\"####\"<<endl;\n        for(int i=0;i<n;i++){\n            cerr<<dat[i]<<\" \";\n        }\n        cerr<<endl;\n    }\n};\nint main(){\n    string s;\n    cin>>s;\n    int erasep=s.size()+2;\n    if(s.size()%2==1){\n        erasep=s.size()/2;\n        string buf;\n        for(int i=0;i<s.size();i++){\n            if(i!=erasep) buf+=s[i];\n        }\n        s=buf;\n    }\n    int n;\n    cin>>n;\n    vector<int> l,r;\n    for(int i=0;i<n;i++){\n        int tmpl,tmpr;\n        cin>>tmpl>>tmpr;\n        tmpl--,tmpr--;\n        if(tmpl==tmpr && tmpl==erasep) continue;\n        if(erasep<=tmpl) tmpl--;\n        if(erasep<=tmpr) tmpr--;\n        l.push_back(tmpl),r.push_back(tmpr);\n    }\n    n=l.size();\n\n    vector<int> v(s.size()/2);\n    for(int i=0;i<v.size();i++){\n        v[i]=(int)(s[s.size()-1-i])-(int)(s[i]);\n    }\n\n    vector<set<int>> com(v.size());\n    for(int i=0;i<n;i++){\n        if(r[i]<v.size()){\n            com[l[i]].insert(r[i]);\n        }\n        else if(v.size()<=l[i]){\n            com[s.size()-1-r[i]].insert(s.size()-1-l[i]);\n        }\n        else{\n            int dl=v.size()-l[i];\n            int dr=r[i]-v.size()+1;\n            if(dl<dr){\n                com[s.size()-1-r[i]].insert(v.size()-1-dl);\n            }\n            if(dl>dr){\n                com[l[i]].insert(v.size()-1-dr);\n            }\n        }\n    }\n    BIT bit(v.size()+1);\n    for(int i=0;i<v.size();i++){\n        if(com[i].empty()){\n            int x=bit.sum(i)+v[i];\n            if(x%MOD!=0){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n        else{\n            int x;\n            int pre=-1;\n            for(auto &e:com[i]){\n                if(pre==-1){\n                    pre=e;\n                    x=e;\n                }\n                else{\n                    com[pre+1].insert(e);\n                    pre=e;\n                }\n            }\n            int y=-(bit.sum(i)+v[i]);\n            bit.add(i,y);\n            bit.add(x+1,-y);\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len + 1);\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    for (int i = len; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    x[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        r[i]++;\n    }\n    vector<int> root(len + 1), sz(len + 1);\n    iota(root.begin(), root.end(), 0);\n    fill(sz.begin(), sz.end(), 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    vector<int> summ(len + 1);\n    for (int i = 1; i <= len; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i <= len; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    cout << \"YES\", exit(0);\n    if (t == -1) cout << \"YES\", exit(0);\n    int s = 0;\n    while (s != root[s]) s = root[s];\n    if (s == t) cout << \"YES\", exit(0);\n    else cout << \"NO\", exit(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nint main(){\n  char s[SIZE];\n  int n,m;\n  int l[SIZE],r[SIZE];\n  vector<int> cc[SIZE];\n  \n  scanf(\"%s%d\",s,&m);\n  n = strlen(s);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",l+i,r+i);\n    l[i]--; r[i]--;\n    \n    if(n%2 == 0){\n      if(l[i] <= n/2-1 && n/2 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - (n/2 - 1);\n        \n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if (a > b){\n          l[i] = n/2 - a;\n          r[i] = n/2 - b - 1;\n        }else{\n          l[i] = n/2 - b;\n          r[i] = n/2 - a - 1;\n        }\n      }\n    }else{\n      if(l[i] == r[i] && l[i] == n/2){\n        l[i] = -1; r[i] = -1;\n      }else if(l[i] == n/2){\n        l[i] += 1;\n      }else if(r[i] == n/2){\n        r[i] -= 1;\n      }else if(l[i] <= n/2-1 && n/2+1 <= r[i]){\n        int a = n/2+1 - l[i];\n        int b = r[i] - n/2;\n\n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if(a > b){\n          l[i] = n/2-1 - a;\n          r[i] = n/2-1 - b - 1;\n        }else{\n          l[i] = n/2-1 - b;\n          r[i] = n/2-1 - a - 1;\n        }\n      }\n    }\n\n    if(n/2 <= l[i]){\n      l[i] = n - l[i] - 1;\n      r[i] = n - r[i] - 1;\n      swap(l[i], r[i]);\n    }\n\n    if(l[i] != -1){\n      cc[l[i]].push_back(r[i]);\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    if(cc[i].size() > 1)\n      sort(cc[i].begin(),cc[i].end());\n\n    for(int j=cc[i].size()-2;j>=0;j--){\n      if(cc[i][j] != cc[i][j+1])\n        cc[cc[i][j]+1].push_back(cc[i][j+1]);\n    }\n  }\n\n  SegTree seg(n);\n  \n  for(int i=0;i<n/2;i++){\n    seg.add(i, i, 26 + s[n-i-1] - s[i]);\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size()){\n      int q = seg.query(i,i);\n      seg.add(i, cc[i][0], 26-q);\n    }\n\n    if(seg.query(i,i)%26){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n\n  puts(\"YES\");\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[++m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+1;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+1) {puts(\"NO\");return 0;}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k + 1) R[i]--;\n\t\tif(L[i] >= k + 1) L[i]--;\n\t\tif(L[i] == k && R[i] == k){\n\t\t\tL[i] = 1;\n\t\t\tR[i] = k * 2;\n\t\t}\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n \nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n \nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\tvec[k].clear();\n\treturn solve(k+1,a,b);\n}\n \n \nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tif(l[i] != S.size()-1-r[i])vec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=400002;\nchar s[N];\nint n,m,c[N],a,b,i,j,k,p;\nint h[N],t[N],v[N],vis[N];\nvoid add(int a,int b){\n\tt[++k]=h[a];h[a]=k;v[k]=b;\n\tt[++k]=h[b];h[b]=k;v[k]=a;\n}\nvoid init(){\n\tscanf(\"%s\",s+1);\n\twhile(s[n+1])n++;\n\tfor(i=1;i<=n+1;i++)\n\t\tc[i]=s[i]-s[i-1];\n\tfor(i=1,j=n+1;i<j;i++,j--)\n\t\tadd(i,j);\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b+1);\n\t}\n}\nvoid dfs(int i){\n\tvis[i]=1;\n\tp+=c[i];\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(!vis[v[j]])\n\t\t\tdfs(v[j]);\n}\nvoid work(){\n\tdfs(n+1);\n\tfor(i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tp=0;\n\t\t\tdfs(i);\n\t\t\tif(p%26!=0){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\tprintf(\"YES\\n\");\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <string>\n\nstruct UnionFind {\n    std::vector<int> par, sz;\n    int gnum;\n\n    explicit UnionFind(int n)\n        : par(n), sz(n, 1), gnum(n) {\n        std::iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int v) {\n        return (par[v] == v) ? v : (par[v] = find(par[v]));\n    }\n\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n\n        if (sz[u] < sz[v]) std::swap(u, v);\n        sz[u] += sz[v];\n        par[v] = u;\n        --gnum;\n    }\n\n    bool same(int u, int v) { return find(u) == find(v); }\n    bool ispar(int v) { return v == find(v); }\n    int size(int v) { return sz[find(v)]; }\n};\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n\n    int n = s.length();\n    std::vector<int> ds(n + 1, 0);\n    for (int i = 0; i <= n; ++i) {\n        int j = n - i - 1;\n        if (j <= i) break;\n\n        ds[i] = (int)s[i] - (int)s[j];\n        if (ds[i] < 0) ds[i] += 26;\n    }\n\n    UnionFind uf(n + 1);\n    int m;\n    std::cin >> m;\n    while (m--) {\n        int l, r;\n        std::cin >> l >> r;\n        --l, --r;\n\n        bool lbig = l > n - l - 1,\n             rbig = r > n - r - 1;\n        l = std::min(l, n - l - 1);\n        r = std::min(r, n - r - 1);\n\n        if (lbig && rbig) {\n            std::swap(l, r);\n            ++r;\n        } else if (!lbig && rbig) {\n            if (l > r) std::swap(l, r);\n        } else {\n            ++r;\n        }\n        uf.unite(l, r);\n    }\n\n    std::vector<int> nxt(n + 1, -1);\n    {\n        std::vector<int> prev(n + 1, -1);\n        for (int i = n; i >= 0; --i) {\n            int id = uf.find(i);\n            nxt[i] = prev[id];\n            prev[id] = i;\n        }\n    }\n\n    std::vector<int> red(n + 1, 0);\n    int d = 0;\n    for (int i = 0; i < n; ++i) {\n        (d += red[i]) %= 26;\n\n        if (i == n - i - 1) d = 0;\n        if (i >= n - i - 1) break;\n\n        (ds[i] += d) %= 26;\n        if (nxt[i] == -1) continue;\n\n        int nd = 26 - ds[i];\n        red[nxt[i]] += 26 - nd;\n        (d += nd) %= 26;\n        ds[i] = 0;\n    }\n\n    std::cout << (d == 0 && std::all_of(ds.begin(), ds.end(),\n                                        [](auto x) { return x == 0; })\n                      ? \"YES\"\n                      : \"NO\")\n              << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n,m,s[N],sum[N],dif[N];\nint flag[N];\nint get_flag(int pos) {\n\treturn flag[pos] == pos ? pos : flag[pos] = get_flag(flag[pos]);\n}\nvoid fit(int& x) {\n\tif (x > n/2) x = n-x+1;\n}\nint fix(int x) {\n\tif (x<0) x = 26-(-x)%26;\n\tx %= 26;\n\treturn x;\n}\nint main() {\n\tint l,r;\n\tfor (char tmp=getchar();tmp>='a'&&tmp<='z';tmp=getchar())\n\t\ts[++n] = tmp-'a';\n\tfor (int i=1;i<=n/2;++i)\n\t\ts[i] -= s[n-i+1],dif[i]=s[i]-s[i-1],flag[i]=i;\n\tdif[n/2+1] = -s[n/2];\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;++i) {\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif (n&1) {\n\t\t\tif (l == n/2+1&&r == n/2+1) continue;\n\t\t\tif (l == n/2+1) l++;\n\t\t\tif (r == n/2+1) r--;\n\t\t}\n\t\tif (l<=n/2&&r>n/2) l--;\n\t\tfit(l);fit(r);\n\t\tif (l>r) swap(l,r);\n\t\tflag[get_flag(l)]=flag[get_flag(r+1)];\n\t}\n\tfor (int i=1;i<=n/2+1;++i) sum[get_flag(i)] += dif[i];\n\tfor (int i=1;i<=n/2+1;++i) if (fix(sum[i])!=0) {\n\t\treturn 0*puts(\"NO\");\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n \nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n \nstring S;\nint add[100010];\nvector<P> vec[50002];\nint A,B,d;\nbool solve(int k,int a,int b){\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tA = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tB = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\td = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\td = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\tvec[k].clear();\n\treturn solve(k+1,a,b);\n}\n \n \nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tif(l[i] != S.size()-1-r[i])vec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, s, e) for(int i = s; i < e; i++)\n#define pb push_back\n#define fst first\n#define snd second\n#define endl '\\n'\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nvector<int> g[N];\n\nbool visited[N];\n\nint a;\n\nvector<int> v;\n\nvoid dfs(int x) {\n    if(visited[x]) return;\n    visited[x] = 1;\n    a = (a + v[x]) % 26;\n    for(auto v : g[x]) dfs(v);\n}\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    string s; cin >> s;\n    fore(i, 0, s.size()) v.pb(s[i] - 'a');\n    v.pb(0);\n    for(int i = v.size() - 1; i >= 0; i--) v[i] = (v[i] - v[i - 1] + 26) % 26;\n    fore(i, 0, v.size()) {\n        g[i].pb(v.size() - 1 - i);\n    }\n    int n; cin >> n;\n    fore(i, 0, n) {\n        int l, r; cin >> l >> r; l--;\n        g[l].pb(r);\n        g[r].pb(l);\n    }\n    bool f = true;\n    fore(i, 0, v.size()) if(!visited[i]) {\n        dfs(i), f = f && !a;\n    }\n    if(f) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N];\nchar s[N];\nvector<int> vct[N];\nvoid add(int x,int y)\n{\n\twhile(x<=m/2)\n\t{\n\t\tc[x]=(c[x]+y)%26;\n\t\tx+=x&-x;\n\t}\n}\nint sum(int x)\n{\n\tint rtn=0;\n\twhile(x>=1)\n\t{\n\t\trtn=(rtn+c[x])%26;\n\t\tx-=x&-x;\n\t}\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=(s[m-i+1]-s[i]+26)%26;\n\t\tadd(i,j);\n\t\tadd(i+1,(26-j)%26);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=sum(i);\n\t\tif(vct[i].empty())\n\t\t{\n\t\t\tif(j!=0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsort(vct[i].begin(),vct[i].end());\n\t\tadd(i+1,(26-j)%26);\n\t\tadd(vct[i][0]+1,j);\n\t\tfor(j=1,k=vct[i][0]+1;j<vct[i].size()&&k<=n;++j)\n\t\t\tif(k<=vct[i][j])\n\t\t\t\tvct[k++].push_back(vct[i][j]);\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<int> vec[N + 5];\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\treturn b - a;\n}\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB(1);\n\t\tvec[r[i] + 1].PB(-1);\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(i != 1 && vec[i].size() == 0) par[i] = i - 1;\n\t\telse par[i] = i;\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back();\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t}\n\t\ttot[i] = totnow;\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(tot[i] == 0) {\n\t\t\tif(tot[len - i + 1] == 0) {\n//\t\t\t\tcout<<\"TEST1 \"<<i<<\" \"<<len - i + 1<<endl;\n\t\t\t\tif(s[i - 1] != s[len - i]){\n\t\t\t\t\tbisa = false;\n//\t\t\t\t\tcout<<\"ERROR1 \"<<i<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pr = find(par[n - i + 1]);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(tot[rev] == 0) {\n\t\t\t\t\tif(dist(i - 1, rev - 1) != dist(n - i, pr - 1)) {\n\t\t\t\t\t\tbisa = false;\n\t//\t\t\t\t\tcout<<\"ERROR2 \"<<i<<endl;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(par[i] == i) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tint pr = find(i);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(find(n - i) == find(rev)) {\n\t\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\t\tbisa = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N];\nchar s[N];\nvector<int> vct[N];\nvoid add(int x,int y)\n{\n\twhile(x<=m/2)\n\t{\n\t\tc[x]=(c[x]+y)%26;\n\t\tx+=x&-x;\n\t}\n}\nint sum(int x)\n{\n\tint rtn=0;\n\twhile(x>=1)\n\t{\n\t\trtn=(rtn+c[x])%26;\n\t\tx-=x&-x;\n\t}\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=(s[m-i+1]-s[i]+26)%26;\n\t\tadd(i,j);\n\t\tadd(i+1,(26-j)%26);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=sum(i);\n\t\tif(vct[i].empty())\n\t\t{\n\t\t\tif(j!=0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsort(vct[i].begin(),vct[i].end());\n\t\tadd(i+1,(26-j)%26);\n\t\tadd(vct[i][0]+1,j);\n\t\tfor(j=vct[i].size()-1;j>=1;--j)\n\t\t\tif(vct[i][0]+1<=vct[i][j])\n\t\t\t\tvct[vct[i][0]+1].push_back(vct[i][j]);\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\nconst ll MOD=998244353;\nconst int N=510000;\n\n\nmain(){\n    string s;cin>>s;\n    vec a;\n    rep(i,s.size()){\n        a.pb(s[i]-'a');\n    }\n    int n=s.size();\n    vec b;\n    rep(i,n/2){\n        b.pb((26+a[i]-a[n-1-i])%26);\n    }\n    vector<vec> p(n);\n    int q=in();\n    rep(i,q){\n        int l=in(),r=in();\n        if(r<=n/2){\n            p[l-1].pb(r-1);\n        }\n        else if(l>n/2){\n            p[n-r].pb(n-l);\n        }\n        else {\n            r=n-r;\n            p[r].pb(l-2);\n        }\n    }\n    rep(i,n/2){\n        if(p[i].size())\n        sort(all(p[i]));\n        rep(j,(int)p[i].size()-1){\n            p[p[i][j]+1].pb(p[i][j+1]);\n        }\n    }\n    vec rui(n);\n    rep(i,n/2){\n        // cout<<b[i]<<\" \"<<rui[i]<<endl;\n        b[i]+=rui[i];\n        b[i]%=26;\n        if(b[i]){\n            if(p[i].size()==0){\n                cout<<\"NO\";return 0;\n            }\n            else{\n                rui[i]+=26-b[i];\n                rui[p[i][0]+1]-=26-b[i];\n            }\n        }\n        rui[i+1]+=rui[i];\n    }\n    cout<<\"YES\";return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nconst ll INF = LLONG_MAX / 2;\nconst int MOD = 1e9 + 7;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tstring s; cin >> s;\n\tint N = s.length();\n\ts = \"a\" + s + \"a\";\n\tint M; cin >> M;\n\tunion_find uf(N + 2);\n\twhile (M--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r), r++;\n\t\tuf.unite(l, r);\n\t\t// cout << l << ' ' << r << endl;\n\t}\n\tfor (int i = 1; i <= N + 1; i++) {\n\t\tuf.unite(i, N + 2 - i);\n\t\t// cout << i << ' ' << N + 2 - i << endl;\n\t}\n\tvector<int> a(N + 2);\n\tfor (int i = 1; i <= N + 1; i++) {\n\t\tchar c = s[i - 1], d = s[i];\n\t\tint j = uf.find(i);\n\t\ta[j] += c - d;\n\t\tc = s[N + 2 - i - 1], d = s[N + 2 - i];\n\t\ta[j] += c - d;\n\t}\n\trep(i, N + 2) if (a[i] % 26) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Aimi Haraguni >> Konomi Suzuki >> Yui >>  Ikimono Gakari >> Garnidelia >> Kalafina >> Eir Aoi.   .. dude?\n// Ztoking the best of the best\n// Kirito >> Naofumi >> Yun Che >> Hao\n// .... Sempre Amei Você ...\n \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser\n// \n// \n// Você nunca verá uma menina como ela\n// Mais linda em sentimentos que romance de novela\n// Bela, ingênua, tipo como cinderela\n// Sorte é do homem que estiver ao lado dela\n// Guerreira, não compare com as demais\n// Lutou muito para cumprir a exigência de seus pais\n// Sua força vai além do que cê pensa ser capaz\n// Essa menina não desiste daquilo que vai atrás, mas\n// Eu fui tão cego pra não ver\n// Que apenas ao meu lado ela queria viver\n// Enquanto que por outra pessoa eu quis correr\n// Ela não desistiu de mim mesmo eu a fazendo sofrer\n// Que idiota, como eu não pude perceber?\n// Que a menina que me amava estava sempre ali pra ver\n// Eu sei que esse sentimento eu não mereço ter\n// Mas desta vez eu vou tentar com meus erros aprender\n//\n// \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser\n// \n// \n// Ela sempre esteve lá, pra me ajudar\n// Quando eu caí, me fez levantar\n// Lutei tanto por meu sonho que sempre quis alcançar\n// Que acabei ficando cego sem poder enxergar\n// Eu nem consegui notar\n// Que bem na minha frente era quem deveria amar\n// Sempre achei que estava certo e que não podia errar\n// Mas só mesmo quando perde pra então valorizar\n// E eu perdi, e finalmente entendi\n// Que quem eu procurava estava sempre ali\n// Levou muito tempo pra ficha cair\n// Como eu fui tapado, eu tenho que admitir\n// Essa menina conseguiu me surpreender\n// Seu olhar estava sempre além do que eu podia ver\n// Eu tive que a perder, só pra perceber\n// Que ao lado dela é onde eu quero viver\n// \n// \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser\n// \n// \n// Eu tive que a perder\n// Pra que pudesse perceber\n// Que ao lado dela\n// É onde eu quero viver\n// Sim, um dia pode ser o fim\n// Pode ser tarde demais e tudo acabar assim\n// Mas pra ela eu vou dizer\n// Não volto com minha palavra\n// Com você quero viver\n// \n// \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser \n \n \n// #pragma GCC optimize (\"Ofast,unroll-loops\")\n// #pragma GCC target (\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n \n#define pb push_back\n#define ff  first\n#define ss second\n#define tm1 first\n#define tm2 second.first\n#define tm3 second.second\n#define sz(x) ll(x.size())\n#define fill(x, v) memset(x, v, sizeof(x))\n#define all(v) (v).begin(), (v).end()\n#define FER(i,a,b) for(ll i=ll(a); i< ll(b); ++i)\n#define IFR(i,a,b) for(ll i=ll(a); i>=ll(b); --i )\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0)\n \n#define N 6800000\n#define kk 550\n#define mod1 1000000007\n#define mod2 1000000009\n#define bas 987625403\n#define sqr(x) (x)*(x)  \n#define INF 5000000000000000\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef pair<ll, ii > tri;\ntypedef vector<ll> vi;\ntypedef vector<ii> vii;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> set_t;\n \n#define trace(...) f(#__VA_ARGS__, __VA_ARGS__)\n \ntemplate<typename t> void f(const char* x, t&& val1){\n    cout<<x<< \" : \"<<val1<<endl;\n}\n \ntemplate<typename t1, typename... t2> void f(const char* x, t1&& val1, t2&&... val2){\n    const char* xd=strchr(x+1, ',');\n    cout.write(x, xd-x)<<\" : \"<<val1<<\" | \";\n    f(xd+1, val2...);\n}\n\n \nstruct ST{\n\tll n, t[1<<18];\n\tinline ll Op(ll &val1, ll &val2){\n\t\treturn val1+val2;\n\t}\n\tinline void build(){\n\t\tIFR(i, n-1, 1) t[i]=Op(t[i<<1], t[i<<1|1]);\n\t}\n\tinline void modify(ll l, ll r, ll val){\n\t\tfor(l+=n, r+=n; l<r; l>>=1, r>>=1){\n\t\t\tif(l&1) t[l++]+=val;\n\t\t\tif(r&1) t[--r]+=val;\n\t\t}\n\t}\n\tinline ll que(ll p){\n\t\tll ans=0;\n\t\tfor(p+=n; p>0; p>>=1) ans+=t[p];\n\t\treturn ans;\n\t}\n}st;\n \ninline tri transform(ll a, ll b, ll n){\n\tll lim=(n+1)/2;\n\tif(n&1){\n\t\tif(b<=lim) return {0, {a-1, b-a+1}};\n\t\tif(a==lim) return {1, {a, b-a}};\n\t\tif(a>lim) return {1, {a-1, b-a+1}};\n\t\tll left=lim-a, right=b-lim;\n\t\tif(left==right) return {-1, {a-1, 0}};\n\t\tif(left<right){\n\t\t\tll add=right-left;\n\t\t\tll idx=b-add;\n\t\t\treturn {1, {idx, add}};\n\t\t}\n\t\telse{\n\t\t\tll add=left-right;\n\t\t\treturn {0, {a-1, add}};\n\t\t}\t\n\t}\n\telse{\n\t\tif(b<=lim) return {0, {a-1, b-a+1}};\n\t\tif(a>lim) return {1, {a-1, b-a+1}};\n\t\tll left=lim-a+1, right=b-lim;\n\t\tif(left==right) return {-1, {a-1, 0}};\n\t\tif(left<right){\n\t\t\tll add=right-left;\n\t\t\tll idx=b-add;\n\t\t\treturn {1, {idx, add}};\n\t\t}\n\t\telse{\n\t\t\tll add=left-right;\n\t\t\treturn {0, {a-1, add}};\n\t\t}\n\t}\n}\n \ninline ll check(ll n){\n\tFER(i,0,(n+1)/2){\n\t\tll t1=st.que(i), t2=st.que(n-1-i);\n\t\tif(t1!=t2) return 0;\n\t}\n\treturn 1;\n}\n\nvi queriesL[1<<17], queriesR[1<<17];\nvi graph[1<<17];\nll ar[1<<17], vis[1<<17];\ninline void dfs(ll u, ll &sum){\n\tvis[u]++;\n\tsum+=ar[u];\n\tfor(auto xd: graph[u]) if(!vis[xd]) dfs(xd, sum);\n}\nint main(){\n\tfastio;\n\tstring s; cin>>s;\n\tll q, n=sz(s); cin>>q;\n\tst.n=n;\n\tar[0]=0, ar[n+1]=0;\n\tFER(i,0,st.n) {\n\t\tll valor=(s[i]-'a'+0);\n\t\tar[i+1]=valor;\n\t}\n\tvi tnt;\n\tFER(i,0,n+1){\n\t\ttnt.pb(ar[i+1]-ar[i]);\n\t\tgraph[i].pb(n-i);\n\t}\n\tFER(i,0,sz(tnt)) ar[i]=tnt[i]%26;\n\tFER(i,0,q){\n\t\tll a, b; cin>>a>>b;\n\t\ttri cur=transform(a, b, n);\n\t\tif(cur.tm1==-1) continue;\n\t\tll x=cur.tm2, y=cur.tm3+cur.tm2;\n\t\tgraph[x].pb(y);\n\t\tgraph[y].pb(x);\n\t}\n\tll flag=1;\n\tFER(i,0,n+1) if(!vis[i]){\n\t\tll sum=0;\n\t\tdfs(i, sum);\n\t\tif(sum%26) flag=0;\n\t}\n\tflag? cout<<\"YES\"<<\"\\n\": cout<<\"NO\"<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\n\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tvector<pair<ll, ll>> segs;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tint m = s.size() / 2 + 1;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tll dis = (r - m + 1) * 2;\n\t\t\tr -= dis + 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) st[cur.first].insert(cur.second);\n\tll m = s.size() / 2, cur = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define debug(x) cout << #x << \" = \" << x << endl\n#define pb push_back\n#define F first\n#define S second\n\nconst int MAX = 100005;\nint dif[MAX];\n\n\nstruct dsu {\n    vector<int> par, sz, sum;\n    int size;\n\n    dsu(int n) {\n        size = n;\n    \tpar = sz = sum = vector<int>(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            sz[i] = 1;\n            sum[i] = dif[i];\n        }\n    }\n\n    int find(int u) {\n        return par[u] == u ? u : (par[u] = find(par[u]));\n    }\n\n    void unite(int u, int v) {\n        if ((u = find(u)) == (v = find(v))) return;\n        if (sz[u] > sz[v]) swap(u,v);\n        par[u] = v;\n        sz[v] += sz[u];\n        sum[v] = (sum[v]+sum[u])%26;\n        size--;\n    }\n\n    int count(int u) {\n        return sz[find(u)];\n    }\n\n    int getSum(int u){\n        return sum[find(u)];\n    }\n};\n\n\nint main() {\n    #ifdef LOCAL\n        freopen(\"in.txt\", \"r\", stdin);\n        //freopen(\"out.txt\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s;\n    int n, sz, a, b;\n\n    cin >> s >> n;\n    sz = s.size();\n\n    for (int i = 0; i < sz; i++){\n        dif[i+1] = s[i]-'a';\n    }\n    for (int i = 0; i < sz+1; i++) {\n        dif[i] = (dif[i+1]+26-dif[i])%26;\n    }\n\n    dsu ds = dsu(sz+1);\n\n    for (int i = 0; i < sz; i++) {\n        ds.unite(i, sz-i);\n    }\n\n    for (int i = 0; i < n; i++) {\n            cin >> a >> b;\n            a--;\n            ds.unite(a, b);\n    }\n    bool f = true;\n    for (int i = 0; i < sz; i++) {\n        if(ds.getSum(i) != 0){\n            f = false;\n            break;\n        }\n    }\n\n    if(f)cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = (int)1e5 + 7;\n\nint pr[N];\nint a[N], sum[N];\nint dif[N];\n\nint find_dsu (int a) {\n    if (pr[a] == a) return a;\n    return pr[a] = find_dsu(pr[a]);\n}\n\nvoid connect (int a, int b) {\n    a = find_dsu(a);\n    b = find_dsu(b);\n    if (a != b) {\n        pr[a] = b;\n        sum[b] += sum[a];\n    }\n}\n\nmain() {\n    string s; cin >> s;\n    int n; scanf (\"%d\", &n);\n    int len = s.size();\n    for (int i = 0; i < len; i++) {\n        a[i + 1] = s[i] - 'a';\n        pr[i + 1] = i + 1;\n    }\n    for (int i = 0; i <= len; i++) {\n        if (a[i] <= a[i + 1]) {\n            dif[i] = a[i + 1] - a[i];\n        } else {\n            dif[i] = (26 - a[i]) + a[i + 1];\n        }\n        sum[i] = dif[i];\n    }\n//    for (int i = 0; i <= len; i++) {\n//        printf (\"%d \", dif[i]);\n//    }\n//    puts(\"\");\n    for (int i = 0; i <= len; i++) {\n        connect(i, len - i);\n    }\n    for (int i = 1; i <= n; i++) {\n        int l, r; scanf (\"%d %d\", &l, &r);\n        l--;\n        connect(l, r);\n    }\n    for (int i = 0; i <= len; i++) {\n        if (pr[i] == i && sum[i] % 26 != 0) {\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\n\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tvector<pair<ll, ll>> segs;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tint m = s.size() / 2 + 1;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tll dis = (r - m + 1) * 2;\n\t\t\tr -= dis + 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) st[cur.first].insert(cur.second);\n\tll m = s.size() / 2, cur = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << 2 / 0;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"main.cpp\"\n\n/**\n * @title Template\n */\n\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n#include <cassert>\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/chmin_chmax.cpp\"\n\ntemplate <class T, class U>\nconstexpr bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\nconstexpr bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\n/**\n * @title Chmin/Chmax\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/range.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/range.cpp\"\n\nclass range {\npublic:\n  class iterator {\n  private:\n    int64_t M_position;\n\n  public:\n    constexpr iterator(int64_t position) noexcept: M_position(position) { }\n    constexpr void operator ++ () noexcept { ++M_position; }\n    constexpr bool operator != (iterator other) const noexcept { return M_position != other.M_position; }\n    constexpr int64_t operator * () const noexcept { return M_position; }\n  };\n\n  class reverse_iterator {\n  private:\n    int64_t M_position;\n  \n  public:\n    constexpr reverse_iterator(int64_t position) noexcept: M_position(position) { }\n    constexpr void operator ++ () noexcept { --M_position; }\n    constexpr bool operator != (reverse_iterator other) const noexcept { return M_position != other.M_position; }\n    constexpr int64_t operator * () const noexcept { return M_position; }\n  };\n  \nprivate:\n  const iterator M_first, M_last;\n\npublic:\n  constexpr range(int64_t first, int64_t last) noexcept: M_first(first), M_last(std::max(first, last)) { }\n  constexpr iterator begin() const noexcept { return M_first; }\n  constexpr iterator end() const noexcept { return M_last; }\n  constexpr reverse_iterator rbegin() const noexcept { return reverse_iterator(*M_last - 1); } \n  constexpr reverse_iterator rend() const noexcept { return reverse_iterator(*M_first - 1); } \n};\n\n/**\n * @title Range\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/rev.cpp\"\n\n#include <type_traits>\n#include <iterator>\n#line 6 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/rev.cpp\"\n\ntemplate <class T>\nclass rev_impl {\npublic:\n  using iterator = decltype(std::rbegin(std::declval<T>()));\n\nprivate:\n  const iterator M_begin;\n  const iterator M_end;\n\npublic:\n  constexpr rev_impl(T &&cont) noexcept: M_begin(std::rbegin(cont)), M_end(std::rend(cont)) { }\n  constexpr iterator begin() const noexcept { return M_begin; }\n  constexpr iterator end() const noexcept { return M_end; }\n};\n\ntemplate <class T>\nconstexpr decltype(auto) rev(T &&cont) {\n  return rev_impl<T>(std::forward<T>(cont));\n}\n\n/**\n * @title Reverser\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/fix_point.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/fix_point.cpp\"\n\ntemplate <class Func>\nstruct fix_point_impl: private Func {\n  explicit constexpr fix_point_impl(Func &&func): Func(std::forward<Func>(func)) { }\n  template <class... Args>\n  constexpr decltype(auto) operator () (Args &&... args) const {\n    return Func::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class Func>\nconstexpr decltype(auto) fix_point(Func &&func) {\n  return fix_point_impl<Func>(std::forward<Func>(func));\n}\n\n/**\n * @title Lambda Recursion\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/ext_gcd.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/ext_gcd.cpp\"\n#include <cstdint>\n\nconstexpr std::pair<int64_t, int64_t> ext_gcd(int64_t a, int64_t b) {\n  if ((a %= b) == 0) return { b, 0 };\n  int64_t s = b, t = (a < 0 ? a + b : a);\n  int64_t m0 = 0, m1 = 1, tmp = 0;\n  while (t > 0) {\n    const auto u = s / t;\n    s -= t * u; m0 -= m1 * u;\n    tmp = s; s = t; t = tmp; tmp = m0; m0 = m1; m1 = tmp;\n  }\n  return { s, (m0 < 0 ? m0 + b / s : m0) };\n}\n\n/**\n * @title Extended GCD\n */\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n\n#line 8 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n#include <type_traits>\n\ntemplate <class Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using cover_type = uint64_t;\n \n  template <class T>\n  static constexpr value_type normalize(T value_) noexcept {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= Modulus::mod();\n      if (value_ == 0) return 0;\n      return Modulus::mod() - value_;\n    }\n    return value_ % Modulus::mod();\n  }\n\nprivate:\n  value_type value;\n\n  template <bool IsPrime, std::enable_if_t<IsPrime>* = nullptr>\n  constexpr modular inverse_helper() const noexcept { return power(*this, Modulus::mod() - 2); }\n  template <bool IsPrime, std::enable_if_t<!IsPrime>* = nullptr>\n  constexpr modular inverse_helper() const noexcept {\n    const auto tmp = ext_gcd(value, Modulus::mod());\n    assert(tmp.first == 1);\n    return modular(tmp.second);\n  }\n\npublic:\n  constexpr modular() noexcept : value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_) noexcept : value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() const noexcept { return static_cast<T>(value); }\n \n  constexpr value_type get() const noexcept { return value; }\n  constexpr value_type &extract() noexcept { return value; }\n  constexpr modular operator - () const noexcept { return modular(Modulus::mod() - value); }\n  constexpr modular operator ~ () const noexcept { return inverse(*this); }\n \n  constexpr modular operator + (const modular &rhs) const noexcept { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) noexcept { \n    if ((value += rhs.value) >= Modulus::mod()) value -= Modulus::mod(); \n    return *this; \n  }\n \n  constexpr modular operator - (const modular &rhs) const noexcept { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) noexcept { \n    if ((value += Modulus::mod() - rhs.value) >= Modulus::mod()) value -= Modulus::mod(); \n    return *this; \n  }\n \n  constexpr modular operator * (const modular &rhs) const noexcept { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) noexcept { \n    value = (cover_type) value * rhs.value % Modulus::mod();\n    return *this;\n  }\n \n  constexpr modular operator / (const modular &rhs) const noexcept { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) noexcept { return (*this) *= inverse(rhs); }\n \n  constexpr bool zero() const noexcept { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const noexcept { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const noexcept { return value != rhs.value; }\n \n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) { return stream << rhs.value; }\n  friend constexpr modular inverse(const modular &val) noexcept { return val.inverse_helper<Modulus::is_prime>(); }\n  friend constexpr modular power(modular val, cover_type exp) noexcept { \n    modular res(1);\n    for (; exp > 0; exp >>= 1, val *= val) if (exp & 1) res *= val;\n    return res;\n  }\n \n};\n \ntemplate <uint32_t Mod, bool IsPrime = true>\nstruct static_modulus { \n  static constexpr uint32_t mod() noexcept { return Mod; } \n  static constexpr bool is_prime = IsPrime;\n};\n\ntemplate <uint32_t Id = 0, bool IsPrime = false>\nstruct dynamic_modulus {\n  static uint32_t &mod() noexcept { static uint32_t val = 0; return val; }\n  static constexpr bool is_prime = IsPrime;\n};\n\ntemplate <uint32_t Mod>\nusing mint32_t = modular<static_modulus<Mod>>;\nusing rmint32_t = modular<dynamic_modulus<>>;\n\n/*\n * @title Modint\n */\n#line 19 \"main.cpp\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nusing m32 = modular<static_modulus<26, false>>;\n\nint main() {\n  std::string S;\n  std::cin >> S;\n  const i32 N = S.length();\n  const i32 H = N / 2;\n  std::vector<m32> initial(H);\n  for (auto i: range(0, H)) {\n    initial[i] = m32(S[N - i - 1] - 'a') - m32(S[i] - 'a');\n  }\n  std::vector<m32> dif(H + 1);\n  dif.front() = initial.front();\n  dif.back() = -initial.back();\n  for (auto i: range(1, H)) {\n    dif[i] = initial[i] - initial[i - 1];\n  }\n  std::vector<std::vector<i32>> graph(H + 1);\n  i32 M;\n  std::cin >> M;\n  while (M--) {\n    i32 a, b;\n    std::cin >> a >> b;\n    --a; --b;\n    i32 l = a, r = b;\n    if (a > N - b - 1) {\n      l = N - b - 1;\n      r = N - a - 1;\n    }\n    if (r >= H) {\n      r = N - r - 2;\n    }\n    if (l <= r) {\n      graph[l].push_back(r + 1);\n      graph[r + 1].push_back(l);\n    }\n  }\n  std::vector<bool> visited(H + 1);\n  const auto dfs = fix_point([&](const auto dfs, const i32 u, const i32 p) -> void {\n    if (visited[u]) return;\n    visited[u] = true;\n    for (const auto v: graph[u]) {\n      dfs(v, u);\n    }\n    if (~p) {\n      dif[p] += dif[u];\n      dif[u] -= dif[u];\n    }\n  });\n  for (auto i: range(0, H + 1)) {\n    if (!visited[i]) {\n      dfs(i, -1);\n      if (!dif[i].zero()) {\n        std::cout << \"NO\\n\";\n        return 0;\n      }\n    }\n  }\n  std::cout << \"YES\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nstruct LL {\n  ll value;\n\n  LL() : value(0) {}\n\n  explicit LL(ll value) : value(value) {}\n\n  LL(const LL& a, const LL& b) {\n    value = a.value + b.value;\n  }\n};\n\nstruct Add {\n  ll value;\n\n  Add() : value(0) {}\n\n  explicit Add(ll value) : value(value) {}\n\n  Add(const Add& a, const Add& b) {\n    value = a.value + b.value;\n  }\n};\n\nvoid apply(LL& e, const Add& m, int l, int r) {\n  e.value += m.value * (r - l);\n  (void) l, (void) r;\n}\n\ntemplate<typename E, typename M>\nstruct ST {\n  static constexpr int inf = 1e9;\n  int base;\n  vector<E> t;\n  vector<M> upd;\n\n  static int calc_base(int n) {\n    int x = 1;\n    while (x < n) {\n      x *= 2;\n    }\n    return x;\n  }\n\n  ST() : base(0) {}\n  ST(int n) : base(calc_base(n)), t(base * 2), upd(base * 2) {}\n\n  void push(int v, int cl, int cr) {\n    int cc = (cl + cr) / 2;\n    apply(t[v * 2 + 0], upd[v], cl, cc);\n    apply(t[v * 2 + 1], upd[v], cc, cr);\n    upd[v * 2 + 0] = M(upd[v * 2 + 0], upd[v]);\n    upd[v * 2 + 1] = M(upd[v * 2 + 1], upd[v]);\n    upd[v] = M();\n  }\n\n  E get(int l, int r, int v = 1, int cl = 0, int cr = inf) {\n    cr = min(cr, base);\n    if (l <= cl && cr <= r) {\n      return t[v];\n    }\n    if (r <= cl || cr <= l) {\n      return E();\n    }\n    push(v, cl, cr);\n    int cc = (cl + cr) / 2;\n    return E(get(l, r, v * 2, cl, cc), get(l, r, v * 2 + 1, cc, cr));\n  }\n\n  void put(int l, int r, const M& x, int v = 1, int cl = 0, int cr = inf) {\n    cr = min(cr, base);\n    if (l <= cl && cr <= r) {\n      apply(t[v], x, cl, cr);\n      upd[v] = M(upd[v], x);\n      return;\n    }\n    if (r <= cl || cr <= l) {\n      return;\n    }\n    push(v, cl, cr);\n    int cc = (cl + cr) / 2;\n    put(l, r, x, v * 2 + 0, cl, cc);\n    put(l, r, x, v * 2 + 1, cc, cr);\n    t[v] = E(t[v * 2], t[v * 2 + 1]);\n  }\n\n  E& raw_data(int pos) {\n    return t[base + pos];\n  }\n\n  void build() {\n    for (int i = base - 1; i > 0; --i) {\n      t[i] = E(t[i * 2], t[i * 2 + 1]);\n    }\n  }\n\n  void set(int pos, const E& val, int v = 1, int cl = 0, int cr = inf) {\n    cr = min(cr, base);\n    if (cl + 1 == cr) {\n      assert(v == pos + base);\n      t[v] = val;\n      return;\n    }\n    push(v, cl, cr);\n    int cc = (cl + cr) / 2;\n    if (pos < cc) {\n      set(pos, val, v * 2, cl, cc);\n    } else {\n      set(pos, val, v * 2 + 1, cc, cr);\n    }\n    t[v] = E(t[v * 2], t[v * 2 + 1]);\n  }\n};\nusing Tree = ST<LL, Add>;\n\nconst int maxn = 100100;\nbitset<maxn> q[maxn];\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  int m = n / 2;\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      q[nl][nr] = 1;\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  bitset<maxn> greater;\n  for (int i = 0; i <= m; ++i) {\n    greater[i] = 1;\n  }\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    greater[i] = 0;\n    q[i] &= greater;\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = q[i]._Find_first();\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 2000005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[mid1 - i] - s[mid2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= minr) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            deladd[minr + 1] %= 26;\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nusing namespace std;\n\nstring s;\nint n, m, l[N], r[N], sum[N];\nint pset[N];\n\nint findset(int i){return ((pset[i] == i) ? i : pset[i] = findset(pset[i]));}\n\nvoid dsu(int i, int j){\n    i = findset(i); j = findset(j);\n    if (i == j) return;\n    pset[j] = i;\n    sum[i] += sum[j];\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s;\n    n = s.size();\n    s = '.' + s;\n    cin >> m;\n    for (int i = 1; i <= m; i++){\n        cin >> l[i] >> r[i];\n        if (r[i] < n + 1 - r[i]) continue;\n        if (l[i] > n + 1 - l[i]){\n            l[i] = n + 1 - l[i];\n            r[i] = n + 1 - r[i];\n            swap(l[i], r[i]);\n            continue;\n        }\n        r[i] = n + 1 - r[i];\n        if (l[i] <= r[i]) r[i]--;\n        else l[i]--, swap(l[i], r[i]);\n    }\n\n    for (int i = 1; i <= n/2; i++) sum[i] = s[n+1-i] - s[i];\n    for (int i = n/2+1; i >= 1; i--) sum[i] -= sum[i-1];\n\n    for (int i = 1; i <= n; i++) pset[i] = i;\n    for (int i = 1; i <= m; i++) dsu(l[i], r[i]+1);\n\n    for (int i = 1; i <= n; i++) {\n        if (pset[i] == i && sum[i] % 26 != 0) return cout << \"NO\", 0;\n    }\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nusing ld = long double;\nll INF = LLONG_MAX;\n\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid print() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); \n\t}\n}\n\nusing namespace output;\n\nstruct DSU {\n    vi p; vi sum; void init(int n) {p = vi (n, -1); sum = vi (n, 0);}\n    int findSet(int x) { return p[x] < 0 ? x : findSet(p[x]);}\n    bool sameSet(int a, int b) { return findSet(a) == findSet(b); }\n\tint size(int x) { return -p[findSet(x)]; }\n\tbool joinSet(int x, int y) { // union-by-rank\n\t\tx = findSet(x), y = findSet(y); if (x == y) return 0;\n\t\tif (p[x] > p[y]) swap(x,y);\n\t\tsum[x] += sum[y]; p[x] += p[y]; p[y] = x; return 1;\n\t}\n};\n\nint main() {\n    // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring S; cin >> S;\n\t\n\tDSU dsu; dsu.init(S.size()-1);\n\tFOR(i, 1, S.size()) dsu.sum[i-1] = S[i] - S[i-1];\n\tfor (int i = 0; i < (S.size() - 1) / 2; ++i) dsu.joinSet(i, S.size()-2-i);\n\tvi solve = vi ();\n\tint N; cin >> N;\n\tF0R(i, N) {\n\t\tint l, r; cin >> l >> r; --l; --r;\n\t\tif ((l == 0) && (r == S.size()-1)) {}\n\t\telse if (r == S.size()-1) solve.push_back(l-1);\n\t\telse if (l == 0) solve.push_back(r);\n\t\telse dsu.joinSet(l-1, r);\n\t}\n\tfor(int x : solve) dsu.sum[dsu.findSet(x)] = 0;\n\tbool works = true;\n\tF0R(i, S.size()-1) {\n\t\tif ((dsu.sum[dsu.findSet(i)] % 26 + 26) % 26 != 0) works = false;\n\t}\n\tprint(works ? \"YES\" : \"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\t//S[k] += a;\n\t//S[S.size()-1-k] += b;\n\tif(S.size()-1-k <= k)return true;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tvec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass UF {\nprivate:\n    int sz;\npublic:\n    vector<int> kind;   //所属しているグループ番号\n    vector<vector<int> > inc;   //グループのメンバー\n    UF(){}\n    UF(int node_size){ sz = node_size; kind.resize(sz),inc.resize(sz); rep(i,sz){ kind[i] = i; inc[i].pb(i); } }\n    bool same(int a,int b){ return kind[a] == kind[b]; }\n    void unite(int a,int b)\n    { if(same(a,b)) return; if(inc[kind[a]].size() < inc[kind[b]].size()) swap(a,b);\n        int ga = kind[a],gb = kind[b]; rep(i,inc[gb].size()) kind[inc[gb][i]] = ga;\n        inc[ga].insert(inc[ga].end(),inc[gb].begin(),inc[gb].end()); inc[gb].clear(); }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    int m;\n    cin >> m;\n    s = \"a\" + s + \"a\";\n    vi vec(n+1);\n    rep(i,n+1){\n        vec[i] = ((int)(s[i+1]-s[i])+26)%26;\n    }\n    UF uf(n+1);\n    rep(i,m){\n        int l, r;\n        cin >> l >> r;\n        --l;\n        uf.unite(l, r);\n    }\n    rep(i,(n+1)/2){\n        uf.unite(i, n-i);\n    }\n    if((n+1)%2){\n        rep(i,n+1){\n            if(uf.inc[i].empty()) continue;\n            int ch = 0;\n            bool flag = false;\n            each(j, uf.inc[i]){\n                ch += vec[j];\n                flag |= (j == n/2);\n            }\n            if(ch % 26 != 0 && !flag){\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n    }else{\n        rep(i,n+1){\n            if(uf.inc[i].empty()) continue;\n            int ch = 0;\n            each(j, uf.inc[i]){\n                ch += vec[j];\n            }\n            if(ch % 26 != 0){\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\n\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() % 2 == 1) cout << 2 / 0;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tvector<pair<ll, ll>> segs;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tint m = s.size() / 2 + 1;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tll dis = (r - m + 1) * 2;\n\t\t\tr -= dis + 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) st[cur.first].insert(cur.second);\n\tll m = s.size() / 2, cur = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ];\n    DSU() {\n        F0R(i,SZ) par[i] = i, sz[i] = 1;\n    }\n    \n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n    \n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tif (sz[x] < sz[y]) swap(x,y);\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nstring S;\nint N;\nvpi al;\n\npi getLeft(pi p) {\n    p.s = min(p.s,N/2-1);\n    // cout << \"OH \" << p.f << \" \" << p.s << \"\\n\";\n    if (p.f > p.s) return {-1,-1};\n    return p;\n}\n\npi getRight(pi p) {\n    p.f = max(p.f,(N+1)/2);\n    if (p.f > p.s) return {-1,-1};\n    return {N-1-p.s,N-1-p.f};\n}\n\nDSU<MX> D;\nint sum[MX];\n    \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> S; N = sz(S);\n    int t; cin >> t;\n    F0R(i,t) {\n        pi p; cin >> p.f >> p.s; p.f --, p.s --;\n        pi x = getLeft(p), y = getRight(p);\n        // cout << p.f << \" \" << p.s << \" \" << x.f << \" \" << x.s << \" \" << y.f << \" \" << y.s << \"\\n\";\n        if (x == mp(-1,-1) && y == mp(-1,-1)) continue;\n        if (x == mp(-1,-1)) al.pb(y);\n        else if (y == mp(-1,-1)) al.pb(x);\n        else if (x.f != y.f) al.pb({min(x.f,y.f),max(x.f,y.f)-1});\n    }\n    vi dif; \n    dif.pb(0);\n    for (int i = 0; i < sz(S)-1-i; ++i) dif.pb((S[sz(S)-1-i]-S[i]+26)%26);\n    dif.pb(0);\n    vi DIF; F0R(i,sz(dif)-1) DIF.pb((dif[i+1]-dif[i]+26)%26);\n    \n    for (auto a: al) D.unite(a.f,a.s+1);\n    F0R(i,sz(DIF)) sum[D.get(i)] += DIF[i];\n    F0R(i,sz(DIF)) if (sum[i] % 26 != 0) {\n        cout << \"NO\";\n        exit(0);\n    }\n    cout << \"YES\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\treturn b - a;\n}\n\nset<int> st;\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB({1, i});\n\t\tvec[r[i] + 1].PB({-1, i});\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t\tif(x == -1) st.erase(id);\n\t\t\telse st.insert(id);\n\t\t}\n\t\ttot[i] = totnow;\n\t\tif(tot[i] == 0) par[i] = 0;\n\t\telse {\n\t\t\tif(ms[st] == 0) ms[st] = i;\n\t\t\tpar[i] = ms[st];\n\t\t}\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= n;i++) {\n\t\tif(find(i) == 0 && find(n - i + 1) == 0) {\n\t\t\tif(s[i - 1] != s[n - i]) bisa = false;\n\t\t}\n\t\telse {\n\t\t\tint pr = find(i);\n\t\t\tif(pr != 0) {\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(find(n - i + 1) == find(rev)) {\n\t\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n\t//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n\t//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\t\tbisa = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  string S;\n  int N;\n\n  cin >> S;\n  cin >> N;\n  UnionFind uf(S.size() + 1);\n  for(int i = 0; i <= S.size(); i++) {\n    uf.unite(i, S.size() - i);\n  }\n  for(int i = 0; i < N; i++) {\n    int L, R;\n    cin >> L >> R;\n    uf.unite(L - 1, R);\n  }\n\n  vector< int > sum(S.size() + 1);\n\n  for(int i = 0; i <= S.size(); i++) {\n    int U = (i == 0 ? 0 : S[i - 1] - 'a');\n    int V = (i == S.size() ? 0 : S[i] - 'a');\n    int dist = (U + 26 - V) % 26;\n    (sum[uf.find(i)] += dist) %= 26;\n  }\n\n\n  for(int i = 0; i <= S.size(); i++) {\n    if(sum[i] != 0) {\n      cout << \"NO\" << endl;\n      return (0);\n    }\n  }\n\n  cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, s, e) for(int i = s; i < e; i++)\n#define pb push_back\n#define fst first\n#define snd second\n#define endl '\\n'\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\n\nvector<int> g[N];\n\nbool visited[N];\n\nint a;\n\nvector<int> v;\n\nvoid dfs(int x) {\n    if(visited[x]) return;\n    visited[x] = 1;\n    a = (a + v[x]) % 26;\n    for(auto v : g[x]) dfs(v);\n}\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    string s; cin >> s;\n    fore(i, 0, s.size()) v.pb(s[i] - 'a');\n    v.pb(0);\n    for(int i = v.size() - 1; i >= 0; i--) v[i] = (v[i] - v[i - 1] + 26) % 26;\n    fore(i, 0, v.size()) {\n        g[i].pb(v.size() - 1 - i);\n    }\n    int n; cin >> n;\n    fore(i, 0, n) {\n        int l, r; cin >> l >> r; l--;\n        g[l].pb(r);\n        g[r].pb(l);\n    }\n    bool f = true;\n    fore(i, 0, v.size()) if(!visited[i]) {\n        dfs(i), f = f && !a;\n    }\n    if(f) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+1;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+1) {puts(\"YES\");return 0;}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[mid1 - i] - s[mid2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= i) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            deladd[minr + 1] %= 26;\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nset<int> st;\nstring ns = \"\";\nstring s;\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n//\t\t\tcout<<\"OP3 \"<<i<<\" \"<<mini<<\" \"<<maxi - 1<<endl;\n\t\t}\n\t}\n\tn = mid;\n\tms[st] = -1;\n\tint total = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) st.insert(id);\n\t\t\telse st.erase(id);\n\t\t}\n\t\tif(ms.find(st) == ms.end()) ms[st] = i;\n\t\tpar[i] = ms[st];\n//\t\tcout<<\"CHECKPAR \"<<i<<\" \"<<par[i]<<endl;\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n//\t\tcout<<\"PRINT \"<<i<<\" \"<<par[i]<<\" \"<<x<<endl;\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\t//S[k] += a;\n\t//S[S.size()-1-k] += b;\n\tif(S.size()-1-k <= k)return true;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,S.size()-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,S.size()-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,S.size()-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,S.size()-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tvec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint n,q,l,r,pset[100007];\nint it[400007];\nset <int> query[100007];\nvoid upd(int k,int l,int r,int L,int R,int val){\n\tif(l>R || r<L || L>R) return;\n\tif(l>=L && r<=R){\n\t\tit[k]+=val;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tupd(k*2,l,mid,L,R,val);\n\tupd(k*2+1,mid+1,r,L,R,val);\n}\nint get(int k,int l,int r,int pos){\n\tif(l==r && l==pos) return it[k];\n\tint mid=(l+r)/2;\n\tif(pos<=mid) return it[k]+get(k*2,l,mid,pos);\n\telse return it[k]+get(k*2+1,mid+1,r,pos);\n}\nint fset(int x){\n\tif(pset[x]==x) return x;\n\treturn pset[x]=fset(pset[x]);\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>s;\n\tn=(int)s.length();\n\tcin>>q;\n\tfor(int i=1;i<=q;i++){\n\t\tcin>>l>>r;\n\t\tif(l<=(n+1)/2 && r>=(n+1)/2){\n\t\t\tr=n-r+1;\n\t\t\tif(l>r) swap(l,r);\n\t\t\tr--;\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse if(l<=(n+1)/2){\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse{\n\t\t\tquery[n-r+1].insert(n-l+1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n/2;i++) pset[i]=i;\n\tfor(int i=1;i<=n/2;i++){\n\t\t//cout<<(s[i-1]-s[n-i]+26)%26<<endl;\n\t\tint cal=((s[i-1]-s[n-i]+26)%26-get(1,1,n/2,i)+26)%26;\n\t\t//cout<<i<<\" \"<<cal<<endl;\n\t\tif(cal!=0 && query[fset(i)].empty()){\n\t\t\tcout<<\"NO\";\n\t\t\treturn 0;\n\t\t}\n\t\telse if(i==n/2) continue;\n\t\telse{\n\t\t\tint cur=fset(i);\n\t\t\tauto it=query[cur].begin();\n\t\t\tquery[cur].erase(query[cur].begin());\n\t\t\tupd(1,1,n/2,i,*it,cal);\n\t\t\tint nxt=fset(*it+1);\n\t\t\tif(query[cur].size()<query[nxt].size()){\n\t\t\t\tpset[cur]=nxt;\n\t\t\t\tfor(auto jt=query[cur].begin();jt!=query[cur].end();jt++){\n\t\t\t\t\tquery[nxt].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpset[nxt]=cur;\n\t\t\t\tfor(auto jt=query[nxt].begin();jt!=query[nxt].end();jt++){\n\t\t\t\t\tquery[cur].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=400002;\nint n,m,i,a,b,c[N],vis[N],sum,tmp;\nchar s[N];\nvector<int>e[N];\nvoid Link(int x,int y){\n\te[x].push_back(y);\n\te[y].push_back(x);\n}\nvoid init(){\n\tscanf(\"%s%d\",s+1,&m);\n\tn=strlen(s+1);\n\tfor(i=0;i<=n;i++)\n\t\tc[i]=s[i+1]-s[i];\n\tfor(i=0;i<n-i;i++)\n\t\tLink(i,n-i);\n\twhile(m--){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tLink(a-1,b);\n\t}\t\n}\nvoid dfs(int i){\n\tvis[i]=1;\n\tsum+=c[i];\n\tfor(int j=0;j<e[i].size();j++)\n\t\tif(!vis[e[i][j]])\n\t\t\tdfs(e[i][j]);\n}\nvoid work(){\n\ttmp=1;\n\tdfs(0);\n\tsum=0;\n\tfor(i=1;i<n;i++)\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t\tif(sum)\n\t\t\t\ttmp=0;\n\t\t}\n\tprintf(\"%s\\n\",tmp?\"YES\":\"NO\");\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD=26;\nclass BIT{\n    int n;\n    vector<int> dat;\n    public:\n    BIT(int n):n(n),dat(n,0){};\n    void add(int pos,int x){\n        pos++;\n        while(pos<=n){\n            dat[pos-1]=(dat[pos-1]+x)%MOD;\n            pos+=(pos & -pos);\n        }\n    }\n    int sum(int pos){\n        pos++;\n        int res=0;\n        while(pos>0){\n            res=res+dat[pos-1];\n            pos-=(pos & -pos);\n        }\n        return (res%MOD+MOD)%MOD;\n    }\n    void debug(){\n        cerr<<\"####\"<<endl;\n        for(int i=0;i<n;i++){\n            cerr<<dat[i]<<\" \";\n        }\n        cerr<<endl;\n    }\n};\nint main(){\n    string s;\n    cin>>s;\n    int erasep=s.size()+2;\n    if(s.size()%2==1){\n        erasep=s.size()/2;\n        string buf;\n        for(int i=0;i<s.size();i++){\n            if(i!=erasep) buf+=s[i];\n        }\n        s=buf;\n    }\n    int n;\n    cin>>n;\n    vector<int> l,r;\n    for(int i=0;i<n;i++){\n        int tmpl,tmpr;\n        cin>>tmpl>>tmpr;\n        tmpl--,tmpr--;\n        if(tmpl==tmpr && tmpl==erasep) continue;\n        if(erasep<tmpl) tmpl--;\n        if(erasep<=tmpr) tmpr--;\n        cerr<<tmpl<<\" \"<<tmpr<<endl;\n        l.push_back(tmpl),r.push_back(tmpr);\n    }\n    n=l.size();\n\n    vector<int> v(s.size()/2);\n    for(int i=0;i<v.size();i++){\n        v[i]=(int)(s[s.size()-1-i])-(int)(s[i]);\n    }\n\n    vector<set<int>> com(v.size());\n    for(int i=0;i<n;i++){\n        if(r[i]<v.size()){\n            com[l[i]].insert(r[i]);\n        }\n        else if(v.size()<=l[i]){\n            com[s.size()-1-r[i]].insert(s.size()-1-l[i]);\n        }\n        else{\n            int dl=v.size()-l[i];\n            int dr=r[i]-v.size()+1;\n            if(dl<dr){\n                com[s.size()-1-r[i]].insert(v.size()-1-dl);\n            }\n            if(dl>dr){\n                com[l[i]].insert(v.size()-1-dr);\n            }\n        }\n    }\n    BIT bit(v.size()+1);\n    for(int i=0;i<v.size();i++){\n        if(com[i].empty()){\n            int x=bit.sum(i)+v[i];\n            if(x%MOD!=0){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n        else{\n            int x;\n            int pre=-1;\n            for(auto &e:com[i]){\n                if(pre==-1){\n                    pre=e;\n                    x=e;\n                }\n                else{\n                    com[pre+1].insert(e);\n                    pre=e;\n                }\n            }\n            int y=-(bit.sum(i)+v[i]);\n            bit.add(i,y);\n            bit.add(x+1,-y);\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\n\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tvector<pair<ll, ll>> segs;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) continue;\n\t\tint m = s.size() / 2 + 1;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tll dis = (r - m + 1) * 2;\n\t\t\tr -= dis + 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) st[cur.first].insert(cur.second);\n\tll m = s.size() / 2, cur = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar s[100100];\nint a[100100], fa[100100], l, r, m;\n\nint Get(int x) {\n\treturn x == fa[x] ? x : fa[x] = Get(fa[x]);\n}\n\nint main(void) {\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tfor(int i = 0; i < n; i++)\n\t\ta[i + 1] = s[i] - 'a';\n\ta[0] = a[n + 1] = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\ta[i] = (a[i + 1] - a[i] + 26) % 26;\n\t\tfa[i] = i;\n\t}\n\t\t\n\tscanf(\"%d\", &m);\n\tfor(int i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &l, &r); \n\t\tl--;\n\t\tint fx = Get(l), fy = Get(r);\n\t\tif(fx != fy) {\n\t\t\tfa[fx] = fy;\n\t\t\ta[fy] = (a[fy] + a[fx]) % 26;\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++) {\n\t\tint fx = Get(i), fy = Get(n - i);\n\t\tif(fx != fy) {\n\t\t\tfa[fx] = fy;\n\t\t\ta[fy] = (a[fy] + a[fx]) % 26;\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t\tif(fa[i] == i && a[i]) {\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t} \n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nchar s[100001];\nint val[50001];\nint sub[50001];\nint par[50001];\nint n, m;\nstruct oper {\n    int l, r;\n    void scan() {\n        cin >> l >> r;\n        --l; --r;\n    }\n} op[100000];\n\nint find(int x) {\n    if (par[x] != x) return par[x] = find(par[x]);\n    return x;\n}\n\nint merge(int x, int y) {\n     x = find(x);\n     y = find(y);\n     if (x == y) return 0;\n     par[y] = x;\n     sub[x] += sub[y];\n     return 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> s >> n;\n\tm = strlen(s);\n\tint od = m & 1;\n\tif (od) {\n        for (int i = m >> 1; i + 1 < m; ++i) {\n            s[i] = s[i + 1];\n        }\n\t}\n\tm = (m >> 1) << 1;\n\tfor (int i = 0; i < n; ++i) {\n        op[i].scan();\n        if (od) {\n            if ((m >> 1) < op[i].l) --op[i].l;\n            if ((m >> 1) <= op[i].r) --op[i].r;\n            if (op[i].r < op[i].l) {\n                --i; --n;\n                continue;\n            }\n        }\n        if ((m >> 1) <= op[i].l) {\n            op[i].l = m - 1 - op[i].l;\n            op[i].r = m - 1 - op[i].r;\n            swap(op[i].l, op[i].r);\n        }\n        else if ((m >> 1) <= op[i].r) {\n            op[i].r = m - 1 - op[i].r;\n            if (op[i].r < op[i].l) swap(op[i].l, op[i].r);\n            --op[i].r;\n            if (op[i].r < op[i].l) {\n                --i; --n;\n                continue;\n            }\n        }\n        \n\t}\n\tfor (int i = 0; i < (m >> 1); ++i) {\n        val[i] = (s[i] - s[m - 1 - i] + 26) % 26;\n\t}\n\tsub[0] = val[0];\n\tfor (int i = 1; i <= (m >> 1); ++i) {\n        sub[i] = ((val[i] - val[i - 1]) % 26 + 26) % 26;\n\t}\n\n\tfor (int i = 0; i <= (m >> 1); ++i) {\n        par[i] = i;\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n        merge(op[i].l, op[i].r + 1);\n\t}\n\tfor (int i = 0; i <= (m >> 1); ++i) {\n        if (find(i) != i) continue;\n        if (sub[i] % 26) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nconst ll K1 = 2;\nconst ll K2 = 3;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk1[N], degk2[N];\nll ha1[N], ha2[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degk1[0] = 1;\n    degk2[0] = 1;\n    for (int i = 1; i < N; i++) degk1[i] = degk1[i - 1] * K1 % MOD;\n    for (int i = 1; i < N; i++) degk2[i] = degk2[i - 1] * K2 % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha1[l[i]] = (ha1[l[i]] + degk1[i]) % MOD;\n            ha1[r[i] + 1] = (ha1[r[i] + 1] + MOD - degk1[i]) % MOD;\n            ha2[l[i]] = (ha2[l[i]] + degk2[i]) % MOD;\n            ha2[r[i] + 1] = (ha2[r[i] + 1] + MOD - degk2[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha1[i] = (ha1[i - 1] + ha1[i]) % MOD;\n        ha2[i] = (ha2[i - 1] + ha2[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<pair<ll, ll>, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[{ha1[i], ha2[i]}].insert(x[i]);\n        if (val[{ha1[i], ha2[i]}].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[{0, 0}].size() && *(val[{0, 0}].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector <int> V[101010], T[101010], Q;\nset <int> S[101010];\nint K[101010], D[101010], G[101010];\nchar str[101010];\nbool chk[101010];\nint n, m, cnt;\n\nvoid die() { printf(\"NO\\n\"); exit(0); }\n\nvoid dfs(int p)\n{\n\tchk[p] = 1;\n\tK[cnt] = (K[cnt] + D[p]) % 26;\n\tT[cnt].push_back(p);\n\t\n\tfor(int &t: V[p]){\n\t\tif(!chk[t]) dfs(t);\n\t}\n}\n\nint main()\n{\n\tint i, a, b, p, k;\n\t\n\tscanf(\"%s\", str);\n\t\n\tn = strlen(str);\n\t\n\tD[0] = str[0] - 'a';\n\tD[n] = (26 + 'a' - str[n-1]) % 26;\n\t\n\tfor(i=1; i<n; i++){\n\t\tD[i] = (26 + str[i] - str[i-1]) % 26;\n\t}\n\t\n\tscanf(\"%d\", &m);\n\t\n\tfor(i=1; i<=m; i++){\n\t\tscanf(\"%d%d\", &a, &b); a --;\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\t\n\tfor(i=0; i<=n; i++){\n\t\tif(!chk[i]){\n\t\t\tcnt ++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\tfor(i=1; i<=cnt; i++){\n\t\tsort(T[i].begin(), T[i].end());\n\t\tfor(int &t: T[i]){\n\t\t\tif((~n & 1) && t == n >> 1) continue;\n\t\t\telse if(*lower_bound(T[i].begin(), T[i].end(), n - t) == n - t) continue;\n\t\t\tS[i].insert(t); G[t] = i;\n\t\t}\n\t\t\n\t\tif(S[i].empty() && K[i]) die();\n\t\t\n\t\tif(S[i].size() <= 1) Q.push_back(i);\n\t}\n\t\n\tfor(; !Q.empty(); ){\n\t\tp = Q.back(); Q.pop_back();\n\t\tif(S[p].empty() && K[p]) die();\n\t\tif(!S[p].empty()){\n\t\t\tk = K[p];\n\t\t\tp = n - *S[p].begin();\n\t\t\tK[G[p]] = (K[G[p]] + k) % 26;\n\t\t\tS[G[p]].erase(p);\n\t\t\tif(S[G[p]].size() <= 1) Q.push_back(G[p]);\n\t\t}\n\t}\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      (ws[x] += ws[p[x]]) %= 26;\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    w += 26;\n    w %= 26;\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    w += 26;\n    w %= 26;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return (weight(y) - weight(x) + 26) % 26;\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          int diff2 = (S[other] - S[idx] + 26) % 26;\n          if(diff != diff2) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"NO\"); exit(0); }\nvoid fg(vector<int> G[], int a, int b) { G[a].eb(b); G[b].eb(a); }\n\nconst bool debug = 0;\nconst int MAXN = 200055;\nconst int MAXK = 200055;\n\nvector<int> G[MAXN];\nbitset<MAXN> chk;\n\nint D[MAXN], E[MAXN];\n\nint B[MAXK], C[MAXK];\nchar A[MAXN];\n\nint N, K;\n\nint f(int i) {\n\tint ret = E[i]; chk[i] = true;\n\tfor(int v : G[i]) if(!chk[v]) {\n\t\tret = (ret + f(v)) % 26;\n\t}\n\treturn ((ret % 26) + 26) % 26;\n}\n\nint main() {\n\tscanf(\" %s\", A+1);\n\tN = int(strlen(A+1));\n\tscanf(\"%d\", &K);\n\tfor(int i = 1; i <= K; i++) scanf(\"%d%d\", &B[i], &C[i]);\n\n\tif(N&1) {\n\t\tN++;\n\t\tfor(int i = N-1; N/2 <= i; i--) A[i+1] = A[i];\n\t\tA[N/2] = A[N/2+1];\n\t\tfor(int i = 1; i <= K; i++) {\n\t\t\tif(N/2 < B[i]) B[i]++;\n\t\t\tif(N/2 <= C[i]) C[i]++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= K; i++) {\n\t\tif(C[i] <= N/2) continue;\n\t\tif(N/2 < B[i]) {\n\t\t\tB[i] = N+1-B[i];\n\t\t\tC[i] = N+1-C[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint l = N/2-B[i]+1, r = C[i]-N/2;\n\t\tif(l > r) swap(l, r);\n\t\tB[i] = N/2-r+1;\n\t\tC[i] = N/2-l;\n\t}\n\n\tif(debug) {\n\t\tprintf(\"N=%d, K=%d\\n\", N, K);\n\t\tfor(int i = 1; i <= N; i++) putchar(A[i]); puts(\"\");\n\t\tfor(int i = 1; i <= K; i++)\n\t\t\tprintf(\"%d ; %d %d\\n\", i, B[i], C[i]);\n\t}\n\n\tN /= 2;\n\tfor(int i = 1; i <= N; i++)\n\t\tD[i] = (A[N*2+1-i] - A[i] + 26) % 26;\n\tfor(int i = 1; i <= N+1; i++)\n\t\tE[i] = ((D[i] - D[i-1] + 26) % 26 + 26) % 26;\n\tfor(int i = 1; i <= K; i++) C[i]++;\n\tN++;\n\n\tfor(int i = 1; i <= K; i++) if(B[i] < C[i]) fg(G, B[i], C[i]);\n\tfor(int i = 1; i <= N; i++) if(!chk[i]) {\n\t\tint t = f(i);\n\t\tif(t) fuk();\n\t}\n\n\tfor(int i = 1; i <= N; i++) if(!chk[i] && E[i]) fuk();\n\n\tputs(\"YES\");\n\n\t{\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 10000; i++) for(int j = 0; j < 10000; j++)\n\t\t\tret = (ret + i + j) % 998244353;\n\t\tif(!ret) puts(\"WTF?\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nchar s[N];\nint n, l[N], r[N], bit[N], p[N];\nbool no[N];\nvoid add(int x, int k) {\n    while (x <= N) {\n        bit[x] += k;\n        x += x & -x;\n    }\n}\nint query(int x) {\n    int ret = 0;\n    while (x) {\n        ret += bit[x];\n        x -= x & -x;\n    }\n    return ret;\n}\nvoid add(int L, int R, int k) {\n    add(L, k);\n    add(R + 1, -k);\n}\nint main() {\n    scanf(\"%s%d\", s + 1, &n);\n    int m = strlen(s + 1);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        p[i] = i;\n    }\n    for (int i = 1; i <= m; i++) {\n        add(i, i, s[i] - 'a');\n    }\n    /*for (int i = 1; i <= m; i++) {\n        cout << i << \"->\" << query(i) << endl;\n    }*/\n    sort(p, p + n,\n         [](int x, int y) { return l[x] == l[y] ? r[x] > r[y] : l[x] < l[y]; });\n    for (int i = 0; i < n; i++) {\n        int now = p[i];\n        add(l[now], r[now], query(m - l[now] + 1) - query(l[now]));\n    }\n    /*for (int i = 1; i <= m; i++) {\n        cout << i << \"=>\" << (query(i) % 26 + 26) % 26 << endl;\n    }*/\n    for (int i = 1; i <= m / 2; i++) {\n        if ((query(i) % 26 + 26) % 26 != (query(m - i + 1) % 26 + 26) % 26) {\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define all(v) begin(v), end(v)\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\nint a[MAXN];\n\nstd::vector<int> G[MAXN];\n\nvoid change(int L, int R, int v) {\n    //cout << L << '-'<<R<<\"\\n\";\n    (a[L] += v) %= 26;\n    (a[R + 1] -= v) %= 26;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            x = n - x + 1;\n            y = n - y + 1;\n            std::swap(x, y);\n        }\n        if (x <=mm && y >mm) {\n            y = n - y + 1;\n            if (x == y) continue;\n            if (x > y) std::swap(x, y);\n            y--;\n        }\n        G[x].push_back(y);\n    }\n    for (int i = 1; i + i <= n; ++i) {\n        if (!G[i].empty()) {\n            std::sort(all(G[i]));\n            G[i].erase(std::unique(all(G[i])), end(G[i]));\n            int k = G[i].size();\n            change(i, G[i][0], -a[i]);\n            for (int j = 1; j < k; ++j) {\n                G[G[i][j - 1] + 1].push_back(G[i][j]);\n            }\n        }\n        if (a[i] != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nint max_kai = 300000;\nvel kai(max_kai, 1);\nvel inv_kai(max_kai, 1);\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nvel pa;\nvel siz;\nint root(int x) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x]); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai() {\n    rep(i, max_kai - 1) {\n        kai[i+1] = kai[i] * (i+1); kai[i+1] %= p;\n        inv_kai[i+1] = modinv(kai[i+1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)){return 0;}\n    int ans = (kai[n] * inv_kai[r])%p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nint inf = 100000;\nvel dijk(V<V<pin>>& way, int st) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin,vector<pin>,greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\nvoid sol(int n, int now_min, int now_max,vel &v) {\n    if (n == 1) {\n        return;\n    }\n    if (n % 2 == 1) {\n        v.push_back(now_max); now_max--;\n    }\n    v.push_back(now_min); now_min++;\n    sol(n / 2, now_min, now_max, v);\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nsigned main() {\n    string s; cin >> s;\n    int n = s.size();\n    vel ts(n);\n    rep(i, n) {\n        ts[i] = s[i] - 'a';\n    }\n    pa=vel(n+1, -1);\n    int q; cin >> q;\n    rep(i, q) {\n        int l, r; cin >> l >> r; l--;\n        mmin(l, n - l); mmin(r, n - r);\n        mar(r, l);\n    }\n    int m = n / 2;\n    vel ns(m, 0);\n    rep(i, n) {\n        if (i < m) { ns[i] = ts[i]; }\n        if (n -1- i < m) { ns[n -1- i] -= ts[i]; }\n    }\n    ns.push_back(0);\n    vel qs = ns;\n    rep(i, m) { qs[i + 1] -= ns[i]; }\n    vvel list(m+1);\n    rep(i, m+1) {\n        list[root(i)].push_back(i);\n    }\n    rep(i, m + 1) {\n        int sum = 0;\n        for (auto x : list[i]) {\n            sum += qs[x];\n        }\n        if (sum % 26 != 0) { cout << \"NO\" << endl; return 0; }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tset<S>::iterator it=st.lower_bound((S){i,0});\n\t\tif(it==st.end()||->s!=i) continue;\n\t\tS range=*it;\n\t\twhile(1)\n\t\t{\n\t\t\tset<S>::iterator it2=st.lower_bound((S){i,0});\n\t\t\tit2++;\n\t\t\tif(it2==st.end()||it2->s!=range.s) break;\n\t\t\tS etemp=*it2;\n\t\t\tst.insert((S){range.e+1,etemp.e});\n\t\t\tst.erase(etemp);\n\t\t}\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t}\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\twhile(!st.empty()&&st.begin()->s<i) st.erase(st.begin());\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <list>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define LL long long\nusing namespace std;\n\nstring s;\nint val[100005],n,N;\nint pre[100005] = {0},add;\nint m,tmp;\n\nstruct node{\n\tint l,r;\n}q[100005];\n\nbool cmp(node x,node y){\n\tif(x.l == y.l) return x.r < y.r;\n\treturn x.l < y.l;\n}\n\ninline string judge(){\n\tfor(register int i = 1;i <= n;i ++){\n\t\tif(val[i] != val[n + 1 - i]) return \"NO\";\n\t}\n\treturn \"YES\";\n}\n\nint main(){\n\tcin >> s; n = s.length();\n\tfor(register int i = 1;i <= n;i ++) val[i] = s[i - 1] - 'a';\n\tcin >> m;\n\tN = ((n & 1) ? ((n >> 1) + 1) : (n >> 1));\n\tfor(register int i = 1;i <= m;i ++){\n\t\tcin >> q[i].l >> q[i].r;\n\t\tif((q[i].l > N) && (q[i].r > N)){\n\t\t\tq[i].l = n + 1 - q[i].l;\n\t\t\tq[i].r = n + 1 - q[i].r;\n\t\t\tswap(q[i].l,q[i].r);\n\t\t}\n\t\telse if(q[i].r > N){\n\t\t\tq[i].l --;\n\t\t\tq[i].r = n + 1 - q[i].r;\n\t\t\tswap(q[i].l,q[i].r);\n\t\t}\n\t}\n\tsort(q + 1,q + 1 + m,cmp);\n\ttmp = q[1].l;\n\tfor(register int i = 2;i <= m;i ++){\n\t\tif(q[i].l == tmp) q[i].l = q[i - 1].r + 1;\n\t\telse tmp = q[i].l;\n\t}\n\tsort(q + 1,q + 1 + m,cmp);\n\t/*\n\tfor(register int i = 1;i <= m;i ++){\n\t\tcout << q[i].l << ' ' << q[i].r << endl;\n\t}\n\t*/\n\tq[0].l = q[1].l;\n\tadd = 0;\n\tfor(register int i = 1;i <= m;i ++){\n\t\tif(q[i].l > q[i].r) continue;\n\t\tadd += pre[q[i].l];\n\t\tfor(register int j = q[i - 1].l + 1;j <= q[i].l;j ++){\n\t\t\tval[j] += add; val[j] = (val[j] + 26) % 26;\n\t\t}\n\t\tif(val[q[i].l] == val[n - q[i].l + 1]) continue;\n\t\ttmp = val[n - q[i].l + 1] - val[q[i].l];\n\t\tval[q[i].l] = val[n - q[i].l + 1];\n\t\tadd += tmp;\n\t\tpre[q[i].r + 1] -= tmp;\n\t}\n\tfor(register int i = q[m].l + 1;i <= N;i ++){\n\t\tadd += pre[i];\n\t\tval[i] += add; val[i] = (val[i] + 26) % 26;\n\t}\n\t/*\n\tfor(register int i = 1;i <= n;i ++){\n\t\tcout << val[i] << (i == n ? '\\n' : ' ');\n\t}\n\tfor(register int i = 1;i <= n;i ++){\n\t\tcout << pre[i] << (i == n ? '\\n' : ' ');\n\t}\n\t*/\n\tcout << judge() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\ntemplate <class OperatorMonoid>\nstruct dual_segment_tree {\n    typedef OperatorMonoid monoid_type;\n    typedef typename OperatorMonoid::underlying_type operator_type;\n    typedef typename OperatorMonoid::target_type underlying_type;\n    int n;\n    vector<operator_type> f;\n    vector<underlying_type> a;\n    OperatorMonoid op;\n    dual_segment_tree() = default;\n    dual_segment_tree(int a_n, underlying_type initial_value, OperatorMonoid const & a_op = OperatorMonoid()) : op(a_op) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(n, initial_value);\n        f.resize(n-1, op.unit());\n    }\n    underlying_type point_get(int i) { // 0-based\n        underlying_type acc = a[i];\n        for (i = (i+n)/2; i > 0; i /= 2) { // 1-based\n            acc = op.apply(f[i-1], acc);\n        }\n        return acc;\n    }\n    void range_apply(int l, int r, operator_type z) { // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply(0, 0, n, l, r, z);\n    }\n    void range_apply(int i, int il, int ir, int l, int r, operator_type z) {\n        if (l <= il and ir <= r) { // 0-based\n            if (i < f.size()) {\n                f[i] = op.append(z, f[i]);\n            } else {\n                a[i-n+1] = op.apply(z, a[i-n+1]);\n            }\n        } else if (ir <= l or r <= il) {\n            // nop\n        } else {\n            range_apply(2*i+1, il, (il+ir)/2, 0, n, f[i]);\n            range_apply(2*i+2, (il+ir)/2, ir, 0, n, f[i]);\n            f[i] = op.unit();\n            range_apply(2*i+1, il, (il+ir)/2, l, r, z);\n            range_apply(2*i+2, (il+ir)/2, ir, l, r, z);\n        }\n    }\n};\ntemplate <int mod>\nstruct modplus_operator_t {\n    typedef int underlying_type;\n    typedef int target_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return (a + b) % mod; }\n    int apply(int a, int b) const { return (a + b) % mod; }\n};\n\nbool solve(string s, vector<pair<int, int> > const & lrs) {\n    int n = s.length();\n    dual_segment_tree<modplus_operator_t<26> > segtree(n, 0);\n    repeat (i, n) {\n        segtree.range_apply(i, i + 1, s[i] - 'a');\n    }\n    vector<vector<pair<int, int> > > xlrs(n / 2 + 3);\n    auto push = [&](int l, int r) {\n        if (l == r) return;\n        xlrs[min(l, n - r)].emplace_back(l, r);\n    };\n    for (auto lr : lrs) {\n        int l, r; tie(l, r) = lr;\n        push(l, r);\n    }\n    repeat (k, n / 2) {\n        int l = k, r = n - k;\n        bool complemented = count(whole(xlrs[k]), make_pair(l, r));\n        if (complemented) {\n            xlrs[k].erase(remove(whole(xlrs[k]), make_pair(l, r)), xlrs[k].end());\n            int n = xlrs[k].size();\n            repeat (i, n) {\n                int l1, r1; tie(l1, r1) = xlrs[k][i];\n                if (l == l1) xlrs[k].emplace_back(r1, r);\n                if (r == r1) xlrs[k].emplace_back(l, l1);\n            }\n        }\n        sort(whole(xlrs[k]));\n        xlrs[k].erase(unique(whole(xlrs[k])), xlrs[k].end());\n        if (xlrs[k].empty()) {\n            if (segtree.point_get(l) != segtree.point_get(r - 1)) return false;\n            continue;\n        }\n        repeat (i, xlrs[k].size() - 1) {\n            int l1, r1; tie(l1, r1) = xlrs[k][i];\n            int l2, r2; tie(l2, r2) = xlrs[k][i + 1];\n            if (l == l1 and l == l2) push(r1, r2);\n            if (r == r1 and r == r2) push(l1, l2);\n            if (l == l1 and r == r2 and l2 < r1) push(l2, r1);\n        }\n        int lm = r, rm = l;\n        for (auto lr : xlrs[k]) {\n            int l1, r1; tie(l1, r1) = lr;\n            if (l == l1) setmin(lm, r1);\n            if (r == r1) setmax(rm, l1);\n        }\n        if (lm == r) {\n            segtree.range_apply(rm, r, (segtree.point_get(l) - segtree.point_get(r - 1) + 26) % 26);\n        } else {\n            segtree.range_apply(l, lm, (segtree.point_get(r - 1) - segtree.point_get(l) + 26) % 26);\n        }\n        if (lm != r and rm != l) {\n            push(lm, rm);\n        }\n    }\n    return true;\n}\n\nint main() {\n    string s; int n; cin >> s >> n;\n    vector<pair<int, int> > lrs(n);\n    repeat (i, n) {\n        int l, r; cin >> l >> r; -- l;\n        lrs[i] = { l, r };\n    }\n    bool result = solve(s, lrs);\n    cout << (result ? \"YES\" : \"NO\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<int> vec[N + 5];\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\tint x1 = a - 'a';\n\tint x2 = b - 'a';\n\treturn (x2 - x1 + 26) % 26;;\n}\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB(1);\n\t\tvec[r[i] + 1].PB(-1);\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(i != 1 && vec[i].size() == 0) par[i] = i - 1;\n\t\telse par[i] = i;\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back();\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t}\n\t\ttot[i] = totnow;\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(tot[i] == 0) {\n\t\t\tif(tot[len - i + 1] == 0) {\n//\t\t\t\tcout<<\"TEST1 \"<<i<<\" \"<<len - i + 1<<endl;\n\t\t\t\tif(s[i - 1] != s[len - i]){\n\t\t\t\t\tbisa = false;\n//\t\t\t\t\tcout<<\"ERROR1 \"<<i<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pr = find(par[n - i + 1]);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(tot[rev] == 0) {\n\t\t\t\t\tif(dist(i - 1, rev - 1) != dist(n - i, pr - 1)) {\n\t\t\t\t\t\tbisa = false;\n\t//\t\t\t\t\tcout<<\"ERROR2 \"<<i<<endl;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(par[i] == i) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tint pr = find(i);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(find(n - i) == find(rev)) {\n\t\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\t\tbisa = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nclass unionfind {\n\tvector<int> par, rank;\n\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return ;\n\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y) { return (find(x) == find(y)); }\n} uf;\n\nstring s;\nint Q;\nint L[100010], R[100010];\nint N;\nint cmp[100010];\n\nint main() {\n\tcin >> s >> Q;\n\tN = s.size();\n\tuf.init(N + 10);\n\n\trep(i, Q) {\n\t\tscanf(\"%d %d\", &L[i], &R[i]);\n\t\t--L[i]; --R[i];\n\t}\n\n\tvector<pii> vec;\n\n\tif (N & 1) {\n\t\tint ct = N / 2;\n\t\trep(i, Q) {\n\t\t\tif (L[i] <= ct && ct <= R[i]) {\n\t\t\t\tif ((ct-L[i])==(R[i]-ct)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if ((ct-L[i])>(R[i]-ct)) {\n\t\t\t\t\tR[i] = ct-(R[i]-ct)-1;\n\t\t\t\t\tvec.eb(L[i], R[i]);\n\t\t\t\t} else {\n\t\t\t\t\tL[i] = ct+(ct-L[i])+1;\n\t\t\t\t\tvec.eb(N-1-R[i],N-1-L[i]);\n\t\t\t\t}\n\t\t\t} else if (R[i] < ct) {\n\t\t\t\tvec.eb(L[i], R[i]);\n\t\t\t} else {\n\t\t\t\tvec.eb(N-1-R[i], N-1-L[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\trep(i, Q) {\n\t\t\tif (L[i] <= N/2-1 && N/2 <= R[i]) {\n\t\t\t\tif ((N/2-1-L[i])==(R[i]-N/2)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if ((N/2-1-L[i])>(R[i]-N/2)) {\n\t\t\t\t\tR[i] = N-2-R[i];\n\t\t\t\t\tvec.eb(L[i],R[i]);\n\t\t\t\t} else {\n\t\t\t\t\tL[i] = N-L[i];\n\t\t\t\t\tvec.eb(N-1-R[i],N-1-L[i]);\n\t\t\t\t}\n\t\t\t} else if (R[i]<N/2) {\n\t\t\t\tvec.eb(L[i],R[i]);\n\t\t\t} else {\n\t\t\t\tvec.eb(N-1-R[i],N-1-L[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvi df;\n\n\trep(i, N/2) {\n\t\tdf.pb(s[i]-s[N-1-i]);\n\t}\n\n\tvi acm;\n\tacm.pb(df[0]);\n\n\trep(i,(int)df.size()-1) {\n\t\tacm.pb(df[i+1]-df[i]);\n\t}\n\n\tacm.pb(-1e9);\n\n\tfor (auto p:vec) {\n\t\tuf.unite(p.fi, p.se + 1);\n\t}\n\n\trep(i, acm.size()) {\n\t\tcmp[uf.find(i)] += acm[i];\n\t}\n\n\tbool ok = 1;\n\trep(i, acm.size()) {\n\t\tif (uf.same(i, (int)acm.size()-1)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (cmp[uf.find(i)] % 26 != 0) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tputs(ok ? \"YES\" : \"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len + 1);\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    for (int i = len; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    x[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        r[i]++;\n    }\n    vector<int> root(len + 1), sz(len + 1);\n    iota(root.begin(), root.end(), 0);\n    fill(sz.begin(), sz.end(), 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    vector<int> summ(len + 1);\n    for (int i = 1; i <= len; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    vector<int> t;\n    for (int i = 0; i <= len; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (root[i] != i) exit(1);\n            t.push_back(i);\n        }\n    }\n    if (t.size() > 2)\n    {\n        cout << \"NO\";\n    }\n    else\n    {\n        cout << \"YES\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nconst ll K1 = 2;\nconst ll K2 = 0;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk1[N], degk2[N];\nll ha1[N], ha2[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        return 1;\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degk1[0] = 1;\n    degk2[0] = 1;\n    for (int i = 1; i < N; i++) degk1[i] = degk1[i - 1] * K1 % MOD;\n    for (int i = 1; i < N; i++) degk2[i] = degk2[i - 1] * K2 % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha1[l[i]] = (ha1[l[i]] + degk1[i]) % MOD;\n            ha1[r[i] + 1] = (ha1[r[i] + 1] + MOD - degk1[i]) % MOD;\n            ha2[l[i]] = (ha2[l[i]] + degk2[i]) % MOD;\n            ha2[r[i] + 1] = (ha2[r[i] + 1] + MOD - degk2[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha1[i] = (ha1[i - 1] + ha1[i]) % MOD;\n        ha2[i] = (ha2[i - 1] + ha2[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<pair<ll, ll>, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[{ha1[i], ha2[i]}].insert(x[i]);\n        if (val[{ha1[i], ha2[i]}].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[{0, 0}].size() && *(val[{0, 0}].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mod = 'z' - 'a' + 1;\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\n\tint m;\n\tcin >> m;\n\tvector<vector<int>> graph(n/2 + 1);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a;\n\t\ta = min(a, n-a);\n\t\tb = min(b, n-b);\n\t\tif(a != b) {\n\t\t\tgraph[a].push_back(b);\n\t\t\tgraph[b].push_back(a);\n\t\t}\n\t}\n\n\tvector<int> vec(n/2);\n\tfor(int i = 0; i < n/2; ++i) {\n\t\tvec[i] = int(s[i]) - int(s[n-1-i]);\n\t\tvec[i] %= mod;\n\t\tvec[i] += mod;\n\t\tvec[i] %= mod;\n\t}\n\n\tn  = n/2+1;\n\n\tvector<bool> seen(n, false);\n\tfunction<void(int, vector<int>&)> dfs = [&](int node, vector<int> &comp) {\n\t\tif(seen[node]) return;\n\t\tseen[node] = true;\n\t\tcomp.push_back(node);\n\t\tfor(int ch : graph[node]) dfs(ch, comp);\n\t};\n\n\tvector<int> finish(n, -1);\n\tvector<int> start(n, -1);\n\tvector<int> total;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(!seen[i]) {\n\t\t\tvector<int> comp;\n\t\t\tdfs(i, comp);\n\t\t\tsort(comp.begin(), comp.end());\n\t\t\tfor(int j = 1; j < comp.size(); ++j) {\n\t\t\t\tstart[comp[j-1]] = total.size();\n\t\t\t\tfinish[comp[j]] = total.size();\n\t\t\t\ttotal.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint sum = 0;\n\tbool can = true;\n\tfor(int i = 0; i < n-1; ++i) {\n\t\tassert(vec[i] >= 0);\n\t\tassert(sum >= 0);\n\t\tvec[i] += sum;\n\t\tvec[i] %= mod;\n\t\tif(vec[i] != 0) {\n\t\t\tif(start[i] == -1) can = false;\n\t\t\telse {\n\t\t\t\tsum += mod - vec[i];\n\t\t\t\tsum %= mod;\n\t\t\t\ttotal[start[i]] = (mod - vec[i]) % mod;\n\t\t\t}\n\t\t}\n\t\tif(finish[i+1] != -1) {\n\t\t\tsum += mod - total[finish[i+1]];\n\t\t\tsum %= mod;\n\t\t}\n\t}\n\n\tif(can) {\n\t\tcout << \"YES\" << endl;\n\t} else {\n\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) {string s; ist >> s; return ist;}\nbool Inside(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* E mondai*/\n\nstring s;\nint N;\nint L[100000], R[100000];\nvector<IntMod<26>> ss;\n\nvoid Add(int i, int j, IntMod<26> val) {\n\tss[i] += val;\n\tss[j] -= val;\n}\n\nint main() {\n\tcin >> s >> N;\n\tREP(i, 0, N) {\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t\tif (L[i] > s.size() / 2) L[i] = s.size() - L[i];\n\t\tif (R[i] > s.size() / 2) R[i] = s.size() - R[i];\n\t\tif (L[i] > R[i]) swap(L[i], R[i]);\n\t}\n\n\tREP(i, 0, s.size() / 2) {\n\t\tss.push_back(s[s.size() - i - 1] - s[i]);\n\t}\n\tss.push_back(0);\n\tadjacent_difference(ss.begin(), ss.end(), ss.begin());\n\n\tmap<int, vector<int>> m;\n\tREP(i, 0, N) {\n\t\tm[L[i]].push_back(R[i]);\n\t}\n\tPriorityQ<PP> Q;\n\tREP(i, 0, N) {\n\t\tQ.push(PP(L[i], R[i]));\n\t}\n\n\tPP prev(-1, 0);\n\twhile (!Q.empty()) {\n\t\tPP p = Q.top(); Q.pop();\n\t\tif (p.first == p.second) continue;\n\t\tif (prev.first == p.first) {\n\t\t\tQ.push(PP(prev.second, p.second));\n\t\t\tprev = p;\n\t\t\tcontinue;\n\t\t}\n\t\tAdd(p.first, p.second, -ss[p.first]);\n\t\tprev = p;\n\t}\n\tYESNO(all_of(ss.begin(), ss.end(), [](IntMod<26> i) {return i == 0; }));\n\treturn 0;\n}\n\n/*-------------------------*/\n/*-----    二分探索   -----*/\n/*-------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n\nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+35;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+35) {puts(\"NO\");return 0;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==1 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\tif (head[i]==0&&d[i]) {puts(\"NO\");return 0;}\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;fa[i+m0*2+1]=x*m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN], sum[MAXN];\nbool mark[MAXN];\nstring S, T;\nvector<int> G[MAXN];\n\nvoid add(int l, int r){\n\tG[l].pb(r+1);\n\tG[r+1].pb(l);\n}\n\nint dfs(int node){\n\tmark[node]=1;\n\tfor (int v:G[node]) if (!mark[v]) sum[node]+=dfs(v);\n//\tdebug2(node, sum[node])\n\treturn sum[node];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>S>>m;\n\tint len=S.size();\n\tn=len/2;\n\tfor (int i=0; i<n; i++) T+=S.back(), S.pop_back();\n\tif (len&1) S.pop_back();\n\tdebug(S)\n\tdebug(T)\n\t\n\tfor (int i=1; i<=n; i++) A[i]=S[n-i]-T[n-i];\n\tfor (int i=1; i<=n+1; i++) sum[i]=A[i]-A[i-1];\n\twhile (m--){\n\t\tcin>>x>>y;\n\t\tif (len%2){\n\t\t\tif (x==n+1 && y==n+1) continue ;\n\t\t\tif (x==n+1) x++;\n\t\t\tif (y==n+1) y--;\n\t\t\tif (x>n) x--;\n\t\t\tif (y>n) y--;\n\t\t}\n\t\tif (x<=n && y<=n) x=n-x+1, y=n-y+1, swap(x, y);\n\t\telse if (x>n && y>n) x-=n, y-=n;\n\t\telse{\n\t\t\tx=n-x+1;\n\t\t\ty-=n;\n\t\t\tif (x>y) swap(x, y);\n\t\t\tx++;\n\t\t}\n\t\tadd(x, y);\n\t}\n\tdebug(len)\n\tfor (int i=1; i<=n+1; i++) if (!mark[i] && dfs(i)%26) kill(\"NO\")\n\tkill(\"YES\")\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nchar s[200020];\nint f[200020];\nint a[200020];\nint L[200020];\nint R[200020];\nint F(int x) {\n\treturn f[x] != x ? f[x] = F(f[x]) : x;\n}\nvoid U(int x, int y) {\n//  printf(\"%d %d\\n\", x, y);\n\tx = F(x);\n\ty = F(y);\n\tif (x != y) {\n\t\tf[x] = y;\n\t\ta[y] += a[x];\n\t}\n\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tl = strlen(s + 1);\n\tbool caonima = false;\n\tif (l % 2 == 0) {\n\t\tcaonima = true;\n\t\tl++;\n\t\tfor (int i = l; i > (l + 1) / 2; i--) {\n\t\t\ts[i] = s[i - 1];\n\t\t}\n\t\ts[(l + 1) / 2] = '$';\n\t}\n//\tprintf(\"%s\\n\", s + 1);\n\tassert(l % 2 == 1);\n\tm = (l + 1) / 2;\n\tfor (int i = 0; i <= 2 * m; i++) {\n\t\tf[i] = i;\n\t\ta[i] = 0;\n\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &L[i], &R[i]);\n\t\tif (caonima) {\n\t\t\tif (L[i] >= m) {\n\t\t\t\tL[i]++;\n\t\t\t}\n\t\t\tif (R[i] >= m) {\n\t\t\t\tR[i]++;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d %d\\n\", L[i], R[i]);\n\t\tif (L[i] > m) {\n\t\t\tint ll = 2 * m - L[i];\n\t\t\tint rr = 2 * m - R[i];\n\t\t\tL[i] = rr;\n\t\t\tR[i] = ll;\n\t\t}\n\t}\n//  printf(\"---\\n\");\n\tfor (int i = 0; i < m; i++) {\n\t\ta[i] = (s[i + 1] - s[i]) - (s[2 * m - i - 1] - s[2 * m - i]);\n//        printf(\"%d\\n\", a[i]);\n\t}\n//  printf(\"---\\n\");\n\tfor (int i = 0; i < n; i++) {\n//      printf(\"???\\n\");\n//      cerr << L[i] << ' ' << R[i] << endl;\n\t\tif (R[i] < m) {\n\t\t\tU(L[i] - 1, R[i]);\n\t\t} else {\n\t\t\tU(L[i] - 1, 2 * m - R[i]);\n\t\t}\n\t}\n\tbool ok = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[F(i)] == 0 || F(i) == F(0)) {\n\n\t\t} else {\n//\t\t\tprintf(\"%d %d %d\\n\", i, F(i), a[F(i)]);\n\t\t\tok = false;\n\t\t}\n\t}\n\tif (ok) {\n\t\tprintf(\"YES\\n\");\n\t} else {\n\t\tprintf(\"NO\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n  int len = s.size();\n  int n;\n  cin>>n;\n  vector<vector<int>> ranges(len);\n  REP(i,n) {\n    int l, r;\n    cin>>l>>r;\n    --l;--r;\n    int a, b;\n    if (r >= len/2) {\n      if (l >= len/2) {\n        a = len-r-1;\n        b = len-l-1;\n      } else if (l-1 >= len-r-1) {\n        a = len-r-1;\n        b = l-1;\n      } else {\n        a = l;\n        b = len-r-1-1;\n      }\n    } else {\n      a = l;\n      b = r;\n    }\n    if (a <= b) {\n      ranges[a].push_back(b);\n    }\n  }\n  REP(i,len) {\n    if (ranges[i].size() > 1) {\n      sort(ALL(ranges[i]));\n      ranges[i].erase(unique(ALL(ranges[i])), end(ranges[i]));\n      int m = ranges[i].size();\n      REP(j,m-1) {\n        ranges[ranges[i][j]+1].push_back(ranges[i][j+1]);\n      }\n      ranges[i].erase(begin(ranges[i])+1, end(ranges[i]));\n    }\n  }\n  using T = pair<int,int>;\n  priority_queue<T, vector<T>, greater<T>> q;\n  int sum = 0;\n  vector<int> t(len);\n  REP(i,len) {\n    t[i] = s[i] - 'a';\n  }\n  bool ok = true;\n  REP(i,len/2) {\n    if ((t[i]+sum)%26 != t[len-i-1]) {\n      if (ranges[i].empty()) {\n        ok = false;\n        break;\n      }\n      int diff = (t[len-i-1] + 26 - (t[i]+sum)%26)%26;\n      sum += diff;\n      q.emplace(ranges[i][0], diff);\n    }\n    while (!q.empty() && q.top().first == i) {\n      sum -= q.top().second;\n      q.pop();\n    }\n  }\n  if (ok) {\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k) R[i]--;\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nusing ui = uint32_t;\n\nconst int maxn = 50100;\n//bitset<maxn> q[maxn];\nui q[3500 * maxn];\nint off[maxn];\nint qmem[maxn];\nint m;\n\nvoid qset(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  q[off[x] + qmem[x] - 1 - (m - y) / 32] |= (ui(1) << (m - y) % 32);\n}\n\nbool qget(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  return q[off[x] + qmem[x] - 1 - (m - y) / 32] & (ui(1) << (m - y) % 32);\n}\n\nvoid qor(int x, int y) {\n  for (int i = 0; i < qmem[y]; ++i) {\n    int block = off[y] + i;\n    int from = off[x] + qmem[x] - qmem[y] + i;\n    q[block] |= q[from];\n  }\n}\n\nint qfind_first(int x) {\n  for (int i = 0; i < qmem[x]; ++i) {\n    if (q[off[x] + i]) {\n      for (int j = 0; j < 32; ++j) {\n        if (qget(x, i * 32 + j))\n          return i * 32 + j;\n      }\n      assert(false);\n    }\n  }\n  return maxn;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  m = n / 2;\n  int OFF = 0;\n  for (int i = m; i >= 0; --i) {\n    int mem = (m - i + 1 + 7) / 8;\n    off[i] = OFF;\n    qmem[i] = mem;\n    OFF += mem;\n  }\n\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      qset(nl, nr);\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = qfind_first(i);\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      qor(to, i);\n      //q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\nconst int MOD = 26;\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntemplate<class T, int SZ> struct LazySeg {\n    T sum[2 * SZ], lazy[2 * SZ];\n    LazySeg() {\n        for (int i = 0; i < 2 * SZ; i++) {\n            sum[i] = 0;\n            lazy[i] = 0;\n        }\n    }\n    void push(int ind, int L, int R) {\n        sum[ind] += (R - L + 1) * lazy[ind];\n        if (L != R) {\n            lazy[2 * ind] += lazy[ind];\n            lazy[2 * ind + 1] += lazy[ind];\n        }\n        lazy[ind] = 0;\n    }\n    void pull(int ind) {\n        sum[ind] = sum[2 * ind] + sum[2 * ind + 1];\n    }\n    void build() {\n        for (int i = SZ - 1; i >= 1; i--) {\n            pull(i);\n        }\n    }\n    void upd(int lo, int hi, T inc, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (hi < L || R < lo) return ;\n        if (lo <= L && R <= hi) {\n            lazy[ind] = inc;\n            push(ind, L, R);\n            return;\n        }\n        int M = (L + R) / 2;\n        upd(lo, hi, inc, 2 * ind, L, M);\n        upd(lo, hi, inc, 2 * ind + 1, M + 1, R);\n        pull(ind);\n    }\n    T qsum(int lo, int hi, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return sum[ind];\n        int M = (L + R) / 2;\n        return qsum(lo, hi, 2 * ind, L, M) + qsum(lo, hi, 2 * ind + 1, M + 1, R);\n    }\n};\nint main() {\n//    ios_base::sync_with_stdio(0); cin.tie(0);\n//    freopen(\"file.in\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    int len = s.size();\n    vector<pair<int, int>> use;\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (r < len / 2) {\n            use.emplace_back(l, r);\n            continue;\n        }\n        if (l >= (len + 1) / 2) {\n            use.emplace_back(len - 1 - r, len - 1 - l);\n            continue;\n        }\n        if (l == len - 1 - r) {\n            continue;\n        }\n        if (l < len - 1 - r) {\n            use.emplace_back(l, len - 1 - r - 1);\n        } else {\n            use.emplace_back(len - 1 - r, l - 1);\n        }\n    }\n    int half = (len - 1) / 2 + 1;\n    vector<vector<int>> loc(half);\n    for (auto x: use) {\n        loc[x.first].push_back(x.second);\n    }\n    for (int i = 0; i < half; i++) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        while(loc[i].size() > 1) {\n            int r = loc[i].back();\n            loc[i].pop_back();\n            int l = loc[i].back() + 1;\n            loc[l].push_back(r);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int r: loc[i]) {\n            use.emplace_back(i, r);\n        }\n        loc[i].clear();\n    }\n    for (auto x: use) {\n        loc[x.second].push_back(x.first);\n    }\n    use.clear();\n    for (int i = half - 1; i >= 0; i--) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        reverse(loc[i].begin(), loc[i].end());\n        while (loc[i].size() > 1) {\n            int l = loc[i].back();\n            loc[i].pop_back();\n            int r = loc[i].back() - 1;\n            loc[r].push_back(l);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int l: loc[i]) {\n            use.emplace_back(l, i);\n        }\n        loc[i].clear();\n    }\n    string t;\n    for (int i = len - 1; i >= len - half; i--) {\n        t += s[i];\n    }\n    while (s.size() > half) {\n        s.pop_back();\n    }\n    len = half;\n    LazySeg<mi, (1 << 16)> seg;\n    for (int i = 0; i < len; i++) {\n        seg.upd(i, i, s[i] - '0');\n    }\n    sort(use.begin(), use.end());\n    for (auto x: use) {\n        int l = x.first;\n        int r = x.second;\n        int add = ((t[l] - '0') - seg.qsum(l, l).val + MOD) % MOD;\n        seg.upd(l, r, add);\n    }\n    for (int i = 0; i < len; i++) {\n        if (seg.qsum(i, i) != t[i] - '0') {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\nconst ll MOD=998244353;\nconst int N=510000;\n\n\nmain(){\n    string s;cin>>s;\n    int n=s.size();\n    vec b;\n    rep(i,n/2){\n        b.pb((26+s[i]-s[n-1-i]));\n        if(b.back()>=26)b.back()-=26;\n    }\n    vector<vec> p(n);\n    int q=in();\n    rep(i,q){\n        int l=in(),r=in();\n        if(r<=n/2){\n            p[l-1].pb(r-1);\n        }\n        else if(l>n/2){\n            p[n-r].pb(n-l);\n        }\n        else {\n            r=n-r;\n            p[r].pb(l-2);\n        }\n    }\n    rep(i,n/2){\n        if(p[i].size())\n        sort(all(p[i]));\n        rep(j,(int)p[i].size()-1){\n            p[p[i][j]+1].pb(p[i][j+1]);\n        }\n    }\n    vec rui(n);\n    rep(i,n/2){\n        // cout<<b[i]<<\" \"<<rui[i]<<endl;\n        b[i]+=rui[i];\n        b[i]%=26;\n        if(b[i]){\n            if(p[i].size()==0){\n                cout<<\"NO\";return 0;\n            }\n            else{\n                rui[i]+=26-b[i];\n                rui[p[i][0]+1]-=26-b[i];\n            }\n        }\n        rui[i+1]+=rui[i];\n        if(rui[i+1]>=26)rui[i+1]-=26;\n    }\n    cout<<\"YES\";return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N];\nchar s[N];\nvector<int> vct[N];\nvoid add(int x,int y)\n{\n\twhile(x<=m/2)\n\t{\n\t\tc[x]=(c[x]+y)%26;\n\t\tx+=x&-x;\n\t}\n}\nint sum(int x)\n{\n\tint rtn=0;\n\twhile(x>=1)\n\t{\n\t\trtn=(rtn+c[x])%26;\n\t\tx-=x&-x;\n\t}\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=(s[m-i+1]-s[i]+26)%26;\n\t\tadd(i,j);\n\t\tadd(i+1,(26-j)%26);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=sum(i);\n\t\tif(vct[i].empty())\n\t\t{\n\t\t\tif(j!=0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsort(vct[i].begin(),vct[i].end());\n\t\tadd(i+1,(26-j)%26);\n\t\tadd(vct[i][0]+1,j);\n\t\tfor(j=1;j<vct[i].size();++j)\n\t\t\tif(vct[i][0]+1<=vct[i][j])\n\t\t\t\tvct[vct[i][0]+1].push_back(vct[i][j]);\n\t\t/*for(j=1,k=vct[i][0]+1;j<vct[i].size()&&k<=m/2;++j)\n\t\t\tif(k<=vct[i][j])\n\t\t\t\tvct[k++].push_back(vct[i][j]);*/\n\t\tvct[i].clear();\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\tini[nuevo.first].insert(nuevo.second);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = ini[i].size();\n\t\tauto it = ini[i].begin();\n\t\tif(sz == 1){\n\t\t\tfin[*it].insert(i);\n\t\t}else if(sz > 1){\n\t\t\tLong ant = i;\n\t\t\twhile(it != ini[i].end()){\n\t\t\t\tfin[*it].insert(ant);\n\t\t\t\tant = *it + 1;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<Long,Long> > rangos;\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = fin[i].size();\n\t\tauto it = fin[i].begin();\n\t\tif(sz == 1){\n\t\t\trangos.push_back({*it,i});\n\t\t}else if(sz > 1){\n\t\t\tLong ant = *it;\n\t\t\twhile(it != fin[i].end()){\n\t\t\t\tit++;\n\t\t\t\tif(it == fin[i].end()){\n\t\t\t\t\trangos.push_back({ant,i});\n\t\t\t\t}else{\n\t\t\t\t\trangos.push_back({ant,*it-1});\n\t\t\t\t\tant = *it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nchar s[200020];\nint f[200020];\nint a[200020];\nint L[200020];\nint R[200020];\nint F(int x) {\n\treturn f[x] != x ? f[x] = F(f[x]) : x;\n}\nvoid U(int x, int y) {\n//\tprintf(\"%d %d\\n\", x, y);\n\tx = F(x);\n\ty = F(y);\n\tif (x != y) {\n\t\tf[x] = y;\n\t\ta[y] += a[x];\n\t}\n\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tl = strlen(s + 1);\n\tbool caonima = false;\n\tif (l % 2 == 0) {\n\t\tcaonima = true;\n\t\tl++;\n\t\tfor (int i = l; i > (l + 1) / 2; i--) {\n\t\t\ts[i] = s[i - 1];\n\t\t}\n\t\ts[(l + 1) / 2] = '$';\n\t}\n//\tprintf(\"%s\\n\", s + 1);\n\tassert(l % 2 == 1);\n\tm = (l + 1) / 2;\n\tfor (int i = 0; i < 2 * m; i++) {\n\t\tf[i] = i;\n\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &L[i], &R[i]);\n\t\tif (caonima) {\n\t\t\tif (L[i] >= m) {\n\t\t\t\tL[i]++;\n\t\t\t}\n\t\t\tif (R[i] >= m) {\n\t\t\t\tR[i]++;\n\t\t\t}\n\t\t}\n\t\tif (L[i] > m) {\n\t\t\tint ll = 2 * m - L[i];\n\t\t\tint rr = 2 * m - R[i];\n\t\t\tL[i] = rr;\n\t\t\tR[i] = ll;\n\t\t}\n\t}\n//\tprintf(\"---\\n\");\n\tfor (int i = 0; i < m; i++) {\n\t\ta[i] = (s[i + 1] - s[i]) - (s[2 * m - i - 1] - s[2 * m - i]);\n//\t\tprintf(\"%d\\n\", a[i]);\n\t}\n//\tprintf(\"---\\n\");\n\tfor (int i = 0; i < n; i++) {\n//\t\tprintf(\"???\\n\");\n\t\tif (R[i] < m) {\n\t\t\tU(L[i] - 1, R[i]);\n\t\t} else {\n\t\t\tU(L[i] - 1, l - R[i]);\n\t\t}\n\t}\n\tbool ok = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[F(i)] == 0 || F(i) == F(0)) {\n\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\tok = false;\n\t\t}\n\t}\n\tif (ok) {\n\t\tprintf(\"YES\\n\");\n\t} else {\n\t\tprintf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define pb push_back\n\nconst int N = 1e5 + 10;\n\ntypedef pair<int, int> ii;\n\nstring s;\nint n, m;\nint a[N], pr[N], sum[N];\nii t[N];\n\nint findn(int i) {\n    return (pr[i] == i) ? i : (pr[i] = findn(pr[i]));\n}\n\nvoid uni(int u, int v)  {\n    if(findn(u) != findn(v))    {\n        int pu = findn(u), pv = findn(v);\n        sum[pu] = (sum[pu] + sum[pv]) % 26;\n        pr[pv] = pu;\n    }\n}\n\nsigned main()\n{\n    //freopen(\"test.inp\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> s >> m;\n    FOR(i, 1, m) cin >> t[i].fi >> t[i].se, t[i].se ++;\n    n = s.length() + 1;\n    for(int i = 0; i < s.length(); ++i) {\n        a[i + 2] = s[i] - 'a';\n        //cout << a[i + 2] << ' ';\n    }\n    //cout << '\\n';\n    FOR(i, 1, n) a[i] = (a[i] - a[i + 1]) % 26;\n    //FOR(i, 1, n) cout << a[i] << ' ';\n    FOR(i, 1, n) pr[i] = i, sum[i] = a[i];\n    FOR(i, 1, m)    uni(t[i].fi, t[i].se);\n    FOR(i, 1, n / 2) uni(i, n - i + 1);\n    FOR(i, 1, n) if(sum[findn(i)] != 0) {\n        cout << \"NO\";\n        return 0;\n    }\n    cout << \"YES\"; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nchar s[200020];\nint f[200020];\nint a[200020];\nint L[200020];\nint R[200020];\nint F(int x) {\n\treturn f[x] != x ? f[x] = F(f[x]) : x;\n}\nvoid U(int x, int y) {\n//\tprintf(\"%d %d\\n\", x, y);\n\tx = F(x);\n\ty = F(y);\n\tif (x != y) {\n\t\tf[x] = y;\n\t\ta[y] += a[x];\n\t}\n\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tl = strlen(s + 1);\n\tbool caonima = false;\n\tif (l % 2 == 0) {\n\t\tcaonima = true;\n\t\tl++;\n\t\tfor (int i = l; i > (l + 1) / 2; i--) {\n\t\t\ts[i] = s[i - 1];\n\t\t}\n\t\ts[(l + 1) / 2] = '$';\n\t}\n//\tprintf(\"%s\\n\", s + 1);\n\tassert(l % 2 == 1);\n\tm = (l + 1) / 2;\n\tfor (int i = 0; i < 2 * m; i++) {\n\t\tf[i] = i;\n\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &L[i], &R[i]);\n\t\tif (caonima) {\n\t\t\tif (L[i] >= m) {\n\t\t\t\tL[i]++;\n\t\t\t}\n\t\t\tif (R[i] >= m) {\n\t\t\t\tR[i]++;\n\t\t\t}\n\t\t}\n\t\tif (L[i] > m) {\n\t\t\tint ll = 2 * m - L[i];\n\t\t\tint rr = 2 * m - R[i];\n\t\t\tL[i] = rr;\n\t\t\tR[i] = ll;\n\t\t}\n\t}\n//\tprintf(\"---\\n\");\n\tfor (int i = 0; i < m; i++) {\n\t\ta[i] = (s[i + 1] - s[i]) - (s[2 * m - i - 1] - s[2 * m - i]);\n//\t\tprintf(\"%d\\n\", a[i]);\n\t}\n//\tprintf(\"---\\n\");\n\tfor (int i = 0; i < n; i++) {\n//\t\tprintf(\"???\\n\");\n//\t\tcerr << L[i] << ' ' << R[i] << endl;\n\t\tif (R[i] < m) {\n\t\t\tU(L[i] - 1, R[i]);\n\t\t} else {\n\t\t\tU(L[i] - 1, l - R[i]);\n\t\t}\n\t}\n\tbool ok = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[F(i)] == 0 || F(i) == F(0)) {\n\n\t\t} else {\n//\t\t\tprintf(\"%d\\n\", i);\n\t\t\tok = false;\n\t\t}\n\t}\n\tif (ok) {\n\t\tprintf(\"YES\\n\");\n\t} else {\n\t\tprintf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, vector<bool> &used, int &s, vec &D){\n        used[v] = true;\n        s = (s + D[v]) % 26;\n        REP(k, G[v].size()){\n            if(!used[G[v][k].to]) dfs(G[v][k].to, used, s, D);\n        }\n    }\n\n};\n\nsigned main(){\n\n    string S; cin >> S;\n    int M = S.size();\n    vec D(M + 1);\n    D[0] = (int)(S[0] - 'a');\n    D[M] = (26 - (int)(S[M - 1] - 'a')) % 26;\n    REP(i, M - 1) D[i + 1] = ((int)(S[i + 1] - S[i]) + 26) % 26;\n    Graph G(M + 1);\n    REP(i, M + 1) if(i < M - i) G.add_edge2(i, M - i, 0);\n\n    int N; cin >> N;\n    int L, R;\n    REP(i, N){\n        cin >> L >> R;\n        G.add_edge2(L - 1, R, 0);\n    }\n\n    vector<bool> used(M + 1, false);\n    bool ans = true;\n    REP(i, M + 1){\n        if(!used[i]){\n            int s = 0;\n            G.dfs(i, used, s, D);\n            if(s) ans = false;\n        }\n    }\n    ANS(ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100100;\n\nint N;\nint n, qn;\nchar s[maxn + 5];\n\nint dif[maxn + 5];\n\nint fa[maxn + 5];\n\nint get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }\n\nint sum[maxn + 5];\n\nint where[maxn + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tstatic char tmp[maxn + 5];\n\tscanf(\"%s\", tmp);\n\tn = strlen(tmp);\n\tint cur = 0;\n\ts[cur++] = '#';\n\tREP(i, 0, n)\n\t{\n\t\tif ((i << 1) == n) s[cur++] = '#';\n\t\twhere[i] = cur;\n\t\ts[cur++] = tmp[i];\n\t}\n\ts[cur++] = '#';\n\tn = cur;\n\tint mid = n >> 1;\n\tN = mid;\n\tREP(i, 0, N)\n\t{\n\t\tdif[i] = (s[n - (N - i) - 1] - s[n - (N - i)]) - (s[N - i] - s[N - i - 1]);\n\t}\n\tREP(i, 0, N) fa[i] = i;\n\tscanf(\"%d\", &qn);\n\tREP(i, 0, qn)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y), --x, --y;\n\t\tx = where[x];\n\t\ty = where[y];\n\t\tif (y < mid)\n\t\t{\n\t\t\tx = mid - x;\n\t\t\ty = mid - y - 1;\n\t\t}\n\t\telse if (x > mid)\n\t\t{\n\t\t\tx = x - mid - 1;\n\t\t\ty = y - mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx = mid - x;\n\t\t\ty = y - mid;\n\t\t}\n\t\tfa[get(x)] = get(y);\n\t}\n\tREP(i, 0, N) sum[get(i)] += dif[i];\n\tputs(\"YES\");\n\treturn 0;\n\tREP(i, 0, N) if (fa[i] == i && sum[i])\n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N], x[N], root[N], summ[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) return x;\n    return root[x] = Root(root[x]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (s[s.size() - 1 - i] + 26 - s[i]) % 26;\n    }\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    iota(root, root + len + 2, 0);\n    fill(sz, sz + len + 2, 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = Root(l[i]), b = Root(r[i]);\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    for (int i = 1; i < len + 2; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i < len + 2; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            cout << \"NO\", exit(0);\n        }\n    }\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// combi.cpp\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 100010;\nconst int ABC = 26;\n\nvoid wrong()\n{\n    cout << \"NO\" << endl;\n    exit(0);\n}\n\nstruct DSU\n{\n    int a[MAX_N + 1], n;\n    DSU(int _n)\n    {\n\t\tn = _n;\n\t\tfor (int i = 0; i <= n; ++i) a[i] = i;\n    }\n    int root(int x) { return (x == a[x] ? x : a[x] = root(a[x])); }\n    void merge(int x, int y)\n    {\n    \tif (root(x) == root(y)) return;\n        x = root(x); y = root(y);\n        if (x > y) swap(x, y);\n        a[y] = x;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n};\n\nint mod(int x, int m)\n{\n    while (x < 0) x += m;\n    while (x >= m) x -= m;\n    return x;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    string S; cin >> S;\n    int sz = S.size();\n    int N; cin >> N;\n\n    // dsu\n    int maxn = sz / 2;\n    DSU dsu(maxn);\n\n    for (int i = 0; i < N; ++i) {\n        int l, r; cin >> l >> r; --l;\n        l = min(l, sz-l);\n        r = min(r, sz-r);\n        dsu.merge(l, r);\n//        cerr << 's' << l << ' ' << r << endl;\n\t}\n\n\tvector<int> vec[maxn+1];\n    for (int i = 0; i <= maxn; ++i) {\n//        cerr << dsu.root(i) << ' ';\n    \tvec[dsu.root(i)].push_back(i);\n    }\n//    cerr << endl;\n\n    int nxt[maxn+1];\n    for (int i = 0; i <= maxn; ++i) {\n\t\tif (vec[i].empty()) continue;\n        sort(vec[i].begin(), vec[i].end());\n        for (int j = 1; j < vec[i].size(); ++j) {\n            nxt[ vec[i][j-1] ] = vec[i][j];\n        }\n        nxt[ vec[i][vec[i].size() - 1] ] = -1;\n    }\n\n//    for (int i = 0; i <= maxn; ++i) {\n//        cerr << nxt[i] << ' ';\n//    }\n//    cerr << endl;\n\n\n    // new string\n    int ch[maxn];\n    for (int i = 0; i < maxn; ++i) {\n        ch[i] = mod(S[i] - S[sz-1-i], ABC);\n//        cerr << ch[i] << ' ';\n    }\n//    cerr << endl;\n\n    // process\n    int add[maxn+1], cur = 0;\n    memset(add, 0, sizeof add);\n    for (int i = 0; i < maxn; ++i) {\n        cur += add[i];\n        cur = mod(cur, ABC);\n\n        ch[i] = mod(ch[i] + cur, ABC);\n        if (ch[i] == 0) continue;\n        if (nxt[i] < 0) wrong();\n\n        cur += mod(-ch[i], ABC);\n        cur = mod(cur, ABC);\n\n        add[ nxt[i] ] += mod(ch[i], ABC);\n        add[ nxt[i] ] = mod(add[ nxt[i] ], ABC);\n    }\n\n    cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\nvector< pair<Long,Long> > rangos;\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\trangos.push_back({nuevo.first,nuevo.second});\n\t}\n\t\nsort(rangos.begin(),rangos.end());\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DBP\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define deb(...) 0\n#endif\n#define fst first\n#define snd second\n#define fore(x,a,b) for(int x=(a), qwerty=(b); x<qwerty; x++)\n#define pb push_back\n#define mset(a,v) memset((a),(v),sizeof(a))\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(a) int((a).size())\n#define FIN ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e5+5;\nstring s;\nint n,m,A[N],B[N],P[N],sum[N];\n\nint find(int u){return u==P[u]?u:P[u]=find(P[u]);}\nvoid join(int i, int j){\n    int x=find(i), y=find(j);\n    if(x!=y){\n        sum[x] += sum[y];\n        P[y] = x;\n    } \n}\n\nint main(){FIN;\n    cin >> s >> m;n=SZ(s);\n    fore(x,0,n)A[x+1]=s[x]-'a';\n    fore(x,0,n+1)B[x]=(A[x+1]-A[x]+26)%26;\n    fore(x,0,n+1)P[x]=x,sum[x]=B[x];\n    fore(x,0,n+1)join(x,n-x);\n    fore(x,0,m){\n        int a,b;cin>>a>>b;a--;\n        join(a,b);\n    }\n    bool can = 1;\n    fore(x,0,n+1)if(find(x)==x)can &= sum[x]%26 == 0;\n    cout << (can ? \"Yes\":\"No\")<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N],sum[N],p[N];\nchar s[N];\nvector<int> vct[N];\nint find(int x)\n{\n\treturn !p[x]?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2;++i)\n\t\tc[i]=(s[m-i+1]-s[i]+26)%26;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=m/2+1;i>=1;--i)\n\t\tsum[i]=(c[i]=(c[i]-c[i-1]+26)%26);\n\tfor(i=1;i<=m/2;++i)\n\t\tfor(j=vct[i].size()-1;j>=0;--j)\n\t\t{\n\t\t\tif(find(i)!=find(vct[i][j]+1))\n\t\t\t{\n\t\t\t\tsum[find(vct[i][j]+1)]=(sum[find(vct[i][j]+1)]+sum[find(i)])%26;\n\t\t\t\tp[find(i)]=find(vct[i][j]+1);\n\t\t\t}\n\t\t}\n\tfor(i=1;i<=m/2+1;++i)\n\t\tif(find(i)==i&&sum[i])\n\t\t{\n\t\t\tprintf(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= i) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int MX=100010;\n\n\nchar S[MX];\nint n, m, k;\nstruct ord {\n\tint l, r;\n\tvoid scan(){\n\t\tcin>>l>>r;\n\t}\n\tvoid norm(){\n\t\tif(r<=k) return;\n\t\tif(k<l){ tie(l,r)=pii(n-r+1, n-l+1); return; }\n\t\tif(l<=n-r+1) r=n-r;\n\t\telse if(n-l+1<=r) tie(l,r)=pii(n-r+1,l-1);\n\t\telse assert(false);\n\t}\n} V[MX];\nint A[MX], B[MX];\n\nint U[MX];\nint find(int x){ return x==U[x] ? x : U[x]=find(U[x]); }\nvoid unite(int x, int y){ U[find(y)]=find(x); }\n\nbool solve(){\n\tint sum[MX]={};\n\n\tfor(int i=1; i<=k+1; i++){\n\t\tsum[find(i)]+=B[i];\n\t}\n\tfor(int i=1; i<=k+1; i++) if(sum[i]%26!=0) return false;\n\treturn true;\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>(S+1)>>m;\n\tfor(n=1; S[n+1]!='\\0'; n++);\n\tk=n/2;\n\tfor(int i=1; i<=k+1; i++) U[i]=i;\n\n\tfor(int i=1; i<=m; i++) V[i].scan(), V[i].norm();\n\tfor(int i=1; i<=k; i++) A[i]=(S[i]-S[n-i+1]+26)%26;\n\tfor(int i=1; i<=k+1; i++) B[i]=(A[i]-A[i-1]+26)%26;\n\n\tfor(int i=1; i<=m; i++) unite(V[i].l, V[i].r+1);\n\n\tcout<<(solve() ? \"YES\" : \"NO\")<<'\\n';\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (f[x] != f[y]) {\n    f[x] = find(y);\n    d[x] = (d[y] + d[x]) % 26;\n  }\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return diff == 0;\n  f[ry] = rx;\n  d[ry] = (d[x] - d[y] - diff + d[rx]) % 26;\n  if (d[ry] < 0) d[ry] += 26;\n  return true;\n}\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[n - 1 - i] - s[i] + 26) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=n;i--;)\n#define rrep2(i,n) for(ll i=n;i--;)\n#define rrep3(i,a,b) for(ll i=b;i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&&i:a)\n#define each2(x,y,a) for(auto&&[x,y]:a)\n#define each3(x,y,z,a) for(auto&&[x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type>name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type>name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > T(b)){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < T(b)){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\nconstexpr uint mod = 26;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint() noexcept {}\n    constexpr Modint(const Modint &x) noexcept : num(x.num){}\n    inline constexpr operator ll() const noexcept { return num; }\n    inline constexpr Modint& operator+=(Modint x) noexcept { num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++() noexcept { if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator-() const noexcept { return Modint(0) -= *this; }\n    inline constexpr Modint operator-(Modint x) const noexcept { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x) noexcept { if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--() noexcept { if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x) noexcept { num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x) noexcept { return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x) noexcept {\n        using U = typename conditional<sizeof(T) >= 4, T, int>::type;\n        U y = x; y %= U(mod); if(y < 0) y += mod; num = uint(y);\n    }\n    template<class T> inline constexpr Modint operator+(T x) const noexcept { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x) noexcept { return operator+=(Modint(x)); }\n    template<class T> inline constexpr Modint operator-(T x) const noexcept { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x) noexcept { return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator*(T x) const noexcept { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x) noexcept { return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/(T x) const noexcept { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x) noexcept { return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x){ ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n    if(r < 0 || n < r) return 0;\n    if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }\n    reserve(n + 1); return fac[n] * inv[n - r];\n}\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nstruct UnionFind{\n    vector<ll>data;\n    UnionFind(ll n):data(n,-1){}\n    bool unite(ll a,ll b){\n        a=root(a);b=root(b);\n        if(a==b)return 1;\n        if(data[a]>data[b])swap(a,b);\n        data[a]+=data[b];\n        data[b]=a;\n        return 0;\n    }\n    bool find(ll a,ll b){return root(a)==root(b);}\n    ll root(ll a){return data[a]<0?a:data[a]=root(data[a]);}\n    ll size(ll a){return -data[root(a)];}\n    ll operator[](ll a){return root(a);}\n};\nsigned main(){\n    STR(s);\n    LL(n);\n    VEC(pll,a,n);\n    n=s.size();\n    vec(Modint,t,n/2);\n    rep(n/2)t[i]=s[i]-s[n-1-i];\n    t.insert(t.begin(),0);\n    rep(n/2)t[i]=t[i+1]-t[i];\n    t[n/2]=-t[n/2];\n    UnionFind uf(n/2+1);\n    each(l,r,a){\n        l--;\n        if(l>n-r)tie(l,r)=pll{n-r,n-l};\n        chmin(r,n-r);\n        uf.unite(l,r);\n    }\n    vec(Modint,cnt,n/2+1);\n    rep(n/2+1)cnt[uf[i]]+=t[i];\n    YES(all_of(all(cnt),logical_not()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[101000];\nint l,n,T,a[101000],x,y,fa[101000];\n\nint GF(int x){\n\treturn fa[x]==x? x: fa[x]=GF(fa[x]);\n}\n\nint main(){\n\tscanf(\"%s\",s+1); l=strlen(s+1); n=l>>1;\n\tfor (int i=1;i<=n;++i) a[i]=s[i]-s[l-i+1];\n\tfor (int i=n+1;fa[i]=i;--i) a[i]-=a[i-1];\n\tfor (cin>>T;T--;){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>n){\n\t\t\tx=l+1-x;\n\t\t\ty=l+1-y;\n\t\t\tswap(x,y);\n\t\t}else if (y>n){\n\t\t\ty=l+1-y;\n\t\t\tif (x>y) swap(x,y);\n\t\t\t--y;\n\t\t}\n\t\tif (x>n||x>y) continue;\n\t\tx=GF(x), y=GF(min(y,n)+1);\n\t\tif (x-y){\n\t\t\ta[x]+=a[y];\n\t\t\tfa[y]=x;\n\t\t}\n\t}\n\tfor (int i=1;i<=n+1;++i) if (fa[i]==i&&a[i]%26)\n\t\treturn !puts(\"NO\");\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  for(int i = 0; i < st.size(); i++) {\n\n    map< int, int > mp;\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(mp.count(ind[other])) {\n          if((S[other] - S[idx] + 26) % 26 != mp[ind[other]]) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        } else {\n          mp[ind[other]] = (S[other] - S[idx] + 26) % 26;\n        }\n      }\n    }\n\n  }\n\n  throw (0);\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,LL>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A;\n\t\tA = A * A;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, 0}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(5, id);\n\t\t\tLL po3 = fast(3, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total -= po3;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, total3}) == ms.end()) ms[{total, total3}] = i;\n\t\tpar[i] = ms[{total, total3}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N], x[N], root[N], summ[N], sz[N];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i <= len; i++)\n    //{\n    //    cout << x[i] << \" \";\n    //}\n    //cout << endl;\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    iota(root, root + len + 2, 0);\n    fill(sz, sz + len + 2, 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    for (int i = 1; i < len + 2; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i <= len; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    if (t == -1) cout << \"YES\", exit(0);\n    int s = 0;\n    while (s != root[s]) s = root[s];\n    if (s == t) cout << \"YES\", exit(0);\n    else cout << \"NO\", exit(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n \n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n \ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n \n  WeightedUnionFind() {}\n \n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n \n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n \n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n \n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n \n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n \n  T diff(int x, int y)\n  {\n    return weight(y) - weight(x);\n  }\n};\n \ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n \n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n \n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n \n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n \nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n \n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n \n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          diff %= 26;\n          int diff2 = (S[other] - S[idx] + 26) % 26;\n          if(max(diff, 26 - diff) != max(diff2, 26 - diff2)) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n \n  }\n \n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,m,a[N],sum;\nvector<int> g[N];\nbool vis[N];\nchar s[N];\n\nvoid add(int x,int y){\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tsum+=a[u];\n\tfor (int v:g[u]){\n\t\tif (!vis[v]) dfs(v);\n\t}\n}\n\nint main(){\n\tscanf(\"%s\",s+1); m=strlen(s+1);\n\tfor (int i=1;i<=m/2;++i) a[i]=s[i]-s[m-i+1];\n\ta[m/2+1]-=a[m/2];\n\tfor (int i=m/2;i;--i) a[i]-=a[i-1];\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tif (x<=m/2&&y>=m-m/2+1){\n\t\t\tint l1=m/2-x,l2=y-(m-m/2+1);\n\t\t\tif (l1>l2){\n\t\t\t\ty=m-y+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty=m-y+1;\n\t\t\t\tswap(x,y);\n\t\t\t}\n\t\t\t--y;\n\t\t}\n\t\tif (x>m/2){\n\t\t\tx=m-x+1; y=m-y+1;\n\t\t\tswap(x,y);\n\t\t}\n\t\tif (y>m/2) y=m/2;\n\t\tif (x<=y) add(x,y+1);\n\t}\n\tfor (int i=1;i<=m/2+1;++i){\n\t\tsum=0;\n\t\tif (!vis[i]) dfs(i);\n\t\tif (sum){puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n\nchar str_def[199999];\nint S[59999];\nint M,M_hf;\nint N;\nusing namespace std;\npriority_queue <int, vector<int>,greater<int> > oper[59999];\nint cmp(const void *ka,const void *kb) {\n\tint a=*(int *)ka;\n\tint b=*(int *)kb;\n\treturn a-b;\n}\nvoid add(int L,int R) {\n\tif(L==R) return;\n\tif(L>R) {\n\t\toper[R].push(L);\n\t} else {\n\t\toper[L].push(R);\n\t}\n}\nint mod26(int x) {\n\twhile(x<0) x+=26;\n\treturn x%26;\n}\nint eff[59999];\nint main() {\n\tscanf(\"%s\",str_def);\n\twhile(str_def[M]!='\\0') M++;\n\tM_hf=M/2;\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++) {\n\t\tint L,R;\n\t\tscanf(\"%d%d\",&L,&R);\n\t\tL--;\n\t\tif(L>=M_hf+M%2) {\n\t\t\tadd(M-R,M-L);\n\t\t} else if(R>=M_hf+M%2) {\n\t\t\tadd(L,M-R);\n\t\t} else {\n\t\t\tadd(L,R);\n\t\t}\n\t}\n\t//printf(\"%d\\n\",M_hf);\n\tfor(int i=0;i<M_hf;i++) S[i]=mod26((int)str_def[M-1-i]-(int)str_def[i]);\n\t//for(int i=0;i<M_hf;i++) printf(\"%d\\n\",S[i]);\n\tfor(int i=M_hf-1;i>0;i--) S[i]=mod26(S[i]-S[i-1]);\n\t//for(int i=0;i<M_hf;i++) printf(\"%d\\n\",S[i]);\n\tfor(int i=0;i<M_hf;i++) {\n\t\tint req=mod26(S[i]+eff[i]);\n\t\t//printf(\"%d %d %d\\n\",i,S[i],eff[i]);\n\t\tif(oper[i].size()) {\n\t\t\tint top = oper[i].top();\n\t\t\t//printf(\"%d\\n\",top);\n\t\t\teff[top]+=req;\n\t\t\tint recent = top;\n\t\t\toper[i].pop();\n\t\t\twhile(oper[i].size()) {\n\t\t\t\ttop = oper[i].top();\n\t\t\t\tif(recent!=top) {\n\t\t\t\t\tadd(recent,top);\n\t\t\t\t\trecent=top;\n\t\t\t\t}\n\t\t\t\toper[i].pop();\n\t\t\t}\n\t\t} else {\n\t\t\tif(req) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<ll, ll>  ii;\ntypedef vector<ll>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst ll INF = ll(1e9 + 7);\n\nconst ll tam = 100010;\n\nvector<ll> G[tam];\nll val[tam];\nbool vis[tam];\n\nll sum;\nvoid dfs(ll v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (ll u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    ll n;\n    cin >> n;\n    for (ll i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    if (s.size() == 1)\n    {\n    \tcout << \"YES\" << '\\n';\n    \treturn 0;\n    }\n    s = \"a\" + s + \"a\";\n\n    //cout << s << endl;\n\tfor (ll i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \t//cout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    //cout << endl;\n\n    for (ll i = 0; i < n; i++)\n    {\n    \t//val[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \t//val[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = false;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tset<S>::iterator it=st.lower_bound((S){i,0});\n\t\tif(it==st.end()||it->s!=i) continue;\n\t\tS range=*it;\n\t\twhile(1)\n\t\t{\n\t\t\tset<S>::iterator it2=st.lower_bound((S){i,0});\n\t\t\tit2++;\n\t\t\tif(it2==st.end()||it2->s!=range.s) break;\n\t\t\tS etemp=*it2;\n\t\t\tst.insert((S){range.e+1,etemp.e});\n\t\t\tst.erase(etemp);\n\t\t}\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t}\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\twhile(!st.empty()&&st.begin()->s<i) st.erase(st.begin());\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nchar S_[101010];\nint N, L[101010], R[101010];\nint S[101010];\nint D[101010];\n\nconst int W = 26;\n\nint uf[101010];\nint root(int p)\n{\n    return uf[p] < 0 ? p : (uf[p] = root(uf[p]));\n}\nvoid join(int p, int q)\n{\n    p = root(p); q = root(q);\n    if (p == q) return;\n    uf[p] += uf[q];\n    uf[q] = p;\n}\n\nvector<int> grps[101010];\n\nstruct data\n{\n    int sum;\n    set<int> *pos, *neg;\n\n    int toppos() const {\n        if (pos->empty()) return 1000000;\n        return *(pos->begin());\n    }\n    int topneg() const {\n        if (neg->empty()) return 1000000;\n        return *(neg->begin());\n    }\n    int top() const {\n        return min(toppos(), topneg());\n    }\n    int size() const {\n        return pos->size() + neg->size();\n    }\n    bool isneg() const {\n        int a = toppos();\n        int b = topneg();\n        return a > b;\n    }\n    data(int sum, set<int> *pos, set<int> *neg) : sum(sum), pos(pos), neg(neg) {}\n};\n\ninline bool operator<(const data& a, const data& b) {\n    return a.top() < b.top() || (a.top() == b.top() && (i64)a.pos < (i64)b.pos);\n}\n\nset<data> eqs;\n\nvoid waf(set<int> *pos, set<int> *neg, int v)\n{\n    // add v as positive\n    if (neg->count(v)) {\n        neg->erase(v);\n    } else {\n        pos->insert(v);\n    }\n}\n\ndata mgr(data a, data b)\n{\n    if (a.size() < b.size()) swap(a, b);\n    bool an = a.isneg(), bn = b.isneg();\n    bool neg = an == bn;\n    if (neg) {\n        a.sum = (a.sum + W - b.sum) % W;\n        for (int p : *b.neg) {\n            waf(a.pos, a.neg, p);\n        }\n        for (int p : *b.pos) {\n            waf(a.neg, a.pos, p);\n        }\n    } else {\n        a.sum = (a.sum + b.sum) % W;\n        for (int p : *b.pos) {\n            waf(a.pos, a.neg, p);\n        }\n        for (int p : *b.neg) {\n            waf(a.neg, a.pos, p);\n        }\n    }\n    return a;\n}\n\nvoid show(const data& d) {\n    printf(\"s=%d pos=\", d.sum);\n    for (int p : *d.pos) printf(\"%d,\", p);\n    printf(\" neg=\");\n    for (int p : *d.neg) printf(\"%d,\", p);\n    puts(\"\");\n}\n\nint main()\n{\n    scanf(\"%s%d\", S_, &N);\n    int M = strlen(S_);\n    for (int i = 0; i < M + 3; ++i) uf[i] = -1;\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d%d\", L + i, R + i);\n        --L[i];\n\n        join(L[i], R[i]);\n    }\n    S[0] = S[M + 2] = 0;\n    for (int i = 0; i < M; ++i) S[i + 1] = S_[i] - 'a';\n\n    for (int i = 0; i <= M; ++i) {\n        D[i] = (S[i + 1] - S[i] + W) % W;\n    }\n    M += 1;\n    for (int i = 0; i < M; ++i) {\n    //\tprintf(\"%d\\n\", D[i]);\n        grps[root(i)].push_back(i);\n    }\n    for (int i = 0; i < M; ++i) if (grps[i].size() > 0) {\n        int sum = 0;\n        set<int> *pos = new set<int>, *neg = new set<int>;\n        for (int p : grps[i]) {\n            if (p * 2 + 1 == M) {\n                sum = (sum + D[p]) % W;\n                continue;\n            }\n            if (p >= M / 2) {\n                waf(neg, pos, M - 1 - p);\n                sum = (sum + D[p]) % W;\n            }\n            else {\n                waf(pos, neg, p);\n                sum = (sum + D[p]) % W;\n            }\n        }\n    //\tshow(data(sum, pos, neg));\n        eqs.insert(data(sum, pos, neg));\n    }\n    while (!eqs.empty()) {\n        data top = *(eqs.begin());\n        eqs.erase(eqs.begin());\n\n        if (top.top() == 1000000) {\n            if (top.sum != 0) {\n                puts(\"NO\");\n                return 0;\n            }\n            continue;\n        }\n        if (eqs.empty()) break;\n\n        if (eqs.begin()->top() != top.top()) {\n            continue;\n        }\n\n        data top2 = *(eqs.begin());\n        eqs.erase(eqs.begin());\n        data nw = mgr(top, top2);\n        eqs.insert(nw);\n    }\n\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b>>1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n\nvector<vector<ll>> g;\n\nvector<ll> see;\n\nbool nibu(ll u) {\n\t\n\tbool ret = 1;\n\n\tfor (ll v : g[u]) {\n\t\tif (see[v] != -1) {\n\t\t\tif (see[v] == see[u]) { ret = 0; }\n\t\t}\n\t\telse {\n\t\t\tsee[v] = (ret + 1) % 2;\n\t\t\tret = nibu(v);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nll wa(ll u,vector<ll> &b) {\n\tll ret = b[u];\n\tsee[u] = 2;\n\n\tfor (ll v : g[u]) {\n\t\tif (see[v] == 2) { continue; }\n\t\tret += wa(v,b);\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tll T = S.size();\n\t\n\tll M = T / 2 + 1;\n\tvector<ll> a(M + 1, 0);\n\trepn(i, M - 1) {\n\t\ta[i] = (ll)S[T - i] - (ll)S[i - 1];\n\t\tif (a[i] < 0) { a[i] += 26; }\n\t}\n\n\tvector<ll> b(M + 1, 0);\n\trepn(i, M)b[i] = a[i] - a[i - 1];\n\n\t//repn(i, M)cout << b[i] << \" \";\n\t//cout << endl;\n\n\tg.resize(M + 1);\n\tll N;\n\tcin >> N;\n\n\trepn(i, N) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\n\t\tif (l + r == T + 1) { continue; }\n\n\t\tif (r <= T / 2) { r++; }\n\t\telse if (l + r < T + 1) { r = T - r + 1; }\n\t\telse if (l <= T / 2) { r = T - r + 1; swap(l, r); }\n\t\telse { l = T - l + 1 + 1; r = T - r + 1; swap(l, r); }\n\n\t\tif (l > M) { l--; }\n\t\tif (r > M) { r--; }\n\n\t\tg[l].push_back(r);\n\t\tg[r].push_back(l);\n\n\t\t//cout << l << \" \" << r << endl;\n\t}\n\n\tsee.assign(M + 1, -1);\n\n\tstring ans = \"YES\";\n\n\trepn(u, M) {\n\t\tif (see[u] != -1) { continue; }\n\n\t\tif (nibu(u)==1 && wa(u, b)%26 != 0) { ans = \"NO\"; }\n\n\t\t//cout << u << \" \" << nibu(u) << \" \" << wa(u, b) << endl;\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nset<int> to[maxn];\nint main(){\n\tstring s; cin >> s;\n\tint len = s.size();\n\tint u = (len - 1) / 2, v = len / 2;\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint l, r; cin >> l >> r; l--; r--;\n\t\tvector<pair<int,int> > ways;\n\t\t/**\n\t\t  abeba\n\t\t   3 4 -> 0 1\n\t\t   0 3 -> 0 0\n\t\t   1 4 -> 0 0 \n\t\t  **/\n\t\tif(r <= u){\n\t\t\tto[l].insert(r);\n\t\t} else if (l >= v){\n\t\t\tto[len - r - 1].insert(len - l - 1);\n\t\t}  else {\n\t\t\tint dl = u - l, dr = r - v;\n\t\t\tif(dl >= dr) to[l].insert(u - dr - 1);\n\t\t\telse to[len - r - 1].insert(len - 1 - (v + dl + 1));\n\t\t}\n\t}\n\tif(u == v) to[u].insert(u);\n\tvector<int> val(len, 0), pref(2 * len + 10, 0);\n\tfor(int i = 0; i <= u; i++){\n\t\tval[i] = s[v + u - i] - s[i] + 26;\n\t\tval[i] %= 26;\n\t}\n\tfor(int i = 0; i <= u; i++){\n\t\tif(i) pref[i] += pref[i - 1];\n\t\tval[i] += pref[i];\n\t\tval[i] %= 26;\n\t\tval[i] += 26;\n\t\tval[i] %= 26;\n\t\tint pk = -1;\n\t\t{\n\t\t\tvector<int> now;\n\t\t\tfor(int j : to[i]){\n\t\t\t\tnow.push_back(j);\n\t\t\t}\n\t\t\tint sz = now.size();\n\t\t\tfor(int i = 1; i < sz; i++){\n\t\t\t\tto[now[i - 1] + 1].insert(now[i]);\n\t\t\t}\n\t\t\tif(sz) pk = now[0];\n\t\t}\n\t\tif(val[i]){\n\t\t\tif(pk == -1) return cout << \"NO\" << endl, 0;\n\t\t\tpref[i] += 26 - val[i];\n\t\t\tpref[pk + 1] += val[i];\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring S; int Q, L[100009], R[100009], c[100009], d[100009]; bool used[100009];\nint main() {\n\tcin >> S >> Q;\n\tfor (int i = 0; i < (int)S.size() / 2; i++) {\n\t\tc[i] = (S[i] - S[S.size() - 1 - i] + 26) % 26;\n\t}\n\tint mid = S.size() / 2;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> L[i] >> R[i]; L[i]--; R[i]--; d[L[i]]++; d[R[i] + 1]--;\n\t\tint F1 = L[i], F2 = R[i] + 1;\n\t\tif (F1 >= mid)F1 = (S.size() - 0) - L[i];\n\t\tif (F2 >= mid)F2 = (S.size() - 1) - R[i];\n\t\tused[F1] = true; used[F2] = true;\n\t}\n\tfor (int i = 1; i < S.size(); i++)d[i] += d[i - 1];\n\tfor (int i = 0; i < mid; i++) {\n\t\tif (d[i] == 0 && d[S.size() - 1 - i] == 0 && c[i] != 0) { cout << \"NO\" << endl; return 0; }\n\t}\n\tif (S.size() % 2 == 1 && d[mid] == 0) { cout << \"NO\" << endl; return 0; }\n\tfor (int i = 0; i < mid - 1; i++) {\n\t\tif (c[i] != c[i + 1] && used[i + 1] == false) { cout << \"NO\" << endl; return 0; }\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n \nusing namespace std;\n \nstruct S{\n\tL s,e;\n};\n \nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n \nset<S>st;\n \nchar str[100010];\nL b[100010];\nL n,len;\n \nL tr[400040];\n \nvoid update(L now,L S,L E,L s,L e,L val){\n\twhile(e)\n\t{\n\t\ttr[e]+=val;\n\t\te^=e&-e;\n\t}\n\ts--;\n\twhile(s)\n\t{\n\t\ttr[s]-=val;\n\t\ts^=s&-s;\n\t}\n}\n \nL get(L now,L S,L E,L loc){\n\tL ret=0;\n\twhile(loc<=len)\n\t{\n\t\tret+=tr[loc];\n\t\tloc+=loc&-loc;\n\t}\n\treturn ret;\n}\n \nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n \nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\t//printf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//for(set<S>::iterator it=st.begin();it!=st.end();it++)\n\t//\tprintf(\"%lld %lld\\n\",it->s,it->e);\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\t\n\t\t\tst.erase(st.begin());\n\t\t\tset<S>sttemp;\n\t\t\tL prelast=range.e;\n\t\t\tfor(set<S>::iterator it=st.begin();it!=st.end()&&it->s==range.s;it++)\n\t\t\t{\n\t\t\t\tsttemp.insert((S){prelast+1,it->e});\n\t\t\t\tprelast=it->e;\n\t\t\t}\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()||it->s!=range.s) break;\n\t\t\t\tst.erase(it);\n\t\t\t}\n\t\t\tfor(set<S>::iterator it=sttemp.begin();it!=sttemp.end();it++)\n\t\t\t{\n\t\t\t\tst.insert(*it);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!st.empty()&&st.begin()->s==i)\n\t\t\t{\n\t\t\t\tS range=*(st.begin());\n\t\t\t\tst.erase(st.begin());\n\t\t\t\tset<S>sttemp;\n\t\t\t\tL prelast=range.e;\n\t\t\t\tfor(set<S>::iterator it=st.begin();it!=st.end()&&it->s==range.s;it++)\n\t\t\t\t{\n\t\t\t\t\tsttemp.insert((S){prelast+1,it->e});\n\t\t\t\t\tprelast=it->e;\n\t\t\t\t}\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\t\tif(it==st.end()||it->s!=range.s) break;\n\t\t\t\t\tst.erase(it);\n\t\t\t\t}\n\t\t\t\tfor(set<S>::iterator it=sttemp.begin();it!=sttemp.end();it++)\n\t\t\t\t{\n\t\t\t\t\tst.insert(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define all(v) begin(v), end(v)\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\nint a[MAXN];\n\nstd::vector<int> G[MAXN];\n\nvoid change(int L, int R, int v) {\n    //cout << L << '-'<<R<<\"\\n\";\n    (a[L] += v) %= 26;\n    (a[R + 1] -= v) %= 26;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            x = n - x + 1;\n            y = n - y + 1;\n        }\n        if (x <=mm && y >mm) {\n            y = n - y + 1;\n            x--;\n        }\n        if (x > y) std::swap(x, y);\n        G[x].push_back(y);\n    }\n    for (int i = 1; i + i <= n; ++i) {\n        if (!G[i].empty()) {\n            std::sort(all(G[i]));\n            G[i].erase(std::unique(all(G[i])), end(G[i]));\n            int k = G[i].size();\n            change(i, G[i][0], -a[i]);\n            for (int j = 1; j < k; ++j) {\n                G[G[i][j - 1] + 1].push_back(G[i][j]);\n            }\n        }\n        if (a[i] != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <tuple>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define FOR(x,xs) for(auto &x: xs)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef pair<ll,ll> PL;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\n\nstruct uf {\n  VI dat;\n  uf(int n): dat(n) {\n    REP(i,0,n) {\n      dat[i] = i;\n    }\n  }\n  int find(int x) {\n    if(dat[x] == x) {\n      return x;\n    }\n    return dat[x] = find(dat[x]);\n  }\n  void unite(int x, int y) {\n    dat[find(x)] = find(y);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  int l = s.size();\n  VI xs(l+2);\n  xs[0] = xs[l+1] = 0;\n  transform(s.begin(), s.end(), xs.begin()+1, [](char c){return c-'a';});\n  transform(xs.begin(), xs.end()-1, xs.begin()+1, xs.begin(), [](int x, int y){return (y+26-x)%26;});\n  xs.pop_back();\n  uf u(l+1);\n  int N;\n  cin >> N;\n  REP(i,0,N) {\n    int l, r;\n    cin >> l >> r;\n    u.unite(l-1, r);\n  }\n  for(int i=0, j=l; i < j; i++, j--) {\n    u.unite(i, j);\n  }\n  VI sum(l+1, 0);\n  REP(i,0,l+1) {\n    sum[u.find(i)] += xs[i];\n    sum[u.find(i)] %= 26;\n  }\n  bool ans = all_of(sum.begin(), sum.end(), [](int x){return x == 0;});\n  cout << (ans ? \"YES\" : \"NO\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100005;\nint n,m,sum[N],fa[N];\nchar s[N];\n\nint find(int x){return !fa[x]?x:fa[x]=find(fa[x]);}\nvoid unite(int x,int y){x=find(x),y=find(y);if(x!=y)fa[x]=y,sum[y]=(sum[y]+sum[x])%26;}\n\nint main(){\n\tscanf(\"%s%d\",s+1,&m),n=strlen(s+1);\n\ts[0]=s[n+1]='a';\n\tfor(int i=1;i<=n+1;++i)sum[i]=(s[i]-s[i-1]+26)%26;\n\tfor(int i=1,l,r;i<=m;++i)\n\t\tscanf(\"%d%d\",&l,&r),unite(l,r+1);\n\tfor(int i=1;i<=n/2+1;++i)unite(i,n+2-i);\n\tfor(int i=1;i<=n+1;++i)if(!fa[i]&&sum[i])return puts(\"NO\"),0;\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 999999999999989LL;\nll K = 2;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk[N];\nll ha[N];\nint len;\n\nbool check()\n{\n    degk[0] = 1;\n    for (int i = 1; i < N; i++) degk[i] = degk[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degk[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degk[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) return 0;\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) return 0;\n    return 1;\n}\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    if (check()) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nconst ll K = 2;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degh[N];\nll ha[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degh[0] = 1;\n    for (int i = 1; i < N; i++) degh[i] = degh[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degh[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degh[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tint m = s.size() / 2;\n\t\tif (l == m && r == m) continue;\n\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t\tif (l >= m) l--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tm = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << 2 / 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\nchar ch[100010];\nint S[100010];\nint N;\nvector <pii> qq;\nvector <int> V[100010];\n\nint T[1<<18]; const int ADD = 1<<17;\n\nvoid add(int l, int r, int v) {\n\tl += ADD, r += ADD;\n\twhile(l <= r) {\n\t\tif(l & 1) T[l] = (T[l] + v) % 26, ++l;\n\t\tif(!(r & 1)) T[r] = (T[r] + v) % 26, --r;\n\t\tl >>= 1, r >>= 1;\n\t}\n}\n\nint Get(int x) {\n\tx += ADD;\n\tint res = 0;\n\twhile(x) res += T[x], x >>= 1;\n\treturn res % 26;\n}\n\nvoid solve() {\n\tscanf(\"%s\", ch+1);\n\tint L = (int)strlen(ch+1);\n\tfor(int i=1;i<=L;i++) S[i] = ch[i] - 'a';\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tif(x+y == L+1) continue;\n\t\tif(x+y > L+1) {\n\t\t\tint px = L+2-x;\n\t\t\tif(x < px) x = px;\n\t\t\tif(L % 2 == 1 && x == (L+1)/2) ++x;\n\t\t\tif(x <= y) qq.pb(pii(x, y)), V[y].pb(x);\n\t\t}\n\t\telse {\n\t\t\tint py = L-y;\n\t\t\tif(y > py) y = py;\n\t\t\tif(L % 2 == 1 && y == (L+1)/2) --y;\n\t\t\tif(x <= y) qq.pb(pii(x, y)), V[x].pb(y);\n\t\t}\n\t}\n\tfor(int i=1;i<=L;i++) add(i, i, S[i]);\n\tint lv = L / 2;\n\tfor(int i=1;i<=lv;i++) {\n\t\tint vl = -1;\n\t\tif(szz(V[i]) >= 1) {\n\t\t\tsort(all(V[i]));\n\t\t\tfor(int j=1;j<szz(V[i]);j++) {\n\t\t\t\tint a = V[i][j], p = V[i][j-1];\n\t\t\t\tif(p < a) V[p+1].pb(a);\n\t\t\t}\n\t\t\tvl = V[i][0];\n\t\t}\n\t\tint ri = L + 1 - i;\n\t\tint vr = -1;\n\t\tif(szz(V[ri]) >= 1) {\n\t\t\tsort(all(V[ri]));\n\t\t\tfor(int j=szz(V[ri])-1;j;j--) {\n\t\t\t\tint a = V[ri][j-1], p = V[ri][j];\n\t\t\t\tif(a < p) V[p-1].pb(a);\n\t\t\t}\n\t\t\tvr = V[ri][0];\n\t\t}\n\t\tif(vl != -1 && vr != -1) {\n\t\t\tint l_len = vl - i + 1;\n\t\t\tint r_len = ri - vr + 1;\n\t\t\tif(l_len > r_len) {\n\t\t\t\tV[i + r_len].pb(vl);\n\t\t\t\tvl = -1;\n\t\t\t}\n\t\t\telse if(l_len < r_len) {\n\t\t\t\tV[ri - l_len].pb(vr);\n\t\t\t\tvr = -1;\n\t\t\t}\n\t\t\telse vr = -1;\n\t\t}\n\t\tif(i == 3) {\n\t\t\t++i; --i;\n\t\t}\n\t\tif(vl == -1 && vr == -1) {\n\t\t\tif(Get(i) != Get(ri)) {\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if(vl == -1) {\n\t\t\tint val = (Get(i) - Get(ri) + 26) % 26;\n\t\t\tadd(vr, ri, val);\n\t\t}\n\t\telse if(vr == -1) {\n\t\t\tint val = (Get(ri) - Get(i) + 26) % 26;\n\t\t\tadd(i, vl, val);\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n\nint main(){\n\tint Tc = 1; // scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  for(int i = 0; i < st.size(); i++) {\n\n    map< int, int > mp;\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(mp.count(ind[other])) {\n          if((S[other] - S[idx] + 26) % 26 != mp[ind[other]]) {\n            throw (0);\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        } else {\n          mp[ind[other]] = (S[other] - S[idx] + 26) % 26;\n        }\n      }\n    }\n\n  }\n\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<pair<int,int> > v;\nset<pair<string,int> >s;\nset<pair<string,int> >:: iterator it;\n\nint bykchange,dapet=0;\n\nint palin(char soal[50]){\n    int len;\n    len=strlen(soal);\n    char revsoal[50];\n    strcpy(revsoal,soal);\n    reverse(revsoal,revsoal+len);\n//    printf(\"%s %s\\n\",soal,revsoal);\n    if(strcmp(soal,revsoal)==0)return 1;\n    return 0;\n}\n\nint backtrack(char soal[50]){\n        for(int i=0;i<bykchange;i++){\n            int start,fin;\n            start=v[i].first;\n            fin=v[i].second;\n            for(int j=start-1;j<=fin-1;j++){\n                if(soal[j]=='z')soal[j]='a';\n                else soal[j]++;\n            }\n            int cek;\n            it=s.find(pair<string,int>(soal,i));\n            if(it!=s.end())return 0;\n            else s.insert(pair<string,int>(soal,i));\n            cek=palin(soal);\n            if(cek==1){\n                dapet++;\n                return 1;\n            }\n\n            if(backtrack(soal)==1){\n                dapet++;\n                return 1;\n            }\n\n            if(dapet==1)return 1;\n            for(int j=start-1;j<=fin-1;j++){\n                if(soal[j]=='a')soal[j]='z';\n                else soal[j]--;\n            }\n//            printf(\"\\n\\n\\n\");\n        }\n        return 0;\n}\n\n\nint main(){\n    char soal[100100];\n    scanf(\"%s\",soal);\n    scanf(\"%d\",&bykchange);\n    for(int i=0;i<bykchange;i++){\n        int t1,t2;\n        scanf(\"%d %d\",&t1,&t2);\n        v.push_back(make_pair(t1,t2));\n    }\n    if(palin(soal)==1)printf(\"YES\\n\");\n    else{\n        if(backtrack(soal)==1)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nconst ll K1 = 2;\nconst ll K2 = 3;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk1[N], degk2[N];\nll ha1[N], ha2[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degk1[0] = 1;\n    degk2[0] = 0;\n    for (int i = 1; i < N; i++) degk1[i] = degk1[i - 1] * K1 % MOD;\n    for (int i = 1; i < N; i++) degk2[i] = degk2[i - 1] * K2 % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha1[l[i]] = (ha1[l[i]] + degk1[i]) % MOD;\n            ha1[r[i] + 1] = (ha1[r[i] + 1] + MOD - degk1[i]) % MOD;\n            ha2[l[i]] = (ha2[l[i]] + degk2[i]) % MOD;\n            ha2[r[i] + 1] = (ha2[r[i] + 1] + MOD - degk2[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha1[i] = (ha1[i - 1] + ha1[i]) % MOD;\n        ha2[i] = (ha2[i - 1] + ha2[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<pair<ll, ll>, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[{ha1[i], ha2[i]}].insert(x[i]);\n        if (val[{ha1[i], ha2[i]}].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[{0, 0}].size() && *(val[{0, 0}].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing pii = pair<int, int>;\n \ntemplate <typename T> T inf;\ntemplate <> int inf<int> = 1e9;\ntemplate <> ll inf<ll> = 1e18;\n \nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nint main() {\n    string S;\n    int N;\n    cin >> S >> N;\n    int const M = S.size();\n    vector<int> b(M);\n    b[0] = (S[0] - 'a');\n    for(int i = 0; i + 1 < S.size(); ++i) {\n        b[i + 1] = (S[i + 1] - S[i] + 26) % 26;\n    }\n    b.push_back((-(S.back() - 'a') + 26) % 26);\n    //for(int i = 0; i <= M; ++i) {\n    //    cout << b[i] << endl;\n    //}\n\n    union_find uf(M + 1);\n    for(int i = 0; i < N; ++i) {\n        int l, r;\n        cin >> l >> r;\n        l--;\n        uf.unite(l, r);\n    }\n    for(int i = 0; i <= M; ++i) {\n        uf.unite(i, M - i);\n    }\n\n    vector<int> sum(M + 1);\n    for(int i = 0; i <= M; ++i) {\n        (sum[uf.root(i)] += b[i]) %= 26;\n    }\n\n    bool ok = true;\n    for(int i = 0; i < M; ++i) {\n        //cout << \"sum[i]: \" << sum[i] << endl;\n        ok &= sum[i] == 0;\n    }\n    if(ok) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN], sum[MAXN];\nbool mark[MAXN];\nstring S, T;\nvector<int> G[MAXN];\n\nint dfs(int node){\n\tmark[node]=1;\n\tfor (int v:G[node]) if (!mark[v]) sum[node]+=dfs(v);\n\treturn sum[node];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>S>>m;\n\tint len=S.size();\n\tn=len/2;\n\tfor (int i=0; i<n; i++) T+=S.back(), S.pop_back();\n\tif (len&1) S.pop_back();\n\t\n\tfor (int i=1; i<=n; i++) A[i]=S[n-i]-T[n-i];\n\tfor (int i=1; i<=n+1; i++) sum[i]=A[i]-A[i-1];\n\twhile (m--){\n\t\tcin>>x>>y;\n\t\tif (len%2){\n\t\t\tif (x==n+1 && y==n+1) continue ;\n\t\t\tif (x==n+1) x++;\n\t\t\tif (y==n+1) y--;\n\t\t\tif (x>n) x--;\n\t\t\tif (y>n) y--;\n\t\t}\n\t\tif (x<=n && y<=n) x=n-x+1, y=n-y+1, swap(x, y);\n\t\telse if (x>n && y>n) x-=n, y-=n;\n\t\telse{\n\t\t\tx=n-x+1;\n\t\t\ty-=n;\n\t\t\tif (x>y) swap(x, y);\n\t\t\tx++;\n\t\t}\n\t\tG[x].pb(y+1);\n\t\tG[y].pb(x+1);\n\t}\n\tfor (int i=1; i<=n+1; i++) if (!mark[i] && dfs(i)%26) kill(\"NO\")\n\tkill(\"YES\")\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\nconstexpr int mod = 26;\n\nclass UnionFind{\nprivate:\n    vec<int> p,s;\n    int cnt;\npublic:\n    vec<int> v;\n    UnionFind(){}\n    UnionFind(int N):cnt(N),s(N,1),p(N),v(N){\n        iota(p.begin(),p.end(),0);\n    }\n    int find(int x){\n        if(p[x]==x) return x;\n        else return p[x] = find(p[x]);\n    }\n    void unite(int x,int y){\n        x = find(x); y = find(y);\n        if(x==y) return;\n        if(s[x]>s[y]) swap(x,y);\n        p[x] = y;\n        s[y] += s[x];\n        (v[y] += v[x])%=mod;\n        cnt--;\n    }\n    bool is_same_set(int x,int y) {return find(x)==find(y);}\n    int size(int x) {return s[find(x)];}\n    int compnents_number(){return cnt;}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    int N = S.size();\n    vec<int> A(N+2,0);\n    for(int i=0;i<N;i++) A[i+1] = S[i]-'a';\n    vec<int> D(N+1);\n    UnionFind uf(N+1);\n    for(int i=0;i<=N;i++){\n        D[i] = (A[i+1]-A[i]+mod)%mod;\n        (uf.v[min(i,N-i)] += D[i])%=mod;\n    }\n//    for(int i=0;i<=N/2;i++) cerr << uf.v[i] << \"\\n\";\n    int M;\n    cin >> M;\n    for(int i=0;i<M;i++){\n        int l,r;\n        cin >> l >> r;\n        l--; r--;\n        uf.unite(min(l,N-l),min(r+1,N-r-1));\n    }\n    bool ok = true;\n    for(int i=0;i<=N;i++) ok &= !uf.v[uf.find(i)];\n    cout << (ok? \"YES\\n\":\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll dsu[SZ], sm[SZ];\n\nll par(int v) {\n\tif (dsu[v] == v) return v;\n\telse return dsu[v] = par(dsu[v]);\n}\n\nvoid uni(int v, int u) {\n\tu = par(u);\n\tv = par(v);\n\tif (u != v) {\n\t\tdsu[u] = v;\n\t\tsm[v] += sm[u];\n\t\tsm[v] %= 26;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tvector<ll> vec;\n\ts.insert(s.begin(), 'a');\n\ts.push_back('a');\n\tfor (int i = 1; i < s.size(); i++) {\n\t\tvec.push_back((s[i] - s[i - 1] + 26) % 26);\n\t}\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tdsu[i] = i;\n\t\tsm[i] = vec[i];\n\t\tuni(i, vec.size() - i - 1);\n\t}\n\n\tll q;\n\tcin >> q;\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tuni(l - 1, r);\n\t}\n\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tll k = par(i);\n\t\tif (sm[k] != 0) {\n\t\t\tcout << \"NO\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (y != f[y]) {\n    f[x] = find(y);\n  }\n    d[x] = (d[y] + d[x]) % 26;\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return d[x] == (diff + d[y]) % 26;\n  f[ry] = rx;\n  d[ry] = (d[x] - d[y] - diff) % 26;\n  if (d[ry] < 0) d[ry] += 26;\n  return true;\n}\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[n - 1 - i] - s[i] + 26) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int u = label[i];\n    find(u);\n    trace(i, u, d[u], (s[i] - 'a' + d[u]) % 26);\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk[N];\nll ha[N];\nint len;\n\nbool check(ll K)\n{\n    for (int i = 0; i < N / 2; i++) ha[i] = 0;\n    degk[0] = 1;\n    for (int i = 1; i < N; i++) degk[i] = degk[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degk[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degk[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    //for (int i = 0; i < len; i++) cout << x[i] << \" \"; cout << \"\\n\";\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) return 0;\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) return 0;\n    return 1;\n}\n\nint main()\n{\n    cin >> s;\n    cout << \"YES\";\n    return 0;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    if (check(2)) cout << \"YES\\n\", exit(0);\n    if (check(3)) cout << \"YES\\n\", exit(0);\n    if (check(5)) cout << \"YES\\n\", exit(0);\n    else cout << \"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else\n        {\n            l = min(abs(l - mid1), abs(l - mid2));\n            r = min(abs(r - mid1), abs(r - mid2));\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n            int minr = *segs[i].begin();\n            segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,m,a[N],sum;\nvector<int> g[N];\nbool vis[N];\nchar s[N];\n\nvoid add(int x,int y){\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tsum+=a[u];\n\tfor (int v:g[u]){\n\t\tif (!vis[v]) dfs(v);\n\t}\n}\n\nint main(){\n\tscanf(\"%s\",s+1); m=strlen(s+1);\n\tfor (int i=1;i<=m/2;++i) a[i]=s[i]-s[m-i+1];\n\ta[m/2+1]-=a[m/2];\n\tfor (int i=m/2;i;--i) a[i]-=a[i-1];\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tif (x<=m/2&&y>=m-m/2+1){\n\t\t\tint l1=m/2-x,l2=y-(m-m/2+1);\n\t\t\tif (l1>l2){\n\t\t\t\tx=m/2-l1; y=m/2-l2-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=m/2-l2; y=m/2-l1-1;\n\t\t\t}\n\t\t}\n\t\tif (x>m/2){\n\t\t\tx=m-x+1; y=m-y+1;\n\t\t\tswap(x,y);\n\t\t}\n\t\tif (y>m/2) y=m/2;\n\t\tif (x<=y) add(x,y+1);\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tsum=0;\n\t\tif (!vis[i]) dfs(i);\n\t\tif (sum){puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define pb push_back\n# define fr first\n# define sc second\n# define mk make_pair\n\nusing namespace std;\n\nconst int inf = 1e9 + 7;\nconst int N = 1e6 + 5;\n\ntypedef long long ll;\n\nstring s;\nint n, l[N], r[N], a[N], b[N], mid, sz;\nint aa[N], ab[N];\n\nint main()\n{\n      cin >> s;\n\n      sz = s.size();\n      s = ' ' + s;\n\n      cin >> n;\n\n      for(int i = 1; i <= n; i ++)\n      {\n            cin >> l[i] >> r[i];\n            if(l[i] > ((sz + 1) / 2)) continue;\n            if(r[i] <= ((sz + 1) / 2)) continue;\n            if(l[i] == (sz - r[i] + 1))\n            {\n                  l[i] = r[i] = 0;\n                  continue;\n            }\n            if(l[i] > (sz - r[i] + 1))\n                  l[i] = sz - (l[i] - 1) + 1;\n            else\n                  r[i] = (sz - r[i] + 1) - 1;\n      }\n\n      for(int i = 1; i <= n; i ++)\n      {\n            if(r[i] <= (sz + 1) / 2)\n                  a[i] = 1;\n            else\n            {\n                  a[i] = -1;\n                  int dd = r[i];\n                  r[i] = sz - l[i] + 1;\n                  l[i] = sz - dd + 1;\n            }\n      }\n\n      for(int i = 1; i <= sz / 2; i ++)\n            b[i] =s[i] - s[sz - i + 1];\n\n      for(int i = 1; i <= n; i ++)\n      {\n            if(a[i] == 1)\n                  aa[l[i]] ++, aa[r[i] + 1] --;\n            else\n                  ab[l[i]] ++, ab[r[i] + 1] --;\n      }\n\n      for(int i = 1; i <= sz / 2; i ++)\n            aa[i] += aa[i - 1], ab[i] += ab[i - 1];\n\n      for(int i = 1; i <= sz / 2; i ++)\n      {\n            if(!aa[i] && !ab[i] && b[i] || (aa[i] && !ab[i] && b[i] > 0) || (!aa[i] && ab[i] && b[i] < 0))\n            {\n                  cout << \"NO\" << endl;\n                  return 0;\n            }\n      }\n\n\n\n      cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 100100;\nstring z;\nint m;\nint f[MAX],il[MAX];\nconst int alfa = 'z' - 'a' + 1;\nvoid pol(int& a){\n  a = min(a, SZ(z) - a);\n}\nint find(int a){\n  return f[a] == a ? a : f[a] = find(f[a]);\n}\nvoid uni(int a,int b){\n  a = find(a);\n  b = find(b);\n  if(a == b)return;\n  f[a] = b;\n  il[b] += il[a];\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> z;\n  R(i,(SZ(z) + 1)/2){\n    f[i] = i;\n    if(i){\n      il[i] = (z[i] - z[i-1]) - (z[SZ(z) - i - 2] - z[SZ(z) - i - 1]);\n    }\n    debug(i,il[i]);\n  }\n  cin >> m;\n  R(i,m){\n    int l,r;\n    cin >> l >> r;\n    l--;\n    pol(l);\n    pol(r);\n    debug(l,r);\n    uni(r,l);\n  }\n  R(i,(SZ(z) + 1)/2){\n    if(f[i] == i){\n      if(il[i] % alfa != 0 && find(0) != i){\n        cout << \"NO\\n\";\n        return 0;\n      }\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  static char s[100010];\n  scanf(\"%s\",s);\n  int n=strlen(s),N;\n  scanf(\"%d\",&N);\n  vector<int> L(N),R(N);\n  for(int i=0;i<N;i++){\n    scanf(\"%d%d\",&(L[i]),&(R[i]));\n  }\n  static int P[100010];\n  for(int i=0;i<n/2;i++){\n    P[i]=(s[i]+26-s[n-i-1])%26;\n    //printf(\"%d %d\\n\",i,P[i]);\n  }\n  vector<vector<int> > e(n/2+1);\n  for(int i=0;i<N;i++){\n    L[i]--;\n    if(L[i]>n/2)L[i]=n-L[i];\n    if(R[i]>n/2)R[i]=n-R[i];\n    e[L[i]].push_back(R[i]);\n    e[R[i]].push_back(L[i]);\n    //printf(\"%d %d\\n\",L[i],R[i]);\n  }\n  bool F=0;\n  for(int i=0;i<=n/2;i++){\n    if(2*i+1!=n&&(i<n/2?P[i]:0)!=(i>0?P[i-1]:0)&&e[i].size()==0){\n      F=1;\n      break;\n    }\n  }\n  vector<int> V(n/2+1,0);\n  for(int i=0;i<=n/2;i++){\n    if(V[i])continue;\n    V[i]=1;\n    int T=0;\n    queue<int> Q;\n    Q.push(i);\n    V[i]=1;\n    bool FF=0;\n    while(!Q.empty()){\n      int j=Q.front();\n      Q.pop();\n      T+=(j<n/2?P[j]:0)+26-(j>0?P[j-1]:0);\n      if(2*i+1==n)FF=1;\n      for(int x=0;x<e[j].size();x++){\n\tint k=e[j][x];\n\tif(!V[k]){\n\t  V[k]=1;\n\t  Q.push(k);\n\t}\n      }\n    }\n    //printf(\"%d %d\\n\",i,T);\n    if(!FF&&T%26!=0){\n      F=1;\n      break;\n    }\n  }\n  puts(F?\"NO\":\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n//     if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n//         cout << mid1 << ' ' << mid2 << ' ' << l << ' ' << r << endl;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            tie(l, r) = make_pair(min(max(-1, mid1 - l), max(-1, r - mid2)) + 1, max(max(-1, mid1 - l), max(-1, r - mid2)));\n//             l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n//             r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[mid1 - i] - s[mid2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= minr) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            deladd[minr + 1] %= 26;\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define D(a) cerr << #a << \" = \" << a << endl\n#else\n\t#define D(a)\n\t#define cerr false && cerr\n#endif\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0)\n#define dforsn(i,s,n) for(int i=int(n-1);i>=int(s);i--)\n#define forsn(i,s,n) for(int i=int(s);i<int(n);i++)\n#define forn(i,n) forsn(i,0,n)\n#define all(a) a.begin(),a.end()\n#define si(a) int((a).size())\n#define pb emplace_back\n#define mp make_pair\n#define snd second\n#define fst first\nusing pii = pair<int,int>;\nusing vi = vector<int>;\nusing ll = long long;\n\nvi node;\nvector<vi> g;\nvector<bool> v;\n\nint sum(int n){\n    v[n] = true;\n    int s = node[n];\n    for(int i : g[n]) if(!v[i]) s += sum(i);\n    return s;\n}\n\nint main() {\n\tfastio;\n\t\n    string s; cin >> s;\n    int n = si(s), sd = n+1, sn = (sd+1)/2;\n    vi d(sd);\n    s = 'a'+s+'a';\n    node = vi(sn), g.resize(sn), v.resize(sn);\n\n    forn(i,sd) d[i] = (26+s[i]-s[i+1]) % 26;\n    forn(i,sd/2) node[i] = (52-d[i]-d[sd-i-1]) % 26; \n    if(sd & 1) node[sd/2] = (26-d[sd/2]) % 26;\n\n    int m; cin >> m;\n    forn(i,m){\n        int x,y; cin >> x >> y; x--;\n        if(x >= sd/2) x = sd-x-1;\n        if(y >= sd/2) y = sd-y-1;\n        g[x].pb(y), g[y].pb(x);\n    }\n    bool ok = true;\n    forn(i,sn) if(!v[i] && sum(i) % 26 != 0) ok = false;\n    cout << (ok ? \"YES\" : \"NO\") << endl;  \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 100005;\nchar s[N];\nint d[N];\n\n\nint main(){\n\tscanf(\"%s\", s + 1);\n\tint q; sd(q);\n\tint n= strlen(s + 1);\n\tint mid = n / 2;\n\tfor(int i = 1; i <= mid; i++) d[i] = (s[i] - s[n + 1 - i] + 26) % 26;\n\tvector<vector<int>> events(n + 1);\n\tfor(int i = 1; i <= q; i++){\n\t\tint l, r; sd(l); sd(r);\n\t\tif(n % 2 == 1 && l == mid + 1 && r == mid + 1) continue;\n\t\tif(n % 2 == 1 && l == mid + 1 &&r != mid + 1){\n\t\t\tevents[n + 1 - r].push_back(1);\n\t\t\tevents[mid + 1].push_back(-1);\n\t\t\tcontinue;\n\t\t}\n\t\tif(n % 2 == 1 && r == mid + 1 && l != mid + 1){\n\t\t\tevents[l].push_back(1);\n\t\t\tevents[mid + 1].push_back(-1);\n\t\t\tcontinue;\n\t\t}\n\t\tint a = l > mid, b = r > mid;\n\t\tint vl = a ? n + 1 - l : l;\n\t\tint vr = b ? n + 1 - r : r;\n\n\t\tif(!a && !b){\n\t\t\tevents[vl].push_back(1);\n\t\t\tevents[vr + 1].push_back(-1);\n\t\t}\n\n\t\tif(!a && b){\n\t\t\t// [vl ... mid] U [vr ... mid]\n\t\t\tif(vl > vr) swap(vl, vr);\n\t\t\tif(vl == vr) continue;\n\t\t\tevents[vl].push_back(1);\n\t\t\tevents[vr].push_back(-1);\n\t\t}\n\t\tif(a){\n\t\t\tevents[vr].push_back(1);\n\t\t\tevents[vl + 1].push_back(-1);\n\t\t}\n\t}\n\tint curr = 0, lst = 0;\n\t// for(int i = 1; i <= mid + 1; i++){\n\t// \tif(!events[i].empty()){\n\t// \t\tif(lst + 1 != i){\n\t// \t\tset<int> st;\n\t// \t\tfor(int j = lst + 1; j < i; j++) st.insert(d[j]);\n\t// \t\tif(st.size() > 1 || (curr == 0 && *st.begin() != 0)){\n\t// \t\t\tprintf(\"NO\\n\");\n\t// \t\t\treturn 0;\n\t// \t\t}}\n\t// \t\tlst = i - 1;\n\t// \t}\n\t// \tfor(auto it : events[i]) curr += it;\t\n\t// }\n\t// for(int j = lst + 1; j <= mid; j++) if(d[j] != 0){\n\t// \tprintf(\"NO\\n\");\n\t// \treturn 0;\n\t// }\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N], x[N], root[N], summ[N], sz[N];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i <= len; i++)\n    //{\n    //    cout << x[i] << \" \";\n    //}\n    //cout << endl;\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    iota(root, root + len + 2, 0);\n    fill(sz, sz + len + 2, 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    for (int i = 1; i < len + 2; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i < len + 2; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    if (t == -1) cout << \"YES\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=100010;\nchar s[N];\nint fa[N],v[N],c[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main() {\n    int n,m,p;\n    scanf(\"%s%d\",s+1,&m);\n    n=strlen(s+1),p=n/2+1;\n    for(int i=1;i<p;i++) fa[i]=i,s[i]-=s[n-i+1],c[i]=s[i]-s[i-1];\n    fa[p]=p,c[p]=-s[p-1];\n    while(m--) {\n\tint l=gi(),r=gi(),t=1;\n\tif(n&1) {\n\t    if(l==p&&r==p) continue;\n\t    if(l==p) ++l;\n\t    if(r==p) --r;\n\t}\n\tif(l<p&&r>=p) r=n-r+1,t=0;\n\telse if(l>p) l=n-l+1,r=n-r+1;\n\tif(l>r) swap(l,r);\n\tfa[find(l)]=find(r+t);\n    }\n    for(int i=1;i<=p;i++) v[find(i)]+=c[i];\n    for(int i=1;i<=p;i++)\n\tif(i==find(i)&&v[i]%26) return puts(\"NO\"),0;\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      (ws[x] += ws[p[x]]) %= 26;\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    w += 26;\n    w %= 26;\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    w += 26;\n    w %= 26;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return (weight(y) - weight(x) + 26) % 26;\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(idx > other) continue;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          int diff2 = (S[other] - S[idx] + 26) % 26;\n          if(diff != diff2) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]==kk);\n\t\t\telse if(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2==1){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i+1] = a[i+1]-a[i];\n\tt[0] = a[0];\n\t//rep(i, n2) cerr<<a[i]<<\" \"; cerr<<endl;\n\t//rep(i, n2+1) cerr<<t[i]<<\" \"; cerr<<endl;\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t\t//cerr<<l[i]<<\" \"<<r[i]<<endl;\n\t}\n\tbool f = true;\n\tvector<vector<int> > v(n2+1);\n\trep(i, n2+1) v[uf.find(i)].push_back(i);\n\trep(i, n2+1){\n\t\tif(v[i].empty()) continue;\n\t\tll x = 0;\n\t\tbool g = false;\n\t\trep(j, v[i].size()){\n\t\t\tx += t[v[i][j]];\n\t\t\t//if(v[i][j]==n2) g = true;\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define pb push_back\n# define fr first\n# define sc second\n# define mk make_pair\n\nusing namespace std;\n\nconst int inf = 1e9 + 7;\nconst int N = 1e6 + 5;\n\ntypedef long long ll;\n\nstring s;\nint n, l[N], r[N], a[N], b[N], mid, sz;\nint pref[N];\n\nint main()\n{\n      cin >> s;\n\n      sz = s.size();\n      s = ' ' + s;\n\n      cin >> n;\n\n      for(int i = 1; i <= n; i ++)\n      {\n            cin >> l[i] >> r[i];\n            if(l[i] > ((sz + 1) / 2)) continue;\n            if(r[i] <= ((sz + 1) / 2)) continue;\n            if(l[i] == (sz - r[i] + 1))\n            {\n                  l[i] = r[i] = 0;\n                  continue;\n            }\n            if(l[i] > (sz - r[i] + 1))\n                  l[i] = sz - (l[i] - 1) + 1;\n            else\n                  r[i] = (sz - r[i] + 1) - 1;\n      }\n\n      for(int i = 1; i <= n; i ++)\n      {\n            if(r[i] <= (sz + 1) / 2)\n                  a[i] = 1;\n            else\n            {\n                  a[i] = -1;\n                  int dd = r[i];\n                  r[i] = sz - l[i] + 1;\n                  l[i] = sz - dd + 1;\n            }\n      }\n\n      for(int i = 1; i <= sz / 2; i ++)\n            b[i] =s[i] - s[sz - i + 1];\n\n      for(int i = 1; i <= n; i ++)\n      {\n            pref[l[i]] ++;\n            pref[r[i] + 1] --;\n      }\n\n      for(int i = 1; i <= sz / 2; i ++)\n            pref[i] += pref[i - 1];\n\n      for(int i = 1; i <= sz / 2; i ++)\n      {\n            if(b[i] && !pref[i])\n            {\n                  cout << \"NO\" << endl;\n                  return 0;\n            }\n      }\n\n      cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return weight(y) - weight(x);\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n\n          if((diff % 26 + 26) % 26 != (S[other] - S[idx] + 26) % 26) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  throw (0);\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\tini[nuevo.first].insert(nuevo.second);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = ini[i].size();\n\t\tauto it = ini[i].begin();\n\t\tif(sz == 1){\n\t\t\tfin[*it].insert(i);\n\t\t}else if(sz > 1){\n\t\t\tLong ant = i;\n\t\t\twhile(it != ini[i].end()){\n\t\t\t\tif(ant != i){\n\t\t\t\t\tini[ant].insert(*it);\n\t\t\t\t}\n\t\t\t\tfin[*it].insert(ant);\n\t\t\t\tant = *it + 1;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<Long,Long> > rangos;\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = fin[i].size();\n\t\tauto it = fin[i].begin();\n\t\tif(sz == 1){\n\t\t\trangos.push_back({*it,i});\n\t\t}else if(sz > 1){\n\t\t\tLong ant = *it;\n\t\t\twhile(it != fin[i].end()){\n\t\t\t\tit++;\n\t\t\t\tif(it == fin[i].end()){\n\t\t\t\t\trangos.push_back({ant,i});\n\t\t\t\t}else{\n\t\t\t\t\trangos.push_back({ant,*it-1});\n\t\t\t\t\tant = *it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(rangos.begin(),rangos.end());\n\t\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(mid1 - l, r - mid2) + 1;\n            r = max(mid1 - l, r - mid2);\n        } else\n        {\n            l = min(abs(l - mid1), abs(l - mid2));\n            r = min(abs(r - mid1), abs(r - mid2));\n        }\n        if (l > r) swap(l, r);\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n            int minr = *segs[i].begin();\n            segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 100100;\n\nint N;\nint n, qn;\nchar s[maxn + 5];\n\nint dif[maxn + 5];\n\nint fa[maxn + 5];\n\nint get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }\n\nint sum[maxn + 5];\n\nint where[maxn + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tstatic char tmp[maxn + 5];\n\tscanf(\"%s\", tmp);\n\tn = strlen(tmp);\n\tint cur = 0;\n\ts[cur++] = '#';\n\tREP(i, 0, n)\n\t{\n\t\tif ((i << 1) == n) s[cur++] = '#';\n\t\twhere[i] = cur;\n\t\ts[cur++] = tmp[i];\n\t}\n\ts[cur++] = '#';\n\tn = cur;\n\tint mid = n >> 1;\n\tN = mid;\n\tREP(i, 0, N)\n\t{\n\t\tdif[i] = (s[n - (N - i) - 1] - s[n - (N - i)]) - (s[N - i] - s[N - i - 1]);\n\t}\n\tREP(i, 0, N) fa[i] = i;\n\tscanf(\"%d\", &qn);\n\tREP(i, 0, qn)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y), --x, --y;\n\t\tx = where[x];\n\t\ty = where[y];\n\t\tif (y < mid)\n\t\t{\n\t\t\tx = mid - x;\n\t\t\ty = mid - y - 1;\n\t\t}\n\t\telse if (x > mid)\n\t\t{\n\t\t\tx = x - mid - 1;\n\t\t\ty = y - mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx = mid - x;\n\t\t\ty = y - mid;\n\t\t}\n\t\tfa[get(x)] = get(y);\n\t}\n\tREP(i, 0, N) sum[get(i)] += dif[i];\n\tREP(i, 0, N) if (fa[i] == i && sum[i])\n\t{\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct BinaryIndexedTree{\n\tint n;\n\tvector<int>dat;\n\tBinaryIndexedTree(int n=0):n(n){\n\t\tdat.resize(n+1);\n\t}\n\tvoid add(int k,int x){\n\t\tfor(k++;k<=n;k+=k&-k)dat[k]+=x;\n\t}\n\tint sum(int k){\n\t\tint ret=0;\n\t\tfor(k++;k;k-=k&-k)ret+=dat[k];\n\t\treturn ret;\n\t}\n};\n\nstring S;\nint N;\nint L[111111],R[111111];\n\nint A[111111];\n\nset<int>st[111111];\n\nsigned main(){\n    cin>>S;\n    cin>>N;\n    rep(i,N)cin>>L[i]>>R[i];\n\n    int l=S.size()/2;\n    rep(i,l){\n        A[i]=(S[S.size()-1-i]-S[i]+26)%26;\n    }\n    rep(i,N){\n        L[i]--;\n        if(L[i]>S.size()-R[i]){\n            L[i]=S.size()-L[i];\n            R[i]=S.size()-R[i];\n            swap(L[i],R[i]);\n        }\n\n        if(R[i]>=(S.size())/2){\n            if(S.size()&1){\n                int d=R[i]-l;\n                R[i]-=d*2-1;\n            }\n            else{\n                int d=R[i]-l;\n                R[i]-=d*2;\n            }\n        }\n    }\n\n    rep(i,N)st[L[i]].insert(R[i]);\n\n    BinaryIndexedTree bit(111111);\n    rep(i,l){\n        int x=A[i]+bit.sum(i);\n        x%=26;\n        while(st[i].size()&&*st[i].begin()<=i)st[i].erase(st[i].begin());\n\n        if(x!=0&&st[i].size()==0){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n\n        if(st[i].size()==0)continue;\n        int r=*st[i].begin();\n        bit.add(i,26-x);\n        bit.add(r,x-26);\n\n        if(st[i].size()>st[r].size())swap(st[i],st[r]);\n        for(auto &w:st[i])st[r].insert(w);\n    }\n\n    cout<<\"YES\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tstring S;\n\tint N;\n\tcin >> S >> N;\n\tint L =S.length();\n\tvector<int> D(L+1,0);\n\tfor(int i =0; i <= L; i++) {\n\t\tchar nxt =(i == L)?'a':S[i], prev =(i == 0)?'a':S[i-1];\n\t\tif(i < L-i) D[i] =((int)nxt-(int)prev+2600)%26;\n\t\telse D[i] =((int)prev-(int)nxt+2600)%26;\n\t}\n\n\tvector< vector<int> > G1(L+1); // +- edges\n\tvector< pair<int,int> > E; // ++ edges\n\n\tfor(int i =0; i < N; i++) {\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tint sgn_l =1, sgn_r =-1;\n\t\tif(l >= (L+1)/2) sgn_l *=-1;\n\t\tif(r >= (L+1)/2) sgn_r *=-1;\n\t\tif(sgn_l != sgn_r) {\n\t\t\tG1[l].push_back(r);\n\t\t\tG1[r].push_back(l);\n\t\t}\n\t\telse E.push_back(make_pair(l,r));\n\t}\n\tfor(int i =0; i < L; i++)\n\t\tif(i <= L-i) E.push_back(make_pair(i,L-i));\n\n\tvector<int> comp(L+1,-1),comp_sum(L+1,0);\n\tqueue<int> q;\n\tfor(int i =0; i <= L; i++) if(comp[i] == -1) {\n\t\tq.push(i);\n\t\tcomp[i] =i;\n\t\twhile(!q.empty()) {\n\t\t\tcomp_sum[i] +=D[q.front()];\n\t\t\tALL_THE(G1[q.front()],it) if(comp[*it] == -1) {\n\t\t\t\tcomp[*it] =i;\n\t\t\t\tq.push(*it);\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcomp_sum[i] %=26;\n\t}\n\n\tvector< vector<int> > G2(L+1);\n\tALL_THE(E,it) {\n\t\tG2[comp[it->ff]].push_back(comp[it->ss]);\n\t\tG2[comp[it->ss]].push_back(comp[it->ff]);\n\t}\n\n\tvector<int> comp2(L+1,-1), comp2_sum(2*(L+1),0), part(L+1);\n\tfor(int i =0; i <= L; i++) if(comp2[i] == -1 && comp[i] == i) {\n\t\tq.push(i);\n\t\tcomp2[i] =i;\n\t\tpart[i] =0;\n\t\tbool is_bip =true;\n\t\tvector<int> v;\n\t\twhile(!q.empty()) {\n\t\t\tv.push_back(q.front());\n\t\t\tcomp2_sum[2*i+part[q.front()]] +=comp_sum[q.front()];\n\t\t\tALL_THE(G2[q.front()],it) if(comp2[*it] != -1)\n\t\t\t\tif(part[q.front()] == part[*it]) is_bip =false;\n\t\t\tALL_THE(G2[q.front()],it) if(*it == q.front()) is_bip =false;\n\t\t\tALL_THE(G2[q.front()],it) if(comp2[*it] == -1) {\n\t\t\t\tcomp2[*it] =i;\n\t\t\t\tpart[*it] =1-part[q.front()];\n\t\t\t\tq.push(*it);\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tif(!is_bip) {\n\t\t\tif((comp2_sum[2*i]+comp2_sum[2*i+1])%2 != 0) {\n\t\t\t\tcout << \"NO\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif((comp2_sum[2*i]-comp2_sum[2*i+1])%26 != 0) {\n\t\t\t\tcout << \"NO\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"YES\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring S; int Q, L[100009], R[100009], c[100009], d[100009]; bool used[100009];\nint main() {\n\tcin >> S >> Q;\n\tfor (int i = 0; i < (int)S.size() / 2; i++) {\n\t\tc[i] = (S[i] - S[S.size() - 1 - i] + 26) % 26;\n\t}\n\tint mid = S.size() / 2;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> L[i] >> R[i]; L[i]--; R[i]--; d[L[i]]++; d[R[i] + 1]--;\n\t\tint F1 = L[i], F2 = R[i] + 1;\n\t\tif (F1 >= mid)F1 = (S.size() - 0) - L[i];\n\t\tif (F2 >= mid)F2 = (S.size() - 1) - R[i];\n\t\tif (F1 == F2)continue;\n\t\tused[F1] = true; used[F2] = true;\n\t}\n\tfor (int i = 1; i < S.size(); i++)d[i] += d[i - 1];\n\tfor (int i = 0; i < mid; i++) {\n\t\tif (c[i] != 0 && used[i] == false) { cout << \"NO\" << endl; return 0; }\n\t\tif (used[i] == true)break;\n\t}\n\tfor (int i = mid - 1; i >= 0; i--) {\n\t\tif (c[i] != 0 && used[i + 1] == false) { cout << \"NO\" << endl; return 0; }\n\t\tif (used[i + 1] == true)break;\n\t}\n\tfor (int i = 0; i < mid; i++) {\n\t\tif (d[i] == 0 && d[S.size() - 1 - i] == 0 && c[i] != 0) { cout << \"NO\" << endl; return 0; }\n\t}\n\tif (S.size() % 2 == 1 && d[mid] == 0) { cout << \"NO\" << endl; return 0; }\n\tfor (int i = 0; i < mid - 1; i++) {\n\t\tif (c[i] != c[i + 1] && used[i + 1] == false) { cout << \"NO\" << endl; return 0; }\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\n\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tvector<pair<ll, ll>> segs;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tint m = s.size() / 2 + 1;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tll dis = (r - m + 1) * 2;\n\t\t\tr -= dis + 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) st[cur.first].insert(cur.second);\n\tll m = s.size() / 2, cur = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << 2 / 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t\tif (l >= m) l--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tint m = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (int i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (int i=(0),_E=(n); i<_E; ++i)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 100005;\nint sum[N], c[N], a[N], pa[N], n, Q, L, R;\nchar s[N];\n\ninline int getpa(int x) {\n\treturn pa[x] == x ? x : pa[x] = getpa(pa[x]);\n}\n\nint main() {\n\tscanf(\"%s%d\", s + 1, &Q);\n\tn = strlen(s + 1);\n\trep (i, 1, n) {\n\t\ta[i] = s[i] - 'a';\n\t}\n\trep (i, 1, n + 1) {\n\t\tc[i] = (a[i] - a[i-1] + 26) % 26;\n\t\tpa[i] = min(i, n + 2 - i);\n\t}\n\trep (i, 1, Q) {\n\t\tscanf(\"%d%d\", &L, &R);\n\t\tpa[getpa(L)] = getpa(R+1);\n\t}\n\trep (i, 1, n + 1) {\n\t\tsum[getpa(i)] += c[i];\n\t}\n\trep (i, 1, n + 1) {\n\t\tif (pa[i] == i && sum[i] % 26) {\n\t\t\treturn puts(\"NO\"), 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\n\nint a[MAXN];\n\nvoid change(int L, int R, int v) {\n    a[L] += v;\n    a[R + 1] -= v;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    int M = (n + 1) / 2;\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            //cout << \"c1\";\n            x = n - x + 1;\n            y = n - y + 1;\n            std::swap(x, y);\n        }\n        if (x <=mm && y >mm) {\n            //cout<<\"c2\";\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        // cout << x << ' ' << y;\n        if (x > y) continue;\n        ls.emplace_back(x, y);\n    }\n    m = ls.size();\n    std::sort(begin(ls), end(ls));\n    int j = 0, val = 0;\n    for (int i = 1; i + i <= n; ++i) {\n        val = (val + a[i]) % 26;\n        val = (val + 26) % 26;\n        while (j < m && ls[j].se < i) j++;\n        if (j < m && ls[j].fi <= i) {\n            change(ls[j].fi, ls[j].se, -val);\n            val = 0;\n            j++;\n        }\n        if (val != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+35;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+35) {puts(\"NO\");return 0;}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\n\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() % 2 == 0) cout << 2 / 0;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tvector<pair<ll, ll>> segs;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tint m = s.size() / 2 + 1;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tll dis = (r - m + 1) * 2;\n\t\t\tr -= dis + 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) st[cur.first].insert(cur.second);\n\tll m = s.size() / 2, cur = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i,a,b) for(int i=a,ggdem=b;i<ggdem;i++)\n#define pb push_back\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(),a.end()\n#define fst first\n#define snd second\ntypedef pair<int,int> ii;\n\nint n,len,mid;\nstring s;\nvector<ii>ranges;\nvector<ii> separate(vector<ii>v) {\n\tpriority_queue<ii,vector<ii>,greater<ii>>pq;\n\tfor(auto it:v)pq.push(it);\n\tvector<ii>res;\n\twhile(SZ(pq)) {\n\t\tii t=pq.top();pq.pop();\n\t\tif(!SZ(res)){res.pb(t);continue;}\n\t\tif(t==res.back())continue;\n\t\tif(t.fst==res.back().fst){\n\t\t\tif(t.fst<t.snd)pq.push({res.back().snd,t.snd});\n\t\t\telse pq.push({-res.back().snd,t.snd});\n\t\t}\n\t\telse res.pb(t);\n\t}\n\treturn res;\n}\nvoid preprocess() {\n\tranges=separate(ranges);\n\t// cout<<\"after first separate:\"<<endl;for(auto it:ranges)cout<<\"[\"<<it.fst<<\",\"<<it.snd<<\")\"<<endl;\n\tfore(i,0,SZ(ranges))swap(ranges[i].fst,ranges[i].snd),ranges[i].snd*=-1;\n\tranges=separate(ranges);\n\tfore(i,0,SZ(ranges))swap(ranges[i].fst,ranges[i].snd),ranges[i].fst*=-1;\n\tsort(ALL(ranges));\n}\nbool is_palindrome(string &s) {\n\tfore(i,0,SZ(s)/2)if(s[i]!=s[SZ(s)-i-1])return 0;\n\treturn 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin>>s>>n;\n\tif(is_palindrome(s))return!(cout<<\"YES\"<<endl);\n\t// cout<<\"SZ: \"<<SZ(s)<<endl;\n\tlen=SZ(s),mid=len/2;\n\tfore(i,0,n) {\n\t\tint l,r;cin>>l>>r;l--;\n\t\t// cout<<\"[\"<<l<<\",\"<<r<<\"): \";\n\t\tif(l<=mid && r<=mid) {\n\t\t\tranges.pb({l,r});\n\t\t} else if(l<=mid && r>mid) {\n\t\t\tii p={min(l,len-r),max(l,len-r)};\n\t\t\tif(p.fst<p.snd)ranges.pb(p);\n\t\t\t// else cout<<\" skip \";\n\t\t} else if (l>mid && r>mid) {\n\t\t\tranges.pb({len-r,len-l});\n\t\t} else {\n\t\t\tcout<<\"UNEXPECTED: \"<<l<<\" \"<<r<<\" | \"<<mid<<endl;\n\t\t\tassert(0);\n\t\t}\n\t\t// cout<<\"[\"<<ranges.back().fst<<\",\"<<ranges.back().snd<<\")\"<<endl;\n\t}\n\tif(!SZ(ranges))return!(cout<<\"NO\"<<endl);\n\tsort(ALL(ranges));\n\t// cout<<\"ranges:\"<<endl;for(auto it:ranges)cout<<\"[\"<<it.fst<<\",\"<<it.snd<<\")\"<<endl;\n\tpreprocess();\n\t// cout<<\"finally ranges:\"<<endl;for(auto it:ranges)cout<<\"[\"<<it.fst<<\",\"<<it.snd<<\")\"<<endl;\n\tint it=0,ac=0;\n\tpriority_queue<ii,vector<ii>,greater<ii>>pq;\n\tfore(i,0,mid) {\n\t\tif(SZ(pq) && pq.top().fst==i) {\n\t\t\tac-=pq.top().snd;\n\t\t\tpq.pop();\n\t\t}\n\t\tint need=(s[len-i-1]-(s[i]+ac)+2600)%26;\n\t\tif(!need)continue;\n\t\tif(ranges[it].fst==i) {\n\t\t\tac+=need;\n\t\t\tpq.push({ranges[it].snd,need});\n\t\t\tit++;\n\t\t} else return!(cout<<\"NO\"<<endl);\n\t}\n\tcout<<\"YES\"<<endl;\n}\n/*   X\n\tXXXXXXX\n\t [1,5)\n\t [3,7)\n*/"
  },
  {
    "language": "C++",
    "code": "/*input\ncassert\n4\n1 2\n3 4\n1 1\n2 2\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=80000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nstring s;\nstring L,R;\n\nvector<int> bound[maxn];\n\npii itv[maxn];\nint main()\n{\n\tIOS;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>itv[i].F>>itv[i].S;\n\tREP(i,n) itv[i].F--;\n\n\tREP(i,n){\n\t\titv[i].F=min(itv[i].F,SZ(s)-itv[i].F);\n\t\titv[i].S=min(itv[i].S,SZ(s)-itv[i].S);\n\t\tif(itv[i].F>itv[i].S) swap(itv[i].F,itv[i].S);\n\t}\n\tREP(i,n) cout<<itv[i]<<'\\n';\n\tfor(int i=0;i<SZ(s)/2;i++) L.pb(s[i]);\n\tfor(int i=0;i<SZ(s)/2;i++) R.pb(s[SZ(s)-1-i]);\n\n\tREP(i,n) bound[itv[i].F].pb(itv[i].S);\n\tREP(i,SZ(s)/2){\n\t\tSORT_UNIQUE(bound[i]);\n\t\tfor(int j=1;j<SZ(bound[i]);j++){\n\t\t\tbound[bound[i][j-1]].pb(bound[i][j]);\n\t\t}\n\t\twhile(SZ(bound[i])>1) bound[i].pop_back();\n\t}\n\tREP(i,SZ(s)/2){\n\t\tfor(int j:bound[i]) cout<<j<<' ';\n\t\tcout<<'\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N], x[N], root[N], summ[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) return x;\n    return root[x] = Root(root[x]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (s[s.size() - 1 - i] + 26 - s[i]) % 26;\n    }\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    iota(root, root + len + 2, 0);\n    fill(sz, sz + len + 2, 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = Root(l[i]), b = Root(r[i]);\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    for (int i = 1; i < len + 2; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i < len + 2; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return weight(y) - weight(x);\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx]));\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          if((diff) != (S[other] - S[idx])) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len + 1);\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    for (int i = len; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    x[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        r[i]++;\n    }\n    vector<int> root(len + 1), sz(len + 1);\n    iota(root.begin(), root.end(), 0);\n    fill(sz.begin(), sz.end(), 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    vector<int> summ(len + 1);\n    for (int i = 1; i <= len; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i <= len; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    if (t == -1) cout << \"YES\", exit(0);\n    int s = 0;\n    while (s != root[s]) s = root[s];\n    if (s == t) cout << \"YES\", exit(0);\n    else cout << \"NO\", exit(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k + 1) R[i]--;\n\t\tif(L[i] >= k + 1) L[i]--;\n\t\tif(L[i] == k + 1 && R[i] == k + 1){\n\t\t\tL[i] = 1;\n\t\t\tR[i] = k * 2;\n\t\t}\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+5;\nint lowbit(int x){return x&(-x);}\nint arr[MAXN];\ninline int sum(int x){int res=0;while(x)res+=arr[x],x-=lowbit(x);return res;}\ninline void add(int x,int n){while(x<MAXN)arr[x]+=n,x+=lowbit(x);}\ninline int update(int x,int y,int n){add(x,n);add(y+1,-n);}\nstruct node{\n    int a,b;\n    bool operator < (const node&p)const{\n        return a==p.a ? b > p.b : a > p.a;\n    }\n};\npriority_queue<node> q;\nqueue<node> qq,qqq;\nint f[MAXN];\nstring s;\n//char s[MAXN];\nint a[MAXN];\nint main()\n{\n    memset(f,-1,sizeof f);\n    int x,n,l,r;\n    cin>>s;\n    s=\"0\"+s;\n    //scanf(\"%s\",&s+1);\n    int len = s.length();\n\n    //printf(\"%s\\n\",s);\n    //cout<<s<<endl;\n    //cout<<\"len:\"<<len<<endl;\n    for(int i=1;i<=len/2;i++){\n        update(i,i,s[i] - s[len-i]);\n    }\n    cin>>n;\n    int ll = len / 2;\n    //cout<<\"ll: \"<<ll<<endl;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        //cout<<l<<\"|\"<<r<<endl;\n        if(r <= ll)\n            q.push(node{l,r});\n        else if(l <= ll){\n            //l += ll - l + 1;\n            if(abs(ll-l)>abs(r-ll))\n            {\n                q.push(node{l,len-r-1});\n            }\n            else if(abs(ll-l)<abs(r-ll))\n                q.push(node{len-r,l-1});\n\n            //q.push(node{ll - max(abs(ll-l),abs(ll-r)), ll - min(abs(ll-l),abs(ll-r))});\n        }\n        else{\n            q.push(node{len-r,len-l});\n        }\n    }\n    /*while(!q.empty()){\n        node now = q.top();\n        //qq.push(now);\n        cout<<now.a<<\"-\"<<now.b<<endl;\n        q.pop();\n    }*/\n    node now,pre = q.top();\n    //qq.push(pre);\n    while(!q.empty()){\n        now = q.top();\n        //cout<<now.a<<\" | \"<<now.b<<endl;\n        if(pre.a < now.a){\n            f[pre.a] = pre.b;\n            pre = now;\n            continue;\n        }\n        q.pop();\n        if(pre.b == now.b)continue;\n        else{\n            q.push(node{pre.b+1, now.b});\n        }\n    }\n    f[pre.a] = pre.b;\n    //qq.push(pre);\n    /*while(!qq.empty()){\n        node now = qq.front();\n        qqq.push(now);\n        cout<<now.a<<\" \"<<now.b<<endl;\n        qq.pop();\n    }*/\n    bool flag = 1;\n    if(len%2==0)len--;\n    for(int i=1;i<=len/2;i++){\n\n        //now = qq.front();\n        x = sum(i) - sum(i-1);\n        //cout<<\"*\"<<x<<\"  \"<<i<<\" \"<<f[i]<<endl;\n        if(x == 0)continue;\n        if(f[i] != -1){\n            //qq.pop();\n            update(i,f[i], -x);\n        }\n        else{\n            flag = 0;\n            break;\n        }\n        //cout<<\"**\"<<sum(i) - sum(i-1)<<endl;\n    }\n    if(flag)\n        cout<<\"YES\\n\";\n    else\n        cout<<\"NO\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tint m = s.size() / 2;\n\t\tif (l == m && r == m) continue;\n\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t\tif (l >= m) l--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tm = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nchar s[MAXN];\nint a[MAXN],N,M;\nstruct node {\n    int to,next;\n}E[MAXN * 10];\nint head[MAXN],sumE,sum;\nbool vis[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    scanf(\"%s\",s + 1);\n    N = strlen(s + 1);\n    s[0] = 'a';s[N + 1] = 'a';\n    for(int i = 1 ; i <= N + 1; ++i) a[i] = (s[i] - s[i - 1] + 26) % 26;\n    read(M);\n    int L,R;\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(L);read(R);\n\tadd(L,R + 1);add(R + 1,L);\n    }\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n\tadd(i,N + 2 - i);\n    }\n}\nvoid dfs(int u) {\n    vis[u] = 1;\n    sum = (sum + a[u]) % 26;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!vis[v]) {\n\t    dfs(v);\n\t}\n    }\n}\nvoid Solve() {\n    bool flag = 1;\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n\tif(!vis[i]) {\n\t    sum = 0;\n\t    dfs(i);\n\t    if(sum != 0) {flag = 0;break;} \n\t}\n    }\n    if(flag) puts(\"YES\");\n    else puts(\"NO\");\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\treturn b - a;\n}\n\nset<int> st;\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB({1, i});\n\t\tvec[r[i] + 1].PB({-1, i});\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t\tif(x == -1) st.erase(id);\n\t\t\telse st.insert(id);\n\t\t}\n\t\ttot[i] = totnow;\n\t\tif(tot[i] == 0) par[i] = 0;\n\t\telse {\n\t\t\tif(ms[st] == 0) ms[st] = i;\n\t\t\tpar[i] = ms[st];\n\t\t}\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(find(i) == find(n - i + 1)) {\n\t\t\tif(s[i - 1] != s[n - i]) bisa = false;\n\t\t}\n\t\telse {\n\t\t\tint pr = find(i);\n\t\t\tif(pr != 0) {\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(find(n - i + 1) == find(rev)) {\n\t\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n\t//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n\t//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\t\tbisa = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nint main(){\n  char s[SIZE];\n  int n,m;\n  int l[SIZE],r[SIZE];\n  vector<int> cc[SIZE];\n  \n  scanf(\"%s%d\",s,&m);\n  n = strlen(s);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",l+i,r+i);\n    l[i]--; r[i]--;\n    \n    if(n%2 == 0){\n      if(l[i] <= n/2-1 && n/2 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - (n/2 - 1);\n        \n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if (a > b){\n          l[i] = n/2 - a;\n          r[i] = n/2 - b - 1;\n        }else{\n          l[i] = n/2 - b;\n          r[i] = n/2 - a - 1;\n        }\n      }\n    }else{\n      if(l[i] == r[i] && l[i] == n/2){\n        l[i] = -1; r[i] = -1;\n      }else if(l[i] == n/2){\n        l[i] += 1;\n      }else if(r[i] == n/2){\n        r[i] -= 1;\n      }else if(l[i] <= n/2-1 && n/2+1 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - n/2;\n\n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if(a > b){\n          l[i] = n/2 - a;\n          r[i] = n/2 - b - 1;\n        }else{\n          l[i] = n/2 - b;\n          r[i] = n/2 - a - 1;\n        }\n      }\n    }\n\n    if(l[i] != -1){\n      if((n+1)/2 <= l[i]){\n        l[i] = n - l[i] - 1;\n        r[i] = n - r[i] - 1;\n        swap(l[i], r[i]);\n      }\n\n      assert(l[i] < n/2 && r[i] < n/2);\n      cc[l[i]].push_back(r[i]);\n    }\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size() > 1)\n      sort(cc[i].begin(),cc[i].end());\n\n    for(int j=cc[i].size()-2;j>=0;j--){\n      if(cc[i][j] != cc[i][j+1])\n        cc[cc[i][j]+1].push_back(cc[i][j+1]);\n    }\n  }\n\n  SegTree seg(n);\n  \n  for(int i=0;i<n/2;i++){\n    seg.add(i, i, 26 + s[n-i-1] - s[i]);\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size()){\n      int q = seg.query(i,i);\n      seg.add(i, cc[i][0], 26-q%26);\n    }\n\n    if(seg.query(i,i)%26 != 0){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n\n  puts(\"YES\");\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nstruct LL {\n  ll value;\n\n  LL() : value(0) {}\n\n  explicit LL(ll value) : value(value) {}\n\n  LL(const LL& a, const LL& b) {\n    value = a.value + b.value;\n  }\n};\n\nstruct Add {\n  ll value;\n\n  Add() : value(0) {}\n\n  explicit Add(ll value) : value(value) {}\n\n  Add(const Add& a, const Add& b) {\n    value = a.value + b.value;\n  }\n};\n\nvoid apply(LL& e, const Add& m, int l, int r) {\n  e.value += m.value * (r - l);\n  (void) l, (void) r;\n}\n\ntemplate<typename E, typename M>\nstruct ST {\n  static constexpr int inf = 1e9;\n  int base;\n  vector<E> t;\n  vector<M> upd;\n\n  static int calc_base(int n) {\n    int x = 1;\n    while (x < n) {\n      x *= 2;\n    }\n    return x;\n  }\n\n  ST() : base(0) {}\n  ST(int n) : base(calc_base(n)), t(base * 2), upd(base * 2) {}\n\n  void push(int v, int cl, int cr) {\n    int cc = (cl + cr) / 2;\n    apply(t[v * 2 + 0], upd[v], cl, cc);\n    apply(t[v * 2 + 1], upd[v], cc, cr);\n    upd[v * 2 + 0] = M(upd[v * 2 + 0], upd[v]);\n    upd[v * 2 + 1] = M(upd[v * 2 + 1], upd[v]);\n    upd[v] = M();\n  }\n\n  E get(int l, int r, int v = 1, int cl = 0, int cr = inf) {\n    cr = min(cr, base);\n    if (l <= cl && cr <= r) {\n      return t[v];\n    }\n    if (r <= cl || cr <= l) {\n      return E();\n    }\n    push(v, cl, cr);\n    int cc = (cl + cr) / 2;\n    return E(get(l, r, v * 2, cl, cc), get(l, r, v * 2 + 1, cc, cr));\n  }\n\n  void put(int l, int r, const M& x, int v = 1, int cl = 0, int cr = inf) {\n    cr = min(cr, base);\n    if (l <= cl && cr <= r) {\n      apply(t[v], x, cl, cr);\n      upd[v] = M(upd[v], x);\n      return;\n    }\n    if (r <= cl || cr <= l) {\n      return;\n    }\n    push(v, cl, cr);\n    int cc = (cl + cr) / 2;\n    put(l, r, x, v * 2 + 0, cl, cc);\n    put(l, r, x, v * 2 + 1, cc, cr);\n    t[v] = E(t[v * 2], t[v * 2 + 1]);\n  }\n\n  E& raw_data(int pos) {\n    return t[base + pos];\n  }\n\n  void build() {\n    for (int i = base - 1; i > 0; --i) {\n      t[i] = E(t[i * 2], t[i * 2 + 1]);\n    }\n  }\n\n  void set(int pos, const E& val, int v = 1, int cl = 0, int cr = inf) {\n    cr = min(cr, base);\n    if (cl + 1 == cr) {\n      assert(v == pos + base);\n      t[v] = val;\n      return;\n    }\n    push(v, cl, cr);\n    int cc = (cl + cr) / 2;\n    if (pos < cc) {\n      set(pos, val, v * 2, cl, cc);\n    } else {\n      set(pos, val, v * 2 + 1, cc, cr);\n    }\n    t[v] = E(t[v * 2], t[v * 2 + 1]);\n  }\n};\nusing Tree = ST<LL, Add>;\n\nconst int maxn = 50100;\nbitset<maxn> q[maxn];\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  int m = n / 2;\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      q[nl][nr] = 1;\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  bitset<maxn> greater;\n  for (int i = 0; i <= m; ++i) {\n    greater[i] = 1;\n  }\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    greater[i] = 0;\n    q[i] &= greater;\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = q[i]._Find_first();\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]==kk);\n\t\t\telse if(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i] = a[i+1]-a[i];\n\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t}\n\tbool f = true;\n\tvector<int> v(n2+1);\n\trep(i, n2+1) v[uf.find(i)].push_back(i);\n\trep(i, n2){\n\t\tif(v[i].empty()) continue;\n\t\tll x = 0;\n\t\tbool g = false;\n\t\trep(j, v[i].size()){\n\t\t\tx += t[v[i][j]];\n\t\t\tif(v[i][j]==n2) g = true;\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n\nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+35;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+35) {puts(\"NO\");return 0;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==1 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\tif (head[i]==0&&d[i]) {puts(\"NO\");return 0;}\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;fa[i+m0*2+1]=x+m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\t/*vector<P> _vec;\n\trep(i,vec[k].size()){\n\t\tif(vec[k][i].fr == k && vec[k][i].sc == S.size()-1-k){}\n\t\telse _vec.pb(vec[k][i]);\n\t}\n\tvec[k] = _vec;*/\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n//S[k] += d;\n//if(S[k] > 'z')S[k] -= 26;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n//S[S.size()-1-k] += d;\n//if(S[S.size()-1-k] > 'z')S[S.size()-1-k] -= 26;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tif(l[i] != S.size()-1-r[i])vec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nostream& operator<<(ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) {string s; ist >> s; return ist;}\nbool Inside(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* E mondai*/\n\nstring s;\nint N;\nint L[100000], R[100000];\nvector<IntMod<26>> ss;\n\nvoid Add(int i, int j, IntMod<26> val) {\n\tss[i] += val;\n\tss[j] -= val;\n}\n\nint main() {\n\tcin >> s >> N;\n\tREP(i, 0, N) {\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t\tif (L[i] > s.size() / 2) L[i] = s.size() - L[i];\n\t\tif (R[i] > s.size() / 2) R[i] = s.size() - R[i];\n\t\tif (L[i] > R[i]) swap(L[i], R[i]);\n\t}\n\n\tREP(i, 0, s.size() / 2) {\n\t\tss.push_back(s[s.size() - i - 1] - s[i]);\n\t}\n\tss.push_back(0);\n\tadjacent_difference(ss.begin(), ss.end(), ss.begin());\n\n\tPriorityQ<PP> Q;\n\tREP(i, 0, N) {\n\t\tQ.push(PP(L[i], R[i]));\n\t}\n\t\n\tPP prev(-1, 0);\n\twhile (!Q.empty()) {\n\t\tPP p = Q.top(); Q.pop();\n\t\tif (p.first == p.second) continue;\n\t\tif (prev.first == p.first) {\n\t\t\tQ.push(PP(prev.second, p.second));\n\t\t\tcontinue;\n\t\t}\n\t\tAdd(p.first, p.second, -ss[p.first]);\n\t\tprev = p;\n\t}\n\tYESNO(all_of(ss.begin(), ss.end(), [](IntMod<26> i) {return i == 0; }));\n\treturn 0;\n}\n\n/*-------------------------*/\n/*-----    二分探索   -----*/\n/*-------------------------*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+5;\nint lowbit(int x){return x&(-x);}\nint arr[MAXN];\ninline int sum(int x){int res=0;while(x)res+=arr[x],x-=lowbit(x);return res;}\ninline void add(int x,int n){while(x<MAXN)arr[x]+=n,x+=lowbit(x);}\ninline int update(int x,int y,int n){add(x,n);add(y+1,-n);}\nstruct node{\n    int a,b;\n    bool operator < (const node&p)const{\n        return a==p.a ? b > p.b : a > p.a;\n    }\n};\npriority_queue<node> q;\nqueue<node> qq,qqq;\nint f[MAXN];\nstring s;\n//char s[MAXN];\nint a[MAXN];\nint main()\n{\n    memset(f,-1,sizeof f);\n    int x,n,l,r;\n    cin>>s;\n    s=\"0\"+s;\n    //scanf(\"%s\",&s+1);\n    int len = s.length();\n\n    //printf(\"%s\\n\",s);\n    //cout<<s<<endl;\n    //cout<<\"len:\"<<len<<endl;\n    for(int i=1;i<=len/2;i++){\n        update(i,i,s[i] - s[len-i]);\n    }\n    cin>>n;\n    int ll = len / 2;\n    //cout<<\"ll: \"<<ll<<endl;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        //cout<<l<<\"|\"<<r<<endl;\n        if(r <= ll)\n            q.push(node{l,r});\n        else if(l <= ll){\n            //l += ll - l + 1;\n            if(abs(ll-l)>abs(r-ll))\n            {\n                q.push(node{l,len-r-1});\n            }\n            else\n                q.push(node{len-r,l-1});\n\n            //q.push(node{ll - max(abs(ll-l),abs(ll-r)), ll - min(abs(ll-l),abs(ll-r))});\n        }\n        else{\n            q.push(node{len-r,len-l});\n        }\n    }\n    /*while(!q.empty()){\n        node now = q.top();\n        //qq.push(now);\n        cout<<now.a<<\"-\"<<now.b<<endl;\n        q.pop();\n    }*/\n    node now,pre = q.top();\n    //qq.push(pre);\n    while(!q.empty()){\n        now = q.top();\n        //cout<<now.a<<\" | \"<<now.b<<endl;\n        if(pre.a < now.a){\n            f[pre.a] = pre.b;\n            pre = now;\n            continue;\n        }\n        q.pop();\n        if(pre.b == now.b)continue;\n        else{\n            q.push(node{pre.b+1, now.b});\n        }\n    }\n    f[pre.a] = pre.b;\n    //qq.push(pre);\n    /*while(!qq.empty()){\n        node now = qq.front();\n        qqq.push(now);\n        cout<<now.a<<\" \"<<now.b<<endl;\n        qq.pop();\n    }*/\n    bool flag = 1;\n    if(len%2==0)len--;\n    for(int i=1;i<=len/2;i++){\n\n        //now = qq.front();\n        x = sum(i) - sum(i-1);\n        //cout<<\"*\"<<x<<\"  \"<<i<<\" \"<<f[i]<<endl;\n        if(x == 0)continue;\n        if(f[i] != -1){\n            //qq.pop();\n            update(i,f[i], -x);\n        }\n        else{\n            flag = 0;\n            break;\n        }\n        //cout<<\"**\"<<sum(i) - sum(i-1)<<endl;\n    }\n    if(flag)\n        cout<<\"YES\\n\";\n    else\n        cout<<\"NO\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://cf17-final.contest.atcoder.jp/tasks/cf17_final_e\n#include<iostream>\n#include<vector>\n#include<string>\n\nstruct DSU{\n\tstd::vector<int> parent;\n\tDSU(int n):parent(n){\n\t\twhile(n--)parent[n]=n;\n\t}\n\tvoid join(int u,int v){parent[root(u)]=root(v);}\n\tint root(int u){return parent[u]!=u?parent[u]=root(parent[u]):u;}\n};\n\nint main(){\n\tstd::ios::sync_with_stdio(false);std::cin.tie(nullptr);\n\tstd::string str;std::cin>>str;\n\tint old_str_len=str.size();\n\n\t// eliminate (str)'s right side\n\tfor(int i=0,j=str.size()-1;i<j;++i,--j){\n\t\tstr[i]=(str[i]-str[j]+26)%26;\n\t\t// str[j]=0;\n\t}\n\tstr.resize(str.size()/2);\n\n\t// compute differences\n\tstr.push_back(0);\n\tfor(int i=str.size();i-- >1;){\n\t\tstr[i]=(str[i]-str[i-1]+26)%26;\n\t}\n\n\t// each operation {l, r} \"connects\" the difference at [l] and [r].\n\tint nOperation;std::cin>>nOperation;\n\tDSU dsu(str.size()+1); // hold the connected components\n\tfor(int _=nOperation;_--;){\n\t\tint left,right;\n\t\tstd::cin>>left>>right;\n\t\t--left;\n\t\tleft =std::min(left ,old_str_len-left );\n\t\tright=std::min(right,old_str_len-right);\n\t\tif(left>right)std::swap(left,right);\n\t\tdsu.join(left,right);\n\t}\n\n\tstd::vector<int> sum(str.size()+1,0);\n\tfor(unsigned i=0;i<=str.size();++i)\n\t\tsum[dsu.root(i)]+=str[i]; // the difference\n\n\tfor(unsigned i=0;i<=str.size();++i)\n\t\tif(sum[i]%26!=0){\n\t\t\tstd::cout<<\"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\n\tstd::cout<<\"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct UnionFind {\n    int n, cc, *u;\n    UnionFind() : n(0), cc(0), u(NULL) {}\n    UnionFind(int n_) : n(n_), cc(n_) {\n\tu = new int[n_];\n\tmemset(u, -1, sizeof (int) * n);\n    }\n    UnionFind(const UnionFind &y) : n(y.n), cc(y.cc) {\n\tu = new int[y.n];\n\tmemcpy(u, y.u, sizeof (int) * n);\n    }\n    ~UnionFind() {\n\tdelete[] u; u = NULL;\n\tn = cc = 0;\n    }\n    friend void swap(UnionFind &x, UnionFind &y) {\n\tswap(x.n, y.n); swap(x.cc, y.cc); swap(x.u, y.u);\n    }\n    UnionFind& operator=(UnionFind y) { \n\tswap(*this, y);\n\treturn *this;\n    }\n    int root(int x) {\n\tint y = x, t;\n\twhile (u[y] >= 0) y = u[y];\n\twhile (x != y) { t = u[x]; u[x] = y; x = t; }\n\treturn y;\n    }\n    bool link(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tif (u[y] < u[x]) swap(x, y);\n\tu[x] += u[y]; u[y] = x; cc--;\n\treturn true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -u[root(x)]; }\n    int count() { return cc; }\n};\n\nint N;\nchar S[100011];\nint A[100011];\nint B[100011];\n\nvoid MAIN() {\n    scanf(\"%s%d\", S+1, &N);\n    S[0] = 'a';\n    int LEN = strlen(S);\n    S[LEN] = 'a';\n    LEN++;\n    REP (i, LEN-1) {\n\tA[i] = (int)S[i+1] - (int)S[i];\n    }\n    UnionFind U(LEN-1);\n    REP (i, N) {\n\tint l, r;\n\tscanf(\"%d%d\", &l, &r);\n\tU.link(l-1, r);\n    }\n    REP (i, LEN-1) U.link(i, LEN-2-i);\n    REP (i, LEN-1) B[U.root(i)] += A[i];\n    bool yes = true;\n    REP (i, LEN-1) if (B[i] % 26) yes = false;\n\n    puts(yes? \"YES\": \"NO\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\nconst int MOD = 26;\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntemplate<class T, int SZ> struct LazySeg {\n    T sum[2 * SZ], lazy[2 * SZ];\n    LazySeg() {\n        for (int i = 0; i < 2 * SZ; i++) {\n            sum[i] = 0;\n            lazy[i] = 0;\n        }\n    }\n    void push(int ind, int L, int R) {\n        sum[ind] += (R - L + 1) * lazy[ind];\n        if (L != R) {\n            lazy[2 * ind] += lazy[ind];\n            lazy[2 * ind + 1] += lazy[ind];\n        }\n        lazy[ind] = 0;\n    }\n    void pull(int ind) {\n        sum[ind] = sum[2 * ind] + sum[2 * ind + 1];\n    }\n    void build() {\n        for (int i = SZ - 1; i >= 1; i--) {\n            pull(i);\n        }\n    }\n    void upd(int lo, int hi, T inc, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (hi < L || R < lo) return ;\n        if (lo <= L && R <= hi) {\n            lazy[ind] = inc;\n            push(ind, L, R);\n            return;\n        }\n        int M = (L + R) / 2;\n        upd(lo, hi, inc, 2 * ind, L, M);\n        upd(lo, hi, inc, 2 * ind + 1, M + 1, R);\n        pull(ind);\n    }\n    T qsum(int lo, int hi, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return sum[ind];\n        int M = (L + R) / 2;\n        return qsum(lo, hi, 2 * ind, L, M) + qsum(lo, hi, 2 * ind + 1, M + 1, R);\n    }\n};\nint main() {\n//    ios_base::sync_with_stdio(0); cin.tie(0);\n//    freopen(\"file.in\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    int len = s.size();\n    vector<pair<int, int>> use;\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (r < len / 2) {\n            use.emplace_back(l, r);\n            continue;\n        }\n        if (l >= (len + 1) / 2) {\n            use.emplace_back(len - 1 - r, len - 1 - l);\n            continue;\n        }\n        if (l == len - 1 - r) {\n            continue;\n        }\n        if (l < len - 1 - r) {\n            use.emplace_back(l, len - 1 - r - 1);\n        } else {\n            use.emplace_back(len - 1 - r, l - 1);\n        }\n    }\n    int half = (len - 1) / 2 + 1;\n    vector<vector<int>> loc(half);\n    for (auto x: use) {\n        loc[x.first].push_back(x.second);\n    }\n    for (int i = 0; i < half; i++) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        while(loc[i].size() > 1) {\n            int r = loc[i].back();\n            loc[i].pop_back();\n            int l = loc[i].back() + 1;\n            loc[l].push_back(r);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int r: loc[i]) {\n            use.emplace_back(i, r);\n        }\n        loc[i].clear();\n    }\n    for (auto x: use) {\n        loc[x.second].push_back(x.first);\n    }\n    use.clear();\n    for (int i = half - 1; i >= 0; i--) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        reverse(loc[i].begin(), loc[i].end());\n        while (loc[i].size() > 1) {\n            int l = loc[i].back();\n            loc[i].pop_back();\n            int r = loc[i].back() - 1;\n            loc[r].push_back(l);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int l: loc[i]) {\n            use.emplace_back(l, i);\n        }\n        loc[i].clear();\n    }\n    string t;\n    for (int i = len - 1; i >= len - half; i--) {\n        t += s[i];\n    }\n    while (s.size() > half) {\n        s.pop_back();\n    }\n    len = half;\n    LazySeg<mi, (1 << 16)> seg;\n    for (int i = 0; i < len; i++) {\n        seg.upd(i, i, s[i] - '0');\n    }\n    sort(use.begin(), use.end());\n    for (auto x: use) {\n        int l = x.first;\n        int r = x.second;\n        int add = ((t[l] - '0') - seg.qsum(l, l).val + MOD) % MOD;\n        seg.upd(l, r, add);\n    }\n    dbg(use);\n    for (int i = 0; i < len; i++) {\n        if (seg.qsum(i, i) != t[i] - '0') {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEMETRIO\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#define deb1(x) cerr << #x << \" = \" << x << endl\n#else\n#define deb(...) 0\n#define deb1(x) 0\n#endif\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define SZ(x) ((int)(x).size())\n#define mset(a,v) memset(a,v,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\n\nchar s[100005];int n,m;\nint w[100005];\nvector<int> g[100005];\nbool vis[100005];\n\nint dfs(int x){\n\tif(vis[x])return 0;\n\tvis[x]=true;\n\tint r=w[x];\n\tfor(int y:g[x])r+=dfs(y);\n\treturn r;\n}\n\nint main(){\n\tscanf(\"%s%d\",s,&m);n=strlen(s);\n\twhile(m--){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);a--;\n\t\tg[a].pb(b);g[b].pb(a);\n\t}\n\tfore(i,0,n)s[i]-='a';\n\tw[0]=s[0];\n\tfore(i,1,n)w[i]=s[i]-s[i-1];\n\tw[n]=-s[n-1];\n\tfore(i,0,n+1)g[i].pb(n-i);\n\tfore(i,0,n+1)if(!vis[i]&&dfs(i)){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\n#define fore(i,a,b) for(int i=a,ggdem=b;i<ggdem;i++)\n#define FIN ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(),a.end()\n#define pb push_back\n#define fst first\n#define snd second\nconst int MAXN=1<<20;\nstring s;\nint n,len,l[MAXN],r[MAXN],vis[MAXN];\nvector<int>g[MAXN],diff;\n\nint dfs(int x) {\n\tif(vis[x])return 0;\n\tvis[x]=1;\n\tint take=0;\n\tfor(int i:g[x])take=(take+dfs(i))%26;\n\tint a=(diff[x]+diff[len-x-1]+take+26)%26;\n\t// cout<<x<<\" : \"<<take<<\" \"<<a<<endl;\n\treturn a;\n}\n\nint main() {FIN;\n\tcin>>s>>n;s=\"a\"+s+\"a\";len=SZ(s)-1;\n\tfore(i,1,SZ(s))diff.pb((s[i]-s[i-1]+26)%26);\n\tfor(int i:diff)cout<<i<<\" \";cout<<endl;\n\tfore(i,0,len)g[i].pb(len-i-1);\n\tfore(i,0,n){\n\t\tint l,r;cin>>l>>r;\n\t\tg[l-1].pb(r);\n\t\tg[r].pb(l-1);\n\t}\n\tfore(i,0,len)if(dfs(i))return!(cout<<\"NO\"<<endl);\n\tcout<<\"YES\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tset<S>::iterator it=st.lower_bound((S){i,0});\n\t\tif(it->s!=i) continue;\n\t\tS range=*it;\n\t\twhile(1)\n\t\t{\n\t\t\tset<S>::iterator it2=st.lower_bound((S){i,0});\n\t\t\tit2++;\n\t\t\tif(it2==st.end()||it2->s!=range.s) break;\n\t\t\tS etemp=*it2;\n\t\t\tst.insert((S){range.e+1,etemp.e});\n\t\t\tst.erase(etemp);\n\t\t}\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t}\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nint n,m,a[N],f[N];\nchar s[N];\nint getf(int x){return f[x]==x?x:f[x]=getf(f[x]);}\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n+1;i++)\n        a[i]=(s[i]-s[i-1]+26)%26,f[i]=i;\n    n++;\n    for(int i=1,j=n;i<j;i++,j--)\n    {\n        int fi=getf(i),fj=getf(j);\n        a[fi]=(a[fi]+a[fj])%26;\n        f[fj]=fi;\n    }\n    scanf(\"%d\",&m);\n    while(m--)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);v++;\n        u=getf(u);v=getf(v);\n        if(u==v) continue;\n        a[u]=(a[u]+a[v])%26;\n        f[v]=u;\n    }\n    for(int i=1;i<=n;i++)\n        if(f[i]==i&&a[i]!=0)\n    {\n        printf(\"NO\\n\");return 0;\n    }\n    printf(\"YES\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint gcd(int x, int y) {\n    while (1) {\n\tif (x) y %= x; else return y;\n\tif (y) x %= y; else return x;\n    }\n}\nint lcm(int x, int y) {\n    return x / gcd(x, y) * y;\n}\n\nint N;\nchar S[100011];\nint L[100011], R[100011];\nint La[100011], Ra[100011];\nint D[100011];\nVI G[100011];\n\nvoid MAIN() {\n    scanf(\"%s%d\", S, &N);\n    int LEN = strlen(S);\n    REP (i, N) scanf(\"%d%d\", L+i, R+i), L[i]--;\n\n    int M = LEN/2;\n    REP (i, LEN-1) {\n\tint d = (int)S[i+1] - (int)S[i];\n\tif (i*2+2 == LEN) {\n\t    D[i] += d+d;\n\t} else if (i >= M) {\n\t    D[LEN-2-i] += d;\n\t} else {\n\t    D[i] += d;\n\t}\n    }\n\n    REP (i, N) {\n\tL[i]--;\n\tLa[i] = 1;\n\n\tR[i]--;\n\tRa[i] = -1;\n\n\tif (M <= L[i]) {\n\t    L[i] = LEN-2-L[i];\n\t    La[i] = -La[i];\n\t}\n\tif (L[i]*2+2 == LEN) La[i] += La[i];\n\n\tif (M <= R[i]) {\n\t    R[i] = LEN-2-R[i];\n\t    Ra[i] = -Ra[i];\n\t}\n\tif (R[i]*2+2 == LEN) Ra[i] += Ra[i];\n\n\tif (L[i] > R[i]) {\n\t    swap(L[i], R[i]);\n\t    swap(La[i], Ra[i]);\n\t}\n\tif (R[i] >= 0) G[R[i]].push_back(i);\n    }\n\n    for (int t=M; t--;) {\n\tD[t] %= 26;\n\tD[t] += 26;\n\tD[t] %= 26;\n\n\tEACH (e, G[t]) {\n\t    assert(R[*e] == t);\n\t    if (D[t] == 0) break;\n\t    if (D[t] % 2 == 1 && Ra[*e] % 2 == 0) continue;\n\t    while (D[t] % abs(Ra[*e])) D[t] += 26;\n\t    int m = D[t] / Ra[*e];\n\t    D[t] -= Ra[*e] * m;\n\t    if (0 <= L[*e]) D[L[*e]] -= La[*e] * m;\n\t}\n\n\tif (D[t]) {\n\t    puts(\"NO\");\n\t    return;\n\t}\n\n\tif (G[t].size() >= 2u) {\n\t    int idx = 0;\n\t    for (int i=1; i<(int)G[t].size(); i++) {\n\t\tif (L[G[t][idx]] > L[G[t][i]]) idx = i;\n\t    }\n\t    REP (i_, G[t].size()) if (i_ != idx) {\n\t\tint i = G[t][i_];\n\t\tint j = G[t][idx];\n\t\tint l = lcm(abs(Ra[i]), abs(Ra[j]));\n\n\t\tint raj = Ra[j], rai = Ra[i];\n\n\t\tR[i] = L[j];\n\t\tRa[i] = l / raj * La[j];\n\t\tLa[i] = l / rai * La[i] * (-1);\n\t\tif (L[i] > R[i]) {\n\t\t    swap(L[i], R[i]);\n\t\t    swap(La[i], Ra[i]);\n\t\t}\n\t\tRa[i] %= 26;\n\t\tif (Ra[i] && 0 <= R[i] && R[i] < t) G[R[i]].push_back(i);\n\t    }\n\t}\n    }\n\n    puts(\"YES\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        if (l < mid2 && r > mid1)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else\n        {\n            l = min(abs(l - mid1), abs(l - mid2));\n            r = min(abs(r - mid1), abs(r - mid2));\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n            int minr = *segs[i].begin();\n            segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nset<int> to[maxn];\nint main(){\n\tstring s; cin >> s;\n\tint len = s.size();\n\tint u = (len - 1) / 2, v = len / 2;\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint l, r; cin >> l >> r; l--; r--;\n\t\tvector<pair<int,int> > ways;\n\t\t/**\n\t\t  abeba\n\t\t   3 4 -> 0 1\n\t\t   0 3 -> 0 0\n\t\t   1 4 -> 0 0 \n\t\t  **/\n\t\tif(r <= u){\n\t\t\tto[l].insert(r);\n\t\t} else if (l >= v){\n\t\t\tto[len - r - 1].insert(len - l - 1);\n\t\t}  else {\n\t\t\tint dl = u - l, dr = r - v;\n\t\t\tif(dl > dr) to[l].insert(u - dr - 1);\n\t\t\telse if(dl < dr) to[len - r - 1].insert(len - 1 - (v + dl + 1));\n\t\t}\n\t}\n\tif(u == v) to[u].insert(u);\n\tvector<int> val(len, 0), pref(2 * len + 10, 0);\n\tfor(int i = 0; i <= u; i++){\n\t\tval[i] = s[v + u - i] - s[i] + 26;\n\t\tval[i] %= 26;\n\t}\n\tfor(int i = 0; i <= u; i++){\n\t\tif(i) pref[i] += pref[i - 1];\n\t\tval[i] += pref[i];\n\t\tval[i] %= 26;\n\t\tval[i] += 26;\n\t\tval[i] %= 26;\n\t\tint pk = -1;\n\t\t{\n\t\t\tvector<int> now;\n\t\t\tfor(int j : to[i]){\n\t\t\t\tnow.push_back(j);\n\t\t\t}\n\t\t\tint sz = now.size();\n\t\t\tfor(int i = 1; i < sz; i++){\n\t\t\t\tto[now[i - 1] + 1].insert(now[i]);\n\t\t\t}\n\t\t\tif(sz) pk = now[0];\n\t\t}\n\t\tif(val[i]){\n\t\t\tif(pk == -1) return cout << \"NO\" << endl, 0;\n\t\t\tpref[i] += 26 - val[i];\n\t\t\tpref[pk + 1] += val[i];\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<int> vec[N + 5];\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\treturn b - a;\n}\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB(1);\n\t\tvec[r[i] + 1].PB(-1);\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(i != 1 && vec[i].size() == 0) par[i] = par[i - 1];\n\t\telse par[i] = i;\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back();\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t}\n\t\ttot[i] = totnow;\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(tot[i] == 0) {\n\t\t\tif(tot[len - i + 1] == 0) {\n//\t\t\t\tcout<<\"TEST1 \"<<i<<\" \"<<len - i + 1<<endl;\n\t\t\t\tif(s[i - 1] != s[len - i]){\n\t\t\t\t\tbisa = false;\n//\t\t\t\t\tcout<<\"ERROR1 \"<<i<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pr = find(par[n - i + 1]);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(dist(i - 1, rev - 1) != dist(n - i, pr - 1)) {\n\t\t\t\t\tbisa = false;\n//\t\t\t\t\tcout<<\"ERROR2 \"<<i<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(par[i] == i) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tint pr = find(i);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(find(n - i) == find(rev)) {\n\t\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\t\tbisa = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n \nusing namespace std;\n \nstruct S{\n\tL s,e;\n};\n \nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n \nset<S>st;\n \nchar str[100010];\nL b[100010];\nL n,len;\n \nL tr[400040];\n \nvoid update(L now,L S,L E,L s,L e,L val){\n\twhile(e)\n\t{\n\t\ttr[e]+=val;\n\t\te^=e&-e;\n\t}\n\ts--;\n\twhile(s)\n\t{\n\t\ttr[s]-=val;\n\t\ts^=s&-s;\n\t}\n}\n \nL get(L now,L S,L E,L loc){\n\tL ret=0;\n\twhile(loc<=len)\n\t{\n\t\tret+=tr[loc];\n\t\tloc+=loc&-loc;\n\t}\n\treturn ret;\n}\n \nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n \nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\t//printf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//for(set<S>::iterator it=st.begin();it!=st.end();it++)\n\t//\tprintf(\"%lld %lld\\n\",it->s,it->e);\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t\tset<S>sttemp;\n\t\t\tL prelast=range.e;\n\t\t\tfor(set<S>::iterator it=st.begin();it!=st.end()&&it->s==range.s;it++)\n\t\t\t{\n\t\t\t\tsttemp.insert((S){prelast+1,it->e});\n\t\t\t\tprelast=it->e;\n\t\t\t}\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()||it->s!=range.s) break;\n\t\t\t\tst.erase(it);\n\t\t\t}\n\t\t\tfor(set<S>::iterator it=sttemp.begin();it!=sttemp.end();it++)\n\t\t\t{\n\t\t\t\tst.insert(*it);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!st.empty()&&st.begin()->s==i)\n\t\t\t{\n\t\t\t\tS range=*(st.begin());\n\t\t\tset<S>sttemp;\n\t\t\tL prelast=range.e;\n\t\t\tfor(set<S>::iterator it=st.begin();it!=st.end()&&it->s==range.s;it++)\n\t\t\t{\n\t\t\t\tsttemp.insert((S){prelast+1,it->e});\n\t\t\t\tprelast=it->e;\n\t\t\t}\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()||it->s!=range.s) break;\n\t\t\t\tst.erase(it);\n\t\t\t}\n\t\t\tfor(set<S>::iterator it=sttemp.begin();it!=sttemp.end();it++)\n\t\t\t{\n\t\t\t\tst.insert(*it);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n\nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+35;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+35) {puts(\"NO\");return 0;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==0 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\tif (head[i]==0&&d[i]) {puts(\"NO\");return 0;}\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;fa[i+m0*2+1]=x*m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"NO\"); exit(0); }\nvoid fg(vector<int> G[], int a, int b) { G[a].eb(b); G[b].eb(a); }\n\nconst bool debug = 0;\nconst int MAXN = 200055;\nconst int MAXK = 200055;\n\nvector<int> G[MAXN];\nbitset<MAXN> chk;\n\nint D[MAXN], E[MAXN];\n\nint B[MAXK], C[MAXK];\nchar A[MAXN];\n\nint N, K;\n\nint f(int i) {\n\tint ret = E[i]; chk[i] = true;\n\tfor(int v : G[i]) if(!chk[v]) {\n\t\tret = (ret + f(v)) % 26;\n\t}\n\treturn ((ret % 26) + 26) % 26;\n}\n\nint main() {\n\tscanf(\" %s\", A+1);\n\tN = int(strlen(A+1));\n\tscanf(\"%d\", &K);\n\tfor(int i = 1; i <= K; i++) scanf(\"%d%d\", &B[i], &C[i]);\n\n\tif(N&1) {\n\t\tN++;\n\t\tfor(int i = N-1; N/2 <= i; i--) A[i+1] = A[i];\n\t\tfor(int i = 1; i <= K; i++) {\n\t\t\tif(N/2 < B[i]) B[i]++;\n\t\t\tif(N/2 <= C[i]) C[i]++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= K; i++) {\n\t\tif(C[i] <= N/2) continue;\n\t\tif(N/2 < B[i]) {\n\t\t\tB[i] = N+1-C[i];\n\t\t\tC[i] = N+1-B[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint l = N/2-B[i]+1, r = C[i]-N/2;\n\t\tif(l > r) swap(l, r);\n\t\tB[i] = N/2-r+1;\n\t\tC[i] = N/2-l;\n\t}\n\n\tif(debug) {\n\t\tprintf(\"N=%d, K=%d\\n\", N, K);\n\t\tfor(int i = 1; i <= N; i++) putchar(A[i]); puts(\"\");\n\t\tfor(int i = 1; i <= K; i++)\n\t\t\tprintf(\"%d ; %d %d\\n\", i, B[i], C[i]);\n\t}\n\n\tN /= 2;\n\tfor(int i = 1; i <= N; i++)\n\t\tD[i] = (A[N*2+1-i] - A[i] + 26) % 26;\n\tfor(int i = 1; i <= N+1; i++)\n\t\tE[i] = ((D[i] - D[i-1] + 26) % 26 + 26) % 26;\n\tfor(int i = 1; i <= K; i++) C[i]++;\n\tN++;\n\n\tfor(int i = 1; i <= K; i++) if(B[i] < C[i]) fg(G, B[i], C[i]);\n\tfor(int i = 1; i <= N; i++) if(!chk[i]) {\n\t\tint t = f(i);\n\t\tif(t) fuk();\n\t}\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"NO\"); exit(0); }\nvoid fg(vector<int> G[], int a, int b) { G[a].eb(b); G[b].eb(a); }\n\nconst int MAXN = 100005;\nconst int MAXK = 100005;\n\nvector<int> G[MAXN];\nbitset<MAXN> chk;\n\nint D[MAXN], E[MAXN];\n\nint B[MAXK], C[MAXK];\nchar A[MAXN];\n\nint N, K;\n\nint f(int i) {\n\tint ret = E[i]; chk[i] = true;\n\tfor(int v : G[i]) if(!chk[v]) {\n\t\tret = (ret + f(v)) % 26;\n\t}\n\treturn ((ret % 26) + 26) % 26;\n}\n\nint main() {\n\tscanf(\" %s\", A+1);\n\tN = int(strlen(A+1));\n\tscanf(\"%d\", &K);\n\tfor(int i = 1; i <= K; i++) scanf(\"%d%d\", &B[i], &C[i]);\n\n\tif(N&1) {\n\t\tN++;\n\t\tfor(int i = N-1; N/2 <= i; i--) A[i+1] = A[i];\n\t\tA[N/2] = A[N/2+1];\n\t\tfor(int i = 1; i <= K; i++) {\n\t\t\tif(N/2 <= B[i]) B[i]++;\n\t\t\tif(N/2 <= C[i]) C[i]++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= K; i++) {\n\t\tif(C[i] <= N/2) continue;\n\t\tif(N/2 < B[i]) {\n\t\t\tB[i] = N+1-B[i];\n\t\t\tC[i] = N+1-C[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint l = N/2-B[i]+1, r = C[i]-N/2;\n\t\tif(l > r) swap(l, r);\n\t\tB[i] = N/2-r+1;\n\t\tC[i] = N/2-l;\n\t}\n\n\tN /= 2;\n\tfor(int i = 1; i <= N; i++)\n\t\tD[i] = (A[N*2+1-i] - A[i] + 26) % 26;\n\tfor(int i = 1; i <= N+1; i++)\n\t\tE[i] = (D[i] - D[i-1] + 26) % 26;\n\tfor(int i = 1; i <= K; i++) C[i]++;\n\tN++;\n\n\tfor(int i = 1; i <= K; i++) if(B[i] < C[i]) fg(G, B[i], C[i]);\n\tfor(int i = 1; i <= N; i++) if(!chk[i]) {\n\t\tint t = f(i);\n\t\tif(t) fuk();\n\t}\n\n\tfor(int i = 1; i <= N; i++) if(!chk[i] && E[i]) fuk();\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sign(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\nusing mint = mod_int<26>;\n\ntemplate<typename M>\nstruct fenwick_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    fenwick_tree(int n) : n(n), data(n + 1, M::id()) {}\n    void add(int i, const T &x) { for (i++; i <= n; i += i & -i) { data[i] = M::op(data[i], x); }}\n    T get_sum(int i) const {\n        T ret = M::id();\n        for (; i > 0; i -= i & -i) { ret = M::op(ret, data[i]); }\n        return ret;\n    }\n    T get_sum(int l, int r) const {\n        return M::op(get_sum(r), M::inv(get_sum(l)));\n    }\n};\n\ntemplate<typename M>\nstruct fenwick_tree_range {\n    using T = typename M::T;\n    fenwick_tree<M> ft;\n    fenwick_tree_range(int n) : ft(n + 1) {}\n    void add(int l, int r, const T &x) { ft.add(l, x), ft.add(r, -x); }\n    T operator[](int i) const { return ft.get_sum(i + 1); }\n};\n\nstruct rsq {\n    using T = mint;\n    static T id() { return 0; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static T inv(const T &a) { return -a; }\n};\n\nstring S;\nint N;\nint L[110000], R[110000];\npriority_queue_rev<int> rs[110000];\nsigned main() {\n    cin >> S >> N;\n    int K = S.length();\n    rep(i, N) {\n        cin >> L[i] >> R[i];\n        if (L[i] - 1 < K - R[i]) { rs[L[i] - 1].push(min(R[i], K - R[i] + 1)); }\n        else if (L[i] - 1 > K - R[i]) { rs[K - R[i]].push(min(L[i] - 1, K - L[i])); }\n    }\n    fenwick_tree_range<rsq> ft(K / 2);\n    rep(i, K / 2) { ft.add(i, i + 1, S[i] - S[K - i - 1]); }\n    rep(i, K / 2) {\n        if (rs[i].empty()) {\n            if (ft[i] != 0) { fin(\"NO\"); }\n            continue;\n        }\n        int cur = rs[i].top();\n        rs[i].pop();\n        ft.add(i, cur, -ft[i]);\n        while (!rs[i].empty()) {\n            if (cur < rs[i].top()) { rs[cur].push(rs[i].top()); }\n            cur = rs[i].top(), rs[i].pop();\n        }\n    }\n    cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//while (clock()<=69*CLOCKS_PER_SEC)\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=100*1007;\n\nint k;\nchar wcz[nax];\n\nint n;\n\nint oj[nax];\n\nint sum[nax];\n\nint fin(int v)\n{\n\tif (v!=oj[v])\n\t\toj[v]=fin(oj[v]);\n\treturn oj[v];\n}\n\nvoid uni(int v, int u)\n{\n\toj[fin(u)]=fin(v);\n}\n\nint main()\n{\n\tscanf(\"%s\", wcz+1);\n\tk=strlen(wcz+1);\n\tint tak=0;\n\tif (!(k&1))\n\t{\n\t\tfor (int i=k; i>(k/2); i--)\n\t\t\twcz[i+1]=wcz[i];\n\t\twcz[k/2+1]='a';\n\t\tk++;\n\t\ttak=1;\n\t}\n\twcz[0]='a';\n\twcz[k+1]='a';\n\tfor (int i=0; i<=k; i++)\n\t\toj[i]=i;\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif (tak && r>(k/2))\n\t\t\tr++;\n\t\tuni(l-1, r);\n\t}\n\tfor (int i=1; i<=k/2+1; i++)\n\t\tuni(i-1, k-(i-1));\n\tfor (int i=0; i<=k; i++)\n\t\tsum[fin(i)]+=(wcz[i]-wcz[i+1]);\n\tfor (int i=0; i<=k; i++)\n\t{\n\t\tif (sum[i]%26)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nusing namespace std;\n\nstring s;\nint n, m, l[N], r[N], sum[N], cnt[N];\nint pset[N];\n\nint findset(int i){return ((pset[i] == i) ? i : pset[i] = findset(pset[i]));}\n\nvoid dsu(int i, int j){\n    i = findset(i); j = findset(j);\n    if (i == j) return;\n    pset[j] = i;\n    sum[i] += sum[j];\n    if (sum[i] >= 26) sum[i] -= 26;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s;\n    n = s.size();\n    s = '.' + s;\n    cin >> m;\n    for (int i = 1; i <= m; i++){\n        cin >> l[i] >> r[i];\n        if (r[i] < n + 1 - r[i]) continue;\n        if (l[i] > n + 1 - l[i]){\n            l[i] = n + 1 - l[i];\n            r[i] = n + 1 - r[i];\n            continue;\n        }\n        r[i] = n + 1 - r[i];\n        if (l[i] <= r[i]) r[i]--;\n        else l[i]--, swap(l[i], r[i]);\n    }\n\n    for (int i = 1; i <= n/2; i++){\n        cnt[i] = s[n+1-i] - s[i]; if (cnt[i] < 0) cnt[i] += 26;\n    }\n\n    sum[n/2+1] = -cnt[n/2];\n    if (sum[n/2+1] < 0) sum[n/2+1] += 26;\n    for (int i = n/2; i >= 1; i--) {\n        sum[i] = cnt[i] - cnt[i-1];\n        if (sum[i] < 0) sum[i] += 26;\n    }\n\n    for (int i = 1; i <= n/2+1; i++) pset[i] = i;\n    for (int i = 1; i <= m; i++) dsu(l[i], r[i]+1);\n\n    for (int i = 1; i <= n/2; i++) {\n        if (pset[i] == i && sum[i] != 0) return cout << \"NO\", 0;\n    }\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nll K = 2;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk[N];\nll ha[N];\nint len;\n\nbool check()\n{\n    degk[0] = 1;\n    for (int i = 1; i < N; i++) degk[i] = degk[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degk[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degk[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) return 0;\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) return 0;\n    return 1;\n}\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    if (check()) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nint diff[limit];\n\n// Description: 素集合を管理するデータ構造\n// TimeComplexity: 初期化$\\mathcal{O}(n)$ 更新$\\mathcal{O}(\\log n)$\n// Verifyed: AOJ DSL_1_A\n\nstruct Union_find {\n\tUnion_find(int n) {par.resize(n), iota(_all(par), 0);}\n\tint find(int x) {return (par[x] == x) ? x : par[x] = find(par[x]);}\n\tvoid unite(int a, int b) {a = find(a), b = find(b); par[a] = b;}\n\tbool same(int a, int b) {return find(a) == find(b);}\n\tvector<int> par;\n};\n\n// abcde\n// 0a1b2c3d4e5\n\nint total[limit];\n\nint main(void) {\n\tstring s;\n\tcin >> s;\n\n\tconst int m = s.size();\n\n\tdiff[0] = (s[0] - 'a') % 26;\n\trep(i, m - 1) diff[i + 1] = (s[i + 1] - s[i] + 26) % 26;\n\tdiff[m] = (26 - (s[m - 1] - 'a')) % 26;\n\n\tUnion_find uf(m + 1);\n\trep(i, m + 1) uf.unite(i, m - i);\n\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tuf.unite(l,r);\n\t}\n\n\tbool ok = true;\n\trep(i,m+1) total[uf.find(i)] = (total[uf.find(i)] + diff[i]) % 26;\n\trep(i,m+1) if(total[i]!=0) ok = false;\n\tputs(ok?\"YES\":\"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) {string s; ist >> s; return ist;}\nbool Inside(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* E mondai*/\n\nstring s;\nint N;\nint L[100000], R[100000];\nvector<IntMod<26>> ss;\n\nvoid Add(int i, int j, IntMod<26> val) {\n\tss[i] += val;\n\tss[j] -= val;\n}\n\nint main() {\n\tcin >> s >> N;\n\tREP(i, 0, N) {\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t\tif (L[i] > s.size() / 2) L[i] = s.size() - L[i];\n\t\tif (R[i] > s.size() / 2) R[i] = s.size() - R[i];\n\t\tif (L[i] > R[i]) swap(L[i], R[i]);\n\t}\n\n\tREP(i, 0, s.size() / 2) {\n\t\tss.push_back(s[s.size() - i - 1] - s[i]);\n\t}\n\tss.push_back(0);\n\tadjacent_difference(ss.begin(), ss.end(), ss.begin());\n\n\tmap<int, vector<int>> m;\n\tREP(i, 0, N) {\n\t\tm[L[i]].push_back(R[i]);\n\t}\n\n\tPriorityQ<PP> Q;\n\tfor(auto&& p : m){\n\t\tvector<int>& v = p.second;\n\t\tsort(v.begin(), v.end());\n\t\tQ.push(PP(p.first, v[0]));\n\t\tREP(i, 0, v.size() - 1) {\n\t\t\tQ.push(PP(v[i], v[i + 1]));\n\t\t}\n\t}\n\n\twhile (!Q.empty()) {\n\t\tPP p = Q.top(); Q.pop();\n\t\tAdd(p.first, p.second, -ss[p.first]);\n\t}\n\tYESNO(all_of(ss.begin(), ss.end(), [](IntMod<26> i) {return i == 0; }));\n\treturn 0;\n}\n\n/*-------------------------*/\n/*-----    二分探索   -----*/\n/*-------------------------*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\t//printf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\twhile(!st.empty()&&st.begin()->s<i) st.erase(st.begin());\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(st.empty()) break;\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()) break;\n\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\tS temp2=*it;\n\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\tst.erase(temp2); \n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n \nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n \nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tif(p.fr != S.size()-1-p.sc)vec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\tvec[k].clear();\n\treturn solve(k+1,a,b);\n}\n \n \nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tif(l[i] != S.size()-1-r[i])vec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N], x[N / 2], root[N / 2], sz[N / 2];\n\ninline int Root(int x)\n{\n    if (x == root[x]) return x;\n    return root[x] = Root(root[x]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (s[s.size() - 1 - i] + 26 - s[i]) % 26;\n    }\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    iota(root, root + len + 2, 0);\n    fill(sz, sz + len + 2, 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = Root(l[i]), b = Root(r[i]);\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            x[b] += x[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            x[a] += x[b];\n            root[b] = a;\n        }\n    }\n    for (int i = 0; i < len + 2; i++)\n    {\n        if (x[Root(i)] % 26 != 0)\n        {\n            cout << \"NO\", exit(0);\n        }\n    }\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nusing namespace std;\n\nchar s[N];\nint n, m, l[N], r[N], x[N / 2], root[N / 2], sz[N / 2];\n\ninline int Root(int x)\n{\n    if (x == root[x]) return x;\n    return root[x] = Root(root[x]);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    scanf(\"%s%d\", s, &n);\n    m = strlen(s);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        l[i]--, r[i]--;\n    }\n    if (m & 1)\n    {\n        int pos = m >> 1;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        m--;\n        for (int i = pos; i < m; i++) s[i] = s[i + 1];\n    }\n    int len = m >> 1;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = m - 1 - l[i];\n            int ll = m - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = s[m - 1 - i] - s[i];\n    }\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] -= x[i - 1];\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    iota(root, root + len + 2, 0);\n    fill(sz, sz + len + 2, 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = Root(l[i]), b = Root(r[i]);\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            x[b] += x[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            x[a] += x[b];\n            root[b] = a;\n        }\n    }\n    for (int i = 0; i < len + 2; i++)\n    {\n        if (x[Root(i)] % 26 != 0)\n        {\n            puts(\"NO\"), exit(0);\n        }\n    }\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[mid1 - i] - s[mid2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= minr) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            deladd[minr + 1] %= 26;\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+5;\nint lowbit(int x){return x&(-x);}\nint arr[MAXN];\ninline int sum(int x){int res=0;while(x)res+=arr[x],x-=lowbit(x);return res;}\ninline void add(int x,int n){while(x<MAXN)arr[x]+=n,x+=lowbit(x);}\ninline int update(int x,int y,int n){add(x,n);add(y+1,-n);}\nstruct node{\n    int a,b;\n    bool operator < (const node&p)const{\n        return a==p.a ? b > p.b : a > p.a;\n    }\n};\npriority_queue<node> q;\n\nint f[MAXN];\nstring s;\n//char s[MAXN];\nint a[MAXN];\nint main()\n{\n    memset(f,-1,sizeof f);\n    int x,n,l,r;\n    cin>>s;\n    s=\"0\"+s;\n    //scanf(\"%s\",&s+1);\n    int len = s.length();\n\n    //printf(\"%s\\n\",s);\n    //cout<<s<<endl;\n    //cout<<\"len:\"<<len<<endl;\n    for(int i=1;i<=len/2;i++){\n        update(i,i,s[i] - s[len-i]);\n    }\n    cin>>n;\n    int ll = len / 2;\n    //cout<<\"ll: \"<<ll<<endl;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        //cout<<l<<\"|\"<<r<<endl;\n        if(r <= ll)\n            q.push(node{l,r});\n        else if(l <= ll){\n            //l += ll - l + 1;\n            if(l+r == len)continue;\n            if(abs(ll-l)>abs(r-ll))\n            {\n                q.push(node{l,len-r-1});\n            }\n            else\n                q.push(node{len-r,l-1});\n\n            //q.push(node{ll - max(abs(ll-l),abs(ll-r)), ll - min(abs(ll-l),abs(ll-r))});\n        }\n        else{\n            q.push(node{len-r,len-l});\n        }\n    }\n    /*while(!q.empty()){\n        node now = q.top();\n        //qq.push(now);\n        cout<<now.a<<\"-\"<<now.b<<endl;\n        q.pop();\n    }*/\n    node now,pre = q.top();\n    //qq.push(pre);\n    while(!q.empty()){\n        now = q.top();\n        //cout<<now.a<<\" | \"<<now.b<<endl;\n        if(pre.a < now.a){\n            f[pre.a] = pre.b;\n            pre = now;\n            continue;\n        }\n        q.pop();\n        if(pre.b == now.b)continue;\n        else{\n            q.push(node{pre.b+1, now.b});\n        }\n    }\n    f[pre.a] = pre.b;\n    //qq.push(pre);\n    /*while(!qq.empty()){\n        node now = qq.front();\n        qqq.push(now);\n        cout<<now.a<<\" \"<<now.b<<endl;\n        qq.pop();\n    }*/\n    bool flag = 1;\n    if(len%2==0)len--;\n    for(int i=1;i<=len/2;i++){\n\n        //now = qq.front();\n        x = sum(i) - sum(i-1);\n        x%=26;\n        //cout<<\"*\"<<x<<\"  \"<<i<<\" \"<<f[i]<<endl;\n        if(x == 0)continue;\n        if(f[i] != -1){\n            //qq.pop();\n            update(i,f[i], -x);\n        }\n        else{\n            flag = 0;\n            break;\n        }\n        //cout<<\"**\"<<sum(i) - sum(i-1)<<endl;\n    }\n    if(flag)\n        cout<<\"YES\\n\";\n    else\n        cout<<\"NO\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  trace(label);\n  map<int64, int> d;\n  bool found = false;\n  for (int i = 0; i < n / 2; ++i) {\n    int j = n - 1 - i;\n    int diff = (s[j] - s[i] + 26) % 26;\n    int64 u = label[i], v = label[j];\n    trace(i, j, u, v, diff);\n    if (u == v && diff) {\n      found = true;\n      break;\n    }\n    if (!d.count(u) && !d.count(v)) {\n      d[u] = diff;\n      d[v] = 0;\n    } else if (!d.count(u)) {\n      d[u] = (d[v] + diff) % 26;\n    } else if (!d.count(v)) {\n      d[v] = (d[u] + 26 - diff) % 26;\n    } else {\n      if ((d[u] - d[v] + 26) % 26 != diff) {\n        found = true;\n        break;\n      }\n    }\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nset<int> st;\nstring ns = \"\";\nstring s;\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n//\t\t\tcout<<\"OP3 \"<<i<<\" \"<<mini<<\" \"<<maxi - 1<<endl;\n\t\t}\n\t}\n\tn = mid;\n\tms[st] = -1;\n\tint total = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) st.insert(id);\n\t\t\telse st.erase(id);\n\t\t}\n\t\tif(ms.find(st) == ms.end()) ms[st] = i;\n\t\tpar[i] = ms[st];\n//\t\tcout<<\"CHECKPAR \"<<i<<\" \"<<par[i]<<endl;\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') bisa = false;\n\t\tint x = find(i);\n//\t\tcout<<\"PRINT \"<<i<<\" \"<<par[i]<<\" \"<<x<<endl;\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DBP\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define deb(...) 0\n#endif\n#define fst first\n#define snd second\n#define fore(x,a,b) for(int x=(a), qwerty=(b); x<qwerty; x++)\n#define pb push_back\n#define mset(a,v) memset((a),(v),sizeof(a))\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(a) int((a).size())\n#define FIN ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e5+5;\nstring s;\nint n,m,A[N],B[N],P[N],sum[N];\n\nint find(int u){return u==P[u]?u:P[u]=find(P[u]);}\nvoid join(int i, int j){\n    int x=find(i), y=find(j);\n    if(x!=y){\n        sum[x] += sum[y];\n        P[y] = x;\n    } \n}\n\nint main(){FIN;\n    cin >> s >> m;n=SZ(s);\n    fore(x,0,n)A[x+1]=s[x]-'a';\n    fore(x,0,n+1)B[x]=(A[x+1]-A[x]+26)%26;\n    fore(x,0,n+1)P[x]=x,sum[x]=B[x];\n    fore(x,0,n+1)join(x,n-x);\n    fore(x,0,m){\n        int a,b;cin>>a>>b;a--;\n        join(a,b);\n    }\n    bool can = 1;\n    fore(x,0,n+1)if(find(x)==x)can &= sum[x]%26 == 0;\n    cout << (can ? \"YES\":\"NO\")<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k + 1) R[i]--;\n\t\tif(L[i] >= k + 1) L[i]--;\n\t\tif(L[i] == k && R[i] == k) L[i] = 1, R[i] = str.size();\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring S; int Q, L[100009], R[100009], c[100009], d[100009]; bool used[100009];\nint main() {\n\tcin >> S >> Q;\n\tfor (int i = 0; i < (int)S.size() / 2; i++) {\n\t\tc[i] = (S[i] - S[S.size() - 1 - i] + 26) % 26;\n\t}\n\tint mid = S.size() / 2;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> L[i] >> R[i]; L[i]--; R[i]--; d[L[i]]++; d[R[i] + 1]--;\n\t\tint F1 = L[i], F2 = R[i] + 1;\n\t\tif (F1 >= mid)F1 = (S.size() - 0) - L[i];\n\t\tif (F2 >= mid)F2 = (S.size() - 1) - R[i];\n\t\tused[F1] = true; used[F2] = true;\n\t}\n\tfor (int i = 1; i < S.size(); i++)d[i] += d[i - 1];\n\tfor (int i = 0; i < mid; i++) {\n\t\tif (d[i] == 0 && d[S.size() - 1] == 0 && c[i] == 0) { cout << \"NO\" << endl; return 0; }\n\t}\n\tif (S.size() % 2 == 1 && d[mid] == 0) { cout << \"NO\" << endl; return 0; }\n\tfor (int i = 0; i < mid - 1; i++) {\n\t\tif (c[i] != c[i + 1] && used[i + 1] == false) { cout << \"NO\" << endl; return 0; }\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\tini[nuevo.first].insert(nuevo.second);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = ini[i].size();\n\t\tauto it = ini[i].begin();\n\t\tif(sz == 1){\n\t\t\tfin[*it].insert(i);\n\t\t}else if(sz > 1){\n\t\t\tLong ant = i;\n\t\t\twhile(it != ini[i].end()){\n\t\t\t\tfin[*it].insert(ant);\n\t\t\t\tant = *it + 1;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<Long,Long> > rangos;\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = fin[i].size();\n\t\tauto it = fin[i].begin();\n\t\tif(sz == 1){\n\t\t\trangos.push_back({*it,i});\n\t\t}else if(sz > 1){\n\t\t\tLong ant = *it;\n\t\t\twhile(it != fin[i].end()){\n\t\t\t\tit++;\n\t\t\t\tif(it == fin[i].end()){\n\t\t\t\t\trangos.push_back({ant,i});\n\t\t\t\t}else{\n\t\t\t\t\trangos.push_back({ant,*it-1});\n\t\t\t\t\tant = *it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n//asdas\n\tcout << \"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree;\n  vector<vector<int>> list;\n\npublic:\n  UnionFind(int v) {\n    tree.resize(v);\n    list.resize(v);\n    REP(i,v) tree[i] = i, list[i].push_back(i);\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return list[root(i)].size();\n  }\n\n  vector<int> nodes(int no){\n    return list[root(no)];\n  }\n\n  bool unit(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x==y) return false;\n    if(list[x].size() < list[y].size()) swap(x,y);\n    for(int no:list[y]) list[x].emplace_back(no);\n    tree[y] = x;\n    return true;\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  string s;\n  int m;\n  cin >> s >> m;\n\n  int n = s.size();\n  UnionFind uf(n+1);\n  REP(_,m){\n    int l,r;\n    cin >> l >> r;\n    l--; r--;\n    uf.unit(l,r+1);\n  }\n\n  vec a; a.push_back(s[0]-'a');\n  REP(i,n-1) a.push_back((s[i+1]-s[i]+26)%26);\n  a.push_back((26-(s.back()-'a'))%26);\n\n  // REP(i,n+1) cout << a[i] << \" \";\n  // cout << endl;\n\n  REP(i,n+1) uf.unit(i,n-i);\n  bool flag = true;\n  map<int,int> mp;\n  REP(i,n+1) mp[uf.root(i)] += a[i];\n\n  ITR(itr,mp) if(itr->sc%26) flag = false;\n\n  if(flag) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k + 1) R[i]--;\n\t\tif(L[i] >= k + 1) L[i]--;\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (y != f[y]) {\n    f[x] = find(y);\n    d[x] = (d[y] + d[x]) % 26;\n  }\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return d[y] == (diff + d[x]) % 26;\n  f[ry] = rx;\n  d[ry] = (d[x] + diff - d[y] + 26) % 26;\n  return true;\n}\n\nint main() {\n  srand(time(0));\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[i] + 26 - s[n - 1 - i]) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int u = label[i];\n    find(u);\n    trace(i, u, d[u], (s[i] - 'a' + d[u]) % 26);\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <list>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define LL long long\nusing namespace std;\n\nstring s;\nint val[100005],n,N;\nint pre[100005] = {0},add;\nint m,tmp;\n\nstruct node{\n\tint l,r;\n}q[100005];\n\nbool cmp(node x,node y){\n\tif(x.l == y.l) return x.r < y.r;\n\treturn x.l < y.l;\n}\n\ninline string judge(){\n\tfor(register int i = 1;i <= n;i ++){\n\t\tif(val[i] != val[n + 1 - i]) return \"NO\";\n\t}\n\treturn \"YES\";\n}\n\nint main(){\n\tcin >> s; n = s.length();\n\tfor(register int i = 1;i <= n;i ++) val[i] = s[i - 1] - 'a';\n\tcin >> m;\n\tN = ((n & 1) ? ((n >> 1) + 1) : (n >> 1));\n\tfor(register int i = 1;i <= m;i ++){\n\t\tcin >> q[i].l >> q[i].r;\n\t\tif((q[i].l > N) && (q[i].r > N)){\n\t\t\tq[i].l = n + 1 - q[i].l;\n\t\t\tq[i].r = n + 1 - q[i].r;\n\t\t\tswap(q[i].l,q[i].r);\n\t\t}\n\t\telse if(q[i].r > N){\n\t\t\tq[i].l --;\n\t\t\tq[i].r = n + 1 - q[i].r;\n\t\t\tswap(q[i].l,q[i].r);\n\t\t}\n\t}\n\tsort(q + 1,q + 1 + m,cmp);\n\ttmp = q[1].l;\n\tfor(register int i = 2;i <= m;i ++){\n\t\tif(q[i].l == tmp) q[i].l = q[i - 1].r + 1;\n\t\telse tmp = q[i].l;\n\t}\n\tsort(q + 1,q + 1 + m,cmp);\n\t/*\n\tfor(register int i = 1;i <= m;i ++){\n\t\tcout << q[i].l << ' ' << q[i].r << endl;\n\t}\n\t*/\n\tq[0].l = q[1].l;\n\tadd = 0;\n\tfor(register int i = 1;i <= m;i ++){\n\t\tif(q[i].l > q[i].r) continue;\n\t\tadd += pre[q[i].l];\n\t\tfor(register int j = q[i - 1].l + 1;j <= q[i].l;j ++){\n\t\t\tval[j] += add; val[j] = (val[j] + 26) % 26;\n\t\t}\n\t\tif(val[q[i].l] == val[n - q[i].l + 1]) continue;\n\t\ttmp = val[n - q[i].l + 1] - val[q[i].l];\n\t\tval[q[i].l] = val[n - q[i].l + 1];\n\t\tadd += tmp;\n\t\tpre[q[i].r + 1] -= tmp;\n\t}\n\tfor(register int i = q[m].l + 1;i <= N;i ++){\n\t\tadd += pre[i];\n\t\tval[i] += add; val[i] = (val[i] + 26) % 26;\n\t}\n\t/*\n\tfor(register int i = 1;i <= n;i ++){\n\t\tcout << val[i] << (i == n ? '\\n' : ' ');\n\t}\n\tfor(register int i = 1;i <= n;i ++){\n\t\tcout << pre[i] << (i == n ? '\\n' : ' ');\n\t}\n\t*/\n\tcout << judge() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\tif(S.size()-1-k <= k)return true;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tvector<P> _vec;\n\trep(i,vec[k].size()){\n\t\tif(vec[k][i].fr == k && vec[k][i].sc == S.size()-1-k){}\n\t\telse _vec.pb(vec[k][i]);\n\t}\n\tvec[k] = _vec;\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n//S[k] += d;\n//if(S[k] > 'z')S[k] -= 26;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n//S[S.size()-1-k] += d;\n//if(S[S.size()-1-k] > 'z')S[S.size()-1-k] -= 26;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 > S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tvec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n\t\n\t//cout << S << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 100100;\nstring z;\nint m;\nint f[MAX],il[MAX];\nconst int alfa = 'z' - 'a' + 1;\nvoid pol(int& a){\n  a = min(a, SZ(z) - a);\n}\nint find(int a){\n  return f[a] == a ? a : f[a] = find(f[a]);\n}\nvoid uni(int a,int b){\n  a = find(a);\n  b = find(b);\n  if(a == b)return;\n  f[a] = b;\n  il[b] += il[a];\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> z;\n  R(i,SZ(z)/2 + 1){\n    f[i] = i;\n    if(i){\n      if(i * 2 == SZ(z)){\n        il[i] = z[i] - z[i-1];\n        debug(il[i]);\n      }else\n        il[i] = (z[i] - z[i-1]) - (z[SZ(z) - i - 1] - z[SZ(z) - i]);\n    }\n    debug(i,il[i]);\n  }\n  cin >> m;\n  R(i,m){\n    int l,r;\n    cin >> l >> r;\n    l--;\n    pol(l);\n    pol(r);\n    debug(l,r);\n    uni(r,l);\n  }\n  R(i,SZ(z)/2 + 1){\n    if(f[i] == i){\n      if(il[i] % alfa != 0 && find(0) != i){\n        cout << \"NO\\n\";\n        return 0;\n      }\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nchar s[MAXN];\nint a[MAXN],N,M;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE,sum;\nbool vis[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    scanf(\"%s\",s + 1);\n    N = strlen(s + 1);\n    s[0] = 'a';s[N + 1] = 'a';\n    for(int i = 1 ; i <= N + 1; ++i) a[i] = (s[i] - s[i - 1] + 26) % 26;\n    read(M);\n    int L,R;\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(L);read(R);\n\tadd(L,R + 1);add(R + 1,L);\n    }\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n\tadd(i,N + 2 - i);\n    }\n}\nvoid dfs(int u) {\n    vis[u] = 1;\n    sum = (sum + a[u]) % 26;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!vis[v]) {\n\t    dfs(v);\n\t}\n    }\n}\nvoid Solve() {\n    bool flag = 1;\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n\tif(!vis[i]) {\n\t    sum = 0;\n\t    dfs(i);\n\t    if(sum != 0) {flag = 0;break;} \n\t}\n    }\n    if(flag) puts(\"YES\");\n    else puts(\"NO\");\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s; cin >> s;\n    int m = s.size();\n    int n; cin >> n;\n    vector<int> l(n), r(n);\n    vector<vector<int>> sg(m);\n    for (int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n        --l[i], --r[i];\n        if (m % 2 == 0) {\n            if (l[i] < m / 2 && r[i] >= m / 2) {\n                int g = min(m / 2 - l[i], r[i] - m / 2 + 1);\n                int tl = m / 2 - g, tr = m / 2 + g - 1;\n                if (tl == l[i] && tr == r[i]) continue;\n                if (tl == l[i]) l[i] = tr + 1;\n                else r[i] = tl - 1;\n            }\n        } else {\n            if (l[i] <= m / 2 && r[i] >= m / 2) {\n                int g = min(m / 2 - l[i], r[i] - m / 2);\n                int tl = m / 2 - g, tr = m / 2 + g;\n                if (tl == l[i] && tr == r[i]) continue;\n                if (tl == l[i]) l[i] = tr + 1;\n                else r[i] = tl - 1;\n            }\n        }\n        if (r[i] < m / 2) sg[l[i]].push_back(r[i]);\n        else sg[m - 1 - r[i]].push_back(m - 1 - l[i]);\n    }\n    for (int i = 0; i < m / 2; ++i) {\n        if (sg[i].empty()) continue;\n        sort(sg[i].begin(), sg[i].end());\n        sg[i].resize(unique(sg[i].begin(), sg[i].end()) - sg[i].begin());\n        int r = sg[i][0];\n        for (int j = i + 1; j < sg[i].size(); ++j) sg[r + 1].push_back(sg[i][j]);\n        sg[i].resize(1);\n    }\n    vector<int> t(m + 1);\n    int sum = 0;\n    for (int i = 0; i < m / 2; ++i) {\n        sum += t[i];\n        int ch = ((((s[i] - 'a') + sum) % 26) + 26) % 26;\n        int diff = ((s[m - 1 - i] - 'a') - ch + 26) % 26;\n        // printf(\"i = %d diff = %d\\n\", i, diff);\n        if (diff != 0 && sg[i].empty()) {\n            puts(\"NO\");\n            return 0;\n        }\n        if (diff != 0) {\n            sum += diff;\n            t[sg[i][0] + 1] += 26 - diff;\n        }\n    }\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nconst ll INF = LLONG_MAX / 2;\nconst int MOD = 1e9 + 7;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tstring s; cin >> s;\n\tint N = s.length();\n\ts = \"a\" + s + \"a\";\n\tint M; cin >> M;\n\tunion_find uf(N + 2);\n\twhile (M--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r), r++;\n\t\tuf.unite(l, r);\n\t\t// cout << l << ' ' << r << endl;\n\t}\n\t/*\n\tfor (int i = 1; i <= N + 1; i++) {\n\t\tuf.unite(i, N + 2 - i);\n\t\tcout << i << ' ' << N + 2 - i << endl;\n\t}\n\t*/\n\tvector<int> a(N + 2);\n\tfor (int i = 1; i <= N + 1; i++) {\n\t\tuf.unite(i, N + 2 - i);\n\t\tchar c = s[i - 1], d = s[i];\n\t\tint j = uf.find(i);\n\t\ta[j] += c - d;\n\t\tc = s[N + 2 - i - 1], d = s[N + 2 - i];\n\t\ta[j] += c - d;\n\t}\n\trep(i, N + 2) if (a[i] % 26) {\n\t\tcout << \"NO\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nchar S[100011];\nint L[100011], R[100011];\nint La[100011], Ra[100011];\nint D[100011];\nVI G[100011];\n\nvoid MAIN() {\n    scanf(\"%s%d\", S, &N);\n    int LEN = strlen(S);\n    REP (i, N) scanf(\"%d%d\", L+i, R+i), L[i]--;\n\n    int M = LEN/2;\n    REP (i, LEN-1) {\n\tint d = (int)S[i+1] - (int)S[i];\n\tif (i*2+2 == LEN) {\n\t    D[i] += d+d;\n\t} else if (i >= M) {\n\t    D[LEN-2-i] += d;\n\t} else {\n\t    D[i] += d;\n\t}\n    }\n\n    REP (i, N) {\n\tL[i]--;\n\tLa[i] = 1;\n\n\tR[i]--;\n\tRa[i] = -1;\n\n\tif (M <= L[i]) {\n\t    L[i] = LEN-2-L[i];\n\t    La[i] = -La[i];\n\t}\n\tif (L[i]*2+2 == LEN) La[i] += La[i];\n\n\tif (M <= R[i]) {\n\t    R[i] = LEN-2-R[i];\n\t    Ra[i] = -Ra[i];\n\t}\n\tif (R[i]*2+2 == LEN) Ra[i] += Ra[i];\n\n\tif (L[i] > R[i]) {\n\t    swap(L[i], R[i]);\n\t    swap(La[i], Ra[i]);\n\t}\n\tif (R[i] >= 0) G[R[i]].push_back(i);\n    }\n\n    for (int t=M; t--;) {\n\tD[t] %= 26;\n\tEACH (e, G[t]) {\n\t    assert(R[*e] == t);\n\t    int m = D[t] / Ra[*e];\n\t    D[t] -= Ra[*e] * m;\n\t    if (0 <= L[*e]) D[L[*e]] -= La[*e] * m;\n\t}\n\tif (D[t]) {\n\t    puts(\"NO\");\n\t    return;\n\t}\n\n\tif (G[t].size() >= 2u) {\n\t    int idx = 0;\n\t    for (int i=1; i<(int)G[t].size(); i++) {\n\t\tif (L[G[t][idx]] > L[G[t][i]]) idx = i;\n\t    }\n\t    REP (i_, G[t].size()) if (i_ != idx) {\n\t\tint i = G[t][i_];\n\t\tint j = G[t][idx];\n\t\tint m = Ra[i] / Ra[j];\n\t\tassert(Ra[i] * m == Ra[j]);\n\n\t\tR[i] = L[j];\n\t\tRa[i] = La[j];\n\t\tLa[i] *= -m;\n\t\tif (L[i] > R[i]) {\n\t\t    swap(L[i], R[i]);\n\t\t    swap(La[i], Ra[i]);\n\t\t}\n\t\tif (0 <= R[i] && R[i] < t) G[R[i]].push_back(i);\n\t    }\n\t}\n    }\n\n    puts(\"YES\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nusing ld = long double;\nll INF = LLONG_MAX;\n\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid print() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); \n\t}\n}\n\nusing namespace output;\n\ntemplate<class T> struct Seg { \n\tconst T ID = 0; // comb(ID,b) must equal b\n\tT combine(T a, T b) { return (a+b)%26;} \n\tint n; vector<T> seg;\n\tvoid init(int _n) { n = _n; seg.assign(2*n,ID);}\n\n\tvoid update(int p, T value) {\t// set value at position p\n\t\tseg[p += n] += value;\n\t\tfor (p /= 2; p; p /= 2) seg[p] = combine(seg[2*p], seg[2*p+1]);\n\t}\n    \n\tT query(int l, int r) {\t // sum on interval [l, r]\n\t\tT ra = ID, rb = ID; \n\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {\n\t\t\tif (l&1) ra = combine(ra,seg[l++]);\n\t\t\tif (r&1) rb = combine(seg[--r],rb);\n\t\t}\n\t\treturn combine(ra,rb);\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring S; cin >> S;\n\tint N; cin >> N;\n\tvector<vi> startsAt (S.size()+1);\n\tvector<vi> endsAt (S.size()+1);\n\tF0R(i, N) {\n\t\tint l, r; cin >> l >> r; --l; --r;\n\t\tstartsAt[l].push_back(r+1); // orig\n\t\tif (l+1 < S.size()-r) {\n\t\t\tstartsAt[r+1].push_back(S.size()-l);\n\t\t} else {\n\t\t\tstartsAt[S.size()-r-1].push_back(l);\n\t\t}\n\t}\n\n\tF0R(i, S.size()+1) {\n\t\tsort(startsAt[i].begin(), startsAt[i].end());\n\t\tfor (int j = 1; j < startsAt[i].size(); ++j) {\n\t\t\tif (startsAt[i][j] != startsAt[i][j-1]) startsAt[startsAt[i][j-1]].push_back(startsAt[i][j]);\n\t\t}\n\t\tif (startsAt[i].size()) startsAt[i] = vi {startsAt[i][0]};\n\t\tfor (int j : startsAt[i]) endsAt[j].push_back(i);\n\t}\n\n\tstartsAt.assign(S.size() + 1, vi {});\n\n\tR0F(i, S.size()+1) {\n\t\tsort(endsAt[i].begin(), endsAt[i].end());\n\t\tfor (int j = 0; j+1 < endsAt[i].size(); ++j) {\n\t\t\tif (endsAt[i][j] != endsAt[i][j+1]) endsAt[endsAt[i][j+1]].push_back(endsAt[i][j]);\n\t\t}\n\t\tif (endsAt[i].size()) endsAt[i] = vi {endsAt[i].back()};\n\t\tfor (int j : endsAt[i]) startsAt[j].push_back(i);\n\t}\n\tSeg<int> seg; seg.init(S.size());\n\tint sum = 0;\n\tF0R(i, S.size()) {\n\t\tseg.update(i, S[i]-'a');\n\t}\n\n\n\tfor (int l = 0; l < S.size() / 2; ++l) {\n\t\tint lc = seg.query(0, l) - ((l != 0) ? seg.query(0, l-1) : 0); lc = (lc + 26) % 26;\n\t\tint rc = seg.query(0, S.size()-l-1) - seg.query(0, S.size()-l-2); rc = (rc + 26) % 26;\n\t\tif (rc != lc) {\n\t\t\tif (startsAt[l].size() && (startsAt[l][0] <= S.size()-l-1)) {\n\t\t\t\tint cycle = (rc - lc + 26) % 26;\n\t\t\t\tseg.update(l, cycle);\n\t\t\t\tseg.update(startsAt[l][0], -cycle);\n\t\t\t} else {\n\t\t\t\tprint(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\n\t}\n\tprint(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N],sum[N],p[N];\nchar s[N];\nvector<int> vct[N];\nint find(int x)\n{\n\treturn !p[x]?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2+1;++i)\n\t\tc[i]=(s[m-i+1]-s[i]+26)%26;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=m/2+1;i>=1;--i)\n\t\tsum[i]=c[i]-=c[i-1];\n\tfor(i=1;i<=m/2;++i)\n\t\tfor(j=vct[i].size()-1;j>=0;--j)\n\t\t\tif(find(i)!=find(vct[i][j]+1))\n\t\t\t{\n\t\t\t\tsum[find(vct[i][j]+1)]+=sum[find(i)];\n\t\t\t\tp[find(i)]=find(vct[i][j]+1);\n\t\t\t}\n\tfor(i=1;i<=m/2+1;++i)\n\t\tif(find(i)==i&&sum[i])\n\t\t{\n\t\t\tprintf(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int MAXN = 100005;\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nstring s;\nint q;\nvector<int> pos[MAXN];\nint nxt[MAXN], dx[MAXN];\n\nint main(){\n\tcin >> s >> q;\n\tint n = s.size();\n\tint h = (n - 1) / 2;\n\tdisj.init(h);\n\tfor(int i=0; i<q; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tif(s + e > n) tie(s, e) = pi(n+1-e, n+1-s);\n\t\tif(e > n - e) e = n - e;\n\t\tdisj.uni(s - 1, e);\n\t}\n\tfor(int i=0; i<=h; i++){\n\t//\tprintf(\"%d %d\\n\", disj.find(i), i);\n\t\tpos[disj.find(i)].push_back(i);\n\t}\n\tmemset(nxt, -1, sizeof(nxt));\n\tfor(int i=0; i<=h; i++){\n\t\tif(pos[i].size() > 1){\n\t\t\tfor(int j=1; j<pos[i].size(); j++){\n\t\t\t\tnxt[pos[i][j-1]] = pos[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=h; i++){\n\t\tdx[i] = s[i] - s[n-1-i];\n\t\tdx[i] += 26;\n\t\tdx[i] %= 26;\n\t}\n\tfor(int i=0; i<h; i++){\n\t\tif(nxt[i] != -1){\n\t\t\tdx[nxt[i]] += dx[i];\n\t\t\tdx[nxt[i]] %= 26;\n\t\t\tdx[i] = 0;\n\t\t}\n\t\tdx[i] %= 26;\n\t\tif(dx[i]){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nchar in[110000];\nint L[110000];\nint R[110000];\nint segtree[262144];\nvoid add(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return ;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]=(segtree[e]+f)%26;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2,f);\n\tadd((a+b)/2+1,b,c,d,e*2+1,f);\n}\nint sum(int a){\n\ta+=131072;\n\tint ret=0;\n\twhile(a){\n\t\tret+=segtree[a];\n\t\ta/=2;\n\t}\n\treturn ret%26;\n}\nset<int>g[110000];\nint ptr[110000];\nint see[110000];\nint main(){\n\tscanf(\"%s\",in);\n\tint n=strlen(in);\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",L+i,R+i);\n\t\tL[i]--;\n\t}\n\tint N=n/2;\n\tfor(int i=0;i<N;i++){\n\t\tint t=in[i]+26-in[n-1-i];\n\t\tif(t>=26)t-=26;\n\t\tadd(0,131071,i,i,1,t);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(R[i]<=N){\n\t\t\tif(L[i]!=R[i])\n\t\t\tg[L[i]].insert(R[i]);\n\t\t}else if(L[i]>=N){\n\t\t\tif(n-R[i]!=n-L[i])\n\t\t\tg[n-R[i]].insert(n-L[i]);\n\t\t}else{\n\t\t\tint pl=L[i];\n\t\t\tint pr=n-R[i];\n\t\t\tif(pl>pr)swap(pl,pr);\n\t\t\tif(pl<pr)\n\t\t\tg[pl].insert(pr);\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)ptr[i]=i;\n\t//for(int i=0;i<N;i++)std::sort(g[i].begin(),g[i].end());\n\tfor(int i=0;i<N;i++)see[i]=i;\n\tfor(int i=0;i<N;i++){\n\t\tint I=see[i];\n\t\tif(!g[see[i]].empty()){\n\t\t\tint fi=*(g[see[i]].begin());\n\t\t\tint now=sum(i);\n\t\t\tint ad=26-now;\n\t\t\tadd(0,131071,i,fi-1,1,ad);\n\t\t\tg[I].erase(fi);\n\t\t\tif(g[I].size()<g[see[fi]].size()){\n\t\t\t\tfor(set<int>::iterator it=g[I].begin();it!=g[I].end();it++){\n\t\t\t\t\tg[see[fi]].insert(*it);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(set<int>::iterator it=g[see[fi]].begin();it!=g[see[fi]].end();it++){\n\t\t\t\t\tg[I].insert(*it);\n\t\t\t\t}\n\t\t\t\tsee[fi]=I;\n\t\t\t}\n\t\t}\n\t\tif(sum(i)){\n\t\t\tprintf(\"NO\\n\");return 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\n\nint a[MAXN];\n\nvoid change(int L, int R, int v) {\n    a[L] += v;\n    a[R + 1] -= v;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    int M = (n + 1) / 2;\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            //cout << \"c1\";\n            x = n - x + 1;\n            y = n - y + 1;\n            std::swap(x, y);\n        }\n        if (x <=mm && y >mm) {\n            //cout<<\"c2\";\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        // cout << x << ' ' << y;\n        if (x > y) continue;\n        ls.emplace_back(x, y);\n    }\n    m = ls.size();\n    std::sort(begin(ls), end(ls));\n    int j = 0, val = 0;\n    for (int i = 1; i + i <= n; ++i) {\n        val = (val + a[i]) % 26;\n        val = (val + 26) % 26;\n        while (j < m && ls[j].fi < i) j++;\n        if (j < m && ls[j].fi == i) {\n            change(ls[j].fi, ls[j].se, -val);\n            val = 0;\n            //j++;\n        }\n        if (val != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint n,q,l,r,pset[100007];\nint it[400007];\nset <int> query[100007];\nvoid upd(int k,int l,int r,int L,int R,int val){\n\tif(l>R || r<L || L>R) return;\n\tif(l>=L && r<=R){\n\t\tit[k]+=val;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tupd(k*2,l,mid,L,R,val);\n\tupd(k*2+1,mid+1,r,L,R,val);\n}\nint get(int k,int l,int r,int pos){\n\tif(l==r && l==pos) return it[k];\n\tint mid=(l+r)/2;\n\tif(pos<=mid) return it[k]+get(k*2,l,mid,pos);\n\telse return it[k]+get(k*2+1,mid+1,r,pos);\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>s;\n\tn=(int)s.length();\n\tcin>>q;\n\tfor(int i=1;i<=q;i++){\n\t\tcin>>l>>r;\n\t\tif(l<=(n+1)/2 && r>=(n+1)/2){\n\t\t\tr=n-r+1;\n\t\t\tif(l>r) swap(l,r);\n\t\t\tif(l==r) continue;\n\t\t\tr--;\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse if(l<=(n+1)/2){\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse{\n\t\t\tquery[n-r+1].insert(n-l+1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) pset[i]=i;\n\tfor(int i=1;i<=n/2;i++){\n\t\t//cout<<(s[i-1]-s[n-i]+26)%26<<endl;\n\t\tint cal=((s[i-1]-s[n-i]+26)%26-get(1,1,n,i)+26)%26;\n\t\t//cout<<i<<\" \"<<cal<<endl;\n\t\tif(cal!=0 && query[pset[i]].empty()){\n\t\t\tcout<<\"NO\";\n\t\t\treturn 0;\n\t\t}\n\t\telse if(i==n/2) continue;\n\t\telse{\n\t\t\tint cur=pset[i];\n\t\t\tauto it=query[cur].begin();\n\t\t\tquery[cur].erase(it);\n\t\t\tupd(1,1,n,i,*it,cal);\n\t\t\tint nxt=pset[*it+1];\n\t\t\tif(query[cur].size()<query[nxt].size()){\n\t\t\t\tpset[cur]=nxt;\n\t\t\t\tfor(auto jt=query[cur].begin();jt!=query[cur].end();jt++){\n\t\t\t\t\tquery[nxt].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpset[nxt]=cur;\n\t\t\t\tfor(auto jt=query[nxt].begin();jt!=query[nxt].end();jt++){\n\t\t\t\t\tquery[cur].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=1e5+5;\nchar s[N];int fa[N],b[N],sum[N],vis[N],n,m;\ninline int val(R int x){return x<0?x+26:x;}\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfp(i,1,n+1)s[i]-='a',fa[i]=i;\n\ts[n+1]=0;\n\tscanf(\"%d\",&m);\n\tfor(R int i=1,l,r;i<=m;++i)scanf(\"%d%d\",&l,&r),fa[find(r+1)]=find(l);\n\tfp(i,1,n+1)b[i]=val(s[i]-s[i-1]);\n\tfp(i,1,(n+1)>>1)fa[find(n+2-i)]=find(i);\n\tfp(i,1,n+1)sum[find(i)]+=b[i];\n\tif((n+1)&1)vis[find((n+2)>>1)]=1;\n\tfp(i,1,n+1)if(i==find(i)&&sum[i]%26)\n\t\tif(!vis[i])return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n \n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n \nconst int maxn = 100005;\n \nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n \n \nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n \nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            tie(l, r) = make_pair(min(max(-1, mid1 - l), max(-1, r - mid2)) + 1, max(max(-1, mid1 - l), max(-1, r - mid2)));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n            int minr = *segs[i].begin();\n            segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tint m = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tll dis = (r - m + 1) * 2;\n\t\t\tr -= dis - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\terr.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nint main(){\n  char s[SIZE];\n  int n,m;\n  int l[SIZE],r[SIZE];\n  vector<int> cc[SIZE];\n  \n  scanf(\"%s%d\",s,&m);\n  n = strlen(s);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",l+i,r+i);\n    l[i]--; r[i]--;\n    \n    if(n%2 == 0){\n      if(l[i] <= n/2-1 && n/2 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - (n/2 - 1);\n        \n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if (a > b){\n          l[i] = n/2 - a;\n          r[i] = n/2 - b - 1;\n        }else{\n          l[i] = n/2 - b;\n          r[i] = n/2 - a - 1;\n        }\n      }\n    }else{\n      if(l[i] == r[i] && l[i] == n/2){\n        l[i] = -1; r[i] = -1;\n      }else if(l[i] == n/2){\n        l[i] += 1;\n      }else if(r[i] == n/2){\n        r[i] -= 1;\n      }else if(l[i] <= n/2-1 && n/2+1 <= r[i]){\n        int a = n/2+1 - l[i];\n        int b = r[i] - n/2;\n\n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if(a > b){\n          l[i] = n/2-1 - a;\n          r[i] = n/2-1 - b - 1;\n        }else{\n          l[i] = n/2-1 - b;\n          r[i] = n/2-1 - a - 1;\n        }\n      }\n    }\n\n    if(l[i] != -1){\n      if((n+1)/2 <= l[i]){\n        l[i] = n - l[i] - 1;\n        r[i] = n - r[i] - 1;\n        swap(l[i], r[i]);\n      }\n      \n      cc[l[i]].push_back(r[i]);\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    if(cc[i].size() > 1)\n      sort(cc[i].begin(),cc[i].end());\n\n    for(int j=cc[i].size()-2;j>=0;j--){\n      if(cc[i][j] != cc[i][j+1])\n        cc[cc[i][j]+1].push_back(cc[i][j+1]);\n    }\n  }\n\n  SegTree seg(n);\n  \n  for(int i=0;i<n/2;i++){\n    seg.add(i, i, 26 + s[n-i-1] - s[i]);\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size()){\n      int q = seg.query(i,i);\n      seg.add(i, cc[i][0], 26-q%26);\n    }\n\n    if(seg.query(i,i)%26){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n\n  puts(\"YES\");\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef _DEBUG\n#ifdef _DEBUG\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\nconst ll MOD=1e9+7;\n\nstruct UF{\n  vector<int> data;\n  UF(int size):data(size,-1){}\n  bool unite(int x,int y){\n    x=root(x); y=root(y);\n    if(x!=y){\n      if(data[y]<data[x]) swap(x,y);\n      data[x]+=data[y]; data[y]=x;\n    }\n    return x!=y;\n  }\n  bool findSet(int x,int y){return root(x)==root(y);}\n  int root(int x){return data[x]<0?x:data[x]=root(data[x]);}\n  int size(int x) {return -data[root(x)];}\n};\nclass Bcc{\n  vector<int> num,inS;\n  stack<int> roots,st;\n  int cnt;\npublic:\n  vv<int> bcc,tree,tedge;\n  vector<int> brdg,inv;\n  void dfs(const vv<int> &g,const vector<pii> &es,int v,int e){\n    num[v]=++cnt;\n    st.push(v); inS[v]=1; roots.push(v);\n    for(const int &i:g[v])if(i!=e){\n\t\t\t\tint w=es[i].X+es[i].Y-v;\n\t\t\t\tif(!num[w]){\n\t\t\t\t\tdfs(g,es,w,i);\n\t\t\t\t}else if(inS[w]){\n\t\t\t\t\twhile(num[roots.top()]>num[w]) roots.pop();\n\t\t\t\t}\n      }\n    if(v==roots.top()){\n      brdg.pb(e);\n      bcc.pb(vector<int>());\n      while(1){\n\t\t\t\tint w=st.top(); st.pop(); inS[w]=0;\n\t\t\t\tbcc.back().pb(w);\n\t\t\t\tif(v==w) break;\n      }\n      roots.pop();\n    }\n  }\n  \n  Bcc(vv<int> &g,vector<pii> es){\n    const int n=g.size();\n    num.resize(n); inS.resize(n);\n    int cnt=0;\n    rep(i,n)if(!num[i]){\n      dfs(g,es,i,-1);\n      brdg.pop_back();\n    }\n    const int m=bcc.size();\n    inv.resize(n);\n    rep(i,m) for(const int &v:bcc[i]) inv[v]=i;\n    for(pii &p:es){p.X=inv[p.X]; p.Y=inv[p.Y];}\n    //sort(all(es)); UNIQUE(es);\n    tree.resize(m); tedge.resize(m);\n    int i=0;\n    for(const pii &p:es){\n      if(p.X!=p.Y){\n\t\t\t\ttree[p.X].pb(p.Y);\n\t\t\t\ttree[p.Y].pb(p.X);\n\t\t\t\ttedge[p.X].pb(i);\n\t\t\t\ttedge[p.Y].pb(i);\n      }\n      ++i;\n    }\n  }\n};\n\nvoid no(){\n\tcout<<\"NO\"<<endl;\n\texit(0);\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tstring s;\n\tcin>>s;\n\tint n=s.size()+1;\n\tvector<int> a(n);\n\trep(i,n-2) a[i+1]=(s[i+1]-s[i]+260)%26;;\n\ta[0]=s[0]-'a';\n\ta[n-1]=-(s.back()-'a');\n\tout(a,1);\n\tint m;\n\tcin>>m;\n\tvector<pii> es(m);\n\trep(i,m){\n\t\tint x,y;\n\t\tcin>>x>>y; --x;\n\t\tes[i]=pii(x,y);\n\t}\n\tUF uf(n);\n\tfor(pii p:es) uf.unite(p.X,p.Y);\n\trep(i,n) uf.unite(i,n-1-i);\n\tvector<int> ws(n);\n\trep(i,n) (ws[uf.root(i)]+=a[i])%=26;\n\trep(i,n)if(ws[i]%26) no();\n\tcout<<\"YES\"<<endl;\n\treturn 0;\n\tout(ws,1);\n\n\tvv<int> g(n);\n\tvector<pii> E;\n\trep(i,n){\n\t\tint j=n-1-i;\n\t\tif(i>=j) break;\n\t\tint v=uf.root(i);\n\t\tint w=uf.root(j);\n\t\tif(v>w) swap(v,w);\n\t\tif(v!=w) E.eb(v,w);\n\t}\n\tsort(all(E)); UNIQUE(E);\n\trep(i,E.size()){\n\t\tg[E[i].X].pb(i);\n\t\tg[E[i].Y].pb(i);\n\t}\n\tout(E,g,1);\n\tBcc h(g,E);\n\tvector<int> W(n);\n\trep(i,h.bcc.size()){\n\t\tauto v=h.bcc[i];\n\t\tint s=0;\n\t\tfor(auto x:v) s+=ws[x];\n\t\tW[i]=s;\n\t}\n\tint N=h.tree.size();\n\tout(W,h.tree,1);\n\tvector<int> vst(N);\n\tfunction<int(int,int)> dfs=[&](int v,int p){\n\t\tvst[v]=1;\n\t\tint s=0;\n\t\tfor(int w:g[v])if(w!=p) s+=dfs(w,v);\n\t\treturn (W[v]+s%26)%26;\n\t};\n\trep(i,N)if(!vst[i]){\n\t\tauto t=dfs(i,-1);\n\t\tout(i,t,1);\n\t\tif(t%26) no();\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 100005;\nchar s[N];\nint d[N];\n\n\nint main(){\n\tscanf(\"%s\", s + 1);\n\tint q; sd(q);\n\tint n= strlen(s + 1);\n\tint mid = n / 2;\n\tfor(int i = 1; i <= mid; i++) d[i] = (s[i] - s[n + 1 - i] + 26) % 26;\n\tvector<vector<int>> events(n + 1);\n\tfor(int i = 1; i <= q; i++){\n\t\tint l, r; sd(l); sd(r);\n\t\tif(n % 2 == 1 && l == mid + 1 && r == mid + 1) continue;\n\t\tif(n % 2 == 1 && l == mid + 1 &&r != mid + 1){\n\t\t\tevents[n + 1 - r].push_back(1);\n\t\t\tevents[mid + 1].push_back(-1);\n\t\t\tcontinue;\n\t\t}\n\t\tif(n % 2 == 1 && r == mid + 1 && l != mid + 1){\n\t\t\tevents[l].push_back(1);\n\t\t\tevents[mid + 1].push_back(-1);\n\t\t\tcontinue;\n\t\t}\n\t\tint a = l > mid, b = r > mid;\n\t\tint vl = a ? n + 1 - l : l;\n\t\tint vr = b ? n + 1 - r : r;\n\n\t\tif(!a && !b){\n\t\t\tevents[vl].push_back(1);\n\t\t\tevents[vr + 1].push_back(-1);\n\t\t}\n\n\t\tif(!a && b){\n\t\t\t// [vl ... mid] U [vr ... mid]\n\t\t\tif(vl > vr) swap(vl, vr);\n\t\t\tevents[vl].push_back(1);\n\t\t\tevents[vr].push_back(-1);\n\t\t}\n\t\tif(a){\n\t\t\tevents[vr].push_back(1);\n\t\t\tevents[vl + 1].push_back(-1);\n\t\t}\n\t}\n\tint curr = 0, lst = 0;\n\tfor(int i = 1; i <= mid + 1; i++){\n\t\tif(!events[i].empty()){\n\t\t\tif(lst + 1 != i){\n\t\t\tset<int> st;\n\t\t\tfor(int j = lst + 1; j < i; j++) st.insert(d[j]);\n\t\t\tif(st.size() > 1 || (curr == 0 && *st.begin() != 0)){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}}\n\t\t\tlst = i - 1;\n\t\t}\n\t\tfor(auto it : events[i]) curr += it;\t\n\t}\n\tfor(int j = lst + 1; j <= mid; j++) if(d[j] != 0){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n\nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=n/2+1) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==1 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\t//printf(\"%d %d %d\\n\",i,a[i].l,a[i].r);\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\t//printf(\"%d\\n\",fa[5]);\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\t//printf(\"%d %d\\n\",head[i],d[i]);\n\t\tif (head[i]==0&&d[i]) {puts(\"NO\");return 0;}\n\t\tif (!head[i]) continue;\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;//printf(\"%d\\n\",find(5));\n\t\tfa[i+m0*2+1]=x+m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(L[i] == k + 1 && R[i] == k + 1){\n\t\t\tL[i] = 1;\n\t\t\tR[i] = k * 2;\n\t\t}else if(R[i] <= k){\n\t\t\t//\n\t\t}else if(L[i] <= k){\n\t\t\tR[i]--;\n\t\t}else{\n\t\t\tL[i]--;\n\t\t\tR[i]--;\n\t\t}\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstring s;\nint q;\nvector<int>edge[100005];\nbool ok[100005],okA[100005],okB[100005];\nstruct UF{\n\tint par[100005],ran[100005];\n\tvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\n\tint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y); if(x==y) return;\n\t\tif(ran[x] < ran[y]) par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y){ return find(x)==find(y); }\n}A,B;\nint cmp[100005];\nint num[100005];\nint ax[100005],bx[100005];\nint main(){\n\tA.init(); B.init();\n\tcin>>s;\n\tcin>>q;\n\trep(i,q){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tax[i]=a; bx[i]=b;\n\t\tif(a == 1){\n\t\t\tok[b] = 1;\n\t\t}\n\t\telse if(b == s.size()){\n\t\t\tok[a-1] = 1;\n\t\t}\n\t\telse{\n\t\t\tA.unite(a-1,b);\n\t\t}\n\t}\n\tint n = s.size();\n\tfor(int i=1;i<n;i++){\n\t\tcmp[i] = A.find(i);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(i >= n-i) continue;\n\t\tint x = cmp[i];\n\t\tint y = cmp[n-i];\n\t\tif(x != y){\n\t\t\tB.unite(x,y);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint k = B.find(A.find(i));\n\t\tnum[k] += (s[i]-s[i-1]);\n\t\tif(ok[i]) okB[k] = 1;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(A.find(i) != i || B.find(i) != i || okB[i]) continue;\n\t\tif(num[i]%26 != 0){\n\t\t\tputs(\"NO\"); return 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mod = 'z' - 'a' + 1;\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\n\tint m;\n\tcin >> m;\n\tvector<vector<int>> graph(n/2 + 1);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a;\n\t\ta = min(a, n-a);\n\t\tb = min(b, n-b);\n\t\tif(a != b) {\n\t\t\tgraph[a].push_back(b);\n\t\t\tgraph[b].push_back(a);\n\t\t}\n\t}\n\n\tvector<int> vec(n/2);\n\tfor(int i = 0; i < n/2; ++i) {\n\t\tvec[i] = int(s[i]) - int(s[n-1-i]);\n\t\tvec[i] %= mod;\n\t\tvec[i] += mod;\n\t\tvec[i] %= mod;\n\t}\n\n\tn  = n/2+1;\n\n\tvector<bool> seen(n, false);\n\tfunction<void(int, vector<int>&)> dfs = [&](int node, vector<int> &comp) {\n\t\tif(seen[node]) return;\n\t\tseen[node] = true;\n\t\tcomp.push_back(node);\n\t\tfor(int ch : graph[node]) dfs(ch, comp);\n\t};\n\n\tvector<int> finish(n, -1);\n\tvector<int> start(n, -1);\n\tvector<int> total;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(!seen[i]) {\n\t\t\tvector<int> comp;\n\t\t\tdfs(i, comp);\n\t\t\tfor(int j = 1; j < comp.size(); ++j) {\n\t\t\t\tstart[comp[j-1]] = total.size();\n\t\t\t\tfinish[comp[j]] = total.size();\n\t\t\t\ttotal.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint sum = 0;\n\tbool can = true;\n\tfor(int i = 0; i < n-1; ++i) {\n\t\tassert(vec[i] >= 0);\n\t\tassert(sum >= 0);\n\t\tvec[i] += sum;\n\t\tvec[i] %= mod;\n\t\tif(vec[i] != 0) {\n\t\t\tif(start[i] == -1) can = false;\n\t\t\telse {\n\t\t\t\tsum += mod - vec[i];\n\t\t\t\tsum %= mod;\n\t\t\t\ttotal[start[i]] = (mod - vec[i]) % mod;\n\t\t\t}\n\t\t}\n\t\tif(finish[i+1] != -1) {\n\t\t\tsum += mod - total[finish[i+1]];\n\t\t\tsum %= mod;\n\t\t}\n\t}\n\n\tif(can) {\n\t\tcout << \"YES\" << endl;\n\t} else {\n\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 100005;\nchar s[N];\nint d[N];\n\n\nint main(){\n\tscanf(\"%s\", s + 1);\n\tint q; sd(q);\n\tint n= strlen(s + 1);\n\tint mid = n / 2;\n\tfor(int i = 1; i <= mid; i++) d[i] = (s[i] - s[n + 1 - i] + 26) % 26;\n\tvector<vector<int>> events(n + 1);\n\tfor(int i = 1; i <= q; i++){\n\t\tint l, r; sd(l); sd(r);\n\t\tif(n % 2 == 1 && l == mid + 1 && r == mid + 1) continue;\n\t\tif(n % 2 == 1 && l == mid + 1 &&r != mid + 1){\n\t\t\tevents[n + 1 - r].push_back(1);\n\t\t\tevents[mid + 1].push_back(-1);\n\t\t\tcontinue;\n\t\t}\n\t\tif(n % 2 == 1 && r == mid + 1 && l != mid + 1){\n\t\t\tevents[l].push_back(1);\n\t\t\tevents[mid + 1].push_back(-1);\n\t\t\tcontinue;\n\t\t}\n\t\tint a = l > mid, b = r > mid;\n\t\tint vl = a ? n + 1 - l : l;\n\t\tint vr = b ? n + 1 - r : r;\n\n\t\tif(!a && !b){\n\t\t\tevents[vl].push_back(1);\n\t\t\tevents[vr + 1].push_back(-1);\n\t\t}\n\n\t\tif(!a && b){\n\t\t\t// [vl ... mid] U [vr ... mid]\n\t\t\tif(vl > vr) swap(vl, vr);\n\t\t\tif(vl == vr) continue;\n\t\t\tevents[vl].push_back(1);\n\t\t\tevents[vr].push_back(-1);\n\t\t}\n\t\tif(a){\n\t\t\tevents[vr].push_back(1);\n\t\t\tevents[vl + 1].push_back(-1);\n\t\t}\n\t}\n\tint curr = 0, lst = 0;\n\tfor(int i = 1; i <= mid + 1; i++){\n\t\tif(!events[i].empty()){\n\t\t\tif(lst + 1 != i){\n\t\t\tset<int> st;\n\t\t\tfor(int j = lst + 1; j < i; j++) st.insert(d[j]);\n\t\t\tif(st.size() > 1 || (curr == 0 && *st.begin() != 0)){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn 0;\n\t\t\t}}\n\t\t\tlst = i - 1;\n\t\t}\n\t\tfor(auto it : events[i]) curr += it;\t\n\t}\n\tfor(int j = lst + 1; j <= mid; j++) if(d[j] != 0){\n\t\tprintf(\"NO\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n==1){\n        cout <<\"YES\" << endl;\n        return 0;\n    }\n    vector<int> a(n/2);\n    rep(i,n/2){\n        a[i] = (26+s[n-1-i]-s[i])%26;\n    }\n    // rep(i,n/2)cerr << a[i] << \" \";\n    // cerr << endl;\n    int m;\n    cin >> m;\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > p;\n    rep(i,m){\n        int l,r;\n        cin >> l >> r;\n        l--;r--;\n        if(n%2==1){\n            if(l==n/2&&r==n/2)continue;\n            if(l==n/2)l++;\n            if(r==n/2)r--;\n        }\n        if(l==r){\n            if(l>=n/2){\n                l = n-1-l;\n                p.push(MP(l,l));\n            }else{\n                p.push(MP(l,l));\n            }\n        }else{\n            if(l<n/2&&r<n/2){\n                p.push(MP(l,r));\n            }else if(l<n/2){\n                r = n-1-r;\n                if(l<r){\n                    p.push(MP(l,r-1));\n                }else if(l>r){\n                    p.push(MP(r,l-1));\n                }\n            }else if(r>=n/2){\n                l = n-1-l;\n                r = n-1-r;\n                p.push(MP(min(l,r),max(l,r)));\n            }\n        }\n    }\n    vector<int> nxt(n/2,-1);\n    while(!p.empty()){\n        auto x = p.top();\n        p.pop();\n        int a = x.first;\n        int b = x.second;\n        if(nxt[a]==-1){\n            nxt[a] = b;\n\n        }else{\n            if(nxt[a]>b){\n                int x = nxt[a];\n                nxt[a] = b;\n                if(nxt[b+1]==-1){\n                    nxt[b+1] = x;\n                }else{\n                    p.push(MP(b+1,x));\n                }\n            }else if(nxt[a]<b){\n                if(nxt[nxt[a]+1]==-1){\n                    nxt[nxt[a]+1] = b;\n                }else{\n                    p.push(MP(nxt[a]+1,b));\n                }\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << nxt[i] << \" \";\n    // }\n    // cerr << endl;\n    vector<int> res(n/2);\n    vector<int> ss(n/2+1);\n    int tmp = 0;\n\n    rep(i,n/2){\n        tmp -= ss[i];\n        res[i] += tmp;\n        res[i] %= 26;\n        if(res[i]!=a[i]){\n            if(nxt[i]!=-1){\n                int c = (26+a[i]-res[i])%26;\n                tmp += c;\n                ss[nxt[i]+1] += c;\n                res[i] = a[i];\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << res[i] << \" \";\n    // }\n    // cerr << endl;\n    rep(i,n/2){\n        if(res[i]!=a[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#define N 100005\n\nchar str[N]; int len, mid;\nstd::pair<int, int> ops[N]; int opscnt;\n\ninline void merge_ops()\n{\n\tstatic std::set<int> rs[N];\n\tfor(int i = 0; i < opscnt; ++i)\n\t\trs[ops[i].first].insert(ops[i].second);\n\n\topscnt = 0;\n\tfor(int l = 1; l <= mid; ++l)\n\t{\n\t\tstd::set<int> &cur = rs[l];\n\t\tif(cur.empty()) continue;\n\n\t\tint r = *cur.begin();\n\t\tops[opscnt++] = std::make_pair(l, r);\n\t\t//printf(\"f->%d %d\\n\", l, r);\n\t\tcur.erase(cur.begin());\n\n\t\tstd::set<int> &dest = rs[r + 1];\n\t\tif(cur.size() < dest.size())\n\t\t\tfor(int i: cur) dest.insert(i);\n\t\telse\n\t\t{\n\t\t\tfor(int i: dest) cur.insert(i);\n\t\t\tdest.swap(cur);\n\t\t}\n\t}\n}\n\ninline bool solve()\n{\n\tstatic int pre[N];\n\tpre[0] = 0;\n\tpre[1] = str[1] - 'a';\n\tfor(int i = 2; i <= mid; ++i)\n\t{\n\t\tpre[i] = str[i] - str[i - 1];\n\t\tpre[i] = (pre[i] + 26) % 26;\n\t}\n\n\tint k = 1;\n\tfor(int o = 0; o < opscnt; ++o)\n\t{\n\t\tconst std::pair<int, int> &cur = ops[o];\n\t\tfor(; k <= cur.first; ++k)\n\t\t{\n\t\t\tpre[k] += pre[k - 1];\n\t\t\tpre[k] = (pre[k] + 26) % 26;\n\t\t}\n\t\tint d = int(str[len - cur.first + 1]) - pre[cur.first] - 'a';\n\t\tpre[cur.first] += d;\n\t\tpre[cur.second + 1] -= d;\n\t}\n\tfor(; k <= mid; ++k)\n\t{\n\t\tpre[k] += pre[k - 1];\n\t\tpre[k] = (pre[k] + 26) % 26;\n\t}\n\n\tfor(int i = 1; i <= mid; ++i)\n\t{\n\t\tif(pre[i] != str[len - i + 1] - 'a')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint _;\n\tscanf(\"%s%d\", str + 1, &_);\n\tlen = strlen(str + 1);\n\tmid = len >> 1;\n\n\topscnt = 0;\n\tfor(int i = 0; i < _; ++i)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif(l - 1 > (len - r))\n\t\t{\n\t\t\tl = len - l + 1;\n\t\t\tr = len - r + 1;\n\t\t\tstd::swap(l, r);\n\t\t}\n\t\tif(r > mid) r = len - r;\n\n\t\tif(l <= r)\n\t\t\tops[opscnt++] = std::make_pair(l, r);\n\t}\n\n\tmerge_ops();\n\n\tif(solve()) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return weight(y) - weight(x);\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          diff %= 26;\n          int diff2 = (S[other] - S[idx] + 26) % 26;\n          if(max(diff, 26 - diff) == max(diff2, 26 - diff2)) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l;\nchar s[200020];\nint f[200020];\nint a[200020];\nint L[200020];\nint R[200020];\nint F(int x) {\n\treturn f[x] != x ? f[x] = F(f[x]) : x;\n}\nvoid U(int x, int y) {\n//\tprintf(\"%d %d\\n\", x, y);\n\tx = F(x);\n\ty = F(y);\n\tif (x != y) {\n\t\tf[x] = y;\n\t\ta[y] += a[x];\n\t}\n\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tl = strlen(s + 1);\n\tbool caonima = false;\n\tif (l % 2 == 0) {\n\t\tcaonima = true;\n\t\tl++;\n\t\tfor (int i = l; i > (l + 1) / 2; i--) {\n\t\t\ts[i] = s[i - 1];\n\t\t}\n\t\ts[(l + 1) / 2] = '$';\n\t}\n//\tprintf(\"%s\\n\", s + 1);\n\tassert(l % 2 == 1);\n\tm = (l + 1) / 2;\n\tfor (int i = 0; i < 2 * m; i++) {\n\t\tf[i] = i;\n\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &L[i], &R[i]);\n\t\tif (caonima) {\n\t\t\tif (L[i] >= m) {\n\t\t\t\tL[i]++;\n\t\t\t}\n\t\t\tif (R[i] >= m) {\n\t\t\t\tR[i]++;\n\t\t\t}\n\t\t}\n\t\tif (L[i] > m) {\n\t\t\tint ll = 2 * m - L[i];\n\t\t\tint rr = 2 * m - R[i];\n\t\t\tL[i] = rr;\n\t\t\tR[i] = ll;\n\t\t}\n\t}\n//\tprintf(\"---\\n\");\n\tfor (int i = 0; i < m; i++) {\n\t\ta[i] = (s[i + 1] - s[i]) - (s[2 * m - i - 1] - s[2 * m - i]);\n//\t\tprintf(\"%d\\n\", a[i]);\n\t}\n//\tprintf(\"---\\n\");\n\tfor (int i = 0; i < n; i++) {\n//\t\tprintf(\"???\\n\");\n\t\tif (R[i] < m) {\n\t\t\tU(L[i] - 1, R[i]);\n\t\t} else {\n\t\t\tU(L[i] - 1, l - R[i]);\n\t\t}\n\t}\n\tbool ok = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[F(i)] == 0 || F(i) == F(0)) {\n\n\t\t} else {\n//\t\t\tprintf(\"%d\\n\", i);\n\t\t\tok = false;\n\t\t}\n\t}\n\tif (ok) {\n\t\tprintf(\"YES\\n\");\n\t} else {\n\t\tprintf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k) R[i]--;\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sign(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\nusing mint = mod_int<26>;\n\ntemplate<typename M>\nstruct fenwick_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    fenwick_tree(int n) : n(n), data(n + 1, M::id()) {}\n    void add(int i, const T &x) { for (i++; i <= n; i += i & -i) { data[i] = M::op(data[i], x); }}\n    T get_sum(int i) const {\n        T ret = M::id();\n        for (; i > 0; i -= i & -i) { ret = M::op(ret, data[i]); }\n        return ret;\n    }\n    T get_sum(int l, int r) const {\n        return M::op(get_sum(r), M::inv(get_sum(l)));\n    }\n};\n\ntemplate<typename M>\nstruct fenwick_tree_range {\n    using T = typename M::T;\n    fenwick_tree<M> ft;\n    fenwick_tree_range(int n) : ft(n + 1) {}\n    void add(int l, int r, const T &x) { ft.add(l, x), ft.add(r, -x); }\n    T operator[](int i) const { return ft.get_sum(i + 1); }\n};\n\nstruct rsq {\n    using T = mint;\n    static T id() { return 0; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static T inv(const T &a) { return -a; }\n};\n\nstring S;\nint N;\nint L[110000], R[110000];\npriority_queue_rev<int> rs[110000];\nsigned main() {\n    cin >> S >> N;\n    int K = S.length();\n    rep(i, N) {\n        cin >> L[i] >> R[i];\n        if (L[i] - 1 < K - R[i]) { rs[L[i] - 1].push(min(R[i], K - R[i])); }\n        else if (L[i] - 1 > K - R[i]) { rs[K - R[i]].push(min(L[i] - 1, K - L[i])); }\n    }\n    fenwick_tree_range<rsq> ft(K / 2);\n    rep(i, K / 2) { ft.add(i, i + 1, S[i] - S[K - i - 1]); }\n    rep(i, K / 2) {\n        if (rs[i].empty()) {\n            if (ft[i] != 0) { fin(\"NO\"); }\n            continue;\n        }\n        int cur = rs[i].top();\n        rs[i].pop();\n        ft.add(i, cur, -ft[i]);\n        while (!rs[i].empty()) {\n            if (cur < rs[i].top()) { rs[cur].push(rs[i].top()); }\n            cur = rs[i].top(), rs[i].pop();\n        }\n    }\n    cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(mid1 - l, r - mid2) + 1;\n            r = max(mid1 - l, r - mid2);\n        } else\n        {\n            l = min(abs(l - mid1), abs(l - mid2));\n            r = min(abs(r - mid1), abs(r - mid2));\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n            int minr = *segs[i].begin();\n            segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tint m = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstring S;\nset<int> st[105000];\nint N;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\n\npublic:\n    LazySegmentTree() {\n        int sz = 100500;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = node[2*k+1] + node[2*k+2];\n        }\n    }\n\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return vl + vr;\n    }\n\n};\n\n\nvoid merge(set<int> &a, set<int> &b) {\n    if(a.size() < b.size()) swap(a, b);\n    for(auto val : b) {\n        a.insert(val);\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> S;\n    N = S.size();\n    int Q;\n    cin >> Q;\n    while(Q--) {\n        int l, r;\n        cin >> l >> r;\n        l--;\n        r--;\n        if(r < N / 2) {\n            st[l].insert(r);\n        } else if(l >= N / 2) {\n            st[N - 1 - r].insert(N - 1 - l);\n        } else {\n            r = N - 1 - r;\n            if(r < l) swap(l, r);\n            if(l != r) {\n                st[l].insert(r - 1);\n            }\n        }\n    }\n    /*\n    for(int i = 0; i <= N; i++) {\n        for(auto val : st[i]) cerr << i << \" \" << val << endl;\n    }\n    */\n    LazySegmentTree seg;\n    for(int i = 0; i < N; i++) {\n        seg.add(i, i + 1, S[i] - 'a');\n    }\n    for(int i = 0; i <= N / 2; i++) {\n        while(true) {\n            if(seg.getsum(i, i + 1) % 26 == seg.getsum(N - 1 - i, N - i) % 26) break;\n            if(st[i].empty()) {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n            auto itr = st[i].begin();\n            seg.add(i, *itr + 1, 1);\n        }\n        if(!st[i].empty()) {\n            auto itr = st[i].begin();\n            int r = *itr + 1;\n            st[i].erase(itr);\n            merge(st[r], st[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint main(){\n    string S;\n    int N;\n    cin >> S >> N;\n    int L = S.size();\n    int sz = L/2;\n    vector<int> V(sz+2, 0);\n    for(int i=1; i<=sz; i++) V[i] = S[i-1] - S[L-i];\n    vector<int> diff(sz+1, 0);\n    for(int i=0; i<=sz; i++) diff[i] = V[i+1] - V[i];\n\n    UnionFind uf(sz+1);\n    for(int i=0; i<N; i++){\n        int l, r;\n        cin >> l >> r;\n        l--;\n        l = min(l, L-l);\n        r = min(r, L-r);\n        uf.unite(l, r);\n    }\n\n    vector<int> sum(sz+1, 0);\n    for(int i=0; i<=sz; i++) sum[uf.find(i)] += diff[i];\n    for(int i=0; i<=sz; i++) if(sum[i] % 26){\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\tprintf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\twhile(!st.empty()&&st.begin()->s<i) st.erase(st.begin());\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(st.empty()) break;\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()) break;\n\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\tS temp2=*it;\n\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\tst.erase(temp2); \n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\tint x1 = a - 'a';\n\tint x2 = b - 'a';\n\treturn (x2 - x1 + 26) % 26;;\n}\n\nset<int> st;\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB({1, i});\n\t\tvec[r[i] + 1].PB({-1, i});\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t\tif(x == -1) st.erase(id);\n\t\t\telse st.insert(id);\n\t\t}\n\t\ttot[i] = totnow;\n\t\tif(tot[i] == 0) par[i] = 0;\n\t\telse {\n\t\t\tif(ms[st] == 0) ms[st] = i;\n\t\t\tpar[i] = ms[st];\n\t\t}\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= n;i++) {\n\t\tif(find(i) == 0 && find(n - i + 1) == 0) {\n\t\t\tif(s[i - 1] != s[n - i]) bisa = false;\n\t\t}\n\t\telse {\n\t\t\tint pr = find(i);\n\t\t\tif(pr != 0) {\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(find(n - i + 1) == find(rev)) {\n\t\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n\t//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n\t//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\t\tbisa = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<ll, ll>  ii;\ntypedef vector<ll>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst ll INF = ll(1e9 + 7);\n\nconst ll tam = 100010;\n\nvector<ll> G[tam];\nll val[tam];\nbool vis[tam];\n\nll sum;\nvoid dfs(ll v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (ll u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    ll n;\n    cin >> n;\n    for (ll i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    if (s.size() == 1)\n    {\n    \tcout << \"YES\" << '\\n';\n    \treturn 0;\n    }\n    s = \"a\" + s + \"a\";\n\n    //cout << s << endl;\n\tfor (ll i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \t//cout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    //cout << endl;\n\n    for (ll i = 0; i < n; i++)\n    {\n    \t//val[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \t//val[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = 0;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint par[N + 5];\nint l[N + 5], r[N + 5];\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\nstring s;\n\nLL arr[N + 5];\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tint pre = 0;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tarr[i] = diff;\n//\t\tcout<<\"TEST \"<<i<<\" \"<<diff<<endl;\n\t\tint npre = arr[i];\n\t\tif(i != 0) arr[i] = (arr[i] - pre + 26) % 26;\n\t\tpre = npre;\n\t\tpar[i] = i;\n//\t\tcout<<i<<\" \"<<arr[i]<<endl;\n\t}\n\tpar[mid] = mid;\n\tarr[mid] = (26 - pre) % 26;\n//\tcout<<mid<<\" \"<<arr[mid]<<endl;\n\tbool bisa = true;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n\t\tint lhs = min(l[i], n - l[i] - 1);\n\t\tint rhs = min(r[i], n - r[i] - 1);\n\t\tif(r[i] < mid) {\n\t\t\tlhs = l[i];\n\t\t\trhs = r[i] + 1;\n\t\t} else if(l[i] > mid) {\n\t\t\tlhs = n - r[i] - 1;\n\t\t\trhs = n - l[i];\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tlhs = mini;\n\t\t\trhs = maxi;\n\t\t}\t\t\n\t\tint u = find(lhs);\n\t\tint v = find(rhs);\n\t\tif(u != v) {\n\t\t\tarr[u] += arr[v];\n\t\t\tpar[v] = u;\n\t\t}\n\t}\n\tfor(int i = 0;i <= mid;i++) {\n//\t\tcout<<i<<\" \"<<find(i)<<\" \"<<arr[find(i)]<<endl;\n\t\tif(arr[find(i)] % 26) bisa = false;\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <tuple>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define FOR(x,xs) for(auto &x: xs)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef pair<ll,ll> PL;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\n\nstruct uf {\n  VI dat;\n  uf(int n): dat(n) {\n    REP(i,0,n) {\n      dat[i] = i;\n    }\n  }\n  int find(int x) {\n    if(dat[x] == x) {\n      return x;\n    }\n    return x = find(dat[x]);\n  }\n  void unite(int x, int y) {\n    dat[find(x)] = find(y);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  int l = s.size();\n  VI xs(l+2);\n  xs[0] = xs[l+1] = 0;\n  transform(s.begin(), s.end(), xs.begin()+1, [](char c){return c-'a';});\n  transform(xs.begin(), xs.end()-1, xs.begin()+1, xs.begin(), [](int x, int y){return (y+26-x)%26;});\n  xs.pop_back();\n  uf u(l+1);\n  int N;\n  cin >> N;\n  REP(i,0,N) {\n    int l, r;\n    cin >> l >> r;\n    u.unite(l-1, r);\n  }\n  for(int i=0, j=l; i < j; i++, j--) {\n    u.unite(i, j);\n  }\n  VI sum(l+1, 0);\n  REP(i,0,l+1) {\n    sum[u.find(i)] += xs[i];\n    sum[u.find(i)] %= 26;\n  }\n  bool ans = all_of(sum.begin(), sum.end(), [](int x){return x == 0;});\n  cout << (ans ? \"YES\" : \"NO\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstring st;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {  cin >> st;\n\tbool flag = false;\n\tif (st.size() % 2) {\n\t\tst.erase(st.begin() + st.size() / 2);\n\t\tflag = true;\n\t}\n\tassert(st.size() % 2 == 0);\n\tint N; cin >> N;\n\tvector<int>nums(st.size() + 1);\n\tnums[0] = st[0] - 'a';\n\tfor (int i = 1; i < st.size(); ++i) {\n\t\tnums[i] = (26+st[i] - st[i - 1])%26;\n\t}\n\tnums[st.size()] = 26 - (st[st.size() - 1]-'a');\n\tvector<pair<int, int>>edges;\n\tvector<long long int>nodes(st.size() + 1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint l, r; cin >> l >> r;\n\t\tl--;\n\t\tif (flag) {\n\t\t\tif (l > st.size() / 2) {\n\t\t\t\tl--;\n\t\t\t}\n\t\t\tif (r>st.size()/2) {\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t\tif (l > st.size()/2) {\n\t\t\tl = st.size() - l;\n\t\t}\n\t\tif(r>st.size()/2){\n\t\t\tr = st.size() - r;\n\t\t}\n\t\tedges.push_back(make_pair(l, r));\n\t}\n\tvector<int>flags(st.size() / 2 + 1);\n\n\tUnionFind uf(st.size() / 2 + 1);\n\tfor (auto e : edges) {\n\t\tif (e.first == e.second)flags[e.first] = true;\n\t\telse {\n\t\t\tuf.unionSet(e.first, e.second);\n\t\t}\n\n\t}\n\tfor (int i = 0; i < st.size() / 2; ++i) {\n\t\tnums[i] += nums[st.size() - i];\n\t}\n\tset<int>roots;\n\tmap<int, pair<long long int, bool>>mp;\n\tvector<long long int >sums(st.size() / 2 + 1);\n\tfor (int i = 0; i < st.size() / 2 + 1; ++i) {\n\t\tmp[uf.root(i)].first += nums[i];\n\t\tif (flags[i])mp[uf.root(i)].second = true;\n\t}\n\tbool ok = true;\n\tfor (auto m : mp) {\n\t\tm.second.first %= 26;\n\t\t//if (m.second.second) {\n\t\t\tif (m.second.first % 2)ok = false;\n\t\t//}\n\t//\telse {\n\t\t\tif (m.second.first)ok = false;\n\t\t//}\n\t}\n\tif (ok)cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 300000\n\nLL n,m,a[N],sum;\nvector<LL> g[N];\nbool vis[N];\nchar s[N];\n\nvoid add(LL x,LL y){\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\n\nvoid dfs(LL u){\n\tvis[u]=1;\n\tsum+=a[u];\n\tfor (LL v:g[u]){\n\t\tif (!vis[v]) dfs(v);\n\t}\n}\n\nint main(){\n\tscanf(\"%s\",s+1); m=strlen(s+1);\n\tfor (LL i=1;i<=m/2;++i) a[i]=s[i]-s[m-i+1];\n\ta[m/2+1]-=a[m/2];\n\tfor (LL i=m/2;i;--i) a[i]-=a[i-1];\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<=n;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\tif (x<=m/2&&y>=m-m/2+1){\n\t\t\tLL l1=m/2-x,l2=y-(m-m/2+1);\n\t\t\tif (l1>l2){\n\t\t\t\ty=m-y+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty=m-y+1;\n\t\t\t\tswap(x,y);\n\t\t\t}\n\t\t\t--y;\n\t\t}\n\t\tif (x>m/2){\n\t\t\tx=m-x+1; y=m-y+1;\n\t\t\tswap(x,y);\n\t\t}\n\t\tif (y>m/2) y=m/2;\n\t\tif (x<=y) add(x,y+1);\n\t}\n\tfor (LL i=1;i<=m/2+1;++i){\n\t\tsum=0;\n\t\tif (!vis[i]) dfs(i);\n\t\tif (sum%26){puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct union_find{\n    VI par;\n\n    void init(int n){\n        par.resize(n);\n        REP(i,n) par[i] = i;\n    }\n\n    int find(int x){\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void merge(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        par[x] = y;\n    }\n};\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    VI a(n);\n    REP(i,n) a[i] = s[i] - 'a';\n\n    VI d(n+1);\n    REP(i,n-1) d[i+1] = (a[i+1] - a[i] + 26) % 26;\n    d[0] = a[0];\n    d[n] = (-a[n-1] + 26) % 26;\n\n    n++;\n\n    union_find uf;\n    uf.init(n);\n    REP(i,n) uf.merge(i, n-1-i);\n\n    int m;\n    cin >> m;\n    while (m--){\n        int l, r;\n        cin >> l >> r;\n        uf.merge(l-1, r);\n    }\n\n    VI sum(n);\n    REP(i,n) sum[uf.find(i)] += d[i];\n    REP(i,n){\n        if (sum[i] % 26 != 0){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nusing ui = uint32_t;\n\nconst int maxn = 50100;\n//bitset<maxn> q[maxn];\nui q[4000 * maxn];\nint off[maxn];\nint qmem[maxn];\nint m;\n\nvoid qset(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  q[off[x] + qmem[x] - 1 - (m - y) / 32] |= (ui(1) << ((m - y) % 32));\n}\n\nbool qget(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  return q[off[x] + qmem[x] - 1 - (m - y) / 32] & (ui(1) << ((m - y) % 32));\n}\n\nvoid qor(int x, int y) {\n  for (int i = 0; i < qmem[y]; ++i) {\n    int block = off[y] + i;\n    int from = off[x] + qmem[x] - qmem[y] + i;\n    q[block] |= q[from];\n  }\n}\n\nint qfind_first(int x) {\n  for (int i = 0; i < qmem[x]; ++i) {\n    if (q[off[x] + i]) {\n      for (int j = 0; j < 32; ++j) {\n        if (qget(x, i * 32 + j))\n          return i * 32 + j;\n      }\n      assert(false);\n    }\n  }\n  return maxn;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  m = n / 2;\n  int OFF = 0;\n  for (int i = m; i >= 0; --i) {\n    int mem = (m - i + 1 + 31) / 32;\n    off[i] = OFF;\n    qmem[i] = mem;\n    OFF += mem;\n  }\n\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      qset(nl, nr);\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = qfind_first(i);\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      qor(to, i);\n      //q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#define N 100005\n\nchar str[N]; int len, mid;\nstd::pair<int, int> ops[N]; int opscnt;\n\ninline void merge_ops()\n{\n\tstatic std::set<int> rs[N];\n\tfor(int i = 0; i < opscnt; ++i)\n\t\trs[ops[i].first].insert(ops[i].second);\n\n\topscnt = 0;\n\tfor(int l = 1; l <= mid; ++l)\n\t{\n\t\tstd::set<int> &cur = rs[l];\n\t\tif(cur.empty()) continue;\n\n\t\tint r = *cur.begin();\n\t\tops[opscnt++] = std::make_pair(l, r);\n\t\t//printf(\"f->%d %d\\n\", l, r);\n\t\tcur.erase(cur.begin());\n\n\t\tstd::set<int> &dest = rs[r + 1];\n\t\tif(cur.size() < dest.size())\n\t\t\tfor(int i: cur) dest.insert(i);\n\t\telse\n\t\t{\n\t\t\tfor(int i: dest) cur.insert(i);\n\t\t\tdest.swap(cur);\n\t\t}\n\t}\n}\n\ninline bool solve()\n{\n\tstatic int pre[N];\n\tpre[0] = 0;\n\tpre[1] = str[1] - 'a';\n\tfor(int i = 2; i <= mid; ++i)\n\t{\n\t\tpre[i] = str[i] - str[i - 1];\n\t\tpre[i] = (pre[i] + 26) % 26;\n\t}\n\n\tint k = 1;\n\tfor(int o = 0; o < opscnt; ++o)\n\t{\n\t\tconst std::pair<int, int> &cur = ops[o];\n\t\tfor(; k <= cur.first; ++k)\n\t\t{\n\t\t\tpre[k] += pre[k - 1];\n\t\t\tpre[k] = (pre[k] + 26) % 26;\n\t\t}\n\t\tint d = int(str[len - cur.first + 1]) - pre[cur.first] - 'a';\n\t\tpre[cur.first] += d;\n\t\tpre[cur.first] = (pre[cur.first] + 26) % 26;\n\t\tpre[cur.second + 1] -= d;\n\t\tpre[cur.second + 1] = (pre[cur.second + 1] + 26) % 26;\n\t}\n\tfor(; k <= mid; ++k)\n\t{\n\t\tpre[k] += pre[k - 1];\n\t\tpre[k] = (pre[k] + 26) % 26;\n\t}\n\n\tfor(int i = 1; i <= mid; ++i)\n\t{\n\t\tif(pre[i] != str[len - i + 1] - 'a')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint _;\n\tscanf(\"%s%d\", str + 1, &_);\n\tlen = strlen(str + 1);\n\tmid = len >> 1;\n\n\topscnt = 0;\n\tfor(int i = 0; i < _; ++i)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif(l - 1 > (len - r))\n\t\t{\n\t\t\tl = len - l + 1;\n\t\t\tr = len - r + 1;\n\t\t\tstd::swap(l, r);\n\t\t}\n\t\tif(r > mid) r = len - r;\n\n\t\tif(l <= r)\n\t\t\tops[opscnt++] = std::make_pair(l, r);\n\t}\n\n\tmerge_ops();\n\n\tif(solve()) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  codeforcesTraining\n//\n//  Created by Pranav Jangir on 04/09/19.\n//  Copyright © 2019 Pranav Jangir. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <unordered_map>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nll n, m;\nll a[200005];\nll p[200005];\nll fs(ll x)\n{\n    return p[x] == x ? p[x] : p[x] = fs(p[x]);\n}\nvoid ms(ll x,ll y)\n{\n    x = fs(x); y = fs(y);\n    p[y] = x;\n}\nll c[200005];\nint main(int argc, const char * argv[]) {\n    \n    cin >> s;\n    cin >> m;\n    n = s.length();\n    s = \"a\" + s;\n    s = s + \"a\";\n    for(ll i=1;i<=n + 1;i++) p[i] = i;\n    for(ll i=1;i <= n + 1;i++){\n        a[i] = s[i] - 'a';\n        a[i] = a[i] - (s[i - 1] - 'a');\n        a[i] += 26;\n        a[i] %= 26;\n    }\n    //for(ll i=1;i<=n+1;i++) cout << a[i] << \" \"; cout << endl; return 0;\n    ll lst = n + 1;\n    for(ll i=1;i < lst ;i++) {\n        ms(i, lst);\n        lst--;\n    }\n    while(m--) {\n        ll l, r;\n        cin >> l>> r;\n        ms(l , r+1);\n    }\n    for(ll i=1;i<=n+1;i++) {\n        //cout << i <<  \" --> \" << fs(i) << endl;\n        c[fs(i)] += a[i];\n        c[fs(i)] %= 26;\n    }\n    for(ll i=1;i<=n;i++) {\n        if(c[i] != 0) {\n            cout << \"NO\\n\"; return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEMETRIO\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#define deb1(x) cerr << #x << \" = \" << x << endl\n#else\n#define deb(...) 0\n#define deb1(x) 0\n#endif\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define SZ(x) ((int)(x).size())\n#define mset(a,v) memset(a,v,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\n\nchar s[100005];int n,m;\nint w[100005];\nvector<int> g[100005];\nbool vis[100005];\n\nint dfs(int x){\n\tif(vis[x])return 0;\n\tvis[x]=true;\n\tint r=w[x];\n\tfor(int y:g[x])r+=dfs(y);\n\treturn r;\n}\n\nint main(){\n\tscanf(\"%s%d\",s,&m);n=strlen(s);\n\twhile(m--){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);a--;\n\t\tg[a].pb(b);g[b].pb(a);\n\t}\n\tfore(i,0,n)s[i]-='a';\n\tw[0]=s[0];\n\tfore(i,1,n)w[i]=s[i]-s[i-1];\n\tw[n]=-s[n-1];\n\tfore(i,0,n+1)g[i].pb(n-i);\n\tfore(i,0,n+1)if(!vis[i]&&dfs(i)%26){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tint m = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tsegs.push_back({ l, r });\n\t\t\terr.push_back({ l, r });\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nchar s[125252];\nint v[125252];\nint n,l;\npii q[125252];\nvector<pii> r[125252];\nint rig[125252];\nint imo[125252];\n\nint main(){\n  scanf(\"%s\",s);\n  l = strlen(s);\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d%d\",&q[i].first, &q[i].second);\n  REP(i,l/2){\n    v[i] = s[l-1-i] - s[i];\n    v[i] = (v[i]+26)%26;\n  }\n  REP(i,n){\n    int x = q[i].first-1;\n    int y = q[i].second-1;\n    if(y >= (l+1)/2){\n      if(x >= l/2){\n        x = l-1-x;\n        y = l-1-y;\n        swap(x,y);\n      }else{\n        y = l-1-y;\n        x--;\n        swap(x,y);\n      }\n    }\n    q[i] = pii(x,y);\n  }\n  REP(i,n)if(q[i].first <= q[i].second){\n    r[q[i].first].push_back(q[i]);\n  }\n  REP(i,l/2){\n    if(r[i].size()==0){\n      rig[i] = -1;\n      continue;\n    }\n    sort(ALL(r[i]));\n    rig[i] = r[i][0].second;\n    REP(j,r[i].size()-1){\n      int x = r[i][j].second+1;\n      int y = r[i][j+1].second;\n      if(x<=y){\n        r[x].push_back(pii(x,y));\n      }\n    }\n  }\n  REP(i,l/2){\n    v[i] += imo[i];\n    v[i] %= 26;\n    if(v[i]>0){\n      int add = 26-v[i];\n      if(rig[i]==-1){\n        puts(\"NO\");\n        return 0;\n      }\n      imo[i] += add;\n      imo[i] %= 26;\n      imo[rig[i]+1] += 26-add;\n      imo[rig[i]+1] %= 26;\n    }\n    imo[i+1] += imo[i];\n    imo[i+1] %= 26;\n  }\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\naabcc\n1\n1 5\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=80000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nstring s;\nstring L,R;\n\nvector<int> bound[maxn];\n\npii itv[maxn];\n\nint d[maxn];\nint tg[maxn];\nint main()\n{\n\tIOS;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>itv[i].F>>itv[i].S;\n\tREP(i,n) itv[i].F--;\n\n\tREP(i,n){\n\t\titv[i].F=min(itv[i].F,SZ(s)-itv[i].F);\n\t\titv[i].S=min(itv[i].S,SZ(s)-itv[i].S);\n\t\tif(itv[i].F>itv[i].S) swap(itv[i].F,itv[i].S);\n\t}\n\tfor(int i=0;i<SZ(s)/2;i++) L.pb(s[i]);\n\tfor(int i=0;i<SZ(s)/2;i++) R.pb(s[SZ(s)-1-i]);\n\n\tREP(i,n) if(itv[i].F<itv[i].S) bound[itv[i].F].pb(itv[i].S);\n\tREP(i,SZ(s)/2){\n\t\tSORT_UNIQUE(bound[i]);\n\t\tfor(int j=1;j<SZ(bound[i]);j++){\n\t\t\tbound[bound[i][j-1]].pb(bound[i][j]);\n\t\t}\n\t\twhile(SZ(bound[i])>1) bound[i].pop_back();\n\t}\n\t// REP(i,SZ(s)/2){\n\t// \tfor(int j:bound[i]) cout<<j<<' ';\n\t// \tcout<<'\\n';\n\t// }\n\t// cout<<L<<' '<<R<<'\\n';\n\tREP(i,SZ(s)/2){\n\t\td[i]=(L[i]-R[i]+26)%26;\n\t}\n\t// REP(i,SZ(s)/2) cout<<d[i]<<\" \\n\"[i==SZ(s)/2-1];\n\tint dd=0;\n\tfor(int i=0;i<SZ(s)/2;i++){\n\t\tdd+=tg[i];\n\t\tdd=(dd%26+26)%26;\n\t\td[i]+=dd;\n\t\td[i]%=26;\n\n\t\tif(SZ(bound[i])){\n\t\t\tint tmp=26-d[i];\n\t\t\td[i]+=tmp;\n\t\t\td[i]%=26;\n\t\t\tdd+=tmp;\n\t\t\ttg[bound[i][0]]-=tmp;\n\t\t}\n\t}\n\tREP(i,SZ(s)/2) if(d[i]){\n\t\tcout<<\"NO\\n\";\n\t\treturn 0;\n\t}\n\tcout<<\"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n,m,s[N],sum[N],dif[N];\nint flag[N];\nint get_flag(int pos) {\n\treturn flag[pos] == pos ? pos : flag[pos] = get_flag(flag[pos]);\n}\nvoid fit(int& x) {\n\tif (x > n/2) x = n-x+1;\n}\nint fix(int x) {\n\tif (x<0) x = 26-(-x)%26;\n\tx %= 26;\n\treturn x;\n}\nint main() {\n\tint l,r;\n\tfor (char tmp=getchar();tmp>='a'&&tmp<='z';tmp=getchar())\n\t\ts[++n] = tmp-'a';\n\tfor (int i=1;i<=n/2;++i)\n\t\ts[i] -= s[n-i+1],dif[i]=s[i]-s[i-1],flag[i]=i;\n\tdif[n/2+1] = -s[n/2];\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;++i) {\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif (n&1) {\n\t\t\tif (l == n/2+1&&r == n/2+1) continue;\n\t\t\tif (l == n/2+1) l++;\n\t\t\tif (r == n/2+1) r--;\n\t\t}\n\t\tif (l<=n/2&&r>n/2) {\n\t\t\tfit(r);\n\t\t\tif (l>r) swap(l,r);\n\t\t\tr--;\n\t\t} else {\n\t\t\tfit(l);fit(r);\n\t\t\tif (l>r) swap(l,r);\n\t\t}\n\t\tflag[get_flag(l)]=flag[get_flag(r+1)];\n\t}\n\tfor (int i=1;i<=n/2+1;++i) sum[get_flag(i)] += dif[i];\n\tfor (int i=1;i<=n/2+1;++i) if (fix(sum[i])!=0) {\n\t\treturn 0*puts(\"NO\");\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"NO\"); exit(0); }\nvoid fg(vector<int> G[], int a, int b) { G[a].eb(b); G[b].eb(a); }\n\nconst int MAXN = 100005;\nconst int MAXK = 100005;\n\nvector<int> G[MAXN];\nbitset<MAXN> chk;\n\nint D[MAXN], E[MAXN];\n\nint B[MAXK], C[MAXK];\nchar A[MAXN];\n\nint N, K;\n\nint f(int i) {\n\tint ret = E[i]; chk[i] = true;\n\tfor(int v : G[i]) if(!chk[v]) {\n\t\tret = (ret + f(v)) % 26;\n\t}\n\treturn ((ret % 26) + 26) % 26;\n}\n\nint main() {\n\tscanf(\" %s\", A+1);\n\tN = int(strlen(A+1));\n\tscanf(\"%d\", &K);\n\tfor(int i = 1; i <= K; i++) scanf(\"%d%d\", &B[i], &C[i]);\n\n\tif(N&1) {\n\t\tN++;\n\t\tfor(int i = N-1; N/2 <= i; i--) A[i+1] = A[i];\n\t\tA[N/2] = A[N/2+1];\n\t\tfor(int i = 1; i <= K; i++) {\n\t\t\tif(N/2 < B[i]) B[i]++;\n\t\t\tif(N/2 <= C[i]) C[i]++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= K; i++) {\n\t\tif(C[i] <= N/2) continue;\n\t\tif(N/2 < B[i]) {\n\t\t\tB[i] = N+1-B[i];\n\t\t\tC[i] = N+1-C[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint l = N/2-B[i]+1, r = C[i]-N/2;\n\t\tif(l > r) swap(l, r);\n\t\tB[i] = N/2-r+1;\n\t\tC[i] = N/2-l;\n\t}\n\n\tN /= 2;\n\tfor(int i = 1; i <= N; i++)\n\t\tD[i] = (A[N*2+1-i] - A[i] + 26) % 26;\n\tfor(int i = 1; i <= N+1; i++)\n\t\tE[i] = (D[i] - D[i-1] + 26) % 26;\n\tfor(int i = 1; i <= K; i++) C[i]++;\n\tN++;\n\n\tfor(int i = 1; i <= K; i++) if(B[i] < C[i]) fg(G, B[i], C[i]);\n\tfor(int i = 1; i <= N; i++) if(!chk[i]) {\n\t\tint t = f(i);\n\t\tif(t) fuk();\n\t}\n\n\tfor(int i = 1; i <= N; i++) if(!chk[i] && E[i]) fuk();\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, q, len;\nchar s[100005];\nint from[100000], to[100000];\nint a[100000];\n\nset<int> se[100000];\nint best[100000];\n\nint par[100000];\n\nvoid dsuInit() {\n    forn(i, len + 1) par[i] = i;\n}\n\nint dsuParent(int v) {\n    if (v == par[v]) return v;\n    return par[v] = dsuParent(par[v]);\n}\n\nvoid dsuMerge(int u, int v) {\n    u = dsuParent(u);\n    v = dsuParent(v);\n    if (u == v) return;\n    if (se[u].size() < se[v].size()) swap(u, v);\n    for (int x : se[v]) {\n        se[u].insert(x);\n    }\n    par[v] = u;\n}\n\nint main() {\n    scanf(\"%s\", s);\n    n = strlen(s);\n    scanf(\"%d\", &q);\n    len = n / 2;\n    int ri = len + n % 2;\n    forn(i, q) {\n        scanf(\"%d%d\", from + i, to + i);\n        --from[i], --to[i];\n        if (to[i] < ri) {\n            to[i] = min(to[i], len - 1);\n            ++to[i];\n        } else if (from[i] >= len) {\n            from[i] = max(from[i], ri);\n            from[i] = n - 1 - from[i];\n            to[i] = n - 1 - to[i];\n            swap(from[i], to[i]);\n            ++to[i];\n        } else {\n            to[i] = n - 1 - to[i];\n            if (from[i] == to[i]) {\n                from[i] = to[i] = len;\n            } else {\n                if (from[i] > to[i]) {\n                    swap(from[i], to[i]);\n                }\n            }\n        }\n    }\n    a[len] = 0;\n    forn(i, len) {\n        a[i] = int(s[i]) - int(s[n - 1 - i]);\n        if (a[i] < 0) {\n            a[i] += 26;\n        }\n    }\n//    cerr << \"!!\" << endl;\n//    forn(i, len) cerr << a[i] << ' ';\n//    cerr << endl;\n//    forn(i, q) cerr << from[i] << ' ' << to[i] << endl;\n//    cerr << \"!!\" << endl;\n    for (int i = len - 1; i >= 0; --i) {\n        a[i + 1] -= a[i];\n        if (a[i + 1] < 0) {\n            a[i + 1] += 26;\n        }\n    }\n    forn(i, q) {\n        se[from[i]].insert(to[i]);\n    }\n    dsuInit();\n    forn(i, len) {\n        int si = dsuParent(i);\n        while (!se[si].empty() && *se[si].begin() == i) {\n            se[si].erase(se[si].begin());\n        }\n        if (!se[si].empty()) {\n            int ind = *se[si].begin();\n            se[si].erase(se[si].begin());\n            if (!se[si].empty()) {\n                dsuMerge(si, ind);\n            }\n            a[ind] += a[i];\n            a[i] = 0;\n            if (a[ind] >= 26) {\n                a[ind] -= 26;\n            }\n\n        }\n        if (a[i] != 0) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    if (a[n] != 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define D(a) cerr << #a << \" = \" << a << endl\n#else\n\t#define D(a)\n\t#define cerr false && cerr\n#endif\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0)\n#define dforsn(i,s,n) for(int i=int(n-1);i>=int(s);i--)\n#define forsn(i,s,n) for(int i=int(s);i<int(n);i++)\n#define forn(i,n) forsn(i,0,n)\n#define all(a) a.begin(),a.end()\n#define si(a) int((a).size())\n#define pb emplace_back\n#define mp make_pair\n#define snd second\n#define fst first\nusing pii = pair<int,int>;\nusing vi = vector<int>;\nusing ll = long long;\n\nvi node;\nvector<vi> g;\nvector<bool> v;\n\nint sum(int n){\n    v[n] = true;\n    int s = node[n];\n    for(int i : g[n]) if(!v[i]) s += sum(i);\n    return s;\n}\n\nint main() {\n\tfastio;\n\t\n    string s; cin >> s;\n    int n = si(s), sd = n+1, sn = (sd+1)/2;\n    vi d(sd);\n    s = 'a'+s+'a';\n    node = vi(sn), g.resize(sn), v.resize(sn);\n\n    forn(i,sd) d[i] = (26+s[i]-s[i+1]) % 26;\n    forn(i,sd/2) node[i] = (52-d[i]-d[sd-i-1]) % 26; \n    if(sd & 1) node[sd/2] = (26-d[sd/2]) % 26;\n\n    int m; cin >> m;\n    forn(i,m){\n        int x,y; cin >> x >> y; x--;\n        if(x >= sd/2) x = sd-x-1;\n        if(y >= sd/2) y = sd-y-1;\n        g[x].pb(y), g[y].pb(x);\n    }\n    bool ok = true;\n    forn(i,sn) if(!v[i] && sum(i) % 26 != 0) ok = false;\n    cout << (ok ? \"YES\" : \"NO\") << endl;  \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define N 100005\n\nchar str[N]; int len, mid;\nstd::pair<int, int> ops[N]; int opcnt;\n\ninline void merge_ops()\n{\n\tstatic std::priority_queue<int, std::vector<int>, std::greater<int>> rs[N];\n\tfor(int i = 0; i < opcnt; ++i)\n\t\trs[ops[i].first].push(ops[i].second);\n\n\topcnt = 0;\n\tfor(int l = 1; l <= mid; ++l)\n\t{\n\t\tauto &cur = rs[l];\n\t\tif(cur.empty()) continue;\n\n\t\tint r = cur.top(); cur.pop();\n\t\tops[opcnt++] = std::make_pair(l, r);\n\n\t\tauto &dest = rs[r + 1];\n\t\tif(cur.size() < dest.size()) //启发式合并\n\t\t\twhile(!cur.empty())\n\t\t\t{\n\t\t\t\tdest.push(cur.top());\n\t\t\t\tcur.pop();\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\twhile(!dest.empty())\n\t\t\t{\n\t\t\t\tcur.push(dest.top());\n\t\t\t\tdest.pop();\n\t\t\t}\n\t\t\tdest.swap(cur);\n\t\t}\n\t}\n}\n\ninline bool solve()\n{\n\tstatic int pre[N]; //差分化\n\tpre[0] = 0;\n\tpre[1] = str[1] - 'a';\n\tfor(int i = 2; i <= mid; ++i)\n\t{\n\t\tpre[i] = str[i] - str[i - 1];\n\t\tpre[i] = (pre[i] + 26) % 26;\n\t}\n\n\tint k = 1;\n\tfor(int o = 0; o < opcnt; ++o)\n\t{\n\t\tconst std::pair<int, int> &cur = ops[o];\n\t\tfor(; k <= cur.first; ++k)\n\t\t{\n\t\t\tpre[k] += pre[k - 1];\n\t\t\tpre[k] = (pre[k] + 26) % 26;\n\t\t}\n\t\tint d = int(str[len - cur.first + 1]) - pre[cur.first] - 'a';\n\t\tpre[cur.first] += d;\n\t\tpre[cur.first] = (pre[cur.first] + 26) % 26;\n\t\tpre[cur.second + 1] -= d;\n\t\tpre[cur.second + 1] = (pre[cur.second + 1] + 26) % 26;\n\t}\n\tfor(; k <= mid; ++k)\n\t{\n\t\tpre[k] += pre[k - 1];\n\t\tpre[k] = (pre[k] + 26) % 26;\n\t}\n\n\tfor(int i = 1; i <= mid; ++i)\n\t{\n\t\tif(pre[i] != str[len - i + 1] - 'a')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint _;\n\tscanf(\"%s%d\", str + 1, &_);\n\tlen = strlen(str + 1);\n\tmid = len >> 1;\n\n\topcnt = 0;\n\tfor(int i = 0; i < _; ++i)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif(l - 1 > (len - r))\n\t\t{\n\t\t\tl = len - l + 1;\n\t\t\tr = len - r + 1;\n\t\t\tstd::swap(l, r);\n\t\t}\n\t\tif(r > mid) r = len - r;\n\n\t\tif(l <= r)\n\t\t\tops[opcnt++] = std::make_pair(l, r);\n\t}\n\n\tmerge_ops();\n\n\tif(solve()) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\nabc\n1\n2 2\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=80000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nstring s;\nstring L,R;\n\nvector<int> bound[maxn];\n\npii itv[maxn];\n\nint d[maxn];\nint tg[maxn];\nint main()\n{\n\tIOS;\n  cout<<\"YES\\n\";\n  return 0;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>itv[i].F>>itv[i].S;\n\tREP(i,n) itv[i].F--;\n\n\tREP(i,n){\n\t\titv[i].F=min(itv[i].F,SZ(s)-itv[i].F);\n\t\titv[i].S=min(itv[i].S,SZ(s)-itv[i].S);\n\t\tif(itv[i].F>itv[i].S) swap(itv[i].F,itv[i].S);\n\t}\n\tfor(int i=0;i<SZ(s)/2;i++) L.pb(s[i]);\n\tfor(int i=0;i<SZ(s)/2;i++) R.pb(s[SZ(s)-1-i]);\n\n\tREP(i,n) bound[itv[i].F].pb(itv[i].S);\n\tREP(i,SZ(s)/2){\n\t\tSORT_UNIQUE(bound[i]);\n\t\tfor(int j=1;j<SZ(bound[i]);j++){\n\t\t\tbound[bound[i][j-1]].pb(bound[i][j]);\n\t\t}\n\t\twhile(SZ(bound[i])>1) bound[i].pop_back();\n\t}\n\t// REP(i,SZ(s)/2){\n\t// \tfor(int j:bound[i]) cout<<j<<' ';\n\t// \tcout<<'\\n';\n\t// }\n\t// cout<<L<<' '<<R<<'\\n';\n\tREP(i,SZ(s)/2){\n\t\td[i]=(L[i]-R[i]+26)%26;\n\t}\n\t// REP(i,SZ(s)/2) cout<<d[i]<<\" \\n\"[i==SZ(s)/2-1];\n\tint dd=0;\n\tfor(int i=0;i<SZ(s)/2;i++){\n\t\tdd+=tg[i];\n\t\tdd=(dd%26+26)%26;\n\t\td[i]+=dd;\n\t\td[i]%=26;\n\n\t\tif(SZ(bound[i])){\n\t\t\tint tmp=26-d[i];\n\t\t\td[i]+=tmp;\n\t\t\td[i]%=26;\n\t\t\tdd+=tmp;\n\t\t\ttg[bound[i][0]]-=tmp;\n\t\t}\n\t}\n\tREP(i,SZ(s)/2) if(d[i]){\n\t\tcout<<\"NO\\n\";\n\t\treturn 0;\n\t}\n\tcout<<\"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct dsu {\n  int cc;\n  vector<int> p, sz, a;\n  dsu(int n) : cc(n), p(n, -1), sz(n, 1), a(n) {}\n  int root(int v) const {\n    while (p[v] != -1) v = p[v];\n    return v;\n  }\n  bool unite(int u, int v) {\n    u = root(u), v = root(v);\n    if (u == v) return false;\n    --cc;\n    if (sz[u] < sz[v]) swap(u, v);\n    p[v] = u;\n    sz[u] += sz[v];\n    a[u] += a[v];\n    return true;\n  }\n  bool same(int u, int v) const { return root(u) == root(v); }\n  int size(int v) const { return sz[root(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  int n = s.size() / 2;\n  int m;\n  cin >> m;\n  vector<pair<int, int>> es;\n  while (m--) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    if (s.size() & 1) {\n      l -= l > n;\n      r -= r > n;\n    }\n    if (l < n and n < r) {\n      if (n - l > r - n) {\n        r = 2 * n - r;\n      } else if (n - l < r - n) {\n        l = 2 * n - l;\n      } else {\n        continue;\n      }\n    }\n    if (n <= l) {\n      tie(l, r) = make_pair(2 * n - r, 2 * n - l);\n    }\n    es.emplace_back(l, r);\n  }\n  if (s.size() & 1) {\n    s.erase(begin(s) + n);\n  }\n  dsu d(n + 1);\n  for (int v = 0; v <= n; ++v) {\n    int goal = (v < n ? s[2 * n - v - 1] : 'a') - (v ? s[2 * n - v] : 'a');\n    int cur = (v < n ? s[v] : 'a') - (v ? s[v - 1] : 'a');\n    d.a[v] = goal - cur + 260;\n  }\n  for (auto e : es) {\n    d.unite(e.first, e.second);\n  }\n  for (int v = 0; v <= n; ++v) {\n    if (d.a[d.root(v)] % 26) {\n      cout << \"NO\\n\";\n      exit(0);\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) {string s; ist >> s; return ist;}\nbool Inside(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* E mondai*/\n\nstring s;\nint N;\nint L[100000], R[100000];\nvector<IntMod<26>> ss;\n\nvoid Add(int i, int j, IntMod<26> val) {\n\tss[i] += val;\n\tss[j] -= val;\n}\n\nint main() {\n\tcin >> s >> N;\n\tREP(i, 0, N) {\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t\tif (L[i] > s.size() / 2) L[i] = s.size() - L[i];\n\t\tif (R[i] > s.size() / 2) R[i] = s.size() - R[i];\n\t\tif (L[i] > R[i]) swap(L[i], R[i]);\n\t}\n\n\tREP(i, 0, s.size() / 2) {\n\t\tss.push_back(s[s.size() - i - 1] - s[i]);\n\t}\n\tss.push_back(0);\n\tadjacent_difference(ss.begin(), ss.end(), ss.begin());\n\n\tPriorityQ<PP> Q;\n\tREP(i, 0, N) {\n\t\tQ.push(PP(L[i], R[i]));\n\t}\n\t\n\tPP prev(-1, 0);\n\twhile (!Q.empty()) {\n\t\tPP p = Q.top(); Q.pop();\n\t\tif (p.first == p.second) continue;\n\t\tif (prev.first == p.first) {\n\t\t\tQ.push(PP(prev.second, p.second));\n\t\t\tcontinue;\n\t\t}\n\t\tAdd(p.first, p.second, -ss[p.first]);\n\t\tprev = p;\n\t}\n\tYESNO(all_of(ss.begin(), ss.end(), [](IntMod<26> i) {return i == 0; }));\n\treturn 0;\n}\n\n/*-------------------------*/\n/*-----    二分探索   -----*/\n/*-------------------------*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\tini[nuevo.first].insert(nuevo.second);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = ini[i].size();\n\t\tauto it = ini[i].begin();\n\t\tif(sz == 1){\n\t\t\tfin[*it].insert(i);\n\t\t}else if(sz > 1){\n\t\t\tLong ant = i;\n\t\t\twhile(it != ini[i].end()){\n\t\t\t\tif(ant != i){\n\t\t\t\t\tini[ant].insert(*it);\n\t\t\t\t}\n\t\t\t\tfin[*it].insert(ant);\n\t\t\t\tant = *it + 1;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<Long,Long> > rangos;\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = fin[i].size();\n\t\tauto it = fin[i].begin();\n\t\tif(sz == 1){\n\t\t\trangos.push_back({*it,i});\n\t\t}else if(sz > 1){\n\t\t\tLong ant = *it;\n\t\t\twhile(it != fin[i].end()){\n\t\t\t\tit++;\n\t\t\t\tif(it == fin[i].end()){\n\t\t\t\t\trangos.push_back({ant,i});\n\t\t\t\t}else{\n\t\t\t\t\trangos.push_back({ant,*it-1});\n\t\t\t\t\tant = *it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(rangos.begin(),rangos.end());\n\t\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n//asd\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nll K = 2;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk[N];\nll ha[N];\nint len;\n\nbool check()\n{\n    degk[0] = 1;\n    for (int i = 1; i < N; i++) degk[i] = degk[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degk[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degk[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    //for (int i = 0; i < len; i++) cout << x[i] << \" \"; cout << \"\\n\";\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) return 0;\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) return 0;\n    return 1;\n}\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    if (check()) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,pair<LL,LL> >, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nconst LL MOD =  1e9 + 7;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A % MOD;\n\t\tA = A * A % MOD;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, {0, 0}}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tLL total4 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(7703, id);\n\t\t\tLL po3 = fast(1277, id);\n\t\t\tLL po4 = fast(2927, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3, total4 += po4;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total3 -= po3, total4 += po4;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, {total3, total4}}) == ms.end()) ms[{total, {total3, total4}}] = i;\n\t\tpar[i] = ms[{total, {total3, total4}}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,pair<LL,LL> >, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A;\n\t\tA = A * A;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, 0}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tLL total4 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(7703, id);\n\t\t\tLL po3 = fast(1277, id);\n\t\t\tLL po4 = fast(2927, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3, total4 += po4;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total3 -= po3, total4 += po4;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, {total3, total4}}) == ms.end()) ms[{total, {total3, total4}}] = i;\n\t\tpar[i] = ms[{total, {total3, total4}}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UF {\n\tvector<int> p;\n\tUF(int n) : p(n, -1) {}\n\tint find(int a) {\n\t\treturn p[a] < 0 ? a : (p[a] = find(p[a]));\n\t}\n\tbool join(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return false;\n\t\tif (-p[a] < -p[b]) swap(a, b);\n\t\tp[a] += p[b];\n\t\tp[b] = a;\n\t\treturn true;\n\t}\n};\n\nstring s;\nint n;\nint m;\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tcin >> s;\n\tn = int(s.size());\n\ts = \"a\" + s + \"a\";\n\tvector<int> diffs(n+1);\n\tfor (int i = 0; i <= n; i++) {\n\t\tdiffs[i] = int(s[i+1] - s[i]);\n\t}\n\n\tUF uf(n+1);\n\tfor (int i = 0; i <= n; i++) uf.join(i, n-i);\n\tcin >> m;\n\tfor (int j = 0; j < m; j++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tuf.join(l, r);\n\t}\n\tvector<int> tot(n+1, 0);\n\tfor (int i = 0; i <= n; i++) {\n\t\ttot[uf.find(i)] += diffs[i];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tif (uf.find(i) != i) continue;\n\t\tif (tot[i] % 26 != 0) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\texit(0);\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nusing ld = long double;\nll INF = LLONG_MAX;\n\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid print() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); \n\t}\n}\n\nusing namespace output;\n\ntemplate<class T> struct Seg { \n\tconst T ID = 0; // comb(ID,b) must equal b\n\tT combine(T a, T b) { return (a+b)%26;} \n\tint n; vector<T> seg;\n\tvoid init(int _n) { n = _n; seg.assign(2*n,ID);}\n\n\tvoid update(int p, T value) {\t// set value at position p\n\t\tseg[p += n] += value;\n\t\tfor (p /= 2; p; p /= 2) seg[p] = combine(seg[2*p], seg[2*p+1]);\n\t}\n    \n\tT query(int l, int r) {\t // sum on interval [l, r]\n\t\tT ra = ID, rb = ID; \n\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {\n\t\t\tif (l&1) ra = combine(ra,seg[l++]);\n\t\t\tif (r&1) rb = combine(seg[--r],rb);\n\t\t}\n\t\treturn combine(ra,rb);\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring S; cin >> S;\n\tint N; cin >> N;\n\tvector<vi> startsAt (S.size()+1);\n\tvector<vi> endsAt (S.size()+1);\n\tF0R(i, N) {\n\t\tint l, r; cin >> l >> r; --l; --r;\n\t\tstartsAt[l].push_back(r+1); // orig\n\t\tif (l+1 == S.size()-r) {\n\n\t\t} else if (l+1 < S.size()-r) {\n\t\t\tstartsAt[r+1].push_back(S.size()-l);\n\t\t} else {\n\t\t\tstartsAt[S.size()-r-1].push_back(l);\n\t\t}\n\t}\n\n\tF0R(i, S.size()+1) {\n\t\tsort(startsAt[i].begin(), startsAt[i].end());\n\t\tfor (int j = 1; j < startsAt[i].size(); ++j) {\n\t\t\tif (startsAt[i][j] != startsAt[i][j-1]) startsAt[startsAt[i][j-1]].push_back(startsAt[i][j]);\n\t\t}\n\t\tif (startsAt[i].size()) startsAt[i] = vi {startsAt[i][0]};\n\t\tfor (int j : startsAt[i]) endsAt[j].push_back(i);\n\t}\n\n\tstartsAt.assign(S.size() + 1, vi {});\n\n\tR0F(i, S.size()+1) {\n\t\tsort(endsAt[i].begin(), endsAt[i].end());\n\t\tfor (int j = 0; j+1 < endsAt[i].size(); ++j) {\n\t\t\tif (endsAt[i][j] != endsAt[i][j+1]) endsAt[endsAt[i][j+1]].push_back(endsAt[i][j]);\n\t\t}\n\t\tif (endsAt[i].size()) endsAt[i] = vi {endsAt[i].back()};\n\t\tfor (int j : endsAt[i]) startsAt[j].push_back(i);\n\t}\n\n\tSeg<int> seg; seg.init(S.size());\n\tint sum = 0;\n\tF0R(i, S.size()) {\n\t\tseg.update(i, S[i]-'a');\n\t}\n\n\n\tfor (int l = 0; l < S.size() / 2; ++l) {\n\t\tint lc = seg.query(0, l) - ((l != 0) ? seg.query(0, l-1) : 0); lc = (lc + 26) % 26;\n\t\tint rc = seg.query(0, S.size()-l-1) - seg.query(0, S.size()-l-2); rc = (rc + 26) % 26;\n\t\tif (rc != lc) {\n\t\t\tif (startsAt[l].size() && (startsAt[l][0] <= S.size()-l-1)) {\n\t\t\t\tint cycle = (rc - lc + 26) % 26;\n\t\t\t\tseg.update(l, cycle);\n\t\t\t\tseg.update(startsAt[l][0], -cycle);\n\t\t\t} else {\n\t\t\t\tprint(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\n\t}\n\tprint(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nint main(){\n  char s[SIZE];\n  int n,m;\n  int l[SIZE],r[SIZE],p[SIZE];\n  vector<int> cc[SIZE];\n  \n  scanf(\"%s%d\",s,&m);\n  n = strlen(s);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",l+i,r+i);\n    l[i]--; r[i]--;\n    \n    if(n%2 == 0){\n      if(l[i] <= n/2-1 && n/2 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - n/2 + 1;\n        \n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if (a > b){\n          l[i] = n/2 - a;\n          r[i] = n/2 - b - 1;\n        }else{\n          l[i] = n/2 - b;\n          r[i] = n/2 - a - 1;\n        }\n      }\n    }else{\n      if(l[i] <= n/2-1 && n/2 <= r[i]){\n        int a = n/2-1 - l[i];\n        int b = r[i] - n/2-1;\n\n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if(a > b){\n          l[i] = n/2-1 - a;\n          r[i] = n/2-1 - b - 1;\n        }else{\n          l[i] = n/2-1 - b;\n          r[i] = n/2-1 - a - 1;\n        }\n      }\n    }\n\n    if(n/2 <= l[i]){\n      l[i] = n - l[i] - 1;\n      r[i] = n - r[i] - 1;\n    }\n\n    if(l[i] != -1){\n      cc[l[i]].push_back(r[i]);\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    if(cc[i].size() > 1)\n      sort(cc[i].begin(),cc[i].end());\n\n    for(int j=cc[i].size()-2;j>=0;j--){\n      if(cc[i][j] != cc[i][j+1])\n        cc[cc[i][j]+1].push_back(cc[i][j+1]);\n    }\n  }\n\n  SegTree seg(n);\n  \n  for(int i=0;i<n/2;i++){\n    seg.add(i, i, 26 + s[n-i-1] - s[i]);\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size()){\n      int q = seg.query(i,i);\n      seg.add(i, cc[i][0], 26-q);\n    }\n\n    if(seg.query(i,i)%26){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n\n  puts(\"YES\");\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\n#define fore(i,a,b) for(int i=a,ggdem=b;i<ggdem;i++)\n#define FIN ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(),a.end()\n#define pb push_back\n#define fst first\n#define snd second\nconst int MAXN=1<<20;\nstring s;\nint n,len,l[MAXN],r[MAXN],vis[MAXN];\nvector<int>g[MAXN],diff;\n\nint dfs(int x) {\n\tif(vis[x])return 0;\n\tvis[x]=1;\n\tint take=0;\n\tfor(int i:g[x])take=(take+dfs(i))%26;\n\tint a=(diff[x]+diff[len-x-1]+take+26)%26;\n\t// cout<<x<<\" : \"<<take<<\" \"<<a<<endl;\n\treturn a;\n}\n\nint main() {FIN;\n\tcin>>s>>n;s=\"a\"+s+\"a\";len=SZ(s)-1;\n\tfore(i,1,SZ(s))diff.pb((s[i]-s[i-1]+26)%26);\n\t// for(int i:diff)cout<<i<<\" \";cout<<endl;\n\tfore(i,0,len)g[i].pb(len-i-1);\n\tfore(i,0,n){\n\t\tint l,r;cin>>l>>r;\n\t\tg[l-1].pb(r);\n\t\tg[r].pb(l-1);\n\t}\n\tfore(i,0,len)if(dfs(i))return!(cout<<\"NO\"<<endl);\n\tcout<<\"YES\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\nchar S_[101010];\nint N, L[101010], R[101010];\nint S[101010];\nint D[101010];\n\nconst int W = 26;\n\nint uf[101010];\nint root(int p)\n{\n    return uf[p] < 0 ? p : (uf[p] = root(uf[p]));\n}\nvoid join(int p, int q)\n{\n    p = root(p); q = root(q);\n    if (p == q) return;\n    uf[p] += uf[q];\n    uf[q] = p;\n}\n\nvector<int> grps[101010];\n\nstruct data\n{\n    int sum;\n    set<int> *pos, *neg;\n\n    int toppos() const {\n        if (pos->empty()) return 1000000;\n        return *(pos->begin());\n    }\n    int topneg() const {\n        if (neg->empty()) return 1000000;\n        return *(neg->begin());\n    }\n    int top() const {\n        return min(toppos(), topneg());\n    }\n    int size() const {\n        return pos->size() + neg->size();\n    }\n    bool isneg() const {\n        int a = toppos();\n        int b = topneg();\n        return a > b;\n    }\n    data(int sum, set<int> *pos, set<int> *neg) : sum(sum), pos(pos), neg(neg) {}\n};\n\ninline bool operator<(const data& a, const data& b) {\n    return a.top() < b.top() || (a.top() == b.top() && (i64)a.pos < (i64)b.pos);\n}\n\nset<data> eqs;\n\nvoid waf(set<int> *pos, set<int> *neg, int v)\n{\n    // add v as positive\n    if (neg->count(v)) {\n        neg->erase(v);\n    } else {\n        pos->insert(v);\n    }\n}\n\ndata mgr(data a, data b)\n{\n    if (a.size() < b.size()) swap(a, b);\n    bool an = a.isneg(), bn = b.isneg();\n    bool neg = an == bn;\n    if (neg) {\n        a.sum = (a.sum + W - b.sum) % W;\n        for (int p : *b.neg) {\n            waf(a.pos, a.neg, p);\n        }\n        for (int p : *b.pos) {\n            waf(a.neg, a.pos, p);\n        }\n    } else {\n        a.sum = (a.sum + b.sum) % W;\n        for (int p : *b.pos) {\n            waf(a.pos, a.neg, p);\n        }\n        for (int p : *b.neg) {\n            waf(a.neg, a.pos, p);\n        }\n    }\n    return a;\n}\n\nvoid show(const data& d) {\n    printf(\"s=%d pos=\", d.sum);\n    for (int p : *d.pos) printf(\"%d,\", p);\n    printf(\" neg=\");\n    for (int p : *d.neg) printf(\"%d,\", p);\n    puts(\"\");\n}\n\nint main()\n{\n    scanf(\"%s%d\", S_, &N);\n    int M = strlen(S_);\n    for (int i = 0; i < M + 3; ++i) uf[i] = -1;\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d%d\", L + i, R + i);\n        --L[i];\n\n        join(L[i], R[i]);\n    }\n    S[0] = S[M + 2] = 0;\n    for (int i = 0; i < M; ++i) S[i + 1] = S_[i] - 'a';\n\n    for (int i = 0; i <= M; ++i) {\n        D[i] = (S[i + 1] - S[i] + W) % W;\n    }\n    M += 1;\n    for (int i = 0; i < M; ++i) {\n    //\tprintf(\"%d\\n\", D[i]);\n        grps[root(i)].push_back(i);\n    }\n    for (int i = 0; i < M; ++i) if (grps[i].size() > 0) {\n        int sum = 0;\n        set<int> *pos = new set<int>, *neg = new set<int>;\n        for (int p : grps[i]) {\n            if (p * 2 + 1 == M) {\n                sum = (sum + D[p]) % W;\n                continue;\n            }\n            if (p >= M / 2) {\n                waf(neg, pos, M - 1 - p);\n                sum = (sum + D[p]) % W;\n            }\n            else {\n                waf(pos, neg, p);\n                sum = (sum + D[p]) % W;\n            }\n        }\n        eqs.insert(data(sum, pos, neg));\n    }\n    while (!eqs.empty()) {\n        data top = *(eqs.begin());\n        eqs.erase(eqs.begin());\n\n        if (top.top() == 1000000) {\n            if (top.sum != 0) {\n                puts(\"NO\");\n                return 0;\n            }\n            continue;\n        }\n        if (eqs.empty()) break;\n        if (eqs.begin()->top() != top.top()) {\n            continue;\n        }\n        data top2 = *(eqs.begin());\n        eqs.erase(eqs.begin());\n        data nw = mgr(top, top2);\n        eqs.insert(nw);\n    }\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x + 1 == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nset<int> st;\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tstring ns = \"\";\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] >= mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n//\t\t\tcout<<\"OP3 \"<<i<<\" \"<<mini<<\" \"<<maxi - 1<<endl;\n\t\t}\n\t}\n\tn = mid;\n\tms[st] = -1;\n\tint total = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) st.insert(id);\n\t\t\telse st.erase(id);\n\t\t}\n\t\tif(ms[st] == 0) ms[st] = i + 1;\n\t\tpar[i] = ms[st];\n//\t\tcout<<\"CHECKPAR \"<<i<<\" \"<<par[i]<<endl;\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') bisa = false;\n\t\tint x = find(i);\n//\t\tcout<<\"PRINT \"<<i<<\" \"<<par[i]<<\" \"<<x<<endl;\n\t\tif(x != i + 1) {\n\t\t\tif(ns[i] != ns[x - 1]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n            int minr = *segs[i].begin();\n            segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<ll, ll>  ii;\ntypedef vector<ll>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst ll INF = ll(1e9 + 7);\n\nconst ll tam = 100010;\n\nvector<ll> G[tam];\nll val[tam];\nbool vis[tam];\n\nll sum;\nvoid dfs(ll v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (ll u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    ll n;\n    cin >> n;\n    for (ll i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    if (s.size() == 1)\n    {\n    \tcout << \"YES\" << '\\n';\n    \treturn 0;\n    }\n    s = \"a\" + s + \"a\";\n\n    //cout << s << endl;\n\tfor (ll i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \t//cout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    //cout << endl;\n\n    for (ll i = 0; i < n; i++)\n    {\n    \t//val[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \t//val[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = false;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!!!!"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]==kk);\n\t\t\telse if(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i] = a[i+1]-a[i];\n\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t}\n\tbool f = true;\n\tvector<vector<int> > v(n2+1);\n\trep(i, n2+1) v[uf.find(i)].push_back(i);\n\trep(i, n2){\n\t\tif(v[i].empty()) continue;\n\t\tll x = 0;\n\t\tbool g = false;\n\t\trep(j, v[i].size()){\n\t\t\tx += t[v[i][j]];\n\t\t\t//if(v[i][j]==n2) g = true;\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAXN = 1e6+10;\nchar s[MAXN];\nint a[MAXN],N,M;\nstruct node {\n    int to,next;\n}E[MAXN * 10];\n\nint head[MAXN],sumE,sum;\nbool vis[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\n#define read(x) scanf(\"%d\",&x)\nvoid Init() {\n    scanf(\"%s\",s + 1);\n    N = strlen(s + 1);\n    s[0] = 'a';s[N + 1] = 'a';\n    for(int i = 1 ; i <= N + 1; ++i) a[i] = (s[i] - s[i - 1] + 26) % 26;\n    read(M);\n    int L,R;\n    for(int i = 1 ; i <= M ; ++i) {\n    read(L);read(R);\n    add(L,R + 1);add(R + 1,L);\n    }\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n    add(i,N + 2 - i),add(N+2-i,i);\n    }\n}\nvoid dfs(int u) {\n    vis[u] = 1;\n    sum = (sum + a[u]) % 26;\n    for(int i = head[u] ; i ; i = E[i].next) {\n    int v = E[i].to;\n    if(!vis[v]) {\n        dfs(v);\n    }\n    }\n}\nvoid Solve() {\n    bool flag = 1;\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n    if(!vis[i]) {\n        sum = 0;\n        dfs(i);\n        if(sum != 0) {flag = 0;break;} \n    }\n    }\n    if(flag) puts(\"YES\");\n    else puts(\"NO\");\n}\nint main() {\n    Init();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e6+5;\nint lowbit(int x){return x&(-x);}\nint arr[MAXN];\ninline int sum(int x){int res=0;while(x)res+=arr[x],x-=lowbit(x);return res;}\ninline void add(int x,int n){while(x<MAXN)arr[x]+=n,x+=lowbit(x);}\ninline int update(int x,int y,int n){add(x,n);add(y+1,-n);}\nstruct node{\n    int a,b;\n    bool operator < (const node&p)const{\n        return a==p.a ? b > p.b : a > p.a;\n    }\n};\npriority_queue<node> q;\n\nint f[MAXN];\nstring s;\n//char s[MAXN];\nint a[MAXN];\nint main()\n{\n    memset(f,-1,sizeof f);\n    int x,n,l,r;\n    cin>>s;\n    s=\"0\"+s;\n    //scanf(\"%s\",&s+1);\n    int len = s.length();\n\n    //printf(\"%s\\n\",s);\n    //cout<<s<<endl;\n    //cout<<\"len:\"<<len<<endl;\n    for(int i=1;i<=len/2;i++){\n        update(i,i,s[i] - s[len-i]);\n    }\n    cin>>n;\n    int ll = len / 2;\n    //cout<<\"ll: \"<<ll<<endl;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        //cout<<l<<\"|\"<<r<<endl;\n        if(r <= ll)\n            q.push(node{l,r});\n        else if(l <= ll){\n            //l += ll - l + 1;\n            if(l+r == len)continue;\n            if(abs(ll-l)>abs(r-ll))\n            {\n                q.push(node{l,len-r-1});\n            }\n            else\n                q.push(node{len-r,l-1});\n\n            //q.push(node{ll - max(abs(ll-l),abs(ll-r)), ll - min(abs(ll-l),abs(ll-r))});\n        }\n        else{\n            q.push(node{len-r,len-l});\n        }\n    }\n    /*while(!q.empty()){\n        node now = q.top();\n        //qq.push(now);\n        cout<<now.a<<\"-\"<<now.b<<endl;\n        q.pop();\n    }*/\n    node now,pre = q.top();\n    //qq.push(pre);\n    while(!q.empty()){\n        if(q.size() > 10000000)break;\n        now = q.top();\n        //cout<<now.a<<\" | \"<<now.b<<endl;\n        if(pre.a < now.a){\n            if(pre.a>0 && pre.b>0)\n            f[pre.a] = pre.b;\n            pre = now;\n            continue;\n        }\n        q.pop();\n        if(pre.b == now.b)continue;\n        else{\n            q.push(node{pre.b+1, now.b});\n        }\n    }\n    f[pre.a] = pre.b;\n    //qq.push(pre);\n    /*while(!qq.empty()){\n        node now = qq.front();\n        qqq.push(now);\n        cout<<now.a<<\" \"<<now.b<<endl;\n        qq.pop();\n    }*/\n    bool flag = 1;\n    if(len%2==0)len--;\n    for(int i=1;i<=len/2;i++){\n\n        //now = qq.front();\n        x = sum(i) - sum(i-1);\n        x%=26;\n        //cout<<\"*\"<<x<<\"  \"<<i<<\" \"<<f[i]<<endl;\n        if(x == 0)continue;\n        if(f[i] != -1){\n            //qq.pop();\n            update(i,f[i], -x);\n        }\n        else{\n            flag = 0;\n            break;\n        }\n        //cout<<\"**\"<<sum(i) - sum(i-1)<<endl;\n    }\n    if(flag)\n        cout<<\"YES\\n\";\n    else\n        cout<<\"NO\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=1e5+5;\nchar s[N];int fa[N],b[N],sum[N],vis[N],n,m;\ninline int val(R int x){return x<0?x+26:x;}\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfp(i,1,n+1)s[i]-='a',fa[i]=i;\n\ts[n+1]=0;\n\tscanf(\"%d\",&m);\n\tfor(R int i=1,l,r;i<=m;++i)scanf(\"%d%d\",&l,&r),fa[find(r+1)]=find(l);\n\tfp(i,1,n+1)b[i]=val(s[i]-s[i-1]);\n\tfp(i,1,(n+1)>>1)fa[find(n+2-i)]=find(i);\n//\tfp(i,1,n+1)printf(\"%d \",b[i]);\n//\tputs(\"\");\n\tfp(i,1,n+1)sum[find(i)]+=b[i];\n\tif((n+1)&1^1)vis[find((n+2)>>1)]=1;\n\tfp(i,1,n+1)if(i==find(i)&&sum[i]%26)\n\t\tif(!vis[i])return puts(\"NO\"),0;\n\tputs(\"YES\");\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n\nusing namespace std;\n\nint pare[100010];\nint num[100010];\n\nint root(int x){\n    if(pare[x]<0)return x;\n    return pare[x]=root(pare[x]);\n}\n\nvoid unite(int x,int y){\n    x = root(x);\n    y = root(y);\n    if(x == y)return;\n    if(pare[y] < pare[x])swap(x,y);\n    pare[x]+=pare[y];\n    num[x]=(num[x]+num[y])%26;\n    pare[y]=x;\n}\n\nbool issame(int x,int y){\n    return root(x)==root(y);\n}\n\nint main(){\n\n    string s;cin>>s;\n\n    num[0]=s[0]-'a';\n    num[s.size()]=('a' +26 - s[s.size()-1])%26;\n    REP(i,s.size()-1){\n        num[i+1]=(s[i+1]-s[i]+26)%26;\n    }\n\n\n    REP(i,s.size()+1)pare[i]=-1;\n\n    REP(i,s.size()+1){\n        unite(i,s.size()-i);\n    }\n\n    int n;cin>>n;\n    REP(i,n){\n        int l,r;cin>>l>>r;\n        unite(l-1,r);\n    }\n\n//    REP(i,s.size()+1){\n//        cout<<root(i)<<endl;\n//        cout<<num[root(i)]<<endl;\n//        cout<<endl;\n//    }\n\n    REP(i,s.size()+1)if(num[root(i)]%26 != 0){\n            cout<<\"NO\"<<endl;\n            return 0;\n        }\n    cout<<\"YES\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 999999999999989LL;\nconst ll K1 = 2;\nconst ll K2 = 3;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk1[N], degk2[N];\nll ha1[N], ha2[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degk1[0] = 1;\n    degk2[0] = 1;\n    for (int i = 1; i < N; i++) degk1[i] = degk1[i - 1] * K1 % MOD;\n    for (int i = 1; i < N; i++) degk2[i] = degk2[i - 1] * K2 % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha1[l[i]] = (ha1[l[i]] + degk1[i]) % MOD;\n            ha1[r[i] + 1] = (ha1[r[i] + 1] + MOD - degk1[i]) % MOD;\n            ha2[l[i]] = (ha2[l[i]] + degk2[i]) % MOD;\n            ha2[r[i] + 1] = (ha2[r[i] + 1] + MOD - degk2[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha1[i] = (ha1[i - 1] + ha1[i]) % MOD;\n        ha2[i] = (ha2[i - 1] + ha2[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<pair<ll, ll>, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[{ha1[i], ha2[i]}].insert(x[i]);\n        if (val[{ha1[i], ha2[i]}].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[{0, 0}].size() && *(val[{0, 0}].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\t//printf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//for(set<S>::iterator it=st.begin();it!=st.end();it++)\n\t//\tprintf(\"%lld %lld\\n\",it->s,it->e);\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(st.empty()) break;\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()) break;\n\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\tS temp2=*it;\n\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\tst.erase(temp2); \n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!st.empty()&&st.begin()->s==i)\n\t\t\t{\n\t\t\t\tS range=*(st.begin());\n\t\t\t\tst.erase(st.begin());\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tif(st.empty()) break;\n\t\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\t\tif(it==st.end()) break;\n\t\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\t\tS temp2=*it;\n\t\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\t\tst.erase(temp2); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nchar S_[101010];\nint N, L[101010], R[101010];\nint S[101010];\nint D[101010];\n\nconst int W = 26;\n\nint uf[101010];\nint root(int p)\n{\n\treturn uf[p] < 0 ? p : (uf[p] = root(uf[p]));\n}\nvoid join(int p, int q)\n{\n\tp = root(p); q = root(q);\n\tif (p == q) return;\n\tuf[p] += uf[q];\n\tuf[q] = p;\n}\n\nvector<int> grps[101010];\n\nstruct data\n{\n\tint sum;\n\tset<int> *pos, *neg;\n\n\tint toppos() const {\n\t\tif (pos->empty()) return 1000000;\n\t\treturn *(pos->begin());\n\t}\n\tint topneg() const {\n\t\tif (neg->empty()) return 1000000;\n\t\treturn *(neg->begin());\n\t}\n\tint top() const {\n\t\treturn min(toppos(), topneg());\n\t}\n\tint size() const {\n\t\treturn pos->size() + neg->size();\n\t}\n\tbool isneg() const {\n\t\tint a = toppos();\n\t\tint b = topneg();\n\t\treturn a > b;\n\t}\n\tdata(int sum, set<int> *pos, set<int> *neg) : sum(sum), pos(pos), neg(neg) {}\n};\n\ninline bool operator<(const data& a, const data& b) {\n\treturn a.top() < b.top();\n}\n\nset<data> eqs;\n\nvoid waf(set<int> *pos, set<int> *neg, int v)\n{\n\t// add v as positive\n\tif (neg->count(v)) {\n\t\tneg->erase(v);\n\t} else {\n\t\tpos->insert(v);\n\t}\n}\n\ndata mgr(data a, data b)\n{\n\tif (a.size() < b.size()) swap(a, b);\n\tbool an = a.isneg(), bn = b.isneg();\n\tbool neg = an == bn;\n\tif (neg) {\n\t\ta.sum = (a.sum + W - b.sum) % W;\n\t\tfor (int p : *b.neg) {\n\t\t\twaf(a.pos, a.neg, p);\n\t\t}\n\t\tfor (int p : *b.pos) {\n\t\t\twaf(a.neg, a.pos, p);\n\t\t}\n\t} else {\n\t\ta.sum = (a.sum + b.sum) % W;\n\t\tfor (int p : *b.pos) {\n\t\t\twaf(a.pos, a.neg, p);\n\t\t}\n\t\tfor (int p : *b.neg) {\n\t\t\twaf(a.neg, a.pos, p);\n\t\t}\n\t}\n\treturn a;\n}\n\nvoid show(const data& d) {\n\tprintf(\"s=%d pos=\", d.sum);\n\tfor (int p : *d.pos) printf(\"%d,\", p);\n\tprintf(\" neg=\");\n\tfor (int p : *d.neg) printf(\"%d,\", p);\n\tputs(\"\");\n}\n\nint main()\n{\n\tscanf(\"%s%d\", S_, &N);\n\tint M = strlen(S_);\n\tfor (int i = 0; i < M + 3; ++i) uf[i] = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\t--L[i];\n\n\t\tjoin(L[i], R[i]);\n\t}\n\tS[0] = S[M + 2] = 0;\n\tfor (int i = 0; i < M; ++i) S[i + 1] = S_[i] - 'a';\n\n\tfor (int i = 0; i <= M; ++i) {\n\t\tD[i] = (S[i + 1] - S[i] + W) % W;\n\t}\n\tM += 1;\n\tfor (int i = 0; i < M; ++i) {\n\t\tgrps[root(i)].push_back(i);\n\t}\n\tfor (int i = 0; i < M; ++i) if (grps[i].size() > 0) {\n\t\tint sum = 0;\n\t\tset<int> *pos = new set<int>, *neg = new set<int>;\n\t\tfor (int p : grps[i]) {\n\t\t\tif (p * 2 + 1 == M) continue;\n\t\t\tif (p >= M / 2) {\n\t\t\t\twaf(neg, pos, M - 1 - p);\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaf(pos, neg, p);\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t}\n\t\t}\n\t\t//show(data(sum, pos, neg));\n\t\teqs.insert(data(sum, pos, neg));\n\t}\n\n\twhile (!eqs.empty()) {\n\t\tdata top = *(eqs.begin());\n\t\teqs.erase(eqs.begin());\n\n\t\tif (top.top() == 1000000) {\n\t\t\tif (top.sum != 0) {\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (eqs.empty()) break;\n\n\t\tif (eqs.begin()->top() != top.top()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata top2 = *(eqs.begin());\n\t\teqs.erase(eqs.begin());\n\n\t\tdata nw = mgr(top, top2);\n\t\teqs.insert(nw);\n\t}\n\n\tputs(\"YES\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n \nusing namespace std;\n \nstruct S{\n\tL s,e;\n};\n \nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n \nset<S>st;\n \nchar str[100010];\nL b[100010];\nL n,len;\n \nL tr[400040];\n \nvoid update(L now,L S,L E,L s,L e,L val){\n\twhile(e)\n\t{\n\t\ttr[e]+=val;\n\t\te^=e&-e;\n\t}\n\ts--;\n\twhile(s)\n\t{\n\t\ttr[s]-=val;\n\t\ts^=s&-s;\n\t}\n}\n \nL get(L now,L S,L E,L loc){\n\tL ret=0;\n\twhile(loc<=len)\n\t{\n\t\tret+=tr[loc];\n\t\tloc+=loc&-loc;\n\t}\n\treturn ret;\n}\n \nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n \nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\t//printf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//for(set<S>::iterator it=st.begin();it!=st.end();it++)\n\t//\tprintf(\"%lld %lld\\n\",it->s,it->e);\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\t\n\t\t\tst.erase(st.begin());\n\t\t\tset<S>sttemp;\n\t\t\tL prelast=range.e;\n\t\t\tfor(set<S>::iterator it=st.begin();it!=st.end()&&it->s==range.s;it++)\n\t\t\t{\n\t\t\t\tsttemp.insert((S){prelast+1,it->e});\n\t\t\t\tprelast=it->e;\n\t\t\t}\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()||it->s!=range.s) break;\n\t\t\t\tst.erase(it);\n\t\t\t}\n\t\t\tfor(set<S>::iterator it=sttemp.begin();it!=sttemp.end();it++)\n\t\t\t{\n\t\t\t\tst.insert(*it);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!st.empty()&&st.begin()->s==i)\n\t\t\t{\n\t\t\t\tS range=*(st.begin());\n\t\t\t\tst.erase(st.begin());\n\t\t\t\tset<S>sttemp;\n\t\t\t\tL prelast=range.e;\n\t\t\t\tfor(set<S>::iterator it=st.begin();it!=st.end()&&it->s==range.s;it++)\n\t\t\t\t{\n\t\t\t\t\tsttemp.insert((S){prelast+1,it->e});\n\t\t\t\t\tprelast=it->e;\n\t\t\t\t}\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\t\tif(it==st.end()||it->s!=range.s) break;\n\t\t\t\t\tst.erase(it);\n\t\t\t\t}\n\t\t\t\tfor(set<S>::iterator it=sttemp.begin();it!=sttemp.end();it++)\n\t\t\t\t{\n\t\t\t\t\tst.insert(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(set<S>::iterator it=st.begin();it!=st.end();it++)\n\t\t{\n\t\t\tprintf(\"%lld %lld\\n\",it->s,it->e);\n\t\t}\n\t\tputs(\"\");\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len + 2);\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i <= len; i++)\n    //{\n    //    cout << x[i] << \" \";\n    //}\n    //cout << endl;\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    vector<int> root(len + 2), sz(len + 2);\n    iota(root.begin(), root.end(), 0);\n    fill(sz.begin(), sz.end(), 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    vector<int> summ(len + 2);\n    for (int i = 1; i < x.size(); i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i <= len; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    if (t == -1) cout << \"YES\", exit(0);\n    int s = 0;\n    while (s != root[s]) s = root[s];\n    if (s == t) cout << \"YES\", exit(0);\n    else cout << \"NO\", exit(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, q, len;\nchar s[100005];\nint from[100005], to[100005];\nint a[100005];\n\nset<int> se[100005];\nint best[100005];\n\nint par[100005];\n\nvoid dsuInit() {\n    forn(i, len + 1) par[i] = i;\n}\n\nint dsuParent(int v) {\n    if (v == par[v]) return v;\n    return par[v] = dsuParent(par[v]);\n}\n\nvoid dsuMerge(int u, int v) {\n    u = dsuParent(u);\n    v = dsuParent(v);\n    if (u == v) return;\n    if (se[u].size() < se[v].size()) swap(u, v);\n    for (int x : se[v]) {\n        se[u].insert(x);\n    }\n    par[v] = u;\n}\n\nint main() {\n    scanf(\"%s\", s);\n    n = strlen(s);\n    scanf(\"%d\", &q);\n    len = n / 2;\n    int ri = len + n % 2;\n    forn(i, q) {\n        scanf(\"%d%d\", from + i, to + i);\n        --from[i], --to[i];\n        if (to[i] < ri) {\n            to[i] = min(to[i], len - 1);\n            ++to[i];\n        } else if (from[i] >= len) {\n            from[i] = max(from[i], ri);\n            from[i] = n - 1 - from[i];\n            to[i] = n - 1 - to[i];\n            swap(from[i], to[i]);\n            ++to[i];\n        } else {\n            to[i] = n - 1 - to[i];\n            if (from[i] == to[i]) {\n                from[i] = to[i] = len;\n            } else {\n                if (from[i] > to[i]) {\n                    swap(from[i], to[i]);\n                }\n            }\n        }\n    }\n    a[len] = 0;\n    forn(i, len) {\n        a[i] = int(s[i]) - int(s[n - 1 - i]);\n        if (a[i] < 0) {\n            a[i] += 26;\n        }\n    }\n//    cerr << \"!!\" << endl;\n//    forn(i, len) cerr << a[i] << ' ';\n//    cerr << endl;\n//    forn(i, q) cerr << from[i] << ' ' << to[i] << endl;\n//    cerr << \"!!\" << endl;\n    for (int i = len - 1; i >= 0; --i) {\n        a[i + 1] -= a[i];\n        if (a[i + 1] < 0) {\n            a[i + 1] += 26;\n        }\n    }\n    forn(i, q) {\n        se[from[i]].insert(to[i]);\n    }\n    dsuInit();\n    forn(i, len) {\n        int si = dsuParent(i);\n        while (!se[si].empty() && *se[si].begin() == i) {\n            se[si].erase(se[si].begin());\n        }\n        if (!se[si].empty()) {\n            int ind = *se[si].begin();\n            se[si].erase(se[si].begin());\n            if (!se[si].empty()) {\n                dsuMerge(si, ind);\n            }\n            a[ind] += a[i];\n            a[i] = 0;\n            if (a[ind] >= 26) {\n                a[ind] -= 26;\n            }\n        }\n        if (a[i] != 0) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    if (a[len] != 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tif(n%2==1) cout<<\"NO\"<<endl;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i] = a[i+1]-a[i];\n\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t}\n\tbool f = true;\n\trep(i, n2){\n\t\tif(used[i]) continue;\n\t\tused[i] = 1;\n\t\tll x = t[i];\n\t\tbool g = false;\n\t\tfor(ll j = i+1; j <= n2; j++){\n\t\t\tif(uf.same(i, j)){\n\t\t\t\tx += t[j];\n\t\t\t\tused[j] = 1;\n\t\t\t\tif(j==n2) g = true;\n\t\t\t}\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (y != f[y]) {\n    f[x] = find(y);\n    d[x] = (d[y] + d[x]) % 26;\n  }\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return d[x] == (diff + d[y]) % 26;\n  f[ry] = rx;\n  d[ry] = (d[x] - d[y] - diff) % 26;\n  if (d[ry] < 0) d[ry] += 26;\n  return true;\n}\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[n - 1 - i] - s[i] + 26) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\nconst ll MOD=998244353;\nconst int N=510000;\n\n\nmain(){\n    string s;cin>>s;\n    int n=s.size();\n    vec b;\n    rep(i,n/2){\n        b.pb((26+s[i]-s[n-1-i]));\n        if(b.back()>=26)b.back()-=26;\n    }\n    vector<vec> p(n);\n    int q=in();\n    rep(i,q){\n        int l=in(),r=in();\n        if(r<=n/2){\n            p[l-1].pb(r-1);\n        }\n        else if(l>n/2){\n            p[n-r].pb(n-l);\n        }\n        else {\n            r=n-r;\n            p[r].pb(l-2);\n        }\n    }\n    rep(i,n/2){\n        if(p[i].size())\n        sort(all(p[i]));\n        rep(j,(int)p[i].size()-1){\n            p[p[i][j]+1].pb(p[i][j+1]);\n        }\n    }\n    vec rui(n);\n    rep(i,n/2){\n        // cout<<b[i]<<\" \"<<rui[i]<<endl;\n        b[i]+=rui[i];\n        b[i]%=26;\n        if(b[i]){\n            if(p[i].size()==0){\n                cout<<\"NO\";return 0;\n            }\n            else{\n                rui[i]+=26-b[i];\n                rui[p[i][0]+1]-=26-b[i];\n            }\n        }\n        rui[i+1]+=rui[i];\n        if(rui[i+1]>=26)rui-=26;\n    }\n    cout<<\"YES\";return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\n\nint a[MAXN];\n\nvoid change(int L, int R, int v) {\n    a[L] += v;\n    a[R + 1] -= v;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    int M = (n + 1) / 2;\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[i + M]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls(m);\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            //cout << \"c1\";\n            x = n - x + 1;\n            y = n - y + 1;\n        }\n        if (x <mm && y >mm) {\n            //cout<<\"c2\";\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        // cout << x << ' ' << y;\n        if (x > y) continue;\n        ls[i] = { x, y };\n    }\n    std::sort(begin(ls), end(ls));\n    int j = 0, val = 0;\n    for (int i = 1; i + i <= n; ++i) {\n        val = (val + a[i]) % 26;\n        val = (val + 26) % 26;\n        while (j < m && ls[j].se < i) j++;\n        if (j < m && ls[j].fi <= i) {\n            change(ls[j].fi, ls[j].se, -val);\n            val = 0;\n            j++;\n        }\n        if (val != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nchar s[N];\nint f[N],val[N],m,l,r;\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nvoid merge(int u,int v) {\n\tu=find(u); v=find(v);\n\tif (u==v) return;\n\tf[u]=v; val[v]=(val[u]+val[v])%26;\n}\nint main() {\n\tscanf(\"%s\",s);\n\tint n=strlen(s);\n\trep(i,0,n) f[i]=i;\n\trep(i,0,n) if (i>0) {\n\t\tint w=(int)s[i]-(int)s[i-1];\n\t\tif (w<0) w+=26;\n\t\tval[i]=w;\n\t}\n\trep(i,1,n) merge(i,n-i);\n\tscanf(\"%d\",&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif (r==n) r=0;\n\t\tmerge(l-1,r);\n\t}\n\trep(i,0,n) if (find(i)!=find(0)&&val[find(i)]!=0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,m,a[N],sum;\nvector<int> g[N];\nbool vis[N];\nchar s[N];\n\nvoid add(int x,int y){\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tsum+=a[u];\n\tfor (int v:g[u]){\n\t\tif (!vis[v]) dfs(v);\n\t}\n}\n\nint main(){\n\tscanf(\"%s\",s+1); m=strlen(s+1);\n\tfor (int i=1;i<=m/2;++i) a[i]=s[i]-s[m-i+1];\n\ta[m/2+1]-=a[m/2];\n\tfor (int i=m/2;i;--i) a[i]-=a[i-1];\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tif (x<=m/2&&y>=m-m/2+1){\n\t\t\tint l1=m/2-x,l2=y-(m-m/2+1);\n\t\t\tif (l1>l2){\n\t\t\t\tx=m/2-l1; y=m/2-l2-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=m/2-l2; y=m/2-l1-1;\n\t\t\t}\n\t\t}\n\t\tif (x>m/2){\n\t\t\tx=m-x+1; y=m-y+1;\n\t\t\tswap(x,y);\n\t\t}\n\t\tif (y>m/2) y=m/2;\n\t\tif (x<=y) add(x,y+1);\n\t}\n\tfor (int i=1;i<=m/2+1;++i){\n\t\tsum=0;\n\t\tif (!vis[i]) dfs(i);\n\t\tif (sum){puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define pb push_back\n#define ALL(s) s.begin(),s.end()\n#define FIN ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define SZ(s) int(s.size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\nint vis[100010];\nvector<int> g[100010],a;\n\nint get(int pos){\n\tint v=a[pos]; vis[pos]=1;\n\tfor(auto x:g[pos]) if(!vis[x]) v+=get(x);\n\treturn v%26;\n}\n\nint main(){FIN;\n\tstring s; int q; cin>>s>>q;\n\ts=\"a\"+s+\"a\";\n\tfore(i,1,SZ(s)) a.pb((s[i]-s[i-1]+26)%26);\n\tint n=SZ(a);\n\tfore(i,0,n) g[i].pb(n-i-1);\n\twhile(q--){\n\t\tint l,r;cin>>l>>r;\n\t\tg[l-1].pb(r); g[r].pb(l-1);\n\t}\n\tfore(i,0,n) if(!vis[i]&&get(i)) cout << \"NO\\n\",exit(0);\n\tcout<<\"YES\\n\";\n}//pingo"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\ntemplate <typename T>\nclass FenwickTree {\n  const int n;\n  vector<T> data;\npublic:\n  FenwickTree(int n) : n(n), data(n, 0) {}\n  void add(int i, T value) {\n    for (; i < n; i |= i + 1) data[i] += value;\n  }\n  T sum(int i) const {\n    T res = 0;\n    for (; i >= 0; i = (i & (i + 1)) - 1) res += data[i];\n    return res;\n  }\n  T sum(int l, int r) const { return sum(r - 1) - sum(l - 1); }\n};\n\nvector<int> le[100010];\nvector<int> ri[100010];\n\nvoid addq(int l, int r) {\n  le[l].push_back(r);\n  ri[r].push_back(l);\n}\n\nvoid solve(string S, ll N, vector<ll> L, vector<ll> R) {\n  const int n = S.size();\n  FenwickTree<int> bit(n + 1);\n  REP(i,n) {\n    bit.add(i, S[i] - 'a');\n    bit.add(i + 1, -(S[i] - 'a'));\n  }\n  REP(i,N) {\n    int l = L[i] - 1, r = R[i] - 1;\n    addq(l, r);\n  }\n  for (int l = 0, r = n - 1; l < r; ++l, --r) {\n    // string s; \n    // REP(i,n) {\n    //   int d = bit.sum(i);\n    //   d = (d % 26 + 26) % 26;\n    //   s += char('a' + d);\n    // }\n    // cout << s << endl;\n    vector<int> ch;\n    for (int i: le[l])\n      if (l <= i && i < r) ch.push_back(i);\n    for (int i: ri[r])\n      if (l < i && i <= r) ch.push_back(i - 1);\n\n    if (ch.empty()) {\n      int d = bit.sum(r) - bit.sum(l);\n      if ((d % 26 + 26) % 26 != 0) {\n        cout << \"NO\" << endl;\n        return;\n      }\n      continue;\n    }\n    else {\n      for (int i = 1; i < int(ch.size()); ++i) {\n        if (ch[0] < ch[i]) addq(ch[0] + 1, ch[i]);\n        if (ch[0] > ch[i]) addq(ch[i] + 1, ch[0]);\n      }\n      int d = bit.sum(r) - bit.sum(l);\n      d = (d % 26 + 26) % 26;\n      bit.add(l, d);\n      bit.add(ch[0] + 1, -d);\n    }\n  }\n  cout << \"YES\" << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tstring S;\n\tll N;\n\tcin >> S;\n\tscanf(\"%lld\", &N);\n\tvector<ll> L(N-1+1);\n\tvector<ll> R(N-1+1);\n\tfor (int i = 0 ; i <= N-1 ; i++) {\n\t  scanf(\"%lld\", &L[i]);\n\t  scanf(\"%lld\", &R[i]);\n\t}\n\tsolve(S, N, L, R);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nconst ll K1 = 2;\nconst ll K2 = 179;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk1[N], degk2[N];\nll ha1[N], ha2[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degk1[0] = 1;\n    degk2[0] = 1;\n    for (int i = 1; i < N; i++) degk1[i] = degk1[i - 1] * K1 % MOD;\n    for (int i = 1; i < N; i++) degk2[i] = degk2[i - 1] * K2 % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha1[l[i]] = (ha1[l[i]] + degk1[i]) % MOD;\n            ha1[r[i] + 1] = (ha1[r[i] + 1] + MOD - degk1[i]) % MOD;\n            ha2[l[i]] = (ha2[l[i]] + degk2[i]) % MOD;\n            ha2[r[i] + 1] = (ha2[r[i] + 1] + MOD - degk2[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha1[i] = (ha1[i - 1] + ha1[i]) % MOD;\n        ha2[i] = (ha2[i - 1] + ha2[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<pair<ll, ll>, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[{ha1[i], ha2[i]}].insert(x[i]);\n        if (val[{ha1[i], ha2[i]}].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[{0, 0}].size() && *(val[{0, 0}].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    vector<set<int> > st;\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n        st.resize(node_size);\n        rep(i,node_size){\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n        for(auto p:st[y]){\n            st[x].insert(p);\n        }\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n==1){\n        cout <<\"YES\" << endl;\n        return 0;\n    }\n    vector<int> a(n/2);\n    rep(i,n/2){\n        a[i] = (26+s[n-1-i]-s[i])%26;\n    }\n    // rep(i,n/2)cerr << a[i] << \" \";\n    // cerr << endl;\n    int m;\n    cin >> m;\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > p;\n    rep(i,m){\n        int l,r;\n        cin >> l >> r;\n        l--;r--;\n        if(n%2==1){\n            if(l==n/2&&r==n/2)continue;\n            if(l==n/2)l++;\n            if(r==n/2)r--;\n        }\n        if(l==r){\n            if(l>=n/2){\n                l = n-1-l;\n                p.push(MP(l,l));\n            }else{\n                p.push(MP(l,l));\n            }\n        }else{\n            if(l<n/2&&r<n/2){\n                p.push(MP(l,r));\n            }else if(l<n/2){\n                r = n-1-r;\n                if(l<r){\n                    p.push(MP(l,r-1));\n                }else if(l>r){\n                    p.push(MP(r,l-1));\n                }\n            }else if(r>=n/2){\n                l = n-1-l;\n                r = n-1-r;\n                p.push(MP(min(l,r),max(l,r)));\n            }\n        }\n    }\n    UnionFind uf(n/2+1);\n    vector<int> nxt(n/2,-1);\n    while(!p.empty()){\n        auto x = p.top();\n        p.pop();\n        int a = x.first;\n        int b = x.second;\n        if(nxt[a]==-1){\n            nxt[a] = b;\n            uf.unite(a,b+1);\n        }else{\n            if(nxt[a]>b){\n                int x = nxt[a];\n                nxt[a] = b;\n                uf.unite(a,b+1);\n                if(uf.same(b+1,x+1))continue;\n                if(nxt[b+1]==-1){\n                    nxt[b+1] = x;\n                    uf.unite(b+1,x);\n                }else{\n                    auto zz = (uf.st[uf.find(b+1)].upper_bound(x));\n                    zz--;\n                    int k = *zz;\n                    nxt[x] = nxt[k];\n                    nxt[k] = x;\n                    uf.unite(b+1,x);\n                }\n            }else if(nxt[a]<b){\n                if(nxt[nxt[a]+1]==-1){\n                    nxt[nxt[a]+1] = b;\n                    uf.unite(nxt[a]+1,b);\n                }else{\n                    int x = b;\n                    auto zz = (uf.st[uf.find(nxt[a]+1)].upper_bound(x));\n                    zz--;\n                    int k = *zz;\n                    nxt[x] = nxt[k];\n                    nxt[k] = x;\n                    uf.unite(nxt[a]+1,x);\n                }\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << nxt[i] << \" \";\n    // }\n    // cerr << endl;\n    vector<int> res(n/2);\n    vector<int> ss(n/2+1);\n    int tmp = 0;\n\n    rep(i,n/2){\n        tmp -= ss[i];\n        res[i] += tmp;\n        res[i] %= 26;\n        if(res[i]!=a[i]){\n            if(nxt[i]!=-1){\n                int c = (26+a[i]-res[i])%26;\n                tmp += c;\n                ss[nxt[i]+1] += c;\n                res[i] = a[i];\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << res[i] << \" \";\n    // }\n    // cerr << endl;\n    rep(i,n/2){\n        if(res[i]!=a[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint n,q,l,r,pset[100007];\nint it[400007];\nset <int> query[100007];\nvoid upd(int k,int l,int r,int L,int R,int val){\n\tif(l>R || r<L || L>R) return;\n\tif(l>=L && r<=R){\n\t\tit[k]+=val;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tupd(k*2,l,mid,L,R,val);\n\tupd(k*2+1,mid+1,r,L,R,val);\n}\nint get(int k,int l,int r,int pos){\n\tif(l==r && l==pos) return it[k];\n\tint mid=(l+r)/2;\n\tif(pos<=mid) return it[k]+get(k*2,l,mid,pos);\n\telse return it[k]+get(k*2+1,mid+1,r,pos);\n}\nint fset(int x){\n\tif(pset[x]==x) return x;\n\treturn pset[x]=fset(pset[x]);\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>s;\n\tn=(int)s.length();\n\tcin>>q;\n\tfor(int i=1;i<=q;i++){\n\t\tcin>>l>>r;\n\t\tif(l<=(n+1)/2 && r>=(n+1)/2){\n\t\t\tr=n-r+1;\n\t\t\tif(l>r) swap(l,r);\n\t\t\tif(l==r) continue;\n\t\t\tr--;\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse if(l<=(n+1)/2){\n\t\t\tquery[l].insert(r);\n\t\t}\n\t\telse{\n\t\t\tquery[n-r+1].insert(n-l+1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) pset[i]=i;\n\tfor(int i=1;i<=n/2;i++){\n\t\t//cout<<(s[i-1]-s[n-i]+26)%26<<endl;\n\t\tint cal=((s[i-1]-s[n-i]+26)%26-get(1,1,n,i)+26)%26;\n\t\t//cout<<i<<\" \"<<cal<<endl;\n\t\tif(cal!=0 && query[fset(i)].empty()){\n\t\t\tcout<<\"NO\";\n\t\t\treturn 0;\n\t\t}\n\t\telse if(i==n/2) continue;\n\t\telse{\n\t\t\tint cur=fset(i);\n\t\t\tauto it=query[cur].begin();\n\t\t\tquery[cur].erase(it);\n\t\t\tupd(1,1,n,i,*it,cal);\n\t\t\tint nxt=fset(*it+1);\n\t\t\tif(query[cur].size()<query[nxt].size()){\n\t\t\t\tpset[cur]=nxt;\n\t\t\t\tfor(auto jt=query[cur].begin();jt!=query[cur].end();jt++){\n\t\t\t\t\tquery[nxt].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpset[nxt]=cur;\n\t\t\t\tfor(auto jt=query[nxt].begin();jt!=query[nxt].end();jt++){\n\t\t\t\t\tquery[cur].insert(*jt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// 解き直し.\n// https://img.atcoder.jp/cf17-final/editorial.pdf\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define repx(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\nconst int MAX = 202020;\nchar c[MAX];\nint d[MAX], connection[MAX];\n\nstruct UnionFind{\n    vector<int> parent, rank, sub;\n    UnionFind(int n = 1){\n        parent.resize(n + 1); rank.resize(n + 1); sub.resize(n + 1);\n        rep(i, n + 1) parent[i] = i, rank[i] = 0, sub[i] = 1;\n    }\n    int root(int x){\n        if(parent[x] == x) return x;\n        else               return parent[x] = root(parent[x]);\n    }\n    bool isSame(int x, int y){\n        return root(x) == root(y);\n    }\n    bool merge(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return false;\n        if(rank[x] < rank[y]) swap(x, y);\n        if(rank[x] == rank[y]) ++rank[x];\n        parent[y] = x;\n        sub[x] += sub[y];\n        return true;\n    }\n    int size(int x){\n        return sub[root(x)];\n    }\n};\n\nint main(){\n    \n    // 1. 入力情報.\n    int N;\n    scanf(\"%s %d\", c, &N);\n    string S(c);\n    S.pb('a');\n    S.insert(0, \"a\");\n    // printf(\"%s\\n\", S.c_str());\n    \n    // 2. 隣接の差を配列に保存.\n    // ex.\n    // bixzja\n    // -> abixzjaa\n    // -> d[7] = {1, 7, 15, 2, 10, 17, 0}\n    int s = S.size();\n    rep(i, s - 1) d[i] = 26 + (S[i + 1] - 'a') - (S[i] - 'a'), d[i] %= 26;\n    // rep(i, s - 1) printf(\"%d \", d[i]);\n    // printf(\"\\n\");\n    \n    // 3. Union-Find木 に 頂点情報 を 保存.\n    UnionFind uf(MAX);\n    // 入力で与えられた区間.\n    int l, r;\n    rep(i, N){\n        scanf(\"%d %d\", &l, &r);\n        // 解説通りになるが, 差を取る前の数列 {0, 0, 0, 0} -> {0, 1, 1, 1} は,\n        // 差の列で考えると, {0, 0, 0, 0, 0} -> {0, 1, 0, 0, -1} と見るので,\n        // 右側 の index が, 1 増えることに注意, なので, l-- だけを残す形に修正.\n        // l--, r--;\n        l--;\n        uf.merge(l, r);\n    }\n    // 回文判定のための区間.\n    rep(i, s / 2) uf.merge(i, s - 2 - i);\n    \n    // 4. 各連結成分内の和を確認.\n    // -> 各部分木の頂点で, 連結性を識別.\n    int v;\n    rep(i, s - 1){\n        v = uf.root(i);\n        connection[v] += d[i];\n        connection[v] %= 26;\n        // printf(\"v=%d i=%d\\n\", v, i);\n    }\n    \n    // 5. 回文判定.\n    int ok = 0;\n    rep(i, s) ok += connection[i];\n    // rep(i, s) printf(\"%d \", connection[i]);\n    // printf(\"\\n\");\n    \n    // 6. 出力.\n    if(!ok) puts(\"YES\");\n    else    puts(\"NO\");\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 25.11.2017 14:40:16       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nchar foo[N];\nint s[N];\nint l[N], r[N];\nvector<int> g[N];\nint decc[N];\n\nint main() {\n  scanf(\"%s\", foo);\n  int n = (int) strlen(foo);\n  for (int i = 0; i < n; i++) {\n    s[i] = foo[i] - 'a';\n  }\n  int m;\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d\", &l[i], &r[i]);\n    l[i]--; r[i]--;\n    int op_l = n - 1 - l[i];\n    if (l[i] <= op_l && op_l <= r[i]) {\n      l[i] = op_l + 1;\n    }\n    int op_r = n - 1 - r[i];\n    if (r[i] >= op_r && op_r >= l[i]) {\n      r[i] = op_r - 1;\n    }\n    if (l[i] > n - 1 - l[i]) {\n      swap(l[i], r[i]);\n      l[i] = n - 1 - l[i];\n      r[i] = n - 1 - r[i];\n    }\n    if (l[i] <= r[i]) {\n      g[l[i]].push_back(r[i]);\n    }\n  }\n  int delta = 0;\n  for (int i = 0; i < n - 1 - i; i++) {\n    sort(g[i].begin(), g[i].end());\n    int to = (g[i].empty() ? -1 : g[i][0]);\n    for (int j = 1; j < (int) g[i].size(); j++) {\n      if (g[i][j - 1] < g[i][j]) {\n        g[g[i][j - 1] + 1].push_back(g[i][j]);\n      }\n    }\n    delta -= decc[i];\n    int cur = (s[i] + delta) % 26;\n    if (cur != s[n - 1 - i]) {\n      if (to == -1) {\n        puts(\"NO\");\n        return 0;\n      }\n      int diff = (s[n - 1 - i] - cur + 26) % 26;\n      delta += diff;\n      decc[to + 1] += diff;\n    }\n  }\n  puts(\"YES\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nint main(){\n  char s[SIZE];\n  int n,m;\n  int l[SIZE],r[SIZE];\n  vector<int> cc[SIZE];\n  \n  scanf(\"%s%d\",s,&m);\n  n = strlen(s);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",l+i,r+i);\n    l[i]--; r[i]--;\n    \n    if(n%2 == 0){\n      if(l[i] <= n/2-1 && n/2 <= r[i]){\n        int a = n/2 - l[i];\n        int b = r[i] - (n/2 - 1);\n        \n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if (a > b){\n          l[i] = n/2 - a;\n          r[i] = n/2 - b - 1;\n        }else{\n          l[i] = n/2 - b;\n          r[i] = n/2 - a - 1;\n        }\n      }\n    }else{\n      if(l[i] == r[i] && l[i] == n/2){\n        l[i] = -1; r[i] = -1;\n      }else if(l[i] == n/2){\n        l[i] += 1;\n      }else if(r[i] == n/2){\n        r[i] -= 1;\n      }else if(l[i] <= n/2-1 && n/2+1 <= r[i]){\n        int a = n/2+1 - l[i];\n        int b = r[i] - n/2;\n\n        if(a == b){\n          l[i] = r[i] = -1;\n        }else if(a > b){\n          l[i] = n/2-1 - a;\n          r[i] = n/2-1 - b - 1;\n        }else{\n          l[i] = n/2-1 - b;\n          r[i] = n/2-1 - a - 1;\n        }\n      }\n    }\n\n    if(l[i] != -1){\n      if((n+1)/2 <= l[i]){\n        l[i] = n - l[i] - 1;\n        r[i] = n - r[i] - 1;\n        swap(l[i], r[i]);\n      }\n      \n      cc[l[i]].push_back(r[i]);\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    if(cc[i].size() > 1)\n      sort(cc[i].begin(),cc[i].end());\n\n    for(int j=cc[i].size()-2;j>=0;j--){\n      if(cc[i][j] != cc[i][j+1])\n        cc[cc[i][j]+1].push_back(cc[i][j+1]);\n    }\n  }\n\n  SegTree seg(n);\n  \n  for(int i=0;i<n/2;i++){\n    seg.add(i, i, 26 + s[n-i-1] - s[i]);\n  }\n\n  for(int i=0;i<n/2;i++){\n    if(cc[i].size()){\n      int q = seg.query(i,i);\n      seg.add(i, cc[i][0], 26-q);\n    }\n\n    if(seg.query(i,i)%26){\n      puts(\"NO\");\n      return 0;\n    }\n  }\n\n  puts(\"YES\");\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (y != f[y]) {\n    f[x] = find(y);\n    d[x] = (d[y] + d[x]) % 26;\n  }\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return diff == 0;\n  f[ry] = rx;\n  d[ry] = (d[x] - d[y] - diff) % 26;\n  if (d[ry] < 0) d[ry] += 26;\n  return true;\n}\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[n - 1 - i] - s[i] + 26) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=400002;\nchar s[N];\nint n,m,c[N],a,b,i,j,k,p;\nint h[N],t[N],v[N],vis[N];\nvoid add(int a,int b){\n\tt[++k]=h[a];h[a]=k;v[k]=b;\n\tt[++k]=h[b];h[b]=k;v[k]=a;\n}\nvoid init(){\n\tscanf(\"%s\",s+1);\n\twhile(s[n+1])n++;\n\tfor(i=1;i<=n+1;i++)\n\t\tc[i]=s[i]-s[i-1];\n\tfor(i=1,j=n+1;i<j;i++,j--)\n\t\tadd(i,j);\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b+1);\n\t}\n}\nvoid dfs(int i){\n\tvis[i]=1;\n\tp+=c[i];\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(!vis[v[j]])\n\t\t\tdfs(v[j]);\n}\nvoid work(){\n\n\tfor(i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tp=0;\n\t\t\tdfs(i);\n\t\t\tif(p%26!=0){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\tprintf(\"YES\\n\");\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nusing ld = long double;\nll INF = LLONG_MAX;\n\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid print() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); \n\t}\n}\n\nusing namespace output;\n\ntemplate<class T> struct Seg { \n\tconst T ID = 0; // comb(ID,b) must equal b\n\tT combine(T a, T b) { return (a+b)%26;} \n\tint n; vector<T> seg;\n\tvoid init(int _n) { n = _n; seg.assign(2*n,ID);}\n\n\tvoid update(int p, T value) {\t// set value at position p\n\t\tseg[p += n] += value;\n\t\tfor (p /= 2; p; p /= 2) seg[p] = combine(seg[2*p], seg[2*p+1]);\n\t}\n    \n\tT query(int l, int r) {\t // sum on interval [l, r]\n\t\tT ra = ID, rb = ID; \n\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {\n\t\t\tif (l&1) ra = combine(ra,seg[l++]);\n\t\t\tif (r&1) rb = combine(seg[--r],rb);\n\t\t}\n\t\treturn combine(ra,rb);\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring S; cin >> S;\n\tint N; cin >> N;\n\tvector<vi> startsAt (S.size()+1);\n\tvector<vi> endsAt (S.size()+1);\n\tF0R(i, N) {\n\t\tint l, r; cin >> l >> r; --l; --r;\n\t\tstartsAt[l].push_back(r+1); // orig\n\t\tif (l+1 == S.size()-r) {\n\n\t\t} else if (l+1 < S.size()-r) {\n\t\t\tstartsAt[r+1].push_back(S.size()-l);\n\t\t} else {\n\t\t\tstartsAt[S.size()-r-1].push_back(l);\n\t\t}\n\t}\n\n\tF0R(i, S.size()+1) {\n\t\tsort(startsAt[i].begin(), startsAt[i].end());\n\t\tstartsAt[i].erase(unique(startsAt[i].begin(), startsAt[i].end()), startsAt[i].end());\n\n\t\tfor (int j = 1; j < startsAt[i].size(); ++j) {\n\t\t\tif (startsAt[i][j] != startsAt[i][j-1]) startsAt[startsAt[i][j-1]].push_back(startsAt[i][j]);\n\t\t}\n\t\tif (startsAt[i].size()) startsAt[i] = vi {startsAt[i][0]};\n\t\tfor (int j : startsAt[i]) endsAt[j].push_back(i);\n\t}\n\n\tstartsAt.assign(S.size() + 1, vi {});\n\n\tR0F(i, S.size()+1) {\n\t\tsort(endsAt[i].begin(), endsAt[i].end());\n\t\tendsAt[i].erase(unique(endsAt[i].begin(), endsAt[i].end()), endsAt[i].end());\n\n\t\tfor (int j = 0; j+1 < endsAt[i].size(); ++j) {\n\t\t\tif (endsAt[i][j] != endsAt[i][j+1]) endsAt[endsAt[i][j+1]].push_back(endsAt[i][j]);\n\t\t}\n\t\tif (endsAt[i].size()) endsAt[i] = vi {endsAt[i].back()};\n\t\tfor (int j : endsAt[i]) startsAt[j].push_back(i);\n\t}\n\n\tSeg<int> seg; seg.init(S.size());\n\tF0R(i, S.size()) {\n\t\tif (i == 0) {\n\t\t\tseg.update(i, S[i]-'a');\n\t\t} else {\n\t\t\tseg.update(i, S[i] - S[i-1]);\n\t\t}\n\t}\n\n\tfor (int l = 0; l < S.size() / 2; ++l) {\n\t\tint lc = seg.query(0, l); lc = (lc + 26) % 26;\n\t\tint rc = seg.query(0, S.size()-l-1); rc = (rc + 26) % 26;\n\t\tif (rc != lc) {\n\t\t\tif (startsAt[l].size() && (startsAt[l][0] <= S.size()-l-1)) {\n\t\t\t\tint cycle = (rc - lc + 26) % 26;\n\t\t\t\tseg.update(l, cycle);\n\t\t\t\tseg.update(startsAt[l][0], -cycle);\n\t\t\t} else {\n\t\t\t\tprint(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\n\t}\n\tprint(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n  string s;\n  cin>>s;\n  int N=s.size();\n  int n=N/2;\n  int m;cin>>m;\n  vector<int> v[n];\n  int a[m],b[m];\n  rep(i,m)cin>>a[i]>>b[i];\n  if(N%2){\n      rep(i,m)if(a[i]>n+1)a[i]--;\n      rep(i,m)if(b[i]>n)b[i]--;\n  }\n  rep(i,m){\n      if(b[i]<=n)a[i]--,b[i]--;\n      else if(a[i]>n)a[i]=2*n-a[i],b[i]=2*n-b[i],swap(a[i],b[i]);\n      else{\n          a[i]--;\n          b[i]=2*n-b[i];\n          if(a[i]>b[i])swap(a[i],b[i]);\n           b[i]--;\n      }\n      if(a[i]<=b[i])v[a[i]].push_back(b[i]);\n  }\n  vector<int> mi(n,-1);\n  rep(i,n){\n      if(v[i].empty())continue;\n      sort(v[i].begin(),v[i].end());\n      mi[i]=v[i][0];\n      REP(j,1,v[i].size()){\n          if(v[i][j-1]!=v[i][j])v[v[i][j-1]+1].push_back(v[i][j]);\n      }\n  }\n  int c[n];\n  rep(i,n)c[i]=s[i]-s[N-1-i];\n  rep(i,n-1)c[n-i-1]-=c[n-i-2];\n  rep(i,n){\n      if(mi[i]==-1){\n          if(c[i]%26==0)continue;\n          else {\n              cout<<\"NO\"<<endl;\n              return 0;\n          }\n      }\n      c[mi[i]+1]+=c[i];\n    }\n   cout<<\"YES\"<<endl; \n  return 0;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\nconst ll MOD=998244353;\nconst int N=510000;\n\nstruct UnionFind{\n    vector<int> par,sizes;\n    UnionFind(int n):par(n+1),sizes(n+1,1){\n        rep2(i,1,n)par[i]=i;\n    }\n    int find(int x){\n        return (x==par[x]?x:par[x]=find(par[x]));\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return ;\n        if(sizes[x]<sizes[y]){\n            swap(x,y);\n        }\n        par[y]=x;\n        sizes[x]+=sizes[y];\n    }\n    bool same(int x,int y) {return (find(x)==find(y));}\n    int size(int x) {return sizes[find(x)];}\n};\nmain(){\n    string s;cin>>s;\n    int n=s.size();\n    vec b;\n    rep(i,n/2){\n        b.pb((26+s[i]-s[n-1-i]));\n        if(b.back()>=26)b.back()-=26;\n    }\n    vector<vec> p(n);\n    UnionFind uf(n);\n    int q=in();\n    rep(i,q){\n        int l=in(),r=in();\n        if(r<=n/2){\n            uf.unite(l-1,r);\n            // p[l-1].pb(r-1);\n        }\n        else if(l>n/2){\n            // p[n-r].pb(n-l);\n            uf.unite(n-r,n-l+1);\n        }\n        else {\n            r=n-r;\n            uf.unite(r,l-1);\n            // p[r].pb(l-2);\n        }\n    }\n    map<int,vec> mp;\n    rep(i,n/2+1){\n        mp[uf.find(i)].pb(i);\n    }\n    for(auto ee:mp){\n        auto e=ee.second;\n        if(e.size()<=1)continue;\n        sort(all(e));\n        // print(e);\n        p[e[0]].pb(e[1]-1);\n        rep(i,e.size()-2){\n            p[e[i+1]].pb(e[i+2]-1);\n        }\n    }\n    vec rui(n);\n    rep(i,n/2){\n        // cout<<b[i]<<\" \"<<rui[i]<<endl;\n        b[i]+=rui[i];\n        b[i]%=26;\n        if(b[i]){\n            if(p[i].size()==0){\n                cout<<\"NO\";return 0;\n            }\n            else{\n                rui[i]+=26-b[i];\n                rui[p[i][0]+1]-=26-b[i];\n            }\n        }\n        rui[i+1]+=rui[i];\n        if(rui[i+1]>=26)rui[i+1]-=26;\n    }\n    cout<<\"YES\";return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (y != f[y]) {\n    f[x] = find(y);\n    d[x] = (d[y] + d[x]) % 26;\n  }\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return d[x] == (diff + d[y]) % 26;\n  f[ry] = rx;\n  d[ry] = (d[x] - d[y] - diff) % 26;\n  if (d[ry] < 0) d[ry] += 26;\n  return true;\n}\n\nint main() {\n  srand(time(0));\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[n - 1 - i] - s[i] + 26) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int u = label[i];\n    find(u);\n    trace(i, u, d[u], (s[i] - 'a' + d[u]) % 26);\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\n\nint a[MAXN];\n\nvoid change(int L, int R, int v) {\n    a[L] += v;\n    a[R + 1] -= v;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    int M = (n + 1) / 2;\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            //cout << \"c1\";\n            x = n - x + 1;\n            y = n - y + 1;\n        }\n        if (x <mm && y >mm) {\n            //cout<<\"c2\";\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        // cout << x << ' ' << y;\n        if (x > y) continue;\n        ls.emplace_back(x, y);\n    }\n    m = ls.size();\n    std::sort(begin(ls), end(ls));\n    int j = 0, val = 0;\n    for (int i = 1; i + i <= n; ++i) {\n        val = (val + a[i]) % 26;\n        val = (val + 26) % 26;\n        while (j < m && ls[j].se < i) j++;\n        if (j < m && ls[j].fi <= i) {\n            change(ls[j].fi, ls[j].se, -val);\n            val = 0;\n            j++;\n        }\n        if (val != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nconst ll K = 3;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degh[N];\nll ha[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degh[0] = 1;\n    for (int i = 1; i < N; i++) degh[i] = degh[i - 1] * K % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha[l[i]] = (ha[l[i]] + degh[i]) % MOD;\n            ha[r[i] + 1] = (ha[r[i] + 1] + MOD - degh[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha[i] = (ha[i - 1] + ha[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<ll, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[ha[i]].insert(x[i]);\n        if (val[ha[i]].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[0].size() && *(val[0].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n    string S; cin >> S;\n    int N = S.size();\n    vector<vector<int>> g(N/2+1);\n    int M; cin >> M;\n    for(int i=0;i<M;i++){\n        int L, R; cin >> L >> R;\n        --L; --R;\n        if(L >= N/2){\n            L = N-1-L;\n            R = N-1-R;\n            swap(L, R);\n        } else if(R >= N/2){\n            if(L == N-1-R) continue;\n            if(L < N-1-R){\n                R = N-2-R;\n            } else {\n                --L;\n                R = N-1-R;\n                swap(L, R);\n            }\n        }\n        R = min(R+1, N/2);\n        g[L].push_back(R);\n        g[R].push_back(L);\n    }\n    vector<int> dif(N, 0);\n    vector<int> reach(N, -1);\n    vector<int> next(N, -1);\n    for(int i=0;i<=N/2;i++){\n        if(reach[i] != -1) continue;\n        reach[i] = i;\n        queue<int> qu; qu.push(i);\n        while(!qu.empty()){\n            int s = qu.front(); qu.pop();\n            for(auto& t : g[s]){\n                if(reach[t] != -1) continue;\n                reach[t] = i;\n                qu.push(t);\n            }\n        }\n        int cur = i;\n        for(int j=i+1;j<=N/2;j++){\n            if(reach[j] != i) continue;\n            next[cur] = j;\n            cur = j;\n        }\n    }\n    int sum = 0;\n    for(int i=0;i<N/2;i++){\n        sum += dif[i];\n        int rot = (S[N-1-i] - S[i] - sum % 26 + 52) % 26;\n        if(rot != 0 && next[i] == -1){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n        sum += rot;\n        dif[next[i]] = -rot;\n    }\n    cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 200005;\n\nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n\n\nvoid merge(set<int> &a, set<int> &b)\n{\n//     if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            l = min(max(-1, mid1 - l), max(-1, r - mid2)) + 1;\n            r = max(max(-1, mid1 - l), max(-1, r - mid2));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[mid1 - i] - s[mid2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= i) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            deladd[minr + 1] %= 26;\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nstruct UF{\n    int n;\n    vector<int> par;\n    UF(int n) : n(n) {\n        for(int i = 0; i < n; i++) par.push_back(i);\n    }\n    int find(int a){\n        if(a != par[a]) par[a] = find(par[a]);\n        return par[a];\n    }\n    void join(int a, int b){\n        par[find(a)] = find(b);\n    }\n};\n\nvector<int> u2[120000];\n\nvector<int> g13[120000];\n\nint main(){\n    string s;\n    cin >> s;\n    s += 'a';\n    int cur = 0;\n    vector<int> diff;\n    for(int i = 0; i < s.size(); i++){\n        int g = s[i]-'a';\n        diff.push_back((g - cur + 26*2) % 26);\n        cur = g;\n    }\n    int N = diff.size();\n\n    UF uf1(N);\n    UF uf13(N);\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        int l, r;\n        cin >> l >> r;\n        uf1.join(l-1, r);\n        uf13.join(l-1, r);\n    }\n    for(int i = 0; i < N; i++){\n        uf1.join(i, N-1-i);\n    }\n    for(int i = 0; i < N; i++){\n        u2[uf1.find(i)].push_back(i);\n    }\n    for(int i = 0; i < N; i++){\n        int m2 = 0;\n        for(int j = 0; j < u2[i].size(); j++){\n            m2 += diff[u2[i][j]];\n        }\n        if(m2 % 2 != 0){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    int ok[120000];\n    for(int i = 0; i < N; i++){\n        ok[i] = 0;\n    }\n\n    for(int i = 0; i < N; i++){\n        g13[uf13.find(i)].push_back(i);\n    }\n    for(int i = 0; i < N; i++){\n        if(uf13.find(i) == uf13.find(N-1-i)){\n            ok[i] = ok[N-1-i] = 0;\n        }\n    }\n    cout << \"YES\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    vector<set<int> > st;\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n        st.resize(node_size);\n        rep(i,node_size){\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n        for(auto p:st[y]){\n            st[x].insert(p);\n        }\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n==1){\n        cout <<\"YES\" << endl;\n        return 0;\n    }\n    vector<int> a(n/2);\n    rep(i,n/2){\n        a[i] = (26+s[n-1-i]-s[i])%26;\n    }\n    // rep(i,n/2)cerr << a[i] << \" \";\n    // cerr << endl;\n    int m;\n    cin >> m;\n    \n    UnionFind uf(n/2+1);\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > p;\n    rep(i,m){\n        int l,r;\n        cin >> l >> r;\n        l--;r--;\n        if(n%2==1){\n            if(l==n/2&&r==n/2)continue;\n            if(l==n/2)l++;\n            if(r==n/2)r--;\n        }\n        if(l==r){\n            if(l>=n/2){\n                l = n-1-l;\n                p.push(MP(l,l));\n                uf.unite(l,l+1);\n            }else{\n                uf.unite(l,l+1);\n                p.push(MP(l,l));\n            }\n        }else{\n            if(l<n/2&&r<n/2){\n                uf.unite(l,r+1);\n                p.push(MP(l,r));\n            }else if(l<n/2){\n                r = n-1-r;\n                if(l<r){\n                    uf.unite(l,r);\n                    p.push(MP(l,r-1));\n                }else if(l>r){\n                    uf.unite(r,l);\n                    p.push(MP(r,l-1));\n                }\n            }else if(r>=n/2){\n                l = n-1-l;\n                r = n-1-r;\n                \n                uf.unite(min(l,r),max(l,r)+1);\n                p.push(MP(min(l,r),max(l,r)));\n            }\n        }\n    }\n    vector<int> nxt(n/2,-1);\n    // while(!p.empty()){\n    //     auto x = p.top();\n    //     p.pop();\n    //     int a = x.first;\n    //     int b = x.second;\n    //     if(nxt[a]==-1){\n    //         nxt[a] = b;\n    //         uf.unite(a,b+1);\n    //     }else{\n    //         if(nxt[a]>b){\n    //             int x = nxt[a];\n    //             nxt[a] = b;\n    //             uf.unite(a,b+1);\n    //             if(uf.same(b+1,x+1))continue;\n    //             if(nxt[b+1]==-1){\n    //                 nxt[b+1] = x;\n    //                 uf.unite(b+1,x);\n    //             }else{\n    //                 auto zz = (uf.st[uf.find(b+1)].upper_bound(x));\n    //                 zz--;\n    //                 int k = *zz;\n    //                 nxt[x] = nxt[k];\n    //                 nxt[k] = x-1;\n    //                 uf.unite(b+1,x);\n    //             }\n    //         }else if(nxt[a]<b){\n    //             if(nxt[nxt[a]+1]==-1){\n    //                 nxt[nxt[a]+1] = b;\n    //                 uf.unite(nxt[a]+1,b);\n    //             }else{\n    //                 int x = b;\n    //                 auto zz = (uf.st[uf.find(nxt[a]+1)].upper_bound(x));\n    //                 zz--;\n    //                 int k = *zz;\n    //                 nxt[x] = nxt[k];\n    //                 nxt[k] = x-1;\n    //                 uf.unite(nxt[a]+1,x);\n    //             }\n    //         }\n    //     }\n    // }\n    rep(i,n/2){\n        auto x = uf.st[uf.find(i)].upper_bound(i);\n        if(x==uf.st[uf.find(i)].end()){\n            nxt[i] = -1;\n        }else{\n            int k = *x;\n            nxt[i] = k-1;\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << nxt[i] << endl;\n    // }\n    vector<int> res(n/2);\n    vector<int> ss(n/2+1);\n    int tmp = 0;\n\n    rep(i,n/2){\n        tmp -= ss[i];\n        res[i] += tmp;\n        res[i] %= 26;\n        if(res[i]!=a[i]){\n            if(nxt[i]!=-1){\n                int c = (26+a[i]-res[i])%26;\n                tmp += c;\n                ss[nxt[i]+1] += c;\n                res[i] = a[i];\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << res[i] << \" \";\n    // }\n    // cerr << endl;\n    rep(i,n/2){\n        if(res[i]!=a[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int N = 1e5 + 10;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[N];\nint fa[N], v[N];\n\nI int findfa(cr x) {return fa[x] == x ? x : fa[x] = findfa(fa[x]);}\n\nint main() {\n\tscanf(\"%s\", ss + 1);\n\treg n = strlen(ss + 1);\n\tfo(i, 1, n) fa[i] = i, ss[i] -= 'a';\n\tfa[n + 1] = n + 1;\n\treg m = read();\n\tfo(i, 1, m) {\n\t\treg l = read(), r = read();\n\t\tfa[findfa(l)] = findfa(r + 1);\n\t} fo(i, 1, n + 1 >> 1) fa[findfa(i)] = findfa(n - i + 2);\n\tfo(i, 1, n + 1) v[i] = ss[i] - ss[i - 1];\n\tfo(i, 1, n + 1) if(fa[i] ^ i) v[findfa(i)] += v[i];\n\tfo(i, 1, n + 1) if(fa[i] == i && v[i] % 26) {puts(\"NO\"); return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define N 100005\n\nchar str[N]; int len, mid;\nstd::pair<int, int> ops[N]; int opcnt;\n\ninline void merge_ops()\n{\n\tstatic std::priority_queue<int, std::vector<int>, std::greater<int>> rs[N];\n\tfor(int i = 0; i < opcnt; ++i)\n\t\trs[ops[i].first].push(ops[i].second);\n\n\topcnt = 0;\n\tfor(int l = 1; l <= mid; ++l)\n\t{\n\t\tauto &cur = rs[l];\n\t\tif(cur.empty()) continue;\n\n\t\tint r = cur.top(); cur.pop();\n\t\tops[opcnt++] = std::make_pair(l, r);\n\n\t\tauto &dest = rs[r + 1];\n\t\tif(cur.size() < dest.size()) //启发式合并\n\t\t\twhile(!cur.empty())\n\t\t\t{\n\t\t\t\tdest.push(cur.top());\n\t\t\t\tcur.pop();\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\twhile(!dest.empty())\n\t\t\t{\n\t\t\t\tcur.push(dest.top());\n\t\t\t\tdest.pop();\n\t\t\t}\n\t\t\tdest.swap(cur);\n\t\t}\n\t}\n}\n\ninline bool solve()\n{\n\tstatic int pre[N]; //差分化\n\tpre[0] = 0;\n\tpre[1] = str[1] - 'a';\n\tfor(int i = 2; i <= mid; ++i)\n\t{\n\t\tpre[i] = str[i] - str[i - 1];\n\t\tpre[i] = (pre[i] + 26) % 26;\n\t}\n\n\tint k = 1;\n\tfor(int o = 0; o < opcnt; ++o)\n\t{\n\t\tconst std::pair<int, int> &cur = ops[o];\n\t\tfor(; k <= cur.first; ++k)\n\t\t{\n\t\t\tpre[k] += pre[k - 1];\n\t\t\tpre[k] = (pre[k] + 26) % 26;\n\t\t}\n\t\tint d = int(str[len - cur.first + 1]) - pre[cur.first] - 'a';\n\t\tpre[cur.first] += d;\n\t\tpre[cur.first] = (pre[cur.first] + 26) % 26;\n\t\tpre[cur.second + 1] -= d;\n\t\tpre[cur.second + 1] = (pre[cur.second + 1] + 26) % 26;\n\t}\n\tfor(; k <= mid; ++k)\n\t{\n\t\tpre[k] += pre[k - 1];\n\t\tpre[k] = (pre[k] + 26) % 26;\n\t}\n\n\tfor(int i = 1; i <= mid; ++i)\n\t{\n\t\tif(pre[i] != str[len - i + 1] - 'a')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint _;\n\tscanf(\"%s%d\", str + 1, &_);\n\tlen = strlen(str + 1);\n\tmid = len >> 1;\n\n\topcnt = 0;\n\tfor(int i = 0; i < _; ++i)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif(l - 1 > (len - r))\n\t\t{\n\t\t\tl = len - l + 1;\n\t\t\tr = len - r + 1;\n\t\t\tstd::swap(l, r);\n\t\t}\n\t\tif(r > mid) r = len - r;\n\n\t\tif(l <= r)\n\t\t\tops[opcnt++] = std::make_pair(l, r);\n\t}\n\n\tmerge_ops();\n\n\tif(solve()) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  trace(label);\n  map<int64, int> d;\n  bool found = false;\n  for (int i = 0; i < n / 2; ++i) {\n    int j = n - 1 - i;\n    int diff = (s[j] - s[i] + 26) % 26;\n    int u = label[i], v = label[j];\n    trace(i, j, u, v, diff);\n    if (u == v && diff) {\n      found = true;\n      break;\n    }\n    if (!d.count(u) && !d.count(v)) {\n      d[u] = diff;\n      d[v] = 0;\n    } else if (!d.count(u)) {\n      d[u] = (d[v] + diff) % 26;\n    } else if (!d.count(v)) {\n      d[v] = (d[u] + 26 - diff) % 26;\n    } else {\n      if ((d[u] - d[v] + 26) % 26 != diff) {\n        found = true;\n        break;\n      }\n    }\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll dsu[SZ], sm[SZ];\n\nll par(int v) {\n\tif (dsu[v] == v) return v;\n\telse return dsu[v] = par(dsu[v]);\n}\n\nvoid uni(int v, int u) {\n\tu = par(u);\n\tv = par(v);\n\tif (u != v) {\n\t\tdsu[u] = v;\n\t\tsm[v] += sm[u];\n\t\tsm[v] %= 26;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tvector<ll> vec;\n\ts.insert(s.begin(), 'a');\n\ts.push_back('a');\n\tfor (int i = 1; i < s.size(); i++) {\n\t\tvec.push_back((s[i] - s[i - 1] + 26) % 26);\n\t}\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tdsu[i] = i;\n\t\tsm[i] = vec[i];\n\t\t\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tfor (int i = 0; i < vec.size(); i++) uni(i, vec.size() - i - 1);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tuni(l - 1, r);\n\t}\n\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tll k = par(i);\n\t\tif (sm[k] != 0) {\n\t\t\tcout << \"NO\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\n\nint a[MAXN];\n\nvoid change(int L, int R, int v) {\n    a[L] += v;\n    a[R + 1] -= v;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    int M = (n + 1) / 2;\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            //cout << \"c1\";\n            x = n - x + 1;\n            y = n - y + 1;\n            std::swap(x, y);\n        }\n        if (x <=mm && y >mm) {\n            //cout<<\"c2\";\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        // cout << x << ' ' << y;\n        if (x > y) continue;\n        ls.emplace_back(x, y);\n    }\n    m = ls.size();\n    std::sort(begin(ls), end(ls));\n    int j = 0, val = 0;\n    for (int i = 1; i + i <= n; ++i) {\n        val = (val + a[i]) % 26;\n        val = (val + 26) % 26;\n        while (j < m && ls[j].se < i) j++;\n        if (j < m && ls[j].fi <= i) {\n            change(ls[j].fi, ls[j].se, -val);\n            val = 0;\n            //j++;\n        }\n        if (val != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\nconst int MOD = 26;\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntemplate<class T, int SZ> struct LazySeg {\n    T sum[2 * SZ], lazy[2 * SZ];\n    LazySeg() {\n        for (int i = 0; i < 2 * SZ; i++) {\n            sum[i] = 0;\n            lazy[i] = 0;\n        }\n    }\n    void push(int ind, int L, int R) {\n        sum[ind] += (R - L + 1) * lazy[ind];\n        if (L != R) {\n            lazy[2 * ind] += lazy[ind];\n            lazy[2 * ind + 1] += lazy[ind];\n        }\n        lazy[ind] = 0;\n    }\n    void pull(int ind) {\n        sum[ind] = sum[2 * ind] + sum[2 * ind + 1];\n    }\n    void build() {\n        for (int i = SZ - 1; i >= 1; i--) {\n            pull(i);\n        }\n    }\n    void upd(int lo, int hi, T inc, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (hi < L || R < lo) return ;\n        if (lo <= L && R <= hi) {\n            lazy[ind] = inc;\n            push(ind, L, R);\n            return;\n        }\n        int M = (L + R) / 2;\n        upd(lo, hi, inc, 2 * ind, L, M);\n        upd(lo, hi, inc, 2 * ind + 1, M + 1, R);\n        pull(ind);\n    }\n    T qsum(int lo, int hi, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return sum[ind];\n        int M = (L + R) / 2;\n        return qsum(lo, hi, 2 * ind, L, M) + qsum(lo, hi, 2 * ind + 1, M + 1, R);\n    }\n};\nint main() {\n//    ios_base::sync_with_stdio(0); cin.tie(0);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    int len = s.size();\n    vector<pair<int, int>> use;\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (r < len / 2) {\n            use.emplace_back(l, r);\n            continue;\n        }\n        if (l >= (len + 1) / 2) {\n            use.emplace_back(len - 1 - r, len - 1 - l);\n            continue;\n        }\n        if (l == len - 1 - r) {\n            continue;\n        }\n        if (l < len - 1 - r) {\n            use.emplace_back(l, len - 1 - r - 1);\n        } else {\n            use.emplace_back(len - 1 - r, l - 1);\n        }\n    }\n    int half = (len - 1) / 2 + 1;\n    vector<vector<int>> loc(half);\n    for (auto x: use) {\n        loc[x.first].push_back(x.second);\n    }\n    for (int i = 0; i < half; i++) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        while(loc[i].size() > 1) {\n            int r = loc[i].back();\n            loc[i].pop_back();\n            int l = loc[i].back() + 1;\n            loc[l].push_back(r);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int r: loc[i]) {\n            use.emplace_back(i, r);\n        }\n        loc[i].clear();\n    }\n    for (auto x: use) {\n        loc[x.second].push_back(x.first);\n    }\n    use.clear();\n    for (int i = half - 1; i >= 0; i--) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        reverse(loc[i].begin(), loc[i].end());\n        while (loc[i].size() > 1) {\n            int l = loc[i].back();\n            loc[i].pop_back();\n            int r = loc[i].back() - 1;\n            loc[r].push_back(l);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int l: loc[i]) {\n            use.emplace_back(l, i);\n        }\n        loc[i].clear();\n    }\n    string t;\n    for (int i = len - 1; i >= len - half; i--) {\n        t += s[i];\n    }\n    while (s.size() > half) {\n        s.pop_back();\n    }\n    len = half;\n    LazySeg<mi, (1 << 16)> seg;\n    for (int i = 0; i < len; i++) {\n        seg.upd(i, i, s[i] - '0');\n    }\n    for (auto x: use) {\n        int l = x.first;\n        int r = x.second;\n        int add = ((t[l] - '0') - seg.qsum(l, l).val + MOD) % MOD;\n        seg.upd(l, r, add);\n    }\n    for (int i = 0; i < len; i++) {\n        if (seg.qsum(i, i) != t[i] - '0') {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct dsu {\n  int cc;\n  vector<int> p, sz, a;\n  dsu(int n) : cc(n), p(n, -1), sz(n, 1), a(n) {}\n  int root(int v) const {\n    while (p[v] != -1) v = p[v];\n    return v;\n  }\n  bool unite(int u, int v) {\n    u = root(u), v = root(v);\n    if (u == v) return false;\n    --cc;\n    if (sz[u] < sz[v]) swap(u, v);\n    p[v] = u;\n    sz[u] += sz[v];\n    a[u] += a[v];\n    return true;\n  }\n  bool same(int u, int v) const { return root(u) == root(v); }\n  int size(int v) const { return sz[root(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  int n = s.size() / 2;\n  int m;\n  cin >> m;\n  vector<pair<int, int>> es;\n  while (m--) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    if (s.size() & 1 and r > n) {\n      --r;\n    }\n    if (l < n and n < r) {\n      if (n - l > r - n) {\n        r = 2 * n - r;\n      } else if (n - l < r - n) {\n        l = 2 * n - l;\n      } else {\n        continue;\n      }\n    }\n    if (n <= l) {\n      tie(l, r) = make_pair(2 * n - r, 2 * n - l);\n    }\n    es.emplace_back(l, r);\n  }\n  if (s.size() & 1) {\n    s.erase(begin(s) + n);\n  }\n  dsu d(n + 1);\n  for (int v = 0; v <= n; ++v) {\n    int goal = (v < n ? s[2 * n - v - 1] : 'a') - (v ? s[2 * n - v] : 'a');\n    int cur = (v < n ? s[v] : 'a') - (v ? s[v - 1] : 'a');\n    d.a[v] = goal - cur + 260;\n  }\n  for (auto e : es) {\n    d.unite(e.first, e.second);\n  }\n  for (int v = 0; v <= n; ++v) {\n    if (d.a[d.root(v)] % 26) {\n      cout << \"NO\\n\";\n      exit(0);\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n \ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n \ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n \nconst int N=100010;\n \nstruct node\n{\n\tint l,r;\n}a[N];\n \nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n \nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n \nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=n/2+1) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==1 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\t//printf(\"%d %d %d\\n\",i,a[i].l,a[i].r);\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\t//printf(\"%d\\n\",fa[5]);\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\t//printf(\"%d %d\\n\",head[i],d[i]);\n\t\tif (head[i]==0&&d[i]%26==0) {puts(\"NO\");return 0;}\n\t\tif (!head[i]) continue;\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;//printf(\"%d\\n\",find(5));\n\t\tfa[i+m0*2+1]=x+m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n \n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n \nconst int maxn = 100005;\n \nset<int> segs[maxn];\nchar s[maxn];\nint need[maxn], deladd[maxn];\nint n;\n \n \nvoid merge(set<int> &a, set<int> &b)\n{\n    if (a.size() < b.size()) a.swap(b);\n    for (auto t : b) a.insert(t);\n    b.clear();\n}\n \nint main()\n{\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    scanf(\"%d\", &n);\n    int mid1 = len / 2 - 1;\n    int mid2 = len / 2 + len % 2;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        l--, r--;\n//             cout << mid1 << ' ' << mid2 << endl;\n        while (l > mid1 && l < mid2) l++;\n        while (r > mid1 && r < mid2) r--;\n        if (l > r) continue;\n        if (l <= mid1 && r >= mid2)\n        {\n            tie(l, r) = make_pair(min(max(-1, mid1 - l), max(-1, r - mid2)) + 1, max(max(-1, mid1 - l), max(-1, r - mid2)));\n//             cout << l << ' ' << r << endl;\n        } else if (r <= mid1)\n        {\n            tie(l, r) = make_pair(mid1 - r, mid1 - l);\n        } else\n        {\n            l = l - mid2;\n            r = r - mid2;\n        }\n//         cout << \"seg \" << l << ' ' << r << endl;\n        if (l <= r) segs[l].insert(r);\n    }\n    int m = len / 2;\n    for (int i = 0; i < m; i++)\n    {\n        need[i] = (s[len / 2 - 1 - i] - s[len / 2 + len % 2 + i]) % 26;\n//         cout << need[i] << ' ';\n    }\n//     cout << endl;\n    int curadd = 0;\n    for (int i = 0; i < m; i++)\n    {\n        curadd -= deladd[i];\n        curadd %= 26;\n        need[i] += curadd;\n        need[i] %= 26;\n        while (!segs[i].empty() && *segs[i].begin() < i) segs[i].erase(segs[i].begin());\n        if (need[i] != 0)\n        {\n            if (segs[i].empty())\n            {\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n        if (!segs[i].empty())\n        {\n            int minr = *segs[i].begin();\n            while (!segs[i].empty() && *segs[i].begin() <= i) segs[i].erase(segs[i].begin());\n            curadd += -need[i];\n            deladd[minr + 1] += -need[i];\n            merge(segs[minr + 1], segs[i]);\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tint m = s.size() / 2;\n\t\tif (l == m && r == m) continue;\n\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t\tif (l >= m) l--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tm = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << \"YES\";\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[101000];\nint l,n,T,a[101000],x,y,used[101000];\nvector<int>G[505555];\n\nint dfs(int x){\n\tused[x]=1;\n\tint res=a[x];\n\tfor (auto y:G[x]) if (!used[y])\n\t\tres+=dfs(y);\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%s\",s+1); l=strlen(s+1); n=l>>1;\n\tfor (int i=1;i<=n;++i) a[i]=s[i]-s[l-i+1];\n\tfor (int i=n+1;i;--i) a[i]-=a[i-1];\n\tfor (cin>>T;T--;){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>n){\n\t\t\tx=l+1-x;\n\t\t\ty=l+1-y;\n\t\t\tswap(x,y);\n\t\t}else if (y>n){\n\t\t\ty=l+1-y;\n\t\t\tif (x>y) swap(x,y);\n\t\t\t--y;\n\t\t}\n\t\tif (x>n||x>y) continue;\n\t\ty=min(y,n);\n\t\tG[x].push_back(y+1);\n\t}\n\tfor (int i=1;i<=n+1;++i) if (!used[i]){\n\t\tif (dfs(i)%26) return !puts(\"NO\");\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct uftree{\n\tint par[100005],rank[100005];\n\tuftree(){\n\t\tfor(int i=0;i<100005;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x==par[x])return x;\n\t\treturn (par[x]=find(par[x]));\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x]=y;\n\t\t}else{\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t\tpar[y]=x;\n\t\t}\n\t}\n};\n\nuftree uf;\n\nstring str;\nint n;\nint l[100005],r[100005];\nint diff[100005];\nint sum[100005];\n\nint main(void){\n\tcin >> str;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i]--;\n\t\tuf.unite(l[i],r[i]);\n\t}\n\tn=str.size();\n\tdiff[0]=(str[0]-'a');\n\tfor(int i=0;i<n-1;i++){\n\t\tdiff[i+1]=(str[i+1]-'a')-(str[i]-'a');\n\t\tif(diff[i+1]<0)diff[i+1]+=26;\n\t}\n\tdiff[n]=26-(str[n-1]-'a');\n\tfor(int i=0;i<(n+1)/2;i++){\n\t\tuf.unite(i,n-i);\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tint v=uf.find(i);\n\t\tsum[v]+=diff[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tif(sum[i]%26!=0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\nconst int MOD = 26;\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntemplate<class T, int SZ> struct LazySeg {\n    T sum[2 * SZ], lazy[2 * SZ];\n    LazySeg() {\n        for (int i = 0; i < 2 * SZ; i++) {\n            sum[i] = 0;\n            lazy[i] = 0;\n        }\n    }\n    void push(int ind, int L, int R) {\n        sum[ind] += (R - L + 1) * lazy[ind];\n        if (L != R) {\n            lazy[2 * ind] += lazy[ind];\n            lazy[2 * ind + 1] += lazy[ind];\n        }\n        lazy[ind] = 0;\n    }\n    void pull(int ind) {\n        sum[ind] = sum[2 * ind] + sum[2 * ind + 1];\n    }\n    void build() {\n        for (int i = SZ - 1; i >= 1; i--) {\n            pull(i);\n        }\n    }\n    void upd(int lo, int hi, T inc, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (hi < L || R < lo) return ;\n        if (lo <= L && R <= hi) {\n            lazy[ind] = inc;\n            push(ind, L, R);\n            return;\n        }\n        int M = (L + R) / 2;\n        upd(lo, hi, inc, 2 * ind, L, M);\n        upd(lo, hi, inc, 2 * ind + 1, M + 1, R);\n        pull(ind);\n    }\n    T qsum(int lo, int hi, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return sum[ind];\n        int M = (L + R) / 2;\n        return qsum(lo, hi, 2 * ind, L, M) + qsum(lo, hi, 2 * ind + 1, M + 1, R);\n    }\n};\nint main() {\n//    ios_base::sync_with_stdio(0); cin.tie(0);\n    freopen(\"file.in\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    int len = s.size();\n    vector<pair<int, int>> use;\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (r < len / 2) {\n            use.emplace_back(l, r);\n            continue;\n        }\n        if (l >= (len + 1) / 2) {\n            use.emplace_back(len - 1 - r, len - 1 - l);\n            continue;\n        }\n        if (l == len - 1 - r) {\n            continue;\n        }\n        if (l < len - 1 - r) {\n            use.emplace_back(l, len - 1 - r - 1);\n        } else {\n            use.emplace_back(len - 1 - r, l - 1);\n        }\n    }\n    int half = (len - 1) / 2 + 1;\n    vector<vector<int>> loc(half);\n    for (auto x: use) {\n        loc[x.first].push_back(x.second);\n    }\n    for (int i = 0; i < half; i++) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        while(loc[i].size() > 1) {\n            int r = loc[i].back();\n            loc[i].pop_back();\n            int l = loc[i].back() + 1;\n            loc[l].push_back(r);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int r: loc[i]) {\n            use.emplace_back(i, r);\n        }\n        loc[i].clear();\n    }\n    for (auto x: use) {\n        loc[x.second].push_back(x.first);\n    }\n    use.clear();\n    for (int i = half - 1; i >= 0; i--) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        reverse(loc[i].begin(), loc[i].end());\n        while (loc[i].size() > 1) {\n            int l = loc[i].back();\n            loc[i].pop_back();\n            int r = loc[i].back() - 1;\n            loc[r].push_back(l);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int l: loc[i]) {\n            use.emplace_back(l, i);\n        }\n        loc[i].clear();\n    }\n    string t;\n    for (int i = len - 1; i >= len - half; i--) {\n        t += s[i];\n    }\n    while (s.size() > half) {\n        s.pop_back();\n    }\n    len = half;\n    LazySeg<mi, (1 << 16)> seg;\n    for (int i = 0; i < len; i++) {\n        seg.upd(i, i, s[i] - '0');\n    }\n    sort(use.begin(), use.end());\n    for (auto x: use) {\n        int l = x.first;\n        int r = x.second;\n        int add = ((t[l] - '0') - seg.qsum(l, l).val + MOD) % MOD;\n        seg.upd(l, r, add);\n    }\n    dbg(use);\n    for (int i = 0; i < len; i++) {\n        if (seg.qsum(i, i) != t[i] - '0') {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<ll, ll>  ii;\ntypedef vector<ll>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst ll INF = ll(1e9 + 7);\n\nconst ll tam = 100010;\n\nvector<ll> G[tam];\nll val[tam];\nbool vis[tam];\n\nll sum;\nvoid dfs(ll v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (ll u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    ll n;\n    cin >> n;\n    for (ll i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    if (s.size() == 1)\n    {\n    \tcout << \"YES\" << '\\n';\n    \treturn 0;\n    }\n    s = \"a\" + s + \"a\";\n/*\n    cout << s << endl;\n\tfor (ll i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n*/\n    for (ll i = 0; i < n; i++)\n    {\n    \tval[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \tval[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = false;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N],sum[N],p[N];\nchar s[N];\nvector<int> vct[N];\nint find(int x)\n{\n\treturn !p[x]?x:p[x]=find(p[x]);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2+1;++i)\n\t\tc[i]=(s[m-i+1]-s[i]+26)%26;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=m/2+1;i>=1;--i)\n\t\tc[i]-=c[i-1];\n\tfor(i=1;i<=m/2;++i)\n\t\tfor(j=vct[i].size()-1;j>=0;--j)\n\t\t\tif(find(i)!=find(vct[i][j]+1))\n\t\t\t{\n\t\t\t\tsum[find(vct[i][j]+1)]+=sum[find(i)];\n\t\t\t\tp[find(i)]=find(vct[i][j]+1);\n\t\t\t}\n\tfor(i=1;i<=m/2+1;++i)\n\t\tif(find(i)==i&&sum[i])\n\t\t{\n\t\t\tprintf(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <tuple>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define FOR(x,xs) for(auto &x: xs)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef pair<ll,ll> PL;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n  UnionFind(int n): par(n), rank(n) {\n    for(int i=0; i<n; i++) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int find(int x) {\n    if(par[x] == x) {\n      return x;\n    }\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) {\n        rank[x]++;\n      }\n    }\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  int l = s.size();\n  VI xs(l+2);\n  xs[0] = xs[l+1] = 0;\n  transform(s.begin(), s.end(), xs.begin()+1, [](char c){return c-'a';});\n  transform(xs.begin(), xs.end()-1, xs.begin()+1, xs.begin(), [](int x, int y){return (y+26-x)%26;});\n  xs.pop_back();\n  UnionFind u(l+1);\n  int N;\n  cin >> N;\n  REP(i,0,N) {\n    int l, r;\n    cin >> l >> r;\n    u.unite(l-1, r);\n  }\n  for(int i=0, j=l; i < j; i++, j--) {\n    u.unite(i, j);\n  }\n  VI sum(l+1, 0);\n  REP(i,0,l+1) {\n    sum[u.find(i)] += xs[i];\n    sum[u.find(i)] %= 26;\n  }\n  bool ans = all_of(sum.begin(), sum.end(), [](int x){return x == 0;});\n  cout << (ans ? \"YES\" : \"NO\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n\nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+35;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+35) {puts(\"NO\");return 0;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==1 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\tif (head[i]==0&&d[i]) {puts(\"NO\");return 0;}\n\t\tif (!head[i]) continue;\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;fa[i+m0*2+1]=x+m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\treturn b - a;\n}\n\nset<int> st;\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB({1, i});\n\t\tvec[r[i] + 1].PB({-1, i});\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t\tif(x == -1) st.erase(id);\n\t\t\telse st.insert(id);\n\t\t}\n\t\ttot[i] = totnow;\n\t\tif(tot[i] == 0) par[i] = 0;\n\t\telse {\n\t\t\tif(ms[st] == 0) ms[st] = i;\n\t\t\tpar[i] = ms[st];\n\t\t}\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(find(i) == find(n - i + 1)) {\n\t\t\tif(s[i - 1] != s[n - i]) bisa = false;\n\t\t}\n\t\telse {\n\t\t\tint pr = find(i);\n\t\t\tint rev = n - pr + 1;\n\t\t\tif(find(n - i + 1) == find(rev)) {\n\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\tbisa = false;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<ll, ll>  ii;\ntypedef vector<ll>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst ll INF = ll(1e9 + 7);\n\nconst ll tam = 100010;\n\nvector<ll> G[tam];\nll val[tam];\nbool vis[tam];\n\nll sum;\nvoid dfs(ll v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (ll u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    ll n;\n    cin >> n;\n    for (ll i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    if (s.size() == 1)\n    {\n    \tcout << \"YES\" << '\\n';\n    \treturn 0;\n    }\n    s = \"a\" + s + \"a\";\n/*\n    cout << s << endl;\n\tfor (ll i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n*/\n    for (ll i = 0; i < n; i++)\n    {\n    \t//val[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \t//val[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (ll i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = false;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len + 1);\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    for (int i = len; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1]) % 26;\n    }\n    x[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        r[i]++;\n    }\n    vector<int> root(len + 1), sz(len + 1);\n    iota(root.begin(), root.end(), 0);\n    fill(sz.begin(), sz.end(), 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    vector<int> summ(len + 1);\n    for (int i = 1; i <= len; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i <= len; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    if (t == -1) cout << \"YES\", exit(0);\n    int s = 0;\n    while (s != root[s]) s = root[s];\n    if (s == t) cout << \"YES\", exit(0);\n    else cout << \"NO\", exit(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring S; int Q, L[100009], R[100009], c[100009]; bool used[100009];\nint main() {\n\tcin >> S >> Q;\n\tfor (int i = 0; i < (int)S.size() / 2; i++) {\n\t\tc[i] = (S[i] - S[S.size() - 1 - i] + 26) % 26;\n\t}\n\tint mid = S.size() / 2;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> L[i] >> R[i]; L[i]--; R[i]--;\n\t\tint F1 = L[i], F2 = R[i] + 1;\n\t\tif (F1 >= mid)F1 = (S.size() - 0) - L[i];\n\t\tif (F2 >= mid)F2 = (S.size() - 1) - R[i];\n\t\tused[F1] = true; used[F2] = true;\n\t}\n\tfor (int i = 0; i < mid; i++) {\n\t\tif (c[i] != 0 && used[i] == false) { cout << \"NO\" << endl; return 0; }\n\t\tif (used[i] == true)break;\n\t}\n\tfor (int i = mid - 1; i >= 0; i--) {\n\t\tif (c[i] != 0 && used[i + 1] == false) { cout << \"NO\" << endl; return 0; }\n\t\tif (used[i + 1] == true)break;\n\t}\n\tfor (int i = 0; i < mid - 1; i++) {\n\t\tif (c[i] != c[i + 1] && used[i + 1] == false) { cout << \"NO\" << endl; return 0; }\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\n\nint n, m, dif[Nmax];\nbool special[Nmax];\nchar S[Nmax];\n\nvector<int> v[Nmax];\nbool used[Nmax];\n\nvoid add_edge(int x, int y)\n{\n    if(x == y) return;\n    v[x].push_back(y);\n    v[y].push_back(x);\n}\n\nvoid dfs(int node, bool &ok, int &sum)\n{\n    used[node] = 1;\n    ok |= special[node];\n    sum += dif[node];\n\n    for(auto it : v[node])\n        if(!used[it])\n            dfs(it, ok, sum);\n\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false); cin.tie(0);\n\n    cin >> (S+1);\n    n = strlen(S+1);\n    cin >> m;\n\n    int i;\n\n    for(i=1; i<n; ++i)\n        if(i <= n/2) dif[i] += (int)S[i] - (int)S[i+1];\n            else dif[n - i] += (int)S[i] - (int)S[i+1];\n\n    for(i=1; i<=m; ++i)\n    {\n        int x, y;\n        cin >> x >> y;\n        --x;\n\n        if(x > n/2) x = n - x;\n        if(y > n/2) y = n - y;\n\n        if(x && y) add_edge(x, y);\n            else if(y) special[y] = 1;\n                else if(x) special[x] = 1;\n    }\n\n    for(i=1; i<=n/2; ++i)\n        if(!used[i])\n        {\n            bool ok = 0;\n            int sum = 0;\n            dfs(i, ok, sum);\n\n            if(!ok && sum%26!=0)\n            {\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n\n    cout << \"YES\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N];\nchar s[N];\nvector<int> vct[N];\nvoid add(int x,int y)\n{\n\twhile(x<=m/2)\n\t{\n\t\tc[x]=(c[x]+y)%26;\n\t\tx+=x&-x;\n\t}\n}\nint sum(int x)\n{\n\tint rtn=0;\n\twhile(x>=1)\n\t{\n\t\trtn=(rtn+c[x])%26;\n\t\tx-=x&-x;\n\t}\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=(s[m-i+1]-s[i]+26)%26;\n\t\tadd(i,j);\n\t\tadd(i+1,(26-j)%26);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=sum(i);\n\t\tif(vct[i].empty())\n\t\t{\n\t\t\tif(j!=0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsort(vct[i].begin(),vct[i].end());\n\t\tadd(i+1,(26-j)%26);\n\t\tadd(vct[i][0]+1,j);\n\t\tfor(j=1,k=vct[i][0]+1;j<vct[i].size();++j)\n\t\t\tif(k<=vct[i][j])\n\t\t\t\tvct[k++].push_back(vct[i][j]);\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int N=100010;\n\nstruct node\n{\n\tint l,r;\n}a[N];\n\nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next[N*2];\nbool ok[N];\n\nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=(n+1)/2) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n;i++) h[i]+=h[i-1];\n\tfor (int i=1;i<=n/2;i++) if (h[i]==0&&h[n+1-i]==0&&b[i]!=b[n+1-i]) {puts(\"NO\");return 0;}\n\tfor (int i=1;i<=m0;i++) {w[i].x=rand();w[i].y=rand();}\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\ts[a[i].l].x^=w[i].x;s[a[i].r+1].x^=w[i].x;\n\t\ts[a[i].r].y^=w[i].y;s[a[i].r+1].y^=w[i].y;\n\t}\n\tfor (int i=1;i<=n/2;i++)\n\t{\n\t\ts[i].x^=s[i-1].x;s[i].y^=s[i-1].y;\n\t\tif (!g[s[i]])\n\t\t\tg[s[i]]=b[i]-b[n+1-i]+35;\n\t\telse\n\t\t\tif (g[s[i]]!=b[i]-b[n+1-i]+35) {puts(\"NO\");return 0;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==0 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\tif (head[a[i].l]) next[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next[head[i]];\n\t\tif (head[i]==0&&d[i]) {puts(\"NO\");return 0;}\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;fa[i+m0*2+1]=x*m0*2+1;\n\t\td[x]+=d[i];next[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n \ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n \ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n \nconst int N=100010;\n \nstruct node\n{\n\tint l,r;\n}a[N];\n \nchar b[N];\nint h[N];\npii w[N],s[N];\nmap<pii,int> g;\nint head[N],tail[N],fa[N*3],d[N],next0[N*2];\nbool ok[N];\n \nint find(int x)\n{\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n \nint main()\n{\n\tsrand(time(0));\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"input.txt\",\"r\",stdin);\n\t\t//freopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",b+1);int n=strlen(b+1);\n\tint m,m0=0;scanf(\"%d\",&m);memset(h,0,sizeof(h));\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l,r;scanf(\"%d%d\",&l,&r);h[l]++;h[r+1]--;\n\t\tif (l+r==n+1) continue;\n\t\tif (r<=(n+1)/2) {a[++m0].l=l;a[m0].r=min(r,n/2);continue;}\n\t\tif (l>=n/2+1) {a[++m0].l=n-r+1;a[m0].r=n-max(l,(n+1)/2+1)+1;continue;}\n\t\tif (l+r<=n) {a[++m0].l=l;a[m0].r=n-r;} else {a[++m0].l=n-r+1;a[m0].r=l-1;}\n\t}\n\tfor (int i=1;i<=n/2+1;i++) head[i]=0;\n\tfor (int i=2;i<=2*m0+2+n/2;i++) fa[i]=i;\n\tfor (int i=1;i<=n/2+1;i++) d[i]=(i==n/2+1 ? 0 : b[i]-b[n+1-i])-(i==1 ? 0: b[i-1]-b[n+2-i]);\n\tfor (int i=1;i<=m0;i++)\n\t{\n\t\tfa[2*i]=2*m0+1+a[i].l;fa[2*i+1]=2*m0+2+a[i].r;\n\t\t//printf(\"%d %d %d\\n\",i,a[i].l,a[i].r);\n\t\tif (head[a[i].l]) next0[2*i]=head[a[i].l]; else tail[a[i].l]=2*i;head[a[i].l]=2*i;\n\t\tif (head[a[i].r+1]) next0[2*i+1]=head[a[i].r+1]; else tail[a[i].r+1]=2*i+1;head[a[i].r+1]=2*i+1;\n\t}\n\t//printf(\"%d\\n\",fa[5]);\n\tmemset(ok,0,sizeof(ok));\n\tfor (int i=1;i<=n/2+1;i++)\n\t{\n\t\twhile (head[i]&&ok[head[i]/2]) head[i]=next0[head[i]];\n\t\t//printf(\"%d %d\\n\",head[i],d[i]);\n\t\tif (head[i]==0&&d[i]%26) {puts(\"NO\");return 0;}\n\t\tif (!head[i]) continue;\n\t\tok[head[i]/2]=1;int x=find(head[i]^1)-m0*2-1;//printf(\"%d\\n\",find(5));\n\t\tfa[i+m0*2+1]=x+m0*2+1;\n\t\td[x]+=d[i];next0[tail[i]]=head[x];head[x]=head[i];\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UF {\n    int n;\n    vector<int> par;\n    UF(int _n) : n(_n) {\n        for(int i = 0; i < n; i++) par.push_back(i);\n    }\n    int find(int a){\n        if(a != par[a]) par[a] = find(par[a]);\n        return par[a];\n    }\n    bool join(int a, int b){\n        a = find(a);\n        b = find(b);\n        par[a] = b;\n        return (a != b);\n    }\n};\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring s;\n\tcin >> s;\n\tint n = (int)s.size();\n\ts = \"a\" + s + \"a\";\n\tvector<int> diffs(n+1);\n\tfor(int i = 0; i <= n; i++){\n\t\tdiffs[i] += (s[i+1] - 'a');\n\t\tdiffs[i] -= (s[i] - 'a');\n\t}\n\tUF uf(n+1);\n\tfor(int i = 0; i <= n; i++) uf.join(i, n-i);\n\tint x;\n\tcin >> x;\n\tfor(int i = 0; i < x; i++){\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tuf.join(l, r);\n\t}\n\tvector<int> tot(n+1, 0);\n\tfor(int i = 0; i <= n; i++) tot[uf.find(i)] += diffs[i];\n\tfor(int i = 0; i <= n; i++){\n\t\tif(tot[i] % 26 != 0){\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"NO\"); exit(0); }\nvoid fg(vector<int> G[], int a, int b) { G[a].eb(b); G[b].eb(a); }\n\nconst bool debug = 0;\nconst int MAXN = 200055;\nconst int MAXK = 200055;\n\nvector<int> G[MAXN];\nbitset<MAXN> chk;\n\nint D[MAXN], E[MAXN];\n\nint B[MAXK], C[MAXK];\nchar A[MAXN];\n\nint N, K;\n\nint f(int i) {\n\tint ret = E[i]; chk[i] = true;\n\tfor(int v : G[i]) if(!chk[v]) {\n\t\tret = (ret + f(v)) % 26;\n\t}\n\treturn ((ret % 26) + 26) % 26;\n}\n\nint main() {\n\tscanf(\" %s\", A+1);\n\tN = int(strlen(A+1));\n\tscanf(\"%d\", &K);\n\tfor(int i = 1; i <= K; i++) scanf(\"%d%d\", &B[i], &C[i]);\n\n\tif(N&1) {\n\t\tN++;\n\t\tfor(int i = N-1; N/2 <= i; i--) A[i+1] = A[i];\n\t\tfor(int i = 1; i <= K; i++) {\n\t\t\tif(N/2 < B[i]) B[i]++;\n\t\t\tif(N/2 <= C[i]) C[i]++;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= K; i++) {\n\t\tif(C[i] <= N/2) continue;\n\t\tif(N/2 < B[i]) {\n\t\t\tB[i] = N+1-B[i];\n\t\t\tC[i] = N+1-C[i];\n\t\t\tswap(B[i], C[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tint l = N/2-B[i]+1, r = C[i]-N/2;\n\t\tif(l > r) swap(l, r);\n\t\tB[i] = N/2-r+1;\n\t\tC[i] = N/2-l;\n\t}\n\n\tif(debug) {\n\t\tprintf(\"N=%d, K=%d\\n\", N, K);\n\t\tfor(int i = 1; i <= N; i++) putchar(A[i]); puts(\"\");\n\t\tfor(int i = 1; i <= K; i++)\n\t\t\tprintf(\"%d ; %d %d\\n\", i, B[i], C[i]);\n\t}\n\n\tN /= 2;\n\tfor(int i = 1; i <= N; i++)\n\t\tD[i] = (A[N*2+1-i] - A[i] + 26) % 26;\n\tfor(int i = 1; i <= N+1; i++)\n\t\tE[i] = ((D[i] - D[i-1] + 26) % 26 + 26) % 26;\n\tfor(int i = 1; i <= K; i++) C[i]++;\n\tN++;\n\n\tfor(int i = 1; i <= K; i++) if(B[i] < C[i]) fg(G, B[i], C[i]);\n\tfor(int i = 1; i <= N; i++) if(!chk[i]) {\n\t\tint t = f(i);\n\t\tif(t) fuk();\n\t}\n\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sign(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\nusing mint = mod_int<26>;\n\ntemplate<typename M>\nstruct fenwick_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    fenwick_tree(int n) : n(n), data(n + 1, M::id()) {}\n    void add(int i, const T &x) { for (i++; i <= n; i += i & -i) { data[i] = M::op(data[i], x); }}\n    T get_sum(int i) const {\n        T ret = M::id();\n        for (; i > 0; i -= i & -i) { ret = M::op(ret, data[i]); }\n        return ret;\n    }\n    T get_sum(int l, int r) const {\n        return M::op(get_sum(r), M::inv(get_sum(l)));\n    }\n};\n\ntemplate<typename M>\nstruct fenwick_tree_range {\n    using T = typename M::T;\n    fenwick_tree<M> ft;\n    fenwick_tree_range(int n) : ft(n + 1) {}\n    void add(int l, int r, const T &x) { ft.add(l, x), ft.add(r, -x); }\n    T operator[](int i) const { return ft.get_sum(i + 1); }\n};\n\nstruct rsq {\n    using T = mint;\n    static T id() { return 0; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static T inv(const T &a) { return -a; }\n};\n\nstring S;\nint N;\nint L[110000], R[110000];\npriority_queue_rev<int> rs[110000];\nsigned main() {\n    cin >> S >> N;\n    int K = S.length();\n    rep(i, N) {\n        cin >> L[i] >> R[i];\n        if (L[i] - 1 < K - R[i]) { rs[L[i] - 1].push(min(R[i], K - R[i])); }\n        else if (L[i] - 1 > K - R[i]) { rs[K - R[i]].push(min(L[i] - 1, K - L[i] + 1)); }\n    }\n    fenwick_tree_range<rsq> ft(K / 2);\n    rep(i, K / 2) { ft.add(i, i + 1, S[i] - S[K - i - 1]); }\n    rep(i, K / 2) {\n        if (rs[i].empty()) {\n            if (ft[i] != 0) { fin(\"NO\"); }\n            continue;\n        }\n        int cur = rs[i].top();\n        rs[i].pop();\n        ft.add(i, cur, -ft[i]);\n        while (!rs[i].empty()) {\n            if (cur < rs[i].top()) { rs[cur].push(rs[i].top()); }\n            cur = rs[i].top(), rs[i].pop();\n        }\n    }\n    cout << \"YES\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nusing ld = long double;\nll INF = LLONG_MAX;\n\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid print() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); \n\t}\n}\n\nusing namespace output;\n\ntemplate<class T> struct Seg { \n\tconst T ID = 0; // comb(ID,b) must equal b\n\tT combine(T a, T b) { return (a+b)%26;} \n\tint n; vector<T> seg;\n\tvoid init(int _n) { n = _n; seg.assign(2*n,ID);}\n\n\tvoid update(int p, T value) {\t// set value at position p\n\t\tseg[p += n] += value;\n\t\tfor (p /= 2; p; p /= 2) seg[p] = combine(seg[2*p], seg[2*p+1]);\n\t}\n    \n\tT query(int l, int r) {\t // sum on interval [l, r]\n\t\tT ra = ID, rb = ID; \n\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {\n\t\t\tif (l&1) ra = combine(ra,seg[l++]);\n\t\t\tif (r&1) rb = combine(seg[--r],rb);\n\t\t}\n\t\treturn combine(ra,rb);\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring S; cin >> S;\n\tint N; cin >> N;\n\tvector<vi> startsAt (S.size()+1);\n\tvector<vi> endsAt (S.size()+1);\n\tF0R(i, N) {\n\t\tint l, r; cin >> l >> r; --l; --r;\n\t\tstartsAt[l].push_back(r+1); // orig\n\t\tif (l+1 == S.size()-r) {\n\n\t\t} else if (l+1 < S.size()-r) {\n\t\t\tstartsAt[r+1].push_back(S.size()-l);\n\t\t} else {\n\t\t\tstartsAt[S.size()-r-1].push_back(l);\n\t\t}\n\t}\n\n\tF0R(i, S.size()+1) {\n\t\tsort(startsAt[i].begin(), startsAt[i].end());\n\t\tstartsAt[i].erase(unique(startsAt[i].begin(), startsAt[i].end()), startsAt[i].end());\n\n\t\tfor (int j = 1; j < startsAt[i].size(); ++j) {\n\t\t\tstartsAt[startsAt[i][0]].push_back(startsAt[i][j]);\n\t\t}\n\t\tif (startsAt[i].size()) startsAt[i] = vi {startsAt[i][0]};\n\t\tfor (int j : startsAt[i]) endsAt[j].push_back(i);\n\t}\n\n\tstartsAt.assign(S.size() + 1, vi {});\n\n\tR0F(i, S.size()+1) {\n\t\tsort(endsAt[i].begin(), endsAt[i].end());\n\t\tendsAt[i].erase(unique(endsAt[i].begin(), endsAt[i].end()), endsAt[i].end());\n\n\t\tfor (int j = 0; j + 1 < endsAt[i].size(); ++j) {\n\t\t\tendsAt[endsAt[i].back()].push_back(endsAt[i][j]);\n\t\t}\n\t\tif (endsAt[i].size()) endsAt[i] = vi {endsAt[i].back()};\n\t\tfor (int j : endsAt[i]) startsAt[j].push_back(i);\n\t}\n\n\tSeg<int> seg; seg.init(S.size());\n\tF0R(i, S.size()) {\n\t\tif (i == 0) {\n\t\t\tseg.update(i, S[i]-'a');\n\t\t} else {\n\t\t\tseg.update(i, S[i] - S[i-1]);\n\t\t}\n\t}\n\n\tfor (int l = 0; l < S.size() / 2; ++l) {\n\t\tint lc = seg.query(0, l); lc = (lc + 26) % 26;\n\t\tint rc = seg.query(0, S.size()-l-1); rc = (rc + 26) % 26;\n\t\tif (rc != lc) {\n\t\t\tif (startsAt[l].size() && (startsAt[l][0] <= S.size()-l-1)) {\n\t\t\t\tint cycle = (rc - lc + 26) % 26;\n\t\t\t\tseg.update(l, cycle);\n\t\t\t\tseg.update(startsAt[l][0], -cycle);\n\t\t\t} else {\n\t\t\t\tprint(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\n\t}\n\tprint(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]==kk);\n\t\t\telse if(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i] = a[i+1]-a[i];\n\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(l[i]>r[i]) continue;\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t}\n\tbool f = true;\n\tvector<vector<int> > v(n2+1);\n\trep(i, n2+1) v[uf.find(i)].push_back(i);\n\trep(i, n2){\n\t\tif(v[i].empty()) continue;\n\t\tll x = 0;\n\t\tbool g = false;\n\t\trep(j, v[i].size()){\n\t\t\tx += t[v[i][j]];\n\t\t\t//if(v[i][j]==n2) g = true;\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len + 2);\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (b[i] + 26 - a[i]) % 26;\n    }\n    //for (int i = 0; i <= len; i++)\n    //{\n    //    cout << x[i] << \" \";\n    //}\n    //cout << endl;\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    //for (int i = 0; i < x.size(); i++) cout << x[i] << \" \"; cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    vector<int> root(len + 2), sz(len + 2);\n    iota(root.begin(), root.end(), 0);\n    fill(sz.begin(), sz.end(), 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    vector<int> summ(len + 2);\n    for (int i = 1; i < x.size(); i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i <= len; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    if (t == -1) cout << \"YES\", exit(0);\n    int s = 0;\n    while (s != root[s]) s = root[s];\n    if (s == t) cout << \"YES\", exit(0);\n    else cout << \"NO\", exit(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nusing ui = uint32_t;\n\nconst int maxn = 50100;\n//bitset<maxn> q[maxn];\nui q[4000 * maxn];\nint off[maxn];\nint qmem[maxn];\nint m;\n\nvoid qset(int x, int y) {\n  //assert((m - y) / 32 < qmem[x]);\n  q[off[x] + qmem[x] - 1 - (m - y) / 32] |= (ui(1) << (m - y) % 32);\n}\n\nbool qget(int x, int y) {\n  //assert((m - y) / 32 < qmem[x]);\n  return q[off[x] + qmem[x] - 1 - (m - y) / 32] & (ui(1) << (m - y) % 32);\n}\n\nvoid qor(int x, int y) {\n  for (int i = 0; i < qmem[y]; ++i) {\n    int block = off[y] + i;\n    int from = off[x] + qmem[x] - qmem[y] + i;\n    q[block] |= q[from];\n  }\n}\n\nint qfind_first(int x) {\n  for (int i = 0; i < qmem[x]; ++i) {\n    if (q[off[x] + i]) {\n      for (int j = 0; j < 32; ++j) {\n        if (qget(x, i * 32 + j))\n          return i * 32 + j;\n      }\n      assert(false);\n    }\n  }\n  return maxn;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  m = n / 2;\n  int OFF = 0;\n  for (int i = m; i >= 0; --i) {\n    int mem = (m - i + 1 + 31) / 32;\n    off[i] = OFF;\n    qmem[i] = mem;\n    OFF += mem;\n  }\n\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      qset(nl, nr);\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = qfind_first(i);\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      qor(to, i);\n      //q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <tuple>\n#include <iterator>\n#include <cmath>\n\nusing namespace std;\n\nchar arr[100010];\nvector<int> lis[100010];\n\nint cnt[100010];\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    int n, m, i, j;\n    scanf(\"%s%d\", arr + 1, &m);\n\n    n = strlen(arr + 1);\n\n    for(i = 0; i < m; i++)\n    {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n\n        if(l <= n / 2 && r > (n + 1) / 2)\n        {\n            int ln = n / 2 - l;\n            int rn = r - ((n + 1) / 2 + 1);\n            if(ln >= rn)\n                r = n / 2 - rn - 1;\n            else\n                l = ((n + 1) / 2 + 1) + ln + 1;\n        }\n\n        if(n % 2 == 1)\n        {\n            if(r == (n + 1) / 2)\n                r--;\n            if(l == (n + 1) / 2)\n                l++;\n        }\n\n        if(r < l)\n            continue;\n\n        if(r > n / 2)\n        {\n            r = n - r + 1;\n            l = n - l + 1;\n            swap(l, r);\n        }\n\n        lis[l].push_back(r);\n    }\n\n    int c = 0;\n    for(i = 1; i <= n / 2; i++)\n    {\n        c += cnt[i];\n\n        int t = (arr[n - i + 1] - arr[i] - c) % 26;\n\n        if(lis[i].empty())\n        {\n            if(!t)\n                continue;\n\n            printf(\"NO\\n\");\n            return 0;\n        }\n\n        sort(lis[i].begin(), lis[i].end());\n        lis[i].erase(unique(lis[i].begin(), lis[i].end()), lis[i].end());\n\n        for(j = 1; j < lis[i].size(); j++)\n            lis[lis[i][j - 1] + 1].push_back(lis[i][j]);\n        \n        c += t;\n        cnt[lis[i][0] + 1] -= t;\n    }\n\n    printf(\"YES\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n \nusing namespace std;\n \nstruct S{\n\tL s,e;\n};\n \nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n \nset<S>st;\n \nchar str[100010];\nL b[100010];\nL n,len;\n \nL tr[400040];\n \nvoid update(L now,L S,L E,L s,L e,L val){\n\twhile(e)\n\t{\n\t\ttr[e]+=val;\n\t\te^=e&-e;\n\t}\n\ts--;\n\twhile(s)\n\t{\n\t\ttr[e]-=val;\n\t\ts^=s&-s;\n\t}\n}\n \nL get(L now,L S,L E,L loc){\n\tL ret=0;\n\twhile(loc<=len)\n\t{\n\t\tret+=tr[loc];\n\t\tloc+=loc&-loc;\n\t}\n\treturn ret;\n}\n \nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n \nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\t//printf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//for(set<S>::iterator it=st.begin();it!=st.end();it++)\n\t//\tprintf(\"%lld %lld\\n\",it->s,it->e);\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(st.empty()) break;\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()) break;\n\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\tS temp2=*it;\n\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\tst.erase(temp2); \n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!st.empty()&&st.begin()->s==i)\n\t\t\t{\n\t\t\t\tS range=*(st.begin());\n\t\t\t\tst.erase(st.begin());\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tif(st.empty()) break;\n\t\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\t\tif(it==st.end()) break;\n\t\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\t\tS temp2=*it;\n\t\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\t\tst.erase(temp2); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD=26;\nclass BIT{\n    int n;\n    vector<int> dat;\n    public:\n    BIT(int n):n(n),dat(n,0){};\n    void add(int pos,int x){\n        pos++;\n        while(pos<=n){\n            dat[pos-1]=(dat[pos-1]+x)%MOD;\n            pos+=(pos & -pos);\n        }\n    }\n    int sum(int pos){\n        pos++;\n        int res=0;\n        while(pos>0){\n            res=res+dat[pos-1];\n            pos-=(pos & -pos);\n        }\n        return (res%MOD+MOD)%MOD;\n    }\n    void debug(){\n        cerr<<\"####\"<<endl;\n        for(int i=0;i<n;i++){\n            cerr<<dat[i]<<\" \";\n        }\n        cerr<<endl;\n    }\n};\nint main(){\n    string s;\n    cin>>s;\n    int erasep=s.size()+2;\n    if(s.size()%2==1){\n        erasep=s.size()/2;\n        string buf;\n        for(int i=0;i<s.size();i++){\n            if(i!=erasep) buf+=s[i];\n        }\n        s=buf;\n    }\n    int n;\n    cin>>n;\n    vector<int> l,r;\n    for(int i=0;i<n;i++){\n        int tmpl,tmpr;\n        cin>>tmpl>>tmpr;\n        tmpl--,tmpr--;\n        if(tmpl==tmpr && tmpl==erasep) continue;\n        if(erasep<tmpl) tmpl--;\n        if(erasep<tmpr) tmpr--;\n        l.push_back(tmpl),r.push_back(tmpr);\n    }\n    n=l.size();\n\n    vector<int> v(s.size()/2);\n    for(int i=0;i<v.size();i++){\n        v[i]=(int)(s[s.size()-1-i])-(int)(s[i]);\n    }\n\n    vector<set<int>> com(v.size());\n    for(int i=0;i<n;i++){\n        if(r[i]<v.size()){\n            com[l[i]].insert(r[i]);\n        }\n        else if(v.size()<=l[i]){\n            com[s.size()-1-r[i]].insert(s.size()-1-l[i]);\n        }\n        else{\n            int dl=v.size()-l[i];\n            int dr=r[i]-v.size()+1;\n            if(dl<dr){\n                com[s.size()-1-r[i]].insert(v.size()-1-dl);\n            }\n            if(dl>dr){\n                com[l[i]].insert(v.size()-1-dr);\n            }\n        }\n    }\n    BIT bit(v.size()+1);\n    for(int i=0;i<v.size();i++){\n        if(com[i].empty()){\n            int x=bit.sum(i)+v[i];\n            if(x%MOD!=0){\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n        else{\n            int x;\n            int pre=-1;\n            for(auto &e:com[i]){\n                if(pre==-1){\n                    pre=e;\n                    x=e;\n                }\n                else{\n                    com[pre+1].insert(e);\n                    pre=e;\n                }\n            }\n            int y=-(bit.sum(i)+v[i]);\n            bit.add(i,y);\n            bit.add(x+1,-y);\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\n\nstruct UF {\n\tint par[N],rank[N];\n\t\n\tvoid init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = par[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstring s;\nint n, l[N], r[N], a[N], t[N], used[N];\n\nint main(){\n\tcin>>s;\n\tn = s.size();\n\tll kk = (n+1)/2;\n\tint m;\n\tcin>>m;\n\trep(i, m){\n\t\tcin>>l[i]>>r[i];\n\t\tif(n%2==1){\n\t\t\tif(l[i]>=kk) l[i]--;\n\t\t\tif(r[i]>=kk) r[i]--;\n\t\t}\n\t\tl[i]--; r[i]--;\n\t}\n\tif(n%2){\n\t\ts = s.substr(0, kk-1)+s.substr(kk);\n\t\tn--;\n\t}\n\tint n2 = n/2;\n\trep(i, n2) a[i] = s[i]-s[n-i-1];\n\tfor(ll i = n2-1; i >= 0; i--) t[i] = a[i+1]-a[i];\n\n\tUF uf;\n\tuf.init(n2+1);\n\trep(i, m){\n\t\tif(r[i]<n2) continue;\n\t\tif(l[i]>=n2){\n\t\t\tll r2 = 2*n2-l[i]-1;\n\t\t\tll l2 = 2*n2-r[i]-1;\n\t\t\tl[i] = l2;\n\t\t\tr[i] = r2;\n\t\t} else {\n\t\t\tll wl = n2-l[i];\n\t\t\tll wr = r[i]-n2+1;\n\t\t\tif(wl==wr){\n\t\t\t\tl[i] = r[i] = -1;\n\t\t\t} else if(wl>wr){\n\t\t\t\tr[i] = l[i]+wl-wr-1;\n\t\t\t} else {\n\t\t\t\tr[i] = l[i]-1;\n\t\t\t\tl[i] = l[i] - (wr-wl);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m){\n\t\tif(l[i]<0) continue;\n\t\tuf.unite(l[i], r[i]+1);\n\t}\n\tbool f = true;\n\trep(i, n2){\n\t\tif(used[i]) continue;\n\t\tused[i] = 1;\n\t\tll x = t[i];\n\t\tbool g = false;\n\t\tfor(ll j = i+1; j <= n2; j++){\n\t\t\tif(uf.same(i, j)){\n\t\t\t\tx += t[j];\n\t\t\t\tused[j] = 1;\n\t\t\t\tif(j==n2) g = true;\n\t\t\t}\n\t\t}\n\t\tif(!g && (x%26+26)%26!=0) f = false;\n\t}\n\tcout<<(f?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <math.h>\n#include <set>\n#include <iomanip>\n#include <time.h>\n#include <list>\n#include <stdio.h>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <assert.h>\n#include <memory.h>\n\n#define mk make_pair\n#define sc second\n#define fr first\n#define pb emplace_back\n#define all(s) s.begin(), s.end()\n#define sz(s) ( (int)s.size() )\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nchar s[N];\n\nint n, ar[N], sz[N], p[N], sum[N];\n\nint get (int v)\n{\n    return v == p[v] ? v : p[v] = get(p[v]);\n}\n\nvoid unite (int a, int b)\n{\n    a = get(a);\n    b = get(b);\n\n    if (a == b) return;\n\n    if (sz[a] > sz[b])\n        swap(a, b);\n\n    sum[b] += sum[a];\n    sum[b] %= 26;\n\n    sz[b] += sz[a];\n    p[a] = b;\n}\n\nmain ()\n{\n    scanf(\"%s\", s + 1);\n    s[0] = 'a';\n    n = strlen(s);\n    s[n] = 'a';\n    for (int i = 0; i < n; i++)\n    {\n        sz[i] = 1;\n        p[i] = i;\n\n        ar[i] = s[i + 1] - s[i];\n\n        if (ar[i] < 0)\n            ar[i] += 26;\n\n        sum[i] = ar[i];\n    }\n    for (int i = 0; i < n; i++)\n        unite(i, n - i - 1);\n\n    int m, a, b;\n    cin >> m;\n    while (m--)\n    {\n        scanf(\"%d%d\", &a, &b);\n        unite(a - 1, b);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (p[i] == i && sum[i] != 0)\n        {\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n\nint par1[100011];\nint rank1[100011];\n//n要素で初期化\nvoid init(int n){\n   for(int i=0;i<n;i++){\n       par1[i]=i;\n       rank1[i]=0;\n   }\n}\n//木の根を求める\nint find(int x){\n    if(par1[x] ==x){\n         return x;\n    }else{\n         return par1[x]=find(par1[x]);\n    }\n}\n//xとyの属する集合を併合\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n\n    if(rank1[x]<rank1[y]){\n         par1[x]=y;\n    }else{\n         par1[y]=x;\n         rank1[x]++;\n    }\n}\n//xとyが同じ集合に属するか否か\nbool same(int x,int y){\n     return find(x)==find(y);\n}\n\nint A[100005];\nint B[100005];\nstring S;\nint M;\nint L[100001];\nint R[100001];\nLL C[100001];\nint main(){\n    cin>>S;\n    A[0]=0;\n    REP(i,S.size()){\n        A[i+1]=(S[i]-'a');\n    }\n    A[S.size()+1]=0;\n    REP(i,S.size()+1){\n        B[i]=A[i+1]-A[i];\n    }\n    init(S.size()+2);\n    {\n       int l=0;\n       int r=S.size();\n       while(l<r){\n           unite(l,r);\n           l++;\n           r--;\n       }\n    }\n    cin>>M;\n    REP(i,M){\n        cin>>L[i]>>R[i];\n        L[i]--;\n        unite(L[i],R[i]);\n    }\n    REP(i,S.size()+1){\n        C[i]=26*(LL)(1000000000);\n        //C[i]=26;\n    }\n    REP(i,S.size()+1){\n        int p=find(i);\n     //   cout<<p<<\" \";\n        C[p]+=B[i];\n    }\n   // cout<<endl;\n    bool check=true;\n    REP(i,S.size()+1){\n        if(C[i]%26!=0)check=false;\n    }\n   /* REP(i,S.size()+2){\n        cout<<A[i]<<\" \";\n    }\n    cout<<endl;\n    REP(i,S.size()+1){\n        cout<<B[i]<<\" \";\n    }\n    cout<<endl;\n    REP(i,S.size()+1){\n        cout<<C[i]<<\" \";\n    }\n    cout<<endl;\n    */\n    if(check){\n        cout<<\"YES\"<<endl;\n    }else{\n        cout<<\"NO\"<<endl;\n    }\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\n\nconst ll N = 120000;\nconst ll MOD = 1e9 + 239;\nconst ll K1 = 2;\nconst ll K2 = 1;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N];\nll degk1[N], degk2[N];\nll ha1[N], ha2[N];\n\nint main()\n{\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    //cout << \"\\n\";\n    //for (int i = 0; i < n; i++) cout << l[i] << \" \" << r[i] << \"\\n\";\n    //cout << \"\\n\";\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    degk1[0] = 1;\n    degk2[0] = 1;\n    for (int i = 1; i < N; i++) degk1[i] = degk1[i - 1] * K1 % MOD;\n    for (int i = 1; i < N; i++) degk2[i] = degk2[i - 1] * K2 % MOD;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] != -1)\n        {\n            ha1[l[i]] = (ha1[l[i]] + degk1[i]) % MOD;\n            ha1[r[i] + 1] = (ha1[r[i] + 1] + MOD - degk1[i]) % MOD;\n            ha2[l[i]] = (ha2[l[i]] + degk2[i]) % MOD;\n            ha2[r[i] + 1] = (ha2[r[i] + 1] + MOD - degk2[i]) % MOD;\n        }\n    }\n    for (int i = 1; i < len; i++)\n    {\n        ha1[i] = (ha1[i - 1] + ha1[i]) % MOD;\n        ha2[i] = (ha2[i - 1] + ha2[i]) % MOD;\n    }\n    //for (int i = 0; i < len; i++) cout << ha[i] << \" \"; cout << \"\\n\";\n    string a = \"\", b = \"\";\n    for (int i = 0; i < len; i++) a += s[i];\n    for (int i = len; i < s.size(); i++) b += s[i];\n    reverse(b.begin(), b.end());\n    vector<int> x(len);\n    for (int i = 0; i < len; i++)\n    {\n        x[i] = (b[i] + 26 - a[i]) % 26;\n    }\n    map<pair<ll, ll>, set<ll> > val;\n    for (int i = 0; i < len; i++)\n    {\n        val[{ha1[i], ha2[i]}].insert(x[i]);\n        if (val[{ha1[i], ha2[i]}].size() > 1) cout << \"NO\", exit(0);\n    }\n    if (val[{0, 0}].size() && *(val[{0, 0}].begin()) != 0) cout << \"NO\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\nclass UnionFind {\npublic:\n  int n;\n  vi par; //親\n  vi ran; //木の深さ\n  vi num; //要素数\n  int g; // group数\n \n  UnionFind(int _n) {\n    n = _n;\n    g = n;\n    par.resize(n); ran.resize(n); num.resize(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i; ran[i] = 0; num[i] = 1;\n    }\n  }\n \n  //木の根を求める\n  int find(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      return par[x] = find(par[x]);\n    }\n  }\n \n  //xとyの属する集合を併合\n  void unite(int x, int y) {\n    x = find(x); y = find(y);\n    int numsum = num[x] + num[y];\n    if (x == y) {\n      return;\n    }\n    if (ran[x]<ran[y]) {\n      par[x] = y;\n    }\n    else {\n      par[y] = x;\n      if (ran[x] == ran[y]) {\n        ran[x]++;\n      }\n    }\n    num[x] = num[y] = numsum;\n    g--;\n  }\n \n  //xとyが同じ集合に属するか否か\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n \n};\n\n\nint main () {\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  UnionFind uf(n + 1);\n  rep (i, n + 1) {\n    int j = n - i;\n    uf.unite(i, j);\n  }\n  int m;\n  cin >> m;\n  rep (i, m) {\n    int l, r;\n    cin >> l >> r;\n    l--;\n    uf.unite(l, r);\n  }\n\n  s = 'a' + s + 'a';\n  vi b(n + 1);\n  rep (i, n + 1) {\n    b[i] = s[i + 1] - s[i];\n  }\n  \n  vi sum(n + 1);\n  rep (i, n + 1) {\n    int j = uf.find(i);\n    sum[j] += b[i];\n    sum[j] %= 26;\n  }\n\n  bool flag = true;\n  rep (j, n + 1) {\n    sum[j] = (sum[j] + 26) % 26;\n    if (sum[j]) flag = false;\n  }\n\n  if (flag) {\n    cout << \"YES\" << endl;\n  }\n  else {\n    cout << \"NO\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n \nusing namespace std;\n \nstruct S{\n\tL s,e;\n};\n \nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n \nset<S>st;\n \nchar str[100010];\nL b[100010];\nL n,len;\n \nL tr[400040];\n \nvoid update(L now,L S,L E,L s,L e,L val){\n\twhile(e)\n\t{\n\t\ttr[e]+=val;\n\t\te^=e&-e;\n\t}\n\ts--;\n\twhile(s)\n\t{\n\t\ttr[s]-=val;\n\t\ts^=s&-s;\n\t}\n}\n \nL get(L now,L S,L E,L loc){\n\tL ret=0;\n\twhile(loc<=len)\n\t{\n\t\tret+=tr[loc];\n\t\tloc+=loc&-loc;\n\t}\n\treturn ret;\n}\n \nvoid E(L x){\n\t//printf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n \nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\t//printf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//for(set<S>::iterator it=st.begin();it!=st.end();it++)\n\t//\tprintf(\"%lld %lld\\n\",it->s,it->e);\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(st.empty()) break;\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()) break;\n\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\tS temp2=*it;\n\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\tst.erase(temp2); \n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!st.empty()&&st.begin()->s==i)\n\t\t\t{\n\t\t\t\tS range=*(st.begin());\n\t\t\t\tst.erase(st.begin());\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tif(st.empty()) break;\n\t\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\t\tif(it==st.end()) break;\n\t\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\t\tS temp2=*it;\n\t\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\t\tst.erase(temp2); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define D(a) cerr << #a << \" = \" << a << endl\n#else\n\t#define D(a)\n\t#define cerr false && cerr\n#endif\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0)\n#define dforsn(i,s,n) for(int i=int(n-1);i>=int(s);i--)\n#define forsn(i,s,n) for(int i=int(s);i<int(n);i++)\n#define dforn(i,n) dforsn(i,0,n)\n#define forn(i,n) forsn(i,0,n)\n#define all(a) a.begin(),a.end()\n#define si(a) int((a).size())\n#define pb emplace_back\n#define mp make_pair\n#define snd second\n#define fst first\n#define endl '\\n'\nusing pii = pair<int,int>;\nusing vi = vector<int>;\nusing ll = long long;\n\nconst int N = 1e5+2;\nint n, dif[N];\nvi adj[N];\nbool vis[N];\n\nint sum(int u) {\n    vis[u] = true;\n    int res = dif[u];\n\n    for (int v : adj[u]) if (!vis[v]) res = (res + sum(v)) % 26;\n\n    return res;\n}\n\nint main() {\n\tfastio;\n\t\n    // leo string\n    string s; cin >> s; \n    n = si(s); \n    s = 'a' + s + 'a';\n\n    // calculo diferencias\n    forn(i, n+1) dif[i] = (s[i+1] - s[i] + 26) % 26;\n\n    // agrego arcos\n    int k; cin >> k;\n    while (k--) {\n        int l, r; cin >> l >> r; l--;\n        adj[l].pb(r), adj[r].pb(l);\n    }\n    forn(i, (n+1)/2) {\n        int j = n-i;\n        adj[i].pb(j), adj[j].pb(i);\n    }\n\n    // controlo suma\n    bool can = true;\n    forn(u, n+1) if (!vis[u] && sum(u) != 0) can = false;\n\n    cout << (can ? \"YES\" : \"NO\") << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 2e5;\n\nstring s;\n\nint len;\nint a[MAXN];\nset<int> go[MAXN];\nint lb[MAXN];\nint rb[MAXN];\nint ad[MAXN];\nint n;\n\nvoid no() {\n\tcout << \"NO\\n\";\n\texit(0);\n}\n\nvoid add(int l, int r) {\n\tif (l * 2 >= len - 1) {\n\t\tl = len - 1 - l;\n\t\tr = len - 1 - r;\n\t\tswap(l, r);\n\t}\n\tgo[l].insert(r);\n}\n\nint main() {\n\tcin >> s;\n\tlen = s.size();\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> lb[i] >> rb[i], --lb[i], --rb[i];\n\tint n2 = len / 2;\n\tfor (int i = 0; i < n2; ++i) {\n\t\ta[i] = s[len - 1 - i] - s[i];\n\t\tif (a[i] < 0)\n\t\t\ta[i] += 26;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint l = lb[i];\n\t\tint r = rb[i];\n\t\tif (l * 2 <= len - 1 && r * 2 >= len - 1) {\n\t\t\tif (len - 1 - l == r) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (len - 1 - l < r) {\n\t\t\t\tadd(len - l, r);\n\t\t\t}\n\t\t\telse\n\t\t\t\tadd(l, len - 1 - r - 1);\n\t\t}\n\t\telse {\n\t\t\tadd(l, r);\n\t\t}\n\t}\n\tint cur = 0;\n\tfor (int i = 0; i < n2; ++i) {\n\t\tint en = -1;\n\t\tif (go[i].size()) {\n\t\t\ten = *go[i].begin();\n\t\t\tgo[i].erase(go[i].begin());\n\t\t}\n\t\tif (go[i].size()) {\n\t\t\tif (go[i].size() > go[en + 1].size())\n\t\t\t\tswap(go[i], go[en + 1]);\n\t\t\tfor (int j: go[i])\n\t\t\t\tgo[en + 1].insert(j);\n\t\t}\n\t\tcur += ad[i];\n\t\tcur %= 26;\n\t\tif (cur != a[i]) {\n\t\t\tint nd = a[i] - cur;\n\t\t\tif (nd < 0)\n\t\t\t\tnd += 26;\n\t\t\tif (en == -1)\n\t\t\t\tno();\n\t\t\tad[i] = (ad[i] + nd) % 26;\n\t\t\tad[en + 1] = (ad[en + 1] - nd + 26) % 26;\n\t\t\tcur = (cur + nd) % 26;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<set<int>, int> ms;\n\nint find(int x) {\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool dist(char a, char b) {\n\treturn b - a;\n}\n\nset<int> st;\n\nvoid hora(int tc) {\n\tstring s;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tint len = s.size();\n\tfor(int i = 0;i < n;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tvec[l[i]].PB({1, i});\n\t\tvec[r[i] + 1].PB({-1, i});\n\t}\n\tint totnow = 0;\n\tfor(int i = 1;i <= len;i++) {\n\t\twhile(vec[i].size() != 0) {\n\t\t\tint x = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tvec[i].pop_back();\n\t\t\ttotnow += x;\n\t\t\tif(x == -1) st.erase(id);\n\t\t\telse st.insert(id);\n\t\t}\n\t\ttot[i] = totnow;\n\t\tif(tot[i] == 0) par[i] = i;\n\t\telse {\n\t\t\tif(ms[st] == 0) ms[st] = i;\n\t\t\tpar[i] = ms[st];\n\t\t}\n//\t\tcout<<i<<\" TOTAL \"<<tot[i]<<endl;\n\t}\n\tbool bisa = true;\n\tn = len;\n\tfor(int i = 1;i <= len;i++) {\n\t\tif(tot[i] == 0) {\n\t\t\tif(tot[len - i + 1] == 0) {\n//\t\t\t\tcout<<\"TEST1 \"<<i<<\" \"<<len - i + 1<<endl;\n\t\t\t\tif(s[i - 1] != s[len - i]){\n\t\t\t\t\tbisa = false;\n//\t\t\t\t\tcout<<\"ERROR1 \"<<i<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pr = find(par[n - i + 1]);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(tot[rev] == 0) {\n\t\t\t\t\tif(dist(i - 1, rev - 1) != dist(n - i, pr - 1)) {\n\t\t\t\t\t\tbisa = false;\n\t//\t\t\t\t\tcout<<\"ERROR2 \"<<i<<endl;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(par[i] == i) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tint pr = find(i);\n\t\t\t\tint rev = n - pr + 1;\n\t\t\t\tif(find(n - i) == find(rev)) {\n\t\t\t\t\tif(dist(i - 1, pr - 1) != dist(n - i, rev - 1)) {\n//\t\t\t\t\t\tcout<<\"TESTERROR3 \"<<i - 1<<\" \"<<pr - 1<<\" \"<<n - i<<\" \"<<rev - 1<<endl;\n//\t\t\t\t\t\tcout<<\"ERROR3 \"<<i<<endl;\n\t\t\t\t\t\tbisa = false;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nchar S[100005];\nint n,m;\npi range[100005];\nint ar[100005];\n\nvector<int> R[100005];\nvoid ng(){\n  puts(\"NO\");\n  exit(0);\n}\nvoid ok(){\n  puts(\"YES\");\n  exit(0);\n}\n\nint addval[100005];\nint main(){\n  scanf(\"%s\",S);\n  m=strlen(S);\n  REP(i,m/2){\n    ar[i]=(S[m-1-i]-(int)S[i]);\n    ar[i]=(ar[i]+26)%26;\n  }\n  int M=m;\n  m=m/2;\n  if(m==0) ok();\n  cin>>n;\n  REP(i,n){\n    int l,r;scanf(\"%d%d\",&l,&r);\n    --l;\n    int l2=M-r,r2=M-l;\n    chmin(r2,m);\n    if(r<=m){\n      range[i]={l,r};\n    }else if(m<=l){\n      range[i]={l2,r2};\n    }else{\n      range[i]={min(l,l2),max(l,l2)};\n    }\n  }\n  REP(i,n){\n    if(range[i].fr<range[i].sc){\n      R[range[i].fr].pb(range[i].sc);\n    }\n  }\n  REP(i,m){\n    sort(ALL(R[i]));\n    R[i].erase(unique(ALL(R[i])),R[i].end());\n    int m2=R[i].size();\n    REPN(j,m2,1){\n      int l=R[i][j-1],r=R[i][j];\n      R[l].pb(r);\n    }\n  }\n\n  int cur=0;\n\n  REP(i,m){\n    cur=((cur-addval[i])%26+26)%26;\n    if(cur!=ar[i]){\n      if(R[i].empty()) ng();\n      int r=R[i][0];\n      int dif=(ar[i]-cur+26)%26;\n      addval[r]+=dif;\n      cur=ar[i];\n    }\n  }\n  ok();\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nusing ui = uint32_t;\n\nconst int maxn = 50100;\nui _q[4000 * maxn];\nui* q[maxn];\nint qmem[maxn];\nint m;\n\nvoid qset(int x, int y, bool val = true) {\n  assert((m - y) / 32 < qmem[x]);\n  q[x][(m - y) / 32] |= (ui(1) << ((m - y) % 32));\n  if (!val) {\n    q[x][(m - y) / 32] ^= (ui(1) << ((m - y) % 32));\n  }\n}\n\nbool qget(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  return q[x][(m - y) / 32] & (ui(1) << ((m - y) % 32));\n}\n\nvoid qor(int x, int y) {\n  assert(x > y);\n  for (int i = 0; i < qmem[x]; ++i) {\n    q[x][i] |= q[y][i];\n  }\n}\n\nint qfind_first(int x) {\n  for (int i = qmem[x] - 1; i >= 0; --i) {\n    if (!q[i]) {\n      continue;\n    }\n    for (int j = 31; j >= 0; --j) {\n      int c = m - (i * 32 + j);\n      if (c <= x) {\n        continue;\n      }\n      if (qget(x, c)) {\n        return c;\n      }\n    }\n  }\n  return maxn;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  m = n / 2;\n  int OFF = 0;\n  for (int i = m; i >= 0; --i) {\n    int mem = (m - i + 1 + 31) / 32;\n    q[i] = _q + OFF;\n    qmem[i] = mem;\n    OFF += mem;\n  }\n\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      qset(nl, nr);\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = qfind_first(i);\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      qor(to, i);\n      //q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define pb push_back\n#define ALL(s) s.begin(),s.end()\n#define FIN ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define SZ(s) int(s.size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\nint vis[100010];\nvector<int> g[100010],a;\n\nint get(int pos){\n\tint v=a[pos]; vis[pos]=1;\n\tfor(auto x:g[pos]) if(!vis[x]) v+=get(x);\n\treturn v%26;\n}\n\nint main(){FIN;\n\tstring s; int q; cin>>s>>q;\n\ts=\"a\"+s+\"a\";\n\tfore(i,1,SZ(s)) a.pb((s[i]-s[i-1]+26)%26);\n\tint n=SZ(a);\n\tfore(i,0,n) g[i].pb(n-i-1);\n\twhile(q--){\n\t\tint l,r;cin>>l>>r;\n\t\tg[l-1].pb(r); g[r].pb(l-1);\n\t}\n\tfore(i,0,n) if(!vis[i]&&get(i)) cout << \"NO\\n\",exit(0);\n\tcout<<\"YES\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\nint faster_in(){int r=0,c;for(c=getchar();c<=32;c=getchar());if(c=='-') return -faster_in();for(;c>32;r=(r<<1)+(r<<3)+c-'0',c=getchar());return r;}\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<int, int>  ii;\ntypedef vector<int>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst int INF = int(1e9 + 7);\n\nconst int tam = 100010;\n\nvector<int> G[tam];\nint val[tam];\nbool vis[tam];\n\nint sum;\nvoid dfs(int v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (int u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    s = \"a\" + s + \"a\";\n/*\n    cout << s << endl;\n\tfor (int i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n*/\n    for (int i = 0; i < n; i++)\n    {\n    \tval[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \tval[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = 0;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\ntypedef long long LL;\n\nLL fa[100005],siz[100005];\nLL c[100005] = {0},d[100005],m,n;\nLL l[100005],r[100005];\nstring s;\n\nvoid init(){\n\tfor(LL i = 1;i <= (m >> 1);i ++) c[i] = (s[m + 1 - i] - s[i] + 26) % 26;\n//\tfor(LL i = 1;i <= (m >> 1);i ++) cout << c[i] << (i == (m >> 1) ? '\\n' : ' ');\n\tfor(LL i = 0;i <= (m >> 1);i ++) d[i + 1] = (c[i + 1] - c[i] + 26) % 26;\n\tfor(LL i = 1;i <= (m >> 1) + 1;i ++){\n\t\tfa[i] = i;\n\t\tsiz[i] = d[i];\n\t}\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(l[i] > (m >> 1) && r[i] > (m >> 1)){\n\t\t\tswap(l[i],r[i]);\n\t\t\tl[i] = m + 1 - l[i];\n\t\t\tr[i] = m + 1 - r[i];\n\t\t}\n\t\telse if(r[i] > (m >> 1)){\n\t\t\tLL tor = m + 1 - r[i];\n\t\t\tif(tor < l[i]){\n\t\t\t\tr[i] = l[i] - 1;\n\t\t\t\tl[i] = tor;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr[i] = tor - 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nLL getf(LL x){\n\tif(fa[x] == x) return x;\n\treturn fa[x] = getf(fa[x]);\n}\n\nvoid unionn(LL x,LL y){\n\tx = getf(x); y = getf(y);\n\tif(x == y) return;\n\tfa[x] = y; siz[y] += siz[x];\n}\n\nint main(){\n\tcin >> s; cin >> n;\n\tfor(LL i = 1;i <= n;i ++) cin >> l[i] >> r[i];\n\tm = s.length(); s = ' ' + s;\n\tinit();\n\t\n//\tfor(LL i = 1;i <= (m >> 1) + 1;i ++) cout << d[i] << ' '; cout << endl;\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tr[i] ++;\n\t\tunionn(l[i],r[i]);\n\t}\n\tfor(LL i = 1;i <= (m >> 1) + 1;i ++){\n\t\tif(siz[getf(i)] % 26){\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nostream& operator<<(ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) {string s; ist >> s; return ist;}\nbool Inside(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* E mondai*/\n\nstring s;\nint N;\nint L[100000], R[100000];\nvector<IntMod<26>> ss;\n\nvoid Add(int i, int j, IntMod<26> val) {\n\tss[i] += val;\n\tss[j] -= val;\n}\n\nint main() {\n\tcin >> s >> N;\n\tREP(i, 0, N) {\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t\tif (L[i] > s.size() / 2) L[i] = s.size() - L[i];\n\t\tif (R[i] > s.size() / 2) R[i] = s.size() - R[i];\n\t\tif (L[i] > R[i]) swap(L[i], R[i]);\n\t}\n\n\tREP(i, 0, s.size() / 2) {\n\t\tss.push_back(s[s.size() - i - 1] - s[i]);\n\t}\n\tss.push_back(0);\n\tadjacent_difference(ss.begin(), ss.end(), ss.begin());\n\n\tPriorityQ<PP> Q;\n\tREP(i, 0, N) {\n\t\tQ.push(PP(L[i], R[i]));\n\t}\n\t\n\tPP prev(-1, 0);\n\twhile (!Q.empty()) {\n\t\tPP p = Q.top(); Q.pop();\n\t\tif (p.first == p.second) continue;\n\t\tif (prev.first == p.first) {\n\t\t\tQ.push(PP(prev.second, p.second));\n\t\t\tcontinue;\n\t\t}\n\t\tAdd(p.first, p.second, -ss[p.first]);\n\t\tprev = p;\n\t}\n\tYESNO(all_of(ss.begin(), ss.end(), [](IntMod<26> i) {return i == 0; }));\n\treturn 0;\n}\n\n/*-------------------------*/\n/*-----    二分探索   -----*/\n/*-------------------------*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nusing ui = uint32_t;\n\nconst int maxn = 50100;\n//bitset<maxn> q[maxn];\nui q[4000 * maxn];\nint off[maxn];\nint qmem[maxn];\nint m;\n\nvoid qset(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  q[off[x] + qmem[x] - 1 - (m - y) / 32] |= (ui(1) << (m - y) % 32);\n}\n\nbool qget(int x, int y) {\n  assert((m - y) / 32 < qmem[x]);\n  return q[off[x] + qmem[x] - 1 - (m - y) / 32] & (ui(1) << (m - y) % 32);\n}\n\nvoid qor(int x, int y) {\n  for (int i = 0; i < qmem[y]; ++i) {\n    int block = off[y] + i;\n    int from = off[x] + qmem[x] - qmem[y] + i;\n    q[block] |= q[from];\n  }\n}\n\nint qfind_first(int x) {\n  for (int i = 0; i < qmem[x]; ++i) {\n    if (q[off[x] + i]) {\n      for (int j = 0; j < 32; ++j) {\n        if (qget(x, i * 32 + j))\n          return i * 32 + j;\n      }\n      assert(false);\n    }\n  }\n  return maxn;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n  string s;\n  int qs;\n  cin >> s >> qs;\n  int n = (int) s.size();\n  m = n / 2;\n  int OFF = 0;\n  for (int i = m; i >= 0; --i) {\n    int mem = (m - i + 1 + 31) / 32;\n    off[i] = OFF;\n    qmem[i] = mem;\n    OFF += mem;\n  }\n\n  for (int i = 0; i < qs; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    int nl, nr;\n    if (r <= m) {\n      nl = l;\n      nr = r;\n    } else if (l >= n - m) {\n      nl = n - r;\n      nr = n - l;\n    } else {\n      nl = l;\n      nr = n - r;\n      if (nl >= nr) {\n        swap(nl, nr);\n      }\n    }\n    if (nl != nr) {\n      assert(nr > nl);\n      qset(nl, nr);\n      //cerr << nl << ' ' << nr << '\\n';\n    }\n  }\n  vector<int> val(m);\n  for (int i = 0; i < m; ++i) {\n    val[i] = (s[i] - s[n - 1 - i] + 26) % 26;\n  }\n  int add = 0;\n  vector<int> delta(m + 1);\n  //for (int i = 0; i < m; ++i) {\n    //cerr << val[i] << '\\n';\n  //}\n  for (int i = 0; i < m; ++i) {\n    //cerr << i << ' ' << val[i] << '\\n';\n    add = (add - delta[i] + 26) % 26;\n    val[i] = (val[i] - add + 26) % 26;\n    int to = qfind_first(i);\n    if (val[i] != 0 && to == maxn) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    if (val[i] != 0) {\n      //cerr << \"add \" << i << ' ' << to << ' ' << val[i] << '\\n';\n      delta[to] = (delta[to] + val[i]) % 26;\n      add = (val[i] + add) % 26;\n    }\n    if (to != maxn) {\n      qor(to, i);\n      //q[to] |= q[i];\n    }\n  }\n  cout << \"YES\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666;\nint n,m,a[N],f[N];char s[N];bool mrk[N];\nint find(int x){return f[x]==x?x:f[x]=find(f[x]);}\nVi dot[N];\nvoid merge(int x, int y){\n\tx=find(x);y=find(y);f[x]=y;\n}\nint main() {\n\tscanf(\"%s\",s+1);n=strlen(s+1);read(m);\n\trep(i,1,n)a[i]=(int(s[i])-int(s[i-1])+26)%26;\n\trep(i,1,n+1)f[i]=i;\n\twhile(m--){\n\t\tint l,r;read(l);read(r);merge(l,r+1);mrk[l]=mrk[r+1]=1;\n\t}\n\tif(n%2){for(int i=2;i<n+2-i;i++)merge(i,n+2-i),mrk[i]=mrk[n+2-i]=1;}\n\telse{mrk[n/2+1]=1;for(int i=2;i<n+2-i;i++)merge(i,n+2-i),mrk[i]=mrk[n+2-i]=1;}\n\tmrk[n+1]=0;mrk[1]=0;\n\trep(i,1,n+1)dot[find(i)].pb(i);\n//\trep(i,1,n+1)printf(\"%d:%d %d\\n\",i,f[i],a[i]);\n\trep(i,1,n+1)if(SZ(dot[i])){\n\t\tint s=0,s1=0;rep(j,0,SZ(dot[i])-1)s+=a[dot[i][j]],s1+=!mrk[dot[i][j]];\n\t\tif(!s1&&s%26){puts(\"NO\");return 0;}\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return weight(y) - weight(x);\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          if((diff + 26) % 26 != (S[other] - S[idx] + 26) % 26) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nclass unionfind {\n\tvector<int> par, rank;\n\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return ;\n\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y) { return (find(x) == find(y)); }\n} uf;\n\nstring s;\nint Q;\nint L[100010], R[100010];\nint N;\nint cmp[100010];\n\nint main() {\n\tcin >> s >> Q;\n\tN = s.size();\n\tuf.init(N + 10);\n\n\trep(i, Q) {\n\t\tscanf(\"%d %d\", &L[i], &R[i]);\n\t\t--L[i]; --R[i];\n\t}\n\n\tvector<pii> vec;\n\n\tif (N & 1) {\n\t\tint ct = N / 2;\n\t\trep(i, Q) {\n\t\t\tif (L[i] <= ct && ct <= R[i]) {\n\t\t\t\tif ((ct-L[i])==(R[i]-ct)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if ((ct-L[i])>(R[i]-ct)) {\n\t\t\t\t\tR[i] = ct-(R[i]-ct)-1;\n\t\t\t\t\tvec.eb(L[i], R[i]);\n\t\t\t\t} else {\n\t\t\t\t\tL[i] = ct+(ct-L[i])+1;\n\t\t\t\t\tvec.eb(N-1-R[i],N-1-L[i]);\n\t\t\t\t}\n\t\t\t} else if (R[i] < ct) {\n\t\t\t\tvec.eb(L[i], R[i]);\n\t\t\t} else {\n\t\t\t\tvec.eb(N-1-R[i], N-1-L[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\trep(i, Q) {\n\t\t\tif (L[i] <= N/2-1 && N/2 <= R[i]) {\n\t\t\t\tif ((N/2-1-L[i])==(R[i]-N/2)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if ((N/2-1-L[i])>(R[i]-N/2)) {\n\t\t\t\t\tR[i] = N-2-R[i];\n\t\t\t\t\tvec.eb(L[i],R[i]);\n\t\t\t\t} else {\n\t\t\t\t\tL[i] = N-L[i];\n\t\t\t\t\tvec.eb(N-1-R[i],N-1-L[i]);\n\t\t\t\t}\n\t\t\t} else if (R[i]<N/2) {\n\t\t\t\tvec.eb(L[i],R[i]);\n\t\t\t} else {\n\t\t\t\tvec.eb(N-1-R[i],N-1-L[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvi df;\n\n\trep(i, N/2) {\n\t\tdf.pb(s[i]-s[N-1-i]);\n\t}\n\n\tvi acm;\n\tacm.pb(df[0]);\n\n\trep(i,(int)df.size()-1) {\n\t\tacm.pb(df[i+1]-df[i]);\n\t}\n\n\tacm.pb(-1e9);\n\n\tfor (auto p:vec) {\n\t\tuf.unite(p.fi, p.se + 1);\n\t}\n\n\trep(i, acm.size()) {\n\t\tcmp[uf.find(i)] += acm[i];\n\t}\n\n\tbool ok = 1;\n\trep(i, acm.size()) {\n\t\tif (uf.same(i, (int)acm.size()-1)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (cmp[uf.find(i)] != 0) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tputs(ok ? \"YES\" : \"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 100005;\nchar s[N];\nint d[N];\nstruct dsu{\n    int n;\n    vector<int> par, sm;\n    dsu(int n) : n(n), par(n), sm(n){\n        iota(par.begin(), par.end(), 0);\n\t\tfor(int i = 1; i < n; i++) sm[i] = (d[i] - d[i - 1] + 26) % 26;\n    }\n    int root(int x){\n        return x == par[x] ? x : (par[x] = root(par[x]));\n    }\n    bool merge(int x, int y){\n        x = root(x); y = root(y);\n        if(x == y) return 0;\n        par[x] = y;\n\t\tsm[y] += sm[x];\n\t\tsm[y] %= 26;\n        return 1;\n    }\n};\n\nint main(){\n\tscanf(\"%s\", s + 1);\n\tint q; sd(q);\n\tint n= strlen(s + 1);\n\tint mid = n / 2;\n\tfor(int i = 1; i <= mid; i++) d[i] = (s[i] - s[n + 1 - i] + 26) % 26;\n\tvector<vector<int>> events(n + 1);\n\tdsu D(mid + 2);\n\tfor(int i = 1; i <= q; i++){\n\t\tint l, r; sd(l); sd(r);\n\t\tif(n % 2 == 1 && l == mid + 1 && r == mid + 1) continue;\n\t\tif(n % 2 == 1 && l == mid + 1 &&r != mid + 1){\n\t\t\tD.merge(n + 1 - r, mid + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif(n % 2 == 1 && r == mid + 1 && l != mid + 1){\n\t\t\tD.merge(l, mid + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tint a = l > mid, b = r > mid;\n\t\tint vl = a ? n + 1 - l : l;\n\t\tint vr = b ? n + 1 - r : r;\n\n\t\tif(!a && !b){\n\t\t\tD.merge(vl, vr + 1);\n\t\t}\n\n\t\tif(!a && b){\n\t\t\t// [vl ... mid] U [vr ... mid]\n\t\t\tif(vl > vr) swap(vl, vr);\n\t\t\tD.merge(vl, vr);\n\t\t}\n\t\tif(a){\n\t\t\tD.merge(vr, vl + 1);\n\t\t}\n\t}\n\tfor(int i = 1; i <= mid + 1; i++) if(D.root(i) == i){\n\t\tif(D.sm[i] != 0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = (int) 1e5;\nint sum[N], lab[N];\n\nint get(int a) {\n    return lab[a] == a ? a : lab[a] = get(lab[a]);\n}\n\nvoid join(int a, int b) {\n    //cout << \"JOIN \" << a << ' ' << b << endl;\n    a = get(a);\n    b = get(b);\n    if (a == b) return;\n    sum[b] += sum[a];\n    lab[a] = b;\n}\n\nint main() {\n    string s; cin >> s;\n    int len = s.size();\n    int n; cin >> n;\n    int nnode = 0;\n    for (int i = 0, j = len - 1; i < j; ++i, --j) {\n        sum[i] = int(s[i]) - int(s[j]);\n        ++nnode;\n    }\n    ++nnode;\n    for (int i = 0; i < nnode; ++i) lab[i] = i;\n    //for (int i = 0; i < nnode; ++i) cout << sum[i] << ' '; cout << endl;\n    for (int i = nnode - 1; i > 0; --i) sum[i] -= sum[i - 1];\n    //for (int i = 0; i < nnode; ++i) cout << sum[i] << ' '; cout << endl;\n    for (int i = 0; i < n; ++i) {\n        int l, r; cin >> l >> r; --l; --r;\n        if (r <= (len - 1) / 2) {\n            if (len % 2 == 1 && r == len / 2) --r;\n            join(l, r + 1);\n        } else if (l >= len / 2) {\n            if (len % 2 == 1 && l == len / 2) ++l;\n            join(len - 1 - r, len - l);\n        } else {\n            int a = l;\n            int b = len - 1 - r;\n            join(a, b);\n        }\n    }\n    for (int i = 0; i < nnode; ++i) if (lab[i] == i && sum[i] % 26 != 0) {\n        cout << \"NO\\n\";\n        return 0;\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint n,m,i,j,k,c[N];\nchar s[N];\nvector<int> vct[N];\nvoid add(int x,int y)\n{\n\twhile(x<=m/2)\n\t{\n\t\tc[x]=(c[x]+y)%26;\n\t\tx+=x&-x;\n\t}\n}\nint sum(int x)\n{\n\tint rtn=0;\n\twhile(x>=1)\n\t{\n\t\trtn=(rtn+c[x])%26;\n\t\tx-=x&-x;\n\t}\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=(s[m-i+1]-s[i]+26)%26;\n\t\tadd(i,j);\n\t\tadd(i+1,(26-j)%26);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tif(j==m-k+1)\n\t\t\tcontinue;\n\t\tif(k<=m/2)\n\t\t\tvct[j].push_back(k);\n\t\telse if(j>m/2)\n\t\t\tvct[m-k+1].push_back(min(m/2,m-j+1));\n\t\telse if(j<=m-k)\n\t\t\tvct[j].push_back(m-k);\n\t\telse\n\t\t{\n\t\t\tj=m-j+1,k=m-k+1;\n\t\t\tswap(j,k);\n\t\t\tvct[j].push_back(m-k);\n\t\t}\n\t}\n\tfor(i=1;i<=m/2;++i)\n\t{\n\t\tj=sum(i);\n\t\tif(vct[i].empty())\n\t\t{\n\t\t\tif(j!=0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsort(vct[i].begin(),vct[i].end());\n\t\tadd(i+1,(26-j)%26);\n\t\tadd(vct[i][0]+1,j);\n\t\tfor(j=1,k=vct[i][0]+1;j<vct[i].size()&&k<=m/2;++j)\n\t\t\tif(k<=vct[i][j])\n\t\t\t\tvct[k++].push_back(vct[i][j]);\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s; cin >> s;\n    int sz = s.size();\n    int n; cin >> n;\n    int l[n], r[n];\n    for (int i = 0; i < n; i++) {\n        cin >> l[i] >> r[i]; l[i]--;\n        if (r[i] <= sz/2) continue;\n        if (l[i] <= sz/2) {\n            r[i] = sz - r[i];\n            if (r[i] < l[i]) swap(l[i], r[i]);\n        } else {\n            l[i] = sz + 1 - l[i];\n            r[i] = sz + 1 - r[i];\n            swap(l[i], r[i]);\n        }\n    }\n\n    int diff[sz/2];\n    for (int i = 0; i <= sz/2; i++) {\n        s[i] -= s[sz-i-1]; s[sz-i-1] = 0;\n        if (!i) diff[i] = s[i];\n        else diff[i] = (s[i] - s[i-1] + 52) % 26;\n    }\n\n    int m = sz/2+1;\n    set<int> e[m];\n    for (int i = 0; i < n; i++) {\n        if (l[i] != r[i]) {\n            e[l[i]].emplace(r[i]);\n            e[r[i]].emplace(l[i]);\n        }\n    }\n    vector<bool> vis(m, 0);\n    auto dfs = [&vis, &diff, &e](auto f, int curr) -> int {\n        int ret = 0;\n        vis[curr] = 1;\n        for (auto &to: e[curr]) {\n            if (vis[to]) continue;\n            ret += f(f, to);\n        }\n        return ret + diff[curr];\n    };\n    bool ok = true;\n    for (int i = 0; i < m; i++) {\n        if (!vis[i]) ok &= (dfs(dfs, i) % 26 == 0);\n    }\n    if (ok) cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nvector<int> v[100001];\nbool used[100001];\nint d[100001];\n\nvoid dfs(int x, int& sum){\n  for(auto y:v[x]){\n    if(!used[y]){\n      used[y]=1;\n      sum+=d[y];\n      dfs(y, sum);\n    }\n  }\n}\n\nint main()\n{\n  string s;\n  cin>>s;\n  int m=s.size();\n  d[0]=s[0]-'a';\n  for(int i=1; i<m; i++){\n    d[i]=((s[i]-'a')-(s[i-1]-'a')+26)%26;\n  }\n  int n;\n  cin>>n;\n  for(int i=0; i<=m; i++){\n    v[i].push_back(m-i);\n  }\n  for(int i=0; i<n; i++){\n    int l, r;\n    cin>>l>>r;\n    l--; r--;\n    v[l].push_back(r+1);\n    v[r+1].push_back(l);\n  }\n  bool no=0;\n  for(int i=m; i>=0; i--){\n    if(used[i]) continue;\n    int sum=d[i];\n    used[i]=1;\n    dfs(i, sum);\n    if(i==m) continue;\n    if(sum%26!=0){\n      no=1;\n      break;\n    }\n  }\n  if(no){\n    cout<<\"NO\"<<endl;\n  }else{\n    cout<<\"YES\"<<endl;\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\tini[nuevo.first].insert(nuevo.second);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = ini[i].size();\n\t\tauto it = ini[i].begin();\n\t\tif(sz == 1){\n\t\t\tfin[*it].insert(i);\n\t\t}else if(sz > 1){\n\t\t\tLong ant = i;\n\t\t\twhile(it != ini[i].end()){\n\t\t\t\tif(ant != i){\n\t\t\t\t\tini[ant].insert(*it);\n\t\t\t\t}\n\t\t\t\tfin[*it].insert(ant);\n\t\t\t\tant = *it + 1;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<Long,Long> > rangos;\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = fin[i].size();\n\t\tauto it = fin[i].begin();\n\t\tif(sz == 1){\n\t\t\trangos.push_back({*it,i});\n\t\t}else if(sz > 1){\n\t\t\tLong ant = *it;\n\t\t\twhile(it != fin[i].end()){\n\t\t\t\tit++;\n\t\t\t\tif(it == fin[i].end()){\n\t\t\t\t\trangos.push_back({ant,i});\n\t\t\t\t}else{\n\t\t\t\t\trangos.push_back({ant,*it-1});\n\t\t\t\t\tant = *it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsort(rangos.begin(),rangos.end());\n\t\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\n\nint n, m, dif[Nmax];\nbool special[Nmax];\nchar S[Nmax];\n\nvector<int> v[Nmax];\nbool used[Nmax];\n\nvoid add_edge(int x, int y)\n{\n    v[x].push_back(y);\n    v[y].push_back(x);\n}\n\nvoid dfs(int node, bool &ok, int &sum)\n{\n    used[node] = 1;\n    ok |= special[node];\n    sum += dif[node];\n\n    for(auto it : v[node])\n        if(!used[it])\n            dfs(it, ok, sum);\n\n}\n\nint main()\n{\n ///   freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false); cin.tie(0);\n\n    cin >> (S+1);\n    n = strlen(S+1);\n    cin >> m;\n\n    int i;\n\n    for(i=1; i<n; ++i)\n        if(i <= n/2) dif[i] += (int)S[i] - (int)S[i+1];\n            else dif[n - i] += (int)S[i] - (int)S[i+1];\n\n    for(i=1; i<=m; ++i)\n    {\n        int x, y;\n        cin >> x >> y;\n        --x;\n\n        if(x > n/2) x = n - x;\n        if(y > n/2) y = n - y;\n\n        if(x && y) add_edge(x, y);\n            else if(y) special[y] = 1;\n                else if(x) special[x] = 1;\n    }\n\n    for(i=1; i<=n/2; ++i)\n        if(!used[i])\n        {\n            bool ok = 0;\n            int sum = 0;\n            dfs(i, ok, sum);\n\n            if(!ok && sum)\n            {\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n\n    cout << \"YES\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEMETRIO\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#define deb1(x) cerr << #x << \" = \" << x << endl\n#else\n#define deb(...) 0\n#define deb1(x) 0\n#endif\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define SZ(x) ((int)(x).size())\n#define mset(a,v) memset(a,v,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\n\nchar s[100005];int n,m;\nint w[100005];\nvector<int> g[100005];\nbool vis[100005];\n\nint dfs(int x){\n\tif(vis[x])return 0;\n\tvis[x]=true;\n\tint r=w[x];\n\tfor(int y:g[x])r+=dfs(y);\n\treturn r;\n}\n\nint main(){\n\tscanf(\"%s%d\",s,&m);n=strlen(s);\n\twhile(m--){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);a--;\n\t\tg[a].pb(b);g[b].pb(a);\n\t}\n\tfore(i,0,n)s[i]-='a';\n\tw[0]=s[0];\n\tfore(i,1,n)w[i]=((int)s[i])-s[i-1];\n\tw[n]=-s[n-1];\n\tfore(i,0,n+1)g[i].pb(n-i);\n\tfore(i,0,n+1)if(!vis[i]&&dfs(i)){puts(\"NO\");return 0;}\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector <int> V[101010], T[101010], Q;\nset <int> S[101010];\nint K[101010], D[101010], G[101010];\nchar str[101010];\nbool chk[101010];\nint n, m, cnt;\n\nvoid die() { printf(\"NO\\n\"); exit(0); }\n\nvoid dfs(int p)\n{\n\tchk[p] = 1;\n\tK[cnt] = (K[cnt] + D[p]) % 26;\n\tT[cnt].push_back(p);\n\t\n\tfor(int &t: V[p]){\n\t\tif(!chk[t]) dfs(t);\n\t}\n}\n\nint main()\n{\n\tint i, a, b, p, k;\n\t\n\tscanf(\"%s\", str);\n\t\n\tn = strlen(str);\n\t\n\tD[0] = str[0] - 'a';\n\tD[n] = (26 + 'a' - str[n-1]) % 26;\n\t\n\tfor(i=1; i<n; i++){\n\t\tD[i] = (26 + str[i] - str[i-1]) % 26;\n\t}\n\t\n\tscanf(\"%d\", &m);\n\t\n\tfor(i=1; i<=m; i++){\n\t\tscanf(\"%d%d\", &a, &b); a --;\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\t\n\tfor(i=0; i<=n; i++){\n\t\tif(!chk[i]){\n\t\t\tcnt ++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\tfor(i=1; i<=cnt; i++){\n\t\tchk[i] = 0;\n\t\t\n\t\tsort(T[i].begin(), T[i].end());\n\t\t\n\t\tfor(int &t: T[i]){\n\t\t\tif((~n & 1) && t == (n >> 1)) continue;\n\t\t\telse if(*lower_bound(T[i].begin(), T[i].end(), n - t) == n - t) continue;\n\t\t\tS[i].insert(t); G[t] = i;\n\t\t}\n\t\t\n\t\tif(S[i].size() <= 1){\n\t\t\tchk[i] = 1;\n\t\t\tQ.push_back(i);\n\t\t}\n\t}\n\t\n\tfor(; !Q.empty(); ){\n\t\tp = Q.back(); Q.pop_back();\n\t\t\n\t\tif(S[p].empty() && K[p]) die();\n\t\t\n\t\tif(!S[p].empty()){\n\t\t\tk = K[p];\n\t\t\tp = n - *S[p].begin();\n\t\t\tK[G[p]] = (K[G[p]] + k) % 26;\n\t\t\tS[G[p]].erase(p);\n\t\t\t\n\t\t\tif(!chk[G[p]] && S[G[p]].size() <= 1){\n\t\t\t\tchk[G[p]] = 1;\n\t\t\t\tQ.push_back(G[p]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"YES\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nchar S[114514];\nint G[114514];\nint X[114514];\nbool used[114514];\nvector<int> es[114514];\nint M;\n\nint dfs(int v) {\n  if (used[v]) return 0;\n  used[v] = true;\n\n  int sum = X[v]%26;\n  for (int u : es[v]) {\n    if (used[u]) continue;\n    sum += dfs(u);\n    sum %= 26;\n  }\n  return sum;\n}\n\nint ToIdx(int b) {\n  //assert(b >= 1);\n  if (N%2 == 1) {\n    if (b <= N/2) return b;\n    return N-b;\n  } \n\n  if (b <= N/2) return b;\n  return N-b;\n}\n\nint main() {\n  scanf(\"%s\", S);\n  N = strlen(S);\n  scanf(\"%d\", &M);\n  for (int i=0; i<M; i++) {\n    int a;\n    int b;\n    scanf(\"%d%d\", &a, &b);\n    --a;\n    --b;\n    int u = ToIdx(a);\n    int v = ToIdx(b+1);\n    if (u == v) continue;\n    es[u].emplace_back(v);\n    es[v].emplace_back(u);\n  }\n\n  G[0] = S[0]-'a';\n  for (int i=1; i<N; i++) {\n    G[i] = (26+(S[i]-S[i-1])%26)%26;\n    int k = ToIdx(i);\n    X[k] += G[i];\n    X[k] %= 26;\n  }\n\n  /*printf(\"G: \");\n  for (int i=0; i<N; i++) {\n    printf(\"%d \", G[i]);\n  }puts(\"\");\n  printf(\"X: \");\n  for (int i=0; i<N; i++) {\n    printf(\"%d \", X[i]);\n  }puts(\"\");*/\n\n  dfs(0);\n  for (int i=1; i<=N/2; i++) {\n    if (!used[i]) {\n      //printf(\"i: %d\\n\", i);\n      int res = dfs(i);\n      //printf(\"res: %d\\n\", res);\n      if (res%26) {\n        puts(\"NO\");\n        return 0;\n      }\n    }\n  }\n  puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nusing ld = long double;\nll INF = LLONG_MAX;\n\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid print() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void print(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); \n\t}\n}\n\nusing namespace output;\n\nstruct DSU {\n    vi p; vi sum; void init(int n) {p = vi (n, -1); sum = vi (n, 0);}\n    int findSet(int x) { return p[x] < 0 ? x : findSet(p[x]);}\n    bool sameSet(int a, int b) { return findSet(a) == findSet(b); }\n\tint size(int x) { return -p[findSet(x)]; }\n\tbool joinSet(int x, int y) { // union-by-rank\n\t\tx = findSet(x), y = findSet(y); if (x == y) return 0;\n\t\tif (p[x] > p[y]) swap(x,y);\n\t\tsum[x] += sum[y]; p[x] += p[y]; p[y] = x; return 1;\n\t}\n};\n\nint main() {\n    // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring S; cin >> S;\n\t\n\tDSU dsu; dsu.init(S.size()-1);\n\tFOR(i, 1, S.size()) dsu.sum[i-1] = S[i] - S[i-1];\n\tfor (int i = 0; i + 1 < S.size() / 2; ++i) dsu.joinSet(i, S.size()-2-i);\n\tvi solve = vi ();\n\tint N; cin >> N;\n\tF0R(i, N) {\n\t\tint l, r; cin >> l >> r; --l; --r;\n\t\tif ((l == 0) && (r == S.size()-1)) {}\n\t\telse if (r == S.size()-1) solve.push_back(l-1);\n\t\telse if (l == 0) solve.push_back(r);\n\t\telse dsu.joinSet(l-1, r);\n\t}\n\tfor(int x : solve) dsu.sum[dsu.findSet(x)] = 0;\n\tbool works = true;\n\tF0R(i, S.size()-1) {\n\t\tif ((dsu.sum[dsu.findSet(i)] % 26 + 26) % 26 != 0) works = false;\n\t}\n\tprint(works ? \"YES\" : \"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=400002;\nint n,m,c[N],vis[N],i,k,l,r,sum,ok;\nint h[N],t[N],v[N],a,b;\nchar s[N];\nvoid add(int a,int b){\n\tt[++k]=h[a];\n\th[a]=k;\n\tv[k]=b;\n}\nvoid init(){\n\tscanf(\"%s\",s+1);\n\twhile(s[n+1])n++;\n\tfor(i=1;i<=n+1;i++)\n\t\tc[i]=s[i]-s[i-1];\n\tfor(l=1,r=n+1;l<r;l++,r--){\n\t\tadd(l,r);\n\t\tadd(r,l);\n\t}\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b+1);\n\t\tadd(b+1,a);\n\t}\n}\nvoid dfs(int i){\n\tvis[i]=1;\n\tsum+=c[i];\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(!vis[v[j]])\n\t\t\tdfs(v[j]);\n}\nvoid work(){\n\tdfs(n+1);\n\tok=1;\n\tfor(i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tsum=0;\n\t\t\tdfs(i);\n\t\t\tif(sum%26!=0)\n\t\t\t\tok=0;\n\t\t}\n\tprintf(\"%s\\n\",ok?\"YES\":\"NO\");\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,LL>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A;\n\t\tA = A * A;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, 0}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(2, id);\n\t\t\tLL po3 = fast(3, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total3 -= po3;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, total3}) == ms.end()) ms[{total, total3}] = i;\n\t\tpar[i] = ms[{total, total3}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\tprintf(\"%lld\\n\",x);\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\tprintf(\"%lld\\n\",len);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t\t//printf(\"%lld \",b[i]);\n\t}\n\t//puts(\"\");\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\t//printf(\"sz %lld\\n\",st.size());\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\twhile(!st.empty()&&st.begin()->s<i) st.erase(st.begin());\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\t//printf(\"%lld %lld %lld\\n\",range.s,range.e,temp);\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t\tst.erase(st.begin());\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(st.empty()) break;\n\t\t\t\tset<S>::iterator it=st.begin();\n\t\t\t\tif(it==st.end()) break;\n\t\t\t\tif(it->s!=range.s) break;\n\t\t\t\tS temp2=*it;\n\t\t\t\tst.insert((S){range.e+1,it->e});\n\t\t\t\tst.erase(temp2); \n\t\t\t}\n\t\t}\n\t\t/*for(j=1;j<=len;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",get(1,1,len,j));\n\t\t}\n\t\tputs(\"\");*/\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tstring s;\n\tcin >> s;\n\tcin >> N;\n\ts = char('a' - 1) + s + char('a' - 1);\n\tvector<int>v;\n\tfor (int i = 1; i < s.size(); i++) {\n\t\tv.push_back((s[i] - s[i - 1] + 26) % 26);\n\t}\n\tUnionFind uf(v.size());\n\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tuf.Unite(i, v.size() - 1 - i);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tuf.Unite(L - 1, R);\n\t}\n\tvector<int>box(v.size());\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tbox[uf.Find(i)] += v[i];\n\t}\n\tfor (auto i : box) {\n\t\tif (i % 26) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <list>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define LL long long\nusing namespace std;\n\nstring s;\nint val[100005],n,N;\nint pre[100005] = {0},add;\nint m,tmp;\n\nstruct node{\n\tint l,r;\n}q[100005];\n\nbool cmp(node x,node y){\n\tif(x.l == y.l) return x.r < y.r;\n\treturn x.l < y.l;\n}\n\ninline string judge(){\n\tfor(register int i = 1;i <= n;i ++){\n\t\tif(val[i] != val[n + 1 - i]) return \"NO\";\n\t}\n\treturn \"YES\";\n}\n\nint main(){\n\tcin >> s; n = s.length();\n\tfor(register int i = 1;i <= n;i ++) val[i] = s[i - 1] - 'a';\n\tcin >> m;\n\tN = ((n & 1) ? ((n >> 1) + 1) : (n >> 1));\n\tfor(register int i = 1;i <= m;i ++){\n\t\tcin >> q[i].l >> q[i].r;\n\t\tif((q[i].l > N) && (q[i].r > N)){\n\t\t\tq[i].l = n + 1 - q[i].l;\n\t\t\tq[i].r = n + 1 - q[i].r;\n\t\t\tswap(q[i].l,q[i].r);\n\t\t}\n\t\telse if(q[i].r > N){\n\t\t\tq[i].l --;\n\t\t\tq[i].r = n + 1 - q[i].r;\n\t\t\tswap(q[i].l,q[i].r);\n\t\t}\n\t}\n\tsort(q + 1,q + 1 + m,cmp);\n\ttmp = q[1].l;\n\tfor(register int i = 2;i <= m;i ++){\n\t\tif(q[i].l == tmp) q[i].l = q[i - 1].r + 1;\n\t\telse tmp = q[i].l;\n\t}\n\tsort(q + 1,q + 1 + m,cmp);\n\t/*\n\tfor(register int i = 1;i <= m;i ++){\n\t\tcout << q[i].l << ' ' << q[i].r << endl;\n\t}\n\t*/\n\tq[0].l = q[1].l;\n\tadd = 0;\n\tfor(register int i = 1;i <= m;i ++){\n\t\tadd += pre[q[i].l];\n\t\tfor(register int j = q[i - 1].l + 1;j <= q[i].l;j ++){\n\t\t\tval[j] += add; val[j] = (val[j] + 26) % 26;\n\t\t}\n\t\tif(val[q[i].l] == val[n - q[i].l + 1]) continue;\n\t\ttmp = val[n - q[i].l + 1] - val[q[i].l];\n\t\tval[q[i].l] = val[n - q[i].l + 1];\n\t\tadd += tmp;\n\t\tpre[q[i].r + 1] -= tmp;\n\t}\n\tfor(register int i = q[m].l + 1;i <= N;i ++){\n\t\tadd += pre[i];\n\t\tval[i] += add; val[i] = (val[i] + 26) % 26;\n\t}\n\tcout << judge() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,pair<LL,LL> >, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A;\n\t\tA = A * A;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, {0, 0}}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tLL total4 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(7703, id);\n\t\t\tLL po3 = fast(1277, id);\n\t\t\tLL po4 = fast(2927, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3, total4 += po4;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total3 -= po3, total4 += po4;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, {total3, total4}}) == ms.end()) ms[{total, {total3, total4}}] = i;\n\t\tpar[i] = ms[{total, {total3, total4}}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 300000\n\nLL n,m,a[N],sum;\nvector<LL> g[N];\nbool vis[N];\nchar s[N];\n\nvoid add(LL x,LL y){\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\n\nvoid dfs(LL u){\n\tvis[u]=1;\n\tsum+=a[u];\n\tfor (LL v:g[u]){\n\t\tif (!vis[v]) dfs(v);\n\t}\n}\n\nint main(){\n\tscanf(\"%s\",s+1); m=strlen(s+1);\n\tfor (LL i=1;i<=m/2;++i) a[i]=s[i]-s[m-i+1];\n\ta[m/2+1]-=a[m/2];\n\tfor (LL i=m/2;i;--i) a[i]-=a[i-1];\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<=n;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\tif (x<=m/2&&y>=m-m/2+1){\n\t\t\tLL l1=m/2-x,l2=y-(m-m/2+1);\n\t\t\tif (l1>l2){\n\t\t\t\ty=m-y+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty=m-y+1;\n\t\t\t\tswap(x,y);\n\t\t\t}\n\t\t\t--y;\n\t\t}\n\t\tif (x>m/2){\n\t\t\tx=m-x+1; y=m-y+1;\n\t\t\tswap(x,y);\n\t\t}\n\t\tif (y>m/2) y=m/2;\n\t\tif (x<=y) add(x,y+1);\n\t}\n\tfor (LL i=1;i<=m/2+1;++i){\n\t\tsum=0;\n\t\tif (!vis[i]) dfs(i);\n\t\tif (sum){puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint L[110000],R[110000];\nint n,m,A[110000],len,a[110000];\nchar ch[110000];\nstruct tree{\n\tint w,l,r,d;\n}t[110000];\nint merge(int k1,int k2){\n\tif (k1==0||k2==0) return k1+k2;\n\tif (t[k1].w>t[k2].w) swap(k1,k2);\n\tt[k1].r=merge(t[k1].l,t[k1].r);\n\tif (t[t[k1].l].d<t[t[k1].r].d) swap(t[k1].l,t[k1].r);\n\tt[k1].d=t[t[k1].r].d+1;\n\treturn k1;\n}\nint LL;\nint root[110000];\nvoid add(int k1,int k2){\n\tLL++; t[LL]=(tree){k2,0,0,0};\n\troot[k1]=merge(root[k1],LL);\n}\nint main(){\n\tscanf(\"%s\",ch+1); len=strlen(ch+1); n=len/2;\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&L[i],&R[i]);\n\tfor (int i=1;i<=n;i++) A[i]=(ch[len-i+1]-ch[i]+26)%26;\n\tfor (int i=1;i<=m;i++){\n\t\tint k1=L[i],k2=R[i];\n\t\tif (k2*2<=len+1) add(k1,k2);\n\t\telse if (k1*2>=len+1){\n\t\t\tadd(len-k2+1,len-k1+1);\n\t\t} else if (len-L[i]+2<=R[i])\n\t\t\tadd(len-R[i]+1,L[i]-1);\n\t\telse if (len-R[i]>=L[i])\n\t\t\tadd(L[i],len-R[i]);\n\t}\n\tmemset(a,0x00,sizeof a);\n\tfor (int i=1;i<=n;i++){\n\t\twhile (root[i]&&t[root[i]].w<i) root[i]=merge(t[root[i]].l,t[root[i]].r);\n\t\tif (root[i]){\n\t\t\ta[i]=t[root[i]].w;\n\t\t\troot[a[i]+1]=merge(merge(root[a[i]+1],t[root[i]].l),t[root[i]].r);\n\t\t}\n\t}\n\tfor (int i=n;i;i--) A[i]=(A[i]-A[i-1]+26)%26;\n\t//for (int i=1;i<=n;i++) cout<<A[i]<<\" \"; cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]==0&&A[i]){\n\t\t\tprintf(\"NO\\n\"); return 0;\n\t\t}\n\t\tint num=A[i];\n\t\tif (num) A[a[i]+1]=(A[a[i]+1]+num+26)%26;\n\t}\n\tprintf(\"YES\\n\"); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nchar s[N];\nint f[N],val[N],m,l,r;\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nvoid merge(int u,int v) {\n\tu=find(u); v=find(v);\n\tif (u==v) return;\n\tf[u]=v; val[v]=(val[u]+val[v])%26;\n}\nint main() {\n\tscanf(\"%s\",s);\n\tint l=strlen(s);\n\trep(i,0,l) f[i]=i;\n\trep(i,0,l) if (i>0) {\n\t\tint w=(int)s[i]-(int)s[i-1];\n\t\tif (w<0) w+=26;\n\t\tval[i]=w;\n\t}\n\trep(i,1,l) merge(i,l-i);\n\tscanf(\"%d\",&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tmerge(l-1,r);\n\t}\n\trep(i,0,l) if (find(i)!=find(0)&&val[find(i)]!=0) {\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\tputs(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nconst int MAXN = 1e6+10;\nchar s[MAXN];\nint a[MAXN],N,M;\nstruct node {\n    int to,next;\n}E[MAXN * 10];\n\nint head[MAXN],sumE,sum;\nbool vis[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\n#define read(x) scanf(\"%d\",&x)\nvoid Init() {\n    scanf(\"%s\",s + 1);\n    N = strlen(s + 1);\n    s[0] = 'a';s[N + 1] = 'a';\n    for(int i = 1 ; i <= N + 1; ++i) a[i] = (s[i] - s[i - 1] + 26) % 26;\n    read(M);\n    int L,R;\n    for(int i = 1 ; i <= M ; ++i) {\n    read(L);read(R);\n    add(L,R + 1);add(R + 1,L);\n    }\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n    add(i,N + 2 - i),add(N+2-i,i);\n    }\n}\nvoid dfs(int u) {\n    vis[u] = 1;\n    sum = (sum + a[u]) % 26;\n    for(int i = head[u] ; i ; i = E[i].next) {\n    int v = E[i].to;\n    if(!vis[v]) {\n        dfs(v);\n    }\n    }\n}\nvoid Solve() {\n    bool flag = 1;\n    for(int i = 1 ; i <= N + 1 ; ++i) {\n    if(!vis[i]) {\n        sum = 0;\n        dfs(i);\n        if(sum != 0) {flag = 0;break;} \n    }\n    }\n    if(flag) puts(\"YES\");\n    else puts(\"NO\");\n}\nint main() {\n    Init();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937_64 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nint f[N], d[N];\n\nint find(int x) {\n  int y = f[x];\n  if (y != f[y]) {\n    f[x] = find(y);\n    d[x] = (d[y] + d[x]) % 26;\n  }\n  return f[x];\n}\n\nbool join(int x, int y, int diff) {\n  int rx = find(x), ry = find(y);\n  if (rx == ry) return d[x] == (diff + d[y]) % 26;\n  f[ry] = rx;\n  d[ry] = (d[x] + diff - d[y] + 26) % 26;\n  return true;\n}\n\nint main() {\n  srand(time(0));\n  string s;\n  cin >> s;\n  int n = s.size(), m;\n  cin >> m;\n  vector<ii> event;\n  vector<int64> H(m);\n  for (int i = 0; i < m; ++i) {\n    int L, R;\n    cin >> L >> R;\n    --L;\n    event.push_back({L, i});\n    event.push_back({R, i});\n    H[i] = mrand();\n  }\n  trace(H);\n  sort(event.begin(), event.end());\n  trace(event);\n  int64 cur = 0;\n  vector<int64> label(n);\n  for (int i = 0, k = 0; i < n; ++i) {\n    for (; k < SZ(event) && event[k].first <= i; ++k) cur ^= H[event[k].second];\n    label[i] = cur;\n  }\n  map<int64, int> A;\n  for (int i = 0; i < n; ++i) {\n    if (!A.count(label[i])) A[label[i]] = A.size();\n    label[i] = A[label[i]];\n  }\n  trace(label);\n  bool found = false;\n  m = A.size();\n  for (int i = 0; i < m; ++i) f[i] = i, d[i] = 0;\n  for (int i = 0; i < n / 2; ++i) {\n    int diff = (s[i] + 26 - s[n - 1 - i]) % 26;\n    if (!join(label[i], label[n - 1 - i], diff)) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int u = label[i];\n    find(u);\n    trace(i, u, d[u], (s[i] - 'a' + d[u]) % 26);\n  }\n  cout << (found ? \"NO\" : \"YES\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, q, len;\nchar s[100005];\nint from[100000], to[100000];\nint a[100000];\n\nset<int> se[100000];\nint best[100000];\n\nint par[100000];\n\nvoid dsuInit() {\n    forn(i, len + 1) par[i] = i;\n}\n\nint dsuParent(int v) {\n    if (v == par[v]) return v;\n    return par[v] = dsuParent(par[v]);\n}\n\nvoid dsuMerge(int u, int v) {\n    u = dsuParent(u);\n    v = dsuParent(v);\n    if (u == v) return;\n    if (se[u].size() < se[v].size()) swap(u, v);\n    for (int x : se[v]) {\n        se[u].insert(x);\n    }\n    par[v] = u;\n}\n\nint main() {\n    scanf(\"%s\", s);\n    n = strlen(s);\n    scanf(\"%d\", &q);\n    len = n / 2;\n    int ri = len + n % 2;\n    forn(i, q) {\n        scanf(\"%d%d\", from + i, to + i);\n        --from[i], --to[i];\n        if (to[i] < ri) {\n            to[i] = min(to[i], len - 1);\n            ++to[i];\n        } else if (from[i] >= len) {\n            from[i] = max(from[i], ri);\n            from[i] = n - 1 - from[i];\n            to[i] = n - 1 - to[i];\n            swap(from[i], to[i]);\n            ++to[i];\n        } else {\n            to[i] = n - 1 - to[i];\n            if (from[i] == to[i]) {\n                from[i] = to[i] = len;\n            } else {\n                if (from[i] > to[i]) {\n                    swap(from[i], to[i]);\n                }\n            }\n        }\n    }\n    a[len] = 0;\n    forn(i, len) {\n        a[i] = int(s[i]) - int(s[n - 1 - i]);\n        if (a[i] < 0) {\n            a[i] += 26;\n        }\n    }\n//    cerr << \"!!\" << endl;\n//    forn(i, len) cerr << a[i] << ' ';\n//    cerr << endl;\n//    forn(i, q) cerr << from[i] << ' ' << to[i] << endl;\n//    cerr << \"!!\" << endl;\n    for (int i = n - 1; i >= 0; --i) {\n        a[i + 1] -= a[i];\n        if (a[i + 1] < 0) {\n            a[i + 1] += 26;\n        }\n    }\n    forn(i, q) {\n        se[from[i]].insert(to[i]);\n    }\n    dsuInit();\n    forn(i, len) {\n        int si = dsuParent(i);\n        while (!se[si].empty() && *se[si].begin() == i) {\n            se[si].erase(se[si].begin());\n        }\n        if (!se[si].empty()) {\n            int ind = *se[si].begin();\n            se[si].erase(se[si].begin());\n            if (!se[si].empty()) {\n                dsuMerge(si, ind);\n            }\n            a[ind] += a[i];\n            a[i] = 0;\n            if (a[ind] >= 26) {\n                a[ind] -= 26;\n            }\n\n        }\n        if (a[i] != 0) {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    if (a[n] != 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\n\nint a[MAXN];\n\nvoid change(int L, int R, int v) {\n    a[L] += v;\n    a[R + 1] -= v;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    int M = (n + 1) / 2;\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls;\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            //cout << \"c1\";\n            x = n - x + 1;\n            y = n - y + 1;\n        }\n        if (x <=mm && y >mm) {\n            //cout<<\"c2\";\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        // cout << x << ' ' << y;\n        if (x > y) continue;\n        ls.emplace_back(x, y);\n    }\n    m = ls.size();\n    std::sort(begin(ls), end(ls));\n    int j = 0, val = 0;\n    for (int i = 1; i + i <= n; ++i) {\n        val = (val + a[i]) % 26;\n        val = (val + 26) % 26;\n        while (j < m && ls[j].se < i) j++;\n        if (j < m && ls[j].fi <= i) {\n            change(ls[j].fi, ls[j].se, -val);\n            val = 0;\n            j++;\n        }\n        if (val != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int A = 26;\nconst int N = 100100;\nchar s[N];\nint a[N];\nint n;\nint L;\nvector<int> g[N];\nint SUM = 0;\nbool used[N];\n\nvoid dfs(int v) {\n\tused[v] = 1;\n\tSUM += a[v];\n\tfor (int u : g[v]) {\n\t\tif (!used[u])\n\t\t\tdfs(u);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\" %s \", s);\n\tn = strlen(s);\n\tL = n / 2;\n\tfor (int i = 0; i < L; i++) {\n\t\ta[i] = (int)s[i] - (int)s[n - 1 - i];\n\t\tif (a[i] < 0) a[i] += A;\n\t}\n\tfor (int i = L; i > 0; i--) {\n\t\ta[i] -= a[i - 1];\n\t\tif (a[i] < 0) a[i] += A;\n\t}\n\tL++;\n\t/*\n\tfor (int i = 0; i < L; i++)\n\t\tprintf(\"%d \", a[i]);\n\tprintf(\"\\n\");\n\t*/\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile(m--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tl--;\n\t\tif (l + r > n) {\n\t\t\tswap(l, r);\n\t\t\tl = n - l;\n\t\t\tr = n - r;\n\t\t}\n\t\tif (r > n - r)\n\t\t\tr = n - r;\n\t\t//printf(\"edge %d %d\\n\", l, r);\n\t\tg[l].push_back(r);\n\t\tg[r].push_back(l);\n\t}\n\tfor (int v = 0; v < L; v++) {\n\t\tif (used[v]) continue;\n\t\tdfs(v);\n\t\tif (SUM % A != 0) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nchar S_[101010];\nint N, L[101010], R[101010];\nint S[101010];\nint D[101010];\n\nconst int W = 26;\n\nint uf[101010];\nint root(int p)\n{\n\treturn uf[p] < 0 ? p : (uf[p] = root(uf[p]));\n}\nvoid join(int p, int q)\n{\n\tp = root(p); q = root(q);\n\tif (p == q) return;\n\tuf[p] += uf[q];\n\tuf[q] = p;\n}\n\nvector<int> grps[101010];\n\nstruct data\n{\n\tint sum;\n\tset<int> *pos, *neg;\n\n\tint toppos() const {\n\t\tif (pos->empty()) return 1000000;\n\t\treturn *(pos->begin());\n\t}\n\tint topneg() const {\n\t\tif (neg->empty()) return 1000000;\n\t\treturn *(neg->begin());\n\t}\n\tint top() const {\n\t\treturn min(toppos(), topneg());\n\t}\n\tint size() const {\n\t\treturn pos->size() + neg->size();\n\t}\n\tbool isneg() const {\n\t\tint a = toppos();\n\t\tint b = topneg();\n\t\treturn a > b;\n\t}\n\tdata(int sum, set<int> *pos, set<int> *neg) : sum(sum), pos(pos), neg(neg) {}\n};\n\ninline bool operator<(const data& a, const data& b) {\n\treturn a.top() < b.top() || (a.top() == b.top() && (i64)a.pos < (i64)b.pos);\n}\n\nset<data> eqs;\n\nvoid waf(set<int> *pos, set<int> *neg, int v)\n{\n\t// add v as positive\n\tif (neg->count(v)) {\n\t\tneg->erase(v);\n\t} else {\n\t\tpos->insert(v);\n\t}\n}\n\ndata mgr(data a, data b)\n{\n\tif (a.size() < b.size()) swap(a, b);\n\tbool an = a.isneg(), bn = b.isneg();\n\tbool neg = an == bn;\n\tif (neg) {\n\t\ta.sum = (a.sum + W - b.sum) % W;\n\t\tfor (int p : *b.neg) {\n\t\t\twaf(a.pos, a.neg, p);\n\t\t}\n\t\tfor (int p : *b.pos) {\n\t\t\twaf(a.neg, a.pos, p);\n\t\t}\n\t} else {\n\t\ta.sum = (a.sum + b.sum) % W;\n\t\tfor (int p : *b.pos) {\n\t\t\twaf(a.pos, a.neg, p);\n\t\t}\n\t\tfor (int p : *b.neg) {\n\t\t\twaf(a.neg, a.pos, p);\n\t\t}\n\t}\n\treturn a;\n}\n\nvoid show(const data& d) {\n\tprintf(\"s=%d pos=\", d.sum);\n\tfor (int p : *d.pos) printf(\"%d,\", p);\n\tprintf(\" neg=\");\n\tfor (int p : *d.neg) printf(\"%d,\", p);\n\tputs(\"\");\n}\n\nint main()\n{\n\tscanf(\"%s%d\", S_, &N);\n\tint M = strlen(S_);\n\tfor (int i = 0; i < M + 3; ++i) uf[i] = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\t--L[i];\n\n\t\tjoin(L[i], R[i]);\n\t}\n\tS[0] = S[M + 2] = 0;\n\tfor (int i = 0; i < M; ++i) S[i + 1] = S_[i] - 'a';\n\n\tfor (int i = 0; i <= M; ++i) {\n\t\tD[i] = (S[i + 1] - S[i] + W) % W;\n\t}\n\tM += 1;\n\tfor (int i = 0; i < M; ++i) {\n\t//\tprintf(\"%d\\n\", D[i]);\n\t\tgrps[root(i)].push_back(i);\n\t}\n\tfor (int i = 0; i < M; ++i) if (grps[i].size() > 0) {\n\t\tint sum = 0;\n\t\tset<int> *pos = new set<int>, *neg = new set<int>;\n\t\tfor (int p : grps[i]) {\n\t\t\tif (p * 2 + 1 == M) {\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p >= M / 2) {\n\t\t\t\twaf(neg, pos, M - 1 - p);\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaf(pos, neg, p);\n\t\t\t\tsum = (sum + D[p]) % W;\n\t\t\t}\n\t\t}\n\t//\tshow(data(sum, pos, neg));\n\t\teqs.insert(data(sum, pos, neg));\n\t}\n\twhile (!eqs.empty()) {\n\t\tdata top = *(eqs.begin());\n\t\teqs.erase(eqs.begin());\n\n\t\tif (top.top() == 1000000) {\n\t\t\tif (top.sum != 0) {\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (eqs.empty()) break;\n\n\t\tif (eqs.begin()->top() != top.top()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata top2 = *(eqs.begin());\n\t\teqs.erase(eqs.begin());\n\n\t//\tshow(top);\n\t//\tshow(top2);\n\t//\tputs(\"---\");\n\n\t\tdata nw = mgr(top, top2);\n\t\teqs.insert(nw);\n\t}\n\n\tputs(\"YES\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstring st;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {  cin >> st;\n\tbool flag = false;\n\tif (st.size() % 2) {\n\t\tst.erase(st.begin() + st.size() / 2);\n\t\tflag = true;\n\t}\n\tassert(st.size() % 2 == 0);\n\tint N; cin >> N;\n\tvector<int>nums(st.size() + 1);\n\tnums[0] = st[0] - 'a';\n\tfor (int i = 1; i < st.size(); ++i) {\n\t\tnums[i] = (26+st[i] - st[i - 1])%26;\n\t}\n\tnums[st.size()] = 26 - (st[st.size() - 1]-'a');\n\tvector<pair<int, int>>edges;\n\tvector<long long int>nodes(st.size() + 1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint l, r; cin >> l >> r;\n\t\tl--;\n\t\tif (flag) {\n\t\t\tif (l > st.size() / 2) {\n\t\t\t\tl--;\n\t\t\t}\n\t\t\tif (r>st.size()/2) {\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t\tif (l > st.size()) {\n\t\t\tl = st.size() - l;\n\t\t}\n\t\tif(r>st.size()){\n\t\t\tr = st.size() - r;\n\t\t}\n\t\tedges.push_back(make_pair(l, r));\n\t}\n\tvector<int>flags(st.size() / 2 + 1);\n\n\tUnionFind uf(st.size() / 2 + 1);\n\tfor (auto e : edges) {\n\t\tif (e.first == e.second)flags[e.first] = true;\n\t\telse {\n\t\t\tuf.unionSet(e.first, e.second);\n\t\t}\n\n\t}\n\tfor (int i = 0; i < st.size() / 2; ++i) {\n\t\tnums[i] += nums[st.size() - i];\n\t}\n\tset<int>roots;\n\tmap<int, pair<long long int, bool>>mp;\n\tvector<long long int >sums(st.size() / 2 + 1);\n\tfor (int i = 0; i < st.size() / 2 + 1; ++i) {\n\t\tmp[uf.root(i)].first += nums[i];\n\t\tif (flags[i])mp[uf.root(i)].second = true;\n\t}\n\tbool ok = true;\n\tfor (auto m : mp) {\n\t\tm.second.first %= 26;\n\t\tif (m.second.second) {\n\t\t\tif (m.second.first % 2)ok = false;\n\t\t}\n\t\telse {\n\t\t\tif (m.second.first)ok = false;\n\t\t}\n\t}\n\tif (ok)cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint xor128(void)\n{\n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123;\n  int t;\n\n  t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind\n{\n  int n;\n  T d;\n  vector< int > r, p;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz, T d_) :\n      n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n  int find(int x)\n  {\n    if(x == p[x]) {\n      return x;\n    } else {\n      int t = find(p[x]);\n      ws[x] += ws[p[x]];\n      return p[x] = t;\n    }\n  }\n\n  T weight(int x)\n  {\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y, T w)\n  {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(r[x] < r[y]) swap(x, y), w = -w;\n    r[x] += r[y];\n    p[y] = x;\n    ws[y] = w;\n  }\n\n  T diff(int x, int y)\n  {\n    return weight(y) - weight(x);\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree\n{\n  vector< T > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k)\n  {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret ^= data[k];\n    return (ret);\n  }\n\n  void add(int k, T x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] ^= x;\n  }\n};\n\nint main()\n{\n  string S;\n  cin >> S;\n  int N;\n  cin >> N;\n  BinaryIndexedTree< int > bit(S.size() + 1);\n  while(N--) {\n    int x, y;\n    cin >> x >> y;\n    --x;\n    int rd = xor128();\n    bit.add(x, rd);\n    bit.add(y, rd);\n  }\n  vector< int > vs;\n  for(int i = 0; i < S.size(); i++) {\n    vs.emplace_back(bit.sum(i));\n  }\n  sort(begin(vs), end(vs));\n  vs.erase(unique(begin(vs), end(vs)), end(vs));\n  vector< vector< int > > st(vs.size());\n  map< int, int > ind;\n  for(int i = 0; i < S.size(); i++) {\n    int p = bit.sum(i);\n    p = lower_bound(begin(vs), end(vs), p) - begin(vs);\n    st[p].emplace_back(i);\n    ind[i] = p;\n  }\n\n  WeightedUnionFind< int > uf(st.size(), 0);\n  for(int i = 0; i < st.size(); i++) {\n\n    for(auto &idx : st[i]) {\n      int other = (int) S.size() - idx - 1;\n      if(ind[other] == i) {\n        if(S[other] != S[idx]) {\n          cout << \"NO\" << endl;\n          return (0);\n        }\n      } else {\n        // S[other]-S[idx]=x\n        if(!uf.same(i, ind[other])) {\n          uf.unite(i, ind[other], (S[other] - S[idx] + 26) % 26);\n        } else {\n          int diff = uf.diff(i, ind[other]);\n          if((diff % 26 + 26) % 26 != (S[other] - S[idx] + 26) % 26) {\n            cout << \"NO\" << endl;\n            return (0);\n          }\n        }\n      }\n    }\n\n  }\n\n  cout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\nconst int MOD = 26;\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntemplate<class T, int SZ> struct LazySeg {\n    T sum[2 * SZ], lazy[2 * SZ];\n    LazySeg() {\n        for (int i = 0; i < 2 * SZ; i++) {\n            sum[i] = 0;\n            lazy[i] = 0;\n        }\n    }\n    void push(int ind, int L, int R) {\n        sum[ind] += (R - L + 1) * lazy[ind];\n        if (L != R) {\n            lazy[2 * ind] += lazy[ind];\n            lazy[2 * ind + 1] += lazy[ind];\n        }\n        lazy[ind] = 0;\n    }\n    void pull(int ind) {\n        sum[ind] = sum[2 * ind] + sum[2 * ind + 1];\n    }\n    void build() {\n        for (int i = SZ - 1; i >= 1; i--) {\n            pull(i);\n        }\n    }\n    void upd(int lo, int hi, T inc, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (hi < L || R < lo) return ;\n        if (lo <= L && R <= hi) {\n            lazy[ind] = inc;\n            push(ind, L, R);\n            return;\n        }\n        int M = (L + R) / 2;\n        upd(lo, hi, inc, 2 * ind, L, M);\n        upd(lo, hi, inc, 2 * ind + 1, M + 1, R);\n        pull(ind);\n    }\n    T qsum(int lo, int hi, int ind = 1, int L = 0, int R = SZ - 1) {\n        push(ind, L, R);\n        if (lo > R || L > hi) return 0;\n        if (lo <= L && R <= hi) return sum[ind];\n        int M = (L + R) / 2;\n        return qsum(lo, hi, 2 * ind, L, M) + qsum(lo, hi, 2 * ind + 1, M + 1, R);\n    }\n};\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    int len = s.size();\n    vector<pair<int, int>> use;\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (r < len / 2) {\n            use.emplace_back(l, r);\n            continue;\n        }\n        if (l >= (len + 1) / 2) {\n            use.emplace_back(len - 1 - r, len - 1 - l);\n            continue;\n        }\n        if (l == len - 1 - r) {\n            continue;\n        }\n        if (l < len - 1 - r) {\n            use.emplace_back(l, len - 1 - r - 1);\n        } else {\n            use.emplace_back(len - 1 - r, l - 1);\n        }\n    }\n    int half = (len - 1) / 2 + 1;\n    vector<vector<int>> loc(half);\n    for (auto x: use) {\n        loc[x.first].push_back(x.second);\n    }\n    for (int i = 0; i < half; i++) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        while(loc[i].size() > 1) {\n            int r = loc[i].back();\n            loc[i].pop_back();\n            int l = loc[i].back() + 1;\n            loc[l].push_back(r);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int r: loc[i]) {\n            use.emplace_back(i, r);\n        }\n        loc[i].clear();\n    }\n    for (auto x: use) {\n        loc[x.second].push_back(x.first);\n    }\n    use.clear();\n    for (int i = half - 1; i >= 0; i--) {\n        sort(loc[i].begin(), loc[i].end());\n        loc[i].erase(unique(loc[i].begin(), loc[i].end()), loc[i].end());\n        reverse(loc[i].begin(), loc[i].end());\n        while (loc[i].size() > 1) {\n            int l = loc[i].back();\n            loc[i].pop_back();\n            int r = loc[i].back() - 1;\n            loc[r].push_back(l);\n        }\n    }\n    for (int i = 0; i < half; i++) {\n        for (int l: loc[i]) {\n            use.emplace_back(l, i);\n        }\n        loc[i].clear();\n    }\n    string t;\n    for (int i = len - 1; i >= len - half; i--) {\n        t += s[i];\n    }\n    while (s.size() > half) {\n        s.pop_back();\n    }\n    len = half;\n    LazySeg<mi, (1 << 16)> seg;\n    for (int i = 0; i < len; i++) {\n        seg.upd(i, i, s[i] - '0');\n    }\n    sort(use.begin(), use.end());\n    for (auto x: use) {\n        int l = x.first;\n        int r = x.second;\n        int add = ((t[l] - '0') - seg.qsum(l, l).val + MOD) % MOD;\n        seg.upd(l, r, add);\n    }\n    for (int i = 0; i < len; i++) {\n        if (seg.qsum(i, i) != t[i] - '0') {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\t//S[k] += a;\n\t//S[S.size()-1-k] += b;\n\tif(S.size()-1-k <= k)return true;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tsor(vec[k]);\n\tuniq(vec[k]);\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tvec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN], sum[MAXN];\nbool mark[MAXN];\nstring S, T;\nvector<int> G[MAXN];\n\nvoid add(int l, int r){\n\tG[l].pb(r+1);\n\tG[r+1].pb(l);\n}\n\nint dfs(int node){\n\tmark[node]=1;\n\tfor (int v:G[node]) if (!mark[v]) sum[node]+=dfs(v);\n\treturn sum[node];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>S>>m;\n\tint len=S.size();\n\tn=len/2;\n\tfor (int i=0; i<n; i++) T+=S.back(), S.pop_back();\n\tif (len&1) S.pop_back();\n\t\n\tfor (int i=1; i<=n; i++) A[i]=S[n-i]-T[n-i];\n\tfor (int i=1; i<=n+1; i++) sum[i]=A[i]-A[i-1];\n\twhile (m--){\n\t\tcin>>x>>y;\n\t\tif (len%2){\n\t\t\tif (x==n+1 && y==n+1) continue ;\n\t\t\tif (x==n+1) x++;\n\t\t\tif (y==n+1) y--;\n\t\t\tif (x>n) x--;\n\t\t\tif (y>n) y--;\n\t\t}\n\t\tif (x<=n && y<=n) x=n-x+1, y=n-y+1, swap(x, y);\n\t\telse if (x>n && y>n) x-=n, y-=n;\n\t\telse{\n\t\t\tx=n-x+1;\n\t\t\ty-=n;\n\t\t\tif (x>y) swap(x, y);\n\t\t\tx++;\n\t\t}\n\t\tadd(x, y);\n\t}\n\tfor (int i=1; i<=n+1; i++) if (!mark[i] && dfs(i)%26) kill(\"NO\")\n\tkill(\"YES\")\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n \ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n \n \n \ntypedef pair<int,int> pint;\nconst int MAX = 210000;\n\nconst int MAX_UF = MAX;\nstruct UnionFind {    \n    int size_;\n    int par[MAX_UF];\n    int rank[MAX_UF];\n    \n    UnionFind(int n = 0) {size_ = n; for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0;}\n    void init(int n) {size_ = n; for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0;}\n    int root(int x) {return par[x] == x ? x : par[x] = root(par[x]);}    \n    bool same(int x, int y) {return root(x) == root(y);}\n    \n    void connect(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return;        \n        if (rank[x] < rank[y]) par[x] = y;\n        else {par[y] = x; if (rank[x] == rank[y]) ++rank[x];}\n    }\n    \n    friend ostream& operator << (ostream& s, UnionFind uf) {return s << uf.group();}\n    vector<vector<int> > group() {\n        vector<vector<int> > res;        \n        vector<bool> fixed(size_, false);\n        for (int i = 0; i < size_; ++i) {\n            if (!fixed[i]) {\n                vector<int> temp;\n                for (int j = i; j < size_; ++j) {\n                    if (same(i, j)) temp.push_back(j), fixed[j] = true;\n                }\n                res.push_back(temp);\n            }\n        }\n        return res;\n    }\n} uf;\n\n\nstring str;\nint a[MAX];\nint b[MAX];\nint N;\npint seg[MAX];\n\nint sum[MAX];\n\nbool solve() {\n\tint n = str.size() + 1;\n\n\tmemset(sum, 0, sizeof(sum));\n\tfor (int i = 0; i < n; ++i) {\n\t  int r = uf.root(i);\n\t  sum[r] += b[i];\n\t}\n\tfor (int i = 0; i < MAX; ++i) {\n\t  if (sum[i] % 26 != 0)\n\t\treturn false;\n\t}\n\t\n\treturn true;\t\t\t\t\t   \n}\n\nint main() {\n  while (cin >> str >> N) {\n\tint n = str.size() + 1;\n\tuf.init(n);\n\tfor (int i = 0; i < N; ++i) {\n\t  cin >> seg[i].first >> seg[i].second;\n\t  --seg[i].first;\n\t  uf.connect(seg[i].first, seg[i].second);\n\t}\n\tfor (int i = 0; i < n/2; ++i) {\n\t  int j = n - i - 1;\n\t  uf.connect(i, j);\n\t}\n\n\tmemset(a, 0, sizeof(a));\n\tfor (int i = 0; i < str.size(); ++i) {\n\t  a[i] = (int)(str[i] - 'a');\n\t}\n\tb[0] = a[0];\n\tfor (int i = 0; i < str.size(); ++i) {\n\t  b[i+1] = a[i+1] - a[i];\n\t  if (b[i+1] < 0) b[i+1] += 26;\n\t  //cout << i + 1 << \", \" << a[i+1] << \", \" << b[i+1] << endl;\n\t}\n\t//COUT(uf);\n\t\n\tif (solve()) puts(\"YES\");\n\telse puts(\"NO\");\n  }\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Aimi Haraguni >> Konomi Suzuki >> Yui >>  Ikimono Gakari >> Garnidelia >> Kalafina >> Eir Aoi.   .. dude?\n// Ztoking the best of the best\n// Kirito >> Naofumi >> Yun Che >> Hao\n// .... Sempre Amei Você ...\n \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser\n// \n// \n// Você nunca verá uma menina como ela\n// Mais linda em sentimentos que romance de novela\n// Bela, ingênua, tipo como cinderela\n// Sorte é do homem que estiver ao lado dela\n// Guerreira, não compare com as demais\n// Lutou muito para cumprir a exigência de seus pais\n// Sua força vai além do que cê pensa ser capaz\n// Essa menina não desiste daquilo que vai atrás, mas\n// Eu fui tão cego pra não ver\n// Que apenas ao meu lado ela queria viver\n// Enquanto que por outra pessoa eu quis correr\n// Ela não desistiu de mim mesmo eu a fazendo sofrer\n// Que idiota, como eu não pude perceber?\n// Que a menina que me amava estava sempre ali pra ver\n// Eu sei que esse sentimento eu não mereço ter\n// Mas desta vez eu vou tentar com meus erros aprender\n//\n// \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser\n// \n// \n// Ela sempre esteve lá, pra me ajudar\n// Quando eu caí, me fez levantar\n// Lutei tanto por meu sonho que sempre quis alcançar\n// Que acabei ficando cego sem poder enxergar\n// Eu nem consegui notar\n// Que bem na minha frente era quem deveria amar\n// Sempre achei que estava certo e que não podia errar\n// Mas só mesmo quando perde pra então valorizar\n// E eu perdi, e finalmente entendi\n// Que quem eu procurava estava sempre ali\n// Levou muito tempo pra ficha cair\n// Como eu fui tapado, eu tenho que admitir\n// Essa menina conseguiu me surpreender\n// Seu olhar estava sempre além do que eu podia ver\n// Eu tive que a perder, só pra perceber\n// Que ao lado dela é onde eu quero viver\n// \n// \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser\n// \n// \n// Eu tive que a perder\n// Pra que pudesse perceber\n// Que ao lado dela\n// É onde eu quero viver\n// Sim, um dia pode ser o fim\n// Pode ser tarde demais e tudo acabar assim\n// Mas pra ela eu vou dizer\n// Não volto com minha palavra\n// Com você quero viver\n// \n// \n// Sempre amei você\n// Mesmo de longe sem te ter\n// Você me deu forças para viver\n// E ser quem eu queria ser \n \n \n// #pragma GCC optimize (\"Ofast,unroll-loops\")\n// #pragma GCC target (\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n \n#define pb push_back\n#define ff  first\n#define ss second\n#define tm1 first\n#define tm2 second.first\n#define tm3 second.second\n#define sz(x) ll(x.size())\n#define fill(x, v) memset(x, v, sizeof(x))\n#define all(v) (v).begin(), (v).end()\n#define FER(i,a,b) for(ll i=ll(a); i< ll(b); ++i)\n#define IFR(i,a,b) for(ll i=ll(a); i>=ll(b); --i )\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0)\n \n#define N 6800000\n#define kk 550\n#define mod1 1000000007\n#define mod2 1000000009\n#define bas 987625403\n#define sqr(x) (x)*(x)  \n#define INF 5000000000000000\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef pair<ll, ii > tri;\ntypedef vector<ll> vi;\ntypedef vector<ii> vii;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> set_t;\n \n#define trace(...) f(#__VA_ARGS__, __VA_ARGS__)\n \ntemplate<typename t> void f(const char* x, t&& val1){\n    cout<<x<< \" : \"<<val1<<endl;\n}\n \ntemplate<typename t1, typename... t2> void f(const char* x, t1&& val1, t2&&... val2){\n    const char* xd=strchr(x+1, ',');\n    cout.write(x, xd-x)<<\" : \"<<val1<<\" | \";\n    f(xd+1, val2...);\n}\n\n \nstruct ST{\n\tll n, t[1<<18];\n\tinline ll Op(ll &val1, ll &val2){\n\t\treturn val1+val2;\n\t}\n\tinline void build(){\n\t\tIFR(i, n-1, 1) t[i]=Op(t[i<<1], t[i<<1|1]);\n\t}\n\tinline void modify(ll l, ll r, ll val){\n\t\tfor(l+=n, r+=n; l<r; l>>=1, r>>=1){\n\t\t\tif(l&1) t[l++]+=val;\n\t\t\tif(r&1) t[--r]+=val;\n\t\t}\n\t}\n\tinline ll que(ll p){\n\t\tll ans=0;\n\t\tfor(p+=n; p>0; p>>=1) ans+=t[p];\n\t\treturn ans;\n\t}\n}st;\n \ninline tri transform(ll a, ll b, ll n){\n\tll lim=(n+1)/2;\n\tif(n&1){\n\t\tif(b<=lim) return {0, {a-1, b-a+1}};\n\t\tif(a==lim) return {1, {a, b-a}};\n\t\tif(a>lim) return {1, {a-1, b-a+1}};\n\t\tll left=lim-a, right=b-lim;\n\t\tif(left==right) return {-1, {a-1, 0}};\n\t\tif(left<right){\n\t\t\tll add=right-left;\n\t\t\tll idx=b-add;\n\t\t\treturn {1, {idx, add}};\n\t\t}\n\t\telse{\n\t\t\tll add=left-right;\n\t\t\treturn {0, {a-1, add}};\n\t\t}\t\n\t}\n\telse{\n\t\tif(b<=lim) return {0, {a-1, b-a+1}};\n\t\tif(a>lim) return {1, {a-1, b-a+1}};\n\t\tll left=lim-a+1, right=b-lim;\n\t\tif(left==right) return {-1, {a-1, 0}};\n\t\tif(left<right){\n\t\t\tll add=right-left;\n\t\t\tll idx=b-add;\n\t\t\treturn {1, {idx, add}};\n\t\t}\n\t\telse{\n\t\t\tll add=left-right;\n\t\t\treturn {0, {a-1, add}};\n\t\t}\n\t}\n}\n \ninline ll check(ll n){\n\tFER(i,0,(n+1)/2){\n\t\tll t1=st.que(i), t2=st.que(n-1-i);\n\t\tif(t1!=t2) return 0;\n\t}\n\treturn 1;\n}\n\nvi queriesL[1<<17], queriesR[1<<17];\nvi graph[1<<17];\nll ar[1<<17], vis[1<<17];\ninline void dfs(ll u, ll &sum){\n\tvis[u]++;\n\tsum+=ar[u];\n\tfor(auto xd: graph[u]) if(!vis[xd]) dfs(xd, sum);\n}\nint main(){\n\tfastio;\n\tstring s; cin>>s;\n\tll q, n=sz(s); cin>>q;\n\tst.n=n;\n\tar[0]=0, ar[n+1]=0;\n\tFER(i,0,st.n) {\n\t\tll valor=(s[i]-'a'+0);\n\t\tar[i+1]=valor;\n\t}\n\tvi tnt;\n\tFER(i,0,n+1){\n\t\ttnt.pb(ar[i+1]-ar[i]);\n\t\tgraph[i].pb(n-i);\n\t}\n\tFER(i,0,sz(tnt)) ar[i]=tnt[i]%26;\n\tFER(i,0,q){\n\t\tll a, b; cin>>a>>b;\n\t\ttri cur=transform(a, b, n);\n\t\tif(cur.tm1==-1) continue;\n\t\tll x=cur.tm2, y=cur.tm3+cur.tm2;\n\t\tgraph[x].pb(y);\n\t\tgraph[y].pb(x);\n\t}\n\tll flag=1;\n\tFER(i,0,n+1) if(!vis[i]){\n\t\tll sum=0;\n\t\tdfs(i, sum);\n\t\tif(sum%26) flag=0;\n\t}\n\tflag? cout<<\"YES\"<<\"\\n\": cout<<\"NO\"<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define PI                acos(-1)\n#define pb                emplace_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define clr(a,h)          memset(a, (h), sizeof(a))\n#define F first\n#define S second\nint faster_in(){int r=0,c;for(c=getchar();c<=32;c=getchar());if(c=='-') return -faster_in();for(;c>32;r=(r<<1)+(r<<3)+c-'0',c=getchar());return r;}\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long       ll;\ntypedef pair<int, int>  ii;\ntypedef vector<int>     vi;\ntypedef vector<ii>      vii;\ntypedef vector<ll>      vll;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst int INF = int(1e9 + 7);\n\nconst int tam = 100010;\n\nvector<int> G[tam];\nint val[tam];\nbool vis[tam];\n\nint sum;\nvoid dfs(int v)\n{\n\t//cout << \"(\" << v << \",\" << val[v] << \") \";\n\tsum += (val[v] + 26);\n\tsum %= 26;\n\tvis[v] = true;\n\tfor (int u : G[v])\n\t{\n\t\tif ( vis[u] ) continue;\n\t\tdfs(u);\n\t}\n}\n\nii E[tam];\n\nint main()\n{\n    std::ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n    \tcin >> E[i].F >> E[i].S;\n    }\n    s = \"a\" + s + \"a\";\n/*\n    cout << s << endl;\n\tfor (int i = 0; i < s.size()-1; i++)\n    {\n    \tval[i] = (s[i+1] - s[i] + 26) % 26;\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n*/\n    for (int i = 0; i < n; i++)\n    {\n    \tval[ E[i].F-1 ] = (val[ E[i].F-1 ] + 1) % 26;\n    \tval[ E[i].S ] = (val[ E[i].S ] - 1 + 26) % 26;\n    \tG[E[i].F-1].pb( E[i].S );\n    \tG[ E[i].S ].pb(E[i].F-1);\n    }\n    /*\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tcout << \"(\" << val[i] << \"[\" << i << \",\" << i+1 << \"]) \";\n    }\n    cout << endl;\n    */\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tG[i].pb( s.size()-2-i );\n    }\n    clr(vis, false);\n    bool poss = true;\n    for (int i = 0; i < s.size()-1; i++)\n    {\n    \tif (vis[i]) continue;\n    \t//cout << \"component: \" << endl;\n    \tsum = 0;\n    \tdfs(i);\n    \t//cout << endl << \"===============\" << endl;\n    \tif (sum != 0) poss = false;\n    }\n    if (poss) cout << \"YES\" << '\\n';\n    else cout << \"NO\" << '\\n';\n    return 0;\n}\n// PLUS ULTRA!"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mod = 'z' - 'a' + 1;\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\n\tint m;\n\tcin >> m;\n\tvector<vector<int>> graph(n/2 + 1);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a;\n\t\ta = min(a, n-a);\n\t\tb = min(b, n-b);\n\t\tif(a != b) {\n\t\t\tgraph[a].push_back(b);\n\t\t\tgraph[b].push_back(a);\n\t\t}\n\t}\n\n\tvector<int> vec(n/2);\n\tfor(int i = 0; i < n/2; ++i) {\n\t\tvec[i] = int(s[i]) - int(s[n-1-i]);\n\t\tvec[i] %= mod;\n\t\tvec[i] += mod;\n\t\tvec[i] %= mod;\n\t}\n\n\tn  = n/2+1;\n\n\tvector<bool> seen(n, false);\n\tfunction<void(int, vector<int>&)> dfs = [&](int node, vector<int> &comp) {\n\t\tif(seen[node]) return;\n\t\tseen[node] = true;\n\t\tcomp.push_back(node);\n\t\tfor(int ch : graph[node]) dfs(ch, comp);\n\t};\n\n\tvector<int> finish(n, -1);\n\tvector<int> start(n, -1);\n\tvector<int> total;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(!seen[i]) {\n\t\t\tvector<int> comp;\n\t\t\tdfs(i, comp);\n\t\t\tfor(int j = 1; j < comp.size(); ++j) {\n\t\t\t\tstart[comp[j-1]] = total.size();\n\t\t\t\tfinish[comp[j]] = total.size();\n\t\t\t\ttotal.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint sum = 0;\n\tbool can = true;\n\tfor(int i = 0; i < n-1; ++i) {\n\t\tassert(vec[i] >= 0);\n\t\tassert(sum >= 0);\n\t\tvec[i] += sum;\n\t\tvec[i] %= mod;\n\t\tif(vec[i] != 0) {\n\t\t\tif(start[i] == -1) can = false;\n\t\t\telse {\n\t\t\t\tsum += mod - vec[i];\n\t\t\t\tsum %= mod;\n\t\t\t\ttotal[start[i]] = (mod - vec[i]) % mod;\n\t\t\t}\n\t\t}\n\t\tif(finish[i+1+0] != -1) {\n\t\t\tsum += mod - total[finish[i+1]];\n\t\t\tsum %= mod;\n\t\t}\n\t}\n\n\tif(can) {\n\t\tcout << \"YES\" << endl;\n\t} else {\n\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nusing namespace std;\n\nstring s;\nint n, l[N], r[N], x[N], root[N], summ[N], sz[N];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    if (s.size() == 1)\n    {\n        cout << \"YES\";\n        return 0;\n    }\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--, r[i]--;\n    }\n    if (s.size() % 2 == 1)\n    {\n        int pos = s.size() / 2;\n        for (int i = 0; i < n; i++)\n        {\n            if (l[i] == pos && r[i] == pos)\n            {\n                n--;\n                swap(l[i], l[n]);\n                swap(r[i], r[n]);\n                i--;\n                continue;\n            }\n            if (l[i] > pos) l[i]--;\n            if (r[i] >= pos) r[i]--;\n        }\n        string t = \"\";\n        for (int i = 0; i < s.size(); i++) if (i != pos) t += s[i];\n        s = t;\n    }\n    int len = s.size() / 2;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] < len && r[i] >= len)\n        {\n            int p1 = len - l[i], p2 = r[i] - len + 1;\n            if (p1 == p2) l[i] = -1, r[i] = -1;\n            if (p1 < p2)\n            {\n                l[i] += 2 * p1;\n            }\n            if (p1 > p2)\n            {\n                r[i] -= 2 * p2;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] >= len)\n        {\n            int rr = s.size() - 1 - l[i];\n            int ll = s.size() - 1 - r[i];\n            l[i] = ll, r[i] = rr;\n        }\n    }\n    for (int i = 0; i < len; i++)\n    {\n        x[i + 1] = (s[s.size() - 1 - i] + 26 - s[i]) % 26;\n    }\n    for (int i = len + 1; i > 0; i--)\n    {\n        x[i] = (x[i] - x[i - 1] + 26) % 26;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        l[i]++, r[i]++, r[i]++;\n    }\n    iota(root, root + len + 2, 0);\n    fill(sz, sz + len + 2, 1);\n    for (int i = 0; i < n; i++)\n    {\n        int a = l[i], b = r[i];\n        while (a != root[a]) a = root[a];\n        while (b != root[b]) b = root[b];\n        if (a == b) continue;\n        if (sz[a] < sz[b])\n        {\n            sz[b] += sz[a];\n            root[a] = b;\n        }\n        else\n        {\n            sz[a] += sz[b];\n            root[b] = a;\n        }\n    }\n    for (int i = 1; i < len + 2; i++)\n    {\n        int j = i;\n        while (j != root[j]) j = root[j];\n        summ[j] += x[i];\n    }\n    int t = -1;\n    for (int i = 0; i < len + 2; i++)\n    {\n        if (summ[i] % 26 != 0)\n        {\n            if (t == -1) t = i;\n            else cout << \"NO\", exit(0);\n        }\n    }\n    if (t == -1) cout << \"YES\", exit(0);\n    cout << \"YES\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a(n/2);\n    rep(i,n/2){\n        a[i] = (26+s[n-1-i]-s[i])%26;\n    }\n    rep(i,n/2)cerr << a[i] << \" \";\n    cerr << endl;\n    int m;\n    cin >> m;\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > p;\n    rep(i,m){\n        int l,r;\n        cin >> l >> r;\n        l--;r--;\n        if(n%2==1){\n            if(l==n/2&&r==n/2)continue;\n            if(l==n/2)l++;\n            if(r==n/2)r--;\n        }\n        if(l==r){\n            if(l>=n/2){\n                l = n-1-l;\n                p.push(MP(l,l));\n            }else{\n                p.push(MP(l,l));\n            }\n        }else{\n            if(l<n/2&&r<n/2){\n                p.push(MP(l,r));\n            }else if(l<n/2){\n                r = n-1-r;\n                if(l<r){\n                    p.push(MP(l,r-1));\n                }else if(l>r){\n                    p.push(MP(r,l-1));\n                }\n            }else if(r>=n/2){\n                l = n-1-l;\n                r = n-1-r;\n                p.push(MP(min(l,r),max(l,r)));\n            }\n        }\n    }\n    vector<int> nxt(n/2,-1);\n    while(!p.empty()){\n        auto x = p.top();\n        p.pop();\n        int a = x.first;\n        int b = x.second;\n        if(nxt[a]==-1){\n            nxt[a] = b;\n        }else{\n            if(nxt[a]>b){\n                p.push(MP(b+1,nxt[a]));\n                nxt[a] = b;\n            }else if(nxt[a]<b){\n                p.push(MP(nxt[a]+1,b));\n            }\n        }\n    }\n    rep(i,n/2){\n        cerr << nxt[i] << \" \";\n    }\n    cerr << endl;\n    vector<int> res(n/2);\n    vector<int> ss(n/2+1);\n    int tmp = 0;\n    rep(i,n/2){\n        tmp -= ss[i];\n        res[i] += tmp;\n        res[i] %= 26;\n        if(res[i]!=a[i]){\n            if(nxt[i]!=-1){\n                int c = (26+a[i]-res[i])%26;\n                tmp += c;\n                ss[nxt[i]+1] += c;\n                res[i] = a[i];\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << res[i] << \" \";\n    // }\n    // cerr << endl;\n    rep(i,n/2){\n        if(res[i]!=a[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define N 100010\nvector<ll> g[N];\nll c[N],d[N];\nbool vis[N];\nll dfs(ll x){\n  if(vis[x])return 0;\n  vis[x]=1;\n  ll res=d[x];\n  for(auto y:g[x]){\n    res+=dfs(y);\n  }\n  return res;\n}\nint main(){\n  ll n,m;string s;\n  cin>>s>>m; n=s.size();\n  for(int i=0;i<n/2;i++){\n    c[i+1]=s[n-1-i]-s[i];\n  }c[0]=c[n/2+1]=0;\n  for(int i=0;i<n/2+2;i++){\n    d[i]=c[i+1]-c[i];\n    vis[i]=0;\n    //cout<<d[i]<<\" \";\n  }//cout<<endl;\n  for(int i=0;i<m;i++){\n    ll l,r;cin>>l>>r;\n    if(r>n/2+1){\n      r=n+1-r;\n      if(l>n/2+1)l=n+1-l;\n      if(l<=n/2)l--;\n    }//cout<<l<<\" \"<<r<<endl;\n    if(l>r)swap(l,r); l--;\n    if(n%2==1&&r==n/2+1)r--;\n    //cout<<\"#\"<<l<<\" \"<<r<<endl;\n    g[l].push_back(r);\n    g[r].push_back(l);\n  }\n  bool ok=1;\n  for(int i=0;i<n/2+2;i++){\n    if(dfs(i)%26!=0)ok=0;\n  }\n  cout<<(ok?\"YES\":\"NO\")<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nchar S[114514];\nint G[114514];\nint X[114514];\nbool used[114514];\nvector<int> es[114514];\nint M;\n\nint dfs(int v) {\n  if (used[v]) return 0;\n  used[v] = true;\n\n  int sum = X[v]%26;\n  for (int u : es[v]) {\n    if (used[u]) continue;\n    sum += dfs(u);\n    sum %= 26;\n  }\n  return sum;\n}\n\nint ToIdx(int b) {\n  //assert(b >= 1);\n  if (N%2 == 1) {\n    if (b <= N/2) return b;\n    return N-b;\n  } \n\n  if (b <= N/2) return b;\n  return N-b;\n}\n\nint main() {\n  scanf(\"%s\", S);\n  N = strlen(S);\n  scanf(\"%d\", &M);\n  for (int i=0; i<M; i++) {\n    int a;\n    int b;\n    scanf(\"%d%d\", &a, &b);\n    --a;\n    --b;\n    int u = ToIdx(a);\n    int v = ToIdx(b+1);\n    if (u == v) continue;\n    es[u].emplace_back(v);\n    es[v].emplace_back(u);\n  }\n\n  G[0] = S[0]-'a';\n  for (int i=1; i<N; i++) {\n    G[i] = (26+(S[i]-S[i-1])%26)%26;\n    int k = ToIdx(i);\n    X[k] += G[i];\n    X[k] %= 26;\n  }\n\n  /*printf(\"G: \");\n  for (int i=0; i<N; i++) {\n    printf(\"%d \", G[i]);\n  }puts(\"\");\n  printf(\"X: \");\n  for (int i=0; i<N; i++) {\n    printf(\"%d \", X[i]);\n  }puts(\"\");*/\n\n  dfs(0);\n  for (int i=1; i<=N/2; i++) {\n    if (!used[i]) {\n      printf(\"i: %d\\n\", i);\n      int res = dfs(i);\n      printf(\"res: %d\\n\", res);\n      if (res%26) {\n        puts(\"NO\");\n        return 0;\n      }\n    }\n  }\n  puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=100002;\nint n,m,c[N],vis[N],i,k,l,r,sum,ok;\nint h[N],t[N],v[N],a,b;\nchar s[N];\nvoid add(int a,int b){\n\tt[++k]=h[a];\n\th[a]=k;\n\tv[k]=b;\n}\nvoid init(){\n\tscanf(\"%s\",s+1);\n\twhile(s[n+1])n++;\n\tfor(i=1;i<=n+1;i++)\n\t\tc[i]=s[i]-s[i-1];\n\tfor(l=1,r=n+1;l<r;l++,r--){\n\t\tadd(l,r);\n\t\tadd(r,l);\n\t}\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b+1);\n\t\tadd(b+1,a);\n\t}\n}\nvoid dfs(int i){\n\tvis[i]=1;\n\tsum+=c[i];\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(!vis[v[j]])\n\t\t\tdfs(v[j]);\n}\nvoid work(){\n\tdfs(n+1);\n\tok=1;\n\tfor(i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tsum=0;\n\t\t\tdfs(i);\n\t\t\tif(sum%26!=0)\n\t\t\t\tok=0;\n\t\t}\n\tprintf(\"%s\\n\",ok?\"YES\":\"NO\");\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "33:41:08 Running Remaining: 366:18:51\nOverview\nProblem\nStatus\nRank (33:40:59)\n0 Comments\nPrevious12345…Next\nUsername\nThreePointers\nProb\n\tResult \n\tTime\n(ms)\tMem\n(MB)\tLang \n\tSubmit Time\nThreePointers\nI\nWrong Answer\nC++\n1 hr ago\nThreePointers\nI\nWrong Answer\nC++\n1 hr ago\n           \nAll Copyright Reserved © 2010-2019 Xu Han\nServer Time: 2019-07-13 22:46:08 UTC-3\n\n#20418081 | ThreePointers's solution for [Problem I]\nStatus\nWrong Answer\nLength\n2384\nLang\nC++14 (GCC 5.3.0)\nSubmitted\n2019-07-13 21:39:08\nShared\n\n41.0 / 63.0\nSelect Code\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\tini[nuevo.first].insert(nuevo.second);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = ini[i].size();\n\t\tauto it = ini[i].begin();\n\t\tif(sz == 1){\n\t\t\tfin[*it].insert(i);\n\t\t}else if(sz > 1){\n\t\t\tLong ant = i;\n\t\t\twhile(it != ini[i].end()){\n\t\t\t\tfin[*it].insert(ant);\n\t\t\t\tant = *it + 1;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<Long,Long> > rangos;\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = fin[i].size();\n\t\tauto it = fin[i].begin();\n\t\tif(sz == 1){\n\t\t\trangos.push_back({*it,i});\n\t\t}else if(sz > 1){\n\t\t\tLong ant = *it;\n\t\t\twhile(it != fin[i].end()){\n\t\t\t\tit++;\n\t\t\t\tif(it == fin[i].end()){\n\t\t\t\t\trangos.push_back({ant,i});\n\t\t\t\t}else{\n\t\t\t\t\trangos.push_back({ant,*it-1});\n\t\t\t\t\tant = *it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(rangos.begin(),rangos.end());\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int MAXN = 100005;\n\nstruct bitree{\n\tint tree[MAXN];\n\tvoid add(int x, int v){\n\t\twhile(x < MAXN){\n\t\t\ttree[x] += v;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint query(int x){\n\t\tint ret = 0;\n\t\twhile(x){\n\t\t\tret += tree[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nstruct seg{\n\tbitree bit;\n\tvoid add(int s, int e, int x){\n\t\tbit.add(s, x);\n\t\tbit.add(e + 1, (26 - x) % 26);\n\t}\n\tint query(int x){\n\t\treturn bit.query(x);\n\t}\n}seg;\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nstring s;\nint q;\nvector<int> pos[MAXN];\nint nxt[MAXN], dx[MAXN];\n\nint main(){\n\tcin >> s >> q;\n\tint n = s.size();\n\tint h = n / 2;\n\tdisj.init(h);\n\tfor(int i=0; i<q; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tif(s + e > n) tie(s, e) = pi(n+1-e, n+1-s);\n\t\tif(e > n - e) e = n - e;\n\t\tdisj.uni(s - 1, e);\n\t}\n\tfor(int i=0; i<=h; i++){\n\t\tpos[disj.find(i)].push_back(i);\n\t}\n\tmemset(nxt, -1, sizeof(nxt));\n\tfor(int i=0; i<=h; i++){\n\t\tif(pos[i].size() > 1){\n\t\t\tfor(int j=1; j<pos[i].size(); j++){\n\t\t\t\tnxt[pos[i][j-1] + 1] = pos[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<h; i++){\n\t\tdx[i+1] = s[i] - s[n-1-i];\n\t\tdx[i+1] += 26;\n\t\tdx[i+1] %= 26;\n\t\tseg.add(i+1, i+1, dx[i+1]);\n\t}\n\tfor(int i=1; i<=h; i++){\n\t\tif(nxt[i] != -1){\n\t\t\tseg.add(i, nxt[i], 26 - seg.query(i) % 26);\n\t\t}\n\t\tint q = seg.query(i) % 26;\n\t\tif(q){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"YES\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b>>1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n\nvector<vector<ll>> g;\n\nvector<ll> see;\n\nbool nibu(ll u) {\n\t\n\tbool ret = 1;\n\n\tfor (ll v : g[u]) {\n\t\tif (see[v] != -1) {\n\t\t\tif (see[v] == see[u]) { ret = 0; }\n\t\t}\n\t\telse {\n\t\t\tsee[v] = (see[u] + 1) % 2;\n\t\t\tret = nibu(v);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nll wa(ll u,vector<ll> &b) {\n\tll ret = b[u];\n\tsee[u] = 2;\n\n\tfor (ll v : g[u]) {\n\t\tif (see[v] == 2) { continue; }\n\t\tret += wa(v,b);\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tll T = S.size();\n\t\n\tll M = T / 2 + 1;\n\tvector<ll> a(M + 1, 0);\n\trepn(i, M - 1) {\n\t\ta[i] = (ll)S[T - i] - (ll)S[i - 1];\n\t\tif (a[i] < 0) { a[i] += 26; }\n\t}\n\n\tvector<ll> b(M + 1, 0);\n\trepn(i, M)b[i] = a[i] - a[i - 1];\n\n\t//repn(i, M)cout << b[i] << \" \";\n\t//cout << endl;\n\n\tg.resize(M + 1);\n\tll N;\n\tcin >> N;\n\n\trepn(i, N) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\n\t\tif (l + r == T + 1) { continue; }\n\n\t\tif (r <= T / 2) { r++; }\n\t\telse if (l + r < T + 1) { r = T - r + 1; }\n\t\telse if (l <= T / 2) { r = T - r + 1; swap(l, r); }\n\t\telse { l = T - l + 1 + 1; r = T - r + 1; swap(l, r); }\n\n\t\tif (l > M) { l--; }\n\t\tif (r > M) { r--; }\n\n\t\tg[l].push_back(r);\n\t\tg[r].push_back(l);\n\n\t\t//cout << l << \" \" << r << endl;\n\t}\n\n\tsee.assign(M + 1, -1);\n\n\tstring ans = \"YES\";\n\n\trepn(u, M) {\n\t\tif (see[u] != -1) { continue; }\n\t\tsee[u] = 0;\n\n\t\tbool nb = nibu(u);\n\t\tll ss = wa(u, b);\n\t\tif (ss%26 != 0) { ans = \"NO\"; }\n\n\t\t//cout << u << \" \" << nb << \" \" << ss << endl;\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SZ = 3e5, INF = 1e9 * 1e9 + 10;\n\nll add[SZ];\n\nset<ll> st[SZ];\nvector<pair<ll, ll>> segs, err, inp;\n\nvoid debug() {\n\tcout << \"------------------\\n\";\n\tll i = 0;\n\tfor (auto cur : err) {\n\t\tcout << inp[i].first << \" \" << inp[i].second << \" - \" << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t\ti++;\n\t}\n}\nint main()\n{\n\tfastInp;\n\n\tstring s;\n\tcin >> s;\n\n\tif (s.size() == 1) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < s.size(); i++) {\n\t\ts[i] = (s[i] - s[s.size() - i - 1] + 26) % 26 + 'a';\n\t}\n\n\tll q;\n\tcin >> q;\n\n\tbool fl = (s.size() % 2);\n\tif (s.size() % 2 == 1) s.erase(s.begin() + s.size() / 2);\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tinp.push_back({ l, r });\n\t\tl--; r--;\n\t\tint m = s.size() / 2;\n\t\tif (l == m && r == m) continue;\n\n\t\tif (fl) {\n\t\t\tint m = s.size() / 2;\n\t\t\tif (r >= m) r--;\n\t\t\tif (l >= m) l--;\n\t\t}\n\n\t\tif (l == s.size() - r - 1) {\n\t\t\terr.push_back({ -1, -1 });\n\t\t\tcontinue;\n\t\t}\n\t\tm = s.size() / 2;\n\t\tif (l >= m) {\n\t\t\tsegs.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\terr.push_back({ s.size() - r - 1, s.size() - l - 1 });\n\t\t\tcontinue;\n\t\t}\n\t\telse if (r >= m) {\n\t\t\tr = s.size() - r - 1;\n\t\t\tif (r < l) {\n\t\t\t\tswap(l, r);\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l < 0) {\n\t\t\t\terr.push_back({ -1, -1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs.push_back({ l, r });\n\t\t\t\terr.push_back({ l, r });\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsegs.push_back({ l, r });\n\t\terr.push_back({ l, r });\n\t}\n\n\tfor (auto cur : segs) {\n\t\tst[cur.first].insert(cur.second);\n\t}\n\tll m = s.size() / 2, cur = 0;\n\n\t//debug();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcur += add[i];\n\t\tif (cur < 26) cur += 26;\n\t\tcur %= 26;\n\t\ts[i] = (s[i] - 'a' + cur) % 26 + 'a';\n\t\tif (s[i] > 'a') {\n\t\t\tcur += 'z' - s[i] + 1;\n\t\t\t\n\t\t\tif (st[i].size() == 0) {\n\t\t\t\tcout << \"NO\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadd[(*st[i].begin()) + 1] -= ('z' - s[i] + 1);\n\n\t\t\ts[i] += cur;\n\t\t}\n\n\t\tif (st[i].size() == 0) continue;\n\t\tll last = *(st[i].begin());\n\t\tst[i].erase(st[i].begin());\n\n\t\twhile (!st[i].empty()) {\n\t\t\tst[last].insert(*st[i].begin());\n\t\t\tlast = *st[i].begin();\n\t\t\tst[i].erase(st[i].begin());\n\t\t}\n\t}\n\n\tcout << 2 / 0;\n\n\treturn 0;\n}\n\n/*\naaaaaaaaa\n10\n3 6\n4 8\n5 5\n1 3\n1 5\n5 7\n2 6\n2 8\n3 9\n1 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint need[MAX];\nbool visited[MAX];\npair<int,int> edge[MAX];\n\nvoid DFS(int u,int p,int e){\n    visited[u]=1;\n    for(auto to:G[u]){\n        if(visited[to.fi]) continue;\n        DFS(to.fi,u,to.se);\n    }\n    \n    if(need[u]){\n        if(e==-1) return;\n        else{\n            int a=edge[e].fi,b=edge[e].se,c=need[u];\n            if(a==u){\n                need[a]-=c;\n                need[b]-=(26-c);\n            }else{\n                need[a]-=(26-c);\n                need[b]-=c;\n            }\n            if(need[a]<0) need[a]+=26;\n            if(need[b]<0) need[b]+=26;\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string S;cin>>S;\n    int N,M;cin>>M;\n    N=si(S);\n    vector<pair<int,int>> T;\n    for(int i=0;i<M;i++){\n        int a,b;cin>>a>>b;\n        if(a+b==N+1) continue;\n        if(a>(N+1)/2){\n            chmin(a,N+1-a);\n            chmin(b,N+1-b);\n            swap(a,b);\n        }else if(b>(N+1)/2){\n            chmin(b,N+1-b);\n            if(a>b) swap(a,b);\n            b--;\n        }else if((N&1)&&b==(N+1)/2) b--;\n        a--;\n        G[a].push_back(mp(b,i));\n        G[b].push_back(mp(a,i));\n        \n        edge[i]=mp(a,b);\n    }\n    \n    for(int i=0;i<N/2;i++){\n        int diff=S[i]-S[N-1-i];\n        if(diff<0) diff+=26;\n        need[i]=diff;\n    }\n    \n    for(int i=N/2;i>=1;i--){\n        need[i]=(26+need[i]-need[i-1])%26;\n    }\n    \n    for(int i=0;i<=N/2;i++){\n        if(!visited[i]) DFS(i,-1,-1);\n    }\n    \n    bool ok=true;\n    for(int i=0;i<=N/2;i++){\n        if(need[i]) ok=false;\n    }\n    \n    if(ok) cout<<\"YES\\n\";\n    else cout<<\"NO\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nchar s[N];\nint n, l[N], r[N], a[N], f[N], k[N];\nint sf(int x) { return x == f[x] ? x : f[x] = sf(f[x]); }\nint main() {\n    scanf(\"%s%d\", s + 1, &n);\n    int m = strlen(s + 1);\n    for (int i = 1; i <= m + 1; i++) {\n        a[i] = s[i] - s[i - 1], f[i] = i;\n    }\n    for (int i = 1; i <= m + 1; i++) {\n        f[sf(i)] = sf(m + 2 - i);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        f[sf(l[i])] = sf(r[i] + 1);\n    }\n    for (int i = 1; i <= m + 1; i++) {\n        k[sf(i)] = (k[sf(i)] + a[i] % 26 + 26) % 26;\n    }\n    bool ok = true;\n    for (int i = 1; i <= m + 1; i++) {\n        if (k[sf(i)]) {\n            ok = false;\n            break;\n        }\n    }\n    puts(ok ? \"YES\" : \"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<pair<int,int> > v;\nset<pair<string,int> >s;\nset<pair<string,int> >:: iterator it;\n\nint bykchange,dapet=0;\n\nint palin(char soal[100500]){\n    int len;\n    len=strlen(soal);\n    char revsoal[100500];\n    strcpy(revsoal,soal);\n    reverse(revsoal,revsoal+len);\n//    printf(\"%s %s\\n\",soal,revsoal);\n    if(strcmp(soal,revsoal)==0)return 1;\n    return 0;\n}\n\nint backtrack(char soal[100500]){\n        for(int i=0;i<bykchange;i++){\n            int start,fin;\n            start=v[i].first;\n            fin=v[i].second;\n            for(int j=start-1;j<=fin-1;j++){\n                if(soal[j]=='z')soal[j]='a';\n                else soal[j]++;\n            }\n            int cek;\n            it=s.find(pair<string,int>(soal,i));\n            if(it!=s.end())return 0;\n            else s.insert(pair<string,int>(soal,i));\n            cek=palin(soal);\n            if(cek==1){\n                dapet++;\n                return 1;\n            }\n\n            if(backtrack(soal)==1){\n                dapet++;\n                return 1;\n            }\n\n            if(dapet==1)return 1;\n            for(int j=start-1;j<=fin-1;j++){\n                if(soal[j]=='a')soal[j]='z';\n                else soal[j]--;\n            }\n//            printf(\"\\n\\n\\n\");\n        }\n        return 0;\n}\n\n\nint main(){\n    char soal[100500];\n    scanf(\"%s\",soal);\n    scanf(\"%d\",&bykchange);\n    for(int i=0;i<bykchange;i++){\n        int t1,t2;\n        scanf(\"%d %d\",&t1,&t2);\n        v.push_back(make_pair(t1,t2));\n    }\n    if(palin(soal)==1)printf(\"YES\\n\");\n    else{\n        if(backtrack(soal)==1)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long Long;\n\nconst Long N = 1e5 + 10;\n\nset<Long> ini[N];\nset<Long> fin[N];\n\nLong tree1[N];\nLong tree2[N];\n\nLong query1(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree1[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\nLong query2(Long i){\n\tLong sum=0;\n\twhile(i>0){\n\t\tsum+=tree2[i];\n\t\ti-=(i&-i);\n\t}\n\treturn sum;\n}\n\nvoid update1(Long i, Long val){\n\twhile(i<N){\n\t\ttree1[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\nvoid update2(Long i, Long val){\n\twhile(i<N){\n\t\ttree2[i]+=val;\n\t\ti+=(i&-i);\n\t}\n\treturn;\n}\n\nLong query(Long x){\n\treturn query1(x)*x-query2(x);\n}\n\nvoid update(Long i, Long j, Long v){\n\tupdate1(i,v);\n\tupdate1(j+1,-v);\n\tupdate2(i,v*(i-1));\n\tupdate2(j+1,-j*v);\n\treturn;\n}\n\npair<Long,Long> cambia(Long l, Long r, Long n){\n\tpair<Long, Long> a,b;\n\ta = {l,r};\n\tb = {n-r-1,n-l-1};\n\ta = min(a,b);\n\tif(a.second >= n/2){\n\t\tLong aux = min(n/2 - 1,n-a.second-2);\n\t\ta = {a.first,aux};\n\t}\n\treturn a;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcout.precision(10);\n\tcout << fixed;\n\t\n\tLong m, l, r, n;\n\tstring cad;\n\tcin >> cad >> m;\n\tn = cad.size();\n\tfor(Long i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tr--;\n\t\tif(l+r == n-1) continue;\n\t\tpair<Long,Long> nuevo = cambia(l,r,n);\n\t\tini[nuevo.first].insert(nuevo.second);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = ini[i].size();\n\t\tauto it = ini[i].begin();\n\t\tif(sz == 1){\n\t\t\tfin[*it].insert(i);\n\t\t}else if(sz > 1){\n\t\t\tLong ant = i;\n\t\t\twhile(it != ini[i].end()){\n\t\t\t\tfin[*it].insert(ant);\n\t\t\t\tant = *it + 1;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<Long,Long> > rangos;\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong sz = fin[i].size();\n\t\tauto it = fin[i].begin();\n\t\tif(sz == 1){\n\t\t\trangos.push_back({*it,i});\n\t\t}else if(sz > 1){\n\t\t\tLong ant = *it;\n\t\t\twhile(it != fin[i].end()){\n\t\t\t\tit++;\n\t\t\t\tif(it == fin[i].end()){\n\t\t\t\t\trangos.push_back({ant,i});\n\t\t\t\t}else{\n\t\t\t\t\trangos.push_back({ant,*it-1});\n\t\t\t\t\tant = *it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nsort(rangos.begin(),rangos.end());\n\tfor(Long i = 0; i < rangos.size(); i++){\n\t\tl = rangos[i].first + 1;\n\t\tr = rangos[i].second + 1;\n\t\tLong auxi = (cad[n-l] - 'a') - (query(l) - query(l-1) + (cad[l-1] - 'a'));\n\t\tauxi %= 26;\n\t\tauxi += 26;\n\t\tauxi %= 26;\n\t\tupdate(l,r,auxi);\n\t}\n\t\n\tfor(Long i = 0; i < n/2; i++){\n\t\tLong aux = query(i+1) - query(i);\n\t\tif(((cad[i] - 'a') + aux)%26 != (cad[n-i-1] - 'a')){\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"YES\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s; cin >> s;\n    int m = s.size();\n    int n; cin >> n;\n    vector<int> l(n), r(n);\n    vector<vector<int>> sg(m);\n    for (int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n        --l[i], --r[i];\n        if (m % 2 == 0) {\n            if (l[i] < m / 2 && r[i] >= m / 2) {\n                int g = min(m / 2 - l[i], r[i] - m / 2 + 1);\n                int tl = m / 2 - g, tr = m / 2 + g - 1;\n                if (tl == l[i] && tr == r[i]) continue;\n                if (tl == l[i]) l[i] = tr + 1;\n                else r[i] = tl - 1;\n            }\n        } else {\n            if (l[i] <= m / 2 && r[i] >= m / 2) {\n                int g = min(m / 2 - l[i], r[i] - m / 2);\n                int tl = m / 2 - g, tr = m / 2 + g;\n                if (tl == l[i] && tr == r[i]) continue;\n                if (tl == l[i]) l[i] = tr + 1;\n                else r[i] = tl - 1;\n            }\n        }\n        // printf(\"l = %d r = %d\\n\", l[i], r[i]);\n        if (r[i] < m / 2) sg[l[i]].push_back(r[i]);\n        else sg[m - 1 - r[i]].push_back(m - 1 - l[i]);\n    }\n    for (int i = 0; i < m / 2; ++i) {\n        if (sg[i].empty()) continue;\n        sort(sg[i].begin(), sg[i].end());\n        sg[i].resize(unique(sg[i].begin(), sg[i].end()) - sg[i].begin());\n        for (int j = 0; j + 1 < sg[i].size(); ++j) sg[sg[i][j] + 1].push_back(sg[i][j + 1]);\n        sg[i].resize(1);\n    }\n    vector<int> t(m + 1);\n    int sum = 0;\n    for (int i = 0; i < m / 2; ++i) {\n        sum += t[i];\n        int ch = ((((s[i] - 'a') + sum) % 26) + 26) % 26;\n        int diff = ((s[m - 1 - i] - 'a') - ch + 26) % 26;\n        // printf(\"i = %d diff = %d\\n\", i, diff);\n        if (diff != 0 && sg[i].empty()) {\n            puts(\"NO\");\n            return 0;\n        }\n        if (diff != 0) {\n            sum += diff;\n            t[sg[i][0] + 1] += 26 - diff;\n        }\n    }\n    puts(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <math.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <string.h>\n#include <bitset>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\nconst int N = 1e6+10;\nint n, m, sum, c[N], vis[N];\nchar s[N];\nvector<int> g[N];\nvoid add(int x, int y) {\n\tg[x].pb(y),g[y].pb(x);\n}\nvoid dfs(int x) {\n\tif (vis[x]) return;\n\tvis[x] = 1;\n\tsum = (sum+c[x])%26;\n\tfor (int y:g[x]) dfs(y);\n}\nint main() {\n\tcin>>s+1;\n\tm = strlen(s+1);\n\tREP(i,1,m+1) { \n\t\tc[i]=(s[i]-s[i-1])%26;\n\t\tadd(i,m+2-i);\n\t}\n\tcin>>n;\n\twhile (n--) {\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tadd(l,r+1);\n\t}\n\tREP(i,1,m+1) {\n\t\tsum = 0;\n\t\tdfs(i);\n\t\tif (sum) return puts(\"NO\"),0;\n\t}\n\tputs(\"YES\");\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#define db double\n#define LL long long\n#define inf 0x3f3f3f3f\n#define N 100005\nusing namespace std;\nint gi()\n{\n    int res=0,s=1; char ch;\n    for(ch=getchar();(ch<'0'||ch>'9')&&ch!='-';ch=getchar());\n    if(ch=='-') s=-1,ch=getchar();\n    for(;ch>='0'&&ch<='9';ch=getchar()) res=res*10+ch-48;\n    return res*s;\n}\nint n,key[N],fa[N],sum[N],flag;\nchar s[N];\nint findfa(int x) {return fa[x]==x?x:fa[x]=findfa(fa[x]);}\nint main()\n{\n    scanf(\"%s\",s+1); n=strlen(s+1);\n    if(n&1) flag=1,n--;\n    for(int i=1;i<=n/2;++i) \n\tkey[i]=s[flag?(n+2-i):(n+1-i)]-s[i],fa[i]=i;\n    fa[n/2+1]=n/2+1,key[n/2+1]=0;\n    for(int i=n/2;i;--i) key[i]-=key[i-1];\n    for(int T=gi(),le,ri;T;--T) {\n\tle=gi(),ri=gi();\n\tif(flag) {\n\t    if(le>n/2+1) le--;\n\t    if(ri>n/2) ri--;\n\t}\n\tif(le>ri) continue;\n\tif(le<=n/2 && ri>n/2) {\n\t    if(n/2+1-le >= ri-n/2) ri=n-ri;\n\t    else le=n+2-le;\n\t}\n\tif(le>ri) continue;\n\tif(le>n/2)\n\t    le=n+1-le,ri=n+1-ri,swap(le,ri);\n\tri++;\n\tif(findfa(le)!=findfa(ri)) fa[fa[le]]=fa[ri];\n    }\n    findfa(n/2+1);\n    for(int i=1;i<=n/2;++i) sum[findfa(i)]+=key[i];\n    for(int i=1;i<=n/2;++i) {\n\tif(fa[i]==fa[n/2+1]) continue;\n\tif(sum[fa[i]]%26) {puts(\"NO\"); return 0;}\n    }\n    puts(\"YES\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\nstruct UnionFind{\n\tvector<int> par,rank,sum;\n\tUnionFind(int N){\n\t\tpar.assign(N,0);\n\t\trank.assign(N,0);\n\t\tsum.assign(N,0);\n\t\trep(i,N) par[i]=i;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n\t\tif(y==(int)par.size()) y--;\n//\t\tprintf(\"unite %d,%d,\\n\",x,y);\n\t\tx=find(x),y=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x]=y;\n\t\t\tsum[y] += sum[x];\n\t\t}else{\n\t\t\tpar[y]=x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n};\n\n\nstring s;\nint N,M;\nint a[100010];\n\nint main(){\n\tcin>>s;\n\tN = s.size();\n\tbool inc = 0;\n\tif(N%2==0){\n\t\tstring ns = s.substr(0,N/2) + \"a\" + s.substr(N/2,N/2);\n\t\ts = ns;\n\t\tN++;\n\t\tinc = 1;\n\t}\n\trep(i,N) a[i+1] = s[i]-'a';\n\n\tUnionFind UF(N/2+1);\n\trep(i,N/2+1){\n\t\tUF.sum[i] += a[i+1]-a[i];\n\t\tUF.sum[i] += a[N+1-i]-a[N-i];\n\t}\n\tcin>>M;\n\tint mid = N/2+1;\n\trep(i,M){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tif(inc && l>N/2) l++;\n\t\tif(inc && r>N/2) r++;\n\t\tif(r<=mid){\n\t\t\tUF.unite(l-1,r);\n\t\t}else if(l>=mid){\n\t\t\tswap(l,r);\n\t\t\tl = N+1-l;\n\t\t\tr = N+1-r;\n\t\t\tUF.unite(l-1,r);\n\t\t}else if(mid-l<=r-mid){\n\t\t\tl = N+2-l;\n\t\t\tif(l>r) continue;\n\t\t\tswap(l,r);\n\t\t\tl = N+1-l;\n\t\t\tr = N+1-r;\n\t\t\tUF.unite(l-1,r);\n\t\t}else{\n\t\t\tr = N-r;\n\t\t\tUF.unite(l-1,r);\n\t\t}\n\t}\n\tbool ok = 1;\n\trep(i,N/2+1){\n\t\tif(UF.find(i)==i){\n\t\t\tif(UF.sum[i]%26!=0) ok = 0;\n\t\t}\n\t}\n\tif(ok) puts(\"YES\");\n\telse puts(\"NO\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tint par[100100];\n\tvoid init(int N){\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y) par[x] = y;\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nUnionFind uf;\n\nstring ini;\n\n//char S[100100], T[100100];\nint target[100100];\nint dif[100100];\n\nint L[100100];\nint R[100100];\nint N;\nint M;\n\nint flip(int x){\n\treturn min(x, (int)ini.size() + 1 - x);\n}\n\nvector<int> comps[26];\n\nchar ch[100100];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tini = ch;\n\tscanf(\"%d\", &M);\n\tint k = ini.size() / 2;\n\tif(ini.size() % 2 == 1){\n\t\tstring str = ini.substr(0, k) + ini.substr(k + 1, 100100);\n\t\tini = str;\n\t}\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\tif(R[i] >= k + 1) R[i]--;\n\t\tif(L[i] >= k + 1) L[i]--;\n\t\tif(L[i] == k + 1 && R[i] == k + 1){\n\t\t\tL[i] = 1;\n\t\t\tR[i] = str.size();\n\t\t}\n\t}\n\tN = ini.size();\n}\n\nint sum[100100];\n\npair<int, int> change(int l, int r){\n\tint k = (N + 1) / 2;\n\tbool odd = (N % 2 == 1);\n\tif(odd && l == k && r == k) return make_pair(-1, 0);\n\tif(r <= k){\n\t\tif(odd && (r == k)) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse if(l <= k){\n\t\tint x = k - l + 1;\n\t\tint y = r - k;\n\t\tint mi = min(x, y);\n\t\tint ma = max(x, y);\n\t\tint l = k - ma + 1;\n\t\tint r = k - mi ;\n\t\t//printf(\"%d %d %d %d\\n\", mi, ma, l ,r);\n\t\tif(odd && r == k) r--;\n\t\treturn make_pair(l, r);\n\t}\n\telse{\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tswap(l, r);\n\t\treturn make_pair(l, r);\n\t}\n}\n\nbool solve(){\n\tuf.init(N);\n//\tif(N % 2 == 1) assert(0);\n\tfor(int i = 0; i < M; ++i){\n\t\tpair<int, int> tmp = change(L[i], R[i]);\n\t\tint l = tmp.first, r = tmp.second;\n\t\tif(l > r) continue;\n\t\t//printf(\"%d %d\\n\", l - 1, r);\n\t\tif(l == -1) continue;\n\t\tuf.unite(l - 1, r);\n//\t\tprintf(\"%d %d\\n\", l - 1, r);\n/*\t\tint l = L[i], r = R[i];\n\t\tl--; r--;\n\t\tl = flip(l);\n\t\tr = flip(r);\n\t\tif(l > r) swap(l, r);\n\t\tl++; r++;\n\t\tif(N + 1 == r * 2) r--;*/\n//\t\tprintf(\"%d %d\\n\", l, r);\n\t//\tprintf(\"uf %d %d\\n\", l, r);\n//\t\tuf.unite(l - 1, r);\n\t//\tprintf(\"%d %d\\n\", l - 1, r);\n\t}\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d \", uf.find(i));\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);*/\n\tfor(int i = 0; i <= N; ++i){\n\t\ttarget[i] = -1;\n\t\tdif[i] = -1;\n\t}\n\ttarget[0] = 0;\n\tfor(int i = 1; i < N + 1 - i; ++i){\n\t\ttarget[i] = (int)ini[N + 1 - i - 1] - ini[i - 1];\n\t\tif(target[i] < 0) target[i] += 26;\n\t//\tprintf(\"%d %d\\n\", target[i], i);\n\t}/*\n\tfor(int i = 0; i + 1 <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tdif[i] = target[i + 1] - target[i];\n\t\twhile(dif[i] < 0) dif[i] += 26;\n\t\twhile(dif[i] >= 26) dif[i] -= 26;\n\t}\n\tfor(int i = 0; i <= N; ++i) printf(\"%d %d d\\n\", dif[i], i);\n\tprintf(\"\\n\");*/\n\t/*for(int i = 0; i <= N; ++i){\n\t\tif(dif[i] == -1) continue;\n\t\tcomps[dif[i]].push_back(uf.find(i));\n\t}\n\tfor(int i = 0; i < 26; ++i){\n\t\tsort(comps[i].begin(), comps[i].end());\n\t\tif(comps[i].size() == 0) continue;\n\t\tif(comps[i][0] != comps[i][comps[i].size() - 1]) return false;\n\t}\n\treturn true;*/\n\t/*\n\tfor(int i = 0; i <= N; ++i){\n\t\tif(target[i + 1] == -1) break;\n\t\tif(target[i + 1] != target[i]){\n\t\t\tprintf(\"check %d %d\\n\", i,i + 1);\n\t\t\tif(uf.same(i, i + 1)){\n\t\t\t\t//ok\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;*/\n\tint k = (N + 1) / 2;\n\ttarget[k + 1] = 0;\n\tint m = k;\n\tif(N % 2 == 1) m--;\n\tfor(int i = 0; i <= m; ++i){\n\t\tsum[uf.find(i)] += (target[i + 1] - target[i]);\n\t}\n\tfor(int i = 0; i < 100100; ++i){\n\t\tif(sum[i] % 26 != 0){\n\t\t\tif((N % 2 == 1)){\n\t\t\t\tif(uf.find(k - 1) == i) continue;\n\t\t\t}\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool ans = solve();\n\tif(ans) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring S; int Q, l[100009], r[100009], a[100009], b[100009], col[100009], cntw; bool used[100009], flag;\nvector<pair<int, int>>D; vector<int>X[100009], V[100009];\n\nint dfs(int pos) {\n\tint sum = 0; used[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tsum += dfs(X[pos][i]); sum %= 26;\n\t}\n\treturn (sum - b[pos] + 26) % 26;\n}\nvoid dfs2(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cntw; V[cntw].push_back(pos);\n\tfor (int i = 0; i < X[pos].size(); i++) dfs2(X[pos][i]);\n}\n\nint main() {\n\tcin >> S;\n\tfor (int i = 0; i < S.size() / 2; i++) { a[i + 1] = (S[i] - S[S.size() - i - 1]); if (a[i + 1] < 0)a[i + 1] += 26; }\n\tfor (int i = 0; i < (S.size() / 2) + 1; i++) { b[i] = (a[i + 1] - a[i] + 26) % 26; }\n\tcin >> Q;\n\tfor (int i = 1; i <= Q; i++) {\n\t\tcin >> l[i] >> r[i]; l[i]--; r[i]--;\n\t\tif (l[i] + r[i] == S.size() - 1) continue;\n\t\tif (l[i] + r[i] >= S.size() - 1) {\n\t\t\tl[i] = S.size() - 1 - l[i];\n\t\t\tr[i] = S.size() - 1 - r[i];\n\t\t\tswap(l[i], r[i]);\n\t\t}\n\t\tint P1 = l[i], P2 = r[i];\n\t\tif (r[i] >= S.size() / 2) P2 = S.size() - 2 - r[i];\n\t\tD.push_back(make_pair(P1 + 1, P2 + 1));\n\t}\n\tfor (int i = 0; i < D.size(); i++) {\n\t\tX[D[i].first - 1].push_back(D[i].second);\n\t\tX[D[i].second].push_back(D[i].first - 1);\n\t}\n\tfor (int i = 0; i < (S.size() / 2) + 1; i++) {\n\t\tif (col[i] >= 1) continue;\n\t\tcntw++; dfs2(i);\n\t}\n\tfor (int i = 1; i <= cntw; i++) {\n\t\tint U = dfs(V[i][0]);\n\t\tif (U != 0) flag = true;\n\t}\n\tif (flag == true) cout << \"NO\" << endl;\n\telse cout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nconst int N=1e5+10;\nchar s[N];\nint n,f[N],a[N],sum[N];\nint find(int x){\n\treturn x==f[x]?x:f[x]=find(f[x]);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&n);\n\tint m=strlen(s+1);\n\tfor(int i=1;i<=m+1;i++){\n\t\ta[i]=s[i]-s[i-1];\n\t\tf[i]=i;\n\t}\n\tfor(int i=1;i<=m+1;i++)\n\t\tf[find(i)]=find(m+1-i+1);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tf[find(l)]=find(r+1);\n\t}\n\tfor(int i=1;i<=m+1;i++)\n\t\tsum[find(i)]=(sum[find(i)]+a[i]%26+26)%26;\n\t\n\tint flag=1;\n\tfor(int i=1;i<=m+1&&flag;i++){\n\t\tif(sum[find(i)])flag=0;\n\t}\n\t\t\n\tif(flag)printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring S;\nint add[100010];\nvector<P> vec[50002];\nbool solve(int k,int a,int b){\n\t//cout << k << \" \" << a << \" \" << b << endl;\n\ta += add[k]%26;\n\tb += add[S.size()-1-k]%26;\n\tint A = a+(S[k]-'a'); A %= 26; S[k] = 'a'+A;\n\tint B = b+(S[S.size()-1-k]-'a'); B %= 26; S[S.size()-1-k] = 'a'+B;\n\t//S[k] += a;\n\t//S[S.size()-1-k] += b;\n\tif(S.size()-1-k <= k)return true;\n\tif(vec[k].size() == 0){\n\t\tif(S[k] != S[S.size()-1-k]){\n\t\t\treturn false;\n\t\t}\n\t\treturn solve(k+1,a,b);\n\t}\n\tif(vec[k][0].fr == k){\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].sc);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.fr ++;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].sc,vec[k][i].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26-S[k]+S[S.size()-1-k]; d%=26;\n\t\ta += d;\n\t\tif(vec[k][0].sc < S.size()/2){\n\t\t\tif(vec[k][0].sc+1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].sc+1] += (26-d)%26;\n\t\t\t}\n\t\t}\n\t\telse add[vec[k][0].sc] +=d ;\n\t}\n\telse {\n\t\tfor(int i = 1 ; i < vec[k].size() ; i ++){\n\t\t\tif(vec[k][i].fr == k){\n\t\t\t\tP p = P(vec[k][i].sc,vec[k][0].fr);\n\t\t\t\tif(p.fr < p.sc){\n\t\t\t\t\tp.fr ++;\n\t\t\t\t\tp.sc --;\n\t\t\t\t\tif(p.fr > p.sc)continue;\n\t\t\t\t}\n\t\t\t\telse swap(p.fr,p.sc);\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP p = P(vec[k][0].fr,vec[k][i].fr);\n\t\t\t\tif(p.sc == p.fr)continue;\n\t\t\t\tif(p.sc < p.fr)swap(p.fr,p.sc);\n\t\t\t\tp.sc --;\n\t\t\t\tvec[min(p.fr,(int)(S.size())-1-p.sc)].pb(p);\n\t\t\t}\n\t\t}\n\t\tint d = 26+S[k]-S[S.size()-1-k]; d%=26;\n\t\tb += d;\n\t\tif(vec[k][0].fr < S.size()/2)add[vec[k][0].fr] += d;\n\t\telse{\n\t\t\tif(vec[k][0].fr-1 < S.size()/2){\n\t\t\t\tadd[vec[k][0].fr-1] += 26-d ;\n\t\t\t}\n\t\t}\n\t}\n\treturn solve(k+1,a,b);\n}\n\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tcin >> S;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i] --;\n\t\tr[i] --;\n\t\tif(l[i] > r[i])swap(l[i],r[i]);\n\t\tvec[min(l[i],(int)(S.size())-1-r[i])].pb(P(l[i],r[i]));\n\t}\n\tif(solve(0,0,0))puts(\"YES\");\n\telse puts(\"NO\");\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    vector<set<int> > st;\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n        st.resize(node_size);\n        rep(i,node_size){\n            st[i].insert(i);\n        }\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n        for(auto p:st[y]){\n            st[x].insert(p);\n        }\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n==1){\n        cout <<\"YES\" << endl;\n        return 0;\n    }\n    vector<int> a(n/2);\n    rep(i,n/2){\n        a[i] = (26+s[n-1-i]-s[i])%26;\n    }\n    // rep(i,n/2)cerr << a[i] << \" \";\n    // cerr << endl;\n    int m;\n    cin >> m;\n    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > p;\n    rep(i,m){\n        int l,r;\n        cin >> l >> r;\n        l--;r--;\n        if(n%2==1){\n            if(l==n/2&&r==n/2)continue;\n            if(l==n/2)l++;\n            if(r==n/2)r--;\n        }\n        if(l==r){\n            if(l>=n/2){\n                l = n-1-l;\n                p.push(MP(l,l));\n            }else{\n                p.push(MP(l,l));\n            }\n        }else{\n            if(l<n/2&&r<n/2){\n                p.push(MP(l,r));\n            }else if(l<n/2){\n                r = n-1-r;\n                if(l<r){\n                    p.push(MP(l,r-1));\n                }else if(l>r){\n                    p.push(MP(r,l-1));\n                }\n            }else if(r>=n/2){\n                l = n-1-l;\n                r = n-1-r;\n                p.push(MP(min(l,r),max(l,r)));\n            }\n        }\n    }\n    UnionFind uf(n/2+1);\n    vector<int> nxt(n/2,-1);\n    while(!p.empty()){\n        auto x = p.top();\n        p.pop();\n        int a = x.first;\n        int b = x.second;\n        if(nxt[a]==-1){\n            nxt[a] = b;\n            uf.unite(a,b+1);\n        }else{\n            if(nxt[a]>b){\n                int x = nxt[a];\n                nxt[a] = b;\n                uf.unite(a,b+1);\n                if(uf.same(b+1,x+1))continue;\n                if(nxt[b+1]==-1){\n                    nxt[b+1] = x;\n                    uf.unite(b+1,x);\n                }else{\n                    auto zz = (uf.st[uf.find(b+1)].upper_bound(x));\n                    zz--;\n                    int k = *zz;\n                    nxt[x] = nxt[k];\n                    nxt[k] = x-1;\n                    uf.unite(b+1,x);\n                }\n            }else if(nxt[a]<b){\n                if(nxt[nxt[a]+1]==-1){\n                    nxt[nxt[a]+1] = b;\n                    uf.unite(nxt[a]+1,b);\n                }else{\n                    int x = b;\n                    auto zz = (uf.st[uf.find(nxt[a]+1)].upper_bound(x));\n                    zz--;\n                    int k = *zz;\n                    nxt[x] = nxt[k];\n                    nxt[k] = x-1;\n                    uf.unite(nxt[a]+1,x);\n                }\n            }\n        }\n    }\n    rep(i,n/2){\n        auto x = uf.st[uf.find(i)].upper_bound(i);\n        if(x==uf.st[uf.find(i)].end()){\n            nxt[i] = -1;\n        }else{\n            int k = *x;\n            nxt[i] = k-1;\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << nxt[i] << endl;\n    // }\n    vector<int> res(n/2);\n    vector<int> ss(n/2+1);\n    int tmp = 0;\n\n    rep(i,n/2){\n        tmp -= ss[i];\n        res[i] += tmp;\n        res[i] %= 26;\n        if(res[i]!=a[i]){\n            if(nxt[i]!=-1){\n                int c = (26+a[i]-res[i])%26;\n                tmp += c;\n                ss[nxt[i]+1] += c;\n                res[i] = a[i];\n            }\n        }\n    }\n    // rep(i,n/2){\n    //     cerr << res[i] << \" \";\n    // }\n    // cerr << endl;\n    rep(i,n/2){\n        if(res[i]!=a[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint n,m,s[N],sum[N],dif[N],flag[N],l,r,mi;\nint get_flag(int pos){\n\treturn flag[pos]==pos?pos:flag[pos]=get_flag(flag[pos]);\n}\nvoid fit(int& x){\n\tif(x>n/2) x=n-x+1;\n}\nint fix(int x){\n\tif(x<0) x=26-(-x)%26;\n\tx%=26;\n\treturn x;\n}\nint main() {\n\tfor(char tmp=getchar();tmp>='a'&&tmp<='z';tmp=getchar())\n\t\ts[++n]=tmp-'a';\n\tfor(int i=1;i<=n/2;++i)\n\t\ts[i]-=s[n-i+1],dif[i]=s[i]-s[i-1],flag[i]=i;\n\tdif[n/2+1]=-s[n/2];\n\tscanf(\"%d\",&m);\n\tmi=n/2+1;\n\tfor(int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(n&1){\n\t\t\tif(l==mi&&r==mi) continue;\n\t\t\tif(l==mi) l++;\n\t\t\tif(r==mi) r--;\n\t\t}\n\t\tif(l<=n/2&&r>n/2){\n\t\t\tfit(r);\n\t\t\tif(l>r) swap(l,r);\n\t\t\tr--;\n\t\t}else{\n\t\t\tfit(l);fit(r);\n\t\t\tif(l>r) swap(l,r);\n\t\t}\n\t\tflag[get_flag(l)]=flag[get_flag(r+1)];\n\t}\n\tfor(int i=1;i<=n/2+1;++i) sum[get_flag(i)]+=dif[i];\n\tfor(int i=1;i<=n/2+1;++i) if(fix(sum[i])!=0)\n\t\treturn 0*puts(\"NO\");\n\tputs(\"YES\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\nconst int N = 1e5;\nint tot[N + 5];\nint par[N + 5];\nint l[N + 5], r[N + 5];\nvector<pair<int,int> > vec[N + 5];\nmap<pair<LL,LL>, int> ms;\n\nint find(int x) {\n\tif(x == -1) return x;\n\tif(x == par[x]) return par[x];\n\treturn par[x] = find(par[x]);\n}\n\n\nstring ns = \"\";\nstring s;\n\nLL fast(LL A,LL B) {\n\tLL res = 1;\n\twhile(B) {\n\t\tif(B & 1) res = res * A;\n\t\tA = A * A;\n\t\tB /= 2;\n\t}\n\treturn res;\n}\n\nvoid hora(int tc) {\n\tcin>>s;\n\tint m;\n\tcin>>m;\n\tint n = s.size();\n\tint mid = n / 2;\n\tfor(int i = 0;i < mid;i++) {\n\t\tint x = s[i] - 'a';\n\t\tint y = s[n - i - 1] - 'a';\n\t\tint diff = (x - y + 26) % 26;\n\t\tns += (diff + 'a');\n\t}\n//\tcout<<ns<<endl;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--, r[i]--;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\tif(r[i] < mid) {\n\t\t\tvec[l[i]].PB({1, i});\n\t\t\tvec[r[i] + 1].PB({-1, i});\n//\t\t\tcout<<\"OP1 \"<<i<<\" \"<<l[i]<<\" \"<<r[i]<<endl;\n\t\t} else if(l[i] > mid) {\n\t\t\tvec[n - r[i] - 1].PB({1, i});\n\t\t\tvec[n - l[i]].PB({-1, i});\n//\t\t\tcout<<\"OP2 \"<<i<<\" \"<<n - r[i] - 1<<\" \"<<n - l[i] - 1<<endl;\n\t\t} else {\n\t\t\tint mini = min(l[i], n - r[i] - 1);\n\t\t\tint maxi = max(l[i], n - r[i] - 1);\n\t\t\tif(mini == maxi) continue;\n\t\t\tvec[mini].PB({1, i});\n\t\t\tvec[maxi].PB({-1, i});\n\t\t}\n\t}\n\tn = mid;\n\tms[{0, 0}] = -1;\n\tLL total = 0;\n\tLL total3 = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\twhile(!vec[i].empty()) {\n\t\t\tint op = vec[i].back().FI;\n\t\t\tint id = vec[i].back().SE;\n\t\t\tLL po2 = fast(2, id);\n\t\t\tLL po3 = fast(3, id);\n\t\t\tvec[i].POB();\n\t\t\tif(op == 1) total += po2, total3 += po3;\n\t\t\telse {\n\t\t\t\ttotal -= po2, total -= po3;\n\t\t\t}\n\t\t}\n\t\tif(ms.find({total, total3}) == ms.end()) ms[{total, total3}] = i;\n\t\tpar[i] = ms[{total, total3}];\n\t}\n\tbool bisa = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(par[i] == -1 && ns[i] != 'a') {\n\t\t\tbisa = false;\n\t\t}\n\t\tif(par[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint x = find(i);\n\t\tif(x != i) {\n\t\t\tif(ns[i] != ns[x]) bisa = false;\n\t\t}\n\t}\n\tif(bisa == false) cout<<\"NO\"<<endl;\n\telse cout<<\"YES\"<<endl;\n}\n\nint main(){\n\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint N, M;\nstring S;\nvector<int> D;\nvector<vector<int> > adj;\nvector<int> vis;\nint sum = 0;\n\nbool dfs(int u) {\n    bool ret = u == 0 || u == N;\n    vis[u] = 1;\n    sum += (u == N - u)? D[u] : D[u] + D[N - u];\n    sum %= 26;\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(vis[v]) continue;\n        ret |= dfs(v);\n    }\n    return ret;\n}\n\nint f(int x) { return min(x, N - x); }\n\nint main() {\n    cin >> S;\n    N = S.size();\n\n    D = vector<int>(N + 1, 0);\n    for(int i = 0; i < N - 1; i++) {\n        D[i + 1] = (S[i] - S[i + 1] + 26) % 26;\n    }\n\n    scanf(\"%d\", &M);\n\n    adj.resize(N + 1);\n    for(int i = 0; i < M; i++) {\n        int l, r; scanf(\"%d %d\", &l, &r);\n        l--; r--;\n\n        adj[ f(l) ].push_back( f(r + 1) );\n        adj[ f(r + 1) ].push_back( f(l) );\n    }\n\n    vis = vector<int>(N + 1, 0);\n    for(int i = 0; i <= N - i; i++) if(!vis[i]) {\n        sum = 0;\n        if(!dfs(i) && sum) {\n            printf(\"NO\");\n            return 0;\n        }\n    }\n    printf(\"YES\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nconst int MX = 100005;\nchar s[MX];\nint n, len, l, r;\nbool used[MX];\nvector<int> G[MX];\nint dfs(int t){\n\tint ret = s[t] - (t ? s[t-1] : 0);\n\tused[t] = true;\n\tfor(int nx: G[t]) if(!used[nx]) ret += dfs(nx);\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\\n%d\", s, &n);\n\tlen = (int)strlen(s);\n\trep(i,n){\n\t\tscanf(\"%d%d\", &l, &r); l--;\n\t\tG[l].push_back(r);\n\t\tG[r].push_back(l);\n\t}\n\trep(i,(len+1)/2){\n\t\tG[i].push_back(len-i);\n\t\tG[len-i].push_back(i);\n\t}\n\tdfs(0);\n\trep(i,len) if(!used[i] && dfs(i) % 26) return 0*puts(\"NO\");\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<int,int> union_tree[200000];\nint union_find(int now) {\n\tif (union_tree[now].first == now) return now;\n\treturn union_tree[now].first = union_find(union_tree[now].first);\n}\nvoid union_merge(int a, int b) {\n\ta = union_find(a);\n\tb = union_find(b);\n\tif (a == b) return;\n\tunion_tree[a].first = b;\n\tunion_tree[b].second += union_tree[a].second;\n\treturn;\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n;\n\tcin >> n;\n\ts = \"a\" + s + \"a\";\n\tfor (int i = 0; i < s.length()-1; ++i) {\n\t\tunion_tree[i] = make_pair(i, 26 + s[i] - s[i + 1]);\n\t}\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tunion_merge(a - 1, b);\n\t}\n\tfor (int i = 0; i < s.length() - 1; ++i) {\n\t\tunion_merge(i, s.length() - 1 - i - 1);\n\t}\n\tREP(i, s.length() - 1) {\n\t\tint hoge = union_find(i);\n\t\tif (union_tree[hoge].second % 26 != 0) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nint main() {\n    string S; cin >> S;\n    int M = S.size();\n    vector<vector<int>> G(M + 1);\n    vector<int> vals(M + 1), visited(M + 1);\n    int Q; cin >> Q;\n    for (int i = 0; i < Q; i++) {\n        int L, R; cin >> L >> R;\n        G[L-1].push_back(R);\n        G[R].push_back(L-1);\n    }\n    for (int i = 0; i < M + 1; i++) {\n        G[i].push_back(M - i);\n    }\n    for (int i = 0; i < M; i++) {\n        vals[i] += S[i] - 'a';\n        vals[i + 1] += 26 - (S[i] - 'a');\n    }\n    for (int i = 0; i < M + 1; i++) {\n        if (visited[i]) continue;\n        int sum = 0;\n        stack<int> S;\n        S.push(i), visited[i] = 1;\n        while (!S.empty()) {\n            int node = S.top();\n            sum += vals[node];\n            S.pop();\n            for (int next : G[node]) {\n                if (!visited[next]) S.push(next), visited[next] = 1;\n            }\n        }\n        if (sum % 26 != 0) {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    cout << \"YES\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =500005;\nconst int MOD =998244353;\n//const int MOD =1e9+7;\nusing mint = static_modint<MOD>;\n//using mint = modint;\nostream& operator << (ostream& ost, const mint& m){ost << m.val();return ost;}\nistream& operator >> (istream& ost,  mint& m){int a;ost >> a;m=a;return ost;}\n\nusing S=int;\nusing F=int;\n\nsigned main(){\nstring s;\nint n;\ncin>>s>>n;\nint m=s.size(),x[4];\ndsu d(m/2+1);\nfor(int i=0;i<n;i++){\n  cin>>x[0]>>x[1];\n  x[0]--;\n  x[3]=m-x[0];\n  x[2]=m-x[1];\n  sort(x,x+4);\n  d.merge(x[0],x[1]);\n}\nvector<int> p;\nfor(int i=0;i<m/2;i++){\n  p.push_back(signed(s[i])-signed(s[m-1-i]));\n}\nfor(int i=p.size()-1;i>0;i--)p[i]-=p[i-1];\nauto h=d.groups();\nfor(auto&& i:h){\n  int ans=0;\n  for(auto&& j:i){\n    if(j==m/2){\n      ans=0;\n      break;\n    }\n    ans+=p[j];\n  }\n  if(ans%26){\n    cout<<\"NO\"<<endl;\n    return 0;\n  }\n}\ncout<<\"YES\"<<endl;\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing std::cin;\nusing std::cout;\nusing pii = std::pair<int, int>;\nconst int MAXN = 1e5 + 10;\n\nint a[MAXN];\n\nvoid change(int L, int R, int v) {\n    a[L] += v;\n    a[R + 1] -= v;\n}\n\nvoid solve() {\n    std::string s;\n    cin >> s;\n    int n = s.length();\n    int M = (n + 1) / 2;\n    for (int i = 0; i + i < n; ++i) {\n        change(i + 1, i + 1, s[i] - s[n - i - 1]);\n    }\n    int m; cin >> m;\n    std::vector<pii> ls(m);\n    double mm = 0.5 * (n + 1);\n    for (int i = 0, x, y; i < m; ++i) {\n        cin >> x >> y;\n        if (x > mm  && y > mm) {\n            //cout << \"c1\";\n            x = n - x + 1;\n            y = n - y + 1;\n        }\n        if (x <mm && y >mm) {\n            //cout<<\"c2\";\n            y = n - y + 1;\n            x--;\n            std::swap(x, y);\n        }\n        // cout << x << ' ' << y;\n        if (x > y) continue;\n        ls[i] = { x, y };\n    }\n    std::sort(begin(ls), end(ls));\n    int j = 0, val = 0;\n    for (int i = 1; i + i <= n; ++i) {\n        val = (val + a[i]) % 26;\n        val = (val + 26) % 26;\n        while (j < m && ls[j].se < i) j++;\n        if (j < m && ls[j].fi <= i) {\n            change(ls[j].fi, ls[j].se, -val);\n            val = 0;\n            j++;\n        }\n        if (val != 0) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b>>1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n\nvector<vector<ll>> g;\n\nvector<ll> see;\n\nbool nibu(ll u) {\n\t\n\tbool ret = 1;\n\n\tfor (ll v : g[u]) {\n\t\tif (see[v] != -1) {\n\t\t\tif (see[v] == see[u]) { ret = 0; }\n\t\t}\n\t\telse {\n\t\t\tsee[v] = (see[u] + 1) % 2;\n\t\t\tret = nibu(v);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nll wa(ll u,vector<ll> &b) {\n\tll ret = b[u];\n\tsee[u] = 2;\n\n\tfor (ll v : g[u]) {\n\t\tif (see[v] == 2) { continue; }\n\t\tret += wa(v,b);\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tll T = S.size();\n\t\n\tll M = T / 2 + 1;\n\tvector<ll> a(M + 1, 0);\n\trepn(i, M - 1) {\n\t\ta[i] = (ll)S[T - i] - (ll)S[i - 1];\n\t\tif (a[i] < 0) { a[i] += 26; }\n\t}\n\n\tvector<ll> b(M + 1, 0);\n\trepn(i, M)b[i] = a[i] - a[i - 1];\n\n\t//repn(i, M)cout << b[i] << \" \";\n\t//cout << endl;\n\n\tg.resize(M + 1);\n\tll N;\n\tcin >> N;\n\n\trepn(i, N) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\n\t\tif (l + r == T + 1) { continue; }\n\n\t\tif (r <= T / 2) { r++; }\n\t\telse if (l + r < T + 1) { r = T - r + 1; }\n\t\telse if (l <= T / 2) { r = T - r + 1; swap(l, r); }\n\t\telse { l = T - l + 1 + 1; r = T - r + 1; swap(l, r); }\n\n\t\tif (l > M) { l--; }\n\t\tif (r > M) { r--; }\n\n\t\tg[l].push_back(r);\n\t\tg[r].push_back(l);\n\n\t\t//cout << l << \" \" << r << endl;\n\t}\n\n\tsee.assign(M + 1, -1);\n\n\tstring ans = \"YES\";\n\n\trepn(u, M) {\n\t\tif (see[u] != -1) { continue; }\n\t\tsee[u] = 0;\n\n\t\tbool nb = nibu(u);\n\t\tll ss = wa(u, b);\n\t\tif (nb==1 && ss%26 != 0) { ans = \"NO\"; }\n\n\t\t//cout << u << \" \" << nb << \" \" << ss << endl;\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e6+5;\nint lowbit(int x){return x&(-x);}\nint arr[MAXN];\ninline int sum(int x){int res=0;while(x)res+=arr[x],x-=lowbit(x);return res;}\ninline void add(int x,int n){while(x<MAXN)arr[x]+=n,x+=lowbit(x);}\ninline int update(int x,int y,int n){add(x,n);add(y+1,-n);}\nstruct node{\n    int a,b;\n    bool operator < (const node&p)const{\n        return a==p.a ? b > p.b : a > p.a;\n    }\n};\npriority_queue<node> q;\nqueue<node> qq,qqq;\nint f[MAXN];\nstring s;\n//char s[MAXN];\nint a[MAXN];\nint main()\n{\n    memset(f,-1,sizeof f);\n    int x,n,l,r;\n    cin>>s;\n    s=\"0\"+s;\n    //scanf(\"%s\",&s+1);\n    int len = s.length();\n\n    //printf(\"%s\\n\",s);\n    //cout<<s<<endl;\n    //cout<<\"len:\"<<len<<endl;\n    for(int i=1;i<=len/2;i++){\n        update(i,i,s[i] - s[len-i]);\n    }\n    cin>>n;\n    int ll = len / 2;\n    //cout<<\"ll: \"<<ll<<endl;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        //cout<<l<<\"|\"<<r<<endl;\n        if(r <= ll)\n            q.push(node{l,r});\n        else if(l <= ll){\n            //l += ll - l + 1;\n            if(l+r == len)continue;\n            if(abs(ll-l)>abs(r-ll))\n            {\n                q.push(node{l,len-r-1});\n            }\n            else\n                q.push(node{len-r,l-1});\n\n            //q.push(node{ll - max(abs(ll-l),abs(ll-r)), ll - min(abs(ll-l),abs(ll-r))});\n        }\n        else{\n            q.push(node{len-r,len-l});\n        }\n    }\n    /*while(!q.empty()){\n        node now = q.top();\n        //qq.push(now);\n        cout<<now.a<<\"-\"<<now.b<<endl;\n        q.pop();\n    }*/\n    node now,pre = q.top();\n    //qq.push(pre);\n    while(!q.empty()){\n        now = q.top();\n        //cout<<now.a<<\" | \"<<now.b<<endl;\n        if(pre.a < now.a){\n            f[pre.a] = pre.b;\n            pre = now;\n            continue;\n        }\n        q.pop();\n        if(pre.b == now.b)continue;\n        else{\n            q.push(node{pre.b+1, now.b});\n        }\n    }\n    f[pre.a] = pre.b;\n    //qq.push(pre);\n    /*while(!qq.empty()){\n        node now = qq.front();\n        qqq.push(now);\n        cout<<now.a<<\" \"<<now.b<<endl;\n        qq.pop();\n    }*/\n    bool flag = 1;\n    if(len%2==0)len--;\n    for(int i=1;i<=len/2;i++){\n\n        //now = qq.front();\n        x = sum(i) - sum(i-1);\n        //cout<<\"*\"<<x<<\"  \"<<i<<\" \"<<f[i]<<endl;\n        if(x == 0)continue;\n        if(f[i] != -1){\n            //qq.pop();\n            update(i,f[i], -x);\n        }\n        else{\n            flag = 0;\n            break;\n        }\n        //cout<<\"**\"<<sum(i) - sum(i-1)<<endl;\n    }\n    if(flag)\n        cout<<\"YES\\n\";\n    else\n        cout<<\"NO\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nstruct S{\n\tL s,e;\n};\n\nbool operator<(S a,S b){\n\tif(a.s!=b.s) return a.s<b.s;\n\treturn a.e<b.e;\n}\n\nset<S>st;\n\nchar str[100010];\nL b[100010];\nL n,len;\n\nL tr[400040];\n\nvoid update(L now,L S,L E,L s,L e,L val){\n\tif(S>e||E<s) return;\n\tif(s<=S&&E<=e)\n\t{\n\t\ttr[now]+=val;\n\t\treturn;\n\t}\n\tL mid=(S+E)/2;\n\tupdate(now*2,S,mid,s,e,val);\n\tupdate(now*2+1,mid+1,E,s,e,val);\n}\n\nL get(L now,L S,L E,L loc){\n\tif(S>loc||E<loc) return 0;\n\tif(S==E) return tr[now];\n\tL mid=(S+E)/2;\n\treturn tr[now]+get(now*2,S,mid,loc)+get(now*2+1,mid+1,E,loc);\n}\n\nvoid E(L x){\n\tputs(\"NO\");\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%s %lld\",str,&n);\n\tL i,j;\n\tfor(i=0;str[i];i++);\n\tlen=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tL s,e;\n\t\tscanf(\"%lld %lld\",&s,&e);\n\t\tif(s<=len/2)\n\t\t{\n\t\t\tif(e>len/2)\n\t\t\t{\n\t\t\t\te=len-e;\n\t\t\t\tif(e<s)\n\t\t\t\t{\n\t\t\t\t\ts--;\n\t\t\t\t\te++;\n\t\t\t\t\tswap(s,e);\n\t\t\t\t\tif(s>e) continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(len%2&&e==(len+1)/2) e--;\n\t\t\tif(s>e) continue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=len-s+1;\n\t\t\te=len-e+1;\n\t\t\tswap(s,e);\n\t\t}\n\t\tst.insert((S){s,e});\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tset<S>::iterator it=st.lower_bound((S){i,0});\n\t\tif(it->s!=i) continue;\n\t\tS range=*it;\n\t\twhile(1)\n\t\t{\n\t\t\tset<S>::iterator it2=st.lower_bound((S){i,0});\n\t\t\tit2++;\n\t\t\tif(it2==st.end()||it2->s!=range.s) break;\n\t\t\tS etemp=*it2;\n\t\t\tst.insert((S){range.e+1,etemp.e});\n\t\t\tst.erase(etemp);\n\t\t}\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tb[i]=str[i-1]-'a';\n\t}\n\tfor(i=1;i<=len/2;i++)\n\t{\n\t\tb[i]-=b[len-i+1];\n\t\tif(b[i]<0) b[i]+=26;\n\t}\n\tlen/=2;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tupdate(1,1,len,i,i,b[i]);\n\t}\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tL temp=get(1,1,len,i)%26;\n\t\tif(temp)\n\t\t{\n\t\t\twhile(!st.empty()&&st.begin()->s<i) st.erase(st.begin());\n\t\t\tif(st.empty()||st.begin()->s!=i) E(1);\n\t\t\tS range=*(st.begin());\n\t\t\tupdate(1,1,len,range.s,range.e,26-temp);\n\t\t}\n\t}\n\tputs(\"YES\");\n}"
  },
  {
    "language": "C++",
    "code": "/*input\nabc\n1\n2 2\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=80000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nstring s;\nstring L,R;\n\nvector<int> bound[maxn];\n\npii itv[maxn];\n\nint d[maxn];\nint tg[maxn];\nint main()\n{\n\tIOS;\n\tcin>>s;\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>itv[i].F>>itv[i].S;\n\tREP(i,n) itv[i].F--;\n\n\tREP(i,n){\n\t\titv[i].F=min(itv[i].F,SZ(s)-itv[i].F);\n\t\titv[i].S=min(itv[i].S,SZ(s)-itv[i].S);\n\t\tif(itv[i].F>itv[i].S) swap(itv[i].F,itv[i].S);\n\t}\n\tfor(int i=0;i<SZ(s)/2;i++) L.pb(s[i]);\n\tfor(int i=0;i<SZ(s)/2;i++) R.pb(s[SZ(s)-1-i]);\n\n\tREP(i,n) bound[itv[i].F].pb(itv[i].S);\n\tREP(i,SZ(s)/2){\n\t\tSORT_UNIQUE(bound[i]);\n\t\tfor(int j=1;j<SZ(bound[i]);j++){\n\t\t\tbound[bound[i][j-1]].pb(bound[i][j]);\n\t\t}\n\t\twhile(SZ(bound[i])>1) bound[i].pop_back();\n\t}\n\t// REP(i,SZ(s)/2){\n\t// \tfor(int j:bound[i]) cout<<j<<' ';\n\t// \tcout<<'\\n';\n\t// }\n\t// cout<<L<<' '<<R<<'\\n';\n\tREP(i,SZ(s)/2){\n\t\td[i]=(L[i]-R[i]+26)%26;\n\t}\n\t// REP(i,SZ(s)/2) cout<<d[i]<<\" \\n\"[i==SZ(s)/2-1];\n\tint dd=0;\n\tfor(int i=0;i<SZ(s)/2;i++){\n\t\tdd+=tg[i];\n\t\tdd=(dd%26+26)%26;\n\t\td[i]+=dd;\n\t\td[i]%=26;\n\n\t\tif(SZ(bound[i])){\n\t\t\tint tmp=26-d[i];\n\t\t\td[i]+=tmp;\n\t\t\td[i]%=26;\n\t\t\tdd+=tmp;\n\t\t\ttg[bound[i][0]]-=tmp;\n\t\t}\n\t}\n\tREP(i,SZ(s)/2) if(d[i]){\n\t\tcout<<\"NO\\n\";\n\t\treturn 0;\n\t}\n\tcout<<\"YES\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//while (clock()<=69*CLOCKS_PER_SEC)\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=100*1007;\n\nint k;\nchar wcz[nax];\n\nint n;\n\nint oj[nax];\n\nint sum[nax];\n\nint fin(int v)\n{\n\tif (v!=oj[v])\n\t\toj[v]=fin(oj[v]);\n\treturn oj[v];\n}\n\nvoid uni(int v, int u)\n{\n\toj[fin(u)]=fin(v);\n}\n\nint main()\n{\n\tscanf(\"%s\", wcz+1);\n\tk=strlen(wcz+1);\n\twcz[0]='a';\n\twcz[k+1]='a';\n\tfor (int i=0; i<=k; i++)\n\t\toj[i]=i;\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tuni(l-1, r);\n\t}\n\tfor (int i=1; i<=k/2+1; i++)\n\t\tuni(i-1, k-(i-1));\n\tfor (int i=0; i<=k; i++)\n\t\tsum[fin(i)]+=(wcz[i]-wcz[i+1]);\n\tfor (int i=0; i<=k; i++)\n\t{\n\t\tif (sum[i]%26)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct uftree{\n\tint par[100005],rank[100005];\n\tuftree(){\n\t\tfor(int i=0;i<100005;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(x==par[x])return x;\n\t\treturn (par[x]=find(par[x]));\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x]=y;\n\t\t}else{\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t\tpar[y]=x;\n\t\t}\n\t}\n};\n\nuftree uf;\n\nstring str;\nint n;\nint l[100005],r[100005];\nint diff[100005];\nint sum[100005];\n\nint main(void){\n\tcin >> str;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tl[i]--;\n\t\tuf.unite(l[i],r[i]);\n\t}\n\tn=str.size();\n\tdiff[0]=(str[0]-'a');\n\tfor(int i=0;i<n-1;i++){\n\t\tdiff[i+1]=(str[i+1]-'a')-(str[i]-'a');\n\t\tif(diff[i+1]<0)diff[i+1]+=26;\n\t}\n\tdiff[n]=26-(str[n-1]-'a');\n\tfor(int i=0;i<n/2;i++){\n\t\tuf.unite(i,n-i);\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tint v=uf.find(i);\n\t\tsum[v]+=diff[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tif(sum[i]%26!=0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#define N 100005\n\nchar str[N] = {0};\nint len, mid;\n\nstd::pair<int, int> ops[N];\nint opscnt = 0;\n\nint pre[N];\n\ninline void merge_ops()\n{\n\tstatic std::set<int> rs[N];\n\tfor(int i = 0; i < opscnt; ++i)\n\t\trs[ops[i].first].insert(ops[i].second);\n\n\topscnt = 0;\n\tfor(int l = 1; l <= mid; ++l)\n\t{\n\t\tstd::set<int> &cur = rs[l];\n\t\tif(cur.empty()) continue;\n\n\t\tint r = *cur.begin();\n\t\tops[opscnt++] = std::make_pair(l, r);\n\t\t//printf(\"f->%d %d\\n\", l, r);\n\t\tcur.erase(cur.begin());\n\n\t\tstd::set<int> &dest = rs[r + 1];\n\t\tif(cur.size() < dest.size())\n\t\t\tfor(int i: cur) dest.insert(i);\n\t\telse\n\t\t{\n\t\t\tfor(int i: dest) cur.insert(i);\n\t\t\tdest.swap(cur);\n\t\t}\n\t}\n}\n\ninline bool solve()\n{\n\tpre[0] = 0;\n\tpre[1] = str[1] - 'a';\n\tfor(int i = 2; i <= mid; ++i)\n\t\tpre[i] = str[i] - str[i - 1];\n\n\tint k = 1;\n\tfor(int o = 0; o < opscnt; ++o)\n\t{\n\t\tconst std::pair<int, int> &cur = ops[o];\n\t\tfor(; k <= cur.first; ++k)\n\t\t{\n\t\t\tpre[k] += pre[k - 1];\n\t\t\tpre[k] = (pre[k] + 26) % 26;\n\t\t}\n\t\tint d = str[len - cur.first + 1] - pre[cur.first] - 'a';\n\t\tpre[cur.first] += d;\n\t\tpre[cur.second + 1] -= d;\n\t}\n\tfor(; k <= mid; ++k)\n\t{\n\t\tpre[k] += pre[k - 1];\n\t\tpre[k] = (pre[k] + 26) % 26;\n\t}\n\n\tfor(int i = 1; i <= mid; ++i)\n\t{\n\t\tif(pre[i] != str[len - i + 1] - 'a')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint _;\n\tscanf(\"%s%d\", str + 1, &_);\n\tlen = strlen(str + 1);\n\tmid = len >> 1;\n\n\t//printf(\"%d\\n\", mid);\n\n\tfor(int i = 0; i < _; ++i)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif(l - 1 > (len - r))\n\t\t{\n\t\t\tl = len - l + 1;\n\t\t\tr = len - r + 1;\n\t\t\tstd::swap(l, r);\n\t\t}\n\t\tif(r > mid) r = len - r;\n\n\t\tif(l <= r)\n\t\t\tops[opscnt++] = std::make_pair(l, r);\n\t\t//printf(\"%d %d\\n\", l, r);\n\t}\n\n\tmerge_ops();\n\n\tif(solve()) printf(\"YES\\n\");\n\telse printf(\"NO\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define max_size (int)(1e5 + 1)\n\ntypedef struct {\n\tint N;\n\tint *u;\n\tint *u_rank;\n}union_find;\n\nunion_find *make_union_find(int N){\n\tint i;\n\tunion_find *uf = (union_find *)malloc(sizeof(union_find));\n\tuf->N = N;\n\tuf->u = (int *)malloc(sizeof(int) * N);\n\tuf->u_rank = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\t(uf->u)[i] = i;\n\t\t(uf->u_rank)[i] = 1;\n\t}\n\treturn uf;\n}\n\nint root_uf(int x, union_find *uf){\n\tint *u = uf->u;\n\tif(u[x] == x){\n\t\treturn x;\n\t}\n\telse{\n\t\tu[x] = root_uf(u[x], uf);\n\t\treturn u[x];\n\t}\n}\n\nvoid combine_uf(int x, int y, union_find *uf){\n\tint x_root = root_uf(x, uf);\n\tint y_root = root_uf(y, uf);\n\tint *u = uf->u;\n\tint *u_rank = uf->u_rank;\n\tif(x_root == y_root){\n\t\treturn;\n\t}\n\telse if(u_rank[x_root] < u_rank[y_root]){\n\t\tu[x_root] = y_root;\n\t\tu_rank[y_root] += u_rank[x_root];\n\t\tu_rank[x_root] = 0;\n\t}\n\telse{\n\t\tu[y_root] = x_root;\n\t\tu_rank[x_root] += u_rank[y_root];\n\t\tu_rank[y_root] = 0;\n\t}\n}\n\n//xとyが同じ集合に属していれば1を,そうでなければ0を返す\nint is_same_union_uf(int x, int y, union_find *uf){\n\tif(root_uf(x, uf) == root_uf(y, uf)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\n//xが属する集合の要素数を返す\nint rank_uf(int x, union_find *uf){\n\treturn (uf->u_rank)[root_uf(x, uf)];\n}\n\nint main(){\n\tint L, N, l, r, i;\n\tchar *S = (char *)malloc(sizeof(char) * max_size);\n\tscanf(\"%s\", S);\n\tfor(i = 0; S[i] != '\\0'; i++){}\n\tL = i;\n\tunion_find *uf = make_union_find(L + 1);\n\tuf->u_rank[0] = ((int)S[0] - (int)'a') % 26;\n\tfor(i = 1; i < L; i++){\n\t\tuf->u_rank[i] = ((int)S[i] - (int)S[i - 1] + 26) % 26;\n\t}\n\tuf->u_rank[L] = ((int)'a' - (int)S[L - 1] + 26) % 26;\n\tfor(i = 0; i < L / 2; i++){\n\t\tcombine_uf(i, L - i, uf);\n\t}\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tcombine_uf(l - 1, r, uf);\n\t}\n\tfor(i = 0; i <= L; i++){\n\t\tif(rank_uf(i, uf) % 26 != 0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define max_size (int)(1e5 + 1)\n\ntypedef struct {\n\tint N;\n\tint *u;\n\tint *u_rank;\n}union_find;\n\nunion_find *make_union_find(int N){\n\tint i;\n\tunion_find *uf = (union_find *)malloc(sizeof(union_find));\n\tuf->N = N;\n\tuf->u = (int *)malloc(sizeof(int) * N);\n\tuf->u_rank = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\t(uf->u)[i] = i;\n\t\t(uf->u_rank)[i] = 1;\n\t}\n\treturn uf;\n}\n\nint root_uf(int x, union_find *uf){\n\tint *u = uf->u;\n\tif(u[x] == x){\n\t\treturn x;\n\t}\n\telse{\n\t\tu[x] = root_uf(u[x], uf);\n\t\treturn u[x];\n\t}\n}\n\nvoid combine_uf(int x, int y, union_find *uf){\n\tint x_root = root_uf(x, uf);\n\tint y_root = root_uf(y, uf);\n\tint *u = uf->u;\n\tint *u_rank = uf->u_rank;\n\tif(x_root == y_root){\n\t\treturn;\n\t}\n\telse if(u_rank[x_root] < u_rank[y_root]){\n\t\tu[x_root] = y_root;\n\t\tu_rank[y_root] += u_rank[x_root];\n\t\tu_rank[x_root] = 0;\n\t}\n\telse{\n\t\tu[y_root] = x_root;\n\t\tu_rank[x_root] += u_rank[y_root];\n\t\tu_rank[y_root] = 0;\n\t}\n}\n\n//xとyが同じ集合に属していれば1を,そうでなければ0を返す\nint is_same_union_uf(int x, int y, union_find *uf){\n\tif(root_uf(x, uf) == root_uf(y, uf)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\n//xが属する集合の要素数を返す\nint rank_uf(int x, union_find *uf){\n\treturn (uf->u_rank)[root_uf(x, uf)];\n}\n\nint main(){\n\tint L, N, l, r, i;\n\tchar *S = (char *)malloc(sizeof(char) * max_size);\n\tscanf(\"%s\", S);\n\tfor(i = 0; S[i] != '\\0'; i++){}\n\tL = i;\n\tunion_find *uf = make_union_find(L + 1);\n\tuf->u_rank[0] = ((int)S[0] - (int)'a') % 26;\n\tfor(i = 1; i < L; i++){\n\t\tuf->u_rank[i] = ((int)S[i] - (int)S[i - 1] + 26) % 26;\n\t}\n\tuf->u_rank[L] = ((int)'a' - (int)S[L - 1] + 26) % 26;\n\tfor(i = 0; i <= L / 2; i++){\n\t\tcombine_uf(i, L - i, uf);\n\t}\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tcombine_uf(l - 1, r, uf);\n\t}\n\tfor(i = 0; i <= L; i++){\n\t\tif(rank_uf(i, uf) % 26 != 0){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            char[] s = new char[100000];\n            int len = in.readString(s, 0);\n            int n = in.readInt();\n            int[] differ = new int[len + 2];\n            for (int i = 1; i <= len; i++) {\n                if (i == 1) {\n                    differ[i] = s[i - 1] - 'a';\n                } else {\n                    differ[i] = s[i - 1] - s[i - 2];\n                }\n            }\n            differ[len + 1] = 'a' - s[len - 1];\n            Node[] nodes = new Node[len + 2];\n            for (int i = 0; i < len + 2; i++) {\n                nodes[i] = new Node();\n                nodes[i].val = differ[i];\n            }\n\n            for (int i = 0; i < n; i++) {\n                int l = in.readInt();\n                int r = in.readInt();\n                Node.merge(nodes[l], nodes[r + 1]);\n            }\n\n            for (int i = 1; i <= (len + 2 + 1) / 2; i++) {\n                Node.merge(nodes[i], nodes[len + 2 - i]);\n            }\n\n            int mod = 'z' - 'a' + 1;\n            boolean allZero = true;\n            for (int i = 0; i < len + 2; i++) {\n                allZero = allZero && nodes[i].find().val % mod == 0;\n            }\n            out.println(allZero ? \"YES\" : \"NO\");\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Node {\n        Node p = this;\n        int rank;\n        int val;\n\n        public Node find() {\n            return p.p == p ? p : (p = p.find());\n        }\n\n        static void merge(Node a, Node b) {\n            a = a.find();\n            b = b.find();\n            if (a == b) {\n                return;\n            }\n            if (a.rank == b.rank) {\n                a.rank++;\n            }\n            if (a.rank < b.rank) {\n                Node tmp = a;\n                a = b;\n                b = tmp;\n            }\n            b.p = a;\n            a.val += b.val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ECombinationLock solver = new ECombinationLock();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ECombinationLock {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int[] a = in.readString().chars().map(c -> c - 'a').toArray();\n\n            int n = a.length;\n            int m = in.readInt();\n            UnionFind uf = new UnionFind(n + 1);\n            for (int i = 0; i < m; i++) uf.union(in.readInt() - 1, in.readInt());\n            for (int i = 0; i < (n + 1) / 2; i++) uf.union(i, n - i);\n\n            int[] sum = new int[n + 1];\n            sum[uf.root(0)] += a[0];\n            for (int i = 1; i < n; i++) sum[uf.root(i)] += a[i] - a[i - 1];\n            sum[uf.root(n)] -= a[n - 1];\n\n            for (int i = 0; i <= n; i++) {\n                if (sum[i] % 26 != 0) {\n                    out.printLine(\"NO\");\n                    return;\n                }\n            }\n            out.printLine(\"YES\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class UnionFind {\n        protected int[] parent;\n        protected int size;\n\n        public UnionFind(int size) {\n            parent = new int[size];\n            this.size = size;\n            Arrays.fill(parent, -1);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x == y) return false;\n            if (parent[y] < parent[x]) {\n                int tmp = y;\n                y = x;\n                x = tmp;\n            }\n            parent[x] += parent[y];\n            parent[y] = x;\n            size--;\n            return true;\n        }\n\n        public int root(int x) {\n            return parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n        }\n\n        public List<Set<Integer>> getGroups() {\n            int n = parent.length;\n            List<Set<Integer>> groups = new ArrayList<>();\n            Map<Integer, Integer> map = new TreeMap<>();\n            for (int i = 0; i < n; i++) {\n                int r = root(i);\n                if (!map.containsKey(r)) {\n                    map.put(r, groups.size());\n                    groups.add(new HashSet<>());\n                }\n                groups.get(map.get(r)).add(i);\n            }\n            return groups;\n        }\n\n        public String toString() {\n            return getGroups().toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Range {\n  final int l, r;\n\n  Range(int l, int r) {\n    this.l = l;\n    this.r = r;\n  }\n}\n\nclass Solver {\n  private static final int ALPHABET_SIZE = 26;\n\n  private static final UpdateRangeGetRangeSegmentTree.Operator<Integer, Integer> OPERATOR = new UpdateRangeGetRangeSegmentTree.Operator<>() {\n\n    @Override\n    public Integer multiplyLazyValue(Integer lazy, int count) {\n      return lazy;\n    }\n\n    @Override\n    public Integer applyOffset(Integer lazy, int offset) {\n      return lazy;\n    }\n\n    @Override\n    public Integer mergeLazyValue(Integer oldLazy, Integer newLazy) {\n      if (oldLazy == null) {\n        return newLazy;\n      }\n      if (newLazy == null) {\n        return oldLazy;\n      }\n      return (newLazy + oldLazy) % ALPHABET_SIZE;\n    }\n\n    @Override\n    public Integer apply(Integer value, Integer lazy) {\n      return (value + lazy) % ALPHABET_SIZE;\n    }\n\n    @Override\n    public Integer mergeValue(Integer smallIndexValue, Integer largeIndexValue) {\n      return (smallIndexValue + largeIndexValue) % ALPHABET_SIZE;\n    }\n\n    @Override\n    public Integer getUnitValue() {\n      return Integer.valueOf(0);\n    }\n\n  };\n\n  final char[] cs;\n  final int n;\n  final int pairCount;\n  final int[][] lrs;\n\n//  List<List<Range>> rangeMatrix;\n\n  List<Set<Integer>> leftSetList;\n  List<Set<Integer>> rightSetList;\n\n  Solver(char[] cs, int pairCount, int[][] lrs) {\n    this.cs = cs;\n    this.n = cs.length;\n    this.pairCount = pairCount;\n    this.lrs = lrs;\n  }\n\n  int getMinAndUpdate(List<Set<Integer>> setList, int index) {\n    List<Integer> list = new ArrayList<>();\n    list.addAll(setList.get(index));\n    Collections.sort(list);\n    for (int i = 1; i < list.size(); i++) {\n      if (list.get(i - 1) < list.get(i)) {\n        setList.get(list.get(i - 1) + 1).add(list.get(i));\n      }\n    }\n    setList.get(index).clear();\n    return list.get(0);\n  }\n\n  // n = 4\n  // 0, 1, 2, 3\n  // 3, 2, 1, 0\n  //\n  // n = 5\n  // 0, 1, 2, 3, 4\n  // 4, 3, 2, 1, 0\n  void addRange(int l, int r) {\n//    System.err.printf(\"addRange: 1, l: %d, r: %d\\n\", l, r);\n    if (l + r == n - 1) {\n//      System.err.printf(\"addRange: 2, l: %d, r: %d\\n\", l, r);\n      return;\n    }\n    if (r < n / 2) {\n//      System.err.printf(\"addRange: 3, l: %d, r: %d\\n\", l, r);\n      leftSetList.get(l).add(r);\n      return;\n    }\n    if (l > n / 2) {\n//      System.err.printf(\"addRange: 4, l: %d, r: %d\\n\", l, r);\n      rightSetList.get(n - 1 - r).add(n - 1 - l);\n      return;\n    }\n//    System.err.printf(\"addRange: 5, l: %d, r: %d\\n\", l, r);\n    int rFromRight = n - 1 - r;\n    if (l < rFromRight) {\n//      System.err.printf(\"addRange: 6, l: %d, r: %d\\n\", l, r);\n      rightSetList.get(l).add(n - 1 - (r + 1));\n    } else if (rFromRight < l) {\n//      System.err.printf(\"addRange: 7, l: %d, r: %d\\n\", l, r);\n      leftSetList.get(rFromRight).add(l - 1);\n    }\n  }\n\n  public boolean solve() {\n    leftSetList = new ArrayList<>();\n    rightSetList = new ArrayList<>();\n    for (int i = 0; i < n / 2; i++) {\n      leftSetList.add(new HashSet<>());\n      rightSetList.add(new HashSet<>());\n    }\n\n    for (int[] lr : lrs) {\n      int l = lr[0] - 1;\n      int r = lr[1] - 1;\n//      System.err.printf(\"%d %d\\n\", l, r);\n      addRange(l, r);\n    }\n\n    Integer[] initialValues = new Integer[n];\n    for (int i = 0; i < n; i++) {\n      initialValues[i] = cs[i] - 'a';\n    }\n    UpdateRangeGetRangeSegmentTree<Integer, Integer> segmentTree = new UpdateRangeGetRangeSegmentTree<>(OPERATOR, initialValues);\n    for (int i = 0; i < n / 2; i++) {\n      int leftValue = segmentTree.get(i);\n      int rightValue = segmentTree.get(n - 1 - i);\n      if (!leftSetList.get(i).isEmpty() && !rightSetList.get(i).isEmpty()) {\n        int leftRight = getMinAndUpdate(leftSetList, i);\n        int rightLeft = getMinAndUpdate(rightSetList, i);\n        if (leftValue != rightValue) {\n          segmentTree.update(i, leftRight + 1, (rightValue - leftValue + ALPHABET_SIZE) % ALPHABET_SIZE);\n        }\n        addRange(leftRight + 1, n - rightLeft - 2);\n      } else if (!leftSetList.get(i).isEmpty()) {\n        int leftRight = getMinAndUpdate(leftSetList, i);\n        if (leftValue != rightValue) {\n          segmentTree.update(i, leftRight + 1, (rightValue - leftValue + ALPHABET_SIZE) % ALPHABET_SIZE);\n        }\n      } else if (!rightSetList.get(i).isEmpty()) {\n        int rightLeft = getMinAndUpdate(rightSetList, i);\n        if (leftValue != rightValue) {\n          segmentTree.update(n - 1 - rightLeft, n - i, (leftValue - rightValue + ALPHABET_SIZE) % ALPHABET_SIZE);\n        }\n      } else if (leftValue != rightValue) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, ContestWriter out) {\n    char[] cs = reader.nextCharArray();\n    int n = reader.nextInt();\n    int[][] lrs = reader.nextInt(n, 2);\n    out.println(new Solver(cs, n, lrs).solve() ? \"YES\" : \"NO\");\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\n// Verify ABC177 F\n// https://atcoder.jp/contests/abc177/tasks/abc177_f\n\nclass UpdateRangeGetRangeSegmentTree<LazyType, ValueType> {\n  public interface Operator<LazyType, ValueType> {\n    LazyType multiplyLazyValue(LazyType lazy, int count);\n    LazyType applyOffset(LazyType lazy, int offset);\n    LazyType mergeLazyValue(LazyType oldLazy, LazyType newLazy);\n    ValueType apply(ValueType value, LazyType lazy);\n    ValueType mergeValue(ValueType smallIndexValue, ValueType largeIndexValue);\n    ValueType getUnitValue();\n  }\n  \n  private final Operator<LazyType, ValueType> operator;\n  private final int n;\n  private final LazyType[] lazies;\n  private final ValueType[] values;\n  \n  public UpdateRangeGetRangeSegmentTree(Operator<LazyType, ValueType> operator, ValueType[] initialValues) {\n    this.operator = operator;\n    \n    int tempN = 1;\n    while (tempN < initialValues.length) {\n      tempN *= 2;\n    }\n    n = tempN;\n    lazies = createTArray(2 * n -1);\n    values = createSArray(2 * n -1);\n    for (int i = 0; i < initialValues.length; i++) {\n      values[i + n - 1] = initialValues[i];\n    }\n    for (int i = initialValues.length; i < n; i++) {\n      values[i + n - 1] = this.operator.getUnitValue();\n    }\n    for (int i = n - 2; i >= 0; i--) {\n      values[i] = this.operator.mergeValue(values[2 * i + 1], values[2 * i + 2]);\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private LazyType[] createTArray(int size) {\n    return (LazyType[])(new Object[size]);    \n  }\n  \n  @SuppressWarnings(\"unchecked\")\n  private ValueType[] createSArray(int size) {\n    return (ValueType[])(new Object[size]);    \n  }\n  \n  private void eval(int k, int l, int r) {\n    if (lazies[k] == null) {\n      return;\n    }\n    values[k] = operator.apply(values[k], operator.multiplyLazyValue(lazies[k], r - l));\n    if (r - l > 1) {\n      lazies[2 * k + 1] = operator.mergeLazyValue(lazies[2 * k + 1], lazies[k]);\n      lazies[2 * k + 2] = operator.mergeLazyValue(lazies[2 * k + 2], operator.applyOffset(lazies[k], (r - l) / 2));\n    }\n    lazies[k] = null;\n  }\n  \n  private void update(int a, int b, LazyType lazy, int k, int l, int r) {\n    eval(k, l, r);\n    if (b <= l || r <= a) {\n      return;\n    }\n    if (a <= l && r <= b) {\n      lazies[k] = operator.mergeLazyValue(lazies[k], lazy);\n      eval(k, l, r);\n    } else {\n      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, operator.applyOffset(lazy, (r - l) / 2), 2 * k + 2, (l + r) / 2, r);\n      values[k] = operator.mergeValue(values[2 * k + 1], values[2 * k + 2]);\n    }\n  }\n  \n  public void update(int a, int b, LazyType lazy) {\n    update(a, b, lazy, 0, 0, n);\n  }\n  \n  public void update(int a, LazyType lazy) {\n    update(a, a + 1, lazy);\n  }\n  \n  private ValueType getRange(int a, int b, int k, int l, int r) {\n    if (b <= l || r <= a) {\n      return operator.getUnitValue();\n    }\n    eval(k, l, r);\n    if (a <= l && r <= b) {\n      return values[k];\n    }\n    ValueType vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);\n    ValueType vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);\n    return operator.mergeValue(vl, vr);\n  }\n  \n  public ValueType getRange(int a, int b) {\n    return getRange(a, b, 0, 0, n);\n  }\n  \n  public ValueType get(int a) {\n    return getRange(a, a + 1);\n  }\n\n  private void dump(Object[] objects) {\n    int sum = 0;\n    for (int i = 0; sum + (1 << i) <= 2 * n - 1; sum += 1 << i, i++) {\n      for (int j = sum; j < sum + (1 << i); j++) {\n        System.err.print(objects[j]);\n        System.err.print(\" \");\n      }\n      System.err.println();\n    }\n    System.err.println();\n  }\n  \n  public void dump() {\n    System.err.println(\"values: \");\n    dump(values);\n    System.err.println(\"lazies: \");\n    dump(lazies);\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.HashMap;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int[] a = in.nextString().chars().map(c -> c - 'a').toArray();\n            int m = a.length;\n            int[] sub = new int[m + 1];\n            sub[0] = a[0];\n            for (int i = 1; i < m; i++) {\n                sub[i] = (26 + a[i] - a[i - 1]) % 26;\n            }\n            sub[m] = (26 - a[m - 1]) % 26;\n\n            int n = in.nextInt();\n            UnionFind uf = new UnionFind(m + 1);\n            for (int i = 0; i <= m / 2; i++) {\n                uf.union(i, m - i);\n            }\n            for (int i = 0; i < n; i++) {\n                int l = in.nextInt() - 1;\n                int r = in.nextInt() - 1;\n                uf.union(l, r + 1);\n            }\n\n            for (List<Integer> list : uf.getGroups()) {\n                if (list.stream().mapToInt(x -> sub[x]).sum() % 26 != 0) {\n                    out.println(\"NO\");\n                    return;\n                }\n            }\n            out.println(\"YES\");\n        }\n\n    }\n\n    static class UnionFind {\n        private int[] parent;\n\n        public UnionFind(int size) {\n            parent = new int[size];\n            Arrays.fill(parent, -1);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (parent[y] < parent[x]) {\n                    int tmp = y;\n                    y = x;\n                    x = tmp;\n                }\n                parent[x] += parent[y];\n                parent[y] = x;\n                return true;\n            }\n            return false;\n        }\n\n        public int root(int x) {\n            return parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n        }\n\n        public List<List<Integer>> getGroups() {\n            int n = parent.length;\n            List<List<Integer>> groups = new ArrayList<>();\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                int r = root(i);\n                if (!map.containsKey(r)) {\n                    map.put(r, groups.size());\n                    groups.add(new ArrayList<>());\n                }\n                groups.get(map.get(r)).add(i);\n            }\n            return groups;\n        }\n\n\n        public String toString() {\n            return getGroups().toString();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.HashMap;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int[] a = in.nextString().chars().map(c -> c - 'a').toArray();\n            int m = a.length;\n            int[] sub = new int[m + 1];\n            sub[0] = a[0];\n            for (int i = 1; i < m; i++) {\n                sub[i] = (26 + a[i] - a[i - 1]) % 26;\n            }\n            sub[m] = (26 - a[m - 1]) % 26;\n\n            int n = in.nextInt();\n            UnionFind uf = new UnionFind(m + 1);\n            for (int i = 0; i < m / 2; i++) {\n                uf.union(i, m - i);\n            }\n            for (int i = 0; i < n; i++) {\n                int l = in.nextInt() - 1;\n                int r = in.nextInt() - 1;\n                uf.union(l, r + 1);\n            }\n\n            for (List<Integer> list : uf.getGroups()) {\n                if (list.stream().mapToInt(x -> sub[x]).sum() % 26 != 0) {\n                    out.println(\"NO\");\n                    return;\n                }\n            }\n            out.println(\"YES\");\n        }\n\n    }\n\n    static class UnionFind {\n        int[] parent;\n\n        public UnionFind(int size) {\n            parent = new int[size];\n            Arrays.fill(parent, -1);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (parent[y] < parent[x]) {\n                    int tmp = y;\n                    y = x;\n                    x = tmp;\n                }\n                parent[x] += parent[y];\n                parent[y] = x;\n                return true;\n            }\n            return false;\n        }\n\n        public int root(int x) {\n            return parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n        }\n\n        public ArrayList<ArrayList<Integer>> getGroups() {\n            int n = parent.length;\n            ArrayList<ArrayList<Integer>> groups = new ArrayList<>();\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                int r = root(i);\n                if (!map.containsKey(r)) {\n                    map.put(r, groups.size());\n                    groups.add(new ArrayList<>());\n                }\n                groups.get(map.get(r)).add(i);\n            }\n            return groups;\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Range {\n  final int l, r;\n\n  Range(int l, int r) {\n    this.l = l;\n    this.r = r;\n  }\n}\n\nclass Solver {\n  private static final int ALPHABET_SIZE = 26;\n\n  private static final UpdateRangeGetRangeSegmentTree.Operator<Integer, Integer> OPERATOR = new UpdateRangeGetRangeSegmentTree.Operator<>() {\n\n    @Override\n    public Integer multiplyLazyValue(Integer lazy, int count) {\n      return lazy;\n    }\n\n    @Override\n    public Integer applyOffset(Integer lazy, int offset) {\n      return lazy;\n    }\n\n    @Override\n    public Integer mergeLazyValue(Integer oldLazy, Integer newLazy) {\n      if (oldLazy == null) {\n        return newLazy;\n      }\n      if (newLazy == null) {\n        return oldLazy;\n      }\n      return (newLazy + oldLazy) % ALPHABET_SIZE;\n    }\n\n    @Override\n    public Integer apply(Integer value, Integer lazy) {\n      return (value + lazy) % ALPHABET_SIZE;\n    }\n\n    @Override\n    public Integer mergeValue(Integer smallIndexValue, Integer largeIndexValue) {\n      return (smallIndexValue + largeIndexValue) % ALPHABET_SIZE;\n    }\n\n    @Override\n    public Integer getUnitValue() {\n      return Integer.valueOf(0);\n    }\n\n  };\n\n  final char[] cs;\n  final int n;\n  final int pairCount;\n  final int[][] lrs;\n\n//  List<List<Range>> rangeMatrix;\n\n  List<Set<Integer>> leftSetList;\n  List<Set<Integer>> rightSetList;\n\n  Solver(char[] cs, int pairCount, int[][] lrs) {\n    this.cs = cs;\n    this.n = cs.length;\n    this.pairCount = pairCount;\n    this.lrs = lrs;\n  }\n\n  int getMinAndUpdate(List<Set<Integer>> setList, int index) {\n    List<Integer> list = new ArrayList<>();\n    list.addAll(setList.get(index));\n    Collections.sort(list);\n    for (int i = 1; i < list.size(); i++) {\n      if (list.get(i - 1) < list.get(i)) {\n        setList.get(list.get(i - 1) + 1).add(list.get(i));\n      }\n    }\n    setList.get(index).clear();\n    return list.get(0);\n  }\n\n  // n = 4\n  // 0, 1, 2, 3\n  // 3, 2, 1, 0\n  //\n  // n = 5\n  // 0, 1, 2, 3, 4\n  // 4, 3, 2, 1, 0\n  void addRange(int l, int r) {\n//    System.err.printf(\"addRange: 1, l: %d, r: %d\\n\", l, r);\n    if (l + r == n - 1) {\n//      System.err.printf(\"addRange: 2, l: %d, r: %d\\n\", l, r);\n      return;\n    }\n    if (r < n / 2) {\n//      System.err.printf(\"addRange: 3, l: %d, r: %d\\n\", l, r);\n      leftSetList.get(l).add(r);\n      return;\n    }\n    if (l > n / 2) {\n//      System.err.printf(\"addRange: 4, l: %d, r: %d\\n\", l, r);\n      rightSetList.get(n - 1 - r).add(n - 1 - l);\n      return;\n    }\n//    System.err.printf(\"addRange: 5, l: %d, r: %d\\n\", l, r);\n    int rFromRight = n - 1 - r;\n    if (l < rFromRight) {\n//      System.err.printf(\"addRange: 6, l: %d, r: %d\\n\", l, r);\n      rightSetList.get(l).add(n - 1 - (r + 1));\n    } else if (rFromRight < l) {\n//      System.err.printf(\"addRange: 7, l: %d, r: %d\\n\", l, r);\n      leftSetList.get(rFromRight).add(l - 1);\n    }\n  }\n\n  public boolean solve() {\n    leftSetList = new ArrayList<>();\n    rightSetList = new ArrayList<>();\n    for (int i = 0; i < n / 2; i++) {\n      leftSetList.add(new HashSet<>());\n      rightSetList.add(new HashSet<>());\n    }\n\n    for (int[] lr : lrs) {\n      int l = lr[0] - 1;\n      int r = lr[1] - 1;\n//      System.err.printf(\"%d %d\\n\", l, r);\n      addRange(l, r);\n    }\n\n    Integer[] initialValues = new Integer[n];\n    for (int i = 0; i < n; i++) {\n      initialValues[i] = cs[i] - 'a';\n    }\n    UpdateRangeGetRangeSegmentTree<Integer, Integer> segmentTree = new UpdateRangeGetRangeSegmentTree<>(OPERATOR, initialValues);\n    for (int i = 0; i < n / 2; i++) {\n      int leftValue = segmentTree.get(i);\n      int rightValue = segmentTree.get(n - 1 - i);\n      if (!leftSetList.get(i).isEmpty() && !rightSetList.get(i).isEmpty()) {\n        int leftRight = getMinAndUpdate(leftSetList, i);\n        int rightLeft = getMinAndUpdate(rightSetList, i);\n        if (leftValue != rightValue) {\n          segmentTree.update(i, leftRight + 1, (rightValue - leftValue + ALPHABET_SIZE) % ALPHABET_SIZE);\n        }\n        addRange(leftRight, n - rightLeft - 2);\n      } else if (!leftSetList.get(i).isEmpty()) {\n        int leftRight = getMinAndUpdate(leftSetList, i);\n        if (leftValue != rightValue) {\n          segmentTree.update(i, leftRight + 1, (rightValue - leftValue + ALPHABET_SIZE) % ALPHABET_SIZE);\n        }\n      } else if (!rightSetList.get(i).isEmpty()) {\n        int rightLeft = getMinAndUpdate(rightSetList, i);\n        if (leftValue != rightValue) {\n          segmentTree.update(n - 1 - rightLeft, n - i, (leftValue - rightValue + ALPHABET_SIZE) % ALPHABET_SIZE);\n        }\n      } else if (leftValue != rightValue) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, ContestWriter out) {\n    char[] cs = reader.nextCharArray();\n    int n = reader.nextInt();\n    int[][] lrs = reader.nextInt(n, 2);\n    out.println(new Solver(cs, n, lrs).solve() ? \"YES\" : \"NO\");\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\n// Verify ABC177 F\n// https://atcoder.jp/contests/abc177/tasks/abc177_f\n\nclass UpdateRangeGetRangeSegmentTree<LazyType, ValueType> {\n  public interface Operator<LazyType, ValueType> {\n    LazyType multiplyLazyValue(LazyType lazy, int count);\n    LazyType applyOffset(LazyType lazy, int offset);\n    LazyType mergeLazyValue(LazyType oldLazy, LazyType newLazy);\n    ValueType apply(ValueType value, LazyType lazy);\n    ValueType mergeValue(ValueType smallIndexValue, ValueType largeIndexValue);\n    ValueType getUnitValue();\n  }\n  \n  private final Operator<LazyType, ValueType> operator;\n  private final int n;\n  private final LazyType[] lazies;\n  private final ValueType[] values;\n  \n  public UpdateRangeGetRangeSegmentTree(Operator<LazyType, ValueType> operator, ValueType[] initialValues) {\n    this.operator = operator;\n    \n    int tempN = 1;\n    while (tempN < initialValues.length) {\n      tempN *= 2;\n    }\n    n = tempN;\n    lazies = createTArray(2 * n -1);\n    values = createSArray(2 * n -1);\n    for (int i = 0; i < initialValues.length; i++) {\n      values[i + n - 1] = initialValues[i];\n    }\n    for (int i = initialValues.length; i < n; i++) {\n      values[i + n - 1] = this.operator.getUnitValue();\n    }\n    for (int i = n - 2; i >= 0; i--) {\n      values[i] = this.operator.mergeValue(values[2 * i + 1], values[2 * i + 2]);\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private LazyType[] createTArray(int size) {\n    return (LazyType[])(new Object[size]);    \n  }\n  \n  @SuppressWarnings(\"unchecked\")\n  private ValueType[] createSArray(int size) {\n    return (ValueType[])(new Object[size]);    \n  }\n  \n  private void eval(int k, int l, int r) {\n    if (lazies[k] == null) {\n      return;\n    }\n    values[k] = operator.apply(values[k], operator.multiplyLazyValue(lazies[k], r - l));\n    if (r - l > 1) {\n      lazies[2 * k + 1] = operator.mergeLazyValue(lazies[2 * k + 1], lazies[k]);\n      lazies[2 * k + 2] = operator.mergeLazyValue(lazies[2 * k + 2], operator.applyOffset(lazies[k], (r - l) / 2));\n    }\n    lazies[k] = null;\n  }\n  \n  private void update(int a, int b, LazyType lazy, int k, int l, int r) {\n    eval(k, l, r);\n    if (b <= l || r <= a) {\n      return;\n    }\n    if (a <= l && r <= b) {\n      lazies[k] = operator.mergeLazyValue(lazies[k], lazy);\n      eval(k, l, r);\n    } else {\n      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, operator.applyOffset(lazy, (r - l) / 2), 2 * k + 2, (l + r) / 2, r);\n      values[k] = operator.mergeValue(values[2 * k + 1], values[2 * k + 2]);\n    }\n  }\n  \n  public void update(int a, int b, LazyType lazy) {\n    update(a, b, lazy, 0, 0, n);\n  }\n  \n  public void update(int a, LazyType lazy) {\n    update(a, a + 1, lazy);\n  }\n  \n  private ValueType getRange(int a, int b, int k, int l, int r) {\n    if (b <= l || r <= a) {\n      return operator.getUnitValue();\n    }\n    eval(k, l, r);\n    if (a <= l && r <= b) {\n      return values[k];\n    }\n    ValueType vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);\n    ValueType vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);\n    return operator.mergeValue(vl, vr);\n  }\n  \n  public ValueType getRange(int a, int b) {\n    return getRange(a, b, 0, 0, n);\n  }\n  \n  public ValueType get(int a) {\n    return getRange(a, a + 1);\n  }\n\n  private void dump(Object[] objects) {\n    int sum = 0;\n    for (int i = 0; sum + (1 << i) <= 2 * n - 1; sum += 1 << i, i++) {\n      for (int j = sum; j < sum + (1 << i); j++) {\n        System.err.print(objects[j]);\n        System.err.print(\" \");\n      }\n      System.err.println();\n    }\n    System.err.println();\n  }\n  \n  public void dump() {\n    System.err.println(\"values: \");\n    dump(values);\n    System.err.println(\"lazies: \");\n    dump(lazies);\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            char[] s = new char[100000];\n            int len = in.readString(s, 0);\n            Node[] nodes = new Node[len];\n            int mod = 'z' - 'a' + 1;\n            for (int i = 0; i < len; i++) {\n                nodes[i] = new Node();\n                nodes[i].val = s[i] - 'a';\n            }\n\n            int n = in.readInt();\n            Interval[] intervals = new Interval[n];\n            for (int i = 0; i < n; i++) {\n                intervals[i] = new Interval();\n                intervals[i].id = i;\n                intervals[i].l = in.readInt() - 1;\n                intervals[i].r = in.readInt() - 1;\n            }\n            ModifiableHash h31 = new ModifiableHash(31, n);\n            ModifiableHash h11 = new ModifiableHash(11, n);\n            LongHashMap map = new LongHashMap(n * 2, true);\n\n            Interval[] intervalsSortByL = intervals.clone();\n            Interval[] intervalsSortByR = intervals.clone();\n            Arrays.sort(intervalsSortByL, (a, b) -> a.l - b.l);\n            Arrays.sort(intervalsSortByR, (a, b) -> a.r - b.r);\n            int lHead = 0;\n            int rHead = 0;\n            for (int i = 0; i < len; i++) {\n                while (lHead < n && intervalsSortByL[lHead].l <= i) {\n                    h31.modify(intervalsSortByL[lHead].id, 1);\n                    h11.modify(intervalsSortByL[lHead].id, 1);\n                    lHead++;\n                }\n                while (rHead < n && intervalsSortByR[rHead].r < i) {\n                    h31.modify(intervalsSortByR[rHead].id, -1);\n                    h11.modify(intervalsSortByR[rHead].id, -1);\n                    rHead++;\n                }\n                long state = DigitUtils.asLong(h11.hash(0, n - 1), h31.hash(0, n - 1));\n                if (!map.containKey(state)) {\n                    map.put(state, i);\n                    continue;\n                }\n                int index = (int) map.get(state);\n                Node.merge(nodes[index], nodes[i], nodes[i].val - nodes[index].val);\n            }\n            int l = 0;\n            int r = len - 1;\n            while (l < r) {\n                Node a = nodes[l++];\n                Node b = nodes[r--];\n                if (a.find() == b.find()) {\n                    int differ = a.dist - b.dist;\n                    if (differ % mod != 0) {\n                        out.println(\"NO\");\n                        return;\n                    }\n                    continue;\n                }\n                Node.merge(a.find(), b.find(), 0);\n            }\n\n            out.println(\"YES\");\n        }\n\n    }\n\n    static class Node {\n        Node p = this;\n        int rank = 0;\n        int dist;\n        int val;\n\n        Node find() {\n            if (p == p.p) {\n                return p;\n            }\n            p.find();\n            dist += p.dist;\n            p = p.find();\n            return p;\n        }\n\n        static void merge(Node a, Node b, int bSubA) {\n            a.find();\n            bSubA += a.dist;\n            a = a.find();\n            b.find();\n            bSubA -= b.dist;\n            b = b.find();\n            if (a == b) {\n                return;\n            }\n            if (a.rank == b.rank) {\n                a.rank++;\n            }\n            if (a.rank < b.rank) {\n                Node tmp = a;\n                a = b;\n                b = tmp;\n                bSubA = -bSubA;\n            }\n            b.p = a;\n            b.dist = bSubA;\n        }\n\n    }\n\n    static class ModBIT {\n        private int[] data;\n        private int n;\n        private Modular modular;\n\n        public ModBIT(int n, Modular mod) {\n            this.n = n;\n            data = new int[n + 1];\n            this.modular = mod;\n        }\n\n        public int query(int i) {\n            long sum = 0;\n            for (; i > 0; i -= i & -i) {\n                sum += data[i];\n            }\n            return modular.valueOf(sum);\n        }\n\n        public void update(int i, int mod) {\n            if (i <= 0) {\n                return;\n            }\n            for (; i <= n; i += i & -i) {\n                data[i] = modular.plus(data[i], mod);\n            }\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 1; i <= n; i++) {\n                builder.append(query(i) - query(i - 1)).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class ModifiableHash {\n        public static final Modular MOD = new Modular((int) (1e9 + 7));\n        public static final Power POWER = new Power(MOD);\n        private int[] inverse;\n        private int[] xs;\n        private ModBIT bit;\n\n        public ModifiableHash(int x, int n) {\n            xs = new int[n + 1];\n            inverse = new int[n + 1];\n            bit = new ModBIT(n, MOD);\n\n            xs[0] = 1;\n            inverse[0] = 1;\n            int invX = POWER.inverse(x);\n            for (int i = 1; i <= n; i++) {\n                xs[i] = MOD.mul(xs[i - 1], x);\n                inverse[i] = MOD.mul(inverse[i - 1], invX);\n            }\n        }\n\n        public void modify(int i, int v) {\n            bit.update(i + 1, MOD.mul(v, xs[i]));\n        }\n\n        public int hash(int l, int r) {\n            int h = bit.query(r + 1);\n            if (l > 0) {\n                h = MOD.subtract(h, bit.query(l));\n                h = MOD.mul(h, inverse[l]);\n            }\n            return h;\n        }\n\n    }\n\n    static class LongHashMap {\n        private int[] slot;\n        private int[] next;\n        private long[] keys;\n        private long[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n\n        public LongHashMap(int cap, boolean rehash) {\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            values = new long[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            size++;\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.mask = newMask;\n        }\n\n        private int hash(long x) {\n            int h = Long.hashCode(x);\n            return h ^ (h >>> 16);\n        }\n\n        public void put(long x, long y) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = y;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = y;\n                } else {\n                    values[index] = y;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public boolean containKey(long x) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                return false;\n            }\n            return keys[findIndexOrLastEntry(s, x)] == x;\n        }\n\n        public long getOrDefault(long x, long def) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? values[index] : def;\n        }\n\n        public long get(long x) {\n            return getOrDefault(x, 0);\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public LongEntryIterator iterator() {\n            return new LongEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public long getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            LongEntryIterator iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static long asLong(int high, int low) {\n            return (((long) high) << 32) | low;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface LongEntryIterator {\n        boolean hasNext();\n\n        void next();\n\n        long getEntryKey();\n\n        long getEntryValue();\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, long n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n        public int inverse(int x) {\n            return pow(x, modular.m - 2);\n        }\n\n    }\n\n    static class Interval {\n        int l;\n        int r;\n        int id;\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing C = System.Int32;\nusing System.Runtime.CompilerServices;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            const int M = 26;\n            var str = 'a' + rs + 'a';\n            var n = str.Length - 1;\n            var a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = (M + str[i + 1] - str[i]) % M;\n            var s = new DisjointSet(n);\n            var k = ri;\n            for (int i = 0; i < k; i++) {\n                var l = ri - 1;\n                var r = ri;\n                s.Unite(l, r);\n            }\n            Debug.WriteLine(a.AsJoinedString());\n            var sum = new int[n];\n            var cnt = new int[n];\n            for (int i = 0; i < n; i++) {\n                sum[s[i]] = (sum[s[i]] + a[i]) % M;\n                cnt[s[i]]++;\n            }\n            for (int l = 0, r = n - 1; l <= r; l++, r--) {\n                if (!s.IsUnited(l, r)) {\n                    var u = sum[s[l]];\n                    var v = sum[s[r]];\n                    sum[s[l]] = sum[s[r]] = 0;\n                    s.Unite(l, r);\n                    sum[s[l]] = (u + v) % M;\n                }\n            }\n            for (int i = 0; i < n; i++)\n                if (sum[s[i]] != 0) {\n                    Console.WriteLine(\"NO\");\n                    return;\n                }\n            Console.WriteLine(\"YES\");\n\n\n        }\n        public const long Mod = 998244353;\n\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.datastructure.unionfind;\n\nint M = 26;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    string _s;\n    sc.read(_s);\n    int[] s = _s.map!(a => (a - 'a').to!int).array;\n    debug writeln(s);\n    int ba = 0;\n    foreach (ref x; s) {\n        int c = x;\n        x = (x - ba + M) % M;\n        ba = c;\n    }\n    debug writeln(s);\n    int n = s.length.to!int;\n    UnionFind uf = UnionFind(n+1);\n\n    int q;\n    sc.read(q);\n    foreach (i; 0..q) {\n        int a, b;\n        sc.read(a, b);\n        a--;\n        uf.merge(a, b);\n    }\n    foreach (i; 0..n) {\n        uf.merge(i, n-i);\n    }\n    bool[] used = new bool[n+1];\n    foreach (i; 0..n) {\n        if (used[i]) continue;\n        auto v = uf.group(i);\n        foreach (d; v) used[d] = true;\n        int sm = 0;\n        foreach (d; v) {\n            if (d == n) {\n                sm = 0;\n                break;\n            }\n            sm += s[d];\n            sm %= M;\n        }\n        if (sm) {\n            writeln(\"NO\");\n            return 0;\n        }\n        debug writeln(v, \" \", sm);\n    }\n    writeln(\"YES\");\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/datastructure/unionfind.d */\n// module dcomp.datastructure.unionfind;\n\n \nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    import std.conv : to;\n    int[] id;  \n    int[][] groups;  \n    int count;  \n     \n    this(size_t n) {\n        id = iota(n.to!int).array;\n        groups = iota(n.to!int).map!(a => [a]).array;\n        count = n.to!int;\n    }\n     \n    void merge(size_t a, size_t b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n     \n    int[] group(size_t i) {\n        return groups[id[i]];\n    }\n     \n    bool same(size_t a, size_t b) {\n        return id[a] == id[b];\n    }\n}\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1;\n    v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nvoid main() {\n    auto S = 'a' ~ readln.chomp ~ 'a';\n    auto N = readln.chomp.to!int;\n    auto A = iota(N).map!(_ => readln.split.map!(to!int).array).array;\n\n    auto M = S.length.to!int;\n    auto B = (M-1).iota.map!(i => ((S[i].to!int - S[i+1].to!int) % 26 + 26) % 26).array;\n\n    auto uf = new UnionFind(M-1);\n\n    foreach (i; 0..(M-1)/2) {\n        uf.unite(i, M-i-2);\n    }\n\n    foreach (a; A) {\n        uf.unite(a[0]-1, a[1]);\n    }\n\n    foreach (i; 0..M-1) if (uf.table[i] < 0) {\n        if (uf.group[i].map!(j => B[j]).sum % 26 != 0) {\n            writeln(\"NO\");\n            return;\n        }\n    }\n\n    writeln(\"YES\");\n}\n\n\nclass UnionFind {\n    int N;\n    int[] table;\n    int[][] group;\n\n    this(int n) {\n        N = n;\n        table = new int[](N);\n        fill(table, -1);\n        group = N.iota.map!(i => [i]).array;\n    }\n\n    int find(int x) {\n        return table[x] < 0 ? x : (table[x] = find(table[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (table[x] > table[y]) swap(x, y);\n        group[x] ~= group[y];\n        group[y] = [];\n        table[x] += table[y];\n        table[y] = x;\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nclass UnionFindTree {\npublic:\n    this(size_t n) {\n        parent = iota(n).array();\n        rank = new size_t[](n);\n    }\n    size_t find(size_t n) {\n        if(n == parent[n]) {\n            return n;\n        } else {\n            parent[n] = find(parent[n]);\n            return parent[n];\n        }\n    }\n    void unite(size_t n, size_t m) {\n        auto p1 = find(n);\n        auto p2 = find(m);\n        if(n == m) {\n            return;\n        }\n        if(rank[p1] < rank[p2]) {\n            swap(p1, p2);\n        }\n        if(rank[p1] == rank[p2]) {\n            ++rank[p1];\n        }\n        parent[p2] = p1;\n    }\nprivate:\n    size_t[] parent;\n    size_t[] rank;\n}\nunittest {\n    auto uft = new UnionFindTree(10);\n    foreach(i; iota(10)) {\n        assert(uft.find(i) == i);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0).drop(1)) {\n        uft.unite(i, i-3);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0)) {\n        assert(uft.find(0) == uft.find(i));\n    }\n    foreach(i; iota(10).filter!(a => a%3 != 0)) {\n        assert(uft.find(0) != uft.find(i));\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\nbool test1(int[] s, long l, long r, long n) {\n    int offset = (26 + s[l] - s[r])%26;\n    foreach(i; iota(n)) {\n        if(s[l+i] != (s[r-i] + offset) % 26) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool test(int[] s, long[][] lr, long lOffset, long rOffset) {\n    if(lOffset + rOffset + 1 >= s.length) {\n        return true;\n    }\n    foreach(ref lri; lr) {\n        if(lri[0] <= lOffset && lri[1] < s.length - rOffset - 1) {\n            lri[0] = lri[1]+1;\n            lri[1] = s.length - rOffset - 1;\n        }\n        if(lri[1] >= s.length - rOffset - 1 && lri[0] > lOffset) {\n            lri[1] = lri[0]-1;\n            lri[0] = lOffset;\n        }\n    }\n    long len = s.length;\n    foreach(lri; lr) {\n        if(lOffset < lri[0] && lri[1] < s.length - rOffset - 1) {\n            len = min(len, lOffset - lri[0], s.length - rOffset - 1 - lri[1]);\n        }\n    }\n    if(!test1(s, lOffset, s.length - rOffset - 1, len)) {\n        return false;\n    }\n    return test(s, lr, lOffset + len, rOffset + len);\n\n}\n\nvoid main(){\n    auto S = readln().chomp();\n    auto s = S.map!(a => (a - 'a').to!int)().array();\n\n    auto n = readLong();\n    long[][] lr;\n    foreach(i; iota(n)) {\n        lr ~= readLongs();\n    }\n    writeln(test(s, lr, 0, 0) ? \"YES\": \"NO\");\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nclass UnionFindTree {\npublic:\n    this(size_t n) {\n        parent = iota(n).array();\n        rank = new size_t[](n);\n    }\n    size_t find(size_t n) {\n        if(n == parent[n]) {\n            return n;\n        } else {\n            parent[n] = find(parent[n]);\n            return parent[n];\n        }\n    }\n    void unite(size_t n, size_t m) {\n        auto p1 = find(n);\n        auto p2 = find(m);\n        if(n == m) {\n            return;\n        }\n        if(rank[p1] < rank[p2]) {\n            swap(p1, p2);\n        }\n        if(rank[p1] == rank[p2]) {\n            ++rank[p1];\n        }\n        parent[p2] = p1;\n    }\nprivate:\n    size_t[] parent;\n    size_t[] rank;\n}\nunittest {\n    auto uft = new UnionFindTree(10);\n    foreach(i; iota(10)) {\n        assert(uft.find(i) == i);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0).drop(1)) {\n        uft.unite(i, i-3);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0)) {\n        assert(uft.find(0) == uft.find(i));\n    }\n    foreach(i; iota(10).filter!(a => a%3 != 0)) {\n        assert(uft.find(0) != uft.find(i));\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\nbool test1(int[] s, long l, long r, long n) {\n    int offset = (26 + s[l] - s[r])%26;\n    foreach(i; iota(n)) {\n        if(s[l+i] != (s[r-i] + offset) % 26) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool test(int[] s, long[][] lr, long lOffset, long rOffset) {\n    if(lOffset + rOffset + 1 >= s.length) {\n        return true;\n    }\n    foreach(ref lri; lr) {\n        if(lri[0] <= lOffset && lri[1] < s.length - rOffset - 1) {\n            lri[0] = lri[1];\n            lri[1] = s.length - rOffset - 1;\n        }\n        if(lri[1] >= s.length - rOffset - 1 && lri[0] > lOffset) {\n            lri[1] = lri[0];\n            lri[0] = lOffset;\n        }\n    }\n    long len = s.length;\n    foreach(lri; lr) {\n        if(lOffset < lri[0] && lri[1] < s.length - rOffset - 1) {\n            len = min(len, lOffset - lri[0], s.length - rOffset - 1 - lri[1]);\n        }\n    }\n    if(!test1(s, lOffset, s.length - rOffset - 1, len)) {\n        return false;\n    }\n    return test(s, lr, lOffset + len, rOffset + len);\n\n}\n\nvoid main(){\n    auto S = readln().chomp();\n    auto s = S.map!(a => (a - 'a').to!int)().array();\n\n    auto n = readLong();\n    long[][] lr;\n    foreach(i; iota(n)) {\n        lr ~= readLongs();\n    }\n    writeln(test(s, lr, 0, 0) ? \"YES\": \"NO\");\n}\n\n"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\nsys.setrecursionlimit(10**5)\nn=len(S)\nN=int(input())\nk=n//2\n\ndef solve(Edge):\n    edge=[[] for i in range(k+1)]\n    for l,r,i in Edge:\n        if l==0 and r==0:\n            continue\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif n%2==0:\n    Edge=[]\n    for i in range(N):\n        l,r=map(int,input().split())\n        Edge.append((l,r,i))\n    solve(Edge)\nelse:\n    Edge=[]\n    for i in range(N):\n        l,r=map(int,input().split())\n        if l==k+1 and r==k+1:\n            Edge.append((0,0,i))\n        elif l==k+1:\n            r-=1\n            Edge.append((l,r,i))\n        elif r==k+1:\n            r-=1\n            Edge.append((l,r,i))\n        elif l>k+1:\n            l-=1;r-=1\n            Edge.append((l,r,i))\n        elif r>k+1:\n            r-=1\n            Edge.append((l,r,i))\n        else:\n            Edge.append((l,r,i))\n    solve(Edge)\n"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\n\ninput=sys.stdin.buffer.readline\nsys.setrecursionlimit(10**5)\n\n\nn=len(S)\nN=int(input())\nk=n//2\n\n\n\nif n%2==0:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif l==k:\n            R=k-1\n            L=n-1-r\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        elif r==k:\n            edge[l].append((k,1,i))\n            edge[k].append((l,-1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n            r%=26\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\nsys.setrecursionlimit(10**5)\nn=len(S)\nN=int(input())\nk=n//2\n\n\n\nif n%2==0:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif l==k:\n            R=k-1\n            L=n-1-r\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        elif r==k:\n            edge[l].append((k,1,i))\n            edge[k].append((l,-1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/cf17-final/tasks/cf17_final_e\n\n回文をちゃんと定義しよう？\n左の文字を何回変化させたら右になるか、をxとする\niを並べた時、対象の部分の和は26(の倍数)でなくてはならない\nただし、xの列が奇数調なら真ん中は0\n\nabba なら\n1,0,25\n\nすると、l,rは2点を更新するだけになる\nindex l-1を+1し、rを-1する(mod26せよ,1-origin)\n左右反転した部分の和を配列yとしてもつ(mod26)\nすると、配列の2つの部分に+1,-1する操作を好きな回数だけ行って全て\n26の倍数にせよという問題になる。\n\n+→-の有向グラフで考える\nまず、連結成分ごとに全てのノードの初期値の総和が26の倍数で無いなら不可能\nそうでなければ可能(端から合わせていけば絶対つじつまが合うため)\n解けたのでは？\nあ、ただし、-1 or len(S-1)とリンクしてる連結成分は26の倍数でなくてもよい\n1-indexedのほうがいいか？\n0 or len(S)とリンクしてる連結成分は26の倍数でなくてもよい\n\n\"\"\"\nimport sys\nsys.setrecursionlimit(200000)\nalp = \"abcdefghijklmnopqrstuvwxyz\"\nad = {}\nfor i in range(26):\n    ad[alp[i]] = i\n\nS = input()\nx = []\n\nfor i in range(len(S)-1):\n    x.append((ad[S[i+1]]-ad[S[i]]) % 26)\n\ny = [0]\nfor j in range((len(x)+1)//2):\n\n    j2 = len(x)-1-j\n\n    if j != j2:\n        y.append(x[j]+x[j2])\n    else:\n        y.append(x[j])\n\n#print (x,y)\nN = int(input())\n\nlis = [ [] for i in range(len(y)) ] #連結リスト\nfor loop in range(N):\n    \n    l,r = map(int,input().split())\n    l -= 1\n\n    l = min( l , len(x)+1-l )\n    r = min( r , len(x)+1-r )\n\n    lis[l].append(r)\n    lis[r].append(l)\n\n#print (lis)\n\ndef dfs(v):\n    ret = y[v]\n    visit[v] = True\n    for nex in lis[v]:\n        if not visit[nex]:\n            ret += dfs(nex)\n    return ret\n\nvisit = [False] * len(lis)\nans = \"YES\"\nfor i in range(len(lis)):\n\n    if visit[i]:\n        continue\n    rec = dfs(i)\n    if i != 0 and rec % 26 != 0:\n        ans = \"NO\"\n        break\n\nprint (ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\nS = [ord(x)-ord('a') for x in readline().rstrip()]\nN = int(readline())\nLR = (tuple(int(x)-1 for x in line.split()) for line in readlines())\n\nLS = len(S)\nM = (LS+1)//2\n\n# 左側の区間内の反転に帰着\n\nL_to_R = [[] for _ in range(M+1)]\nfor L,R in LR:\n    if R <= M:\n        pass\n    elif M<L:\n        L,R = LS-1-R,LS-1-L\n    elif L+R > LS-1:\n        L,R = LS-1-R,L-1\n    elif L+R <= LS-1:\n        L,R = L,LS-R-2\n    if L<=R:\n        L_to_R[L].append(R)\n\nbl = True\nadd = 0\ndiff_add = [0] * (LS+1)\nfor L in range(LS//2):\n    add += diff_add[L]\n    left = S[L]\n    right = S[LS-L-1]\n    arr = sorted(set(L_to_R[L]))\n    if len(arr) == 0:\n        if (left + add) % 26 != right:\n            bl = False\n            break\n    else:\n        R0 = arr[0]\n        for R in arr[1:]:\n            L_to_R[R0+1].append(R)\n        n = (right-left-add)%26\n        add += n\n        diff_add[R0+1] -= n\n\nanswer = 'YES' if bl else 'NO'\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\nsys.setrecursionlimit(10**5)\nn=len(S)\nN=int(input())\nk=n//2\n\ndef solve(Edge):\n    edge=[[] for i in range(k+1)]\n    for l,r,i in Edge:\n        if l==0 or r==0:\n            continue\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif n%2==0:\n    Edge=[]\n    for i in range(N):\n        l,r=map(int,input().split())\n        Edge.append((l,r,i))\n    solve(Edge)"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n            r%=26\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\nsys.setrecursionlimit(10**5)\nn=len(S)\nN=int(input())\nk=n//2\n\n\n\nif n%2==0:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif l==k:\n            R=k-1\n            L=n-1-r\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        elif r==k:\n            edge[l].append((k,1,i))\n            edge[k].append((l,-1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\nsys.setrecursionlimit(10**5)\nn=len(S)\nN=int(input())\nk=n//2\n\n\n\nif n%2==0:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    edge=[[] for i in range(k+1)]\n    for i in range(N):\n        l,r=map(int,input().split())\n        l-=1;r-=1;\n        if l>k:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif l==k:\n            R=k-1\n            L=n-1-r\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        elif r==k:\n            edge[l].append((k,1,i))\n            edge[k].append((l,-1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\nsys.setrecursionlimit(10**5)\nn=len(S)\nN=int(input())\nk=n//2\n\ndef solve(Edge):\n    edge=[[] for i in range(k+1)]\n    for l,r,i in Edge:\n        if l==0 or r==0:\n            continue\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif n%2==0:\n    Edge=[]\n    for i in range(N):\n        l,r=map(int,input().split())\n        Edge.append((l,r,i))\n    solve(Edge)\nelse:\n    Edge=[]\n    for i in range(N):\n        l,r=map(int,input().split())\n        if l==r==k+1:\n            Edge.append((0,0,i))\n        elif l==k+1:\n            r-=1\n            Edge.append((l,r,i))\n        elif r==k+1:\n            r-=1\n            Edge.append((l,r,i))\n        elif l>k+1:\n            l-=1;r-=1\n            Edge.append((l,r,i))\n        elif r>k+1:\n            r-=1\n            Edge.append((l,r,i))\n        else:\n            Edge.append((l,r,i))\n    solve(Edge)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/cf17-final/tasks/cf17_final_e\n\n回文をちゃんと定義しよう？\n左の文字を何回変化させたら右になるか、をxとする\niを並べた時、対象の部分の和は26(の倍数)でなくてはならない\nただし、xの列が奇数調なら真ん中は0\n\nabba なら\n1,0,25\n\nすると、l,rは2点を更新するだけになる\nindex l-1を+1し、rを-1する(mod26せよ,1-origin)\n左右反転した部分の和を配列yとしてもつ(mod26)\nすると、配列の2つの部分に+1,-1する操作を好きな回数だけ行って全て\n26の倍数にせよという問題になる。\n\n+→-の有向グラフで考える\nまず、連結成分ごとに全てのノードの初期値の総和が26の倍数で無いなら不可能\nそうでなければ可能(端から合わせていけば絶対つじつまが合うため)\n解けたのでは？\nあ、ただし、-1 or len(S-1)とリンクしてる連結成分は26の倍数でなくてもよい\n1-indexedのほうがいいか？\n0 or len(S)とリンクしてる連結成分は26の倍数でなくてもよい\n\n\"\"\"\nimport sys\nsys.setrecursionlimit(200000)\nalp = \"abcdefghijklmnopqrstuvwxyz\"\nad = {}\nfor i in range(26):\n    ad[alp[i]] = i\n\nS = input()\nx = []\n\nfor i in range(len(S)-1):\n    x.append((ad[S[i+1]]-ad[S[i]]) % 26)\n\ny = [0]\nfor j in range((len(x)+1)//2):\n\n    j2 = len(x)-1-j\n\n    if j != j2:\n        y.append(x[j]+x[j2])\n    else:\n        y.append(x[j])\n\n#print (x,y)\nN = int(input())\n\nlis = [ [] for i in range(len(y)) ] #連結リスト\nfor loop in range(N):\n    \n    l,r = map(int,input().split())\n    l -= 1\n\n    l = min( l , len(x)+1-l )\n    r = min( r , len(x)+1-r )\n\n    lis[l].append(r)\n    lis[r].append(l)\n\n#print (lis)\n\ndef dfs(v):\n    ret = y[v]\n    visit[v] = True\n    for nex in lis[v]:\n        if not visit[nex]:\n            ret += dfs(nex)\n    return ret\n\nvisit = [False] * len(lis)\nans = \"YES\"\nfor i in range(len(lis)):\n\n    if visit[i]:\n        continue\n    rec = dfs(i)\n    if i != 0 and rec % 26 != 0:\n        ans = \"NO\"\n        break\n\nprint (ans)\n"
  },
  {
    "language": "Python",
    "code": "def solveequation(edge,ans,n,m):\n    #edge=[[to,dire,id]...]\n    x=[0]*m\n    used=[False]*n\n\n    def dfs(v):\n        used[v]=True\n        r=ans[v]\n        for to,dire,id in edge[v]:\n            if used[to]:\n                continue\n            y=dfs(to)\n            if dire==-1:\n                x[id]=y\n            else:\n                x[id]=-y\n            r+=y\n        return r\n\n    for v in range(n):\n        if used[v]:\n            continue\n        y=dfs(v)\n        if y%26!=0:\n            return False\n    return x\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nalpha={i:e for e,i in enumerate(alphabetlist)}\n\n\nimport sys\n\nS=input()\n\ninput=sys.stdin.buffer.readline\nsys.setrecursionlimit(10**5)\n\n\nn=len(S)\nN=int(input())\nk=n//2\n\ndef solve(Edge):\n    edge=[[] for i in range(k+1)]\n    for l,r,i in Edge:\n        if l==0 or r==0:\n            continue\n        l-=1;r-=1;\n        if l>k-1:\n            L=n-1-r\n            R=n-1-l\n            edge[L].append((R+1,-1,i))\n            edge[R+1].append((L,1,i))\n        elif r>k-1:\n            R=n-1-r\n            if R>l:\n                edge[l].append((R,1,i))\n                edge[R].append((l,-1,i))\n            elif l>R:\n                edge[l].append((R,-1,i))\n                edge[R].append((l,1,i))\n        else:\n            edge[l].append((r+1,1,i))\n            edge[r+1].append((l,-1,i))\n    ans=[alpha[S[i]]-alpha[S[-i-1]] for i in range(k)]\n    ans+=[0]\n    for i in range(k,0,-1):\n        ans[i]-=ans[i-1]\n    res=solveequation(edge,ans,k+1,N)\n    if res:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif n%2==0:\n    Edge=[]\n    for i in range(N):\n        l,r=map(int,input().split())\n        Edge.append((l,r,i))\n    solve(Edge)\nelse:\n    Edge=[]\n    for i in range(N):\n        l,r=map(int,input().split())\n        if l==r==k+1:\n            Edge.append((0,0,i))\n        elif l==k+1:\n            r-=1\n            Edge.append((l,r,i))\n        elif r==k+1:\n            r-=1\n            Edge.append((l,r,i))\n        elif l>k+1:\n            l-=1;r-=1\n            Edge.append((l,r,i))\n        elif r>k+1:\n            r-=1\n            Edge.append((l,r,i))\n        else:\n            Edge.append((l,r,i))\n    solve(Edge)"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\n/**\n * Union-Find tree.\n * Verified by https://atcoder.jp/contests/keyence2019/submissions/4071067\n */\nstruct UnionFind { disj: Vec<usize>, rank: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let disj = (0..n).collect();\n        UnionFind { disj: disj, rank: vec![0; n] }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        self.disj[x]\n    }\n    fn unite(&mut self, x: usize, y: usize) {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y { return }\n        if self.rank[x] > self.rank[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.disj[x] = y;\n        self.rank[y] = std::cmp::max(self.rank[y], self.rank[x] + 1);\n    }\n    #[allow(unused)]\n    fn is_same_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        s: chars,\n        lr: [(usize1, usize)],\n    }\n    let m = s.len();\n    let mut uf = UnionFind::new(m + 1);\n    for &(l, r) in &lr {\n        uf.unite(l, r);\n    }\n    for i in 0..m {\n        uf.unite(i, m - i);\n    }\n    let mut sum = vec![0; m + 1];\n    for i in 0..m + 1 {\n        sum[uf.root(i)] += if i == m { 0 } else { s[i] as i32 }\n        - if i == 0 { 0 } else { s[i - 1] as i32 };\n        sum[uf.root(i)] %= 26;\n        sum[uf.root(i)] += 26;\n        sum[uf.root(i)] %= 26;\n    }\n    puts!(\"{}\\n\", if sum.iter().all(|&x| x == 0) { \"YES\" } else { \"NO\" });\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]