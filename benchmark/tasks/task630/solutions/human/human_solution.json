[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\nint main() {\n    multiset<ll> a;\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int command;\n        ll x;\n        cin >> command >> x;\n\n        if (command == 0) {\n            a.insert(x);\n            cout << a.size() << endl;\n        } else if (command == 1) {\n            cout << a.count(x) << endl;\n        } else if (command == 2) {\n            a.erase(x);\n        } else if (command == 3) {\n            ll l, r;\n            l = x;\n            cin >> r;\n            for (auto it = a.lower_bound(l); it != a.end() && *it <= r; it++) {\n                cout << *it << endl;\n            }\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\nunsigned long xor128() {\n  static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;\n  unsigned long t=(x^(x<<11));\n  x=y; y=z; z=w;\n  return ( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\ntemplate <class T>\nclass Treap {\n    std::size_t size_ = 0;\n    struct Node {\n        T key;\n        int priority;\n        Node *l, *r;\n        Node(T key, int priority) : key(key), priority(priority), l(nullptr), r(nullptr) {}\n    } *root = nullptr;\n    using Tree = Node *;\n\n    void split(Tree t, T key, Tree& l, Tree& r, bool by_upper_bound) {\n        if (!t) {\n            l = r = nullptr;\n        } else if (key < t->key || (key == t->key && !by_upper_bound)) {\n            split(t->l, key, l, t->l, by_upper_bound), r = t;\n        } else {\n            split(t->r, key, t->r, r, by_upper_bound), l = t;\n        }\n    }\n\n    void split_by_lower_bound(Tree t, T key, Tree& l, Tree& r) {\n      split(t,key,l,r,false);\n    }\n    void split_by_upper_bound(Tree t, T key, Tree& l, Tree& r) {\n      split(t,key,l,r,true);\n    }\n    void split_into_tree_parts(Tree t, T key, Tree& l, Tree& c, Tree& r) {\n      Tree tmp;\n      split_by_lower_bound(t, key, l, tmp);\n      split_by_upper_bound(tmp, key, c, r);\n    }\n\n    void merge(Tree& t, Tree l, Tree r) {\n      if (!l || !r) {\n        t = l ? l : r;\n      } else if (l->priority > r->priority) {\n        merge(l->r, l->r, r), t = l;\n      } else {\n        merge(r->l, l, r->l), t = r;\n      }\n    }\n    void merge_three_trees(Tree& t, Tree l, Tree c, Tree r) {\n      Tree tmp;\n      merge(tmp, c, r);\n      merge(t, l, tmp);\n    }\n\n    void insert(Tree& t, Tree item) {\n      if (!t) {\n        t = item;\n      } else if (item->priority > t->priority) {\n        split_by_lower_bound(t, item->key, item->l, item->r), t = item;\n      } else {\n        insert(item->key < t->key ? t->l : t->r, item);\n      }\n    }\n\n    void erase(Tree& t, T key) {\n      Tree l,r,c;\n      split_into_tree_parts(t, key, l, c, r);\n      merge(t, l, r);\n      size_ -= nuke(c);\n    }\n\n    std::size_t find(Tree& t, T key) {\n      Tree l,r,c;\n      split_into_tree_parts(t, key, l, c, r);\n      std::size_t ans = count(c);\n      merge_three_trees(t, l, c, r);\n      return ans;\n    }\n\n    std::size_t nuke(Tree t) {\n      if (!t) return 0;\n      std::size_t ret = 1;\n      ret += nuke(t->l);\n      ret += nuke(t->r);\n      delete t;\n      return ret;\n    }\n\n    std::size_t count(Tree t) {\n      if (!t) return 0;\n      std::size_t ret = 1;\n      ret += count(t->l);\n      ret += count(t->r);\n      return ret;\n    }\n\n    void collect_(std::vector< T >& v, Tree t) {\n      if (!t) return;\n      collect_(v, t->l);\n      v.emplace_back(t->key);\n      collect_(v, t->r);\n    }\n\n  public:\n    std::size_t size() const { return size_; }\n\n    void insert(T key) {\n      size_++;\n      insert(root, new Node(key, xor128()));\n    }\n\n    void erase(T key) {\n      erase(root, key);\n    }\n\n    std::size_t find(T key) {\n      return find(root, key);\n    }\n\n    std::vector<T> collect(T x, T y) {\n      std::vector<T> v;\n      Tree l,r,c,tmp;\n      split_by_lower_bound(root, x, l, tmp);\n      split_by_upper_bound(tmp, y, c, r);\n      collect_(v, c);\n      merge(tmp, c, r);\n      merge(root, l, tmp);\n      return v;\n    }\n};\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  Treap< int > treap;\n  int q; std::cin >> q;\n  loop(q) {\n    int c; std::cin >> c;\n    if (c == 0) {\n      int x; std::cin >> x;\n      treap.insert(x);\n      std::cout << treap.size() << std::endl;\n    } else if (c == 1) {\n      int x; std::cin >> x;\n      std::size_t found = treap.find(x);\n      std::cout << found << std::endl;\n    } else if (c == 2) {\n      int x; std::cin >> x;\n      treap.erase(x);\n    } else if (c == 3) {\n      int l, r; std::cin >> l >> r;\n      auto v = treap.collect(l,r);\n      for (int x : v) {\n        std::cout << x << std::endl;\n      }\n    }\n    // debug(treap.collect(-10, 100));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() \n{\n    int n, x, y, z, i;\n    scanf(\"%d\", &n);\n    \n    multiset<int> s;\n    \n    for(i = 0; i < n; i++)\n    {\n        scanf(\"%d %d\", &x, &y);\n        \n        if(x == 0)\n        {\n            s.insert(y);\n            printf(\"%d\\n\", (int)s.size());\n        }\n        else if(x == 1)\n        {\n            printf(\"%d\\n\", (int)s.count(y));\n        }\n        else if(x == 2)\n        {\n            s.erase(y);\n        }\n        else if(x == 3)\n        {\n            scanf(\"%d\", &z);\n            \n            auto L = s.lower_bound(y);\n            auto R = s.upper_bound(z);\n            \n            while(L != R)\n            {\n                printf(\"%d\\n\", *L);\n                L++;\n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main (){\n  int q,t,x,y;\n  multiset<int> a;\n\n  cin >> q;\n\n  for (int i = 0; i < q; i++){\n    cin >> t;\n    cin >> x;\n    if (t==0){\n      a.insert(x);\n      cout << a.size() << endl;\n    }else if(t==1){\n      cout << a.count(x) << endl;\n    }else if(t==2){\n      a.erase(x);\n    }else{\n      cin >> y;\n      auto it = a.lower_bound(x);\n      auto last = a.upper_bound(y);\n\n      while (it != last) {\n        cout << *it << endl;\n        ++it;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n\nconst long long INFLL = 1LL << 60;\nconst int INFINT = 1 << 30;\nconst long long MOD = 1e9 + 7;\n\ntemplate <class T> void vecout(T V) {\n    auto t = V.begin();\n    while(t != V.end()) {\n        cout << *t++;\n        if(t != V.end()) cout << \" \";\n    }\n    cout << endl;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // int n;\n    // cin >> n;\n    multiset<int> s;\n    int q, a, b, c;\n    cin >> q;\n    rep(i, q) {\n        cin >> a >> b;\n        if(a == 0) {\n            s.insert(b);\n            cout << s.size() << \"\\n\";\n        } else if(a == 1) {\n            cout << s.count(b) << \"\\n\";\n        } else if(a == 2) {\n            s.erase(b);\n        } else {\n            cin >> c;\n            auto p1 = s.equal_range(b);\n            auto p2 = s.equal_range(c);\n\n            while(p1.first != p2.second) {\n                cout << *p1.first++ << \"\\n\";\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nint main(){\n\n    int q;\n    cin >> q;\n    multiset<int> st;\n    for(int i = 0; i < q; ++i){\n        int com, x;\n        cin >> com;\n        if(com != 3){\n            cin >> x;\n        }\n        if(com == 0){\n            st.insert(x);\n            cout << st.size() << endl;\n        }\n        else if(com == 1){\n            cout << st.count(x) << endl;\n        }\n        else if(com == 2){\n            st.erase(x);\n        }\n        else{\n            int L, R;\n            cin >> L >> R;\n            auto l = st.lower_bound(L);\n            auto r = st.upper_bound(R);\n            for(auto it = l; it != r; ++it){\n                cout << *it << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n// #define DEBUG\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, k, x, y;\n    cin >> n;\n    // set<int> workspace;\n    multiset<int> workspace;\n\n    for (int i = 0; i < n; i++)\n    {\n        cin >> k;\n        if (k == 0)\n        {\n            cin >> x;\n            workspace.insert(x);\n            cout << workspace.size() << \"\\n\";\n        }\n        else if (k == 1)\n        {\n            cin >> x;\n            cout << workspace.count(x) << \"\\n\";\n            // auto z = workspace.find(x);\n            // cout << ((z == workspace.end()) ? 0 : 1) << \"\\n\";\n        }\n        else if (k == 2)\n        {\n            cin >> x;\n            workspace.erase(x);\n        }\n        else if (k == 3)\n        {\n            cin >> x >> y;\n            for (auto itr = workspace.lower_bound(x); itr != workspace.upper_bound(y); itr++)\n                cout << *itr << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n// getline(cin,s);\n// a = strtok(s, \",\");  \",\"で分解\n// for (int i = 0; i < n; i++)\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <set>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0');return m?-n:n;} //&&c<='9'\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n//_sc(string &s){int c;s=\"\";\n//\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n//_vo(string &s){for(char c:s)pcu(c);}\n//_vo(string s){for(char c:s)pcu(c);}\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n//_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nint main() {\n\tmultiset<int> A;\n\tfor (int i = in(); i; i--)\n\t\tswitch(in()) {\n\t\tcase 0:\n\t\t\tA.insert(in());\n\t\t\toutl(A.size());\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\toutl(A.count(in()));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tA.erase(in());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauto i = A.lower_bound(in()), e = A.upper_bound(in());\n\t\t\tfor (; i != e; i++)\n\t\t\t\toutl(*i);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,x,n) for(int i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD (1000000007)\n#define INF (1e9)\n#define INFL (1e18)\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>using arr=vector<vector<T>>;\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} cout << a[a.size()-1] << endl;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nint main()\n{\n    multiset<int> s;\n    int q; cin >> q;\n    rep(i, q){\n        int c, x, l ,r;\n        cin >> c;\n        if(c==0){\n            cin >> x;\n            s.insert(x);\n            pr(s.size());\n        }else if(c==1){\n            cin >> x;\n            pr(s.count(x));\n        }else if(c==2){\n            cin >> x;\n            s.erase(x);\n        }else{\n            cin >> l >> r;\n            if(l<=r){\n                auto li = s.lower_bound(l);\n                auto ri = s.upper_bound(r);\n                for(; li!=ri; li++) pr(*li);\n                // if(*li==r) pr(*li);\n            }\n        }\n    }\n    return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n \nint q;\n \nint main(){\n    cin >> q;\n    multiset<int> msa;\n    for(int i = 0; i < q; i++){\n        char query;\n        cin >> query;\n        if(query == '0'){\n            int x;\n            cin >> x;\n            msa.insert(x);\n            cout << msa.size() << endl;\n        }else if(query == '1'){\n            int x;\n            cin >> x;\n            cout << msa.count(x) << endl;\n        }else if(query == '2'){\n            int x;\n            cin >> x;\n            msa.erase(x);\n        }else if(query == '3'){\n            int L, R;\n            cin >> L >> R;\n            multiset<int>::iterator itr, itr1, itr2;\n            itr1 = msa.lower_bound(L);\n            itr2 = msa.upper_bound(R);\n            for(itr = itr1; itr != itr2; itr++){\n                cout << *itr << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <numeric>\n#include <climits>\n#include <iterator>\n#include <iomanip>\n#include <stack>\n#include <set>\n#include <cstdio>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <list>\n#include <deque>\nusing namespace std;\ntypedef pair<int, int> P;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i<(ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntypedef long long ll;\ntypedef vector<int> VI;\n\nint a[200010];\nint b[200010];\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    \n    ll n; cin >> n;\n    multiset<ll> st;\n    REP(i, n){\n        ll a, b; cin >> a >> b;\n        if(a==1){\n            cout << st.count(b) << endl;\n        }else if(a==0){\n            st.insert(b);\n            cout << st.size() << endl;\n        }else if(a==2){\n            st.erase(b);\n        }else{\n            ll c; cin >> c;\n            for(auto itr=st.lower_bound(b); itr!=st.upper_bound(c); ++itr) cout << *itr << endl;\n        }\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nsigned main(){\n\tint q;\n\tmultiset<int>s;\n\tcin>>q;\n\twhile(q--){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(x==1)cout<<s.count(y)<<endl;\n\t\telse if(!x){\n\t\t\ts.insert(y);\n\t\t\tcout<<s.size()<<endl;\n\t\t}\n\t\telse if(x==2)s.erase(y);\n\t\telse{\n\t\t\tint l=y,r;\n\t\t\tcin>>r;\n\t\t\tset<int>::iterator end,it;\n\t\t\tit=s.lower_bound(l);\n\t\t\tend=s.upper_bound(r);\n\t\t\tfor(;it!=end;it++){\n\t\t\t\tcout<<(*it)<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); i++)\n#define repd(i,a,b) for (int i = (a); i < (b); i++)\ntypedef long long ll;\n\nint main(void)\n{\n\tint q, com, x;\n\tmultiset<int> S;\n    cin >> q;\n    rep(i, q)\n    {\n        cin >> com >> x;\n        if (com == 0)\n        {\n            S.insert(x);\n            cout << S.size() << endl;\n        }\n        else if (com == 1)\n        {\n            cout << S.count(x) << endl;\n        }\n        else if (com == 2)\n        {\n            S.erase(x);\n        }\n        else\n        {\n            int y;\n            cin >> y;\n            set<int>::iterator st, en, itr;\n            st = S.lower_bound(x);\n            en = S.upper_bound(y);\n            for(itr = st; itr != en; ++itr) {\n                cout << *itr << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nint main() {\n\tint q, query, x, L, R;\n\tcin >> q;\n\tmultiset<int> S;\n\tfor (int i = 0; i < q; ++i) {\n\t\tcin >> query;\n\t\tif (0 == query) {\n\t\t\tcin >> x;\n\t\t\tS.insert(x);\n\t\t\tcout << S.size() << endl;\n\t\t}\n\t\telse if (1 == query) {\n\t\t\tcin >> x;\n\t\t\tcout << S.count(x) << endl;\n\t\t}\n\t\telse if (2 == query) {\n\t\t\tcin >> x;\n\t\t\tS.erase(x);\n\t\t}\n\t\telse {\n\t\t\tcin >> L >> R;\n\t\t\tfor (multiset<int>::iterator i = S.lower_bound(L); i != S.upper_bound(R); ++i) cout << *i << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include<initializer_list>\n// #include<iostream>\n\n#include<iostream>\nusing namespace std;\n\ntemplate<typename type>\nclass BTree {\npublic :\n\tstatic const int default_min_degree = 2;\n\tbool MULTISET = true; // true -> duplicate 　false -> not duplicate \n\tint SEARCH = 0; // linear search ->0  binary search ->1\n\tbool COUNT_NUM = true;\n\t\n\tint number_of_element;\n\tint min_degree;\n\t\n\t\n\tclass Node {\n\tpublic :\n\t\tbool leaf;\n\t\tint number_of_key;\n\t\tint w_num;\n\t\t\n\t\tNode* parent;\n\t\t// int *count;\n\t\tint *sum;\n\t\ttype *key;\n\t\tNode** children;\n\t\tBTree<type>* btree;\n\t\t\n\t\tNode(BTree<type>* btree, Node* parent = nullptr): btree(btree), parent(parent) {init();}\t\n\t\t\n\t\t~Node(){\n\t\t\tdelete[] sum;\n\t\t\tdelete[] key;\n\t\t\tdelete[] children;\n\t\t}\n\t\t\n\t\tvoid init() {\n\t\t\tleaf = true;\n\t\t\tnumber_of_key = 0;\n\t\t\tw_num = 0;\n\t\t\t// count = 1;\n\t\t\t\n\t\t\tkey = new type[btree->min_degree * 2 - 1];\n\t\t\tchildren = new Node*[btree->min_degree * 2];\n\t\t\t\n\t\t\tif(btree->COUNT_NUM) {\n\t\t\t\tsum = new int[btree->min_degree * 2];\n\t\t\t\tsum[0] = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t};\n\t\n\tNode* root;\n\t\n\t\n\tclass jnode {\n\tpublic:\n\t\tNode* node;\n\t\tint index;\n\t\t\n\t\tjnode(Node* node = nullptr, int index = -1): node(node), index(index){}\t\n\t\tjnode(const jnode &j) { node = j.node;  index = j.index;};\n\t\t\n\t\tjnode& operator ++(){\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\tif(node == nullptr) { //cout<<\"A\"<<endl;\n\t\t\t\tindex = -2;\n\t\t\t} else if(node->number_of_key <= index){//cout<<\"B\"<<endl;\n\t\t\t\t\n\t\t\t\tdo{\n\t\t\t\t\tindex = node->w_num;\n\t\t\t\t\tnode = node->parent;\n\t\t\t\t} while(node != nullptr && node->number_of_key <= index);\n\t\t\t\t\n\t\t\t} else if(node->leaf) { \n\t\t\t\tif(node->number_of_key - 1 <= index) { //cout<<\"C\"<<endl;\n\t\t\t\t\tdo{\n\t\t\t\t\t\tindex = node->w_num;\n\t\t\t\t\t\tnode = node->parent;\n\t\t\t\t\t} while(node != nullptr && node->number_of_key <= index);\n\t\t\t\t\n\t\t\t\t} else { //cout<<\"D\"<<endl;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t} else { //cout<<\"E\"<<endl;\n\t\t\t\tnode = node->children[index+1];\n\t\t\t\t\n\t\t\t\twhile(!node->leaf){\n\t\t\t\t\tnode = node->children[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn *this;\n\t\t}\n\t\t\n\t\tjnode operator ++(int) {\n\t\t\tjnode j = *this;\n\t\t\t\n\t\t\t++(*this);\n\t\t\t\n\t\t\treturn j;\n\t\t}\n\t\t\n\t\tjnode& operator --(){\n\t\t\t\n\t\t\tif(node == nullptr) {\n\t\t\t\tindex = -1;\n\t\t\t} else if(index < 0){\n\t\t\t\tdo{\n\t\t\t\t\tindex = node->w_num - 1;\n\t\t\t\t\tnode = node->parent;\n\t\t\t\t} while(node != nullptr && index < 0);\n\t\t\t\t\n\t\t\t} else if(node->leaf) {\n\t\t\t\tif(index == 0) {\n\t\t\t\t\tdo{\n\t\t\t\t\t\tindex = node->w_num - 1;\n\t\t\t\t\t\tnode = node->parent;\n\t\t\t\t\t} while(node != nullptr && index < 0);\n\t\t\t\t} else {\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = node->children[index];\n\t\t\t\t\n\t\t\t\twhile(!node->leaf){\n\t\t\t\t\tnode = node->children[node->children->number_of_key];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tindex = node->number_of_key - 1;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\t\n\t\tjnode operator --(int) {\n\t\t\tjnode j = *this;\n\t\t\t\n\t\t\t--(*this);\n\t\t\t\n\t\t\treturn j;\n\t\t}\t\t\n\t\t\n\t\tbool operator == (const jnode &j) const {\n\t\t\treturn node ==  j.node && index == j.index;\n\t\t}\n\t};\n\t\n\t\n\tBTree(int min_degree = default_min_degree) : min_degree(min_degree){ create();};\n\t\n\t~BTree(){\n\t\tclear(root);\n\t}\n\t\n\tint index_search(Node *node, int key, int k){  // lower bound\n\t\tint index;\n\t\t\n\t\tif(k == 0){\n\t\t\t// linear search\n\t\t\t\n\t\t\tfor(index = 0; index < node->number_of_key && (node->key[index] < key); index++);\n\t\t} else if(k == 1){\n\t\t\t//binary search\n\t\t\t\n\t\t\tindex = node->number_of_key;\n\t\t\tint low = -1, med;\n\t\t\twhile(low + 1< index){\n\t\t\t\tint med = (low + index) >> 1;\n\t\t\t\t\n\t\t\t\tif((node->key[med] < key)) {\n\t\t\t\t\tlow = med;\n\t\t\t\t} else {\n\t\t\t\t\tindex = med;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn index;\n\t}\n\t\n\tint index_search2(Node *node, int key, int k){ // upper bound\n\t\tint index;\n\t\t\n\t\tif(k == 0){\n\t\t\t// linear search\n\t\t\t\n\t\t\tfor(index = 0; index < node->number_of_key && (key >= node->key[index]); index++);\n\t\t} else if(k == 1){\n\t\t\t//binary search\n\t\t\t\n\t\t\tindex = node->number_of_key;\n\t\t\tint low = -1, med;\n\t\t\twhile(low + 1 < index){\n\t\t\t\tint med = (low + index) >> 1;\n\t\t\t\t\n\t\t\t\tif(key >= node->key[med]) {\n\t\t\t\t\tlow = med;\n\t\t\t\t} else {\n\t\t\t\t\tindex = med;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn index;\n\t}\n\t\n\tint sum_search(Node *node, int num, int k){\n\t\tint index = 0;\n\t\t\n\t\tif(k == 0){\n\t\t\t// linear search\n\t\t\t\n\t\t\tfor(index = 0; index < node->number_of_key && node->sum[index] < num; index++);\n\t\t} else if(k == 1){\n\t\t\t//binary search\n\t\t\t\n\t\t\tindex = node->number_of_key;\n\t\t\tint low = -1, med;\n\t\t\twhile(low + 1 < index){\n\t\t\t\tint med = (low + index) >> 1;\n\t\t\t\t\n\t\t\t\tif(node->sum[med] < num) {\n\t\t\t\t\tlow = med;\n\t\t\t\t} else {\n\t\t\t\t\tindex = med;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn index;\n\t}\n\t\n\tvoid clear(Node* node){\n\t\t\n\t\tif(!node->leaf) {\n\t\t\tfor(int i = 0; i <= node->number_of_key; i++){\n\t\t\t\tclear(node->children[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdelete node;\n\t}\n\t\n\tvoid create(){\n\t\tnumber_of_element = 0;\n\t\t\n\t\troot = new Node(this);\n\t}\n\t\n\tint lower_bound(type key){\n\t\treturn lower_bound(root, key);\n\t}\n\t\n\tint lower_bound(Node *node, type key){\n\t\tint index = index_search(node, key, SEARCH);\n\t\t\n\t\tif(node->leaf) {\n\t\t\tif(index < node->number_of_key) return node->sum[index];\n\t\t\telse return node->number_of_key;\n\t\t} else {\n\t\t\t if(index) return lower_bound(node->children[index], key) + node->sum[index-1] + 1;\n\t\t\telse return lower_bound(node->children[index], key);\n\t\t}\n\t}\n\t\n\tint upper_bound(type key){\n\t\treturn upper_bound(root, key);\n\t}\n\t\n\tint upper_bound(Node *node, type key){\n\t\tint index = index_search2(node, key, SEARCH);\n\t\t\n\t\tif(node->leaf) {\n\t\t\tif(index < node->number_of_key) return node->sum[index];\n\t\t\telse return node->number_of_key;\n\t\t} else {\n\t\t\t if(index) return upper_bound(node->children[index], key) + node->sum[index-1] + 1;\n\t\t\telse return upper_bound(node->children[index], key);\n\t\t}\n\t}\n\t\n\tint size(){\n\t\treturn number_of_element;\n\t}\n\t\n\tNode* search(type k){\n\t\treturn search(root, k);\n\t}\n\t\n\tNode* search(Node* node, type key){\n\t\t\n\t\tint index = index_search(node, key, SEARCH);\n\t\t\n\t\t\n\t\tif(index < node->number_of_key && (node->key[index] == key)) {\n\t\t\treturn node;\n\t\t} else if(node->leaf) {\n\t\t\treturn nullptr;\n\t\t} else {\n\t\t\treturn search(node->children[index], key);\n\t\t}\n\t}\n\t\n\tvoid operation(Node *node, int index = 0){\n\t\tif(COUNT_NUM) count_number(node, index);\n\t\tchange_w_num(node, index);\n\t}\n\t\n\tvoid count_number(Node *node, int index){\n\t\t\n\t\tif(node == nullptr) return;\n\t\t\n\t\tif(node->leaf) {\n\t\t\tfor(int i = index; i <= node->number_of_key; i++) {\n\t\t\t\tnode->sum[i] = 0;\n\t\t\t\tif(i) {\n\t\t\t\t\tnode->sum[i] += node->sum[i-1] + 1;\n\t\t\t\t\t// node->sum[i] += node->sum[i-1] + node->count[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i = index; i <= node->number_of_key; i++){\n\t\t\t\t\n\t\t\t\tnode->sum[i] = node->children[i]->sum[node->children[i]->number_of_key];\n\t\t\t\n\t\t\t\tif(i) {\n\t\t\t\t\tnode->sum[i] += node->sum[i-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid change_w_num(Node *node, int index){\n\t\tif(node == nullptr) return;\n\t\tif(node == root) node->parent = nullptr;\n\t\t\n\t\tif(!node->leaf) {\n\t\t\tfor(int i = index; i <= node->number_of_key; i++){\n\t\t\t\tnode->children[i]->w_num = i;\n\t\t\t\tnode->children[i]->parent = node;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tjnode nth_element(int num){\n\t\tif(num < 0 || num >= size()) return jnode();\n\t\treturn nth_element(root, num);\n\t}\n\t\n\tjnode nth_element(Node* node, int num){\n\t\tint index = sum_search(node, num, SEARCH);\n\t\t\n\t\tif(index < node->number_of_key && num == node->sum[index]) {\n\t\t\treturn jnode(node, index);\n\t\t} else {\n\t\t\tif(node->leaf) {\n\t\t\t\t// どうしてここに？\n\t\t\t} else {\n\t\t\t\tif(index) return nth_element(node->children[index], num - node->sum[index-1] - 1);\n\t\t\t\telse return nth_element(node->children[index], num);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid split_child(Node* node, int index){\n\t\tNode *right_child = new Node(this, node);\n\t\tNode *left_child = node->children[index];\n\t\t\n\t\tright_child->leaf =  left_child->leaf;\n\t\tright_child->number_of_key = min_degree - 1;\n\t\t\n\t\tfor(int j = 0; j < min_degree - 1; j++){\n\t\t\tright_child->key[j] = left_child->key[j + min_degree];\n\t\t}\n\t\t\n\t\tif(!left_child->leaf) {\n\t\t\t\n\t\t\tfor(int j = 0; j < min_degree; j++){\n\t\t\t\tright_child->children[j] = left_child->children[j + min_degree];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tleft_child->number_of_key = min_degree - 1;\n\t\t\n\t\tfor(int j = node->number_of_key; j > index; j--){\n\t\t\tnode->children[j+1] = node->children[j];\n\t\t}\n\t\t\n\t\tnode->children[index+1] = right_child;\n\t\t\n\t\tfor(int j = node->number_of_key - 1; j >= index; j--){\n\t\t\tnode->key[j+1] = node->key[j];\n\t\t}\n\t\t\n\t\tnode->key[index] = left_child->key[min_degree-1];\n\t\t\n\t\tnode->number_of_key++;\n\t\t\n\t\tright_child->parent = node;\n\t\t\n\t\toperation(right_child);\n\t\toperation(left_child);\n\t}\n\t\n\tvoid insert_nonfull(Node* node, type key){\n\t\tint index = node->number_of_key - 1;\n\t\t\n\t\tif(node->leaf) {\n\t\t\t\n\t\t\tfor(; index >= 0 && (key < node->key[index]); index--){\n\t\t\t\tnode->key[index+1] = node->key[index];\n\t\t\t}\n\t\t\t\n\t\t\tnode->key[index+1] = key;\n\t\t\tnode->number_of_key++;\n\t\t} else {\n\t\t\tfor(; index >= 0 && (key < node->key[index]); index--);\n\t\t\t\n\t\t\tindex++;\n\t\t\t\n\t\t\tif(node->children[index]->number_of_key == 2 * min_degree - 1) {\n\t\t\t\tsplit_child(node, index);\n\t\t\t\t\n\t\t\t\tif((node->key[index] < key)) index++;\n\t\t\t}\n\t\t\t\n\t\t\tinsert_nonfull(node->children[index], key);\n\t\t}\n\t\t\n\t\toperation(node);\n\t}\n\t\n\tvoid insert(type key){\n\t\tif(!MULTISET && search(key) != nullptr) return ;\n\t\t\n\t\tnumber_of_element++;\n\t\t\n\t\t_insert(key);\n\t}\n\t\n\tvoid _insert(type key){\n\t\tNode* temp_root = root;\n\t\t\n\t\tif(root->number_of_key == 2 * min_degree - 1) {\n\t\t\tNode* new_node = new Node(this);\n\t\t\t\n\t\t\troot = new_node;\n\t\t\t\n\t\t\troot->leaf = false;\n\t\t\troot->children[0] = temp_root;\n\t\t\troot->parent = new_node;\n\t\t\t\n\n\t\t\tsplit_child(root, 0);\n\t\t\tinsert_nonfull(root, key);\n\t\t} else {\n\t\t\tinsert_nonfull(root, key);\n\t\t}\n\t}\n\t\n\tvoid erase(type key){\n\t\terase(root, key);\n\t\t\n\t\twhile(root->number_of_key == 0 && !root->leaf) {\n\t\t\tNode *temp = root;\n\t\t\t\n\t\t\troot = root->children[0];\n\t\t\troot->parent = nullptr;\t\t\n\t\t\t\n\t\t\tdelete temp;\n\t\t}\n\t}\n\t\n\tvoid erase(Node* node, type key){\n\t\tint index = index_search(node, key, SEARCH);\n\t\t\n\t\tif(index < node->number_of_key && (node->key[index] == key)) {\n\t\t\tif(node->leaf) {\n\t\t\t\tfor(int i = index; i + 1 < node->number_of_key; i++){\n\t\t\t\t\tnode->key[i] = node->key[i + 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnumber_of_element--;\n\t\t\t\tnode->number_of_key--;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tNode* child1 = node->children[index];\n\t\t\t\tNode* child2 = node->children[index+1];\n\t\t\t\t\n\t\t\t\tif(child1->number_of_key >= min_degree) {\n\t\t\t\t\tNode *maximum = child1;\n\t\t\t\t\t\n\t\t\t\t\twhile(!maximum->leaf){\n\t\t\t\t\t\tmaximum = maximum->children[maximum->number_of_key];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode->key[index] = maximum->key[maximum->number_of_key-1];\n\t\t\t\t\t\n\t\t\t\t\terase(child1, node->key[index]);\n\t\t\t\t} else if(child2->number_of_key >= min_degree){\n\t\t\t\t\tNode *minimum = child2;\n\t\t\t\t\t\n\t\t\t\t\twhile(!minimum->leaf){\n\t\t\t\t\t\tminimum = minimum->children[0];\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tnode->key[index] = minimum->key[0];\n\t\t\t\t\t\n\t\t\t\t\terase(child2, node->key[index]);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tchild1->key[min_degree - 1] = key;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = min_degree; i < min_degree * 2 - 1; i++){\n\t\t\t\t\t\tchild1->key[i] = child2->key[i - min_degree];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = min_degree; i < min_degree * 2; i++){\n\t\t\t\t\t\tchild1->children[i] = child2->children[i - min_degree];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdelete child2;\n\t\t\t\t\t\n\t\t\t\t\tchild1->number_of_key = min_degree * 2 - 1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = index; i + 1 < node->number_of_key; i++){\n\t\t\t\t\t\tnode->key[i] = node->key[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = index + 1; i < node->number_of_key; i++){\n\t\t\t\t\t\tnode->children[i] = node->children[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode->number_of_key--;\n\t\t\t\t\t\n\t\t\t\t\terase(child1, key);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(node->leaf) {\n\t\t\n\t\t} else {\n\t\t\n\t\t\tNode* child0 = nullptr;\n\t\t\tNode* child1 = child1 = node->children[index];;\n\t\t\tNode* child2 = nullptr;\n\t\t\t\n\t\t\tif(index >= 1) child0 = node->children[index-1];\n\t\t\tif(index + 1 <= node->number_of_key) child2 = node->children[index+1];\n\t\t\t\n\t\t\tif(child1 == nullptr) { \n\t\t\t\t//　ﾊﾞｶｼﾞｬﾈｰﾉ\n\t\t\t\treturn ;\n\t\t\t} else if(child1->number_of_key >= min_degree) {\n\t\t\t\terase(child1, key);\n\t\t\t} else if(child0 != nullptr && child0->number_of_key >= min_degree){\n\t\t\t\tindex--;\n\t\t\t\t\n\t\t\t\tfor(int i = child1->number_of_key - 1; i >= 0; i--){\n\t\t\t\t\tchild1->key[i+1] = child1->key[i];\n\t\t\t\t}\n\t\t\t\tfor(int i = child1->number_of_key; i >= 0; i--){\n\t\t\t\t\tchild1->children[i+1] = child1->children[i];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchild1->key[0] = node->key[index];\n\t\t\t\tchild1->children[0] = child0->children[child0->number_of_key];\n\t\t\t\t\n\t\t\t\tnode->key[index] = child0->key[child0->number_of_key-1];\n\t\t\t\t\n\t\t\t\tchild0->number_of_key--;\n\t\t\t\tchild1->number_of_key++;\n\t\t\t\t\n\t\t\t\terase(child1, key);\n\t\t\t\t\n\t\t\t} else if(child2 != nullptr && child2->number_of_key >= min_degree){\n\t\t\t\t\n\t\t\t\tchild1->key[child1->number_of_key] = node->key[index];\n\t\t\t\tchild1->children[child1->number_of_key + 1] = child2->children[0];\n\t\t\t\t\n\t\t\t\tnode->key[index] = child2->key[0];\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i + 1 < child2->number_of_key; i++){\n\t\t\t\t\tchild2->key[i] = child2->key[i+1];\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < child2->number_of_key; i++){\n\t\t\t\t\tchild2->children[i] = child2->children[i+1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchild2->number_of_key--;\n\t\t\t\tchild1->number_of_key++;\n\t\t\t\t\n\t\t\t\toperation(child2);\n\t\t\t\terase(child1, key);\n\t\t\t} else if(child2 != nullptr || child0 != nullptr){\n\t\t\t\tNode* child_left, *child_right;\n\t\t\t\t\n\t\t\t\tif(child2 != nullptr){\n\t\t\t\t\tchild_left = child1;\n\t\t\t\t\tchild_right = child2;\n\t\t\t\t\t\n\t\t\t\t} else if(child0 != nullptr){\n\t\t\t\t\tchild_left = child0;\n\t\t\t\t\tchild_right = child1;\n\t\t\t\t\t\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchild_left->key[min_degree - 1] = node->key[index];\n\t\t\t\t\t\n\t\t\t\tfor(int i = min_degree; i < min_degree * 2 - 1; i++){\n\t\t\t\t\tchild_left->key[i] = child_right->key[i - min_degree];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = min_degree; i < min_degree * 2; i++){\n\t\t\t\t\tchild_left->children[i] = child_right->children[i - min_degree];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdelete child_right;\n\t\t\t\t\n\t\t\t\tchild_left->number_of_key = min_degree * 2 - 1;\n\t\t\t\t\n\t\t\t\tfor(int i = index; i + 1 < node->number_of_key; i++){\n\t\t\t\t\tnode->key[i] = node->key[i + 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = index + 1; i < node->number_of_key; i++){\n\t\t\t\t\tnode->children[i] = node->children[i + 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnode->number_of_key--;\n\t\t\t\t\n\t\t\t\toperation(node);\n\t\t\t\terase(child_left, key);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\toperation(node);\n\t}\n\t\n\tconst type operator[](int num) & {\n\t\tjnode j = nth_element(num);\n\t\treturn j.node->key[j.index];\n\t}\n};\n\n\n\n\n#include<iostream>\n \nmain(){\n\tusing namespace std;\n\t\n\tBTree<int> bt(12);\n\tint Q;\n\t\n\tstd::cin>>Q;\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tint a, b, c;\n\t\t\n\t\tstd::cin>>a>>b;\n\t\t\n\t\tif(a == 0){\n\t\t\tbt.insert(b);\n\t\t\tcout<<bt.size()<<endl;\n\t\t} else if(a == 1) {\n\t\t\tcout<<(bt.upper_bound(b) - bt.lower_bound(b))<<endl;\n\t\t} else if(a == 2){\n\t\t\t\n\t\t\twhile(bt.search(b) != nullptr) {\n\t\t\t\tbt.erase(b);\n\t\t\t}\n\t\t} else if(a == 3) {\n\t\t\tBTree<int>::jnode jn;\n\t\t\t\n\t\t\tcin>>c;\n\t\t\t\n\t\t\t// int num = bt.lower_bound(b);\n\t\t\t\n\t\t\t// for(int i = num; i < bt.size() && bt[i] <= c; i++){\n\t\t\t\t// cout<<bt[i]<<endl;\n\t\t\t// }\n\t\t\tjn = bt.nth_element(bt.lower_bound(b));\n\t\t\t\n\t\t\tfor(; jn.node != nullptr && jn.node->key[jn.index] <= c; jn++){\n\t\t\t\tcout<<jn.node->key[jn.index]<<endl;\n\t\t\t}\n\t\t} else if(a == 4) {\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  multiset <int> S;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, num;\n    cin>>cmd>>num;\n    if(cmd == 0){\n      S.insert(num);\n      cout<<S.size()<<endl;\n    }\n\n    if(cmd == 1){\n      cout<<S.count(num)<<endl;\n    }\n    \n    if(cmd == 2){\n      S.erase(num);\n    }\n\n    if(cmd == 3){\n      int l = num, r;\n      cin>>r;\n      auto start = S.lower_bound(l);\n      auto last= S.upper_bound(r);\n      for(auto it = start; it != last; it++) cout<<*it<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsigned main(){\n\n  int q;\n  cin>>q;\n  multiset<int> s;\n  while(q--){\n    int c,x;\n    cin>>c>>x;\n    if(c==0){\n      s.insert(x);\n      cout<< s.size() <<endl;\n    }\n    else if(c==1){\n      cout<< s.count(x) <<endl;\n    }\n    else if(c==2){\n      s.erase(x);\n    }\n    else if(c==3){\n      int y;\n      cin>>y;\n      auto itr = s.lower_bound(x);\n      auto end = s.upper_bound(y);\n      while(itr!=end){\n        cout<<*itr<<endl;\n        itr++;\n      }\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX 100005\n#define INF 1001001001\n\nint main(int, char**)\n{\n  multiset<int> a;\n  int q;\n  cin >> q;\n  vector<int> ans;\n  rep(i,q) {\n    int command; cin >> command;\n    if (command == 0) {\n      int x; cin >> x;\n      a.insert(x);\n      ans.push_back(a.size());\n    } else if (command == 1) {\n      int x; cin >> x;\n      ans.push_back(a.count(x));\n    } else if (command == 2) {\n      int x; cin >> x;\n      a.erase(x);\n    } else if (command == 3) {\n      int l, r; cin >> l >> r;      \n      auto itrl = a.lower_bound(l);\n      auto itrr = a.upper_bound(r);\n      for (auto itr = itrl; itr != itrr; itr++)\n      ans.push_back(*itr);\n    }\n  }\n\n  for (auto a : ans) cout << a << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N;\n  cin >> N;\n  multiset<int> Set;\n\n  for(int i = 0; i < N; ++i)\n  {\n    int Command; cin >> Command;\n\n    if(Command == 0)\n    {\n      int Val; cin >> Val;\n      Set.insert(Val);\n      cout << Set.size() << endl;\n    }\n    else if(Command == 1)\n    {\n      int Val; cin >> Val;\n      int Count = Set.count(Val);\n      cout << Count << endl;\n\n    }\n    else if(Command == 2)\n    {\n      int Val; cin >> Val;\n      auto ite = Set.equal_range(Val);\n      Set.erase(ite.first, ite.second);\n    }\n    else \n    {\n      int LB, UB; cin >> LB >> UB;\n\n      auto ite = Set.lower_bound(LB);\n      auto last = Set.upper_bound(UB);\n\n      while(ite != last)\n      {\n\tcout << *ite << endl;\n        ++ite;\n      }\n\n\n    }\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n/**\n *      purpose : \n *      author  : kyomukyomupurin\n *      created : \n**/\n\n// input/output\n#include <iostream>\n#include <fstream>\n#include <sstream>\n// container class\n#include <array>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n// math, algorithm\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <numeric>\n// etc\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cstring>\n#include <chrono>\n#include <iomanip>\n#include <random>\n#include <utility>\n// using-directive\nusing namespace std;\n// alias template\nusing int64 = long long;\nusing vi = vector<int>;\nusing vl = vector<int64>;\nusing pii = pair<int, int>;\nusing pll = pair<int64, int64>;\n// text macro replacement\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define print(x) cout << (x) << '\\n'\n#define debug(x) cerr << #x << \": \" << (x) << '\\n'\n#define dbg(v) for (size_t _ = 0; _ < v.size(); ++_){cerr << #v << \"[\" << _ << \"] : \" << v[_] << '\\n';}\n// variadic template\ntemplate<typename T> inline void chmin(T &a, T b) {if (a > b) a = b; return;}\ntemplate<typename T> inline void chmax(T &a, T b) {if (a < b) a = b; return;}\n// constant\nconst int INF = (1<<30) - 1;\nconst int64 INF64 = (1LL<<62) - 1;\nconst int MOD = 1000000007;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  multiset<int> st;\n  int query; cin >> query;\n\n  for (int i = 0; i < query; ++i) {\n    int op, x; cin >> op >> x;\n    if (op == 0) {\n      st.insert(x);\n      cout << st.size() << '\\n';\n    } else if (op == 1) {\n      cout << (distance(st.lower_bound(x), st.upper_bound(x))) << '\\n';\n    } else if (op == 2) {\n      st.erase(x);\n    } else {\n      int r; cin >> r;\n      auto it1 = st.lower_bound(x);\n      auto it2 = st.upper_bound(r);\n      for (auto it = it1; it != it2; ++it) {\n        cout << *it << '\\n';\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\nint main(){\n\tint q,a,b;\n\tint s,t;\n\tcin>>q;\n\tmultiset<int>m;\n\tfor(;q--;){\n\t\tcin>>a;\n\t\tif(a==0)cin>>s,m.insert(s),cout<<m.size()<<endl;\n\t\tif(a==1)cin>>s,cout<<m.count(s)<<endl;\n\t\tif(a==2)cin>>s,m.erase(s);\n\t\tif(a==3){cin>>s>>t;auto it1=m.lower_bound(s),it2=m.upper_bound(t);for(;it1!=it2;++it1)cout<<*it1<<endl;}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int num_query; cin >> num_query;\n  multiset<int> integers;\n  \n  for (int i = 0; i < num_query; i++) {\n    int command, x; scanf(\"%d %d\", &command, &x);\n    \n    switch (command) {\n      case 0:\n        integers.insert(x);\n        printf(\"%d\\n\", integers.size());\n        break;\n        \n      case 1:\n        printf(\"%d\\n\", integers.count(x));\n        break;\n        \n      case 2:\n        integers.erase(x);\n        break;\n        \n      case 3:\n        int y; scanf(\"%d\", &y);\n        multiset<int>::iterator it = integers.lower_bound(x);\n        multiset<int>::iterator last = integers.upper_bound(y);\n        while (it != last) {\n          printf(\"%d\\n\", *it);\n          it++;\n        }\n        break;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<typename T = lint>inline T in() { T x; cin >> x; return x; }\n#define INF           1e9\n#define INFL          static_cast<lint>(INF)\n#define REP(i,n)      for(lint i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)     for(lint i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)     for(lint i=n-1;i>=0;--i)\n#define REPR1(i,n)    for(lint i=n;i>0;--i)\n#define REPI(i,ini,n) for(lint i=(ini),i##_len=(n);i<i##_len;++i)\n#define REPC(i,obj)   for(auto i:obj)\n#define R_UP(a,b)     (((a)+(b)-1)/(b))\n#define ALL(obj)      (obj).begin(),(obj).end()\nint main()\n{\n\tint q = in();\n\tmultiset<int>s;\n\tREP(i, q)\n\t{\n\t\tint n = in();\n\t\tint x, l, r;\n\t\tswitch (n)\n\t\t{\n\t\tcase 0:\n\t\t\tx = in();\n\t\t\ts.insert(x);\n\t\t\tcout << s.size() << endl;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tx = in();\n\t\t\tcout << distance(s.lower_bound(x), s.upper_bound(x)) << endl;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tx = in();\n\t\t\ts.erase(s.lower_bound(x), s.upper_bound(x));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tl = in();\n\t\t\tr = in();\n\t\t\tfor (auto start = s.lower_bound(l), last = s.upper_bound(r); start != last; start++)cout << *start << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\nint main()\n{\n    multiset<int > s;\n    int q;\n    cin>>q;\n    int b,tp1;\n    while(q--){\n        cin>>tp1;\n        if(tp1==1){\n                cin>>b;\n                cout<<s.count(b)<<\"\\n\";\n        }\n        else if(tp1==0){\n            cin>>b;\n            s.insert(b);\n            cout<<s.size()<<\"\\n\";\n        }\n        else if(tp1==2){\n            cin>>b;\n            s.erase(b);\n        }\n        else{\n            int r,l;\n            cin>>l>>r;\n            set<int>::iterator it=s.lower_bound(l);\n            while(*it<=r&&it!=s.end()){\n                cout<<*it<<\"\\n\";\n                it++;\n            }\n        }\n    }\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define r(i, n) for(int i=0;i<n;i++)\n\nint main() {\n    int q;\n    multiset<int> s;\n    cin >> q;\n    while (q--) {\n        int x, y;\n        cin >> x >> y;\n        if (x == 1)cout << s.count(y) << endl;\n        else if (!x) {\n            s.insert(y);\n            cout << s.size() << endl;\n        } else if (x == 2)s.erase(y);\n        else {\n            int l = y, r;\n            cin >> r;\n            set<int>::iterator end, it;\n            it = s.lower_bound(l);\n            end = s.upper_bound(r);\n            for (; it != end; it++) {\n                cout << (*it) << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<ld> vld;\ntypedef vector<string> vstr;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> spqll;  // 小さい順に取り出し\ntypedef priority_queue<ll, vector<ll>, less<ll>> bpqll;     // 大きい順に取り出し\n\n#define REP(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define IREP(i, v) for (auto i = (v).begin(); i != (v).end(); ++i)\n#define TS to_string\n#define ALL(v) (v).begin(), (v).end()\n#define endl \"\\n\"\n\nll INF = 1e9;\nll MOD = 1000000007;\nll LINF = 1e18;\nld EPS = 1e-9;\nld PI = M_PI;\nvll dx = {1, 0, -1, 0, 1, -1, -1, 1};\nvll dy = {0, 1, 0, -1, 1, 1, -1, -1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;} //最大公約数\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}     //最小公倍数\n\nvoid yes(){ cout << \"Yes\" << endl;}\nvoid no(){ cout << \"No\" << endl;}\n\n//-----------------------------------------\n\n//-----------------------------------------\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  ll q;\n  cin >> q;\n  multiset<ll> st;\n  REP(i,q){\n    ll com;\n    cin >> com;\n    if(com == 0){\n      ll x; cin >> x;\n      st.insert(x);\n      cout << st.size() <<endl;\n    }\n    else if(com == 1){\n      ll x; cin >> x;\n      auto s = st.lower_bound(x);\n      auto t = st.upper_bound(x);\n      cout << distance(s,t) << endl;\n    }\n    else if(com == 2){\n      ll x;\n      cin >> x;\n      st.erase(x);\n    }\n    else{\n      ll l, r;\n      cin >> l >> r;\n      auto s = st.lower_bound(l);\n      auto t = st.upper_bound(r);\n      for(auto i = s; i != t; ++i){\n        cout << (*i) << endl;\n      }\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\n#define lambda(RES_TYPE, ...) (function<RES_TYPE(__VA_ARGS__)>)[&](__VA_ARGS__) -> RES_TYPE\n#define method(FUNC_NAME, RES_TYPE, ...) function<RES_TYPE(__VA_ARGS__)> FUNC_NAME = lambda(RES_TYPE, __VA_ARGS__)\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nint main(){\n  int q = in();\n  multiset<int> s;\n  rep(_,q){\n    int kind = in();\n    if(kind==0){\n      int add = in();\n      s.emplace(add);\n      cout << s.size() << endl;\n    }else if(kind==1){\n      int x = in();\n      cout << s.count(x) << endl;\n    }else if(kind==2){\n      int x = in();\n      s.erase(x);\n    }else{\n      int x = in();\n      int y = in();\n      auto from = s.lower_bound(x);\n      auto end = s.upper_bound(y);\n      while(from!=end){\n        cout << *from << endl;\n        ++from;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main() {\n\n    std::multiset<int> s;\n    int Q;\n    std::cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int t;\n        std::cin >> t;\n        if (t == 0) {\n            int x;\n            std::cin >> x;\n            s.insert(x);\n            std::cout << s.size() << \"\\n\";\n        } else if (t == 1) {\n            int x;\n            std::cin >> x;\n            std::cout << s.count(x) << \"\\n\";\n        } else if (t == 2) {\n            int x;\n            std::cin >> x;\n            s.erase(x);\n        } else {\n            int l, r;\n            std::cin >> l >> r;\n            auto e = s.upper_bound(r);\n            for (auto itr = s.lower_bound(l); itr != e; ++itr) std::cout << *itr << \"\\n\";\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#include <boost/multiprecision/cpp_int.hpp>\n//using multiInt = boost::multiprecision::cpp_int;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconst int MOD_TYPE = 1;\nconst ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\nconst int INF = (int)1e9;\nconst ll LINF = (ll)4e18;\nconst double PI = acos(-1.0);\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << endl\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << endl\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << endl;\n\nvector<int> Dx = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nvector<int> Dy = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(50) << setiosflags(ios::fixed);\n  int q;\n  cin >> q;\n  multiset<int> st;\n  rep(qi, q)\n  {\n    int type;\n    cin >> type;\n    if (type == 0)\n    {\n      int x;\n      cin >> x;\n      st.insert(x);\n      cout << st.size() << endl;\n    }\n    else if (type == 1)\n    {\n      int x;\n      cin >> x;\n      cout << st.count(x) << endl;\n    }\n    else if (type == 2)\n    {\n      int x;\n      cin >> x;\n      st.erase(x);\n    }\n    else\n    {\n      int l, r;\n      cin >> l >> r;\n      auto itr = st.lower_bound(l);\n      while (itr != st.end() && *itr <= r)\n      {\n        cout << *itr << endl;\n        itr++;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nsigned main(){\n\tint q;\n\tmultiset<int>s;\n\tcin>>q;\n\twhile(q--){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(x==1)cout<<s.count(y)<<endl;\n\t\telse if(!x){\n\t\t\ts.insert(y);\n\t\t\tcout<<s.size()<<endl;\n\t\t}\n\t\telse if(x==2)s.erase(y);\n\t\telse{\n\t\t\tint l=y,r;\n\t\t\tcin>>r;\n\t\t\tset<int>::iterator end,it;\n\t\t\tit=s.lower_bound(l);\n\t\t\tend=s.upper_bound(r);\n\t\t\tfor(;it!=end;it++){\n\t\t\t\tcout<<(*it)<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nmultiset<int>st;\nint main() {\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint Q, k;\n\t\tcin >> Q >> k;\n\t\tif (Q == 0) {\n\t\t\tst.insert(k);\n\t\t\tcout << st.size() << endl;\n\t\t}\n\t\telse if (Q == 1) {\n\t\t\tcout << st.count(k) << endl;\n\t\t}\n\t\telse if (Q == 2) {\n\t\t\tst.erase(k);\n\t\t}\n\t\telse {\n\t\t\tint y;\n\t\t\tcin >> y;\n\t\t\tauto nowitr = st.lower_bound(k);\n\t\t\tauto enditr = st.upper_bound(y);\n\t\t\twhile (nowitr != enditr) {\n\t\t\t\tcout << *nowitr << endl;\n\t\t\t\tnowitr++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include<iostream>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<list>\n#include<stack>\n#include<map>\n#include<set>\n#include<string>\n#include <sstream>\n\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<limits.h>\n\nusing namespace std;\n\n\nint main(){\n  long ii,jj,kk;\n  vector<int> a;\n  multiset<int> s;\n  int q,c,x,l,r;\n\n  cin >> q;\n  multiset<int>::iterator it;\n  multiset<int>::iterator lit,rit;  \n  for(ii=0;ii<q;ii++){\n    cin >> c >> x;\n    if(c == 0){\n      s.insert(x);\n      cout << s.size() << endl;\n    }\n    else if(c == 1){\n      it = s.find(x);\n      if(it != s.end()){\n        cout << s.count(x) << endl;\n      }\n      else{\n        cout << 0 << endl;\n      }\n    }\n    else if(c == 2){\n      s.erase(x);\n    }\n    else{\n      l = x;\n      cin >> r;\n      lit = s.lower_bound(l);\n      rit = s.lower_bound(r);\n\n      while(lit != rit){\n        cout << *lit << endl;\n        lit++;\n      }\n      int cnt=0;\n      if(*lit <= r && lit!=s.end()){\n        for(jj=0;jj<s.count(r);jj++){\n          cout << *lit << endl;\n          lit++;\n        }\n\n      }\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void) {\n\tmultiset<int> S;\n\tint q, com, x, y;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> com;\n\t\tswitch (com) {\n\t\t\tcase 0:\n\t\t\t\tcin >> x;\n\t\t\t\tS.insert(x);\n\t\t\t\tcout << S.size() << endl;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcin >> x;\n\t\t\t\tcout << S.count(x) << endl;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcin >> x;\n\t\t\t\tS.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> x >> y;\n\t\t\t\tset<int>::iterator it = S.lower_bound(x);\n\t\t\t\tset<int>::iterator end = S.upper_bound(y);\n\t\t\t\twhile (it != end) {\n\t\t\t\t\tcout << *it << endl;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int> >\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\n\nsigned main(){\n    multiset<int> set;\n    int q;\n    cin>>q;\n    while(q--){\n        int y;\n        cin>>y;\n        if(y==0){\n            int x;\n            cin>>x;\n            set.insert(x);\n            cout<<set.size()<<endl;\n        }\n        else if(y==1){\n            int x;\n            cin>>x;\n            cout<<set.count(x)<<endl;\n        }\n        else if(y==2){\n            int x;\n            cin>>x;\n            set.erase(x);\n        }\n        else{\n            int l,r;\n            cin>>l>>r;\n            for(auto it=set.lower_bound(l);it!=set.upper_bound(r);it++){\n                cout<<*it<<endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define reps(i,a,b) for(int i=a;i<b;++i)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int q;\n    cin >> q;\n    multiset<int> mst;\n    while (q--) {\n        int com, x, l, r;\n        cin >> com;\n        if (com == 0) {\n            cin >> x;\n            mst.insert(x);\n            cout << mst.size() << endl;\n        } else if (com == 1) {\n            cin >> x;\n            cout << mst.count(x) << endl;\n        } else if (com == 2) {\n            cin >> x;\n            mst.erase(x);\n        } else {\n            cin >> l >> r;\n            auto litr = mst.lower_bound(l);\n            auto ritr = mst.upper_bound(r);\n            for (auto itr = litr; itr != ritr; ++itr) {\n                cout << *itr << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <set>\n#include <iterator>\nusing namespace std;\nint main(){\n    int n,temp,k;\n    multiset<int> s;\n    multiset<int>::iterator u;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&k,&temp);\n        if(k==0){\n            s.insert(temp);\n            printf(\"%ld\\n\",s.size());\n        }\n        else if(k==1)printf(\"%ld\\n\",s.count(temp));\n        else if(k==2)s.erase(temp);\n        else{\n            u=s.lower_bound(temp);\n            scanf(\"%d\",&temp);\n            while(u!=s.end()){\n                if(*u>temp)break;\n                printf(\"%d\\n\",*u);\n                u++;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\n\n\n\n\nint main(){\n\t\n\tint q;\n\tcin >> q;\n\tmultiset<int> se;\n\tFOR(i,0,q){\n\t\tll k,x,L,R;\n\t\tcin >> k >> x;\n\t\tif(k==0){\n\t\t\tse.insert(x);\n\t\t\tcout << se.size() << \"\\n\";\n\t\t}else if(k==1){\n\t\t\tcout << se.count(x) << \"\\n\";\n\t\t}else if(k==2){\n\t\t\tse.erase(x);\n\t\t}else if(k==3){\n\t\t\tL = x;\n\t\t\tcin >> R;\n\t\t\tauto it = se.lower_bound(L);\n\t\t\tauto end = se.upper_bound(R);\n\t\t\tfor(;it!=end;it++){\n\t\t\t\tcout << (*it) << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <iomanip>\n#include <unordered_set>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<ll> > vvll;\ntypedef map<int, int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define itn int\n#define endl '\\n';\n#define fi first\n#define se second\n#define NONVOID [[nodiscard]]\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\n\n\n\n\nint main() {\n    multiset<ll> s;\n    ll q,x;\n    ll n;\n    cin>>n;\n    rep(i,n){\n        scanf(\"%lld %lld\",&q,&x);\n        if(q==1){\n            fin(s.count(x));\n        } else if(q==0){\n            s.insert(x);\n            fin(s.size());\n        }\n        else if(q==2){\n            s.erase((x));\n        } else {\n            int r;\n            cin>>r;\n            for(auto i=s.lower_bound(x);i!=s.end()&&*i<=r;i++){\n                if(*i>=x)cout<<*i<<endl;\n            }\n        }\n        \n    }\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    multiset<int> mst;\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int op, x;\n        cin >> op >> x;\n\n        switch (op) {\n            case 0:\n                mst.insert(x);\n                cout << mst.size() << endl;\n                break;\n            case 1:\n                cout << mst.count(x) << endl;\n                break;\n            case 2:\n                mst.erase(x);\n                break;\n            case 3:\n                int r;\n                cin >> r;\n                for (auto itr = mst.lower_bound(x); itr != mst.end() and *itr <= r; ++itr) {\n                    cout << *itr << endl;\n                }\n                break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int q; cin >> q;\n  multiset<int> ms;\n  for (int i = 0; i < q; i++) {\n    int cmd; cin >> cmd;\n    if (cmd == 0) {\n      int x; cin >> x;\n      ms.insert(x);\n      cout << ms.size() << endl;\n    }\n    if (cmd == 1) {\n      int x; cin >> x;\n      cout << ms.count(x) << endl;\n    }\n    if (cmd == 2) {\n      int x; cin >> x;\n      ms.erase(x);\n    }\n    if (cmd == 3) {\n      int l, r; cin >> l >> r;\n      for (auto itr = ms.lower_bound(l), end = ms.upper_bound(r); itr != end; itr++) {\n        cout << *itr << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\nusing VULL = vector<ull>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T, class S>\nbool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S>\nbool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\nint main(){\n    multiset<int> S;\n    int q; cin >> q;\n    REP(i, q){\n        int op, x, y, cnt = 0; cin >> op >> x;\n        switch(op){\n            case 0:\n                S.insert(x);\n                cout << S.size() << endl;\n                break;\n            case 1:\n                for(auto itr = S.lower_bound(x); itr != S.end(); ++itr){\n                    if(*itr == x) ++cnt;\n                    else break;\n                }\n                cout << cnt << \"\\n\";\n                break;\n            case 2:\n                S.erase(x);\n                break;\n            case 3:\n                cin >> y;\n                for(auto itr = S.lower_bound(x); itr != S.end(); ++itr){\n                    if(x <= *itr && *itr <= y)\n                        cout << *itr << \"\\n\";\n                    if(y < *itr)\n                        break;\n                }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int cmd, val;\n  int lhd, rhd;\n\n  multiset<int> s;\n  multiset<int>::iterator it;\n  for (int i = 0; i < n; i++) {\n    cin >> cmd;\n    switch (cmd) {\n      case 0:\n        cin >> val;\n        s.insert(val);\n        cout << s.size() << endl;\n        break;\n\n      case 1:\n        cin >> val;\n        cout << s.count(val) << endl;\n        break;\n\n      case 2:\n        cin >> val;\n        s.erase(val);\n        break;\n\n      case 3:\n        cin >> lhd >> rhd;\n\n        for (auto itr = s.lower_bound(lhd); itr != s.end() && *itr <= rhd;\n             itr++) {\n          cout << *itr << endl;\n        }\n        break;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n    multiset<int> mlS;\n    multiset<int>::iterator begin, end;\n    int q;\n    cin >> q;\n\n    for(int i=0; i<q; i++){\n        int cmd;\n        cin >> cmd;\n        if(cmd==0){\n            int x;\n            cin >> x;\n            mlS.insert(x);\n            cout << mlS.size() << \"\\n\";\n        }\n        else if(cmd==1){\n            int x;\n            cin >> x;\n            cout << mlS.count(x) << \"\\n\";\n        }\n        else if(cmd==2){\n            int x;\n            cin >> x;\n            mlS.erase(x);\n        }\n        else if(cmd==3){\n            int L,R;\n            cin >> L >> R;\n            begin = mlS.lower_bound(L);\n            end = mlS.upper_bound(R);\n            for(; begin!=end; begin++){\n                cout << *begin << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main(void) {\n    int q;\n    std::cin >> q;\n\n    std::multiset<int> my_multiset{};\n    for (int i = 0; i < q; ++i) {\n        int kind;\n        std::cin >> kind;\n\n        int x;\n        switch (kind) {\n            case 0:\n                /// insert\n                std::cin >> x;\n                my_multiset.insert(x);\n                std::cout << my_multiset.size() << std::endl;\n                break;\n            case 1:\n                /// find\n                std::cin >> x;\n                std::cout << my_multiset.count(x) << std::endl;\n                break;\n            case 2:\n                /// delete\n                std::cin >> x;\n                my_multiset.erase(x);\n                break;\n            case 3:\n                /// dump\n                int l, r;\n                std::cin >> l >> r;\n                for (auto iter = my_multiset.lower_bound(l);\n                     iter != my_multiset.upper_bound(r); ++iter)\n                    std::cout << *iter << std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <set>\n\nusing namespace std;\n\nint main()\n{\n    int q;\n    cin >> q;\n\n    multiset<int> S;\n    int cmd, x, L, R;\n    while (q--)\n    {\n        cin >> cmd;\n        if (cmd == 0)\n        {\n            cin >> x;\n            S.insert(x);\n            cout << S.size() << endl;\n        }\n        else if (cmd == 1)\n        {\n            cin >> x;\n            // cout << (S.find(x) != S.end()) << endl;\n            cout << S.count(x) << endl;\n        }\n        else if (cmd == 2)\n        {\n            cin >> x;\n            S.erase(x);\n            // remove(S.begin(), S.end(), x);\n        }\n        else\n        {\n            cin >> L >> R;\n            multiset<int>::iterator it1 = S.lower_bound(L), it2 = S.upper_bound(R);\n            while (it1 != it2)\n            {\n                cout << *it1 << endl;\n                it1++;\n            }\n\n        }\n        \n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1000000000\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\nint main (){\n    int q;cin>>q;\n    multiset<int> st;\n    rep(i,0,q){\n        int a,b;cin>>a>>b;\n        if(a==0){\n            st.insert(b);\n            cout<<st.size()<<endl;\n        }else if(a==1){\n            cout<<st.count(b)<<endl;\n        }else if(a==2){\n            st.erase(b);\n        }else {\n            int r;cin>>r;\n            auto low=st.lower_bound(b);\n            auto high=st.upper_bound(r);\n            for(auto it=low;it!=high;it++)cout<<*it<<endl;\n            \n            \n        }\n    }\n    \n    \n}\n\n\n\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define int long long\nusing namespace std;\nsigned main() {\n\tmultiset<int>s;\n\tint w; cin >> w;\n\tfor (int i = 0; i < w; i++) {\n\t\tint n, x, l, r; cin >> n;\n\t\tif (n == 0) {\n\t\t\tcin >> x;\n\t\t\ts.insert(x);\n\t\t\tcout << s.size() << endl;\n\t\t}\n\t\telse if (n == 1) {\n\t\t\tcin >> x;\n\t\t\tcout << s.count(x) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tcin >> x;\n\t\t\ts.erase(x);\n\t\t}\n\t\telse {\n\t\t\tcin >> l >> r;\n\t\t\tfor (auto i = s.lower_bound(l); i != s.upper_bound(r); i++)cout << *i << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    int q;\n    cin >> q;\n    int a, x, y;\n    multiset<int> s;\n    while(q--){\n        cin >> a >> x;\n        if(a==0){\n            s.insert(x);\n            cout << s.size() << \"\\n\";\n        }else if(a==1){\n            cout << s.count(x) << \"\\n\";\n        }else if(a==2){\n            s.erase(x);\n        }else{\n            cin >> y;\n            set<int>:: iterator start, end;\n            end=s.upper_bound(y);\n            for(start=s.lower_bound(x); start!=end; start++){\n                cout << *start << \"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tmultiset<int> S;\n\n\tint query, x;\n\tint L, R;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tif (query == 0) {\n\t\t\tcin >> x;\n\t\t\tS.insert(x);\n\t\t\tcout << S.size() << endl;\n\t\t}\n\t\telse if (query == 1){\n\t\t\tcin >> x;\n\t\t\t\tcout << S.count(x) << endl;\t\n\t\t}\n\t\telse if(query == 2){\n\t\t\tcin >> x;\n\t\t\tS.erase(x);\t\t\n\t\t}\n\t\telse {\n\t\t\tcin >> L >> R;\n\t\t\tfor (auto itr = S.lower_bound(L); itr != S.upper_bound(R); itr++) {\n\t\t\t\tcout << *itr << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include<vector>\n#include <algorithm>\n#include <queue>\n#include<string>\n#include <map>\n#include <cmath>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <set>\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define REP(i,s,n)for(ll i=s;i<(n);++i)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nll S[1000] = { 0 };\nll N,M,Q;\n\n\nint main() {\n\tmultiset<ll>A;\n\tcin >> Q;\n\trep(i, Q) {\n\t\tll a, b,c;\n\t\tcin >> a ;\n\t\tif (a==0) {\n\t\t\tcin >> b;\n\t\t\tA.insert(b);\n\t\t\tcout << A.size() << endl;\n\t\t}\n\t\telse if(a==1){\n\t\t\tcin >> b;\n\t\t\tcout << A.count(b)<< endl;\n\t\t}\n\t\telse if (a == 2) {\n\t\t\tcin >> b;\n\t\t\tA.erase(b);\n\t\t}\n\t\telse {\n\t\t\tcin >> b >> c;\n\t\t\tfor (set<ll>::iterator j = A.lower_bound(b); j != A.upper_bound(c); ++j) {\n\t\t\t\tcout << *j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i, n, m) for (int i = (int) (n); i < (int) (m); i++)\n#define rep(i, n) reps(i, 0, (n))\n#define all(v) (v).begin(), (v).end()\n\nint main() {\n    int q; cin >> q;\n    multiset<int> s;\n    while (q--) {\n        int a, x; cin >> a >> x;\n        if (a == 0) {\n            s.insert(x); cout << s.size() << endl;\n            \n        } else if (a == 1) {\n            cout << s.count(x) << endl;\n        } else if (a == 2) {\n            s.erase(x);\n        } else {\n            int y; cin >> y;\n            auto b = s.lower_bound(x);\n            auto e = s.upper_bound(y);\n            for (auto i = b; i != e; i++) {\n                cout << *i << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lli long long int\n#define FILE_IN freopen(\"input.txt\", \"r\", stdin);\n#define FILE_OUT freopen(\"output.txt\", \"w\", stdout);\n#define PI acos(-1)\nusing namespace std;\nvoid fastio()\n{\n ios_base::sync_with_stdio(false);\n  cin. tie(0);\n  cout. tie(0);\n\n}\nint main() {\n fastio();\n  int f,t,x,y;\n    multiset<int>s;\n multiset<int>::iterator it1,it2;\n    cin>>t;\n    while(t--) {\n        cin>>f>>x;\n        if(f==0) {\n            s.insert(x);\n            cout<<s.size()<<endl;\n        }\n        else if(f==1)\n            cout<<s.count(x)<<endl;\n\n       else if(f==2)\n          s.erase(x);\n\n       else{\n          cin>>y;\n\n         it1=s.lower_bound(x);\n         it2=s.upper_bound(y);\n         for(;it1 != it2;it1++)\n          cout<<*it1<<endl;\n       }\n\n}\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n   cin.tie(NULL);\n    cout.tie(NULL);\n\n    ll q, x, p, o;\n    multiset <ll> ms;\n\n    cin >> q;\n\n    while(q--)\n    {\n        cin >> x >> p;\n\n        if(x == 0)\n        {\n            ms.insert(p);\n            cout << ms.size() << endl;\n        }\n\n        else if(x == 1)\n            cout << ms.count(p) << endl;\n\n        else if(x == 2)\n            ms.erase(p);\n\n        else\n        {\n            cin >> o;\n            auto it = ms.lower_bound(p);\n\n            for(; it != ms.end() && *it <= o; it++)\n                cout << *it << endl;\n        }\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tmultiset<long long> s;\t\n\tlong q;\n\n\tcin >> q;\n\n\tfor (long i = 0; i < q; i++) {\n\t\tint t;\n\t\tlong long x;\n\t\tcin >> t >> x;\n\n\t\tif (t == 0) {\n\t\t\ts.insert(x);\n\t\t\tcout << s.size() << endl;\n\t\t}\n\t\telse if (t == 1)\n\t\t\tcout << s.count(x) << endl;\n\t\telse if (t == 2)\n\t\t\ts.erase(x);\n\t\telse if (t == 3) {\n\t\t\tlong long y;\n\t\t\tstd::set<long long>::iterator it;\n\n\t\t\tcin >> y;\n\n\t\t\tfor (it = s.lower_bound(x); it != s.upper_bound(y); it++)\n\t\t\t\tcout << *it << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n    multiset<int> st;\n    int q,a,b,c;\n    cin >> q;\n    for (int i=0;i<q;i++) {\n        cin >> a;\n        if ( a==0 ) {\n            cin >> b;\n            st.insert(b);\n            cout << st.size() << endl;\n        } else if ( a==1 ) {\n            cin >> b;\n            cout << st.count(b) << endl;\n        } else if ( a==2 ) {\n            cin >> b;\n            if ( st.find(b)!=st.end() ) {\n                st.erase(b);\n            }\n        } else if ( a==3 ) {\n            cin >> b >> c;\n            auto itr1 = st.lower_bound(b);\n            auto itr2 = st.upper_bound(c);\n            for (itr1;itr1!=itr2;++itr1) {\n                cout << *itr1 << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define FORR(i, m, n) for (int i = (m); i >= (n); i--)\n#define REP(i, n) FOR(i, 0, (n))\n#define REPR(i, n) FORR(i, (n) - 1, 0)\n#define REP1(i, n) FOR(i, 1, (n) + 1)\n#define REPS(c, s) for (char c : s)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n#define REV(c) reverse(ALL(c))\n#define sz(v) (int)v.size()\n#define endl '\\n'\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T> inline void printv(vector<T>& v) {int n = sz(v); REP(i, n) cout << v[i] << (i == n - 1 ? endl : ' ');}\nconst int MOD = 1000000007;\nconst int INF = 1000000001;\nconst ll LINF = 1000000001000000001LL;\n \nvoid solve();\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(numeric_limits<double>::max_digits10);\n    solve();\n    return 0;\n}\n\nvoid solve() {\n    int q;\n    cin >> q;\n    multiset<int> s;\n    while (q--) {\n        int c, x;\n        cin >> c >> x;\n        if (c == 0) {\n            s.emplace(x);\n            cout << sz(s) << endl;\n        } else if (c == 1) {\n            cout << s.count(x) << endl;\n        } else if (c == 2) {\n            s.erase(x);\n        } else if (c == 3) {\n            int y;\n            cin >> y;\n            auto st = s.lower_bound(x);\n            auto ed = s.upper_bound(y);\n            for (;st != ed; st++) cout << *st << endl;\n        }\n    } \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n \nusing namespace std;\n \ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n \ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n  \n\tmultiset<int> s;\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tint op, el;\n\t\tcin >> op >> el;\n\t\tif(op == 1)cout << s.count(el) << '\\n';\n\t\telse if(op == 2)s.erase(el);\n\t\telse if(op == 3){\n\t\t\tint r;cin >> r;\n\t\t\tauto lef = s.lower_bound(el);\n\t\t\tauto right = s.upper_bound(r);\n\t\t\twhile(lef != right)cout << *lef << '\\n', lef++;\n\t\t\t\n\t\t}\n\t\telse s.insert(el), cout << s.size() << '\\n';\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main()\n{\t\n\tstd::multiset<int> S;\n\t\n\tint q; std::cin >> q;\n\tfor (int i=0; i<q; i++) {\n\t\tint op, x, L, R;\n\t\tstd::cin >> op;\n\t\tif (op==0) {\n\t\t\tstd::cin >> x;\n\t\t\tS.insert(x);\n\t\t\tstd::cout << S.size() << std::endl;\n\t\t}\n\t\telse if (op==1) {\n\t\t\tstd::cin >> x;\n\t\t\tstd::cout << S.count(x) << std::endl;\n\t\t}\n\t\telse if (op==2) {\n\t\t\tstd::cin >> x;\n\t\t\tS.erase(x);\n\t\t}\n\t\telse {\n\t\t\tstd::cin >> L >> R;\n\t\t\tstd::set<int>::iterator lb = S.lower_bound(L);\n\t\t\tstd::set<int>::iterator ub = S.upper_bound(R);\n\t\t\tfor (std::set<int>::iterator it = lb; it != ub; ++it) std::cout << *it << std::endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n/* 大文字を小文字に変換 */\nchar tolower(char c) {return (c + 0x20);}\n/* 小文字を大文字に変換 */\nchar toupr(char c) {return (c - 0x20);}\n\n// if('A'<=s[i] && s[i]<='Z') s[i] += 'a'-'A';\n\n/*\nstring s = \"abcdefg\"\ns.substr(4) \"efg\"\ns.substr(0,3) \"abc\"\ns.substr(2,4) \"cdef\"\n\n// イテレータ要素のインデックス\ndistance(A.begin(), itr);\n*/\n\nint main()\n{\n    int q; cin >> q;\n    multiset<int> S;\n    rep(i,q){\n        int query; cin >> query;\n        if(query == 0){\n            int x; cin >> x;\n            S.insert(x);\n            cout << S.size() << endl;\n        }else if(query == 1){\n            int x; cin >> x;\n            cout << S.count(x) << endl;\n        }else if(query == 2){\n            int x; cin >> x;\n            S.erase(x);\n        }else if(query == 3){\n            int L,R; cin >> L >> R;\n            auto it = S.lower_bound(L);\n\t\t\twhile (it != S.end() && *it <= R) {\n\t\t\t\tprintf(\"%d\\n\", *it); ++it;\n\t\t\t}\n        }\n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n\nvoid solve(){\n    int q; cin >> q;\n    map<ll,ll> mp;\n    ll allnum = 0;\n    while(q--){\n        int com; cin >> com;\n        if(com == 0){\n            int x; cin >> x;\n            mp[x]++;\n            allnum++;\n            cout << allnum << endl;\n        }\n        if(com == 1){\n            int x; cin >> x;\n            cout << mp[x] << endl;\n        }\n        if(com == 2){\n            int x; cin >> x;\n            allnum -= mp[x];\n            mp[x] = 0;\n        }\n        if(com == 3){\n            ll L,R; cin >> L >> R;\n            for(auto it = mp.lower_bound(L); it != mp.end() ; it++){\n                if(it->first > R) break;\n                for(int j = 0; j < it->second;j++){\n                    cout << it->first << endl;\n                }\n            }\n        }\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <set>\n//#define LOCAL\nusing namespace std;\ntypedef long long ll;\nmultiset<ll>s;\n\nint main() {\n#ifdef LOCAL\nifstream fin(\"1.txt\");\nstreambuf*p;\np=cin.rdbuf(fin.rdbuf());\n#endif // LOCAL\nll q;\ncin>>q;\nfor(ll i=0;i<q;i++){\n    ll a,b;\n    cin>>a>>b;\n    if(0==a){\n        s.insert(b);\n        cout<<s.size()<<endl;\n    }else if(1==a){\n        cout<<s.count(b)<<endl;\n    }else if(2==a){\n        s.erase(b);\n    }else{\n        ll t;\n        cin>>t;\n        set<ll>::iterator i1=s.lower_bound(b);\n        set<ll>::iterator i2=s.upper_bound(t);\n        for(;i1!=i2;i1++) cout<<(*i1)<<endl;\n    }\n}\n\n#ifdef LOCAL\nfin.close();\n#endif // LOCAL\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e6+5;\nmultiset<int> s;\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int q;cin>>q;while(q--){\n        int op=0;cin>>op;\n        if(op==3){\n            int l,r;\n            cin>>l>>r;\n            auto ed=s.upper_bound(r);\n            for(auto it=s.lower_bound(l);it!=ed;it++)cout<<*it<<endl;\n        }else{\n            int x=0;\n            cin>>x;\n            if(op==0){s.insert(x);cout<<s.size()<<endl;}\n            if(op==1){cout<<s.count(x)<<endl;}\n            if(op==2){s.erase(x);}\n        }\n        \n    }\n}\n/* \n\n- insert(xx): Insert xx to SS and report the number of elements in SS after the operation.\n- find(xx): Report the number of xx in SS.\n- delete(xx): Delete all xx from SS.\n- dump(LL, RR): Print elements xx in SS such that L≤x≤RL≤x≤R\n9\n0 1\n0 2\n0 3\n2 2\n1 1\n1 2\n1 3\n0 4\n3 2 4\n */\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\nint main(){\n\tmultiset<int>s;\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint c,x;\n\t\tcin>>c>>x;\n\t\tif(c==0){\n\t\t\ts.insert(x);\n\t\t\tcout<<s.size()<<endl;\n\t\t}\n\t\telse if(c==1){\n\t\t\tcout<<s.count(x)<<endl;\n\t\t}\n\t\telse if(c==2){\n\t\t\ts.erase(x);\n\t\t}\n\t\telse if(c==3){\n\t\t\tint y;\n\t\t\tcin>>y;\n\t\t\tfor(set<int>::iterator i=s.lower_bound(x); i!=s.upper_bound(y); i++)\n\t\t\t\tcout<<*i<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro_and_Function\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nT DEG_2_RAD(T deg) {\n    return deg * PI / 180;\n}\ntemplate <class T>\nT RAD_2_DEG(T rad) {\n    return rad * 180 / PI;\n}\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\nvoid operator*=(string& l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { l += str; }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro_and_Function\n\nint main() {\n    PRE_COMMAND\n    int n;\n    multiset<int> s;\n    INPUT(n);\n    REP(i, n) {\n        int a, b, c;\n        INPUT(a, b);\n        if (a == 0) {\n            s.insert(b);\n            PRINT(SZ(s));\n        } else if (a == 1) {\n            PRINT(s.count(b));\n        } else if (a == 2) {\n            s.erase(b);\n        } else {\n            INPUT(c);\n            auto lb = s.lower_bound(b);\n            auto lc = s.lower_bound(c + 1);\n            for (auto j = lb; j != lc; j++) { PRINT(*j); }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main()\n{\n    int n, q, x, y;\n\n    multiset<int> a;\n\n    cin >> n;\n\n    for( int i = 0; i < n; i++ )\n    {\n        cin >> q >> x;\n        if( q == 0 )\n        {\n            a.insert(x);\n            cout << a.size() << endl;\n        }\n        else if( q == 1 )\n            cout << a.count(x) << endl;                                 //countという、指定された値の個数を返す関数もある。setは重複を許さないので0 or 1が返る。\n        else if( q == 2 )\n            a.erase(x);\n        else\n        {\n            cin >> y;\n            multiset<int>::iterator l = a.lower_bound(x), r = a.upper_bound(y);\n            for(; l != r; l++ )\n                cout << *l << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    ll q, c, x, y;\n    multiset<ll> s;\n    cin >> q;\n    for(ll i = 0; i < q; i++){\n        cin >> c >> x;\n        if (c == 0){\n            s.insert(x);\n            cout << s.size() << endl;\n        }else if(c == 1){\n            cout << s.count(x) << endl;\n        }else if(c == 2){\n            auto j = s.find(x);\n            if(j != s.end()){\n                s.erase(x);\n            }\n        }else{\n            cin >> y;\n            auto b = s.lower_bound(x);\n            auto e = s.upper_bound(y);\n            if(b != e){\n                for(auto j = b; j != e; j++){\n                    cout << *j << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vecll = vector<long long>;\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (long long i = 0; i < (long long)(n); i++)\n\nint main()\n{\n    ll q, que, x, y;\n    multiset<ll> S;\n    cin >> q;\n\n    rep(i, q)\n    {\n        cin >> que >> x;\n        if (que == 0)\n            S.insert(x);\n        else if (que == 2)\n        {\n            S.erase(x);\n            continue;\n        }\n        else if (que == 3)\n        {\n            cin >> y;\n            //delctype(S)\n            multiset<ll>::iterator first_itr = S.lower_bound(x);\n            multiset<ll>::iterator end_itr = S.upper_bound(y);\n\n            for (auto i = first_itr; i != end_itr; ++i)\n                cout << *i << endl;\n\n            /*for (int i = x; i <= y; i++)\n            {\n                if (S.find(i) != S.end())\n                {\n                    cout << *S.find(i) << endl;\n                }\n            }*/\n\n                /*for(struct { ll i; int j;} s = { x, 0} ; s.i <= y ; ++s.i , ++s.j)\n            {\n                if (S.find(s.i) != S.end())\n                {\n                    //cout << (s.j ? \" \" : \"\");\n                    cout << *S.find(s.i) << endl;\n                }\n            }*/\n                continue;\n        }\n\n        cout << (que ? S.count(x) : S.size()) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#define long long long\n#define LF '\\n'\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\ntypedef pair<int,int> pii;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF = 0x3f3f3f3f;\n\n\nsigned main()\n{\n  cin.tie(nullptr), ios::sync_with_stdio(false);\n  multiset<int> U;\n  int Q;\n\n  cin >> Q;\n  while(Q--) {\n    int com, x, y;\n    cin >> com;\n\n    switch(com) {\n    case 0:\n      cin >> x;\n      U.insert(x);\n      cout << U.size() << LF;\n      break;\n\n    case 1:\n      cin >> x;\n      cout << U.count(x) << endl;\n      break;\n\n    case 2:\n      cin >> x;\n      U.erase(x);\n      break;\n\n    default:\n      cin >> x >> y;\n      for (auto it = U.lower_bound(x), end=U.upper_bound(y); it != end; ++it) {\n        cout << *it << LF;\n      }\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int q;\n    cin >> q;\n    set<int> se;\n    map<int, int> mp;\n    int sum = 0;\n    while(q--) {\n        int t, x;\n        cin >> t >> x;\n        if(t == 0) {\n            se.insert(x);\n            sum++;\n            cout << sum << '\\n';\n            mp[x]++;\n        } else if(t == 1) {\n            set<int>::iterator itr = se.find(x);\n            cout << (itr != se.end()?mp[x]:0) << '\\n';\n        } else if(t == 2) {\n            sum -= mp[x];\n            se.erase(x);\n            mp.erase(x);\n        } else {\n            int r;\n            cin >> r;\n            auto itr = se.lower_bound(x);\n            for(;*itr <= r and itr != se.end(); itr = next(itr)) {\n                rep(i, mp[*itr]) {\n                    cout << *itr << '\\n';\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T>\nclass node\n{\npublic:\n    T data;\n    node<T> *left = NULL;\n    node<T> *right = NULL;\n    int balance = 0;\n    node(T data)\n    {\n        this->data = data;\n    };\n\n    // you can implement other relevant things here\n    // TODO\n    int depth = 1;\n};\ntemplate <typename T>\nclass AVLtree\n{\n    node<T> *root = NULL;\n\n    /// you can implement other relevant things here\n    /// TODO\n    int N = 0;\n    int Depth(node<T>* &root) {\n        return root->depth;\n    }\n    int GetBalance(node<T>* &root) {\n        int depth_Left, depth_Right;\n        if (!root->left) depth_Left = 0;\n        else depth_Left = root->left->depth;\n        if (!root->right) depth_Right = 0;\n        else depth_Right = root->right->depth;\n        return depth_Left - depth_Right;\n    }\n    int update_depth(node<T>* &root) {\n        int depth_root, depth_Left, depth_Right;\n        if (!root->left) depth_Left = 0;\n        else depth_Left = root->left->depth;\n        if (!root->right) depth_Right = 0;\n        else depth_Right = root->right->depth;\n        depth_root = (depth_Left > depth_Right ? depth_Left : depth_Right) + 1;\n        return root->depth = depth_root;\n    }\n    node<T>* rotLeft(node<T>* &root) {\n        node<T>* y = root;\n        node<T>* x = y->right;\n        y->right = x->left;\n        x->left = y;\n        update_depth(y);\n        update_depth(x);\n        return x;\n    }\n    node<T>* rotRight(node<T>* &root) {\n        node<T>* y = root;\n        node<T>* x = y->left;\n        y->left = x->right;\n        x->right = y;\n        update_depth(y);\n        update_depth(x);\n        return x;\n    }\n    node<T>* rotLeftRight(node<T>* &root) {\n        node<T>* y = root;\n        node<T>* x = y->left;\n        node<T>* z = x->right;\n        x->right = z->left;\n        z->left = x;\n\n        y->left = z->right;\n        z->right = y;\n        update_depth(y);\n        update_depth(x);\n        update_depth(z);\n        return z;\n//        root->left = rotLeft(root->left);\n//        return rotRight(root);\n    }\n    node<T>* rotRightLeft(node<T>* &root) {\n        node<T>* y = root;\n        node<T>* x = y->right;\n        node<T>* z = x->left;\n        x->left = z->right;\n        z->right = x;\n\n        y->right = z->left;\n        z->left = y;\n        update_depth(y);\n        update_depth(x);\n        update_depth(z);\n        return z;\n//        root->right = rotRight(root->right);\n//        return rotLeft(root);\n    }\n    node<T>* add(node<T>* &root, T &data) {\n        if (root == NULL) {\n            node<T>* Node = new node<T>(data);\n            return Node;\n        }\n        else {\n            if (data >= root->data) {\n                root->right = add(root->right, data);\n            }\n            else {\n                root->left = add(root->left, data);\n            }\n            update_depth(root);\n            int balance = GetBalance(root);\n            if (balance > 1) {\n                if (GetBalance(root->left) >= 0) root = rotRight(root);\n                else root = rotLeftRight(root);\n            }\n            if (balance < -1) {\n                if (GetBalance(root->right) <= 0) root = rotLeft(root);\n                else root = rotRightLeft(root);\n            }\n            return root;\n        }\n    }\n    node<T>* find_max(node<T>* &root) {\n        if (root == NULL) return NULL;\n        if (root->right == NULL) return root;\n        return find_max(root->right);\n    }\n    node<T>* find_min(node<T>* &root) {\n        if (root == NULL) return NULL;\n        if (root->left == NULL) return root;\n        return find_min(root->left);\n    }\n    node<T>* find_value(node<T>* &root, T &data) {\n        if (root == NULL) return NULL;\n        if (root->data == data) return root;\n        if (data < root->data) return find_value(root->left, data);\n        return find_value(root->right, data);\n    }\n    node<T>* remove(node<T>* &root, T &data){\n        if (root == NULL) return NULL;\n        if (data < root->data) root->left = remove(root->left, data);\n        else {\n            if (data > root->data) root->right = remove(root->right, data);\n            else {\n                if (root->left == NULL && root->right == NULL) {\n                    delete root;\n                    root = NULL;\n                    return NULL;\n                }\n                if (root->left == NULL) return root->right;\n                if (root->right == NULL) return root->left;\n                node<T> *y = find_min(root->right);\n                root->data = y->data;\n                root->right = remove(root->right, root->data);\n            }\n        }\n        update_depth(root);\n        int D = Depth(root);\n        int Balance = GetBalance(root);\n        if (Balance > 1 && GetBalance(root->left) >= 0) return rotRight(root);\n        if (Balance > 1 && GetBalance(root->left) < 0) return rotLeftRight(root);\n        if (Balance < -1 && GetBalance(root->right) <= 0) return rotLeft(root);\n        if (Balance < -1 && GetBalance(root->right) > 0) return rotRightLeft(root);\n        return root;\n    }\n    node<T>* lower_bound(node<T>* &root, T &data) {\n        if (root == NULL) return NULL;\n        if (root->data < data) return lower_bound(root->right, data);\n        node<T> *Res = lower_bound(root->left, data);\n        if (Res != NULL) return Res;\n        return root;\n    }\n    node<T>* upper_bound(node<T>* &root, T &data) {\n        if (root == NULL) return NULL;\n        if (root->data > data) return upper_bound(root->left, data);\n        node<T> *Res = upper_bound(root->right, data);\n        if (Res != NULL) return Res;\n        return root;\n    }\n    void print(node<T> *&subroot)\n    {\n        if (subroot == 0)\n        {\n            cout << '*';\n            return;\n        }\n        cout << subroot->data;\n        cout << '(';\n        print(subroot->left);\n        cout << '|';\n        print(subroot->right);\n        cout << ')';\n        return;\n    }\n    void PrintLNR(node<T>* &root) {\n        if (root == 0) return;\n        PrintLNR(root->left);\n        cout << root->data << ' ';\n        PrintLNR(root->right);\n    }\n\npublic:\n    AVLtree() {}\n\n    // the add function:\n    int size() {\n        return N;\n    }\n    bool empty() {\n        return root == NULL;\n    }\n    bool add(T &data)\n    {\n        ///if (find_value(root, data) == NULL)\n        root = add(root, data);\n        N++;\n        return true;\n    }\n    bool find(T &data) {\n        return find_value(root, data) != NULL;\n    }\n    bool remove(T &data) {\n        if (find_value(root, data) == NULL) return false;\n        N--;\n        root = remove(root, data);\n        return true;\n    }\n    bool DoLower_bound(T &data, T &Value) {\n        node<T>* Res = lower_bound(root, data);\n        if (Res == NULL) {\n            return false;\n        }\n        Value = Res->data;\n        return true;\n    }\n    bool DoUpper_bound(T &data, T &Value) {\n        node<T>* Res = upper_bound(root, data);\n        if (Res == NULL) {\n            return false;\n        }\n        Value = Res->data;\n        return true;\n    }\n    T find_min() {\n        return find_min(root)->data;\n    }\n    T find_max() {\n        return find_max(root)->data;\n    }\n    void print()\n    {\n        ///print(root);\n        PrintLNR(root);\n    }\n};\n\n#define INP \"solve\"\n#define OUT \"solve\"\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(nullptr); cout.tie(nullptr);\n    ///freopen(INP \".inp\",\"r\",stdin);\n    ///freopen(OUT \".out\",\"w\",stdout);\n\tAVLtree<int> ATree;\n\tint Q;\n\tcin >> Q;\n\twhile (Q--) {\n        int Type;\n        cin >> Type;\n        if (Type == 0) {\n            int x;\n            cin >> x;\n            ATree.add(x);\n            cout << ATree.size() << '\\n';\n        }\n        if (Type == 1) {\n            int x;\n            cin >> x;\n            vector <int> A;\n            while (ATree.find(x)) {\n                A.push_back(x);\n                ATree.remove(x);\n            }\n            cout << (int)A.size() << '\\n';\n            for (int x : A) ATree.add(x);\n        }\n        if (Type == 2) {\n            int x;\n            cin >> x;\n            while (ATree.find(x)) ATree.remove(x);\n        }\n        if (Type == 3) {\n            int L, R;\n            cin >> L >> R;\n            vector <int> A;\n            if (ATree.DoLower_bound(L, L) == true) {\n                while (L <= R) {\n                    A.push_back(L);\n                    ATree.remove(L);\n                    if (ATree.DoLower_bound(L, L) == false) break;\n                }\n            }\n            for (int x : A) {\n                cout << x << '\\n';\n                ATree.add(x);\n            }\n        }\n\t}\n\n//    while (true) {\n//        int Type;\n//        cin >> Type;\n//        if (Type == 0) break;\n//        if (Type == 1) {\n//            int x;\n//            cin >> x;\n//            ATree.add(x);\n//            continue;\n//        }\n//        if (Type == 2) {\n//            int x;\n//            cin >> x;\n//            ATree.remove(x);\n//            continue;\n//        }\n//        if (ATree.empty()) {\n//            if (Type > 4) {\n//                int x;\n//                cin >> x;\n//            }\n//            cout << \"empty\" << '\\n';\n//            continue;\n//        }\n//        if (Type == 3) {\n//            cout << ATree.find_min() << '\\n';\n//            continue;\n//        }\n//        if (Type == 4) {\n//            cout << ATree.find_max() << '\\n';\n//            continue;\n//        }\n//        int x;\n//        cin >> x;\n//        int Res = -1;\n//        if (Type == 5) x++;\n//        if (Type <= 6) {\n//            if (ATree.DoLower_bound(x, Res)) cout << Res << '\\n';\n//            else cout << \"no\" << '\\n';\n//            continue;\n//        }\n//        if (Type == 7) x--;\n//        if (ATree.DoUpper_bound(x, Res)) cout << Res << '\\n';\n//        else cout << \"no\" << '\\n';\n//    }\n    ///ATree.print();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::multiset<int> s;\n    int Q;\n    std::cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int t;\n        std::cin >> t;\n        if (t == 0) {\n            int x;\n            std::cin >> x;\n            s.insert(x);\n            std::cout << s.size() << \"\\n\";\n        } else if (t == 1) {\n            int x;\n            std::cin >> x;\n            std::cout << s.count(x) << \"\\n\";\n        } else if (t == 2) {\n            int x;\n            std::cin >> x;\n            s.erase(x);\n        } else {\n            int l, r;\n            std::cin >> l >> r;\n            auto e = s.upper_bound(r);\n            for (auto itr = s.lower_bound(l); itr != e; ++itr) std::cout << *itr << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n    int num_query,command,val,val2;\n    scanf(\"%d\",&num_query);\n    multiset<int> int_set;\n    multiset<int>::iterator itr;\n    \n    for(int i = 0;i < num_query;i++){\n        scanf(\"%d %d\",&command,&val);\n        if(command == 0){\n            int_set.insert(val);\n            printf(\"%d\\n\",(int)int_set.size());\n        }else if(command == 1){\n            int counter = int_set.count(val);\n            printf(\"%d\\n\",counter);\n        }else if(command == 2){\n            int_set.erase(val);\n        }else if(command == 3){\n            scanf(\"%d\",&val2);\n            itr = int_set.lower_bound(val);\n            while(int_set.end() != itr && *itr <= val2){\n                printf(\"%d\\n\",*itr);\n                itr++;\n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF (2e9)\n#define FOR(i, a, b) for (ll (i) = (a); (i) < (b); ++(i))\n#define REP(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ld = long double;\n\n#define ALL(x) (x).begin(), (x).end()\ntemplate<class T>\nusing vc = vector<T>;\nusing vi = vc<ll>;\nusing vvi = vc<vi>;\n\ntemplate<class T>\nusing va = valarray<T>;\nusing vad = va<ld>;\nusing vai = va<ll>;\n\nusing pii = pair<ll, ll>;\n\nvi Read(ll n) {\n    auto      v = vi(n);\n    for (auto i = std::size_t(0); i < n; ++i) {\n        cin >> v[i];\n    }\n    return v;\n}\n\ntemplate<class T>\nvoid DumpRow(const T& A) {\n    for (const auto& value : A)\n        cout << value << \"\\n\";\n}\n\ntemplate<class T>\nvoid DumpColumn(const T& A) {\n    auto isFirst = true;\n    for (const auto& value : A) {\n        if (isFirst) {\n            cout << value;\n            isFirst = false;\n        } else {\n            cout << \" \" << value;\n        }\n\n    }\n    cout << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    auto v = multiset<int>();\n\n    REP(i, n) {\n        int q, x;\n        cin >> q >> x;\n        if (q == 0) {\n            v.insert(x);\n            cout << v.size() << endl;\n        } else if (q == 1){\n            cout << v.count(x) << endl;\n        } else if (q == 2){\n            v.erase(x);\n        } else if (q == 3){\n            int y;\n            cin >> y;\n            auto it = v.lower_bound(x);\n            while (it != v.end() && *it <= y){\n                cout << *it << endl;\n                ++it;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\nusing namespace std;\n\nint main()\n{  \n    int n;\n    cin>>n;\n    multiset<int>s;\n    REP(i,n)\n    {\n        int x,y;\n        cin>>x>>y;\n        if(x==0){s.insert(y);cout<<s.size()<<endl;}\n        if(x==1)cout<<s.count(y)<<endl;\n        if(x==2)\n        {\n            if(s.find(y)!=s.end())s.erase(y);\n        }\n        if(x==3)\n        {\n            int z;\n            cin>>z;\n            decltype(s)::iterator it=s.lower_bound(y);\n            decltype(s)::iterator end=s.upper_bound(z);\n            while(it!=end)\n            {\n                cout<<*it<<endl;\n                ++it;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint q;cin>>q;\n\n\tmultiset<int> st;\n\tst.insert(1e9+1);\n\twhile(q--){\n\t\tint query,y;cin>>query>>y;\n\t\tif(query==0){\n\t\t\t// insert\n\t\t\tst.insert(y);\n\t\t\tcout<<(st.size()-1)<<endl;\n\t\t}else if(query==1){\n\t\t\tcout<<st.count(y)<<endl;\n\t\t}else if(query==2){\n\t\t\tst.erase(y);\n\t\t}else{\n\t\t\tint r;cin>>r;\n\t\t\tfor(auto it=st.lower_bound(y);it!=st.upper_bound(r);++it){\n\t\t\t\tcout<<*it<<endl;\n\t\t\t}\n\t\t}\n\t}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i = 0; i<n; i++)\ntypedef long long ll;\nusing namespace std;\n\nint main(){\n multiset<int> s;\n  int n,a,b,c;\n  cin >> n;\n  while(n--){\n    cin >> a>>b;\n    if(!a){\n      s.insert(b);\n      cout << s.size() <<endl;\n    }\n    else if(a==1)cout << s.count(b) << endl;\n    else if(a==2)s.erase(b);\n    else{\n      cin >> c;\n      auto it=s.lower_bound(b),end=s.upper_bound(c);\n      for(;it!=end;it++){\n        cout << *it<<endl;\n      }\n    }\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 100000000\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define mod 1000000007\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    multiset<ll>s;\n    ll q;cin>>q;\n    while(q--){\n        ll a,x;cin>>a>>x;\n        if(a==0){\n            s.insert(x);\n            cout<<s.size()<<endl;\n        }\n        else if(a==1){\n            cout<<s.count(x)<<endl;\n        }\n        else if(a==2){\n                s.erase(x);\n        }\n        else{\n            ll l=x;\n            ll r;cin>>r;\n\n            auto left=s.lower_bound(l);\n\n            auto right=s.upper_bound(r);\n            for(auto it=left;it!=right;it++){\n                cout<<*it<<endl;\n            }\n        }\n    }\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  multiset <int> S;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, num;\n    cin>>cmd>>num;\n    if(cmd == 0){\n      S.insert(num);\n      cout<<S.size()<<endl;\n    }\n\n    if(cmd == 1){\n      cout<<S.count(num)<<endl;\n    }\n    \n    if(cmd == 2){\n      S.erase(num);\n    }\n\n    if(cmd == 3){\n      int l = num, r;\n      cin>>r;\n      auto start = S.lower_bound(l);\n      auto last= S.upper_bound(r);\n      for(auto it = start; it != last; it++) cout<<*it<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main(int argc, char *argv[]) {\n  int q;\n  std::cin >> q;\n  std::multiset<long> s;\n  for (int i = 0; i < q; ++i) {\n    int c, x;\n    std::cin >> c >> x;\n    switch (c) {\n    case 0:\n      s.insert(x);\n      std::cout << s.size() << std::endl;\n      break;\n    case 1:\n      std::cout << s.count(x) << std::endl;\n      break;\n    case 2:\n      s.erase(x);\n      break;\n    case 3:\n      int r;\n      std::cin >> r;\n      for (auto i = s.lower_bound(x); i != s.upper_bound(r); ++i) {\n        std::cout << *i << std::endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int q;\n    cin >> q;\n    multiset<int> s;\n    for(int i=0; i<q; i++){\n        int a, x;\n        cin >> a >> x;\n        if(a == 0){\n            s.insert(x);\n            cout << s.size() << endl;\n        }else if(a == 1){\n            cout << s.count(x) << endl;\n        }else if(a == 2){\n            s.erase(x);\n        }else{\n            int y;\n            cin >> y;\n            auto first = s.lower_bound(x);\n            auto last = s.upper_bound(y);\n            for(auto itr = first; itr != last; ++itr) {\n                cout << *itr << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <array>\n#include <queue>\n#include <deque>\n#include <set>\n#include <list>\n#include <map>\n#include <stack>\n#include <utility>\n#include <bitset>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <random>\n#include <functional>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); i++)\n#define FOR(i, m, n) for(int i=(m);i<(n);i++)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REVE(x) reverse((x).begin(),(x).end())\n#define mp make_pair\n#define pb push_back\n#define Cout(x) cout << (x) << endl\n#define Cout2(x, y) cout << (x) << \" \" << (y) << endl\n#define dump(x) cout << #x << \" = \" << (x) << endl;\n#define forauto(i, a) for(auto i : a)cout << i << \" \"; puts(\"\");\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<vector<int>> VVI;\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\ntypedef complex<double> CD;\n\nint main() {\n\tmultiset<int> s;\n\tint q; cin >> q;\n\trep(i, q) {\n\t\tint t, x;\n\t\tcin >> t;\n\n\t\tswitch (t) {\n\t\tcase 0:\n\t\t\tcin >> x;\n\t\t\ts.insert(x);\n\t\t\tCout(sz(s));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcin >> x;\n\t\t\tCout(s.count(x));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcin >> x;\n\t\t\ts.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tint l, r; cin >> l >> r;\n\t\t\tauto it = s.lower_bound(l);\n\t\t\tauto last = s.upper_bound(r);\n\t\t\twhile (it != last) {\n\t\t\t\tCout(*it);\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  multiset<int> st;\n  int q; scanf(\"%d\", &q);\n  for(int i=0; i<q; i++){\n    int query, x;\n    scanf(\"%d %d\", &query, &x);\n    if(query==0){\n      st.insert(x);\n      printf(\"%d\\n\", st.size());\n    }\n    else if(query==1){\n      printf(\"%d\\n\", st.count(x));\n    }\n    else if(query==2){\n      st.erase(x);\n    }\n    else {\n      int y; scanf(\"%d\", &y);\n      auto itrLower = st.lower_bound(x);\n      auto itrUpper = st.upper_bound(y);\n\n      while(itrLower != itrUpper){\n        printf(\"%d\\n\", *itrLower);\n        itrLower++;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain() {\n  int q = in();\n  multiset<int> s;\n  while (q--) {\n    int t = in();\n    if (t == 0) {\n      s.emplace(in());\n      cout << s.size() << endl;\n    }\n    if (t == 1) cout << s.count(in()) << endl;\n    if (t == 2) s.erase(in());\n    if (t == 3) {\n      int l, r;\n      cin >> l >> r;\n      for (auto it = s.lower_bound(l), end = s.upper_bound(r); it != end; it++) cout << *it << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    multiset <int> m;\n    int q;\n    cin>>q;\n    while(q--)\n    {\n        int a;\n        cin>>a;\n        if(a==0)\n        {\n            int x;\n            cin>>x;\n            m.emplace(x);\n            cout<<m.size()<<endl;\n        }\n        else if(a==1)\n        {\n            int x;\n            cin>>x;\n            cout<<m.count(x)<<endl;\n        }\n        else if(a==2)\n        {\n            int x;\n            cin>>x;\n            m.erase(x);\n        }\n        else\n        {\n            int l,r;\n            cin>>l>>r;\n            auto p=m.lower_bound(l);\n            while(p!=m.end()&&*p<=r)\n            {\n                cout<<*p<<endl;\n                p++;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n\nint main() {\n\tint n;\n\tstd::cin >> n;\n\tstd::multiset<int> set;\n\tfor (auto i = 0; i < n; ++i) {\n\t\tint o, x, r;\n\t\tstd::cin >> o >> x;\n\t\tswitch (o) {\n\t\tcase 0: set.insert(x); std::cout << set.size() << std::endl; break;\n\t\tcase 1: std::cout << set.count(x) << std::endl; break;\n\t\tcase 2: set.erase(x); break;\n\t\tdefault:\n\t\t\tstd::cin >> r;\n\t\t\tauto end = set.upper_bound(r);\n\t\t\tfor (auto begin = set.lower_bound(x); begin != end; ++begin) {\n\t\t\t\tstd::cout << *begin << std::endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  multiset<int> S;\n  int q;\n  cin >> q;\n  while (q--) {\n    int op, x;\n    cin >> op >> x;\n    if (op == 0) {\n      S.insert(x);\n      cout << S.size() << endl;\n    } else if (op == 1) {\n      cout << S.count(x) << endl;\n    } else if (op == 2) {\n      S.erase(x);\n    } else {\n      int l = x, r;\n      cin >> r;\n      auto left = S.lower_bound(l);\n      auto right = S.upper_bound(r);\n      for (auto it = left; it != right; it++) {\n        cout << *it << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int q; cin >> q;\n  multiset<int> ms;\n  for (int i = 0; i < q; i++) {\n    int cmd; cin >> cmd;\n    if (cmd == 0) {\n      int x; cin >> x;\n      ms.insert(x);\n      cout << ms.size() << endl;\n    }\n    if (cmd == 1) {\n      int x; cin >> x;\n      cout << ms.count(x) << endl;\n    }\n    if (cmd == 2) {\n      int x; cin >> x;\n      ms.erase(x);\n    }\n    if (cmd == 3) {\n      int l, r; cin >> l >> r;\n      for (auto itr = ms.begin(), end = ms.end(); itr != end; itr++) {\n        cout << *itr << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep_i(i, n) for (int i = 0; i < (n); ++i)\n#define rep_ll(i, n) for (long long i = 0; i < (n); ++i)\n#define r_rep_i(i, start, end) for (int i = (start); i < (end); ++i)\n#define r_rep_ll(i, start, end) for (long long i = (start); i < (end); ++i)\n#define debug_vi(v) copy((v).begin(), (v).end(), ostream_iterator<int>(cout, \" \"));\n#define debug_vll(v) copy((v).begin(), (v).end(), ostream_iterator<long long>(cout, \" \"));\n#define debug_vd(v) copy((v).begin(), (v).end(), ostream_iterator<double>(cout, \" \"));\n#define sort_v(v) sort((v).begin(), (v).end()); //昇順\n#define d_sort_vi(v) sort((v).begin(), (v).end(), greater<int>()); //降\n#define d_sort_vd(v) sort((v).begin(), (v).end(), greater<double>()); //昇順\n#define say(t) cout << (t) << endl;\n#define sum_vi(v) accumulate((v).begin(), (v).end(), 0);\n#define sum_vll(v)accumulate((v).begin(), (v).end(), 0LL);\n\nint main(){\n  multiset<int> s;\n  int q;\n  cin >> q;\n  int tmp, tmp2, tmp3;\n  rep_i(i, q){\n    cin >> tmp >> tmp2;\n    if(tmp == 0){\n      s.insert(tmp2);\n      say(s.size());\n    }else if(tmp == 1){\n      // set<int>::iterator itr = s.find(tmp2);\n      // if(itr == s.end()){\n      //   say(0);\n      // }else{\n      //   say(1);\n      // }\n      cout << s.count(tmp2) << endl;\n    }else if(tmp == 2){\n      s.erase(tmp2);\n    }else{\n      cin >> tmp3;\n      // set<int>::iterator lit = s.lower_bound(tmp2);\n      // set<int>::iterator rit = s.lower_bound(tmp3);\n      // size_t start = distance(s.begin(), lit);\n      // size_t end = distance(s.begin(), rit);\n      set<int>::iterator itr = s.lower_bound(tmp2);\n      set<int>::iterator itr2 = s.find(tmp3);\n      for (auto i = itr; i != s.end() && *i <= tmp3; i++){\n        say(*i);\n      }\n      \n      // r_rep_i(i, tmp2, tmp3 + 1){\n      //   if(itr == s.end()){\n      //     continue;\n      //   }else{\n      //     say(*itr);\n      //   }\n      // }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <list>\n#include <set>\n#include <stack>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* constant */\n\nconst int INF = 1 << 30;\nconst int MAX = 10000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\n\n/* function */\nvoid printAns(bool can);\n\n/* main */\nint main(){\n    int q, option, num, num2; \n    // multiset : multiple elements can have equivalent values in S\n    multiset<int> S;\n    using iterator = decltype(S)::iterator;\n    cin >> q;\n    for (int i  = 0; i < q; i++) {\n        cin >> option >> num;\n        // cout << option << ' ' << num << '\\n';\n        switch(option) {\n        case 0: {\n            // insert(x): Insert x to S \n            //            and report the number of elements \n            //            in S after the operation\n            S.insert(num);\n            cout << S.size() << '\\n';\n            break;\n                }\n        case 1: {\n            // find(x): Report the number of x in S\n            cout << S.count(num) << '\\n';\n            break;\n            }\n        case 2: {\n            // delete(x): Delete all x from S\n            // 1\n            /*\n            pair<iterator, iterator> ret = S.equal_range(num);\n            for (iterator it = ret.first; it != ret.second; ) {\n                it = S.erase(it);\n            }\n            */\n            //2 \n            S.erase(num);\n            break;\n            }\n        case 3: {\n            // dump(L, R): Print elements x in S \n            //             such that L <= x <= R\n            cin >> num2;\n            iterator cur = S.lower_bound(num);\n            iterator last = S.upper_bound(num2);\n            for (; cur != last ; cur++)\n                cout << *cur << '\\n';\n            break;\n            }\n        }\n    }\n}\n\n\nvoid printAns(bool can) {\n    if (can) cout << 1 << '\\n';\n    else cout << 0 << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{\n    multiset<int> S;\n    int query;\n    int command, num, L, R;\n    multiset<int>::iterator itrL, itrR;\n\n    scanf(\"%d\", &query);\n    for (int i = 0; i < query; i++)\n    {\n        scanf(\"%d\", &command);\n        switch (command) {\n        case 0:\n            scanf(\"%d\", &num);\n            S.insert(num);\n            printf(\"%d\\n\", S.size());\n            break;\n        case 1:\n            scanf(\"%d\", &num);\n            printf(\"%d\\n\", S.count(num));\n            break;\n        case 2:\n            scanf(\"%d\", &num);\n            S.erase(num);\n            break;\n        case 3:\n            scanf(\"%d %d\", &L, &R);\n            itrL = S.lower_bound(L);\n            itrR = S.upper_bound(R);\n            while (itrL != itrR)\n            {\n                printf(\"%d\\n\", *itrL++);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int q;\n    cin>>q;\n    multiset<int> st;\n    rep(i, q) {\n        int m, x;\n        cin>>m>>x;\n        if (m == 0) {\n            st.insert(x);\n            cout<<st.size()<<endl;\n        }\n        else if (m == 1) {\n            cout<<st.count(x)<<endl;\n        }\n        else if (m == 2) {\n            st.erase(x);\n        }\n        else {\n            int r;\n            cin>>r;\n            auto it = st.lower_bound(x);\n            auto cl = st.upper_bound(r);\n            for (; it != cl; ++it) {\n                cout<<*it<<endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmultiset<int> s;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\twhile(n--)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x == 0) \n\t\t{\n\t\t\ts.insert(y);\n\t\t\tprintf(\"%d\\n\",s.size());\n\t\t}\n\t\telse if(x == 1) printf(\"%d\\n\",s.count(y));\n\t\telse if(x == 2) s.erase(y);\n\t\telse if(x == 3)\n\t\t{\n\t\t\tint l, r;\n\t\t\tl = y;\n\t\t\tscanf(\"%d\",&r);\n\t\t\tmultiset<int>::iterator it, it2;\n\t\t\tit = s.lower_bound(l);\n\t\t\tit2 = s.upper_bound(r);\n\t\t\tfor(; it!=it2; it++) printf(\"%d\\n\",*it);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint q;\n\nint main(){\n\tcin >> q;\n\tmultiset<int> msa;\n\tfor(int i = 0; i < q; i++){\n\t\tchar query;\n\t\tcin >> query;\n\t\tif(query == '0'){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tmsa.insert(x);\n\t\t\tcout << msa.size() << endl;\n\t\t}else if(query == '1'){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << msa.count(x) << endl;\n\t\t}else if(query == '2'){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tmsa.erase(x);\n\t\t}else if(query == '3'){\n\t\t\tint L, R;\n\t\t\tcin >> L >> R;\n\t\t\tmultiset<int>::iterator itr;\n\t\t\tpair<multiset<int>::iterator, multiset<int>::iterator> itr1, itr2;\n\t\t\titr1 = msa.equal_range(L);\n\t\t\titr2 = msa.equal_range(R);\n\t\t\tfor(itr = itr1.first; itr != itr2.second; itr++){\n\t\t\t\tcout << *itr << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long int\nusing namespace std;\nint main()\n{\n  multiset<ll>s;\n  multiset<ll>::iterator it;\n  ll temp,tc,q,x,l,r;\n  cin>>tc;\n  while(tc--)\n  {\n    cin>>q;\n    if(q==0)\n    {\n      cin>>temp;\n      s.insert(temp);\n      cout<<s.size()<<endl;\n    }\n    else if(q==1)\n    {\n      cin>>x;\n      cout<<s.count(x)<<endl;\n    }\n    else if(q==2)\n    {\n      cin>>x;\n      s.erase(x);\n    }\n    else\n    {\n      cin>>l>>r;\n\t\t\tfor(it=s.lower_bound(l);it!=s.upper_bound(r);it++){\n\t\t\tcout<<(*it)<<endl;\n    }\n  }\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int q;\n    cin >> q;\n    multiset<int> mst;\n    for(int i = 0; i < q; i++)\n    {\n        int com, x;\n        cin >> com >> x;\n        if(com == 0)\n        {\n            mst.insert(x);\n            cout << mst.size() << endl;\n        }\n        else if(com == 1)\n        {\n            cout << mst.count(x) << endl;\n        }\n        else if(com == 2)\n        {\n            mst.erase(x);\n        }\n        else if(com == 3)\n        {\n            int y;\n            cin >> y;\n            auto it = mst.lower_bound(x);\n            auto last = mst.upper_bound(y);\n            while(it != last)\n            {\n                cout << *it << endl;\n                it++;\n            }\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n    multiset<int> s;\n    int q; cin >> q;\n    while (q--) {\n        int com, x; cin >> com >> x;\n        if (com == 0) {\n            s.emplace(x);\n            cout << s.size() << endl;\n        } else if (com == 1) {\n            cout << s.count(x) << endl;\n        } else if (com == 2) {\n            s.erase(x);\n        } else if (com == 3) {\n            int y; cin >> y;\n            auto it = s.lower_bound(x);\n            while (it != s.end() && *it <= y) cout << *it++ << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  multiset<int> s;\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t,x;\n    cin>>t>>x;\n    if(t==0) s.emplace(x);\n    if(t==0) cout<<s.size()<<endl;\n    if(t==1) cout<<s.count(x)<<endl;\n    if(t==2) s.erase(x);\n    if(t==3){\n      int y;\n      cin>>y;\n      auto latte=s.lower_bound(x);\n      while(latte!=s.end()&&*latte<=y) cout<<*latte++<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define long int64_t\n\nstruct Solver {\n\tSolver() {\n\t\tios::sync_with_stdio( false );\n\t\tcout << fixed << setprecision( 10 );\n\t}\n\n\tvoid solve() {\n\t\tint q;\n\t\tcin >> q;\n\n\t\tmultiset<int> s;\n\t\twhile( q-- ) {\n\t\t\tint cmd, x, y;\n\t\t\tcin >> cmd;\n\n\t\t\tif( cmd == 0 ) {\n\t\t\t\tcin >> x;\n\t\t\t\ts.insert( x );\n\t\t\t\tcout << s.size() << '\\n';\n\t\t\t}\n\t\t\telse if( cmd == 1 ) {\n\t\t\t\tcin >> x;\n\t\t\t\tcout << s.count( x ) << '\\n';\n\t\t\t}\n\t\t\telse if( cmd == 2 ) {\n\t\t\t\tcin >> x;\n\t\t\t\ts.erase( x );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tauto a = s.lower_bound( x );\n\t\t\t\tauto b = s.upper_bound( y );\n\t\t\t\twhile( a != b ) {\n\t\t\t\t\tcout << *a << '\\n';\n\t\t\t\t\t++a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tSolver().solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nset<int>st;\nint main() {\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint Q, k;\n\t\tcin >> Q >> k;\n\t\tif (Q == 0) {\n\t\t\tst.insert(k);\n\t\t\tcout << st.size() << endl;\n\t\t}\n\t\telse if (Q == 1) {\n\t\t\tcout << st.count(k) << endl;\n\t\t}\n\t\telse if (Q == 2) {\n\t\t\tst.erase(k);\n\t\t}\n\t\telse {\n\t\t\tint y;\n\t\t\tcin >> y;\n\t\t\tauto nowitr = st.lower_bound(k);\n\t\t\tauto enditr = st.upper_bound(y);\n\t\t\twhile (nowitr != enditr) {\n\t\t\t\tcout << *nowitr << endl;\n\t\t\t\tnowitr++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\ntypedef long long ll;\nconst ll inf = 1e9;\nint main(){\n    int q; cin >> q;\n    multiset<ll> st;\n    rep(i,q){\n        ll com, x, y;\n        cin >> com >> x;\n        if(com == 0){\n            st.insert(x);\n            cout << st.size() << endl;\n        }else if(com == 1)cout << st.count(x) << endl;\n        else if(com == 2)st.erase(x);\n        else{\n            cin >> y;\n            for(multiset<ll>::iterator it=st.lower_bound(x); it != st.upper_bound(y); it++)cout << *it << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define all(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int q;\n  cin >> q;\n  multiset<int> st;\n  rep(_, q) {\n    int t, x, y;\n    cin >> t >> x;\n    switch (t) {\n    case 0:\n      st.insert(x);\n      cout << st.size() << '\\n';\n      break;\n    case 1:\n      cout << st.count(x) << '\\n';\n      break;\n    case 2:\n      st.erase(x);\n      break;\n    case 3:\n      cin >> y;\n      auto b = st.lower_bound(x), e = st.upper_bound(y);\n      for (auto it = b; it != e; ++it) cout << *it << '\\n';\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    multiset<int> s;\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int x, y;\n        cin >> x >> y;\n        if (x == 0)\n        {\n            s.insert(y);\n            cout << s.size() << endl;\n        }\n        if (x == 1)\n        {\n            cout << s.count(y) << endl;\n        }\n        if (x == 2)\n        {\n            s.erase(y);\n        }\n        if (x == 3)\n        {\n            int z;\n            cin >> z;\n            for (auto it = s.lower_bound(y); it != s.upper_bound(z); it++)\n            {\n                cout << *it << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int q, query, x, L, R;\n  scanf(\"%d\", &q);\n  multiset<int> S;\n  for(int i = 0; i < q; i++){\n    scanf(\"%d\", &query);\n    if(query == 3){\n      scanf(\"%d %d\", &L,&R);\n      auto it = S.lower_bound(L);\n      for(auto i = it; i != S.end() && *i <= R; i++){\n        printf(\"%d\\n\", *i);\n      }\n    }else{\n      scanf(\"%d\", &x);\n      if(query == 0){\n        S.insert(x);\n        printf(\"%d\\n\", S.size());\n      }else if(query == 1){\n        printf(\"%d\\n\", S.count(x));\n      }else{\n        S.erase(x);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    multiset<int> s;\n    int q;\n    cin>>q;\n    while(q--)\n    {\n        int c,t;\n        cin>>c>>t;\n        if(c==0) \n        {\n            s.insert(t);\n            cout<<s.size()<<endl;\n        }\n        else if(c==1) \n        {\n            cout<<s.count(t)<<endl;\n        }\n        else if(c==2)\n        {\n            s.erase(t);\n        }\n        else\n        {\n            int R;\n            cin>>R;\n            auto its=s.lower_bound(t);\n            auto ite=s.upper_bound(R);\n            for(auto it=its;it!=ite;it++)\n            {\n                cout<<*it<<endl;\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <functional>\n#include <set>\n\n#define INPUT_FROM_FILE (0) \n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\n\nint main(){\n\tint q, com;\n\tlong x;\n\tlong L, R;\n\tstd::multiset<long> s;\n\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\n#if INPUT_FROM_FILE\n\tifs >> q;\n#else\n\tstd::cin >> q;\n#endif\n\t\n\tfor(int i = 0; i < q; i++){\n#if INPUT_FROM_FILE\n\t\tifs >> com >> x;\n#else\n\t\tstd::cin >> com >> x;\n#endif\n\t\tif(com == 0){\n\t\t\ts.insert(x);\n\t\t\tstd::cout << s.size() << std::endl;\n\t\t}\n\t\telse if(com == 1){\n\t\t\tstd::cout << s.count(x) << std::endl;\n\t\t}\n\t\telse if(com == 2){\n\t\t\ts.erase(x);\n\t\t}\n\t\telse{\n\t\t\tL = x;\n#if INPUT_FROM_FILE\n\t\t\tifs >> R;\n#else\n\t\t\tstd::cin >> R;\n#endif\n\t\t\tstd::set<long>::iterator it = s.lower_bound(L);\n\t\t\twhile(it != s.end() && *it <= R){\n\t\t\t\tstd::cout <<  *it << std::endl;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nint main() {\n multiset<UL> S;\n UL Q; scanf(\"%u\",&Q);\n rep(q,Q){\n  UL c; scanf(\"%u\",&c);\n  if(c==0){\n   UL x; scanf(\"%u\",&x);\n   S.insert(x);\n   printf(\"%u\\n\",S.size());\n  }\n  if(c==1){\n   UL x; scanf(\"%u\",&x);\n   printf(\"%u\\n\",S.count(x));\n  }\n  if(c==2){\n   UL x; scanf(\"%u\",&x);\n   S.erase(x);\n  }\n  if(c==3){\n   UL L,R; scanf(\"%u%u\",&L,&R);\n   for(auto itr=S.lower_bound(L); itr!=S.end(); itr++){\n    if(*itr>R) break;\n    printf(\"%u\\n\",*itr);\n   }\n  }fflush(stdout);\n }\n return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,c,x,y,i;\nmultiset<int>S;\nmain()\n{\n  cin>>n;\n  for(i=0;i<n;i++)\n  {\n    cin>>c>>x;\n    if(c==1)cout<<S.count(x)<<endl;\n    else if(c==0)S.insert(x),cout<<S.size()<<endl;\n    else if(c==2)S.erase(x);\n    else\n    {\n      cin>>y;\n      auto a=S.lower_bound(x),b=S.upper_bound(y);\n      for(auto it=a;it!=b;it++)cout<<*it<<endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i ,n) for(int i=0;i<(int)(n);++i)\nusing namespace std;\ntypedef long long int int64;\ntypedef unsigned long long uint64;\n\nint main(){\n    int q; cin >> q;\n    multiset<int> a;\n    decltype(a)::iterator itr1;\n    decltype(a)::iterator itr2;\n    rep(i ,q){\n        int m , x , y;\n        cin >> m >> x;\n        switch (m)\n        {\n        case 0: \n            a.insert(x);\n            cout << a.size() << endl; \n            break;\n        case 1:\n            cout << a.count(x) << endl;\n            break;\n        case 2:\n            a.erase(x);\n            break;\n        case 3:\n            cin >> y;\n            if(a.empty()) break;\n            else { \n                set<int>::iterator itr1,itr2;\n                itr1 = a.lower_bound(x);\n                itr2 = a.upper_bound(y);\n                set<int>::iterator it = itr1;\n                while(it != itr2){\n                    cout << *(it++) << endl;\n                }\n            }\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <set>\n#include <iterator>\nusing namespace std;\nint main(){\n    int n,temp,k;\n    multiset<int> s;\n    multiset<int>::iterator u;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&k,&temp);\n        if(k==0){\n            s.insert(temp);\n            printf(\"%ld\\n\",s.size());\n        }\n        else if(k==1)printf(\"%ld\\n\"s.count(temp));\n        else if(k==2)s.erase(temp);   \n        else{\n            u=s.lower_bound(temp);\n            scanf(\"%d\",&temp);\n            while(u!=s.end()){\n                if(*u>temp)break;\n                printf(\"%d\\n\",*u);\n                u++;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\n\nint main()\n{\n    int q,ope;\n    long long num,L,R;\n    std::cin>>q;\n    std::multiset<long long> S;\n    \n    for(int i = 0; i < q; i++)\n    {\n        std::cin>>ope;\n        if(ope==1){std::cin>>num; std::cout<<S.count(num)<<std::endl;}\n        else if(ope==0){std::cin>>num; S.insert(num); std::cout<<S.size()<<std::endl;}\n        else if(ope==2){std::cin>>num; S.erase(num);}\n        else{\n            std::cin>>L>>R;\n            auto a = S.lower_bound(L);\n            auto b = S.upper_bound(R);\n            for(auto it = a; it!=b; it++){std::cout<<*it<<std::endl;}\n        }\n    } \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmultiset<int> p;\n\twhile (n--)\n\t{\n\t\tint oper;\n\t\tcin >> oper;\n\t\tswitch (oper)\n\t\t{\n\t\t\tint num;\n\t\tcase 0:\n\t\t\tcin >> num;\n\t\t\tp.insert(num);\n\t\t\tcout << p.size() << endl;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcin >> num;\n\t\t\tcout << p.count(num) << endl;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcin >> num;\n\t\t\tp.erase(num);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tint head, end;\n\t\t\tcin >> head >> end;\n\t\t\tset<int>::iterator p1 = p.lower_bound(head);\n\t\t\tset<int>::iterator p2 = p.upper_bound(end);\n\t\t\tfor (;p1 != p2;p1++)\n\t\t\t{\n\t\t\t\tcout << *p1 << endl;\n\t\t\t}\n\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tmultiset<int> s;\n\tfor(int i = 0; i < n; i++) {\n\t\tint id, x;\n\t\tscanf(\"%d%d\", &id, &x);\n\t\tif(id == 0) {\n\t\t\ts.insert(x);\n\t\t\tprintf(\"%lu\\n\", s.size());\n\t\t}else if(id == 1) {\n\t\t\tprintf(\"%lu\\n\", s.count(x));\n\t\t}else if(id == 2) {\n\t\t\ts.erase(x);\n\t\t}else if(id == 3) {\n\t\t\tint y;\n\t\t\tscanf(\"%d\", &y);\n\t\t\tauto itr = s.lower_bound(x);\n\t\t\tfor(; itr != s.end() && *itr <= y; itr++)\n\t\t\t\tprintf(\"%d\\n\", *itr);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main() {\n\tint\tN;\n\tcin >> N;\n\tmultiset<int> ms;\n\trep(i, N)\n\t{\n\t\tint\ta, b;\n\t\tcin >> a >> b;\n\t\tif (a == 0)\n\t\t{\n\t\t\tms.insert(b);\n\t\t\tcout << ms.size() << endl;\n\t\t}\n\t\telse if (a == 1)\n\t\t\tcout << ms.count(b) << endl;\n\t\telse if (a == 2)\n\t\t\tms.erase(b);\n\t\telse\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tfor (multiset<int>::iterator it = ms.lower_bound(b); it != ms.upper_bound(c); it++)\n\t\t\t\tcout << *it << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main()\n{\n\tmultiset<int> cpp; \n\tint q, com, o, r;\n\tscanf(\"%d\", &q);\n\n\twhile (q--)\n\t{\n\n\t\tscanf(\"%d%d\", &com, &o);\n\t\tswitch (com)\n\t\t{\n\t\tcase 0:\n\t\t\tcpp.insert(o);\n\t\t\tprintf(\"%d\\n\", cpp.size());\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tprintf(\"%d\\n\", cpp.count(o));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tcpp.erase(o);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tscanf(\"%d\", &r);\n\t\t\tset<int>::iterator prev = cpp.lower_bound(o);\n\t\t\tset<int>::iterator next = cpp.upper_bound(r);\n\t\t\twhile (prev != next)    \n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", *prev);\n\t\t\t\tprev++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main()\n{\n    iostream::sync_with_stdio(0);\n    multiset<int>s;\n    int T,num=0;\n    cin>>T;\n    while(T--)\n    {\n        int flag,x;\n        cin>>flag>>x;\n        if(flag==0)\n        {\n            auto it=s.insert(x);\n           // if(it.second==1)\n                num++;\n            cout<<num<<endl;\n        }\n        else if(flag==1)\n        {\n            auto m=s.count(x);\n\n             cout<<m<<endl;\n        }\n        else if(flag==2)\n        {\n            int n=s.erase(x);\n            num-=n;\n        }\n        else\n        {\n            int R;\n            cin>>R;\n            for(auto it=s.lower_bound(x);it!=s.end()&&*it<=R;it++)\n            {\n\n                    cout<<*it<<endl;\n\n            }\n        }\n    }\n  //  cout << \"Hello world!\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main() {\n    int q;\n    std::cin >> q;\n\n    std::multiset<int> S;\n    for (int i = 0; i < q; i++) {\n        int op;\n        std::cin >> op;\n        if (op == 0) {\n            int x;\n            std::cin >> x;\n            S.insert(x);\n            std::cout << S.size() << std::endl;\n        } else if (op == 1) {\n            int x;\n            std::cin >> x;\n            std::cout << S.count(x) << std::endl;\n        } else if (op == 2) {\n            int x;\n            std::cin >> x;\n            S.erase(x);\n        } else if (op == 3) {\n            int L, R;\n            std::cin >> L >> R;\n            auto begin = S.lower_bound(L);\n            auto end = S.upper_bound(R);\n            for (auto it = begin; it != end; it++) {\n                std::cout << *it << std::endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int q; cin >> q;\n  multiset<int> ms;\n  for (int i = 0; i < q; i++) {\n    int cmd; cin >> cmd;\n    if (cmd == 0) {\n      int x; cin >> x;\n      ms.insert(x);\n      cout << ms.size() << endl;\n    }\n    if (cmd == 1) {\n      int x; cin >> x;\n      cout << ms.count(x) << endl;\n    }\n    if (cmd == 2) {\n      int x; cin >> x;\n      ms.erase(x);\n    }\n    if (cmd == 3) {\n      int l, r; cin >> l >> r;\n      for (auto itr = ms.upper_bound(l), end = ms.lower_bound(r); itr != end; itr++) {\n        cout << *itr << endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <set>\n#include <iterator>\nusing namespace std;\nint main(){\n    int n,temp,k;\n    multiset<int> s;\n    multiset<int>::iterator u;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&k,&temp);\n        if(k==0){\n            s.insert(temp);\n            printf(\"%ld\\n\",s.size());\n        }\n        else if(k==1){\n            if(s.find(temp)==s.end())printf(\"0\\n\");\n            else printf(\"1\\n\");\n        }\n        else if(k==2)s.erase(temp);   \n        else{\n            u=s.lower_bound(temp);\n            scanf(\"%d\",&temp);\n            while(u!=s.end()){\n                if(*u>temp)break;\n                printf(\"%d\\n\",*u);\n                u++;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n\nint main(){\n    ll Q;\n    cin >> Q;\n\n    multiset<ll> se;\n\n    while(Q--){\n        ll a, x;\n        cin >> a >> x;\n\n        if(a==0){\n            // insert\n            se.insert(x);\n            p(se.size());\n        }\n        else if(a==1){\n            // find\n            p(se.count(x));\n        }\n        else if(a==2){\n            // delete\n            se.erase(x);\n        }\n        else{\n            // dump\n            ll L = x;\n            ll R; cin >> R;\n\n            auto it = se.lower_bound(L);\n            auto it2 = se.upper_bound(R);\n            for(; it!=it2; it++){\n                p(*it);\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tint Q=in();\n\tmultiset<int> S;\n\tREP(i,Q){\n\t\tint q=in();\n\t\tif(q==1){\n\t\t\tauto res = S.equal_range(in());\n\t\t\tout(distance(res.first,res.second));\n\t\t}\n\t\telse if(q==2){\n\t\t\tS.erase(in());\n\t\t}\n\t\telse if(q==3){\n\t\t\tint L=in(),R=in();\n\t\t\tauto start = S.lower_bound(L);\n\t\t\tauto end = S.upper_bound(R);\n\t\t\twhile(start!=end){\n\t\t\t\tout(*start);\n\t\t\t\t++start;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tS.insert(in());\n\t\t\tout(S.size());\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    multiset<int> s;\n    while (T--) {\n        int a;\n        cin >> a;\n        if (a == 0) {\n            int t;\n            cin >> t;\n            s.insert(t);\n            cout << s.size() << endl;\n        } else if (a == 1) {\n            int t;\n            cin >> t;\n            cout << s.count(t) << endl;\n        } else if (a == 2) {\n            int t;\n            cin >> t;\n            s.erase(t);\n        } else {\n            int l, r;\n            cin >> l >> r;\n            auto it = s.lower_bound(l);\n            auto it1 = s.upper_bound(r);\n            for (; it != it1; it++) cout << *it << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\nusing namespace std;\n\nint main(){\n  int q; cin>>q;\n  multiset<int>s;\n  while(q--){\n    int x,y;\n    cin>>x>>y;\n    if(x==1)cout<<s.count(y)<<endl;\n    else if(x==0){\n      s.insert(y);\n      cout<<s.size()<<endl;\n    }\n    else if(x==2)s.erase(y);\n    else{\n      int l=y,r;\n      cin>>r;\n      set<int>::iterator end,it;\n      it=s.lower_bound(l);\n      end=s.upper_bound(r);\n      for(;it!=end;it++){\n        cout<<(*it)<<endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<cstdio>\nusing namespace std;\nmultiset<int>a;\nint main()\n{\n    int n,choose,temp,l,r;\n    scanf(\"%d\", &n);\n    while (n--)\n    {\n        scanf(\"%d\", &choose);\n        switch (choose)\n        {\n        case 0:\n            scanf(\"%d\", &temp);\n            a.insert(temp);\n            printf(\"%d\\n\", a.size());\n            break;\n        case 1:\n            scanf(\"%d\", &temp);\n            printf(\"%d\\n\", count(a.lower_bound(temp), a.upper_bound(temp), temp) );\n            break;\n        case 2:\n            scanf(\"%d\", &temp);\n            a.erase(temp);\n            break;\n        case 3:\n            scanf(\"%d\", &l);\n            scanf(\"%d\", &r);\n            set<int>::iterator begin, end;\n            begin = a.lower_bound(l);\n            end = a.upper_bound(r);\n            for (; begin != end; begin++)\n            {\n                printf(\"%d\\n\", *begin);\n            }\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nint n;\nmultiset<int>S;\nmain()\n{\n  cin>>n;\n  for(int i=0;i<n;i++)\n  {\n    int c,x;cin>>c>>x;\n    if(c==1)cout<<S.count(x)<<endl;\n    else if(c==0)S.insert(x),cout<<S.size()<<endl;\n    else if(c==2)S.erase(x);\n    else\n    {\n      int y;cin>>y;\n      auto a=S.lower_bound(x),b=S.upper_bound(y);\n      for(auto it=a;it!=b;it++)cout<<*it<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n#define PI acos(-1)\n#define Mod (int)1000000007\n#define INFTY (int)INT_MAX\n#define Rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define BitRep(i, n) for (int i = 0; i < (int)(1 << n); i++)\n#define All(vec) vec.begin(), vec.end()\n#define Part(vec, b, e) vec.begin() + b, vec.begin() + e\n#define Sum(vec) accumulate(vec.begin(), vec.end(), 0)\n#define Sort(vec) sort(vec.begin(), vec.end())\n#define Reverse(vec) reverse(vec.begin(), vec.end())\n#define Count(vec, x) count(vec.begin(), vec.end(), x)\n#define Next_permutation(vec) next_permutation(vec.begin(), vec.end())\n#define Find(vec, s) vec.find(s) != vec.end()\n\nint main() {\n\tmultiset<int> MS;\n\tint q;\n\tcin >> q;\n\tRep(i, q) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tMS.insert(x);\n\t\t\tcout << MS.size() << endl;\n\t\t}\n\t\telse if (n == 1) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << distance(MS.lower_bound(x), MS.upper_bound(x)) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tMS.erase(x);\n\t\t}\n\t\telse if (n == 3) {\n\t\t\tint L, R;\n\t\t\tcin >> L >> R;\n\t\t\tfor (auto itr = MS.lower_bound(L); itr != MS.end() && *itr <= R; itr++) {\n\t\t\t\tcout << *itr << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    multiset<int> s;\n    int q, op, x, y;\n\n    cin >> q;\n\n    while(q-- > 0){\n        cin >> op >> x;\n        if(op == 0){\n            s.insert(x);\n            cout << s.size() << endl;\n        }else if(op == 1){\n            cout << s.count(x) << endl;\n        }else if(op == 2){\n            s.erase(x);\n        }else if(op == 3){\n            cin >> y;\n            auto l = s.lower_bound(x);\n            auto r = s.upper_bound(y);\n            for(; l != r; l++)  printf(\"%d\\n\", *l);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n,command,x,l,r;\n    multiset<int> mySet;\n    multiset<int>::iterator begin;\n    multiset<int>::iterator end;\n    cin >> n;\n    \n    for(int i = 0;i < n;++i){\n        cin >> command;\n        if(command == 0){\n            cin >> x;\n            mySet.insert(x);\n            cout << mySet.size() << endl;\n        }else if(command == 1){\n            cin >> x;\n            cout << mySet.count(x) << endl;\n        }\n        else if(command == 2){\n            cin >> x;\n            mySet.erase(x);\n        }\n        else{\n            cin >> l >> r;\n            begin = mySet.lower_bound(l);\n            end = mySet.upper_bound(r);\n            \n            for(;begin != end;++begin){\n                cout << *begin << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmultiset<int> ms;\n\nint main()\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int q;\n\n  cin >> q;\n  while(q--) {\n    int a, x;\n    cin >> a >> x;\n    if (a == 0) {\n      ms.insert(x);\n      cout << ms.size() << endl;\n    }\n    else if (a == 1) {\n      cout << ms.count(x) << endl;\n    }\n    else if (a == 2) {\n      ms.erase(x);\n    }\n    else if (a == 3) {\n      int y;\n      cin >> y;\n      auto aa = ms.lower_bound(x);\n      auto bb = ms.upper_bound(y);\n      for(auto it = aa; it != bb; it++) {\n        cout << *it << endl;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll inf = 1ll << 60;\nconst ll mod = (ll)1e9 + 7;\n\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\n#define print(s) cout << s;\n#define println(s) cout << s << endl;\n#define printd(s, f) cout << fixed << setprecision(f) << s << endl;\n\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\n\tmultiset<ll> a;\n\tfor (ll i = 0; i < n; i++)\n\t{\n\t\tll q, x;\n\t\tcin >> q;\n\n\t\tswitch (q)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tcin >> x;\n\t\t\t\ta.insert(x);\n\t\t\t\tprintln(a.size());\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tcin >> x;\n\t\t\t\tif (a.count(x))\n\t\t\t\t{\n\t\t\t\t\tprintln(a.count(x));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintln(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcin >> x;\n\t\t\t\ta.erase(x);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tll l, r;\n\t\t\t\tcin >> l >> r;\n\n\t\t\t\tfor (decltype(a)::iterator it = a.equal_range(l).first; it != a.equal_range(r).second; it++)\n\t\t\t\t{\n\t\t\t\t\tprintln(*it);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  \n  int q, com, x, l, r;\n  multiset<int> S;\n  \n  cin >> q;\n  for(int i = 0;i < q;i++){\n    cin >> com;\n    \n    if(com == 0){\n      cin >> x;\n      S.insert(x);\n      cout << S.size() << endl;\n    }else if(com == 1){\n      cin >> x;\n      cout << S.count(x) << endl;\n    }else if(com == 2){\n      cin >> x;\n      S.erase(x);\n    }else if(com == 3){\n      set<int>::iterator itl, itr;\n      \n      cin >> l >> r;\n      itl = S.lower_bound(l);\n      itr = S.upper_bound(r);\n      \n      for(set<int>::iterator it = itl;it != itr;it++) cout << *it << endl;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 1000000000000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nmap<int,int> MAP;\n\nint main(){\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tint command;\n\tint a,b,sum = 0;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%d\",&command);\n\n\t\tswitch(command){\n\t\tcase 0:\n\n\t\t\tscanf(\"%d\",&a);\n\t\t\tMAP[a]++;\n\t\t\tsum++;\n\t\t\tprintf(\"%d\\n\",sum);\n\t\t\tbreak;\n\n\t\tcase 1:\n\n\t\t\tscanf(\"%d\",&a);\n\t\t\tprintf(\"%d\\n\",MAP[a]);\n\n\t\t\tbreak;\n\t\tcase 2:\n\n\t\t\tscanf(\"%d\",&a);\n\t\t\tsum -= MAP[a];\n\t\t\tMAP[a] = 0;\n\n\t\t\tbreak;\n\t\tcase 3:\n\n\t\t\tscanf(\"%d %d\",&a,&b);\n\n\t\t\tauto at = MAP.lower_bound(a);\n\t\t\tauto right = MAP.upper_bound(b);\n\n\t\t\twhile(at != right){\n\n\t\t\t\tfor(int i = 0; i < at->second; i++){\n\n\t\t\t\t\tprintf(\"%d\\n\",at->first);\n\t\t\t\t}\n\t\t\t\tat++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1000000000\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\nint main (){\n    int q;cin>>q;\n    multiset<int> st;\n    rep(i,0,q){\n        int a,b;cin>>a>>b;\n        if(a==0){\n            st.insert(b);\n            cout<<st.size()<<endl;\n        }else if(a==1){\n            cout<<st.count(b)<<endl;\n        }else if(a==2){\n            st.erase(b);\n        }else {\n            int r;cin>>r;\n            auto low=st.lower_bound(b);\n            auto high=st.upper_bound(r);\n            for(auto it=low;it!=high;it++)cout<<*it<<endl;\n            \n            \n        }\n    }\n    \n    \n}\n\n\n\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\nint main() {\n  multiset<int> s;\n  int q, x;\n  cin >> q; // skip n\n  while (cin >> q >> x) {\n    if (q == 0) {\n      s.insert(x);\n      cout << s.size() << endl;\n    }\n    if (q == 1)\n      cout << s.count(x) << endl;\n    if (q == 2)\n      s.erase(x);\n    if (q == 3) {\n      int r;\n      cin >> r;\n      auto li = s.lower_bound(x);\n      auto ri = s.lower_bound(r + 1);\n      while (li != ri)\n        cout << *(li++) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <set>\nusing namespace std;\n\nint main() {\n    int num_query; scanf(\"%d\", &num_query);\n    int command, x, left, right;\n    multiset<int> S;\n    \n    for (int i = 0; i < num_query; ++i) {\n        scanf(\"%d\", &command);\n        \n        switch (command) {\n            case 0:\n                scanf(\"%d\", &x);\n                S.insert(x);\n                printf(\"%d\\n\", (int) S.size());\n                break;\n            case 1:\n                scanf(\"%d\", &x);\n                printf(\"%d\\n\", S.count(x));\n                break;\n            case 2:\n                scanf(\"%d\", &x);\n                S.erase(x);\n                break;\n            case 3:\n                scanf(\"%d%d\", &left, &right);\n                auto lower_itr = S.lower_bound(left);\n                auto upper_itr = S.upper_bound(right);\n                \n                for (auto itr = lower_itr; itr != upper_itr; ++itr) printf(\"%d\\n\", *itr);\n                break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int q;\n    cin>>q;\n\n    multiset<int> Set;\n    while(q--)\n    {\n        int op,x;\n        cin>>op>>x;\n\n        if(!op)\n        {\n            Set.insert(x);\n            cout<<Set.size()<<endl;\n        }else if(op==1)\n        {\n            cout<<Set.count(x)<<endl;\n        }else if(op==2)\n        {\n            Set.erase(x);\n        }else if(op==3)\n        {\n            int l=x,r,cnt=0;\n            cin>>r;\n            for(auto i=Set.lower_bound(l);i!=Set.end()&&*i<=r;i++)\n                cout<<*i<<endl;\n        }\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  multiset<int> S;\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 0){\n      int x;\n      cin >> x;\n      S.insert(x);\n      cout << S.size() << endl;\n    }\n    if (t == 1){\n      int x;\n      cin >> x;\n      cout << S.count(x) << endl;\n    }\n    if (t == 2){\n      int x;\n      cin >> x;\n      S.erase(x);\n    }\n    if (t == 3){\n      int L, R;\n      cin >> L >> R;\n      auto itr = S.lower_bound(L);\n      while (*itr <= R && itr != S.end()){\n        cout << *itr << endl;\n        itr++;\n        if (R < *itr){\n          break;\n        }\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint searchA(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key){\n        if(mid-1<0||s[mid-1]!=key)return mid;\n        else tail=mid-1;\n    }\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return searchA(s,key,head,tail);\n}\nint searchB(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key){\n        if(mid+1>tail||s[mid+1]!=key)return mid;\n        else head=mid+1;\n    }\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return searchB(s,key,head,tail);\n}\nint getLB(int s[],int key,int head,int tail){\n    if(s[0]>key||tail<0)return 0;\n    if(s[tail]<key||head>tail)return tail+1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]<key)head=mid+1;\n    else if(s[mid]>=key){\n        if(s[mid-1]<key)return mid;\n        else tail=mid-1;\n    }\n        \n    return getLB(s,key,head,tail);\n}\nint insert(int s[],int key,int cnt){\n    int d;\n    if(cnt==0)d=0;\n    else d=getLB(s,key,0,cnt-1);\n    \n    int i;\n    for(i=cnt;i>d;i--)s[i]=s[i-1];\n    s[i]=key;\n    return 1;\n}\nint delete(int s[],int key,int cnt){\n    int h,t;\n    h=searchA(s,key,0,cnt-1);\n    if(h<0)return 0;\n    t=searchB(s,key,h,cnt-1);\n    \n    int i,j;\n    for(i=h,j=1;i<cnt;i++,j++)s[i]=s[t+j];\n    return t-h+1;\n}\nvoid dump(int s[],int l,int r,int cnt){\n    int i;\n    i=getLB(s,l,0,cnt-1);\n\n    while(s[i]<=r&&i<cnt)printf(\"%d\\n\",s[i++]);\n    return;\n}\nvoid print(int s[],int cnt){\n    printf(\"cnt=%d,s:\",cnt);\n    for(int i=0;i<cnt;i++)printf(\"%d \",s[i]);\n    printf(\"\\n\");\n    return;\n}\nint main(void){\n    int q;\n    scanf(\"%d\\n\",&q);\n    \n    int s[q];\n    int cnt=0;\n    \n    int com,x,y;\n    int h,t;\n    while(q--){\n        scanf(\"%d \",&com);\n        switch(com){\n            case 0:\n                //insert\n                scanf(\"%d\\n\",&x);\n//    printf(\"insert:%d\\n\",x);\n                if(insert(s,x,cnt)==1)cnt++;\n                printf(\"%d\\n\",cnt);\n                break;\n            case 1:\n                //find\n                scanf(\"%d\\n\",&x);\n//    printf(\"find:%d\\n\",x);\n                h=searchA(s,x,0,cnt-1);\n                if(h==-1){\n                    printf(\"0\\n\");\n                    break;\n                }\n                t=searchB(s,x,h,cnt-1);\n//    printf(\"h=%d,t=%d\\n\",h,t);\n                printf(\"%d\\n\",t-h+1);\n                break;\n            case 2:\n                //delete\n                scanf(\"%d\\n\",&x);\n//    printf(\"delete:%d\\n\",x);\n                cnt-=delete(s,x,cnt);\n                break;\n            case 3:\n                //dump\n                scanf(\"%d %d\\n\",&x,&y);\n//    printf(\"dump:%d %d\\n\",x,y);\n                dump(s,x,y,cnt);\n                break;\n        }\n//        print(s,cnt);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nunsigned xor128() {\n\tstatic unsigned x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\tunsigned t = x ^ (x << 11);\n\tx = y; y = z; z = w;\n\treturn w = w ^ (w >> 19) ^ (t ^ (t >> 8));\n}\n\ntypedef struct node_t {\n\tint val;\n\tstruct node_t *lch, *rch;\n\tint size;\n\tunsigned int pri;\n} node;\n\nnode* new_node(int val) {\n\tstatic int it = 0;\n\tstatic node pool[200000];\n\tpool[it] = (node) { val, 0, 0, 1, xor128() };\n\treturn &pool[it++];\n}\n\nint count(node *t) {\n\treturn !t ? 0 : t->size;\n}\n\nnode *update(node *t) {\n\tt->size = count(t->lch) + count(t->rch) + 1;\n\treturn t;\n}\n\nnode *merge(node *l, node *r) {\n\tif (!l || !r) return !l ? r : l;\n\tif (l->pri > r->pri) {\n\t\tl->rch = merge(l->rch, r);\n\t\treturn update(l);\n\t}\n\tr->lch = merge(l, r->lch);\n\treturn update(r);\n}\n\ntypedef struct{ node *a, *b; } pnode;\n\npnode split(node *t, int k) {\n\tif (!t) return (pnode) { 0, 0 };\n\tif (k <= count(t->lch)) {\n\t\tpnode s = split(t->lch, k);\n\t\tt->lch = s.b;\n\t\treturn (pnode) { s.a, update(t) };\n\t}\n\tpnode s = split(t->rch, k - count(t->lch) - 1);\n\tt->rch = s.a;\n\treturn (pnode) { update(t), s.b };\n}\n\nint count_lower(node *t, int v) {\n\tint res = 0;\n\twhile (t) {\n\t\tif (t->val < v) {\n\t\t\tres += count(t->lch) + 1;\n\t\t\tt = t->rch;\n\t\t}\n\t\telse {\n\t\t\tt = t->lch;\n\t\t}\n\t}\n\treturn res;\n}\n\nnode *insert(node *t, int val) {\n\tint k = count_lower(t, val);\n\tpnode s = split(t, k);\n\treturn merge(merge(s.a, new_node(val)), s.b);\n}\n\nnode *erase(node *t, int l, int r) {\n\tpnode s1 = split(t, l), s2 = split(s1.b, r - l);\n\treturn merge(s1.a, s2.b);\n}\n\nvoid print(node *t) {\n\tif (!t) return;\n\tprint(t->lch);\n\tprintf(\"%d\\n\", t->val);\n\tprint(t->rch);\n}\n\nint main(void)\n{\n\tint q, com, x, l, r, cnt = 0;\n\tnode *root = 0;\n\tpnode p1, p2;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tscanf(\"%d%d\", &com, &x);\n\t\tif (com == 0) {\n\t\t\troot = insert(root, x);\n\t\t\tprintf(\"%d\\n\", ++cnt);\n\t\t}\n\t\telse if (com == 1) {\n\t\t\tprintf(\"%d\\n\", count_lower(root, x + 1) - count_lower(root, x));\n\t\t}\n\t\telse if (com == 2) {\n\t\t\tl = count_lower(root, x);\n\t\t\tr = count_lower(root, x + 1);\n\t\t\tcnt -= r - l;\n\t\t\troot = erase(root, l, r);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d\", &r);\n\t\t\tl = count_lower(root, x);\n\t\t\tr = count_lower(root, r + 1);\n\t\t\tp1 = split(root, l), p2 = split(p1.b, r - l);\n\t\t\tprint(p2.a);\n\t\t\troot = merge(merge(p1.a, p2.a), p2.b);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef int record;\n\ntypedef struct node {\n  void **pointers;\n  int *keys;\n  struct node *parent;\n  bool is_leaf;\n  int num_keys;\n  struct node *next;\n} node;\n\nint count = 0;\nint order = 64;  // 4\nnode *queue = NULL;\n\nvoid find_and_print(node *const root, int key); \nvoid find_and_print_range(node *const root, int range1, int range2); \nnode *find_leaf(node *const root, int key);\nrecord *find(node *root, int key, node **leaf_out);\n//int cut(int length);\n#define cut(a) ((a)/2+(a)%2)\n\n// Insertion.\n\nrecord *make_record(int value);\nnode *make_node(void);\nnode *make_leaf(void);\nint get_left_index(node *parent, node *left);\nnode *insert_into_leaf(node *leaf, int key, record *pointer);\nnode *insert_into_leaf_after_splitting(node *root, node *leaf, int key,\n                                        record *pointer);\nnode *insert_into_node(node *root, node *parent, \n\t\t\tint left_index, int key, node *right);\nnode *insert_into_node_after_splitting(node *root, node *parent,\n                                        int left_index,\n\t\t\t\t\tint key, node *right);\nnode *insert_into_parent(node *root, node *left, int key, node *right);\nnode *insert_into_new_root(node *left, int key, node *right);\nnode *start_new_tree(int key, record *pointer);\nnode *insert(node *root, int key, int value);\n\n// Deletion.\n\nint get_neighbor_index(node *n);\nnode *adjust_root(node *root);\nnode *coalesce_nodes(node *root, node *n, node *neighbor,\n                      int neighbor_index, int k_prime);\nnode *redistribute_nodes(node *root, node *n, node *neighbor,\n                          int neighbor_index,\n\t\t\t  int k_prime_index, int k_prime);\nnode *delete_entry(node *root, node *n, int key, void *pointer);\nnode *delete(node *root, int key);\n\n\nvoid find_and_print(node *const root, int key) {\n  record *r = find(root, key, NULL);\n  if (r == NULL) {\n    putc_unlocked('0', stdout);\n    putc_unlocked('\\n', stdout);\n  } else {\n    // printf(\"%d\\n\", r->value);\n    int b = *r;\n    int i;\n    if (b<0) {\n      putc_unlocked('-', stdout);\n      b=-b;\n    }\n    for (i=1; i*10<=b; i*=10);\n    for (;i>0; i/=10) {\n      putc_unlocked('0'+b/i, stdout);\n      b %= i;\n    }\n    putc_unlocked('\\n', stdout);\n  }\n}\n\nvoid find_and_print_range(node *const root, int key_start, int key_end)\n{\n  node *n = find_leaf(root, key_start);\n  if (n == NULL) return;\n  int i;\n\n  for (i = 0; i < n->num_keys && n->keys[i] < key_start; i++);\n\n  while (n != NULL) {\n    for (; i < n->num_keys && n->keys[i] <= key_end; i++) {\n\n      for (int j=0; j<*((record*)n->pointers[i]); j++) {\n\tint b = n->keys[i];\n\tint k;\n\tif (b<0) {\n\t  putc_unlocked('-', stdout);\n\t  b=-b;\n\t}\n\tfor (k=1; k*10<=b; k*=10);\n\tfor (;k>0; k/=10) {\n\t  putc_unlocked('0'+b/k, stdout);\n\t  b %= k;\n\t}\n\tputc_unlocked('\\n', stdout);\n      }\n    }\n    n = n->pointers[order - 1];\n    i = 0;\n  }\n}\n\n\nnode *find_leaf(node *const root, int key) {\n  if (root == NULL) {\n    return root;\n  }\n  int i = 0;\n  node *c = root;\n  while (!c->is_leaf) {\n    i = 0;\n    while (i < c->num_keys) {\n      if (key >= c->keys[i]) i++;\n      else break;\n    }\n    c = (node *)c->pointers[i];\n  }\n  return c;\n}\n\n\nrecord *find(node *root, int key, node **leaf_out) {\n  if (root == NULL) {\n    if (leaf_out != NULL) {\n      *leaf_out = NULL;\n    }\n    return NULL;\n  }\n  \n  int i = 0;\n  node *leaf = NULL;\n  \n  leaf = find_leaf(root, key);\n  \n  for (i = 0; i < leaf->num_keys; i++)\n    if (leaf->keys[i] == key) break;\n  if (leaf_out != NULL) {\n    *leaf_out = leaf;\n  }\n  if (i == leaf->num_keys)\n    return NULL;\n  else\n    return (record *)leaf->pointers[i];\n}\n\nrecord *make_record(int value)\n{\n  record *new_record = (record *)malloc(sizeof(record));\n  if (new_record == NULL) {\n    perror(\"Record creation.\");\n    exit(EXIT_FAILURE);\n  } else {\n    *new_record = value;\n  }\n  return new_record;\n}\n\n\nnode *make_node(void)\n{\n  node *new_node;\n  new_node = malloc(sizeof(node));\n  if (new_node == NULL) {\n    perror(\"Node creation.\");\n    exit(EXIT_FAILURE);\n  }\n  new_node->keys = malloc((order - 1) * sizeof(int));\n  if (new_node->keys == NULL) {\n    perror(\"New node keys array.\");\n    exit(EXIT_FAILURE);\n  }\n  new_node->pointers = malloc(order * sizeof(void *));\n  if (new_node->pointers == NULL) {\n    perror(\"New node pointers array.\");\n    exit(EXIT_FAILURE);\n  }\n  new_node->is_leaf = false;\n  new_node->num_keys = 0;\n  new_node->parent = NULL;\n  new_node->next = NULL;\n  return new_node;\n}\n\n\nnode *make_leaf(void)\n{\n  node *leaf = make_node();\n  leaf->is_leaf = true;\n  return leaf;\n}\n\n\nint get_left_index(node *parent, node *left)\n{\n  int left_index = 0;\n  while (left_index <= parent->num_keys && \n\t parent->pointers[left_index] != left)\n    left_index++;\n  return left_index;\n}\n\n\nnode *insert_into_leaf(node *leaf, int key, record *pointer)\n{\n  int i, insertion_point;\n\n  insertion_point = 0;\n  while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)\n    insertion_point++;\n\n  for (i = leaf->num_keys; i > insertion_point; i--) {\n    leaf->keys[i] = leaf->keys[i - 1];\n    leaf->pointers[i] = leaf->pointers[i - 1];\n  }\n  leaf->keys[insertion_point] = key;\n  leaf->pointers[insertion_point] = pointer;\n  leaf->num_keys++;\n  return leaf;\n}\n\n\nnode *insert_into_leaf_after_splitting(node *root, node *leaf, int key, record *pointer)\n{\n  node *new_leaf;\n  int *temp_keys;\n  void **temp_pointers;\n  int insertion_index, split, new_key, i, j;\n\n  new_leaf = make_leaf();\n\n  temp_keys = malloc(order * sizeof(int));\n  if (temp_keys == NULL) {\n    perror(\"Temporary keys array.\");\n    exit(EXIT_FAILURE);\n  }\n\n  temp_pointers = malloc(order * sizeof(void *));\n  if (temp_pointers == NULL) {\n    perror(\"Temporary pointers array.\");\n    exit(EXIT_FAILURE);\n  }\n\n  insertion_index = 0;\n  while (insertion_index < order - 1 && leaf->keys[insertion_index] < key)\n    insertion_index++;\n\n  for (i = 0, j = 0; i < leaf->num_keys; i++, j++) {\n    if (j == insertion_index) j++;\n    temp_keys[j] = leaf->keys[i];\n    temp_pointers[j] = leaf->pointers[i];\n  }\n\n  temp_keys[insertion_index] = key;\n  temp_pointers[insertion_index] = pointer;\n\n  leaf->num_keys = 0;\n\n  split = cut(order - 1);\n\n  for (i = 0; i < split; i++) {\n    leaf->pointers[i] = temp_pointers[i];\n    leaf->keys[i] = temp_keys[i];\n    leaf->num_keys++;\n  }\n\n  for (i = split, j = 0; i < order; i++, j++) {\n    new_leaf->pointers[j] = temp_pointers[i];\n    new_leaf->keys[j] = temp_keys[i];\n    new_leaf->num_keys++;\n  }\n\n  free(temp_pointers);\n  free(temp_keys);\n\n  new_leaf->pointers[order - 1] = leaf->pointers[order - 1];\n  leaf->pointers[order - 1] = new_leaf;\n\n  for (i = leaf->num_keys; i < order - 1; i++)\n    leaf->pointers[i] = NULL;\n  for (i = new_leaf->num_keys; i < order - 1; i++)\n    new_leaf->pointers[i] = NULL;\n\n  new_leaf->parent = leaf->parent;\n  new_key = new_leaf->keys[0];\n\n  return insert_into_parent(root, leaf, new_key, new_leaf);\n}\n\n\nnode *insert_into_node(node *root, node *n, \n\t\t\tint left_index, int key, node *right)\n{\n  int i;\n\n  for (i = n->num_keys; i > left_index; i--) {\n    n->pointers[i + 1] = n->pointers[i];\n    n->keys[i] = n->keys[i - 1];\n  }\n  n->pointers[left_index + 1] = right;\n  n->keys[left_index] = key;\n  n->num_keys++;\n  return root;\n}\n\n\nnode *insert_into_node_after_splitting(node *root, node *old_node, int left_index, int key, node *right)\n{\n  int i, j, split, k_prime;\n  node *new_node, *child;\n  int *temp_keys;\n  node **temp_pointers;\n\n  temp_pointers = malloc((order + 1) * sizeof(node *));\n  if (temp_pointers == NULL) {\n    perror(\"Temporary pointers array for splitting nodes.\");\n    exit(EXIT_FAILURE);\n  }\n  temp_keys = malloc(order * sizeof(int));\n  if (temp_keys == NULL) {\n    perror(\"Temporary keys array for splitting nodes.\");\n    exit(EXIT_FAILURE);\n  }\n\n  for (i = 0, j = 0; i < old_node->num_keys + 1; i++, j++) {\n    if (j == left_index + 1) j++;\n    temp_pointers[j] = old_node->pointers[i];\n  }\n\n  for (i = 0, j = 0; i < old_node->num_keys; i++, j++) {\n    if (j == left_index) j++;\n    temp_keys[j] = old_node->keys[i];\n  }\n\n  temp_pointers[left_index + 1] = right;\n  temp_keys[left_index] = key;\n\n\n  split = cut(order);\n  new_node = make_node();\n  old_node->num_keys = 0;\n  for (i = 0; i < split - 1; i++) {\n    old_node->pointers[i] = temp_pointers[i];\n    old_node->keys[i] = temp_keys[i];\n    old_node->num_keys++;\n  }\n  old_node->pointers[i] = temp_pointers[i];\n  k_prime = temp_keys[split - 1];\n  for (++i, j = 0; i < order; i++, j++) {\n    new_node->pointers[j] = temp_pointers[i];\n    new_node->keys[j] = temp_keys[i];\n    new_node->num_keys++;\n  }\n  new_node->pointers[j] = temp_pointers[i];\n  free(temp_pointers);\n  free(temp_keys);\n  new_node->parent = old_node->parent;\n  for (i = 0; i <= new_node->num_keys; i++) {\n    child = new_node->pointers[i];\n    child->parent = new_node;\n  }\n\n  return insert_into_parent(root, old_node, k_prime, new_node);\n}\n\nnode *insert_into_parent(node *root, node *left, int key, node *right)\n{\n  int left_index;\n  node *parent;\n\n  parent = left->parent;\n  if (parent == NULL)\n    return insert_into_new_root(left, key, right);\n\n  left_index = get_left_index(parent, left);\n\n  if (parent->num_keys < order - 1)\n    return insert_into_node(root, parent, left_index, key, right);\n\n  return insert_into_node_after_splitting(root, parent, left_index, key, right);\n}\n\n\nnode *insert_into_new_root(node *left, int key, node *right)\n{\n  node *root = make_node();\n  root->keys[0] = key;\n  root->pointers[0] = left;\n  root->pointers[1] = right;\n  root->num_keys++;\n  root->parent = NULL;\n  left->parent = root;\n  right->parent = root;\n  return root;\n}\n\n\nnode *start_new_tree(int key, record *pointer)\n{\n  node *root = make_leaf();\n  root->keys[0] = key;\n  root->pointers[0] = pointer;\n  root->pointers[order - 1] = NULL;\n  root->parent = NULL;\n  root->num_keys++;\n  return root;\n}\n\n\nnode *insert(node *root, int key, int value)\n{\n  record *record_pointer = NULL;\n  node *leaf = NULL;\n\n  record_pointer = find(root, key, NULL);\n  if (record_pointer != NULL) {\n    *record_pointer = *record_pointer + 1;\n    return root;\n  }\n\n  record_pointer = make_record(value);\n\n  if (root == NULL) \n    return start_new_tree(key, record_pointer);\n\n  leaf = find_leaf(root, key);\n\n  if (leaf->num_keys < order - 1) {\n    leaf = insert_into_leaf(leaf, key, record_pointer);\n    return root;\n  }\n\n  return insert_into_leaf_after_splitting(root, leaf, key, record_pointer);\n}\n\n\nint get_neighbor_index(node *n)\n{\n  int i;\n\n  for (i = 0; i <= n->parent->num_keys; i++)\n    if (n->parent->pointers[i] == n)\n      return i - 1;\n\n  // Error state.\n  printf(\"Search for nonexistent pointer to node in parent.\\n\");\n  printf(\"Node:  %#lx\\n\", (unsigned long)n);\n  exit(EXIT_FAILURE);\n}\n\n\nnode *remove_entry_from_node(node *n, int key, node *pointer) {\n\n  int i, num_pointers;\n\n  // Remove the key and shift other keys accordingly.\n  i = 0;\n  while (n->keys[i] != key)\n    i++;\n  for (++i; i < n->num_keys; i++)\n    n->keys[i - 1] = n->keys[i];\n\n\n  num_pointers = n->is_leaf ? n->num_keys : n->num_keys + 1;\n  i = 0;\n  while (n->pointers[i] != pointer)\n    i++;\n  for (++i; i < num_pointers; i++)\n    n->pointers[i - 1] = n->pointers[i];\n\n\n  // One key fewer.\n  n->num_keys--;\n\n  // Set the other pointers to NULL for tidiness.\n  // A leaf uses the last pointer to point to the next leaf.\n  if (n->is_leaf)\n    for (i = n->num_keys; i < order - 1; i++)\n      n->pointers[i] = NULL;\n  else\n    for (i = n->num_keys + 1; i < order; i++)\n      n->pointers[i] = NULL;\n\n  return n;\n}\n\n\nnode *adjust_root(node *root) {\n\n  node *new_root;\n\n  if (root->num_keys > 0)   return root;\n\n  if (!root->is_leaf) {\n    new_root = root->pointers[0];\n    new_root->parent = NULL;\n  } else\n    new_root = NULL;\n\n  free(root->keys);\n  free(root->pointers);\n  free(root);\n\n  return new_root;\n}\n\n\nnode *coalesce_nodes(node *root, node *n, node *neighbor, int neighbor_index, int k_prime) {\n\n  int i, j, neighbor_insertion_index, n_end;\n  node *tmp;\n\n  if (neighbor_index == -1) {\n    tmp = n;\n    n = neighbor;\n    neighbor = tmp;\n  }\n\n  neighbor_insertion_index = neighbor->num_keys;\n\n  if (!n->is_leaf) {\n\n    neighbor->keys[neighbor_insertion_index] = k_prime;\n    neighbor->num_keys++;\n\n    n_end = n->num_keys;\n\n    for (i = neighbor_insertion_index + 1, j = 0; j < n_end; i++, j++) {\n      neighbor->keys[i] = n->keys[j];\n      neighbor->pointers[i] = n->pointers[j];\n      neighbor->num_keys++;\n      n->num_keys--;\n    }\n\n    neighbor->pointers[i] = n->pointers[j];\n\n    for (i = 0; i < neighbor->num_keys + 1; i++) {\n      tmp = (node *)neighbor->pointers[i];\n      tmp->parent = neighbor;\n    }\n  } else {\n    for (i = neighbor_insertion_index, j = 0; j < n->num_keys; i++, j++) {\n      neighbor->keys[i] = n->keys[j];\n      neighbor->pointers[i] = n->pointers[j];\n      neighbor->num_keys++;\n    }\n    neighbor->pointers[order - 1] = n->pointers[order - 1];\n  }\n\n  root = delete_entry(root, n->parent, k_prime, n);\n  free(n->keys);\n  free(n->pointers);\n  free(n); \n  return root;\n}\n\n\nnode *redistribute_nodes(node *root, node *n, node *neighbor, int neighbor_index, \n\t\t\t  int k_prime_index, int k_prime)\n{  \n  int i;\n  node *tmp;\n\n  if (neighbor_index != -1) {\n    if (!n->is_leaf)\n      n->pointers[n->num_keys + 1] = n->pointers[n->num_keys];\n    for (i = n->num_keys; i > 0; i--) {\n      n->keys[i] = n->keys[i - 1];\n      n->pointers[i] = n->pointers[i - 1];\n    }\n    if (!n->is_leaf) {\n      n->pointers[0] = neighbor->pointers[neighbor->num_keys];\n      tmp = (node *)n->pointers[0];\n      tmp->parent = n;\n      neighbor->pointers[neighbor->num_keys] = NULL;\n      n->keys[0] = k_prime;\n      n->parent->keys[k_prime_index] = neighbor->keys[neighbor->num_keys - 1];\n    } else {\n      n->pointers[0] = neighbor->pointers[neighbor->num_keys - 1];\n      neighbor->pointers[neighbor->num_keys - 1] = NULL;\n      n->keys[0] = neighbor->keys[neighbor->num_keys - 1];\n      n->parent->keys[k_prime_index] = n->keys[0];\n    }\n  } else {  \n    if (n->is_leaf) {\n      n->keys[n->num_keys] = neighbor->keys[0];\n      n->pointers[n->num_keys] = neighbor->pointers[0];\n      n->parent->keys[k_prime_index] = neighbor->keys[1];\n    } else {\n      n->keys[n->num_keys] = k_prime;\n      n->pointers[n->num_keys + 1] = neighbor->pointers[0];\n      tmp = (node *)n->pointers[n->num_keys + 1];\n      tmp->parent = n;\n      n->parent->keys[k_prime_index] = neighbor->keys[0];\n    }\n    for (i = 0; i < neighbor->num_keys - 1; i++) {\n      neighbor->keys[i] = neighbor->keys[i + 1];\n      neighbor->pointers[i] = neighbor->pointers[i + 1];\n    }\n    if (!n->is_leaf)\n      neighbor->pointers[i] = neighbor->pointers[i + 1];\n  }\n\n  n->num_keys++;\n  neighbor->num_keys--;\n\n  return root;\n}\n\n\nnode *delete_entry(node *root, node *n, int key, void *pointer)\n{\n  int min_keys;\n  node *neighbor;\n  int neighbor_index;\n  int k_prime_index, k_prime;\n  int capacity;\n\n  n = remove_entry_from_node(n, key, pointer);\n\n  if (n == root)  return adjust_root(root);\n\n  min_keys = n->is_leaf ? cut(order - 1) : cut(order) - 1;\n\n  if (n->num_keys >= min_keys) return root;\n\n  neighbor_index = get_neighbor_index(n);\n  k_prime_index = neighbor_index == -1 ? 0 : neighbor_index;\n  k_prime = n->parent->keys[k_prime_index];\n  neighbor = neighbor_index == -1 ? n->parent->pointers[1] : \n    n->parent->pointers[neighbor_index];\n\n  capacity = n->is_leaf ? order : order - 1;\n\n  if (neighbor->num_keys + n->num_keys < capacity)\n    return coalesce_nodes(root, n, neighbor, neighbor_index, k_prime);\n  else\n    return redistribute_nodes(root, n, neighbor, neighbor_index, k_prime_index, k_prime);\n}\n\nnode *delete(node *root, int key) {\n  node *key_leaf = NULL;\n  record *key_record = find(root, key, &key_leaf);\n  \n  if (key_record)    count -= *key_record;\n\n  if (key_record != NULL && key_leaf != NULL) {\n    root = delete_entry(root, key_leaf, key, key_record);\n    free(key_record);\n  }\n  return root;\n}\n\n\nint main() {\n  node *root = NULL;\n  int x;\n  char buf[32];\n  fgets(buf, 32, stdin);\n  int n = atoi(buf);\n  for (int i=0; i<n; i++) {\n    fgets(buf, 32, stdin);\n    char *p = buf;\n    int q = atoi(p);\n    p = strchr(p, ' ');\n    x = atoi(p);\n    switch (q) {\n    case 0: // insert\n      root = insert(root, x, 1);\n      int b=++count;\n      if (b<0) {\n\tputc_unlocked('-', stdout);\n\tb = -b;\n      }\n      int j;\n      for (j=1; j*10<=b; j*=10);\n      for (;j>0; j/=10) {\n\tputc_unlocked('0'+b/j, stdout);\n\tb %= j;\n      }\n      putc_unlocked('\\n', stdout);\n      break;\n    case 1: // find\n      find_and_print(root, x);\n      break;\n    case 2: // delete x\n      root = delete(root, x);\n      break;\n    default: // dump\n      find_and_print_range(root, x, atoi(strchr(p+1, ' ')));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint searchA(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key){\n        if(mid-1<0||s[mid-1]!=key)return mid;\n        else tail=mid-1;\n    }\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return searchA(s,key,head,tail);\n}\nint searchB(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key){\n        if(mid+1>tail||s[mid+1]!=key)return mid;\n        else head=mid+1;\n    }\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return searchB(s,key,head,tail);\n}\nint getLB(int s[],int key,int head,int tail){\n    if(s[0]>key||tail<0)return 0;\n    if(s[tail]<key||head>tail)return tail+1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]<key)head=mid+1;\n    else if(s[mid]>=key){\n        if(s[mid-1]<key)return mid;\n        else tail=mid-1;\n    }\n        \n    return getLB(s,key,head,tail);\n}\nint insert(int s[],int key,int cnt){\n    int d;\n    if(cnt==0)d=0;\n    else d=getLB(s,key,0,cnt-1);\n    \n    int i;\n    for(i=cnt;i>d;i--)s[i]=s[i-1];\n    s[i]=key;\n    return 1;\n}\nint delete(int s[],int key,int cnt){\n    int h,t;\n    h=searchA(s,key,0,cnt-1);\n    if(h<0)return -1;\n    t=searchB(s,key,h,cnt-1);\n    \n    int i;\n    for(i=0;i<t-h+1&&i<cnt;i++)s[h+i]=s[t+i+1];\n    return 1;\n}\nvoid dump(int s[],int l,int r,int cnt){\n    int i;\n    i=getLB(s,l,0,cnt-1);\n\n    while(s[i]<=r&&i<cnt)printf(\"%d\\n\",s[i++]);\n    return;\n}\nvoid print(int s[],int cnt){\n    printf(\"cnt=%d,s:\",cnt);\n    for(int i=0;i<cnt;i++)printf(\"%d \",s[i]);\n    printf(\"\\n\");\n    return;\n}\nint main(void){\n    int q;\n    scanf(\"%d\\n\",&q);\n    \n    int s[q];\n    int cnt=0;\n    \n    int com,x,y;\n    int h,t;\n    while(q--){\n        scanf(\"%d \",&com);\n        switch(com){\n            case 0:\n                //insert\n                scanf(\"%d\\n\",&x);\n//    printf(\"insert:%d\\n\",x);\n                if(insert(s,x,cnt)==1)cnt++;\n                printf(\"%d\\n\",cnt);\n                break;\n            case 1:\n                //find\n                scanf(\"%d\\n\",&x);\n//    printf(\"find:%d\\n\",x);\n                h=searchA(s,x,0,cnt-1);\n                if(h==-1){\n                    printf(\"0\\n\");\n                    break;\n                }\n                t=searchB(s,x,h,cnt-1);\n//    printf(\"h=%d,t=%d\\n\",h,t);\n                printf(\"%d\\n\",t-h+1);\n                break;\n            case 2:\n                //delete\n                scanf(\"%d\\n\",&x);\n//    printf(\"delete:%d\\n\",x);\n                if(delete(s,x,cnt)==1)cnt--;\n                break;\n            case 3:\n                //dump\n                scanf(\"%d %d\\n\",&x,&y);\n//    printf(\"dump:%d %d\\n\",x,y);\n                dump(s,x,y,cnt);\n                break;\n        }\n//        print(s,cnt);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\n//block linked list\n#define Bsize 700 /*2sqrt(n)*/\ntypedef struct block{\n\tint cnt;\n\tll a[Bsize+1];\n\tstruct block*pre;\n\tstruct block*nxt;\n}block;\nvoid Bpush(block*b,ll x){\n\t//リストにxを追加する\n\tif((*b).nxt&&(*(*b).nxt).a[0]<x){\n\t\t//次へ\n\t\tBpush((*b).nxt,x);\n\t\treturn;\n\t}\n\tint i=(*b).cnt;\n\tfor(;i>0&&(*b).a[i-1]>x;i--)(*b).a[i]=(*b).a[i-1];\n\t(*b).a[i]=x;\n\t(*b).cnt++;\n\tif((*b).cnt>=Bsize){\n\t\t//分割\n\t\tblock*nn=(block*)malloc(sizeof(block));\n\t\t(*nn).cnt=Bsize-Bsize/2;\n\t\trep(i,0,Bsize-Bsize/2)(*nn).a[i]=(*b).a[i+Bsize/2];\n\t\t(*nn).pre=b;\n\t\t(*nn).nxt=(*b).nxt;\n\t\tif((*b).nxt)(*(*b).nxt).pre=nn;\n\t\t(*b).cnt=Bsize/2;\n\t\t(*b).nxt=nn;\n\t}\n}\nvoid con(block*p,block*q){\n\t//qをpにマージしてqを消す\n\trep(i,0,(*q).cnt)(*p).a[(*p).cnt+i]=(*q).a[i];\n\t(*p).cnt+=(*q).cnt;\n\t(*p).nxt=(*q).nxt;\n\tif((*q).nxt)(*(*q).nxt).pre=p;\n\tfree(q);\n}\nvoid Bdel(block*b,int idx){\n\t//idx番目を削除する(必ずidx個以上ある)\n\tfor(;idx<(*b).cnt-1;idx++)(*b).a[idx]=(*b).a[idx+1];\n\t(*b).cnt--;\n\t\n\tif((*b).cnt==0&&(*b).pre)con((*b).pre,b);\n\telse if((*b).pre&&(*(*b).pre).cnt+(*b).cnt<Bsize/4)con((*b).pre,b);\n\telse if((*b).nxt&&(*(*b).nxt).cnt+(*b).cnt<Bsize/4)con(b,(*b).nxt);\n}\n\nll Bans(block*b,int k,int flag){\n\t//リストのk番目を返す\n\t//リストにk個未満しかなければ適当に返す\n\t//flagがtrueなら削除する\n\tif((*b).cnt<=k){\n\t\tif((*b).nxt)return Bans((*b).nxt,k-(*b).cnt,flag);\n\t\telse return -1;//<-例外\n\t}\n\tll ans=(*b).a[k];\n\tif(flag)Bdel(b,k);\n\treturn ans;\n}\n//マージサボった\nint Bfind(block*b,ll k,int flag){\n\t//リストにkが何個存在するか答える\n\t//flagがtrueなら削除する\n\tif((*b).cnt==0||(*b).a[(*b).cnt-1]<k){\n\t\tif((*b).nxt)return Bfind((*b).nxt,k,flag);\n\t\telse return 0;\n\t}\n\tint i=0;\n\tfor(;(*b).a[i]<k;i++);\n\tint j=i;\n\twhile(j<(*b).cnt&&(*b).a[j]==k)j++;\n\tif(j==(*b).cnt&&(*b).nxt){\n\t\tif(flag)(*b).cnt=i;\n\t\treturn j-i+Bfind((*b).nxt,k,flag);\n\t}else{\n\t\tif(flag){\n\t\t\tfor(int xxx=j;xxx<(*b).cnt;xxx++)(*b).a[xxx-j+i]=(*b).a[xxx];\n\t\t\t(*b).cnt-=j-i;\n\t\t}\n\t\treturn j-i;\n\t}\n}\nvoid Bdump(block*b,ll l,ll r){\n\tif((*b).cnt==0){\n\t\tif((*b).nxt)Bdump((*b).nxt,l,r);\n\t}else if((*b).a[0]>r)return;\n\telse if((*b).a[(*b).cnt-1]<l){\n\t\tif((*b).nxt)Bdump((*b).nxt,l,r);\n\t}\n\telse{\n\t\trep(i,0,(*b).cnt)if(l<=(*b).a[i]&&(*b).a[i]<=r)printf(\"%lld\\n\",(*b).a[i]);\n\t\tif((*b).a[(*b).cnt-1]<=r&&(*b).nxt)Bdump((*b).nxt,l,r);\n\t}\n}\n#undef Bsize\n\n\nblock*b;\nint main(){\n\tb=calloc(1,sizeof(block));\n\tint q;\n\tscanf(\"%d\",&q);\n\tint cnt=0;\n\twhile(q--){\n\t\tint t,x;\n\t\tscanf(\"%d%d\",&t,&x);\n\t\tif(t==0){\n\t\t\tBpush(b,x);\n\t\t\tcnt++;\n\t\t\tprintf(\"%d\\n\",cnt);\n\t\t}else if(t==1){\n\t\t\tprintf(\"%d\\n\",Bfind(b,x,0));\n\t\t}else if(t==2){\n\t\t\tcnt-=Bfind(b,x,1);\n\t\t}else{\n\t\t\tint y;\n\t\t\tscanf(\"%d\",&y);\n\t\t\tBdump(b,x,y);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint searchA(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key){\n        if(mid-1<0||s[mid-1]!=key)return mid;\n        else tail=mid-1;\n    }\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return searchA(s,key,head,tail);\n}\nint searchB(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key){\n        if(mid+1>tail||s[mid+1]!=key)return mid;\n        else head=mid+1;\n    }\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return searchB(s,key,head,tail);\n}\nint getLB(int s[],int key,int head,int tail){\n    if(s[0]>key||tail<0)return 0;\n    if(s[tail]<key||head>tail)return tail+1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]<key)head=mid+1;\n    else if(s[mid]>=key){\n        if(s[mid-1]<key)return mid;\n        else tail=mid-1;\n    }\n        \n    return getLB(s,key,head,tail);\n}\nint insert(int s[],int key,int cnt){\n    int d;\n    if(cnt==0)d=0;\n    else d=getLB(s,key,0,cnt-1);\n    \n    int i;\n    for(i=cnt;i>d;i--)s[i]=s[i-1];\n    s[i]=key;\n    return 1;\n}\nint delete(int s[],int key,int cnt){\n    int h,t;\n    h=searchA(s,key,0,cnt-1);\n    if(h<0)return 0;\n    t=searchB(s,key,h,cnt-1);\n    \n    int i,j;\n    for(i=h,j=1;i<cnt;i++,j++)s[i]=s[t+j];\n    return t-h+1;\n}\nvoid dump(int s[],int l,int r,int cnt){\n    int i;\n    i=getLB(s,l,0,cnt-1);\n\n    while(s[i]<=r&&i<cnt)printf(\"%d\\n\",s[i++]);\n    return;\n}\nvoid print(int s[],int cnt){\n    printf(\"cnt=%d,s:\",cnt);\n    for(int i=0;i<cnt;i++)printf(\"%d \",s[i]);\n    printf(\"\\n\");\n    return;\n}\nint main(void){\n    int q;\n    scanf(\"%d\\n\",&q);\n    \n    int s[q];\n    int cnt=0;\n    \n    int com,x,y;\n    int h,t;\n    while(q--){\n        scanf(\"%d \",&com);\n        switch(com){\n            case 0:\n                //insert\n                scanf(\"%d\\n\",&x);\n//    printf(\"insert:%d\\n\",x);\n                if(insert(s,x,cnt)==1)cnt++;\n                printf(\"%d\\n\",cnt);\n                break;\n            case 1:\n                //find\n                scanf(\"%d\\n\",&x);\n//    printf(\"find:%d\\n\",x);\n                h=searchA(s,x,0,cnt-1);\n                if(h==-1){\n                    printf(\"0\\n\");\n                    break;\n                }\n                t=searchB(s,x,h,cnt-1);\n    printf(\"h=%d,t=%d\\n\",h,t);\n                printf(\"%d\\n\",t-h+1);\n                break;\n            case 2:\n                //delete\n                scanf(\"%d\\n\",&x);\n//    printf(\"delete:%d\\n\",x);\n                cnt-=delete(s,x,cnt);\n                break;\n            case 3:\n                //dump\n                scanf(\"%d %d\\n\",&x,&y);\n//    printf(\"dump:%d %d\\n\",x,y);\n                dump(s,x,y,cnt);\n                break;\n        }\n//        print(s,cnt);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\n#define\tll_int\tlong long int\n#define\tBUCKET_SIZE\t10000000\n#define\tSUB_SIZE\t100\n\n\nint ELEMENT_N;\n\ntypedef struct data_t{\n\tll_int num;\n\tint n;\n\tstruct data_t *next;\n} DATA_T;\n\nDATA_T **S;\n\n\n// ハッシュテーブルの初期化\nvoid Init()\n{\n\tint i;\n\n\n\tfor(i = 0; i < BUCKET_SIZE; i++)\n\t\tS[i] = NULL;\n}\n\n\n// ハッシュ算出\nll_int Hash(ll_int num)\n{\n\treturn num / SUB_SIZE;\n}\n\n\n// 受け取った数値を探索\nDATA_T *Find(ll_int num)\n{\n\tll_int h;\n\tDATA_T *p;\n\n\n\th = Hash(num);\n\n\tfor(p = S[h]; p != NULL; p = p->next){\n\t\tif(num == p->num)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\n\n// 該当する添え字の箱へ昇順になるように数値を挿入\nvoid Insert(ll_int num)\n{\n\tll_int h;\n\tDATA_T *p;\n\tDATA_T *i, *j;\n\n\n\tELEMENT_N++;\n\n\tif(( p = Find(num) )){\n\t\tp->n++;\n\t\treturn;\n\t}\n\n\n\t/* 挿入処理(比較していき、該当する場所へ突っ込む) */\n\tif( ( p = (DATA_T *)malloc(sizeof(DATA_T)) ) == NULL){\n\t\tprintf(\"malloc error\\n\");\n\t\texit(1);\n\t}\n\n\tp->num = num;\n\tp->n = 1;\n\th = Hash(num);\n\n\tif(S[h] == NULL){\n\t// 該当する添え字の箱が空の場合\n\t\tS[h] = p;\n\t\tp->next = NULL;\n\t}else if(num < S[h]->num){\n\t// 該当する添え字の先頭に挿入\n\t\tp->next = S[h];\n\t\tS[h] = p;\n\t}else{\n\t// 先頭以降への挿入\n\t\tfor(i = S[h], j = i->next; j != NULL; i = j, j = j->next){\n\t\t\tif(i->num < num && num < j->num){\n\t\t\t\ti->next = p;\n\t\t\t\tp->next = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(j == NULL){\n\t\t// 最後尾に突っ込む\n\t\t\ti->next = p;\n\t\t\tp->next = j;\n\t\t}\n\t}\n}\n\n\n// 受け取った数値の全削除\nvoid Delete(ll_int num)\n{\n\tDATA_T *p, *q;\n\tll_int h;\n\n\n\t// 削除したい数値がないなら戻る\n\tif(Find(num) == NULL)\n\t\treturn;\n\n\n\th = Hash(num);\n\tp = S[h];\n\n\t// 先頭にある場合の処理\n\tif(num == p->num){\n\t\tS[h] = p->next;\n\t\tELEMENT_N -= p->n;\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\t// 先頭以降の処理\n\tfor(q = p->next;; p = q, q = q->next){\n\t\tif(num == q->num){\n\t\t\tp->next = q->next;\n\t\t\tELEMENT_N -= q->n;\n\t\t\tfree(q);\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\n\n// lとrを基準にハッシュテーブルの添え字を計算、条件にあった数値を出力\nvoid Dump(ll_int l, ll_int r)\n{\n\tDATA_T *p;\n\tll_int start_h, end_h;\n\tll_int i;\n\tint j;\n\n\n\tstart_h = Hash(l);\n\tend_h = Hash(r);\n\n\tfor(i = start_h; i <= end_h; i++){\n\t\tfor(p = S[i]; p != NULL; p = p->next){\n\t\t\tif(r < p->num)\n\t\t\t\treturn;\n\n\t\t\tif(l <= p->num && p->num <= r)\n\t\t\t\tfor(j = 0; j < p->n; j++)\n\t\t\t\t\tprintf(\"%lld\\n\", p->num);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tint q;\n\tint query;\n\tll_int num, l, r;\n\tDATA_T *p;\n\tint i;\n\n\n\tELEMENT_N = 0;\n\tS = (DATA_T **)malloc(sizeof(DATA_T *) * (BUCKET_SIZE + 1));\n\n\tscanf(\"%d\", &q);\n\n\tfor(i = 0; i < q; i++){\n\t\tscanf(\"%d\", &query);\n\n\t\tif(query == 0){\n\t\t// insert\n\t\t\tscanf(\"%lld\", &num);\n\t\t\tInsert(num);\n\t\t\tprintf(\"%d\\n\", ELEMENT_N);\n\t\t}else if(query == 1){\n\t\t// find\n\t\t\tscanf(\"%lld\", &num);\n\t\t\tif(( p = Find(num) ))\n\t\t\t\tprintf(\"%d\\n\", p->n);\n\t\t\telse\n\t\t\t\tprintf(\"0\\n\");\n\t\t}else if(query == 2){\n\t\t// Delete\n\t\t\tscanf(\"%lld\", &num);\n\t\t\tDelete(num);\n\t\t}else if(query == 3){\n\t\t// Dump\n\t\t\tscanf(\"%lld %lld\", &l, &r);\n\t\t\tDump(l, r);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/*\n\tSet_Range_Searchを改良\n*/\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.SortedMap;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class Main  {\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tint count = 0;\n\t\tTreeMap<Long, Long> map = new TreeMap<>();\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint query = scan.nextInt();\n\t\t\tlong a = scan.nextInt();\n\n\t\t\tswitch(query) {\n\n\t\t\tcase 0:\t//insert\n\t\t\t\tif(!map.containsKey(a)) map.put(a, 1l);\n\t\t\t\telse map.put(a, map.get(a) + 1);\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\t//find\n\t\t\t\tif(map.get(a) != null) System.out.println(map.get(a));\n\t\t\t\telse System.out.println(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t//delete\n\t\t\t\tif(map.get(a) != null) {\n\t\t\t\t\tcount -= map.get(a);\n\t\t\t\t\tmap.remove(map.get(a));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\t//dump\n\t\t\t\tlong b = scan.nextInt();\n\t\t\t\tSortedMap<Long, Long> subM = map.subMap(a,true, b,true);\n\t\t\t\tfor(Long x : subM.keySet()) {\n\t\t\t\t\tfor(int j=0; j<map.get(x); i++) {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            \n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tSystem.out.println(mset.size());\n            \tbreak;\n            \t\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tSystem.out.println(mset.find(x1));\n            \tbreak;\n            \t\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n            \t\n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact;\n\t\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\t\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(size==0) {\n\t\t\tROOT=NEW;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\t\n\tint size() {\n\t\treturn size;\n\t}\n\t\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\t\n\tint find(int x) {\n\t\tBnode F=search(x);\n\t\treturn (F.v==x)? F.num : 0;\n\t}\n\t\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x) {\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\t\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\t\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\t\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\t\t\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\t\t\n\t\tchild.p=D.p;\n\t}\n\t\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\t\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\t\n\tvoid dump(int L,int R) {\n\t\tNOW=ROOT;\n\t\tinodrwalk(NOW,L,R);\n\t\tout.flush();\n\t}\n\t\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        Mymset mset=new Mymset();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            switch(odr) {\n            case 0:\n                System.out.println(mset.insert(Integer.parseInt(in.next())));\n                break;\n                 \n            case 1:\n                System.out.println(mset.find(Integer.parseInt(in.next())));\n                break;\n                 \n            case 2:\n                mset.removeOf(Integer.parseInt(in.next()));\n                break;\n                 \n            case 3:\n                mset.dump(Integer.parseInt(in.next()),Integer.parseInt(in.next()));\n                break;\n            }\n        }\n    }\n \n}\n \nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n \n \n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n \nclass Mymset{\n    Bnode root,dummy,NOW;\n    int size;\n    PrintWriter out=new PrintWriter(System.out);\n     \n    Mymset(){\n        dummy=new Bnode(-1,-1);\n        dummy.p=dummy; dummy.l=dummy; dummy.r=dummy;\n        init();\n        size=0;\n    }\n \n    void init() {\n        root=dummy;\n    }\n \n    int insert(int x) {\n        Bnode NEW=new Bnode(x,1);\n        NEW.l=dummy;NEW.r=dummy;\n        if(size==0) {\n            root=NEW;\n            root.p=dummy;\n        }\n        else {\n            //Bnode NOW=root;\n            NOW=root;\n            while(true) {\n                if(NOW.v==NEW.v) {\n                    NOW.num++;\n                    break;\n                }\n                else if(NEW.v>NOW.v) {\n                    if(NOW.r.v==-1) {\n                        NOW.r=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.r;\n                }\n                else {\n                    if(NOW.l.v==-1) {\n                        NOW.l=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.l;\n                }\n            }\n        }\n        size++;\n        return size;\n    }\n \n    void removeOf(int x){\n        find(x);\n        int n=NOW.num;\n        if(NOW.r.v==-1 && NOW.l.v==-1){\n        \tSystem.out.println(\"delete mode 0\");\n            if(NOW.p.l==NOW)NOW.p.l=dummy;\n            else NOW.p.r=dummy;\n            \n            if(size-n==0)init();\n        }\n        else if((NOW.r.v!=-1 && NOW.l.v==-1) || (NOW.l.v!=-1 && NOW.r.v==-1)) {\n        \tSystem.out.println(\"delete mode 1\");\n        \tif(NOW==root) {\n        \t\tif(root.l.v==-1)root=root.r;\n        \t\telse root=root.l;\n        \t}\n        \telse if(NOW.p.r==NOW) {\n                NOW.p.r=NOW.r;\n                NOW.r.p=NOW.p;\n            }\n            else {\n                NOW.p.l=NOW.l;\n                NOW.l.p=NOW.p;\n            }\n        }\n        else {\n        \tSystem.out.println(\"delete mode 2\");\n            Bnode y=findNextNode(NOW.r);\n            NOW.v=y.v;\n            NOW.num=y.num;\n            if(y.r.v==-1 && y.l.v==-1){\n                if(y.p.l==y)y.p.l=dummy;\n                else y.p.r=dummy;\n            }\n            else if((y.r.v!=-1 && y.l.v==-1) || (y.l.v!=-1 && y.r.v==-1)) {\n                if(y.p.r==y) {\n                    y.p.r=y.r;\n                    y.r.p=y.p;\n                }\n                else {\n                    y.p.l=y.l;\n                    y.l.p=y.p;\n                }\n            }\n        }\n        size-=n;\n    }\n     \n     \n    Bnode findNextNode(Bnode node) {\n        if(node.l.v!=-1)return findNextNode(node.l);\n        else return node;\n    }\n \n    int find(int x){\n        NOW=root;\n        while(NOW.v!=-1) {\n \n            if(NOW.v==x)break;\n            else if(NOW.v>x)NOW=NOW.l;\n            else NOW=NOW.r;\n        }\n        return (NOW.num>0)?NOW.num : 0;\n    }\n \n    void dump(int L,int R) {\n        inwalk(root,L,R);\n        out.flush();\n    }\n \n    void inwalk(Bnode now,int L,int R) {\n        if(now.v>=L && now.v<=R) {\n            if(now.l.v!=-1)inwalk(now.l,L,R);\n            for(int i=0;i<now.num;i++)out.println(now.v);\n            if(now.r.v!=-1)inwalk(now.r,L,R);\n        }\n    }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        Mymset mset=new Mymset();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            switch(odr) {\n            case 0:\n            \tSystem.out.println(mset.insert(Integer.parseInt(in.next())));\n            \tbreak;\n            \t\n            case 1:\n            \tSystem.out.println(mset.find(Integer.parseInt(in.next())));\n            \tbreak;\n            \t\n            case 2:\n            \tmset.removeOf(Integer.parseInt(in.next()));\n            \tbreak;\n            \t\n            case 3:\n            \tmset.dump(Integer.parseInt(in.next()),Integer.parseInt(in.next()));\n            \tbreak;\n            }\n        }\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass Mymset{\n    Bnode root,dummy,NOW;\n    int size;\n    PrintWriter out=new PrintWriter(System.out);\n    \n    Mymset(){\n        dummy=new Bnode(-1,-1);\n        dummy.p=dummy; dummy.l=dummy; dummy.r=dummy;\n        init();\n        size=0;\n    }\n\n    void init() {\n        root=dummy;\n    }\n\n    int insert(int x) {\n        Bnode NEW=new Bnode(x,1);\n        NEW.l=dummy;NEW.r=dummy;\n        if(size==0) {\n            root=NEW;\n            root.p=dummy;\n        }\n        else {\n            //Bnode NOW=root;\n            NOW=root;\n            while(true) {\n            \tif(NOW.v==NEW.v) {\n                    NOW.num++;\n                    break;\n                }\n            \telse if(NEW.v>NOW.v) {\n                    if(NOW.r.v==-1) {\n                        NOW.r=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.r;\n                }\n                else {\n                    if(NOW.l.v==-1) {\n                        NOW.l=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.l;\n                }\n            }\n        }\n        size++;\n        return size;\n    }\n\n    void removeOf(int x){\n    \tfind(x);\n    \tint n=NOW.num;\n    \tif(NOW.r.v==-1 && NOW.l.v==-1){\n    \t\tif(NOW.p.l==NOW)NOW.p.l=dummy;\n    \t\telse NOW.p.r=dummy;\n    \t}\n    \telse if(NOW.r.v!=-1 || NOW.l.v!=-1) {\n    \t\tif(NOW.p.r==NOW) {\n    \t\t\tNOW.p.r=NOW.r;\n    \t\t\tNOW.r.p=NOW.p;\n    \t\t}\n    \t\telse {\n    \t\t\tNOW.p.l=NOW.l;\n    \t\t\tNOW.l.p=NOW.p;\n    \t\t}\n    \t}\n    \telse {\n    \t\tBnode y=findNextNode(NOW.r);\n    \t\tNOW.v=y.v;\n    \t\tNOW.num=y.num;\n    \t\tif(y.r.v==-1 && y.l.v==-1){\n        \t\tif(y.p.l==y)y.p.l=dummy;\n        \t\telse y.p.r=dummy;\n        \t}\n        \telse if(y.r.v!=-1 || y.l.v!=-1) {\n        \t\tif(y.p.r==y) {\n        \t\t\ty.p.r=y.r;\n        \t\t\ty.r.p=y.p;\n        \t\t}\n        \t\telse {\n        \t\t\ty.p.l=y.l;\n        \t\t\ty.l.p=y.p;\n        \t\t}\n        \t}\n    \t}\n    \tsize-=n;\n    }\n    \n    \n    Bnode findNextNode(Bnode node) {\n    \tif(node.l.v!=-1)return findNextNode(node.l);\n    \telse return node;\n    }\n\n    int find(int x){\n        NOW=root;\n        while(NOW.v!=-1) {\n\n            if(NOW.v==x)break;\n            else if(NOW.v>x)NOW=NOW.l;\n            else NOW=NOW.r;\n        }\n        return (NOW.num>0)?NOW.num : 0;\n    }\n\n    void dump(int L,int R) {\n        inwalk(root,L,R);\n        out.flush();\n    }\n\n    void inwalk(Bnode now,int L,int R) {\n        if(now.v>=L && now.v<=R) {\n        \tif(now.l.v!=-1)inwalk(now.l,L,R);\n            System.out.println(now.v);\n            if(now.r.v!=-1)inwalk(now.r,L,R);\n        }\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0, index, count, output;\n\t\tList<Integer> a = new ArrayList<Integer>(1);\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\ta.add(x);\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tSystem.out.println(a.lastIndexOf(x) - a.indexOf(x) + 2);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tindex = a.indexOf(x);\n\t\t\t\t\t\t\tcount = a.lastIndexOf(x) - index;\n\t\t\t\t\t\t\tfor(; count >= 0; count--) {\n\t\t\t\t\t\t\t\ta.remove(index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tNavigableSet<Integer> subset = set.subSet(x, true, sc.nextInt(), true);\n//\t\t\t\t\tfor(Integer ir : subset) {\n//\t\t\t\t\t\tSystem.out.println(ir);\n//\t\t\t\t\t}\n\t\t\t\t\tfor(j = 0; j < subset.size(); j++) {\n\t\t\t\t\t\toutput = subset.pollFirst();\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(a.contains(output)) {\n\t\t\t\t\t\t\tfor(int k = 0; k < a.lastIndexOf(x) - a.indexOf(x) + 1; k++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint times = sc.nextInt();\n\t\t\tTreeMap<Long, Long> map = new TreeMap<>();\n\t\t\tlong size = 0l;\n\t\t\tfor (int i = 0; i<times; i++){\n\t\t\t\tint query = sc.nextInt();  //0insert 1find 2delete 3dump\n\t\t\t\tlong x = sc.nextLong();\n\t\t\t\tswitch (query) {\n\t\t\t\t//insert(x)\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!map.containsKey(x)) map.put(x,1l);\n\t\t\t\t\telse map.put(x,map.get(x)+1);\n\t\t\t\t\tsize++;  //毎回size+1\n\t\t\t\t\tSystem.out.println(size);\n\t\t\t\t\tbreak;\n\t\t\t\t//find(x)\n\t\t\t\tcase 1:\n\t\t\t\t\tif (map.get(x)!=null) {\n\t\t\t\t\t\tSystem.out.println(map.get(x));\n\t\t\t\t\t} else System.out.println(0);\n\t\t\t\t\tbreak;\n\t\t\t\t//delete(x)\n\t\t\t\tcase 2:\n\t\t\t\t\tif (map.get(x) != null) {\n\t\t\t\t\t\tsize -= map.get(x);  //remove時sizeを減る\n\t\t\t\t\t\tmap.remove(x);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t//dump(x,large)\n\t\t\t\tcase 3:\n\t\t\t\t\tlong large = sc.nextLong();\n\t\t\t\t\tSortedMap<Long,Long> submap = map.subMap(x,true,large,true);\n\t\t\t\t\tfor (Long l : submap.keySet()) {\n\t\t\t\t\t\tfor (int j=0; j<map.get(l); j++) System.out.println(l);   //回数があるだけ出力\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\tint count = 0;\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint op = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tswitch (op) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!map.keySet().contains(y)) {\n\t\t\t\t\t\tmap.put(y, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap.put(y, map.get(y) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(++count);\n\t\t\t\t\tsb.append('\\n');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (map.keySet().contains(y)) {\n\t\t\t\t\t\tsb.append(map.get(y));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append('0');\n\t\t\t\t\t}\n\t\t\t\t\tsb.append('\\n');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (map.keySet().contains(y)) {\n\t\t\t\t\t\tint num2 = map.get(y);\n\t\t\t\t\t\tmap.remove(y);\n\t\t\t\t\t\tcount -= num2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tint z = sc.nextInt() + 1;\n\t\t\t\t\tSet<Integer> subset = map.subMap(y, z).keySet();\n\t\t\t\t\tfor (int num : subset) {\n\t\t\t\t\t\tint end = map.get(num);\n\t\t\t\t\t\tfor (int j = 0; j < end; j++) {\n\t\t\t\t\t\t\tsb.append(num);\n\t\t\t\t\t\t\tsb.append('\\n');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tvoid solve (FastScanner in, PrintWriter out, Methods ms) {\n\n\t\tint n = in.nextInt();\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\tint count = 0;\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint mode = in.nextInt();\n\t\t\tif (mode == 0) {\n\t\t\t\tint key = in.nextInt();\n\t\t\t\tmap.put(key, map.getOrDefault(key, 0)+1);\n\t\t\t\tcount++;\n\t\t\t\tout.println(count);\n\t\t\t}\n\t\t\telse if (mode == 1) {\n\t\t\t\tout.println(map.getOrDefault(in.nextInt(), 0));\n\t\t\t}\n\t\t\telse if (mode == 2) {\n\t\t\t\tint key = in.nextInt();\n\t\t\t\tcount -= map.getOrDefault(key, 0);\n\t\t\t\tmap.remove(key);\n\t\t\t}\n\t\t\telse if (mode == 3) {\n\t\t\t\tNavigableMap<Integer, Integer> sub = map.subMap(in.nextInt(), true, in.nextInt(), true);\n\t\t\t\tfor (Map.Entry<Integer, Integer> e : sub.entrySet()) {\n\t\t\t\t\tfor (int j=0; j<e.getValue(); j++) {\n\t\t\t\t\t\tout.println(e.getKey());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tMethods ms = new Methods();\n\t\tmain.solve(in, out, ms);\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic class Methods {\n\n\t\tpublic void print (Object... ar) {System.out.println(Arrays.deepToString(ar));}\n\n\t\tpublic void yesno (PrintWriter out, boolean b) {out.println(b?\"Yes\":\"No\");}\n\n\t\tpublic void YESNO (PrintWriter out, boolean b) {out.println(b?\"YES\":\"NO\");}\n\n\t\tpublic int max (int... ar) {Arrays.sort(ar); return ar[ar.length-1];}\n\n\t\tpublic int min (int... ar) {Arrays.sort(ar); return ar[0];}\n\n\t}\n\n\tstatic class FastScanner {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate  int length = 0, p = 0;\n\n\t\tpublic FastScanner (InputStream stream) {\n\t\t\tin = stream;\n\t\t}\n\n\t\tpublic boolean hasNextByte () {\n\t\t\tif (p < length) return true;\n\t\t\telse {\n\t\t\t\tp = 0;\n\t\t\t\ttry {length = in.read(buffer);}\n\t\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\t\tif (length <= 0) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int readByte () {\n\t\t\tif (hasNextByte() == true) return buffer[p++];\n\t\t\treturn -1;\n\t\t}\n\n\t\tpublic boolean isPrintable (int n) {return 33<=n&&n<=126;}\n\n\t\tpublic void skip () {\n\t\t\twhile (hasNextByte() && !isPrintable(buffer[p])) p++;\n\t\t}\n\n\t\tpublic boolean hasNext () {skip(); return hasNextByte();}\n\n\t\tpublic String next () {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint t = readByte();\n\t\t\twhile (isPrintable(t)) {\n\t\t\t\tsb.appendCodePoint(t);\n\t\t\t\tt = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic String[] nextArray (int n) {\n\t\t\tString[] ar = new String[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = next();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic int nextInt () {return Math.toIntExact(nextLong());}\n\n\t\tpublic int[] nextIntArray (int n) {\n\t\t\tint[] ar = new int[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = nextInt();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic long nextLong () {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tboolean minus = false;\n\t\t\tint temp = readByte();\n\t\t\tif (temp == '-') {\n\t\t\t\tminus = true;\n\t\t\t\ttemp = readByte();\n\t\t\t}\n\t\t\tif (temp<'0' || '9'<temp) throw new NumberFormatException();\n\t\t\tlong n = 0;\n\t\t\twhile (isPrintable(temp)) {\n\t\t\t\tif ('0'<=temp && temp<='9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += temp - '0';\n\t\t\t\t}\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\ttemp = readByte();\n\t\t\t}\n\t\t\treturn minus? -n : n;\n\t\t}\n\n\t\tpublic long[] nextLongArray (int n) {\n\t\t\tlong[] ar = new long[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = nextLong();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic double nextDouble () {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray (int n) {\n\t\t\tdouble[] ar = new double[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = nextDouble();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic void close () {\n\t\t\ttry {in.close();}\n\t\t\tcatch(Exception e){}\n\t\t}\n\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tmap.compute(x, (key, old) -> old + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tSystem.out.println(map.get(x) + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tcounter -= map.remove(x);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tcounter--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tfor(Integer output : set.subSet(x, true, sc.nextInt(), true)) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(map.containsKey(output)) {\n\t\t\t\t\t\t\tfor(j = 0; j < map.get(output); j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.SortedMap;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class Main  {\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tint count = 0;\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint query = scan.nextInt();\n\t\t\tint a = scan.nextInt();\n\n\t\t\tswitch(query) {\n\n\t\t\tcase 0:\t//insert\n\t\t\t\tif(!map.containsKey(a)) map.put(a, 1);\n\t\t\t\telse map.put(a, map.get(a) + 1);\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\t//find\n\t\t\t\tif(map.get(a) != null) System.out.println(map.get(a));\n\t\t\t\telse System.out.println(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t//delete\n\t\t\t\tif(map.get(a) != null) {\n\t\t\t\t\tcount -= map.get(a);\n\t\t\t\t\tmap.remove(map.get(a));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\t//dump\n\t\t\t\tint b = scan.nextInt();\n\t\t\t\tSortedMap<Integer, Integer> subM = map.subMap(a,true, b,true);\n\t\t\t\tfor(Integer x : subM.keySet()) {\n\t\t\t\t\tfor(int j=0; j<map.get(x); i++) {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();  //キーに対応する値にはキーの要素数を入れる\n\t\tint mapSize = 0;\n\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tint query = sc.nextInt();\n\n\t\t\tswitch(query) {\n\t\t\tcase 0:\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(map.get(x) == null) {\n\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t}\n\t\t\t\telse map.replace(x, map.get(x) + 1);\n\t\t\t\tmapSize++;\n\t\t\t\tSystem.out.println(mapSize);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(map.get(x) == null) \tSystem.out.println(0);\n\t\t\t\telse System.out.println(map.get(x));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(map.get(x) != null) {\n\t\t\t\t\tmapSize -= map.get(x);\n\t\t\t\t\tmap.remove(x);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\n\t\t\t\tfor(int n : map.subMap(l, true, r, true).keySet()) {\n\t\t\t\t\tfor(int j = 0; j < map.get(n); j++) {\n\t\t\t\t\t\tSystem.out.println(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        TreeMap<Integer,Integer> mset=new TreeMap<>();\n        int q=Integer.parseInt(in.next()),size=0;\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tInteger num0=mset.get(x0);\n            \tif(num0!=null)mset.put(x0, num0+1);\n            \telse mset.put(x0, 1);\n            \tsize++;\n            \tout.println(size);\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tInteger num1=mset.get(x1);\n            \tout.println((num1!=null)? num1:0);\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tInteger num2=mset.get(x2);\n            \tif(num2!=null)size-=num2;\n            \tmset.remove(x2);\n            \tbreak;\n\n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tNavigableMap<Integer,Integer> sub=mset.subMap(L, true, R, true);\n            \tIterator<NavigableMap.Entry<Integer,Integer>> itr=sub.entrySet().iterator();\n            \t\n            \twhile(itr.hasNext()) {\n            \t\tNavigableMap.Entry<Integer,Integer> get=itr.next();\n            \t\tint k=get.getKey(),num=get.getValue();\n            \t\tfor(int j=0;j<num;j++)out.println(k);\n            \t}\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0;\n\t\tList<Integer> a = new ArrayList<Integer>(1);\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\ta.add(x);\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tSystem.out.println(a.lastIndexOf(x) - a.indexOf(x) + 2);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\twhile(a.contains(x)) {\n\t\t\t\t\t\t\ta.remove(a.indexOf(x));\n\t\t\t\t\t\t\tcounter--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tNavigableSet<Integer> subset = set.subSet(x, true, sc.nextInt(), true);\n\t\t\t\t\tfor(Integer output : subset) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(a.contains(output)) {\n\t\t\t\t\t\t\tfor(j = 0; j < a.lastIndexOf(x) - a.indexOf(x) + 1; j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        Mymset mset=new Mymset();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            switch(odr) {\n            case 0:\n                System.out.println(mset.insert(Integer.parseInt(in.next())));\n                break;\n                 \n            case 1:\n                System.out.println(mset.find(Integer.parseInt(in.next())));\n                break;\n                 \n            case 2:\n                mset.removeOf(Integer.parseInt(in.next()));\n                break;\n                 \n            case 3:\n                mset.dump(Integer.parseInt(in.next()),Integer.parseInt(in.next()));\n                break;\n            }\n        }\n    }\n \n}\n \nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n \n \n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n \nclass Mymset{\n    Bnode root,dummy,NOW;\n    int size;\n    PrintWriter out=new PrintWriter(System.out);\n     \n    Mymset(){\n        dummy=new Bnode(-1,-1);\n        dummy.p=dummy; dummy.l=dummy; dummy.r=dummy;\n        init();\n        size=0;\n    }\n \n    void init() {\n        root=dummy;\n    }\n \n    int insert(int x) {\n        Bnode NEW=new Bnode(x,1);\n        NEW.l=dummy;NEW.r=dummy;\n        if(size==0) {\n            root=NEW;\n            root.p=dummy;\n        }\n        else {\n            //Bnode NOW=root;\n            NOW=root;\n            while(true) {\n                if(NOW.v==NEW.v) {\n                    NOW.num++;\n                    break;\n                }\n                else if(NEW.v>NOW.v) {\n                    if(NOW.r.v==-1) {\n                        NOW.r=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.r;\n                }\n                else {\n                    if(NOW.l.v==-1) {\n                        NOW.l=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.l;\n                }\n            }\n        }\n        size++;\n        return size;\n    }\n \n    void removeOf(int x){\n        find(x);\n        int n=NOW.num;\n        if(NOW.r.v==-1 && NOW.l.v==-1){\n        \t//System.out.println(\"delete mode 0\");\n            if(NOW.p.l==NOW)NOW.p.l=dummy;\n            else NOW.p.r=dummy;\n            \n            if(size-n==0)init();\n        }\n        else if((NOW.r.v!=-1 && NOW.l.v==-1) || (NOW.l.v!=-1 && NOW.r.v==-1)) {\n        \t//System.out.println(\"delete mode 1\");\n        \tif(NOW==root) {\n        \t\tif(root.l.v==-1)root=root.r;\n        \t\telse root=root.l;\n        \t}\n        \telse if(NOW.p.r==NOW) {\n                NOW.p.r=NOW.r;\n                NOW.r.p=NOW.p;\n            }\n            else {\n                NOW.p.l=NOW.l;\n                NOW.l.p=NOW.p;\n            }\n        }\n        else {\n        \t//System.out.println(\"delete mode 2\");\n            Bnode y=findNextNode(NOW.r);\n            NOW.v=y.v;\n            NOW.num=y.num;\n            if(y.r.v==-1 && y.l.v==-1){\n                if(y.p.l==y)y.p.l=dummy;\n                else y.p.r=dummy;\n            }\n            else if((y.r.v!=-1 && y.l.v==-1) || (y.l.v!=-1 && y.r.v==-1)) {\n                if(y.p.r==y) {\n                    y.p.r=y.r;\n                    y.r.p=y.p;\n                }\n                else {\n                    y.p.l=y.l;\n                    y.l.p=y.p;\n                }\n            }\n        }\n        size-=n;\n    }\n     \n     \n    Bnode findNextNode(Bnode node) {\n        if(node.l.v!=-1)return findNextNode(node.l);\n        else return node;\n    }\n \n    int find(int x){\n        NOW=root;\n        while(NOW.v!=-1) {\n \n            if(NOW.v==x)break;\n            else if(NOW.v>x)NOW=NOW.l;\n            else NOW=NOW.r;\n        }\n        return (NOW.num>0)?NOW.num : 0;\n    }\n \n    void dump(int L,int R) {\n        inwalk(root,L,R);\n        out.flush();\n    }\n \n    void inwalk(Bnode now,int L,int R) {\n    \tif(now.l.v!=-1)inwalk(now.l,L,R);\n    \tif(now.v>=L && now.v<=R)for(int i=0;i<now.num;i++)out.println(now.v);\n        if(now.r.v!=-1)inwalk(now.r,L,R);\n    }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\tmap.computeIfAbsent(x, old -> old++);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + map.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tSystem.out.println(map.get(x) + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\tmap.remove(x);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tfor(Integer output : set.subSet(x, true, sc.nextInt(), true)) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(map.containsKey(output)) {\n\t\t\t\t\t\t\tfor(j = 0; j < map.get(output); j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();  //キーに対応する値にはキーの要素数を入れる\n\t\tint mapSize = 0;\n\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tint query = sc.nextInt();\n\n\t\t\tswitch(query) {\n\t\t\tcase 0:\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(map.get(x) == null) {\n\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t}\n\t\t\t\telse map.replace(x, map.get(x) + 1);\n\t\t\t\tmapSize++;\n\t\t\t\tSystem.out.println(mapSize);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(map.get(x) == null) \tSystem.out.println(0);\n\t\t\t\telse System.out.println(map.get(x));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tmapSize -= map.get(x);\n\t\t\t\tmap.remove(x);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\n\t\t\t\tfor(int n : map.subMap(l, true, r, true).keySet()) {\n\t\t\t\t\tfor(int j = 0; j < map.get(n); j++) {\n\t\t\t\t\t\tSystem.out.println(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner (System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n        List<Integer> mset=new ArrayList<>();\n        boolean ex[]=new boolean[1000000001];\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            switch(odr) {\n            case 0:\n            \tint x1=Integer.parseInt(in.next());\n            \tmset.add(x1);\n                System.out.println(mset.size());\n                break;\n                 \n            case 1:\n            \tint x2=Integer.parseInt(in.next());\n            \tCollections.sort(mset);\n            \tint k=mset.indexOf(x2),l=mset.lastIndexOf(x2);\n                if(l>=0)System.out.println(l-k+1);\n                else System.out.println(0);\n                break;\n                 \n            case 2:\n            \tList<Integer> rm=new ArrayList<>();\n            \trm.add(Integer.parseInt(in.next()));\n                mset.removeAll(rm);\n                break;\n                 \n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tCollections.sort(mset);\n            \tfor(int j=L;j<=R;j++) {\n            \t\tif(mset.contains(j)) {\n            \t\t\tint b=mset.indexOf(j),e=mset.lastIndexOf(j);\n            \t\t\tfor(int v=b;v<=e;v++)out.println(j);\n            \t\t}\n            \t}\n            \tout.flush();\n                //mset.dump(Integer.parseInt(in.next()),Integer.parseInt(in.next()));\n                break;\n            }\n        }\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\npublic class Main  {\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tint count = 0;\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint query = scan.nextInt();\n\t\t\tint a = scan.nextInt();\n\n\t\t\tswitch(query) {\n\n\t\t\tcase 0:\t//insert\n\t\t\t\tif(!map.containsKey(a)) map.put(a, 1l);\n\t\t\t\telse map.put(a, map.get(a) + 1);\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\t//find\n\t\t\t\tif(map.get(a) != null) System.out.println(map.get(a));\n\t\t\t\telse System.out.println(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t//delete\n\t\t\t\tif(map.get(a) != null) {\n\t\t\t\t\tcount -= map.get(a);\n\t\t\t\t\tmap.remove(map.get(a));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\t//dump\n\t\t\t\tint b = scan.nextInt();\n\t\t\t\tSortedMap<Integer, Integer> subM = map.subMap(a,true, b,true);\n\t\t\t\tfor(Integer x : subM.keySet()) {\n\t\t\t\t\tfor(int j=0; j<map.get(x); i++) {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0, index, count, output;\n\t\tList<Integer> a = new ArrayList<Integer>(1);\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\ta.add(x);\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tSystem.out.println(a.lastIndexOf(x) - a.indexOf(x) + 2);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tindex = a.indexOf(x);\n\t\t\t\t\t\t\tcount = a.lastIndexOf(x) - index;\n\t\t\t\t\t\t\tfor(; count >= 0; count--) {\n\t\t\t\t\t\t\t\ta.remove(index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tNavigableSet<Integer> subset = set.subSet(x, true, sc.nextInt(), true);\n//\t\t\t\t\tfor(Integer ir : subset) {\n//\t\t\t\t\t\tSystem.out.println(ir);\n//\t\t\t\t\t}\n\t\t\t\t\tfor(j = 0; j < subset.size() + 2; j++) {\n\t\t\t\t\t\toutput = subset.pollFirst();\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(a.contains(output)) {\n\t\t\t\t\t\t\tfor(int k = 0; k < a.lastIndexOf(x) - a.indexOf(x) + 1; k++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tSystem.out.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tSystem.out.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(size==0) {\n\t\t\tROOT=NEW;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode F=search(x);\n\t\treturn (F.v==x)? F.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x) {\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\t\tNOW=ROOT;\n\t\tinodrwalk(NOW,L,R);\n\t\tout.flush();\n\t}\n\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0;\n\t\tList<Integer> a = new ArrayList<Integer>(1);\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\ta.add(x);\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tSystem.out.println(a.lastIndexOf(x) - a.indexOf(x) + 2);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\twhile(a.contains(x)) {\n\t\t\t\t\t\t\ta.remove(a.indexOf(x));\n\t\t\t\t\t\t\tcounter--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tNavigableSet<Integer> subset = set.subSet(x, true, sc.nextInt(), true);\n\t\t\t\t\tfor(Integer output : subset) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(a.contains(output)) {\n\t\t\t\t\t\t\tfor(j = 0; j < a.lastIndexOf(output) - a.indexOf(output) + 1; j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tmap.compute(x, (key, old) -> old + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tSystem.out.println(map.get(x) + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tcounter -= map.remove(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tfor(Integer output : set.subSet(x, true, sc.nextInt(), true)) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(map.containsKey(output)) {\n\t\t\t\t\t\t\tfor(j = 0; j < map.get(output); j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tmap.compute(x, (key, old) -> old + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tSystem.out.println(map.get(x) + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t    counter--;\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tcounter -= map.remove(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tfor(Integer output : set.subSet(x, true, sc.nextInt(), true)) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(map.containsKey(output)) {\n\t\t\t\t\t\t\tfor(j = 0; j < map.get(output); j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t    int type = sc.nextInt();\n\t\t    int x = sc.nextInt();\n\t\t    if (type == 0) {\n\t\t        if (map.containsKey(x)) {\n\t\t            map.put(x, map.get(x) + 1);\n\t\t        } else {\n\t\t            map.put(x, 1);\n\t\t        }\n\t\t        count++;\n\t\t        sb.append(count).append(\"\\n\");\n\t\t    } else if (type == 1) {\n\t\t        if (map.containsKey(x)) {\n\t\t            sb.append(map.get(x));\n\t\t        } else {\n\t\t            sb.append(0);\n\t\t        }\n\t\t        sb.append(\"\\n\");\n\t\t    } else if (type == 2) {\n\t\t        if (map.containsKey(x)) {\n\t\t            count -= map.get(x);\n\t\t            map.remove(x);\n\t\t        }\n\t\t    } else {\n\t\t        int y = sc.nextInt();\n\t\t        Integer tmp = x - 1;\n\t\t        while ((tmp = map.higherKey(tmp)) != null && tmp <= y) {\n\t\t            for (int j = 0; j < map.get(tmp); j++) {\n\t\t                sb.append(tmp).append(\"\\n\");\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tout.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(fact==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\t\tfor(int i=L;i<=R;i++){\n\t\t\tBnode T=search(i);\n\t\t\tif(T.v==i){\n\t\t\t\tfor(int j=0;j<T.num;j++)out.println(i);\n\t\t\t}\n\t\t}\n\t\t/*NOW=ROOT;\n\t\tinodrwalk(NOW,L,R);*/\n\t\tout.flush();\n\t}\n\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tTreeMap<Integer,Integer> S = new TreeMap<>();\n\t\t\tint c = 0;\n\t\t\tint q = sc.nextInt();\n\t\t\tfor(int i = 0; i < q; i++) {\n\t\t\t\tint cmd = sc.nextInt();\n\t\t\t\tInteger x = sc.nextInt();\n\t\t\t\tif(cmd == 0) {\n\t\t\t\t\tInteger n = S.getOrDefault(x, 0);\n\t\t\t\t\tS.put(x, n+1);\n\t\t\t\t\tSystem.out.println(++c);\n\t\t\t\t}\n\t\t\t\telse if(cmd == 1){\n\t\t\t\t\tInteger n = S.getOrDefault(x, 0);\n\t\t\t\t\tSystem.out.println(n);\n\t\t\t\t}\n\t\t\t\telse if(cmd == 2) {\n\t\t\t\t\tInteger n = S.getOrDefault(x, 0);\n\t\t\t\t\tS.remove(x);\n\t\t\t\t\tc-=n;\n\t\t\t\t}\n\t\t\t\telse /* cmd == 3 */{\n\t\t\t\t\tint r = sc.nextInt();\n\t\t\t\t\tS.subMap(x,true, r, true).forEach((k,v)->{\n\t\t\t\t\t\tfor(int j = 0; j <v; j++) System.out.println(k);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0, index, count;\n\t\tList<Integer> a = new ArrayList<Integer>(1);\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\ta.add(x);\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tSystem.out.println(a.lastIndexOf(x) - a.indexOf(x) + 2);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tindex = a.indexOf(x);\n\t\t\t\t\t\t\tcount = a.lastIndexOf(x) - index;\n\t\t\t\t\t\t\tfor(; count >= 0; count--) {\n\t\t\t\t\t\t\t\ta.remove(index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tNavigableSet<Integer> subset = set.subSet(x, true, sc.nextInt(), true);\n\t\t\t\t\tfor(Integer output : subset) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(a.contains(output)) {\n\t\t\t\t\t\t\tfor(int k = 0; k < a.lastIndexOf(x) - a.indexOf(x) + 1; k++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tout.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(size==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\t\tfor(int i=L;i<=R;i++){\n\t\t\tBnode T=search(i);\n\t\t\tif(T.v==i){\n\t\t\t\tfor(int j=0;j<T.num;j++)out.println(i);\n\t\t\t}\n\t\t}\n\t\t/*NOW=ROOT;\n\t\tinodrwalk(NOW,L,R);*/\n\t\tout.flush();\n\t}\n\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0, index, count;\n\t\tList<Integer> a = new ArrayList<Integer>(1);\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\ta.add(x);\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tSystem.out.println(a.lastIndexOf(x) - a.indexOf(x) + 2);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\twhile(a.contains(x)) {\n\t\t\t\t\t\t\ta.remove(a.indexOf(x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tNavigableSet<Integer> subset = set.subSet(x, true, sc.nextInt(), true);\n\t\t\t\t\tfor(Integer output : subset) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(a.contains(output)) {\n\t\t\t\t\t\t\tfor(int k = 0; k < a.lastIndexOf(x) - a.indexOf(x) + 1; k++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tout.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n\nclass Bnode{\n    int v,num,hash1=-1,hash2=-1;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact,dumpL,dumpR;\n\tQueue<Integer> dumpList;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(fact==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\n\t\tdumpL=L; dumpR=R;\n\t\tdumpList=new ArrayDeque<>();\n\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\tif(NOW==END)break;\n\t\t\tif(NOW.v>R) NOW=NOW.l;\n\t\t\telse if(NOW.v<L)NOW=NOW.r;\n\t\t\telse break;\n\t\t}\n\t\t//inodrwalk(NOW);\n\t\t\n\t\tint key=L+R;\n\t\tStack<Bnode> stk=new Stack<>();\n\t\tstk.push(NOW);\n\t\twhile(!stk.isEmpty()){\n\t\t\tBnode N=stk.peek();\n\t\t\tif(N.l!=END && N.l.hash1!=key) {\n\t\t\t\tstk.add(N.l);\n\t\t\t\tN.l.hash1=key;\n\t\t\t}else {\n\t\t\t\tif((N.v>=L && N.v<=R) && N.hash2!=key) {\n\t\t\t\t\tfor(int i=0;i<N.num;i++)out.println(N.v);\n\t\t\t\t\tN.hash2=key;\n\t\t\t\t}\n\t\t\t\tif(N.r!=END && N.r.hash1!=key) {\n\t\t\t\t\tstk.add(N.r);\n\t\t\t\t\tN.r.hash1=key;\n\t\t\t\t}\n\t\t\t\telse stk.pop();\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\tout.flush();\n\t\tdumpList.clear();\n\t}\n\n\t/*private void inodrwalk(Bnode N) {\n\t\tif(N.l!=END)inodrwalk(N.l);\n\t\tif(N.v>=dumpL && N.v<=dumpR) {\n\t\t\tfor(int i=0;i<N.num;i++) dumpList.add(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r);\n\t}*/\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tout.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n\nclass Bnode{\n    int v,num,hash1=-1,hash2=-1;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact,dumpCall,dumpL,dumpR;\n\tQueue<Integer> dumpList;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t\tdumpCall=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(fact==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\n\t\tdumpL=L; dumpR=R;\n\t\t//dumpList=new ArrayDeque<>();\n\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\tif(NOW==END)break;\n\t\t\tif(NOW.v>R) NOW=NOW.l;\n\t\t\telse if(NOW.v<L)NOW=NOW.r;\n\t\t\telse break;\n\t\t}\n\t\t//inodrwalk(NOW);\n\t\t\n\t\tint key=++dumpCall;\n\t\tStack<Bnode> stk=new Stack<>();\n\t\tstk.push(NOW);\n\t\twhile(!stk.isEmpty()){\n\t\t\tBnode N=stk.peek();\n\t\t\tif(N.l!=END && N.l.hash1!=key) {\n\t\t\t\tstk.add(N.l);\n\t\t\t\tN.l.hash1=key;\n\t\t\t}else {\n\t\t\t\tif((N.v>=L && N.v<=R) && N.hash2!=key) {\n\t\t\t\t\tfor(int i=0;i<N.num;i++)out.println(N.v);\n\t\t\t\t\tN.hash2=key;\n\t\t\t\t}\n\t\t\t\tif(N.r!=END && N.r.hash1!=key) {\n\t\t\t\t\tstk.add(N.r);\n\t\t\t\t\tN.r.hash1=key;\n\t\t\t\t}\n\t\t\t\telse stk.pop();\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\tout.flush();\n\t\t//dumpList.clear();\n\t}\n\n\t/*private void inodrwalk(Bnode N) {\n\t\tif(N.l!=END)inodrwalk(N.l);\n\t\tif(N.v>=dumpL && N.v<=dumpR) {\n\t\t\tfor(int i=0;i<N.num;i++) dumpList.add(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r);\n\t}*/\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tmap.compute(x, (key, old) -> old + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(map.values());\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tSystem.out.println(map.get(x) + 1);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\tif(map.containsKey(x)) {\n\t\t\t\t\t\t\tcounter -= map.remove(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tfor(Integer output : set.subSet(x, true, sc.nextInt(), true)) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(map.containsKey(output)) {\n\t\t\t\t\t\t\tfor(j = 0; j < map.get(output); j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tout.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(fact==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\t\t/*for(int i=L;i<=R;i++){\n\t\t\tBnode T=search(i);\n\t\t\tif(T.v==i){\n\t\t\t\tfor(int j=0;j<T.num;j++)out.println(i);\n\t\t\t}\n\t\t}*/\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\tif(NOW==END)break;\n\t\t\tif(NOW.v>R) NOW=NOW.l;\n\t\t\telse if(NOW.v<L)NOW=NOW.r;\n\t\t\telse break;\n\t\t}\n\t\tinodrwalk(NOW,L,R);\n\t\tout.flush();\n\t}\n\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        Mymset mset=new Mymset();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            switch(odr) {\n            case 0:\n                System.out.println(mset.insert(Integer.parseInt(in.next())));\n                break;\n                 \n            case 1:\n                System.out.println(mset.find(Integer.parseInt(in.next())));\n                break;\n                 \n            case 2:\n                mset.removeOf(Integer.parseInt(in.next()));\n                break;\n                 \n            case 3:\n                mset.dump(Integer.parseInt(in.next()),Integer.parseInt(in.next()));\n                break;\n            }\n        }\n    }\n \n}\n \nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n \n \n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n \nclass Mymset{\n    Bnode root,dummy,NOW;\n    int size;\n    PrintWriter out=new PrintWriter(System.out);\n     \n    Mymset(){\n        dummy=new Bnode(-1,-1);\n        dummy.p=dummy; dummy.l=dummy; dummy.r=dummy;\n        init();\n        size=0;\n    }\n \n    void init() {\n        root=dummy;\n    }\n \n    int insert(int x) {\n        Bnode NEW=new Bnode(x,1);\n        NEW.l=dummy;NEW.r=dummy;\n        if(size==0) {\n            root=NEW;\n            root.p=dummy;\n        }\n        else {\n            //Bnode NOW=root;\n            NOW=root;\n            while(true) {\n                if(NOW.v==NEW.v) {\n                    NOW.num++;\n                    break;\n                }\n                else if(NEW.v>NOW.v) {\n                    if(NOW.r.v==-1) {\n                        NOW.r=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.r;\n                }\n                else {\n                    if(NOW.l.v==-1) {\n                        NOW.l=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.l;\n                }\n            }\n        }\n        size++;\n        return size;\n    }\n \n    void removeOf(int x){\n        find(x);\n        int n=NOW.num;\n        if(NOW.r.v==-1 && NOW.l.v==-1){\n        \t//System.out.println(\"delete mode 0\");\n            if(NOW.p.l==NOW)NOW.p.l=dummy;\n            else NOW.p.r=dummy;\n            \n            if(size-n==0)init();\n        }\n        else if((NOW.r.v!=-1 && NOW.l.v==-1) || (NOW.l.v!=-1 && NOW.r.v==-1)) {\n        \t//System.out.println(\"delete mode 1\");\n        \tif(NOW==root) {\n        \t\tif(root.l.v==-1)root=root.r;\n        \t\telse root=root.l;\n        \t}\n        \telse if(NOW.p.r==NOW) {\n                NOW.p.r=NOW.r;\n                NOW.r.p=NOW.p;\n            }\n            else {\n                NOW.p.l=NOW.l;\n                NOW.l.p=NOW.p;\n            }\n        }\n        else {\n        \t//System.out.println(\"delete mode 2\");\n            Bnode y=findNextNode(NOW.r);\n            NOW.v=y.v;\n            NOW.num=y.num;\n            if(y.r.v==-1 && y.l.v==-1){\n                if(y.p.l==y)y.p.l=dummy;\n                else y.p.r=dummy;\n            }\n            else if((y.r.v!=-1 && y.l.v==-1) || (y.l.v!=-1 && y.r.v==-1)) {\n                if(y.p.r==y) {\n                    y.p.r=y.r;\n                    y.r.p=y.p;\n                }\n                else {\n                    y.p.l=y.l;\n                    y.l.p=y.p;\n                }\n            }\n        }\n        size-=n;\n    }\n     \n     \n    Bnode findNextNode(Bnode node) {\n        if(node.l.v!=-1)return findNextNode(node.l);\n        else return node;\n    }\n \n    int find(int x){\n        NOW=root;\n        while(NOW.v!=-1) {\n \n            if(NOW.v==x)break;\n            else if(NOW.v>x)NOW=NOW.l;\n            else NOW=NOW.r;\n        }\n        return (NOW.num>0)?NOW.num : 0;\n    }\n \n    void dump(int L,int R) {\n        inwalk(root,L,R);\n        out.flush();\n    }\n \n    void inwalk(Bnode now,int L,int R) {\n        if(now.v>=L && now.v<=R) {\n            if(now.l.v!=-1)inwalk(now.l,L,R);\n            for(int i=0;i<now.num;i++)out.println(now.v);\n            if(now.r.v!=-1)inwalk(now.r,L,R);\n        }\n    }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            \n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tSystem.out.println(mset.size());\n            \tbreak;\n            \t\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tSystem.out.println(mset.find(x1));\n            \tbreak;\n            \t\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n            \t\n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size;\n\t\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\t\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(size==0) {\n\t\t\tROOT=NEW;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\t\n\tint size() {\n\t\treturn size;\n\t}\n\t\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\t\n\tint find(int x) {\n\t\tBnode F=search(x);\n\t\treturn (F.v==x)? F.num : 0;\n\t}\n\t\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x) {\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t}\n\t}\n\t\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\t\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(size==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\t\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\t\t\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\t\t\n\t\tchild.p=D.p;\n\t}\n\t\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\t\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\t\n\tvoid dump(int L,int R) {\n\t\tNOW=ROOT;\n\t\tinodrwalk(NOW,L,R);\n\t\tout.flush();\n\t}\n\t\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();  //キーに対応する値にはキーの要素数を入れる\n\t\tint mapSize = 0;\n\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tint query = sc.nextInt();\n\n\t\t\tswitch(query) {\n\t\t\tcase 0:\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(map.get(x) == null) {\n\t\t\t\t\tmap.put(x, 1);\n\t\t\t\t}\n\t\t\t\telse map.replace(x, map.get(x) + 1);\n\t\t\t\tmapSize++;\n\t\t\t\tSystem.out.println(mapSize);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(map.get(x) == null) \tSystem.out.println(0);\n\t\t\t\telse System.out.println(map.get(x));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(map.get(x) != null) {\n\t\t\t\t\tmapSize -= map.get(x);\n\t\t\t\t\tmap.remove(x);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\n\t\t\t\tfor(int n : map.subMap(l, true, r, true).keySet()) {\n\t\t\t\t\tfor(int j = 0; j < map.get(n); j++) {\n\t\t\t\t\t\tSystem.out.println(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            \n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tSystem.out.println(mset.size());\n            \tbreak;\n            \t\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tSystem.out.println(mset.find(x1));\n            \tbreak;\n            \t\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n            \t\n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size;\n\t\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\t\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(size==0) {\n\t\t\tROOT=NEW;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\t\n\tint size() {\n\t\treturn size;\n\t}\n\t\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\t\n\tint find(int x) {\n\t\tBnode F=search(x);\n\t\treturn (F.v==x)? F.num : 0;\n\t}\n\t\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x) {\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t}\n\t}\n\t\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\t\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(size==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\t\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\t\t\n\t\tif(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\t\t\n\t\tchild.p=D.p;\n\t}\n\t\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\t\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\t\n\tvoid dump(int L,int R) {\n\t\tNOW=ROOT;\n\t\tinodrwalk(NOW,L,R);\n\t\tout.flush();\n\t}\n\t\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            \n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tSystem.out.println(mset.size());\n            \tbreak;\n            \t\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tSystem.out.println(mset.find(x1));\n            \tbreak;\n            \t\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n            \t\n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact;\n\t\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\t\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(size==0) {\n\t\t\tROOT=NEW;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t\tfact++;\n\t}\n\t\n\tint size() {\n\t\treturn size;\n\t}\n\t\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\t\n\tint find(int x) {\n\t\tBnode F=search(x);\n\t\treturn (F.v==x)? F.num : 0;\n\t}\n\t\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x) {\n\t\t\tsize-=T.num;\n\t\t\tfact--;\n\t\t\tdelete(T);\n\t\t}\n\t}\n\t\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\t\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\t\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\t\t\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\t\t\n\t\tchild.p=D.p;\n\t}\n\t\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\t\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\t\n\tvoid dump(int L,int R) {\n\t\tNOW=ROOT;\n\t\tinodrwalk(NOW,L,R);\n\t\tout.flush();\n\t}\n\t\n\tprivate void inodrwalk(Bnode N,int L,int R) {\n\t\tif(N.l!=END)inodrwalk(N.l,L,R);\n\t\tif(N.v>=L && N.v<=R) {\n\t\t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r,L,R);\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        Mymset mset=new Mymset();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n            switch(odr) {\n            case 0:\n                System.out.println(mset.insert(Integer.parseInt(in.next())));\n                break;\n                 \n            case 1:\n                System.out.println(mset.find(Integer.parseInt(in.next())));\n                break;\n                 \n            case 2:\n                mset.removeOf(Integer.parseInt(in.next()));\n                break;\n                 \n            case 3:\n                mset.dump(Integer.parseInt(in.next()),Integer.parseInt(in.next()));\n                break;\n            }\n        }\n    }\n \n}\n \nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n \n \n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n \nclass Mymset{\n    Bnode root,dummy,NOW;\n    int size;\n    PrintWriter out=new PrintWriter(System.out);\n     \n    Mymset(){\n        dummy=new Bnode(-1,-1);\n        dummy.p=dummy; dummy.l=dummy; dummy.r=dummy;\n        init();\n        size=0;\n    }\n \n    void init() {\n        root=dummy;\n    }\n \n    int insert(int x) {\n        Bnode NEW=new Bnode(x,1);\n        NEW.l=dummy;NEW.r=dummy;\n        if(size==0) {\n            root=NEW;\n            root.p=dummy;\n        }\n        else {\n            //Bnode NOW=root;\n            NOW=root;\n            while(true) {\n                if(NOW.v==NEW.v) {\n                    NOW.num++;\n                    break;\n                }\n                else if(NEW.v>NOW.v) {\n                    if(NOW.r.v==-1) {\n                        NOW.r=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.r;\n                }\n                else {\n                    if(NOW.l.v==-1) {\n                        NOW.l=NEW;\n                        NEW.p=NOW;\n                        break;\n                    }\n                    else NOW=NOW.l;\n                }\n            }\n        }\n        size++;\n        return size;\n    }\n \n    void removeOf(int x){\n        find(x);\n        int n=NOW.num;\n        if(NOW.r.v==-1 && NOW.l.v==-1){\n            if(NOW.p.l==NOW)NOW.p.l=dummy;\n            else NOW.p.r=dummy;\n        }\n        else if(NOW.r.v!=-1 || NOW.l.v!=-1) {\n            if(NOW.p.r==NOW) {\n                NOW.p.r=NOW.r;\n                NOW.r.p=NOW.p;\n            }\n            else {\n                NOW.p.l=NOW.l;\n                NOW.l.p=NOW.p;\n            }\n        }\n        else {\n            Bnode y=findNextNode(NOW.r);\n            NOW.v=y.v;\n            NOW.num=y.num;\n            if(y.r.v==-1 && y.l.v==-1){\n                if(y.p.l==y)y.p.l=dummy;\n                else y.p.r=dummy;\n            }\n            else if(y.r.v!=-1 || y.l.v!=-1) {\n                if(y.p.r==y) {\n                    y.p.r=y.r;\n                    y.r.p=y.p;\n                }\n                else {\n                    y.p.l=y.l;\n                    y.l.p=y.p;\n                }\n            }\n        }\n        size-=n;\n    }\n     \n     \n    Bnode findNextNode(Bnode node) {\n        if(node.l.v!=-1)return findNextNode(node.l);\n        else return node;\n    }\n \n    int find(int x){\n        NOW=root;\n        while(NOW.v!=-1) {\n \n            if(NOW.v==x)break;\n            else if(NOW.v>x)NOW=NOW.l;\n            else NOW=NOW.r;\n        }\n        return (NOW.num>0)?NOW.num : 0;\n    }\n \n    void dump(int L,int R) {\n        inwalk(root,L,R);\n        out.flush();\n    }\n \n    void inwalk(Bnode now,int L,int R) {\n        if(now.v>=L && now.v<=R) {\n            if(now.l.v!=-1)inwalk(now.l,L,R);\n            for(int i=0;i<now.num;i++)out.println(now.v);\n            if(now.r.v!=-1)inwalk(now.r,L,R);\n        }\n    }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nclass Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint q = sc.nextInt();\n\t\t\tTreeMap<Integer, Integer> s = new TreeMap<>();\n\t\t\tint length = 0;\n\t\t\tfor(int i = 0; i < q; i++) {\n\t\t\t\tint query = sc.nextInt();\n\t\t\t\tint key;\n\t\t\t\tswitch(query) {\n\t\t\t\tcase 0:\n\t\t\t\t\tkey = sc.nextInt();\n\t\t\t\t\ts.put(key, s.getOrDefault(key, 0) + 1);\n\t\t\t\t\tlength++;\n\t\t\t\t\tSystem.out.println(length);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tSystem.out.println(s.getOrDefault(sc.nextInt(), 0));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tkey = sc.nextInt();\n\t\t\t\t\tlength -= s.getOrDefault(key, 0);\n\t\t\t\t\ts.remove(key);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tMap<Integer, Integer> sub = s.subMap(sc.nextInt(), true, sc.nextInt(), true);\n\t\t\t\t\tfor (Map.Entry<Integer, Integer> n : sub.entrySet()) {\n\t\t\t\t\t\tfor(int j = 0; j < n.getValue(); j++) {\n\t\t\t\t\t\t\tSystem.out.println(n.getKey());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tout.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n\nclass Bnode{\n    int v,num;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact,dumpL,dumpR;\n\tList<Bnode> dumpList;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(fact==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\n\t\tdumpL=L; dumpR=R;\n\t\tdumpList=new ArrayList<>();\n\t\t\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\tif(NOW==END)break;\n\t\t\tif(NOW.v>R) NOW=NOW.l;\n\t\t\telse if(NOW.v<L)NOW=NOW.r;\n\t\t\telse break;\n\t\t}\n\t\tinodrwalk(NOW);\n\t\t\n\t\tfor(int i=0;i<dumpList.size();i++){\n\t\t\tBnode D=dumpList.get(i);\n\t\t\tfor(int j=0;j<D.num;j++)out.println(D.v);\n\t\t}\n\t\tout.flush();\n\t\tdumpList.clear();\n\t}\n\n\tprivate void inodrwalk(Bnode N) {\n\t\tif(N.l!=END)inodrwalk(N.l);\n\t\tif(N.v>=dumpL && N.v<=dumpR) {\n\t\t\tdumpList.add(N);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r);\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, counter = 0;\n\t\tList<Integer> a = new ArrayList<Integer>(1);\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tif(!set.add(x)) {\n\t\t\t\t\t\ta.add(x);\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(set.size() + counter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tif(set.contains(x)) {\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tSystem.out.println(a.lastIndexOf(x) - a.indexOf(x) + 2);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tif(set.remove(x)) {\n\t\t\t\t\t\twhile(a.contains(x)) {\n\t\t\t\t\t\t\ta.remove(a.indexOf(x));\n\t\t\t\t\t\t\tcounter--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tNavigableSet<Integer> subset = set.subSet(x, true, sc.nextInt(), true);\n\t\t\t\t\tfor(Integer output : subset) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\tif(a.contains(x)) {\n\t\t\t\t\t\t\tfor(j = 0; j < a.lastIndexOf(x) - a.indexOf(x) + 1; j++) {\n\t\t\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main  {\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tint count = 0;\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint query = scan.nextInt();\n\t\t\tint a = scan.nextInt();\n\n\t\t\tswitch(query) {\n\n\t\t\tcase 0:\t//insert\n\t\t\t\tif(!map.containsKey(a)) map.put(a, 1);\n\t\t\t\telse map.put(a, map.get(a) + 1);\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\t//find\n\t\t\t\tif(map.get(a) != null) System.out.println(map.get(a));\n\t\t\t\telse System.out.println(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t//delete\n\t\t\t\tif(map.get(a) != null) {\n\t\t\t\t\tcount -= map.get(a);\n\t\t\t\t\tmap.remove(a);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\t//dump\n\t\t\t\tint b = scan.nextInt();\n\t\t\t\tMap<Integer, Integer> subM = map.subMap(a,true, b,true);\n\t\t\t\tfor(Integer x : subM.keySet()) {\n\t\t\t\t\tfor(int j=0; j<map.get(x); j++) {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main  {\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tint count = 0;\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint query = scan.nextInt();\n\t\t\tint a = scan.nextInt();\n\n\t\t\tswitch(query) {\n\n\t\t\tcase 0:\t//insert\n\t\t\t\tif(!map.containsKey(a)) map.put(a, 1);\n\t\t\t\telse map.put(a, map.get(a) + 1);\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\t//find\n\t\t\t\tif(map.get(a) != null) System.out.println(map.get(a));\n\t\t\t\telse System.out.println(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t//delete\n\t\t\t\tif(map.get(a) != null) {\n\t\t\t\t\tcount -= map.get(a);\n\t\t\t\t\tmap.remove(map.get(a));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\t//dump\n\t\t\t\tint b = scan.nextInt();\n\t\t\t\tMap<Integer, Integer> subM = map.subMap(a,true, b,true);\n\t\t\t\tfor(Integer x : subM.keySet()) {\n\t\t\t\t\tfor(int j=0; j<map.get(x); i++) {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "package ITP2;\n\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main  {\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tint count = 0;\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint query = scan.nextInt();\n\t\t\tint a = scan.nextInt();\n\n\t\t\tswitch(query) {\n\n\t\t\tcase 0:\t//insert\n\t\t\t\tif(!map.containsKey(a)) map.put(a, 1);\n\t\t\t\telse map.put(a, map.get(a) + 1);\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\t//find\n\t\t\t\tif(map.get(a) != null) System.out.println(map.get(a));\n\t\t\t\telse System.out.println(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t//delete\n\t\t\t\tif(map.get(a) != null) {\n\t\t\t\t\tcount -= map.get(a);\n\t\t\t\t\tmap.remove(map.get(a));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\t//dump\n\t\t\t\tint c = scan.nextInt();\n\t\t\t\tMap<Integer, Integer> subM = map.subMap(a,true, c,true);\n\t\t\t\tfor(Integer x : subM.keySet()) {\n\t\t\t\t\tfor(int j=0; j<map.get(x); i++) {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tSortedMap<Integer, Integer> S = new TreeMap<Integer, Integer>();\n\t\tint q = sc.nextInt();\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint com = sc.nextInt();\n\t\t\tif(com == 0){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(S.containsKey(x)){\n\t\t\t\t\tint num = S.get(x);\n\t\t\t\t\tS.put(x, num + 1);\n\t\t\t\t}else{\n\t\t\t\t\tS.put(x, 1);\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tSystem.out.println(cnt);\n\t\t\t}else if(com == 1){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(S.containsKey(x)) System.out.println(S.get(x));\n\t\t\t\telse System.out.println(0);\n\t\t\t}else if(com == 2){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(!S.containsKey(x)) continue;\n\t\t\t\tcnt -= S.get(x);\n\t\t\t\tS.remove(x);\n\t\t\t}else{\n\t\t\t\tint L = sc.nextInt();\n\t\t\t\tint R = sc.nextInt();\n\t\t\t\tSortedMap<Integer, Integer> SS = S.subMap(L, R + 1);\n\t\t\t\tfor(Integer num : SS.keySet()){\n\t\t\t\t\tfor(int j = 0; j < SS.get(num); j++) System.out.println(num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \tout.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tmset.dump(L, R);\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n\nclass Bnode{\n    int v,num,hash1=-1,hash2=-1;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact,dumpL,dumpR;\n\tQueue<Integer> dumpList;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(fact==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tvoid dump(int L,int R) {\n\n\t\tdumpL=L; dumpR=R;\n\t\tdumpList=new ArrayDeque<>();\n\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\tif(NOW==END)break;\n\t\t\tif(NOW.v>R) NOW=NOW.l;\n\t\t\telse if(NOW.v<L)NOW=NOW.r;\n\t\t\telse break;\n\t\t}\n\t\t//inodrwalk(NOW);\n\t\t\n\t\tint key=L+R%R;\n\t\tStack<Bnode> stk=new Stack<>();\n\t\tstk.push(NOW);\n\t\twhile(!stk.isEmpty()){\n\t\t\tBnode N=stk.peek();\n\t\t\tif(N.l!=END && N.l.hash1!=key) {\n\t\t\t\tstk.add(N.l);\n\t\t\t\tN.l.hash1=key;\n\t\t\t}else {\n\t\t\t\tif((N.v>=L && N.v<=R) && N.hash2!=key) {\n\t\t\t\t\tfor(int i=0;i<N.num;i++)out.println(N.v);\n\t\t\t\t\tN.hash2=key;\n\t\t\t\t}\n\t\t\t\tif(N.r!=END && N.r.hash1!=key) {\n\t\t\t\t\tstk.add(N.r);\n\t\t\t\t\tN.r.hash1=key;\n\t\t\t\t}\n\t\t\t\telse stk.pop();\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\tout.flush();\n\t\tdumpList.clear();\n\t}\n\n\t/*private void inodrwalk(Bnode N) {\n\t\tif(N.l!=END)inodrwalk(N.l);\n\t\tif(N.v>=dumpL && N.v<=dumpR) {\n\t\t\tfor(int i=0;i<N.num;i++) dumpList.add(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r);\n\t}*/\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        myMultiSet mset=new myMultiSet();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tmset.insert(x0);\n            \tout.println(mset.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(mset.find(x1));\n            \tbreak;\n\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tmset.deleteOf(x2);\n            \tbreak;\n\n            case 3:\n            \t//out.flush();\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tQueue<Bnode> list=mset.dump(L, R);\n            \twhile(!list.isEmpty()) {\n            \t\tBnode N=list.remove();\n            \t\tfor(int j=0;j<N.num;j++)out.println(N.v);\n            \t}\n            \tbreak;\n            }\n        }\n        out.flush();\n    }\n\n}\n\nclass Bnode{\n    int v,num,hash1=-1,hash2=-1;\n    Bnode p,l,r;\n\n    Bnode(int v,int num){\n        this.v=v;\n        this.num=num;\n    }\n}\n\nclass myMultiSet{\n\tPrintWriter out=new PrintWriter(System.out);\n\tBnode NOW,END,ROOT;\n\tint size,fact,dumpCall,dumpL,dumpR;\n\tQueue<Bnode> dumpList;\n\n\tmyMultiSet(){\n\t\tEND=new Bnode(-1,-1);\n\t\tEND.p=END;\n\t\tEND.l=END;\n\t\tEND.r=END;\n\t\tinit();\n\t\tsize=0;\n\t\tfact=0;\n\t\tdumpCall=0;\n\t}\n\tprivate void init() {\n\t\tROOT=END;\n\t}\n\n\tvoid insert(int x) {\n\t\tBnode NEW=new Bnode(x,1);\n\t\tNEW.l=END;\n\t\tNEW.r=END;\n\t\tif(fact==0) {\n\t\t\tROOT=NEW;\n\t\t\t//exist[x]=true;\n\t\t\tfact++;\n\t\t}\n\t\telse {\n\t\t\tNOW=ROOT;\n\t\t\twhile(true) {\n\t\t\t\tif(NEW.v==NOW.v) {\n\t\t\t\t\tNOW.num++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(NEW.v<NOW.v) {\n\t\t\t\t\tif(NOW.l==END) {\n\t\t\t\t\t\tNOW.l=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.l;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(NOW.r==END) {\n\t\t\t\t\t\tNOW.r=NEW;\n\t\t\t\t\t\tNEW.p=NOW;\n\t\t\t\t\t\tfact++;\n\t\t\t\t\t\t//exist[x]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse NOW=NOW.r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize++;\n\t}\n\n\tint size() {\n\t\treturn size;\n\t}\n\n\tprivate Bnode search(int x) {\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\t//System.out.println(\"SEARCHING:\"+NOW.v);\n\t\t\tif(x==NOW.v)break;\n\t\t\telse if((x<NOW.v && NOW.l.v==-1) || (x>NOW.v && NOW.r.v==-1))break;\n\t\t\telse if(x<NOW.v)NOW=NOW.l;\n\t\t\telse NOW=NOW.r;\n\t\t}\n\t\treturn NOW;\n\t}\n\n\tint find(int x) {\n\t\tBnode T=search(x);\n\t\treturn (T.v==x)?T.num : 0;\n\t}\n\n\tvoid deleteOf(int x) {\n\t\tBnode T=search(x);\n\t\t//System.out.println(\"x=\"+x+\"T.v=\"+T.v);\n\t\tif(T.v==x){\n\t\t\tsize-=T.num;\n\t\t\tdelete(T);\n\t\t\tfact--;\n\t\t}\n\t}\n\n\tprivate void delete(Bnode Del) {\n\t\tif(Del.l!=END && Del.r!=END) deleteHaveChilds(Del);\n\t\telse if(Del.l!=END || Del.r!=END) deleteHaveaChild(Del);\n\t\telse if(Del.l==END && Del.r==END) deleteNoChild(Del);\n\t\telse System.out.println(\"ERR\");\n\t}\n\n\tprivate void deleteNoChild(Bnode D) {\n\t\t//System.out.printf(\"D.v=%d D.p.v=%d\",D.v,D.p.v);\n\t\tif(fact==1)init();\n\t\telse if(D.p.l==D)D.p.l=END;\n\t\telse D.p.r=END;\n\t}\n\n\tprivate void deleteHaveaChild(Bnode D) {\n\t\tBnode child;\n\t\tif(D.l!=END)child=D.l;\n\t\telse child=D.r;\n\n\t\tif(D==ROOT)ROOT=child;\n\t\telse if(D.p.l==D)D.p.l=child;\n\t\telse D.p.r=child;\n\n\t\tchild.p=D.p;\n\t}\n\n\tprivate void deleteHaveChilds(Bnode D) {\n\t\tBnode Sub=findNextNodeToDelete(D.r);\n\t\tD.v=Sub.v;\n\t\tD.num=Sub.num;\n\t\tdelete(Sub);\n\t}\n\n\tprivate Bnode findNextNodeToDelete(Bnode N) {\n\t\tif(N.l!=END) return findNextNodeToDelete(N.l);\n\t\telse return N;\n\t}\n\n\tQueue<Bnode> dump(int L,int R) {\n\n\t\tdumpL=L; dumpR=R;\n\t\tdumpList=new ArrayDeque<>();\n\n\t\tNOW=ROOT;\n\t\twhile(true) {\n\t\t\tif(NOW==END)break;\n\t\t\tif(NOW.v>R) NOW=NOW.l;\n\t\t\telse if(NOW.v<L)NOW=NOW.r;\n\t\t\telse break;\n\t\t}\n\t\t//inodrwalk(NOW);\n\t\t\n\t\tint key=++dumpCall;\n\t\tStack<Bnode> stk=new Stack<>();\n\t\tstk.push(NOW);\n\t\twhile(!stk.isEmpty()){\n\t\t\tBnode N=stk.peek();\n\t\t\tif(N.l!=END && N.l.hash1!=key) {\n\t\t\t\tstk.add(N.l);\n\t\t\t\tN.l.hash1=key;\n\t\t\t}else {\n\t\t\t\tif((N.v>=L && N.v<=R) && N.hash2!=key) {\n\t\t\t\t\t//for(int i=0;i<N.num;i++)out.println(N.v);\n\t\t\t\t\tdumpList.add(N);\n\t\t\t\t\t//out.flush();\n\t\t\t\t\tN.hash2=key;\n\t\t\t\t}\n\t\t\t\tif(N.r!=END && N.r.hash1!=key) {\n\t\t\t\t\tstk.add(N.r);\n\t\t\t\t\tN.r.hash1=key;\n\t\t\t\t}\n\t\t\t\telse stk.pop();\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\t//out.flush();\n\t\treturn dumpList;\n\t}\n\n\t/*private void inodrwalk(Bnode N) {\n\t\tif(N.l!=END)inodrwalk(N.l);\n\t\tif(N.v>=dumpL && N.v<=dumpR) {\n\t\t\tfor(int i=0;i<N.num;i++) dumpList.add(N.v);\n\t\t}\n\t\tif(N.r!=END)inodrwalk(N.r);\n\t}*/\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        var S = new MultiSet<int>();\n        int Q = cin.nextint;\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S.GetValue(cin.nextint));\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else if (mode == 3)\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint);\n            }\n        }\n    }\n\n}\n\nclass MultiSet<T> where T : IComparable<T>\n{\n    SortedSet<T> set;\n    Dictionary<T, int> map;\n    public MultiSet(IComparer<T> comparer, IEqualityComparer<T> equalityComparer)\n    {\n        set = new SortedSet<T>(comparer);\n        map = new Dictionary<T, int>(equalityComparer);\n    }\n    public MultiSet() : this(Comparer<T>.Default, EqualityComparer<T>.Default) { }\n\n    public void Add(T key)\n    {\n        if (!map.ContainsKey(key))\n        {\n            set.Add(key);\n            map[key] = 1;\n        }\n        else\n        {\n            map[key]++;\n        }\n        Count++;\n    }\n    public int GetValue(T key)\n    {\n        if(!map.ContainsKey(key))\n        {\n            return 0;\n        }\n        else\n        {\n            return map[key];\n        }\n    }\n    public void Remove(T key)\n    {\n        if (map.ContainsKey(key))\n        {\n            Count -= map[key];\n            map.Remove(key);\n            set.Remove(key);\n        }\n    }\n    public void GetViewBetween(T lowerKey, T upperKey)\n    {\n        foreach (var key in set.GetViewBetween(lowerKey, upperKey))\n        {\n            for (int i = 0; i < map[key]; i++)\n            {\n                WriteLine(key);\n            }\n        }\n    }\n    public int Count { get; private set; }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ITP2_7_D\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = ReadInt();\n            SortedList<int,int> sd = new SortedList<int, int>();\n\n            int count = 0;\n            for (int i = 0 ; i < n ; i++)\n            {\n                int[] line = ReadIntAr();\n                switch (line[0])\n                {\n                    case 0:\n                        if (sd.ContainsKey(line[1]))\n                        {\n                            sd[line[1]]++;\n                        }\n                        else\n                        {\n                            sd.Add(line[1], 1);\n                        }\n                        count++;\n                        Console.WriteLine(count);\n                        break;\n                    case 1:\n                        if (sd.ContainsKey(line[1]))\n                        {\n                            Console.WriteLine(sd[line[1]]);\n                        }\n                        else Console.WriteLine(0);\n                        break;\n                    case 2:\n                        if (sd.ContainsKey(line[1]))\n                        {\n                            count -= sd[line[1]];\n                            sd.Remove(line[1]);\n                        }\n                        break;\n                    case 3:\n\n                        for (int k = Math.Max(sd.IndexOfKey(line[1]),0) ; k < sd.Keys.Count() ; k++)\n                        {\n                            if(sd.Keys[k] <= line[2] && line[1] <= sd.Keys[k])\n                            {\n                                for (int l = 0 ; l < sd.Values[k] ; l++)\n                                {\n                                    Console.WriteLine(sd.Keys[k]);\n                                }\n                            }\n                            if (sd.Keys[k] > line[2])\n                            {\n                                break;\n                            }\n                        }\n                        break;\n                }\n\n            }\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n        static string WriteAr(int[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n        static string WriteAr(double[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n        static string WriteAr(long[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>(true);\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint);\n            }\n        }\n\n    }\n\n}\n\nclass MultiSet<T> : SortedList<T, int> where T : IComparable<T>\n{\n    readonly bool is_multi;\n    public MultiSet(bool is_multi = false)\n    {\n        this.is_multi = is_multi;\n    }\n    public void Add(T item)\n    {\n        if (is_multi || this[item] == 0)\n        {\n            Count++;\n            this[item]++;\n        }\n    }\n    public new void Remove(T item)\n    {\n        int size;\n        if (TryGetValue(item, out size))\n        {\n            Count -= size;\n            base.Remove(item);\n        }\n    }\n    public void GetViewBetween(T lowerValue, T upperValue)\n    {\n        var s = Keys.lower_bound(lowerValue);\n        var t = Keys.upper_bound(upperValue);\n        for (int i = s; i < t; i++)\n        {\n            for (int j = 0; j < Values[i]; j++)\n            {\n                WriteLine(Keys[i]);\n            }\n        }\n    }\n    public new int this[T key]\n    {\n        get\n        {\n            int value;\n            return TryGetValue(key, out value) ? value : 0;\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n    public new int Count { get; private set; }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>(true);\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint);\n            }\n        }\n        \n    }\n\n}\n\nclass MultiSet<T> : SortedList<T, int> where T : IComparable<T>\n{\n    readonly bool is_multi;\n    public MultiSet(bool is_multi = false)\n    {\n        this.is_multi = is_multi;\n    }\n    public void Add(T item)\n    {\n        if (is_multi || this[item] == 0)\n        {\n            Count++;\n            this[item]++;\n        }\n    }\n    public new void Remove(T item)\n    {\n        Count -= this[item];\n        base.Remove(item);\n    }\n    public void GetViewBetween(T lowerValue, T upperValue)\n    {\n        var s = Keys.lower_bound(lowerValue);\n        var t = Keys.upper_bound(upperValue);\n        for (int i = s; i < t; i++)\n        {\n            for (int j = 0; j < Values[i]; j++)\n            {\n                WriteLine(Keys[i]);\n            }\n        }\n    }\n    public new int this[T key]\n    {\n        get\n        {\n            int value;\n            return TryGetValue(key, out value) ? value : base[key] = default(int);\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n    public new int Count { get; private set; }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class SB_BinarySearchTree<T> where T : IComparable\n{\n    public class Node\n    {\n        public T Value;\n        public Node LChild;\n        public Node RChild;\n        public int Count;\n\n        public Node(T v)\n        {\n            Value = v;\n            Count = 1;\n        }\n    }\n\n    static Random _rnd = new Random();\n\n    public static int Count(Node t)\n    {\n        return t == null ? 0 : t.Count;\n    }\n\n    static Node Update(Node t)\n    {\n        t.Count = Count(t.LChild) + Count(t.RChild) + 1;\n        return t;\n    }\n\n    public static Node Merge(Node l, Node r)\n    {\n        if (l == null || r == null) return l == null ? r : l;\n\n        if (Count(l) / (double)(Count(l) + Count(r)) > _rnd.NextDouble())\n        {\n            l.RChild = Merge(l.RChild, r);\n            return Update(l);\n        }\n        else\n        {\n            r.LChild = Merge(l, r.LChild);\n            return Update(r);\n        }\n    }\n\n    public static Tuple<Node, Node> Split(Node t, int k)\n    {\n        if (t == null) return new Tuple<Node, Node>(null, null);\n        if (k <= Count(t.LChild))\n        {\n            var s = Split(t.LChild, k);\n            t.LChild = s.Item2;\n            return new Tuple<Node, Node>(s.Item1, Update(t));\n        }\n        else\n        {\n            var s = Split(t.RChild, k - Count(t.LChild) - 1);\n            t.RChild = s.Item1;\n            return new Tuple<Node, Node>(Update(t), s.Item2);\n        }\n    }\n\n    public static Node Remove(Node t, T v)\n    {\n        if (Find(t, v) == null) return t;\n        return RemoveAt(t, LowerBound(t, v));\n    }\n\n    public static Node RemoveAt(Node t, int k)\n    {\n        var s = Split(t, k);\n        var s2 = Split(s.Item2, 1);\n        return Merge(s.Item1, s2.Item2);\n    }\n\n    public static bool Contains(Node t, T v)\n    {\n        return Find(t, v) != null;\n    }\n\n    public static Node Find(Node t, T v)\n    {\n        while (t != null)\n        {\n            var cmp = t.Value.CompareTo(v);\n            if (cmp > 0) t = t.LChild;\n            else if (cmp < 0) t = t.RChild;\n            else break;\n        }\n        return t;\n    }\n\n    public static Node FindByIndex(Node t, int idx)\n    {\n        if (t == null) return null;\n\n        var currentIdx = Count(t) - Count(t.RChild) - 1;\n        while (t != null)\n        {\n            if (currentIdx == idx) return t;\n            if (currentIdx > idx)\n            {\n                t = t.LChild;\n                currentIdx -= (Count(t == null ? null : t.RChild) + 1);\n            }\n            else\n            {\n                t = t.RChild;\n                currentIdx += (Count(t == null ? null : t.LChild) + 1);\n            }\n        }\n\n        return null;\n    }\n\n    public static int UpperBound(Node t, T v)\n    {\n        var torg = t;\n        if (t == null) return -1;\n\n        var ret = int.MaxValue;\n        var idx = Count(t) - Count(t.RChild) - 1;\n        while (t != null)\n        {\n            var cmp = t.Value.CompareTo(v);\n\n            if (cmp > 0)\n            {\n                ret = Min(ret, idx);\n                t = t.LChild;\n                idx -= (Count(t == null ? null : t.RChild) + 1);\n            }\n            else if (cmp <= 0)\n            {\n                t = t.RChild;\n                idx += (Count(t == null ? null : t.LChild) + 1);\n            }\n        }\n        return ret == int.MaxValue ? Count(torg) : ret;\n    }\n\n    public static int LowerBound(Node t, T v)\n    {\n        var torg = t;\n        if (t == null) return -1;\n\n        var idx = Count(t) - Count(t.RChild) - 1;\n        var ret = int.MaxValue;\n        while (t != null)\n        {\n            var cmp = t.Value.CompareTo(v);\n            if (cmp >= 0)\n            {\n                if (cmp == 0) ret = Min(ret, idx);\n                t = t.LChild;\n                if (t == null) ret = Min(ret, idx);\n                idx -= t == null ? 0 : (Count(t.RChild) + 1);\n            }\n            else if (cmp < 0)\n            {\n                t = t.RChild;\n                idx += (Count(t == null ? null : t.LChild) + 1);\n                if (t == null) return idx;\n            }\n        }\n        return ret == int.MaxValue ? Count(torg) : ret;\n    }\n\n    public static Node Insert(Node t, T v)\n    {\n        var ub = LowerBound(t, v);\n        return InsertByIdx(t, ub, v);\n    }\n\n    static Node InsertByIdx(Node t, int k, T v)\n    {\n        var s = Split(t, k);\n        return Merge(Merge(s.Item1, new Node(v)), s.Item2);\n    }\n\n    public static IEnumerable<T> Enumerate(Node t)\n    {\n        var ret = new List<T>();\n        Enumerate(t, ret);\n        return ret;\n    }\n\n    static void Enumerate(Node t, List<T> ret)\n    {\n        if (t == null) return;\n        Enumerate(t.LChild, ret);\n        ret.Add(t.Value);\n        Enumerate(t.RChild, ret);\n    }\n}\n\npublic class Set<T> where T : IComparable\n{\n    protected SB_BinarySearchTree<T>.Node _root;\n\n    public T this[int idx] { get { return ElementAt(idx); } }\n\n    public int Count()\n    {\n        return SB_BinarySearchTree<T>.Count(_root);\n    }\n\n    public virtual void Insert(T v)\n    {\n        if (_root == null) _root = new SB_BinarySearchTree<T>.Node(v);\n        else\n        {\n            if (SB_BinarySearchTree<T>.Find(_root, v) != null) return;\n            _root = SB_BinarySearchTree<T>.Insert(_root, v);\n        }\n    }\n\n    public void Clear()\n    {\n        _root = null;\n    }\n\n    public void Remove(T v)\n    {\n        _root = SB_BinarySearchTree<T>.Remove(_root, v);\n    }\n\n    public bool Contains(T v)\n    {\n        return SB_BinarySearchTree<T>.Contains(_root, v);\n    }\n\n    public T ElementAt(int k)\n    {\n        var node = SB_BinarySearchTree<T>.FindByIndex(_root, k);\n        if (node == null) throw new IndexOutOfRangeException();\n        return node.Value;\n    }\n\n    public int Count(T v)\n    {\n        return SB_BinarySearchTree<T>.UpperBound(_root, v) - SB_BinarySearchTree<T>.LowerBound(_root, v);\n    }\n\n    public int LowerBound(T v)\n    {\n        return SB_BinarySearchTree<T>.LowerBound(_root, v);\n    }\n\n    public int UpperBound(T v)\n    {\n        return SB_BinarySearchTree<T>.UpperBound(_root, v);\n    }\n\n    public Tuple<int, int> EqualRange(T v)\n    {\n        if (!Contains(v)) return new Tuple<int, int>(-1, -1);\n        return new Tuple<int, int>(SB_BinarySearchTree<T>.LowerBound(_root, v), SB_BinarySearchTree<T>.UpperBound(_root, v) - 1);\n    }\n\n    public List<T> ToList()\n    {\n        return new List<T>(SB_BinarySearchTree<T>.Enumerate(_root));\n    }\n}\n\npublic class MultiSet<T> : Set<T> where T : IComparable\n{\n    public override void Insert(T v)\n    {\n        if (_root == null) _root = new SB_BinarySearchTree<T>.Node(v);\n        else _root = SB_BinarySearchTree<T>.Insert(_root, v);\n    }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        var q = int.Parse(Console.ReadLine().Trim());\n        getAns(q);\n    }\n    static void getAns(int q)\n    {\n        var sb = new StringBuilder();\n        var ms = new MultiSet<int>();\n        var d = new Dictionary<int, int>();\n        for (int i = 0; i < q; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            if (line[0] == \"0\")\n            {\n                var x = int.Parse(line[1]);\n                ms.Insert(x);\n                if (d.ContainsKey(x)) d[x]++;\n                else d[x] = 1;\n                sb.Append(ms.Count().ToString() + \"\\n\");\n            }\n            else if (line[0] == \"1\")\n            {\n                var x = int.Parse(line[1]);\n                if (d.ContainsKey(x)) sb.Append(d[x].ToString() + \"\\n\");\n                else sb.Append(\"0\\n\");\n            }\n            else if (line[0] == \"2\")\n            {\n                var x = int.Parse(line[1]);\n                if (d.ContainsKey(x))\n                {\n                    for (int j = 0; j < d[x]; j++) ms.Remove(x);\n                    d.Remove(x);\n                }\n            }\n            else\n            {\n                var L = int.Parse(line[1]);\n                var r = int.Parse(line[2]);\n                var s = ms.LowerBound(L);\n                var e = ms.UpperBound(r) - 1;\n                for (int j = s; j <= e; j++) sb.Append(ms.ElementAt(j).ToString() + \"\\n\");\n            }\n        }\n        Console.Write(sb);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                var v = S.GetViewBetween(cin.nextint, cin.nextint);\n                if (v.Any()) v.join(\"\\n\");\n            }\n        }\n\n    }\n\n}\n\nclass MultiSet<T> : Map<T, int> where T : IComparable<T>\n{\n    public void Add(T item)\n    {\n        Count++;\n        this[item]++;\n    }\n    public new void Remove(T item)\n    {\n        Count -= this[item];\n        base.Remove(item);\n    }\n    public IEnumerable<T> GetViewBetween(T lowerValue, T upperValue)\n    {\n        return this.SkipWhile(i => i.Key.CompareTo(lowerValue) < 0).TakeWhile(i => i.Key.CompareTo(upperValue) <= 0).SelectMany(i => Enumerable.Repeat(i.Key, i.Value));\n    }\n    public new int Count { get; private set; }\n}\n\nclass Map<TKey, TValue> : SortedDictionary<TKey, TValue>\n{\n    public new TValue this[TKey key]\n    {\n        get\n        {\n            if (!ContainsKey(key))\n            {\n                base[key] = default(TValue);\n            }\n            return base[key];\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                var v = S.GetViewBetween(cin.nextint, cin.nextint);\n                if (v.Any()) v.join(\"\\n\");\n            }\n        }\n\n    }\n\n}\n\nclass MultiSet<T> : Map<T, int> where T : IComparable<T>\n{\n    public void Add(T item)\n    {\n        Count++;\n        this[item]++;\n    }\n    public new void Remove(T item)\n    {\n        Count -= this[item];\n        base.Remove(item);\n    }\n    public IEnumerable<T> GetViewBetween(T lowerValue, T upperValue)\n    {\n        return this.SkipWhile(i => i.Key.CompareTo(lowerValue) < 0).TakeWhile(i => i.Key.CompareTo(upperValue) <= 0).SelectMany(i => Enumerable.Repeat(i.Key, i.Value));\n    }\n    public new int Count { get; private set; }\n}\n\nclass Map<TKey, TValue> : SortedDictionary<TKey, TValue>\n{\n    public new TValue this[TKey key]\n    {\n        get\n        {\n            TValue value;\n            return TryGetValue(key, out value) ? value : base[key] = default(TValue);\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint);\n            }\n        }\n\n    }\n\n}\n\nclass MultiSet<T> : Map<T, int> where T : IComparable<T>\n{\n    public void Add(T item)\n    {\n        Count++;\n        this[item]++;\n    }\n    public new void Remove(T item)\n    {\n        Count -= this[item];\n        base.Remove(item);\n    }\n    public void GetViewBetween(T lowerValue, T upperValue)\n    {\n        foreach (var v in this)\n        {\n            if (upperValue.CompareTo(v.Key) < 0) break;\n            if (v.Key.CompareTo(lowerValue) < 0) continue;\n            for (int i = 0; i < v.Value; i++)\n            {\n                WriteLine(v.Key);\n            }\n        }\n    }\n    public new int Count { get; private set; }\n}\n\nclass Map<TKey, TValue> : SortedDictionary<TKey, TValue>\n{\n    public new TValue this[TKey key]\n    {\n        get\n        {\n            TValue value;\n            return TryGetValue(key, out value) ? value : base[key] = default(TValue);\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var d = new Dictionary<int, int>();\n        var count = 0;\n        var q = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < q; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                count++;\n                if (d.ContainsKey(c2))\n                {\n                    d[c2]++;\n                    Console.WriteLine(count);\n                }\n                else\n                {\n                    d[c2] = 1;\n                    Console.WriteLine(count);\n                }\n            }\n            else if (c == 1) Console.WriteLine(d.ContainsKey(c2) ? d[c2] : 0);\n            else if (c == 2)\n            {\n                if (d.ContainsKey(c2))\n                {\n                    count -= d[c2];\n                    d.Remove(c2);\n                }\n            }\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                printLR(d, c2, c3);\n            }\n        }\n    }\n    public static void printLR(Dictionary<int, int> d, int L, int r)\n    {\n        foreach (var x in d.Where(y => y.Key >= L && y.Key <= r).OrderBy(y => y.Key))\n        {\n            for (int i = 0; i < x.Value; i++)\n                Console.WriteLine(x.Key);\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                var v = S.GetViewBetween(cin.nextint, cin.nextint);\n                if (v.Any()) v.join(\"\\n\");\n            }\n        }\n\n    }\n\n}\n\nclass MultiSet<T> : Map<T, int> where T : IComparable<T>\n{\n    public void Add(T item)\n    {\n        Count++;\n        this[item]++;\n    }\n    public new void Remove(T item)\n    {\n        Count -= this[item];\n        base.Remove(item);\n    }\n    public IEnumerable<T> GetViewBetween(T lowerValue, T upperValue)\n    {\n        return this.SkipWhile(i => i.Key.CompareTo(lowerValue) < 0).TakeWhile(i => i.Key.CompareTo(upperValue) <= 0).SelectMany(i => Enumerable.Repeat(i.Key, i.Value));\n    }\n    public new int Count { get; private set; }\n}\n\nclass Map<TKey, TValue> : SortedDictionary<TKey, TValue>\n{\n    public new TValue this[TKey key]\n    {\n        get\n        {\n            return TryGetValue(key, out TValue value) ? value : base[key] = default(TValue);\n            //if (!ContainsKey(key))\n            //{\n            //    base[key] = default(TValue);\n            //}\n            //return base[key];\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"math\"\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\n\t\"strconv\"\n\t\"strings\"\n)\n\n//  長い入力を読む\nfunc ReadLongLines(times int) ([]string, error) {\n\tresult := make([]string, times)\n\treader := bufio.NewReader(os.Stdin)\n\tbuffer := bytes.NewBuffer(make([]byte, 0))\n\treadBytes := int64(2)\n\tfor i := 0; i < times; i++ {\n\t\tfor {\n\t\t\treadBuf, isPrefix, err := reader.ReadLine()\n\t\t\t// fmt.Printf(\"Reader.Read: %d\\n\", len(readBuf))\n\t\t\treadBytes += int64(len(readBuf) + 1)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tfmt.Println(\"EOF\")\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\treturn result, err\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err = buffer.Write(readBuf)\n\t\t\tif err != nil {\n\t\t\t\treturn result, err\n\t\t\t}\n\t\t\t// end of line\n\t\t\tif !isPrefix {\n\t\t\t\tresult[i] = buffer.String()\n\t\t\t\tbuffer.Reset()\n\t\t\t\t// reader = bufio.NewReader(os.Stdin)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// 先読みしてしまうようなので、戻しておく\n\tos.Stdin.Seek(-int64(reader.Buffered()), os.SEEK_CUR)\n\treturn result, nil\n}\n\n// 出力 for 競プロ\ntype Console struct {\n\twriter *bufio.Writer\n}\n\nfunc NewConsole() Console {\n\treturn Console{bufio.NewWriter(os.Stdout)}\n}\nfunc (this *Console) Printf(format string, a ...interface{}) {\n\tfmt.Fprintf(this.writer, format, a...)\n}\nfunc (this *Console) Println(s string) {\n\tfmt.Fprintln(this.writer, s)\n}\nfunc (this *Console) Close() {\n\tthis.Flush()\n}\nfunc (this Console) Flush() {\n\tthis.writer.Flush()\n}\n\nfunc PrintList(list []int) {\n\tcon := NewConsole()\n\tdefer con.Flush()\n\tfor i := range list {\n\t\tif i == 0 {\n\t\t\tcon.Printf(\"%d\", list[i])\n\t\t} else {\n\t\t\tcon.Printf(\" %d\", list[i])\n\t\t}\n\t}\n\tcon.Println(\"\")\n}\n\nconst MAX int = 1000000001\nconst CAP int = 512\n\nfunc GetLank(i int) int {\n\treturn int(math.Floor(float64(i) / float64(CAP)))\n}\n\ntype MultiSet struct {\n\tlist   map[int]int //[val] => count\n\tcounts []int\n\ttotal int\n}\n\nfunc NewSet() MultiSet {\n\tlist := make(map[int]int)\n\tnumLank := (MAX / CAP) + 1\n\tcounts := make([]int, numLank)\n\treturn MultiSet{list, counts, 0}\n}\n\nfunc (this *MultiSet) Exists(i int) bool {\n\t_, ok := this.list[i]\n\treturn ok\n}\n\nfunc (this *MultiSet) Add(i int) int {\n\tthis.list[i]++\n\tthis.counts[GetLank(i)]++\n\tthis.total++\n\treturn this.total\n}\n\nfunc (this *MultiSet) Remove(i int) {\n\tif this.Exists(i) {\n\t\tnum := this.list[i]\n\t\tthis.list[i] = 0\n\t\tthis.counts[GetLank(i)] -= num\n\t\tthis.total -= num\n\t}\n}\n\nfunc (this *MultiSet) Find(i int) int {\n\tif this.Exists(i) {\n\t\treturn this.list[i]\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc (this *MultiSet) Dump(left, right int) []int {\n\tcount := 0\n\tfound := 0\n\tresult := make([]int, 8)\n\tfor i := left; i <= right; i++ {\n\t\t// boundary\n\t\tif i % CAP == 0 {\n\t\t\tfound = 0\n\t\t}\n\t\t// not exists in current lank\n\t\tlank := GetLank(i)\n\t\tif this.counts[lank] == 0 {\n\t\t\ti = (lank + 1) * CAP - 1\n\t\t\tfound = 0\n\t\t\tcontinue\n\t\t}\n\t\tif this.Exists(i) {\n\t\t\tfor j := 0; j < this.list[i]; j++ {\n\t\t\t\tif len(result) <= count {\n\t\t\t\t\tresult = append(result, i)\n\t\t\t\t} else {\n\t\t\t\t\tresult[count] = i\n\t\t\t\t}\n\t\t\t\tfound++\n\t\t\t\tcount++\n\t\t\t}\n\t\t\t// done in current lank\n\t\t\tif found == this.counts[lank] {\n\t\t\t\ti = (lank + 1) * CAP - 1\n\t\t\t}\n\t\t}\n\t}\n\t// _ = sort.Slice\n\tresult = result[:count]\n\tsort.Slice(result, func(lhs, rhs int) bool {\n\t\treturn result[lhs] < result[rhs]\n\t})\n\treturn result\n}\n\nfunc main() {\n\tcon := NewConsole()\n\tdefer con.Flush()\n\n\t// create list\n\tvar n int\n\tfmt.Scanf(\"%d\", &n)\n\n\tset := NewSet()\n\n\tlines, _ := ReadLongLines(n)\n\n\tfor i := range lines {\n\t\targs := strings.Split(lines[i], \" \")\n\t\tcommand, _ := strconv.Atoi(args[0])\n\t\tx, _ := strconv.Atoi(args[1])\n\n\t\tswitch command {\n\t\tcase 0: //insert\n\t\t\tl := set.Add(x)\n\t\t\tcon.Printf(\"%d\\n\", l)\n\t\tcase 1: //find\n\t\t\tcon.Printf(\"%d\\n\", set.Find(x))\n\t\tcase 2: // delete\n\t\t\tset.Remove(x)\n\t\tcase 3: // dump\n\t\t\tl, _ := strconv.Atoi(args[1])\n\t\t\tr, _ := strconv.Atoi(args[2])\n\t\t\tresult := set.Dump(l, r)\n\t\t\tfor i := range result {\n\t\t\t\tcon.Printf(\"%d\\n\", result[i])\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\n// NewTreapNode is a constructor of TreapNode\nfunc NewTreapNode(key int, priority int) *TreapNode {\n\ttp := TreapNode{}\n\ttp.key = key\n\ttp.priority = priority\n\treturn &tp\n}\n\n// TreapNode contains integer\ntype TreapNode struct {\n\tkey      int\n\tpriority int\n\tleft     *TreapNode\n\tright    *TreapNode\n}\n\nfunc (node *TreapNode) setLeftChild(key int, priority int) {\n\tchild := NewTreapNode(key, priority)\n\tnode.left = child\n}\n\nfunc (node *TreapNode) setRightChild(key int, priority int) {\n\tchild := NewTreapNode(key, priority)\n\tnode.right = child\n}\n\n// NewTreap is a constructor of Treap\nfunc NewTreap() *Treap {\n\ttreap := Treap{}\n\treturn &treap\n}\n\n// Treap described at\n//  https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_D\ntype Treap struct {\n\troot *TreapNode\n}\n\nfunc (t *Treap) insert(key int, priority int) {\n\tif t.root == nil {\n\t\tnode := NewTreapNode(key, priority)\n\t\tt.root = node\n\t} else {\n\t\tt.root = t.insertLoop(t.root, key, priority)\n\t}\n}\n\nfunc (t *Treap) insertLoop(current *TreapNode, key int, priority int) *TreapNode {\n\tif current == nil {\n\t\tnewNode := NewTreapNode(key, priority)\n\t\treturn newNode\n\t}\n\n\tif key < current.key {\n\t\tcurrent.left = t.insertLoop(current.left, key, priority)\n\t\tif current.priority < current.left.priority {\n\t\t\tcurrent = t.rightRotate(current)\n\t\t}\n\t} else {\n\t\tcurrent.right = t.insertLoop(current.right, key, priority)\n\t\tif current.priority < current.right.priority {\n\t\t\tcurrent = t.leftRotate(current)\n\t\t}\n\t}\n\n\treturn current\n}\n\nfunc (t *Treap) leftRotate(x *TreapNode) *TreapNode {\n\ty := x.right\n\tx.right = y.left\n\ty.left = x\n\treturn y\n}\n\nfunc (t *Treap) rightRotate(y *TreapNode) *TreapNode {\n\tx := y.left\n\ty.left = x.right\n\tx.right = y\n\treturn x\n}\n\nfunc (t *Treap) find(key int) int {\n\treturn t.findLoop(t.root, key)\n}\n\nfunc (t *Treap) findLoop(current *TreapNode, key int) int {\n\tif current == nil {\n\t\treturn 0\n\t}\n\n\tnFitted := 0\n\tif key <= current.key {\n\t\tnFitted += t.findLoop(current.left, key)\n\t}\n\tif current.key == key {\n\t\tnFitted++\n\t}\n\tif key >= current.key {\n\t\tnFitted += t.findLoop(current.right, key)\n\t}\n\n\treturn nFitted\n}\n\nfunc (t *Treap) delete(key int) {\n\tt.root = t.deleteLoop(t.root, key)\n}\n\nfunc (t *Treap) deleteLoop(current *TreapNode, key int) *TreapNode {\n\tif current == nil {\n\t\treturn nil\n\t}\n\tif key <= current.key {\n\t\tcurrent.left = t.deleteLoop(current.left, key)\n\t} else if key >= current.key {\n\t\tcurrent.right = t.deleteLoop(current.right, key)\n\t}\n\tif current.key == key {\n\t\tcurrent = t.deleteNode(current, key)\n\t}\n\treturn current\n}\n\nfunc (t *Treap) deleteNode(node *TreapNode, key int) *TreapNode {\n\tif node.left == nil && node.right == nil {\n\t\treturn nil\n\t} else if node.left == nil {\n\t\tnode = t.leftRotate(node)\n\t} else if node.right == nil {\n\t\tnode = t.rightRotate(node)\n\t} else {\n\t\tif node.left.priority > node.right.priority {\n\t\t\tnode = t.rightRotate(node)\n\t\t} else {\n\t\t\tnode = t.leftRotate(node)\n\t\t}\n\t}\n\treturn t.deleteLoop(node, key)\n}\n\nfunc (t *Treap) inorderTreeWalkV2(p *TreapNode) string {\n\tif p == nil {\n\t\treturn \".\"\n\t}\n\n\tl := t.inorderTreeWalkV2(p.left)\n\tr := t.inorderTreeWalkV2(p.right)\n\treturn fmt.Sprintf(\"(%v %v %v)\", p.key, l, r)\n}\n\nfunc (t *Treap) printInorderWalk(l, r int) {\n\tif t.root != nil {\n\t\tfmt.Print(t.printInorderWalkRoop(t.root, l, r))\n\t}\n}\n\nfunc (t *Treap) printInorderWalkRoop(mid *TreapNode, l, r int) string {\n\tconcated := \"\"\n\tif mid.left != nil && l <= mid.key {\n\t\tconcated += t.printInorderWalkRoop(mid.left, l, r)\n\t}\n\tif l <= mid.key && mid.key <= r {\n\t\tconcated += strconv.Itoa(mid.key) + \"\\n\"\n\t}\n\tif mid.right != nil && mid.key <= r {\n\t\tconcated += t.printInorderWalkRoop(mid.right, l, r)\n\t}\n\treturn concated\n}\n\n// NewSet is constructer of Set\nfunc NewSet() *Set {\n\ts := new(Set)\n\ts.tree = *NewTreap()\n\ts.size = 0\n\treturn s\n}\n\n// Set for integer\ntype Set struct {\n\ttree Treap\n\tsize int\n}\n\nfunc (s *Set) insert(x int) int {\n\tpriority := rand.Int()\n\ts.tree.insert(x, priority)\n\ts.size++\n\treturn s.size\n}\n\nfunc (s *Set) find(x int) int {\n\treturn s.tree.find(x)\n}\n\nfunc (s *Set) delete(x int) {\n\tnFitted := s.tree.find(x)\n\tif nFitted > 0 {\n\t\ts.tree.delete(x)\n\t\ts.size -= nFitted\n\t}\n}\n\nfunc (s *Set) printAll() {\n\tfmt.Println(s.tree.inorderTreeWalkV2(s.tree.root))\n}\n\nfunc (s *Set) printRange(l, r int) {\n\ts.tree.printInorderWalk(l, r)\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tnQueries := nextInt()\n\tset := NewSet()\n\tfor iQuery := 0; iQuery < nQueries; iQuery++ {\n\t\tqueryType := nextInt()\n\t\tx := nextInt()\n\t\tif queryType == 0 { // insert\n\t\t\tsetSize := set.insert(x)\n\t\t\tfmt.Println(setSize)\n\t\t} else if queryType == 1 { // find\n\t\t\tfmt.Println(set.find(x))\n\t\t} else if queryType == 2 { // delete\n\t\t\t// fmt.Println(\"delete\", x)\n\t\t\tset.delete(x)\n\t\t} else if queryType == 3 { // dump(L, R)\n\t\t\tl := x\n\t\t\tr := nextInt()\n\t\t\t// set.printAll()\n\t\t\tset.printRange(l, r)\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tq := getNextInt(scanner)\n\taa := make([]int, 0)\n\tqq := make([]query, q)\n\tfor i := 0; i < q; i++ {\n\t\tqq[i].t = getNextInt(scanner)\n\t\tqq[i].x = getNextInt(scanner)\n\t\taa = append(aa, qq[i].x)\n\t\tif qq[i].t != 3 {\n\t\t\tcontinue\n\t\t}\n\t\tqq[i].y = getNextInt(scanner)\n\t\taa = append(aa, qq[i].y)\n\t}\n\tc := newCompress(aa)\n\tr := map[int]int{}\n\tfor v, i := range c {\n\t\tr[i] = v\n\t}\n\tseg := newSegment(len(c) + 1)\n\tfor i := 0; i < q; i++ {\n\t\tswitch qq[i].t {\n\t\tcase 0:\n\t\t\tseg.update(c.get(qq[i].x), seg[0][c.get(qq[i].x)]+1, seg.add)\n\t\t\tfmt.Fprintln(writer, seg[len(seg)-1][0])\n\t\tcase 1:\n\t\t\tfmt.Fprintln(writer, seg[0][c.get(qq[i].x)])\n\t\tcase 2:\n\t\t\tseg.update(c.get(qq[i].x), 0, seg.add)\n\t\tcase 3:\n\t\t\tfor j := seg.right(0, c.get(qq[i].x), 1); j <= c.get(qq[i].y); j = seg.right(0, j+1, 1) {\n\t\t\t\tfor k := 0; k < seg[0][j]; k++ {\n\t\t\t\t\tfmt.Fprintln(writer, r[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype query struct {\n\tt    int\n\tx, y int\n}\ntype segment [][]int\n\nfunc newSegment(n int) segment {\n\tseg := make(segment, 0)\n\tfor n > 1 {\n\t\tseg = append(seg, make([]int, n))\n\t\tn = (n + 1) >> 1\n\t}\n\tseg = append(seg, make([]int, 1))\n\treturn seg\n}\nfunc (seg segment) update(i int, v int, f func(x, y int) int) {\n\tseg[0][i] = v\n\tfor h := 1; h < len(seg); h++ {\n\t\ti >>= 1\n\t\tif i<<1+1 < len(seg[h-1]) {\n\t\t\tseg[h][i] = f(seg[h-1][i<<1], seg[h-1][i<<1+1])\n\t\t} else {\n\t\t\tseg[h][i] = seg[h-1][i<<1]\n\t\t}\n\t}\n}\nfunc (seg segment) add(x, y int) int {\n\treturn x + y\n}\nfunc (seg segment) right(h, i, k int) int {\n\tif h >= len(seg) || i >= len(seg[h]) {\n\t\treturn len(seg[0])\n\t}\n\tif seg[h][i] < k {\n\t\tk -= seg[h][i]\n\t\ti++\n\t\tif i&1 == 1 {\n\t\t\treturn seg.right(h, i, k)\n\t\t}\n\t\treturn seg.right(h+1, i>>1, k)\n\t}\n\tif h == 0 {\n\t\treturn i\n\t}\n\tif k <= seg[h-1][i<<1] {\n\t\treturn seg.right(h-1, i<<1, k)\n\t}\n\treturn seg.right(h-1, i<<1+1, k-seg[h-1][i<<1])\n}\n\ntype compress map[int]int\n\nfunc newCompress(aa []int) compress {\n\tn := len(aa)\n\tbb := make([]int, n)\n\tcopy(bb, aa)\n\tsort.SliceStable(bb, func(i, j int) bool {\n\t\treturn bb[i] < bb[j]\n\t})\n\tc := compress{}\n\tl := 0\n\ti := 0\n\tfor r := 0; r < n; r++ {\n\t\tfor r > l && bb[r] != bb[l] {\n\t\t\tl++\n\t\t}\n\t\tif r == l {\n\t\t\tc[bb[l]] = i\n\t\t\ti++\n\t\t}\n\t}\n\treturn c\n}\nfunc (c compress) get(x int) int {\n\treturn c[x]\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n)\n\nvar DEBUG = true\n\nfunc main() {\n\tdefer Flush()\n\n\tQ := readi()\n\tb := NewBST()\n\tsize := 0\n\tfor q := 0; q < Q; q++ {\n\t\tt := readi()\n\t\tswitch t {\n\t\tcase 0:\n\t\t\tx := readi()\n\t\t\tn := 1\n\t\t\tnd := b.Find(x)\n\t\t\tif nd != nil {\n\t\t\t\tn += nd.Value().(int)\n\t\t\t}\n\t\t\tb.Insert(x, n)\n\t\t\tsize++\n\t\t\tprintln(size)\n\t\tcase 1:\n\t\t\tx := readi()\n\t\t\tnd := b.Find(x)\n\t\t\tif nd == nil {\n\t\t\t\tprintln(0)\n\t\t\t} else {\n\t\t\t\tprintln(nd.Value().(int))\n\t\t\t}\n\t\tcase 2:\n\t\t\tx := readi()\n\t\t\tnd := b.Find(x)\n\t\t\tif nd != nil {\n\t\t\t\tsize -= nd.Value().(int)\n\t\t\t}\n\t\t\tb.Insert(x, 0)\n\t\tdefault:\n\t\t\tl := readi()\n\t\t\tr := readi()\n\t\t\tb.RangeForEach(l, r+1, func(nd *BSTNode, cancel func()) {\n\t\t\t\tfor i := 0; i < nd.Value().(int); i++ {\n\t\t\t\t\tprintln(nd.key)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n}\n\n//\n// Binary Search Tree\n//\n//   This is Go implementation of LLRB Tree. Some parts of code are\n//   based on the paper \"Left-leaning Red-Black Trees\" by Robert Sedgewick.\n//\n\n// BST represents Binary Search Tree\ntype BST struct {\n\troot  *BSTNode\n\tsize  int\n\tdebug bool\n}\n\n// NewBST returns the pointer a BST object\nfunc NewBST() *BST {\n\tt := &BST{}\n\treturn t\n}\n\n// Len returns the size of the BST\nfunc (t *BST) Len() int {\n\treturn t.size\n}\n\n// Insert inserts the val on the key\nfunc (t *BST) Insert(key int, val interface{}) bool {\n\tvar ok bool\n\tt.root, ok = t.root.insert(key, val)\n\tt.root.color = BST_BLACK\n\tif ok {\n\t\tt.size++\n\t}\n\treturn ok\n}\n\nfunc (t *BST) Debug() {\n\tt.debug = !t.debug\n}\n\nvar dump func()\n\nfunc defaultDump() {\n\treturn\n}\n\nfunc (t *BST) mkDumpFunc(label string) func() {\n\treturn func() {\n\t\tpc, file, line, _ := runtime.Caller(1)\n\t\tfmt.Fprintf(os.Stderr, \"* %s [0x%x@%s:%d]\\n\", label, pc, file, line)\n\t\tfmt.Fprintln(os.Stderr, \"```graphviz\")\n\t\tfmt.Fprintf(os.Stderr, \"%s\", t.Graphviz())\n\t\tfmt.Fprintln(os.Stderr, \"```\")\n\t}\n}\n\n// Remove removes the value on the key\nfunc (t *BST) Remove(key int) bool {\n\t//if t.debug {\n\t//\tfmt.Fprintf(os.Stderr, \"\\n## Remove %d\\n\\n\", key)\n\t//\tdump = t.mkDumpFunc(fmt.Sprintf(\"Remove(%d)\", key))\n\t//} else {\n\t//\tdump = defaultDump\n\t//}\n\n\tvar ok bool\n\tt.root, ok = t.root.remove(key)\n\tif t.root != nil {\n\t\tt.root.color = BST_BLACK\n\t}\n\tif ok {\n\t\tt.size--\n\t}\n\t//if t.debug {\n\t//\tdump = defaultDump\n\t//}\n\treturn ok\n}\n\n// Find returns the BSTNode that matches the key.  It returns nil if the key is not found.\nfunc (t *BST) Find(key int) *BSTNode {\n\treturn t.root.find(key)\n}\n\n// ForEach iterates calling fn on all the BST nodes.\nfunc (t *BST) ForEach(fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.forEach(func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// ReverseForEach iterates like ForEach but in reverse order.\nfunc (t *BST) ReverseForEach(fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.reverseForEach(func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// RangeForEach iterates calling fn with all the BST nodes that has keys such that low <= key < high\nfunc (t *BST) RangeForEach(low, high int, fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.rangeForEach(low, high, func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// ReverseRangeForEach iterates calling fn with all the BST nodes that has keys such that low < key <= high in reverse order.\nfunc (t *BST) ReverseRangeForEach(low, high int, fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.reverseRangeForEach(low, high, func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// Find returns the BSTNode that has a key which is greater than or equal to the specified key.\nfunc (t *BST) LowerBound(key int) *BSTNode {\n\treturn t.root.lowerBound(key)\n}\n\n// Find returns the BSTNode that has a key which is lesser than or equal to the specified key.\nfunc (t *BST) UpperBound(key int) *BSTNode {\n\treturn t.root.upperBound(key)\n}\n\n// String returns the string representation of the BST\nfunc (t *BST) String() string {\n\tbuf := new(bytes.Buffer)\n\tfmt.Fprintf(buf, \"BST[\")\n\tsp := \"\"\n\tt.ForEach(func(nd *BSTNode, cancel func()) {\n\t\tfmt.Fprintf(buf, \"%s%s\", sp, nd)\n\t\tsp = \" \"\n\t})\n\tfmt.Fprintf(buf, \"]\")\n\treturn buf.String()\n}\n\n// Graphviz returns the graph directives of the BST in graphviz format\nfunc (t *BST) Graphviz() string {\n\tbuf := new(bytes.Buffer)\n\tfmt.Fprintf(buf, \"digraph hierarchy {\\n\")\n\tfmt.Fprintf(buf, \"graph [splines=line];\\n\")\n\tt.root.graphviz(buf)\n\tif t.root != nil {\n\t\tif t.root.isRed() {\n\t\t\tfmt.Fprintf(buf, \"%d [color=red fontcolor=red]\\n\", t.root.key)\n\t\t} else {\n\t\t\tfmt.Fprintf(buf, \"%d [color=black fontcolor=black]\\n\", t.root.key)\n\t\t}\n\t}\n\tfmt.Fprintf(buf, \"}\\n\")\n\treturn buf.String()\n}\n\n//\n// BST Node\n//\n\n// BSTNode represents the node of BST\ntype BSTNode struct {\n\tkey         int\n\tvalue       interface{}\n\tleft, right *BSTNode\n\tcolor       bool\n}\n\n// BST_RED and BST_BLACK represent colors of the BSTNode\nconst (\n\tBST_RED   = false\n\tBST_BLACK = true\n)\n\n// Key returns the key of the node\nfunc (nd *BSTNode) Key() int {\n\treturn nd.key\n}\n\n// Value returns the value of the node\nfunc (nd *BSTNode) Value() interface{} {\n\treturn nd.value\n}\n\n// SetValue updates the value of the node with val\nfunc (nd *BSTNode) SetValue(val interface{}) {\n\tnd.value = val\n}\n\n// String returns the string representation of the node\nfunc (nd *BSTNode) String() string {\n\treturn fmt.Sprintf(\"%d:%s\", nd.key, nd.value)\n}\n\nfunc (nd *BSTNode) find(key int) *BSTNode {\n\tif nd == nil {\n\t\treturn nil\n\t}\n\tif key < nd.key {\n\t\treturn nd.left.find(key)\n\t} else if nd.key < key {\n\t\treturn nd.right.find(key)\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) fixup() *BSTNode {\n\tif !nd.left.isRed() && nd.right.isRed() {\n\t\tnd = nd.rotateLeft()\n\t}\n\tif nd.left.isRed() && nd.left != nil && nd.left.left.isRed() {\n\t\tnd = nd.rotateRight()\n\t}\n\tif nd.left.isRed() && nd.right.isRed() {\n\t\tnd.flipColors()\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) insert(key int, val interface{}) (*BSTNode, bool) {\n\tvar ok bool\n\tif nd == nil {\n\t\tnd = &BSTNode{\n\t\t\tkey:   key,\n\t\t\tvalue: val,\n\t\t}\n\t\treturn nd, true\n\t} else if key < nd.key {\n\t\tnd.left, ok = nd.left.insert(key, val)\n\t} else if nd.key < key {\n\t\tnd.right, ok = nd.right.insert(key, val)\n\t} else {\n\t\tnd.value = val\n\t}\n\treturn nd.fixup(), ok\n}\n\nfunc (nd *BSTNode) findMin() (int, interface{}) {\n\tp := nd\n\tfor p.left != nil {\n\t\tp = p.left\n\t}\n\treturn p.key, p.value\n}\n\nfunc (nd *BSTNode) removeMin() *BSTNode {\n\tif nd.left == nil {\n\t\treturn nd.right\n\t}\n\n\tif !nd.left.isRed() && nd.left != nil && !nd.left.left.isRed() {\n\t\tnd = nd.moveRedLeft()\n\t}\n\n\tnd.left = nd.left.removeMin()\n\n\treturn nd.fixup()\n}\n\nfunc (nd *BSTNode) moveRedLeft() *BSTNode {\n\tnd.flipColors()\n\tif nd.right != nil && nd.right.left.isRed() {\n\t\tnd.right = nd.right.rotateRight()\n\t\tnd = nd.rotateLeft()\n\t\tnd.flipColors()\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) moveRedRight() *BSTNode {\n\tnd.flipColors()\n\tif nd.left != nil && nd.left.left.isRed() {\n\t\tnd = nd.rotateRight()\n\t\tnd.flipColors()\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) remove(key int) (*BSTNode, bool) {\n\tif nd == nil {\n\t\treturn nil, false\n\t}\n\n\tvar ok bool\n\tif key < nd.key {\n\t\tif !nd.left.isRed() && nd.left != nil && !nd.left.left.isRed() {\n\t\t\tnd = nd.moveRedLeft()\n\t\t}\n\t\tnd.left, ok = nd.left.remove(key)\n\t} else {\n\t\tif nd.left.isRed() {\n\t\t\tnd = nd.rotateRight()\n\t\t}\n\t\tif nd.key == key && nd.right == nil {\n\t\t\treturn nil, true\n\t\t}\n\t\tif !nd.right.isRed() && nd.right != nil && !nd.right.left.isRed() {\n\t\t\tnd = nd.moveRedRight()\n\t\t}\n\t\tif nd.key == key {\n\t\t\tnd.key, nd.value = nd.right.findMin()\n\t\t\tnd.right = nd.right.removeMin()\n\t\t\tok = true\n\t\t} else {\n\t\t\tnd.right, ok = nd.right.remove(key)\n\t\t}\n\t}\n\treturn nd.fixup(), ok\n}\n\nfunc (nd *BSTNode) forEach(fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif nd.left != nil {\n\t\tif nd.left.forEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif fn(nd) {\n\t\treturn true\n\t}\n\n\tif nd.right != nil {\n\t\tif nd.right.forEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) reverseForEach(fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif nd.right != nil {\n\t\tif nd.right.reverseForEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif fn(nd) {\n\t\treturn true\n\t}\n\n\tif nd.left != nil {\n\t\tif nd.left.reverseForEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) rangeForEach(low, high int, fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif low < nd.key && nd.left != nil {\n\t\tif nd.left.rangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif low <= nd.key && nd.key < high {\n\t\tif fn(nd) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif nd.key < high && nd.right != nil {\n\t\tif nd.right.rangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) reverseRangeForEach(low, high int, fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif nd.key < high && nd.right != nil {\n\t\tif nd.right.reverseRangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif low < nd.key && nd.key <= high {\n\t\tif fn(nd) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif low < nd.key && nd.left != nil {\n\t\tif nd.left.reverseRangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) lowerBound(key int) *BSTNode {\n\tif nd == nil {\n\t\treturn nil\n\t}\n\n\tif key < nd.key && nd.left != nil {\n\t\tif res := nd.left.lowerBound(key); res != nil {\n\t\t\treturn res\n\t\t}\n\t}\n\n\tif key <= nd.key {\n\t\treturn nd\n\t}\n\n\tif nd.key < key && nd.right != nil {\n\t\treturn nd.right.lowerBound(key)\n\t}\n\treturn nil\n}\n\nfunc (nd *BSTNode) upperBound(key int) *BSTNode {\n\tif nd == nil {\n\t\treturn nil\n\t}\n\n\tif nd.key <= key {\n\t\tif nd.right == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn nd.right.upperBound(key)\n\t}\n\n\tif nd.left != nil {\n\t\tif res := nd.left.upperBound(key); res != nil {\n\t\t\treturn res\n\t\t}\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) rotateLeft() *BSTNode {\n\tx := nd.right\n\tnd.right = x.left\n\tx.left = nd\n\tx.color = nd.color\n\tnd.color = BST_RED\n\treturn x\n}\n\nfunc (nd *BSTNode) rotateRight() *BSTNode {\n\tx := nd.left\n\tnd.left = x.right\n\tx.right = nd\n\tx.color = nd.color\n\tnd.color = BST_RED\n\treturn x\n}\n\nfunc (nd *BSTNode) flipColors() {\n\tnd.color = !nd.color\n\tif nd.left != nil {\n\t\tnd.left.color = !nd.left.color\n\t}\n\tif nd.right != nil {\n\t\tnd.right.color = !nd.right.color\n\t}\n}\n\nfunc (nd *BSTNode) isRed() bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\treturn nd.color == BST_RED\n}\n\nfunc (nd *BSTNode) graphviz(w io.Writer) {\n\tif nd == nil {\n\t\treturn\n\t}\n\tif nd.left != nil {\n\t\tfmt.Fprintf(w, `%d -> %d`, nd.key, nd.left.key)\n\t\tif nd.left.isRed() {\n\t\t\tfmt.Fprintf(w, ` [color=red]`)\n\t\t}\n\t\tfmt.Fprintln(w)\n\t\tnd.left.graphviz(w)\n\t}\n\tif nd.right != nil {\n\t\tfmt.Fprintf(w, `%d -> %d`, nd.key, nd.right.key)\n\t\tif nd.right.isRed() {\n\t\t\tfmt.Fprintf(w, ` [color=red]`)\n\t\t}\n\t\tfmt.Fprintln(w)\n\t\tnd.right.graphviz(w)\n\t}\n\tif nd.isRed() {\n\t\tfmt.Fprintf(w, \"%d [color=red fontcolor=red]\\n\", nd.key)\n\t}\n}\n\n// -----------------------------------------------------------------------------\n\n// IO helper functions\n\n// Returns next token from input.  It must be initialized by SetInput()\n// before the first call.\nvar nextToken func() ([]byte, error)\nvar nextLine func() ([]byte, error)\n\n// Holds a buffer for output.  It must be initialized by SetOutput().\n// All IO fucntions (read*() and [e]print*()) should write to OutputWriter\n// instead of this.\nvar OutputBuffer *bufio.Writer\n\n// Holds an io.Writer.  It must be initialized by SetOutput()\nvar OutputWriter io.Writer\n\n// Set IO functions for interactive input/output.\nfunc SetInteractive(w io.Writer, r io.Reader) {\n\tSetUnbefferedInput(r)\n\tOutputBuffer = nil\n\tOutputWriter = w\n}\n\n// Setup OutputBuffer and OutputWriter.\nfunc SetOutput(w io.Writer) {\n\tOutputBuffer = bufio.NewWriter(w)\n\tOutputWriter = OutputBuffer\n}\n\n// Flushes OutputBuffer\nfunc Flush() {\n\tif OutputBuffer != nil {\n\t\tOutputBuffer.Flush()\n\t}\n}\n\n// Returns true if c is a white space\nfunc IsSpace(c byte) bool {\n\tswitch c {\n\tcase '\\t', '\\n', '\\v', '\\f', '\\r', ' ':\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc IsNewLine(c byte) bool {\n\tswitch c {\n\tcase '\\n', '\\r':\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Setup nextToken with input buffer.\nfunc SetInput(r io.Reader) {\n\tbuf := new(bytes.Buffer)\n\tvar b []byte\n\n\tvar i int\n\trest := func() ([]byte, error) {\n\t\tfor i < len(b) && IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == len(b) {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n\tinitial := func() ([]byte, error) {\n\t\tio.Copy(buf, r)\n\t\tb = buf.Bytes()\n\t\tnextToken = rest\n\t\treturn rest()\n\t}\n\tnextToken = initial\n\n\trestLn := func() ([]byte, error) {\n\t\tfor i < len(b) && IsNewLine(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == len(b) {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsNewLine(b[i]) {\n\t\t\ti++\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n\n\tinitialLn := func() ([]byte, error) {\n\t\tio.Copy(buf, r)\n\t\tb = buf.Bytes()\n\t\tnextLine = restLn\n\t\treturn restLn()\n\t}\n\tnextLine = initialLn\n}\n\n// Setup nextToken without input buffer.\nfunc SetUnbefferedInput(r io.Reader) {\n\tbuf := bufio.NewReader(r)\n\tvar b []byte\n\n\tvar i int\n\tnextToken = func() ([]byte, error) {\n\t\tvar err error\n\t\tif i == len(b) {\n\t\t\tb, err = buf.ReadBytes('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ti = 0\n\t\t\tj := len(b) - 1\n\t\t\tfor 0 <= j && IsSpace(b[j]) {\n\t\t\t\tj--\n\t\t\t}\n\t\t\tb = b[0 : j+1]\n\t\t}\n\t\tfor i < len(b) && IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == j {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n}\n\n// -----------------------------------------------------------------------------\n\n// IO functions\n\n// Reads next token and return it as []byte\nfunc readb() []byte {\n\tb, err := nextToken()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b[:len(b):len(b)]\n}\n\n// Reads next token and return it as string\nfunc reads() string {\n\treturn string(readb())\n}\n\n// Read next line as []byte.  Trailing '\\n' will not be included.\n// See also comments on readb()\nfunc readbln() []byte {\n\tb, err := nextLine()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b[:len(b):len(b)]\n}\n\n// Read next line as string\nfunc readsln() string {\n\treturn string(readbln())\n}\n\n// Reads next token and return it as int64\nfunc readll() int64 {\n\ti, err := strconv.ParseInt(reads(), 10, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// Reads next token and return it as int\nfunc readi() int {\n\treturn int(readll())\n}\n\n// Reads next token and return it as float64\nfunc readf() float64 {\n\tf, err := strconv.ParseFloat(reads(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// Write args to OutputWriter with the format f\nfunc printf(f string, args ...interface{}) (int, error) {\n\treturn fmt.Fprintf(OutputWriter, f, args...)\n}\n\n// Write args to OutputWriter without format\nfunc println(args ...interface{}) (int, error) {\n\treturn fmt.Fprintln(OutputWriter, args...)\n}\n\n// Write args to stderr with the format f\nfunc eprintf(f string, args ...interface{}) (int, error) {\n\treturn fmt.Fprintf(os.Stderr, f, args...)\n}\n\n// Write args to stderr without format\nfunc eprintln(args ...interface{}) (int, error) {\n\treturn fmt.Fprintln(os.Stderr, args...)\n}\n\nfunc dbgf(f string, args ...interface{}) {\n\tif !DEBUG {\n\t\treturn\n\t}\n\tfmt.Fprintf(os.Stderr, f, args...)\n}\n\nfunc dbg(args ...interface{}) {\n\tif !DEBUG {\n\t\treturn\n\t}\n\tfmt.Fprintln(os.Stderr, args...)\n}\n\n// -----------------------------------------------------------------------------\n\n// Utilities\n\nfunc sumSlice(a []int) int {\n\tvar res int\n\tfor _, v := range a {\n\t\tres += v\n\t}\n\treturn res\n}\n\nfunc sumSlicell(a []int64) int64 {\n\tvar res int64\n\tfor _, v := range a {\n\t\tres += v\n\t}\n\treturn res\n}\n\nfunc readInts(N int) (int, []int) {\n\tif N == 0 {\n\t\tN = readi()\n\t}\n\ta := make([]int, N)\n\tfor i := range a {\n\t\ta[i] = readi()\n\t}\n\treturn N, a\n}\n\nfunc readIntsll(N int) (int, []int64) {\n\tif N == 0 {\n\t\tN = readi()\n\t}\n\ta := make([]int64, N)\n\tfor i := range a {\n\t\ta[i] = readll()\n\t}\n\treturn N, a\n}\n\n// -----------------------------------------------------------------------------\n\n// Simple math functions\n\nconst (\n\t// big prime\n\tINF  = 1000000007\n\tINF2 = 1000000009\n\tINF3 = 998244353\n)\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minll(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minf(a, b float64) float64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc maxll(a, b int64) int64 {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc maxf(a, b float64) float64 {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc absll(a int64) int64 {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc absf(a float64) float64 {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// egcd(a, b) returns d, x, y:\n//   d is gcd(a,b)\n//   x, y are  integers that satisfy ax + by = d\nfunc egcd(a, b int) (int, int, int) {\n\tif b == 0 {\n\t\treturn a, 1, 0\n\t}\n\td, x, y := egcd(b, a%b)\n\treturn d, y, x - a/b*y\n}\n\nfunc egcdll(a, b int64) (int64, int64, int64) {\n\tif b == 0 {\n\t\treturn a, 1, 0\n\t}\n\td, x, y := egcdll(b, a%b)\n\treturn d, y, x - a/b*y\n}\n\nfunc gcd(a, b int) int {\n\td, _, _ := egcd(a, b)\n\treturn d\n}\n\nfunc gcdll(a, b int64) int64 {\n\td, _, _ := egcdll(a, b)\n\treturn d\n}\n\n// set up IO functions\nfunc init() {\n\t// for non-interactive\n\tSetInput(os.Stdin)\n\tSetOutput(os.Stdout)\n\n\t// Enable below when interactive.  Its ok to leave above intact.\n\t// SetInteractive(os.Stdout, os.Stdin)\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\nimport collections\n\n\ndef main6():\n    values = collections.defaultdict(int)\n    element_count = 0\n\n    q = int(input())\n\n    for _ in range(q):\n        com, *para = map(int, input().split())\n\n        if   com == 0:\n            values[para[0]] += 1\n            element_count += 1\n            print(element_count)\n\n        elif com == 1:\n            print(values[para[0]])\n\n        elif com == 2:\n            element_count -= values[para[0]]\n            values[para[0]] = 0\n\n        elif com == 3:\n\n            if para[0] == para[1]:\n                for _ in range(values[para[0]]):\n                    print(para[0])\n\n            elif  abs(para[0] - para[1]) < 10:\n\n                for i in range(para[0], para[1] + 1):\n                    for _ in range(values[i]):\n                        print(i)\n            \n            else:\n                key_list = [k for k, v in values.items() if v != 0]\n                key_list = sorted(key_list)\n\n                lb = bisect.bisect_left(key_list, para[0])\n                rb = bisect.bisect_right(key_list, para[1])\n\n                for s in key_list[lb:rb] :\n                    for _ in range(values[s]):\n                        print(s)\n\nmain6()\n"
  },
  {
    "language": "Python",
    "code": "# AOJ ITP2_7_D: Multi-Set\n# Python3 2018.6.24 bal4u\n\nfrom bisect import bisect_left, bisect_right, insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n\ta = list(input().split())\n\tki = int(a[1])\n\tif a[0] == '0':\n\t\tif ki not in dict:\n\t\t\tdict[ki] = 1\n\t\t\tinsort_left(keytbl, ki)\n\t\telse: dict[ki] += 1\n\t\tcnt += 1\n\t\tprint(cnt)\n\telif a[0] == '1': print(dict[ki] if ki in dict else 0)\n\telif a[0] == '2':\n\t\tif ki in dict:\n\t\t\tcnt -= dict[ki]\n\t\t\tdict[ki] = 0\n\telse:\n\t\tL = bisect_left (keytbl, int(a[1]))\n\t\tR = bisect_right(keytbl, int(a[2]), L)\n\t\tfor j in range(L, R):\n\t\t\tfor k in range(dict[keytbl[j]]): print(keytbl[j])\n"
  },
  {
    "language": "Python",
    "code": "# AOJ ITP2_7_D: Multi-Set\n# Python3 2018.6.24 bal4u\n\nfrom bisect import bisect_left, bisect_right, insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n\ta = list(input().split())\n\tki = int(a[1])\n\tif a[0] == '0':\n\t\tif ki not in dict:\n\t\t\tdict[ki] = 1\n\t\t\tinsort_left(keytbl, ki)\n\t\telse: dict[ki] += 1\n\t\tcnt += 1\n\t\tprint(cnt)\n\telif a[0] == '1': print(dict[ki] if ki in dict else 0)\n\telif a[0] == '2':\n\t\tif ki in dict:\n\t\t\tcnt -= dict[ki]\n\t\t\tdict[ki] = 0\n\telse:\n\t\tL = bisect_left (keytbl, int(a[1]))\n\t\tR = bisect_right(keytbl, int(a[2]), L)\n\t\tr = []\n\t\tfor j in range(L, R): r += [keytbl[j]]*dict[keytbl[j]]\n\t\tprint(*r, sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "from bisect import insort, bisect_right, bisect_left\n\n\nclass MultiSet:\n    def __init__(self) -> None:\n        self.total = 0\n        self.ms: dict = dict()\n        self.lr: list = []\n\n    def insert(self, x: int) -> None:\n        self.total += 1\n        if x in self.ms:\n            self.ms[x] += 1\n        else:\n            self.ms[x] = 1\n            insort(self.lr, x)\n        print(self.total)\n\n    def find(self, x: int) -> None:\n        print(self.ms.get(x, 0))\n\n    def delete(self, x: int) -> None:\n        if x in self.ms:\n            self.total -= self.ms[x]\n            self.ms[x] = 0\n\n    def dump(self, l: int, r: int) -> None:\n        lb = bisect_left(self.lr, l)\n        ub = bisect_right(self.lr, r)\n        for i in range(lb, ub):\n            k = self.lr[i]\n            v = self.ms[k]\n            print(f'{k}\\n' * v, end='')\n\n\nif __name__ == \"__main__\":\n    ms = MultiSet()\n    num_query = int(input())\n    for _ in range(num_query):\n        op, *v = map(lambda x: int(x), input().split())\n        if 0 == op:\n            ms.insert(v[0])\n        elif 1 == op:\n            ms.find(v[0])\n        elif 2 == op:\n            ms.delete(v[0])\n        else:\n            ms.dump(v[0], v[1])\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1]:\n                for c in range(b,len(S)):\n                    if S[c] <= a[i][2]:\n                        print(S[c])\n                    else:\n                        break\n                break\n"
  },
  {
    "language": "Python",
    "code": "\nfrom enum import Enum\n\n\nclass Color(Enum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass Node:\n    __slots__ = ('key', 'left', 'right', 'size', 'color', 'value')\n\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.left = Leaf\n        self.right = Leaf\n        self.size = 1\n        self.color = Color.RED\n\n    def is_red(self):\n        return self.color == Color.RED\n\n    def is_black(self):\n        return self.color == Color.BLACK\n\n    def __str__(self):\n        if self.color == Color.RED:\n            key = '*{}'.format(self.key)\n        else:\n            key = '{}'.format(self.key)\n        return \"{}[{}] ({}, {})\".format(key, self.size,\n                                        self.left, self.right)\n\n\nclass LeafNode(Node):\n    def __init__(self):\n        self.key = None\n        self.value = None\n        self.left = None\n        self.right = None\n        self.size = 0\n        self.color = None\n\n    def is_red(self):\n        return False\n\n    def is_black(self):\n        return False\n\n    def __str__(self):\n        return '-'\n\n\nLeaf = LeafNode()\n\n\nclass RedBlackBinarySearchTree:\n    \"\"\"Red Black Binary Search Tree with range, min, max.\n    Originally impremented in the textbook\n    Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,\n    Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.\n    \"\"\"\n\n    def __init__(self):\n        self.root = Leaf\n\n    def put(self, key, value=None):\n        def _put(node):\n            if node is Leaf:\n                node = Node(key, value)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n            else:\n                node.value = value\n\n            node = self._restore(node)\n\n            node.size = node.left.size + node.right.size + 1\n            return node\n\n        self.root = _put(self.root)\n        self.root.color = Color.BLACK\n\n    def _rotate_left(self, node):\n        assert node.right.is_red()\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        node.size = node.left.size + node.right.size + 1\n        return x\n\n    def _rotate_right(self, node):\n        assert node.left.is_red()\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        node.size = node.left.size + node.right.size + 1\n        return x\n\n    def _flip_colors(self, node):\n        node.color = Color.flip(node.color)\n        node.left.color = Color.flip(node.left.color)\n        node.right.color = Color.flip(node.right.color)\n        return node\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is Leaf:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def get(self, key):\n        def _get(node):\n            if node is Leaf:\n                return None\n            if node.key > key:\n                return _get(node.left)\n            elif node.key < key:\n                return _get(node.right)\n            else:\n                return node.value\n        return _get(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is Leaf:\n                return Leaf\n\n            if node.key > key:\n                if node.left is Leaf:\n                    return self._balance(node)\n                if not self._is_red_left(node):\n                    node = self._red_left(node)\n                node.left = _delete(node.left)\n            else:\n                if node.left.is_red():\n                    node = self._rotate_right(node)\n                if node.key == key and node.right is Leaf:\n                    return Leaf\n                elif node.right is Leaf:\n                    return self._balance(node)\n                if not self._is_red_right(node):\n                    node = self._red_right(node)\n                if node.key == key:\n                    x = self._find_min(node.right)\n                    node.key = x.key\n                    node.value = x.value\n                    node.right = self._delete_min(node.right)\n                else:\n                    node.right = _delete(node.right)\n\n            return self._balance(node)\n\n        if self.is_empty():\n            raise ValueError('delete on empty tree')\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = _delete(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n        assert self.is_balanced()\n\n    def delete_max(self):\n        if self.is_empty():\n            raise ValueError('delete max on empty tree')\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = self._delete_max(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n        assert self.is_balanced()\n\n    def _delete_max(self, node):\n        if node.left.is_red():\n            node = self._rotate_right(node)\n        if node.right is Leaf:\n            return Leaf\n\n        if not self._is_red_right(node):\n            node = self._red_right(node)\n        node.right = self._delete_max(node.right)\n        return self._balance(node)\n\n    def _red_right(self, node):\n        node = self._flip_colors(node)\n        if node.left.left.is_red():\n            node = self._rotate_right(node)\n        return node\n\n    def _is_red_right(self, node):\n        return (node.right.is_red() or\n                (node.right.is_black() and node.right.left.is_red()))\n\n    def delete_min(self):\n        if self.is_empty():\n            raise ValueError('delete min on empty tree')\n\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = self._delete_min(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n        assert self.is_balanced()\n\n    def _delete_min(self, node):\n        if node.left is Leaf:\n            return Leaf\n\n        if not self._is_red_left(node):\n            node = self._red_left(node)\n        node.left = self._delete_min(node.left)\n        return self._balance(node)\n\n    def _red_left(self, node):\n        node = self._flip_colors(node)\n        if node.right.left.is_red():\n            node.right = self._rotate_right(node.right)\n            node = self._rotate_left(node)\n        return node\n\n    def _is_red_left(self, node):\n        return (node.left.is_red() or\n                (node.left.is_black() and node.left.left.is_red()))\n\n    def _balance(self, node):\n        if node.right.is_red():\n            node = self._rotate_left(node)\n        return self._restore(node)\n\n    def _restore(self, node):\n        if node.right.is_red() and not node.left.is_red():\n            node = self._rotate_left(node)\n        if node.left.is_red() and node.left.left.is_red():\n            node = self._rotate_right(node)\n        if node.left.is_red() and node.right.is_red():\n            node = self._flip_colors(node)\n\n        node.size = node.left.size + node.right.size + 1\n        return node\n\n    def is_empty(self):\n        return self.root is Leaf\n\n    def is_balanced(self):\n        if self.is_empty():\n            return True\n\n        try:\n            left = self._depth(self.root.left)\n            right = self._depth(self.root.right)\n            return left == right\n        except Exception:\n            return False\n\n    @property\n    def depth(self):\n        return self._depth(self.root)\n\n    def _depth(self, node):\n        if node is Leaf:\n            return 0\n        if node.right.is_red():\n            raise Exception('right red')\n        left = self._depth(node.left)\n        right = self._depth(node.right)\n        if left != right:\n            raise Exception('unbalanced')\n        if node.is_red():\n            return left\n        else:\n            return 1 + left\n\n    def __len__(self):\n        return self.root.size\n\n    @property\n    def max(self):\n        if self.is_empty():\n            raise ValueError('max on empty tree')\n        return self._max(self.root)\n\n    def _max(self, node):\n        x = self._find_max(node)\n        return x.key\n\n    def _find_max(self, node):\n        if node.right is Leaf:\n            return node\n        else:\n            return self._find_max(node.right)\n\n    @property\n    def min(self):\n        if self.is_empty():\n            raise ValueError('min on empty tree')\n        return self._min(self.root)\n\n    def _min(self, node):\n        x = self._find_min(node)\n        return x.key\n\n    def _find_min(self, node):\n        if node.left is Leaf:\n            return node\n        else:\n            return self._find_min(node.left)\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is Leaf:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield (node.key, node.value)\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\nclass BalancedBstCounter:\n    def __init__(self):\n        self.bst = RedBlackBinarySearchTree()\n        self.count = 0\n\n    def up(self, key):\n        if key in self.bst:\n            value = self.bst.get(key) + 1\n        else:\n            value = 1\n        self.bst.put(key, value)\n        self.count += 1\n\n    def __contains__(self, key):\n        if key in self.bst:\n            return self.bst.get(key) > 0\n        return False\n\n    def get(self, key):\n        if key in self.bst:\n            return self.bst.get(key)\n        return 0\n\n    def down(self, key):\n        if key in self.bst:\n            value = self.bst.get(key) - 1\n            if value >= 0:\n                self.bst.put(key, value)\n                self.count -= 1\n\n    def range(self, a, b):\n        for k, v in self.bst.range(a, b):\n            for _ in range(v):\n                yield k\n\n    def __len__(self):\n        return self.count\n\n    def __str__(self):\n        return str(self.bst.root)\n\n\ndef run():\n    q = int(input())\n    counter = BalancedBstCounter()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            counter.up(value[0])\n            print(len(counter))\n        elif command == 1:\n            print(counter.get(value[0]))\n        elif command == 2:\n            counter.down(value[0])\n        elif command == 3:\n            for i in counter.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# Solved by QBnewb\n# Discretization\n# off-line\n\nq = int(input())\ns = []\nrs = [] # for discretization\n\n# download the input\nfor i in range(q):\n    s.append(list(map(int, input().split())))\n    if s[i][0] == 3:\n        rs.append(s[i][1])\n        rs.append(s[i][2])\n    else:\n        rs.append(s[i][1])\n\nrs.append(10**9 + 1)\nrs = sorted(list(set(rs)))\nindex = {rs[i]:i for i in range(len(rs))} # discretization\ncounter = [0 for i in range(len(rs) + 1)] # count the number of every element in set\ncnt = 0\nfor i in range(q):\n    op, x = s[i][0], s[i][1]\n    idx = index[x]\n    if op == 0:\n        cnt += 1\n        counter[idx] += 1\n        print(cnt)\n    elif op == 1:\n        print(counter[idx])\n    elif op == 2:\n        cnt -= counter[idx]\n        counter[idx] = 0\n    else:\n        l = idx\n        r = index[s[i][2]]\n        for j in range(l, r+1):\n            for k in range(counter[j]):\n                print(rs[j])\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nSet - Multi-Set\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP2_7_D&lang=jp\n\n\"\"\"\nfrom bisect import insort, bisect_right, bisect_left\n\nclass Multi_set:\n    def __init__(self):\n        self.total = 0\n        self.ms = dict()\n        self.lr = []\n\n    def insert(self, x):\n        self.total += 1\n        if x in self.ms:\n            self.ms[x] += 1\n        else:\n            self.ms[x] = 1\n            insort(self.lr, x)\n        print(self.total)\n\n    def find(self, x):\n        print(self.ms.get(x, 0))\n\n    def delete(self, x):\n        if x in self.ms:\n            self.total -= self.ms[x]\n            self.ms[x] = 0\n\n    def dump(self, l, r):\n        lb = bisect_left(self.lr, l)\n        ub = bisect_right(self.lr, r)\n        for i in range(lb, ub):\n            k = self.lr[i]\n            v = self.ms[k]\n            print(f'{k}\\n' * v, end='')\n\n\nms = Multi_set()\nfor _ in range(int(input())):\n    op, x, y = (input() + ' 1').split()[:3]\n    if op == '0':\n        ms.insert(int(x))\n    elif op == '1':\n        ms.find(int(x))\n    elif op == '2':\n        ms.delete(int(x))\n    else:\n        ms.dump(int(x), int(y))\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left, bisect_right, insort_left\ndict = {}\nli = []\ncount = 0\nq = int(input())\nfor i in range(q):\n    a = input().split()\n    t = int(a[1])\n    if a[0] == \"0\":\n        if t not in dict:\n            dict[t] = 1\n            insort_left(li, t)\n        else:\n            dict[t] += 1\n        count += 1\n        print(count)\n    elif a[0] == \"1\":\n        print(dict[t] if t in dict else 0)\n    elif a[0] == \"2\":\n        if t in dict:\n            count -= dict[t]\n            dict[t] = 0\n    else:\n        l = bisect_left(li, int(a[1]))\n        r = bisect_right(li, int(a[2]))\n        lis = []\n        for i in range(l, r):\n            lis += [li[i]] * dict[li[i]]\n        if lis != []:\n            print(*lis, sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "import bisect\nimport sys\ndef input():\n    return sys.stdin.readline().strip()\nS = []\ncount = {}\ntotal = 0\n\nfor _ in range(int(input())):\n    order = tuple(map(int,input().split()))\n    value = order[1]\n    if order[0] == 0:\n        if value in count:\n            count[value] += 1\n        else:\n            count[value] = 1\n            bisect.insort(S,value)\n        total += 1\n        print(total)\n    elif order[0] == 1:\n        if value in count:\n            print(count[value])\n        else:\n            print(0)\n    elif order[0] == 2:\n        if value in count:\n            total -= count[value]\n            count[value] = 0\n\n    else:\n        left = bisect.bisect_left(S,order[1])\n        right = bisect.bisect(S,order[2])\n\n        out = []\n\n        for i in range(left,right):\n            out += [S[i]]*count[S[i]]\n        \n        for i in out:\n            print(i)\n\"\"\"  \n    print(S)\n    print(count)\n\"\"\"\n"
  },
  {
    "language": "Python",
    "code": "# AOJ ITP2_7_D: Multi-Set\n# Python3 2018.6.24 bal4u\n\nfrom bisect import bisect_left, bisect_right, insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n\ta = list(input().split())\n\tki = int(a[1])\n\tif a[0] == '0':\n\t\tif ki not in dict:\n\t\t\tdict[ki] = 1\n\t\t\tinsort_left(keytbl, ki)\n\t\telse: dict[ki] += 1\n\t\tcnt += 1\n\t\tprint(cnt)\n\telif a[0] == '1': print(dict[ki] if ki in dict else 0)\n\telif a[0] == '2':\n\t\tif ki in dict:\n\t\t\tcnt -= dict[ki]\n\t\t\tdict[ki] = 0\n\telse:\n\t\tL = bisect_left (keytbl, int(a[1]))\n\t\tR = bisect_right(keytbl, int(a[2]), L)\n\t\tfor j in range(L, R):\n\t\t\tif dict[keytbl[j]] > 0: print(keytbl[j])\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nS=[]\n\ndef insert(S,count,x):\n    y=bisect.bisect(S,x)\n    S.insert(y,x)\n    count+=1\n    print(count)\n    return S,count\n\ndef find(S,x):\n    y0=bisect.bisect_left(S,x)\n    y1=bisect.bisect_right(S,x)\n    return y0,y1\n\ndef erase(S,count,x):\n    y0,y1=find(S,x)\n    if y1-y0>0:\n        del S[y0:y1]\n        count-=y1-y0\n    return S,count\n\ndef dump(S,L,R):\n    s=bisect.bisect_left(S,L)\n    e=bisect.bisect_right(S,R)\n    if e-s>0:\n        print('\\n'.join(map(str,S[s:e])))\n\nq=int(input())\ncount=0\nfor i in range(q):\n    query=list(map(int,input().split()))\n    \n    if query[0]==0:\n        S,count=insert(S,count,query[1])\n    elif query[0]==1:\n        y0,y1=find(S,query[1])\n        print(y1-y0)\n    elif query[0]==2:\n        S,count=erase(S,count,query[1])\n    else:\n        dump(S,query[1],query[2])\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left,bisect_right,insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n    a = list(input().split())\n    ki = int(a[1])\n    if a[0] == \"0\":\n        if ki not in dict:\n            dict[ki] =1\n            insort_left(keytbl,ki)\n        else:dict[ki] += 1\n        cnt += 1\n        print(cnt)\n    elif a[0] == \"1\":print(dict[ki] if ki in dict else 0)\n    elif a[0] == \"2\":\n        if ki in dict:\n            cnt -= dict[ki]\n            dict[ki] =0\n    else:\n        L = bisect_left(keytbl,int(a[1]))\n        R = bisect_right(keytbl,int(a[2]),L)\n        r = []\n        for j in range(L,R):r += [keytbl[j]]*dict[keytbl[j]]\n        if r != []:print(*r,sep=\"\\n\")\n\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\nq = int(input())\n\nS = []\n\n\nfor _ in range(q):\n\n    command, *list_num = input().split()\n    x = int(list_num[0])\n\n    index_left_x = bisect.bisect_left(S, x)\n    index_right_x = bisect.bisect_right(S, x)\n\n    if   command == \"0\":\n        # insert(x)\n        x = int(list_num[0])\n        S.insert(index_left_x, x)\n        print(len(S))\n    elif command == \"1\":\n        # find(x)\n        x = int(list_num[0])\n        print(index_right_x - index_left_x)\n    elif command == \"2\":\n        # delete(x)\n        x = int(list_num[0])\n        S[index_left_x:index_right_x]= []\n    elif command == \"3\":\n        # dump(L, R)\n        L = x\n        R = int(list_num[1])\n\n        index_left = bisect.bisect_left(S, L)\n        index_right = bisect.bisect_right(S, R)\n        \n        for element in S[index_left:index_right]:\n            print(element)\n    else:\n        raise\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nS=[]\n\nq=int(input())\n\ndef find(x):\n    index=bisect.bisect_left(S,x)\n    if index==len(S):\n        return -1\n    if S[index]==x:\n        return index\n    else:\n        return -1\n\n\nfor _ in range(q):\n    query=[int(i) for i in input().split(\" \")]\n    if query[0]==0:\n        bisect.insort_left(S, query[1])\n        print(len(S))\n    elif query[0]==1:\n        L,R=query[1],query[1]\n        indL=bisect.bisect_left(S,L)\n        indR=bisect.bisect_right(S,R)\n        print(len(S[indL:indR]))\n    elif query[0]==2:\n        while find(query[1])>=0:\n            S.pop(find(query[1]))\n    else:\n        L,R=query[1],query[2]\n        indL=bisect.bisect_left(S,L)\n        indR=bisect.bisect_right(S,R)\n        for s in S[indL:indR]:\n            print(s)\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nq = int(input())\nS = []\n\nfor i in range(q):\n    query, *n = input().split()\n    x = int(n[0])\n    index_left = bisect.bisect_left(S, x)\n    index_right = bisect.bisect_right(S, x)\n\n    # insert\n    if query[0] == \"0\":\n        x = int(n[0])\n        S.insert(index_left, x)\n        print(len(S))\n\n    # find\n    elif query[0] == \"1\":\n        x = int(n[0])\n        print(index_right - index_left)\n\n    # delete\n    elif query[0] == \"2\":\n        x = int(n[0])\n        S[index_left:index_right] = []\n\n    # dump\n    else:\n        L = int(n[0])\n        R = int(n[1])\n        \n        index_left = bisect.bisect_left(S, L)\n        index_right = bisect.bisect_right(S, R)\n\n        [print(i) for i in S[index_left:index_right]]\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        print(S.count(a[i][1]))\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            c = 0\n            for b in range(len(S)):\n                if S[b] == a[i][1]:\n                    c += 1\n            for b in range(c):\n                S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1]:\n                for c in range(b,len(S)):\n                    if S[c] <= a[i][2]:\n                        print(S[c])\n                    else:\n                        break\n                break\n"
  },
  {
    "language": "Python",
    "code": "\nfrom enum import Enum\n\n\nclass Color(Enum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass Node:\n    __slots__ = ('key', 'left', 'right', 'size', 'color', 'value')\n\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.left = Leaf\n        self.right = Leaf\n        self.size = 1\n        self.color = Color.RED\n\n    def is_red(self):\n        return self.color == Color.RED\n\n    def is_black(self):\n        return self.color == Color.BLACK\n\n    def __str__(self):\n        if self.color == Color.RED:\n            key = '*{}'.format(self.key)\n        else:\n            key = '{}'.format(self.key)\n        return \"{}[{}] ({}, {})\".format(key, self.size,\n                                        self.left, self.right)\n\n\nclass LeafNode(Node):\n    def __init__(self):\n        self.key = None\n        self.value = None\n        self.left = None\n        self.right = None\n        self.size = 0\n        self.color = None\n\n    def is_red(self):\n        return False\n\n    def is_black(self):\n        return False\n\n    def __str__(self):\n        return '-'\n\n\nLeaf = LeafNode()\n\n\nclass RedBlackBinarySearchTree:\n    \"\"\"Red Black Binary Search Tree with range, min, max.\n    Originally impremented in the textbook\n    Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,\n    Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.\n    \"\"\"\n\n    def __init__(self):\n        self.root = Leaf\n\n    def put(self, key, value=None):\n        def _put(node):\n            if node is Leaf:\n                node = Node(key, value)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n            else:\n                node.value = value\n\n            node = self._restore(node)\n\n            node.size = node.left.size + node.right.size + 1\n            return node\n\n        self.root = _put(self.root)\n        self.root.color = Color.BLACK\n\n    def _rotate_left(self, node):\n        assert node.right.is_red()\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        node.size = node.left.size + node.right.size + 1\n        return x\n\n    def _rotate_right(self, node):\n        assert node.left.is_red()\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        node.size = node.left.size + node.right.size + 1\n        return x\n\n    def _flip_colors(self, node):\n        node.color = Color.flip(node.color)\n        node.left.color = Color.flip(node.left.color)\n        node.right.color = Color.flip(node.right.color)\n        return node\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is Leaf:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def get(self, key):\n        def _get(node):\n            if node is Leaf:\n                return None\n            if node.key > key:\n                return _get(node.left)\n            elif node.key < key:\n                return _get(node.right)\n            else:\n                return node.value\n        return _get(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is Leaf:\n                return Leaf\n\n            if node.key > key:\n                if node.left is Leaf:\n                    return self._balance(node)\n                if not self._is_red_left(node):\n                    node = self._red_left(node)\n                node.left = _delete(node.left)\n            else:\n                if node.left.is_red():\n                    node = self._rotate_right(node)\n                if node.key == key and node.right is Leaf:\n                    return Leaf\n                elif node.right is Leaf:\n                    return self._balance(node)\n                if not self._is_red_right(node):\n                    node = self._red_right(node)\n                if node.key == key:\n                    x = self._find_min(node.right)\n                    node.key = x.key\n                    node.value = x.value\n                    node.right = self._delete_min(node.right)\n                else:\n                    node.right = _delete(node.right)\n\n            return self._balance(node)\n\n        if self.is_empty():\n            raise ValueError('delete on empty tree')\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = _delete(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n        assert self.is_balanced()\n\n    def delete_max(self):\n        if self.is_empty():\n            raise ValueError('delete max on empty tree')\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = self._delete_max(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n        assert self.is_balanced()\n\n    def _delete_max(self, node):\n        if node.left.is_red():\n            node = self._rotate_right(node)\n        if node.right is Leaf:\n            return Leaf\n\n        if not self._is_red_right(node):\n            node = self._red_right(node)\n        node.right = self._delete_max(node.right)\n        return self._balance(node)\n\n    def _red_right(self, node):\n        node = self._flip_colors(node)\n        if node.left.left.is_red():\n            node = self._rotate_right(node)\n        return node\n\n    def _is_red_right(self, node):\n        return (node.right.is_red() or\n                (node.right.is_black() and node.right.left.is_red()))\n\n    def delete_min(self):\n        if self.is_empty():\n            raise ValueError('delete min on empty tree')\n\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = self._delete_min(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n        assert self.is_balanced()\n\n    def _delete_min(self, node):\n        if node.left is Leaf:\n            return Leaf\n\n        if not self._is_red_left(node):\n            node = self._red_left(node)\n        node.left = self._delete_min(node.left)\n        return self._balance(node)\n\n    def _red_left(self, node):\n        node = self._flip_colors(node)\n        if node.right.left.is_red():\n            node.right = self._rotate_right(node.right)\n            node = self._rotate_left(node)\n        return node\n\n    def _is_red_left(self, node):\n        return (node.left.is_red() or\n                (node.left.is_black() and node.left.left.is_red()))\n\n    def _balance(self, node):\n        if node.right.is_red():\n            node = self._rotate_left(node)\n        return self._restore(node)\n\n    def _restore(self, node):\n        if node.right.is_red() and not node.left.is_red():\n            node = self._rotate_left(node)\n        if node.left.is_red() and node.left.left.is_red():\n            node = self._rotate_right(node)\n        if node.left.is_red() and node.right.is_red():\n            node = self._flip_colors(node)\n\n        node.size = node.left.size + node.right.size + 1\n        return node\n\n    def is_empty(self):\n        return self.root is Leaf\n\n    def is_balanced(self):\n        if self.is_empty():\n            return True\n\n        try:\n            left = self._depth(self.root.left)\n            right = self._depth(self.root.right)\n            return left == right\n        except Exception:\n            return False\n\n    @property\n    def depth(self):\n        return self._depth(self.root)\n\n    def _depth(self, node):\n        if node is Leaf:\n            return 0\n        if node.right.is_red():\n            raise Exception('right red')\n        left = self._depth(node.left)\n        right = self._depth(node.right)\n        if left != right:\n            raise Exception('unbalanced')\n        if node.is_red():\n            return left\n        else:\n            return 1 + left\n\n    def __len__(self):\n        return self.root.size\n\n    @property\n    def max(self):\n        if self.is_empty():\n            raise ValueError('max on empty tree')\n        return self._max(self.root)\n\n    def _max(self, node):\n        x = self._find_max(node)\n        return x.key\n\n    def _find_max(self, node):\n        if node.right is Leaf:\n            return node\n        else:\n            return self._find_max(node.right)\n\n    @property\n    def min(self):\n        if self.is_empty():\n            raise ValueError('min on empty tree')\n        return self._min(self.root)\n\n    def _min(self, node):\n        x = self._find_min(node)\n        return x.key\n\n    def _find_min(self, node):\n        if node.left is Leaf:\n            return node\n        else:\n            return self._find_min(node.left)\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is Leaf:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield (node.key, node.value)\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\nclass BalancedBstCounter:\n    def __init__(self):\n        self.bst = RedBlackBinarySearchTree()\n        self.count = 0\n\n    def up(self, key):\n        if key in self.bst:\n            value = self.bst.get(key) + 1\n        else:\n            value = 1\n        self.bst.put(key, value)\n        self.count += 1\n\n    def __contains__(self, key):\n        if key in self.bst:\n            return self.bst.get(key) > 0\n        else:\n            return False\n\n    def get(self, key):\n        if key in self.bst:\n            return self.bst.get(key)\n        else:\n            return 0\n\n    def down(self, key):\n        if key in self.bst:\n            value = self.bst.get(key)\n            self.bst.put(key, 0)\n            self.count -= value\n\n    def range(self, a, b):\n        for k, v in self.bst.range(a, b):\n            for _ in range(v):\n                yield k\n\n    def __len__(self):\n        return self.count\n\n    def __str__(self):\n        return str(self.bst.root)\n\n\ndef run():\n    q = int(input())\n    counter = BalancedBstCounter()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            counter.up(value[0])\n            print(len(counter))\n        elif command == 1:\n            print(counter.get(value[0]))\n        elif command == 2:\n            counter.down(value[0])\n        elif command == 3:\n            for i in counter.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ ITP2_7_D: Multi-Set\n# Python3 2018.6.24 bal4u\n\nfrom bisect import bisect_left, bisect_right, insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n\ta = list(input().split())\n\tki = int(a[1])\n\tif a[0] == '0':\n\t\tif ki not in dict:\n\t\t\tdict[ki] = 1\n\t\t\tinsort_left(keytbl, ki)\n\t\telse: dict[ki] += 1\n\t\tcnt += 1\n\t\tprint(cnt)\n\telif a[0] == '1': print(dict[ki] if ki in dict else 0)\n\telif a[0] == '2':\n\t\tif ki in dict:\n\t\t\tcnt -= dict[ki]\n\t\t\tdict[ki] = 0\n\telse:\n\t\tL = bisect_left (keytbl, int(a[1]))\n\t\tR = bisect_right(keytbl, int(a[2]), L)\n\t\tr = []\n\t\tfor j in range(L, R): r += [keytbl[j]]*dict[keytbl[j]]\n\t\tif r != []: print(*r, sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "\nfrom bisect import *\nimport sys\nn = int(input())\nss = []\ncolor = {}\ncnt = 0\nfor _ in range(n):\n    a, b, *c = map(int,sys.stdin.readline().split())\n    if a == 0:\n        if b not in color:\n            insort_left(ss,b)\n            color[b] = 1\n            cnt += 1\n        else:\n            color[b] += 1\n            cnt += 1\n        print(cnt)\n    elif a == 1:\n        print(color[b] if b in color else 0)\n    elif a == 2:\n        if b in color:\n            cnt -= color[b]\n            color[b] = 0\n    else:\n        L = bisect_left(ss,b)\n        R = bisect(ss,c[0])\n        for i in range(L,R):\n            for _ in range(color[ss[i]]):\n                print(ss[i])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\ns = []\ninput()\n\nfor q in sys.stdin:\n    q = q.split()\n    q[1:] = list(map(int, q[1:]))\n    if q[0] == '0':\n        bisect.insort_left(s, q[1])\n        print(len(s))\n    elif q[0] == '1':\n        first = bisect.bisect_left(s,q[1])\n        end = bisect.bisect_right(s,q[1])\n        print(end - first)\n    elif q[0] == '2':\n        first = bisect.bisect_left(s,q[1])\n        end = bisect.bisect_right(s,q[1])\n        del s[first:end]\n    else:\n        first = bisect.bisect_left(s,q[1])\n        end = bisect.bisect_right(s,q[2])\n        if first != end:\n            print('\\n'.join(list(map(str,[i for i in s[first:end]]))))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\nnq = int(input())\nlines = sys.stdin.readlines()\nans = [None] * nq\narr = []\nfor i in range(nq):\n    q, *arg = lines[i].split()\n    x = int(arg[0])\n    l_idx = bisect.bisect_left(arr, x)\n    r_idx = bisect.bisect_right(arr, x)\n    if q == '0':    # insert x\n        arr.insert(l_idx, x)\n        ans[i] = str(len(arr))\n    elif q == '1':   # find x\n        ans[i] = r_idx - l_idx\n    elif q == '2':           # delete x\n        arr[l_idx:r_idx] = []\n    else:                   # dump L R\n        r_idx = bisect.bisect_right(arr, int(arg[1]))\n        ans[i] = '\\n'.join(map(str, arr[l_idx:r_idx])) if l_idx != r_idx else None\n    #print(q, *arg, '\\t', arr, '\\t', ans[i])\n\n[print(x) for x in ans if x is not None]\n"
  },
  {
    "language": "Python",
    "code": "q = int(input())\ns = []\nrs = []\n\nfor i in range(q):\n    s.append(list(map(int, input().split())))\n    if s[i][0] == 3:\n        rs.append(s[i][1])\n        rs.append(s[i][2])\n    else:\n        rs.append(s[i][1])\n\nrs.append(10 ** 9 + 1)\nrs = sorted(list(set(rs)))\nindex = {rs[i]: i for i in range(len(rs))}\ncounter = [0 for i in range(len(rs) + 1)]\ncnt = 0\nfor i in range(q):\n    op, x = s[i][0], s[i][1]\n    idx = index[x]\n    if op == 0:\n        cnt += 1\n        counter[idx] += 1\n        print(cnt)\n    elif op == 1:\n        print(counter[idx])\n    elif op == 2:\n        cnt -= counter[idx]\n        counter[idx] = 0\n    else:\n        l = idx\n        r = index[s[i][2]]\n        for j in range(l, r + 1):\n            for k in range(counter[j]):\n                print(rs[j])\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom enum import Enum\n\n\nclass Color(Enum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass Node:\n    __slots__ = ('key', 'left', 'right', 'size', 'color', 'value')\n\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.left = Leaf\n        self.right = Leaf\n        self.size = 1\n        self.color = Color.RED\n\n    def is_red(self):\n        return self.color == Color.RED\n\n    def is_black(self):\n        return self.color == Color.BLACK\n\n    def __str__(self):\n        if self.color == Color.RED:\n            key = '*{}'.format(self.key)\n        else:\n            key = '{}'.format(self.key)\n        return \"{}[{}] ({}, {})\".format(key, self.size,\n                                        self.left, self.right)\n\n\nclass LeafNode(Node):\n    def __init__(self):\n        self.key = None\n        self.value = None\n        self.left = None\n        self.right = None\n        self.size = 0\n        self.color = None\n\n    def is_red(self):\n        return False\n\n    def is_black(self):\n        return False\n\n    def __str__(self):\n        return '-'\n\n\nLeaf = LeafNode()\n\n\nclass RedBlackBinarySearchTree:\n    \"\"\"Red Black Binary Search Tree with range, min, max.\n    Originally impremented in the textbook\n    Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,\n    Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.\n    \"\"\"\n\n    def __init__(self):\n        self.root = Leaf\n\n    def put(self, key, value=None):\n        def _put(node):\n            if node is Leaf:\n                node = Node(key, value)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n            else:\n                node.value = value\n\n            node = self._restore(node)\n\n            node.size = node.left.size + node.right.size + 1\n            return node\n\n        self.root = _put(self.root)\n        self.root.color = Color.BLACK\n\n    def _rotate_left(self, node):\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        node.size = node.left.size + node.right.size + 1\n        return x\n\n    def _rotate_right(self, node):\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        node.size = node.left.size + node.right.size + 1\n        return x\n\n    def _flip_colors(self, node):\n        node.color = Color.flip(node.color)\n        node.left.color = Color.flip(node.left.color)\n        node.right.color = Color.flip(node.right.color)\n        return node\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is Leaf:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def get(self, key):\n        def _get(node):\n            if node is Leaf:\n                return None\n            if node.key > key:\n                return _get(node.left)\n            elif node.key < key:\n                return _get(node.right)\n            else:\n                return node.value\n        return _get(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is Leaf:\n                return Leaf\n\n            if node.key > key:\n                if node.left is Leaf:\n                    return self._balance(node)\n                if not self._is_red_left(node):\n                    node = self._red_left(node)\n                node.left = _delete(node.left)\n            else:\n                if node.left.is_red():\n                    node = self._rotate_right(node)\n                if node.key == key and node.right is Leaf:\n                    return Leaf\n                elif node.right is Leaf:\n                    return self._balance(node)\n                if not self._is_red_right(node):\n                    node = self._red_right(node)\n                if node.key == key:\n                    x = self._find_min(node.right)\n                    node.key = x.key\n                    node.value = x.value\n                    node.right = self._delete_min(node.right)\n                else:\n                    node.right = _delete(node.right)\n\n            return self._balance(node)\n\n        if self.is_empty():\n            raise ValueError('delete on empty tree')\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = _delete(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n\n    def delete_max(self):\n        if self.is_empty():\n            raise ValueError('delete max on empty tree')\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = self._delete_max(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n\n    def _delete_max(self, node):\n        if node.left.is_red():\n            node = self._rotate_right(node)\n        if node.right is Leaf:\n            return Leaf\n\n        if not self._is_red_right(node):\n            node = self._red_right(node)\n        node.right = self._delete_max(node.right)\n        return self._balance(node)\n\n    def _red_right(self, node):\n        node = self._flip_colors(node)\n        if node.left.left.is_red():\n            node = self._rotate_right(node)\n        return node\n\n    def _is_red_right(self, node):\n        return (node.right.is_red() or\n                (node.right.is_black() and node.right.left.is_red()))\n\n    def delete_min(self):\n        if self.is_empty():\n            raise ValueError('delete min on empty tree')\n\n        if not self.root.left.is_red() and not self.root.right.is_red():\n            self.root.color = Color.RED\n        self.root = self._delete_min(self.root)\n        if not self.is_empty():\n            self.root.color = Color.BLACK\n\n    def _delete_min(self, node):\n        if node.left is Leaf:\n            return Leaf\n\n        if not self._is_red_left(node):\n            node = self._red_left(node)\n        node.left = self._delete_min(node.left)\n        return self._balance(node)\n\n    def _red_left(self, node):\n        node = self._flip_colors(node)\n        if node.right.left.is_red():\n            node.right = self._rotate_right(node.right)\n            node = self._rotate_left(node)\n        return node\n\n    def _is_red_left(self, node):\n        return (node.left.is_red() or\n                (node.left.is_black() and node.left.left.is_red()))\n\n    def _balance(self, node):\n        if node.right.is_red():\n            node = self._rotate_left(node)\n        return self._restore(node)\n\n    def _restore(self, node):\n        if node.right.is_red() and not node.left.is_red():\n            node = self._rotate_left(node)\n        if node.left.is_red() and node.left.left.is_red():\n            node = self._rotate_right(node)\n        if node.left.is_red() and node.right.is_red():\n            node = self._flip_colors(node)\n\n        node.size = node.left.size + node.right.size + 1\n        return node\n\n    def is_empty(self):\n        return self.root is Leaf\n\n    def is_balanced(self):\n        if self.is_empty():\n            return True\n\n        try:\n            left = self._depth(self.root.left)\n            right = self._depth(self.root.right)\n            return left == right\n        except Exception:\n            return False\n\n    @property\n    def depth(self):\n        return self._depth(self.root)\n\n    def _depth(self, node):\n        if node is Leaf:\n            return 0\n        if node.right.is_red():\n            raise Exception('right red')\n        left = self._depth(node.left)\n        right = self._depth(node.right)\n        if left != right:\n            raise Exception('unbalanced')\n        if node.is_red():\n            return left\n        else:\n            return 1 + left\n\n    def __len__(self):\n        return self.root.size\n\n    @property\n    def max(self):\n        if self.is_empty():\n            raise ValueError('max on empty tree')\n        return self._max(self.root)\n\n    def _max(self, node):\n        x = self._find_max(node)\n        return x.key\n\n    def _find_max(self, node):\n        if node.right is Leaf:\n            return node\n        else:\n            return self._find_max(node.right)\n\n    @property\n    def min(self):\n        if self.is_empty():\n            raise ValueError('min on empty tree')\n        return self._min(self.root)\n\n    def _min(self, node):\n        x = self._find_min(node)\n        return x.key\n\n    def _find_min(self, node):\n        if node.left is Leaf:\n            return node\n        else:\n            return self._find_min(node.left)\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is Leaf:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield (node.key, node.value)\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\nclass BalancedBstCounter:\n    def __init__(self):\n        self.bst = RedBlackBinarySearchTree()\n        self.count = 0\n\n    def up(self, key):\n        if key in self.bst:\n            value = self.bst.get(key) + 1\n        else:\n            value = 1\n        self.bst.put(key, value)\n        self.count += 1\n\n    def __contains__(self, key):\n        if key in self.bst:\n            return self.bst.get(key) > 0\n        else:\n            return False\n\n    def get(self, key):\n        if key in self.bst:\n            return self.bst.get(key)\n        else:\n            return 0\n\n    def down(self, key):\n        if key in self.bst:\n            value = self.bst.get(key)\n            self.bst.put(key, 0)\n            self.count -= value\n\n    def range(self, a, b):\n        for k, v in self.bst.range(a, b):\n            for _ in range(v):\n                yield k\n\n    def __len__(self):\n        return self.count\n\n    def __str__(self):\n        return str(self.bst.root)\n\n\ndef run():\n    q = int(input())\n    counter = BalancedBstCounter()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            counter.up(value[0])\n            print(len(counter))\n        elif command == 1:\n            print(counter.get(value[0]))\n        elif command == 2:\n            counter.down(value[0])\n        elif command == 3:\n            for i in counter.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n\n"
  }
]