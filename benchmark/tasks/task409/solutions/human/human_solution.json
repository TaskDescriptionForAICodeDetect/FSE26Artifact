[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint h,w,n,sx,sy,gx,gy,dp[1111][1111][4],nex[10009][4][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint MIN[4];\nstring t,s[1009];\n\nvoid init(){\n  int pos=0;\n  r(i,4)MIN[i]=1e9;\n  r(i,n+1)r(j,4)r(k,4)nex[i][j][k]=1e9;\n  for(int i=n;i>=1;i--){\n    if(t[i-1]=='R'){\n      for(int i=3;i>1;i--)swap(MIN[(i)%4],MIN[(i-1+4)%4]);\n    }\n    if(t[i-1]=='L'){\n      r(i,3)swap(MIN[i],MIN[(i+1)%4]);\n    }\n    if(t[i-1]=='R')pos=1;\n    if(t[i-1]=='L')pos=3;\n    pos=(pos+4)%4;\n    MIN[pos]=min(MIN[pos],i);\n    r(j,4)r(k,4){\n      if(j<k)nex[i-1][j][k]=MIN[(k-j+4)%4];\n      else nex[i-1][j][k]=MIN[(4-j+k+4)%4];\n    }\n  }\n}\n\nbool dij(){\n  r(i,1111)r(j,1111)r(k,4)dp[i][j][k]=1e9;\n  priority_queue<P,vector<P>,greater<P> >q;\n  while(1){\n    q.push(P(0,sx+sy*10000+0*100000000));\n    dp[sy--][sx][0]=0;\n    if(sy==-1)break;\n    if(s[sy][sx]=='#')break;\n  }\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int x=p.second%10000;\n    int y=(p.second/10000)%10000;\n    int d=p.second/100000000;\n    if(dp[y][x][d]<p.first)continue;\n    r(i,4){\n      if(i==d)continue;\n      if(nex[p.first][d][i]==1e9)continue;\n      int cost=nex[p.first][d][i];\n      int X=x,Y=y;\n      while(1){\n        X+=dx[i];\n        Y+=dy[i];\n        if(X<0||Y<0||X>=w||Y>=h)break;\n        if(s[Y][X]=='#')break;\n        if(dp[Y][X][i]<=cost)continue;\n        dp[Y][X][i]=cost;\n        q.push(P(cost,X+Y*10000+i*100000000));\n      }\n    }\n  }\n  r(i,4)if(dp[gy][gx][i]!=1000000000)return 1;\n  return 0;\n}\n\nsigned main(){\n  while(cin>>h>>w>>n,n){\n    cin>>t;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w){\n      if(s[i][j]=='S')sx=j,sy=i;\n      if(s[i][j]=='G')gx=j,gy=i;\n    }\n    init();\n    cout<<(dij()?\"Yes\":\"No\")<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct State {\n    int x, y, dir, n;\n    State(int x, int y, int dir, int n)\n        : x{x}, y{y}, dir{dir}, n{n} {}\n};\n\nint H, W;\nstring commands;\nvector<vector<char>> field;\nvector<int> dir[4];\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nbool in_field(int x, int y)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid init()\n{\n    for (int i = 0; i < 4; i++) {\n        dir[i].clear();\n    }\n}\n\nvoid make(int N)\n{\n    init();\n    int nd = 1;\n    for (int i = 0; i < N; i++) {\n        if (commands[i] == 'L') {\n            nd = (nd + 3) % 4;\n        } else {\n            nd = (nd + 1) % 4;\n        }\n        dir[nd].emplace_back(i);\n    }    \n}\n\nbool solve(int sx, int sy, int gx, int gy)\n{\n    queue<State> Q;\n    Q.push({sx, sy, 1, 0});\n    vector<vector<vector<bool>>> d(H, vector<vector<bool>>(W, vector<bool>(4, 0)));\n    d[sy][sx][1] = 1;\n\n    while (!Q.empty()) {\n        State s = Q.front(); Q.pop();\n        int x = s.x, y = s.y;\n        if (x == gx && y == gy) return 1;\n        \n        // move forward\n        int nx = s.x + dx[s.dir], ny = s.y + dy[s.dir];\n        if (in_field(nx, ny) && field[ny][nx] != '#' && !d[ny][nx][s.dir]) {\n            d[ny][nx][s.dir] = 1;\n            Q.push({nx, ny, s.dir, s.n});\n        }\n        \n        // turn\n        for (int i = 0; i < 4; i++) {\n            auto np = lower_bound(dir[i].begin(), dir[i].end(), s.n);\n            if (np == dir[i].end()) continue;\n            int nn = np - dir[i].begin();\n            if (!d[y][x][i]) {\n                d[y][x][i] = 1;\n                Q.push({x, y, i, nn + 1});                \n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{\n    int N, sx, sy, gx, gy;\n    while (cin >> H >> W >> N, H) {\n        cin >> commands;\n        field.resize(H);\n        for (int i = 0; i < H; i++) {\n            field[i].resize(W);\n            for (int j = 0; j < W; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == 'S') { \n                    field[i][j] = '.';\n                    sx = j; sy = i;\n                } else if (field[i][j] == 'G') {\n                    field[i][j] = '.';\n                    gx = j; gy = i;\n                }\n            }\n        }\n        make(N);\n        cout << (solve(sx, sy, gx, gy) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct State {\n    int x, y, dir, n;\n    State(int x, int y, int dir, int n)\n        : x{x}, y{y}, dir{dir}, n{n} {}\n};\n\nint H, W;\nstring commands;\nvector<vector<char>> field;\nvector<int> dir[4];\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nbool in_field(int x, int y)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid init()\n{\n    for (int i = 0; i < 4; i++) {\n        dir[i].clear();\n    }\n}\n\nvoid make(int N)\n{\n    init();\n    int nd = 1;\n    for (int i = 0; i < N; i++) {\n        if (commands[i] == 'L') {\n            nd = (nd + 3) % 4;\n        } else {\n            nd = (nd + 1) % 4;\n        }\n        dir[nd].emplace_back(i);\n    }    \n}\n\nbool solve(int sx, int sy, int gx, int gy)\n{\n    queue<State> Q;\n    Q.push({sx, sy, 1, 0});\n    \n    bool d[H][W][4];\n    memset(d, 0, sizeof(d));\n    d[sy][sx][1] = 1;\n\n    while (!Q.empty()) {\n        State s = Q.front(); Q.pop();\n        int x = s.x, y = s.y;\n        if (x == gx && y == gy) return 1;\n        \n        // move forward\n        int nx = s.x + dx[s.dir], ny = s.y + dy[s.dir];\n        if (in_field(nx, ny) && field[ny][nx] != '#' && !d[ny][nx][s.dir]) {\n            d[ny][nx][s.dir] = 1;\n            Q.push({nx, ny, s.dir, s.n});\n        }\n        \n        // turn\n        for (int i = 0; i < 4; i++) {\n            if (i == s.dir) continue;\n            \n            auto np = lower_bound(dir[i].begin(), dir[i].end(), s.n);\n            if (np == dir[i].end()) continue;\n            int nn = np - dir[i].begin();\n            if (!d[y][x][i]) {\n                d[y][x][i] = 1;\n                Q.push({x, y, i, nn + 1});                \n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{\n    int N, sx, sy, gx, gy;\n    while (cin >> H >> W >> N, H) {\n        cin >> commands;\n        field.resize(H);\n        for (int i = 0; i < H; i++) {\n            field[i].resize(W);\n            for (int j = 0; j < W; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == 'S') { \n                    field[i][j] = '.';\n                    sx = j; sy = i;\n                } else if (field[i][j] == 'G') {\n                    field[i][j] = '.';\n                    gx = j; gy = i;\n                }\n            }\n        }\n        make(N);\n        cout << (solve(sx, sy, gx, gy) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nchar dic[]=\"NESW\";\nbool solve(int h,int w,int n){\n    vector<int> com(n);\n    {\n        string buf;\n        cin>>buf;\n        int now=0;\n        for(int i=0;i<n;i++){\n            if(buf[i]=='L') now=(now+4-1)%4;\n            else now=(now+1)%4;\n            com[i]=now;\n        }\n    }\n    Field f(h+2,\"\");\n    for(int i=0;i<h;i++) cin>>f[i+1];\n    for(int i=0;i<h;i++){\n        string tmp=\"#\"+f[i+1]+\"#\";\n        f[i+1]=tmp;\n    }\n    for(int i=0;i<w+2;i++){\n        f[0]+=\"#\";\n        f[h+1]+=\"#\";\n    }\n    h+=2,w+=2;\n\n    vvvi dp(h,vvi(w,vi(4,n+1)));\n    using Item=pair<int,tuple<int,int,int>>;\n    priority_queue<Item,vector<Item>,greater<>> que;\n    int gh,gw;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='S'){\n                dp[i][j][0]=0;\n                que.push({0,make_tuple(i,j,0)});\n            }\n            if(f[i][j]=='G'){\n                gh=i,gw=j;\n            }\n        }\n    }\n    \n    auto push=[&](int i,int j,int iter,int d){\n        if(d<dp[i][j][iter]){\n            dp[i][j][iter]=d;\n            que.push({d,make_tuple(i,j,iter)});\n        }\n    };\n    \n    vvi compos(n+1,vector<int>(4,n));\n    for(int i=n-1;i>=0;i--){\n        compos[i]=compos[i+1];\n        compos[i][com[i]]=i;\n    }\n    while(!que.empty()){\n        int d;\n        tuple<int,int,int> tmp;\n        auto tmptmp=que.top(); que.pop();\n        d=tmptmp.first,tmp=tmptmp.second;\n        int i,j,iter;\n        tie(i,j,iter)=tmp;\n        if(dp[i][j][iter]<d) continue;\n        for(int dir=0;dir<4;dir++){\n            if(compos[d][dir]<n){\n                int toh=i+dh[dir],tow=j+dw[dir];\n                if(f[toh][tow]!='#'){\n                    push(toh,tow,dir,compos[d][dir]+1);\n                }\n            }\n        }\n        int toh=i+dh[iter],tow=j+dw[iter];\n        if(f[toh][tow]!='#') push(toh,tow,iter,d);\n    }\n    return *min_element(dp[gh][gw].begin(),dp[gh][gw].end())<=n;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int h,w,n;\n    while(cin>>h>>w>>n,h){\n        cout<<(solve(h,w,n) ? \"Yes\" : \"No\")<<\"\\n\";\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {0, 1, 0, -1};\nconstexpr int dy[] = {-1, 0, 1, 0};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint turn[128];\n\tturn['L'] = -1;\n\tturn['R'] = 1;\n\n\tfor(int h, w, n; cin >> h >> w >> n && h;) {\n\t\tstring command;\n\t\tcin >> command;\n\n\t\tvector<int> dir(n + 1, 0);\n\t\tarray<vector<int>, 4> get_d;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tget_d[dir[i]].emplace_back(i);\n\t\t\tdir[i + 1] = (dir[i] + turn[command[i]] + 4) % 4;\n\t\t}\n\n\t\tget_d[dir.back()].emplace_back(n);\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\ttypedef tuple<int, int, int> P;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tvector<vector<int>> dist(h, vector<int>(w, n + 1));\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'S') {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tque.push({0, j, i});\n\t\t\t\t\tgoto unloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tunloop:;\n\n\t\twhile(!que.empty()) {\n\t\t\tint di, x, y;\n\t\t\ttie(di, x, y) = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(dist[y][x] < di) continue;\n\n\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || field[ny][nx] == '#') continue;\n\n\t\t\t\tconst auto it = lower_bound(get_d[d].begin(), get_d[d].end(), di);\n\t\t\t\tif(it == get_d[d].end()) continue;\n\n\t\t\t\tif(dist[ny][nx] > *it) {\n\t\t\t\t\tif(field[ny][nx] == 'G') goto ok;\n\t\t\t\t\tdist[ny][nx] = *it;\n\t\t\t\t\tque.push({*it, nx, ny});\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tcout << \"No\" << endl;\n\t\tcontinue;\n\n\tok:;\n\t\tcout << \"Yes\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<vector>\n#include<cstdio>\n\nusing namespace std;\n\nstruct State{\n  int cur,h,w,dir;\n  bool operator < (const State& st) const {\n    return cur > st.cur;\n  }\n};\nconst int NORTH = 0;\nconst int EAST = 1;\nconst int SOUTH = 2;\nconst int WEST = 3;\nconst int SIZE = 1001;\nconst int INF = (1<<25);\nint H,W,N;\nint dh[] = {-1,0,1,0};\nint dw[] = {0,1,0,-1};\nstring command;\nchar field[SIZE][SIZE];\nint sh,sw,gh,gw;\nint T[SIZE][SIZE][4];\n\nbool isInside(int h, int w){return 0<=h&&h<H&&0<=w&&w<W;}\n\nvoid input(){\n  cin >> command;\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){sh=i;sw=j;}\n      if(field[i][j] == 'G'){gh=i;gw=j;}\n    }\n}\n\nbool solve(){\n  fill(T[0][0], T[0][0]+SIZE*SIZE*4, INF);\n  priority_queue<State> Q;\n  Q.push((State){0,sh,sw,NORTH});\n  T[sh][sw][NORTH] = 0;\n\n  while(!Q.empty()){\n    const State now = Q.top(); Q.pop();\n\n    if(now.h == gh && now.w == gw) return true;\n    if(T[now.h][now.w][now.dir] > now.cur) continue;\n   \n    // turn around\n    if(now.cur < (int)command.length()){\n      State nex = now;\n      if(command[now.cur] == 'R') nex.dir = (nex.dir+1)%4;\n      else nex.dir = (nex.dir+3)%4;\n      nex.cur++;\n      if(T[nex.h][nex.w][nex.dir] > nex.cur && field[nex.h][nex.w] != '#'){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n    }\n    \n    // go forward\n    State nex = now;\n    while(isInside(nex.h,nex.w)){\n      if(T[nex.h][nex.w][nex.dir] > nex.cur && field[nex.h][nex.w] != '#'){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n      nex.h += dh[nex.dir];\n      nex.w += dw[nex.dir];\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H|N|W)){\n    input();\n    cout << (solve()?\"Yes\":\"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass S{\npublic:\n  int y, x, d;\n  S(){}\n  S(int y, int x, int d) : y(y), x(x), d(d) {}\n  bool operator < (const S &s) const {\n    if(y == s.y){\n      if(x == s.x){\n        return d < s.d;\n      }\n      return x < s.x;\n    }\n    return y < s.y;\n  }\n};\n\ntypedef pair<int, S> P;\n\nconst int N = 1000;\nconst int M = 1000001;\nconst int MAX_V = N * N * 4;\nconst int INF = 1 << 28;\n\nint V, h, w, n, gx, gy;\nint G[M][4];\nint d[N][N][4];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nchar dat[N][N];\n\nbool dijkstra(S s){\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[0][0], d[N][0], INF);\n  d[s.y][s.x][s.d] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    S v = p.second;\n    if(v.y == gy && v.x == gx) return true;\n    if(d[v.y][v.x][v.d] < p.first) continue;\n    for(int i=0;i<4;i++){\n      int cost = G[p.first][i];\n      if(cost == -1) continue;\n      int ny = v.y + dy[i];\n      int nx = v.x + dx[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(dat[ny][nx] == '#') continue;\n      if(d[ny][nx][i] > d[v.y][v.x][v.d] + cost){\n        d[ny][nx][i] = d[v.y][v.x][v.d] + cost;\n        que.push(P(d[ny][nx][i], S(ny, nx, i)));\n      }\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  fill(G[0], G[M], -1);\n}\n\nmain(){\n  while(cin >> h >> w >> n && (h|w|n)){\n    init();\n    string L;\n    cin >> L;\n    int sy, sx;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> dat[i][j];\n        if(dat[i][j] == 'S'){\n          sy = i;\n          sx = j;\n          dat[i][j] = '.';\n        }\n        if(dat[i][j] == 'G'){\n          gy = i;\n          gx = j;\n          dat[i][j] = '.';\n        }\n      }\n    }\n    vector<int> vec[4];\n    vec[0].push_back(0);\n    int dir = 0;\n    for(int i=0;i<n;i++){\n      if(L[i] == 'L'){\n        dir = (dir + 3) % 4;\n      }else{\n        dir = (dir + 1) % 4;\n      }\n      vec[dir].push_back(i+1);\n    }\n    for(int i=0;i<4;i++){\n      for(int j=0;j<vec[i].size();j++){\n        for(int k=0;k<4;k++){\n          int p = lower_bound(vec[k].begin(), vec[k].end(), vec[i][j]) - vec[k].begin();\n\t\t\t\t\tint tmp = -1;\n\t\t\t\t\tif(p < vec[k].size()){\n\t\t\t\t\t\ttmp = vec[k][p];\n\t\t\t\t\t}\n          G[vec[i][j]][k] = tmp;\n        }\n      }\n    }\n    cout << (dijkstra(S(sy, sx, 0)) ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MAX = 1000;\nconstexpr int INF = 1e9;\n\nstruct State {\n    int x, y, dir, n;\n    State(int x, int y, int dir, int n)\n        : x{x}, y{y}, dir{dir}, n{n} {}\n};\n\nint H, W;\nstring commands;\nchar field[MAX][MAX];\nvector<int> dir[4];\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nbool in_field(int x, int y)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid init()\n{\n    for (int i = 0; i < 4; i++) {\n        dir[i].clear();\n    }\n}\n\nvoid make(int N)\n{\n    init();\n    int nd = 1;\n    for (int i = 0; i < N; i++) {\n        if (commands[i] == 'L') {\n            nd = (nd + 3) % 4;\n        } else {\n            nd = (nd + 1) % 4;\n        }\n        dir[nd].emplace_back(i);\n    }    \n}\n\nbool solve(int sx, int sy, int gx, int gy)\n{\n    queue<State> Q;\n    Q.push({sx, sy, 1, 0});\n    vector<vector<vector<bool>>> d(H, vector<vector<bool>>(W, vector<bool>(4, 0)));\n    d[sy][sx][1] = 1;\n\n    while (!Q.empty()) {\n        State s = Q.front(); Q.pop();\n        int x = s.x, y = s.y;\n        if (x == gx && y == gy) return 1;\n        \n        // move forward\n        int nx = s.x + dx[s.dir], ny = s.y + dy[s.dir];\n        if (in_field(nx, ny) && !d[ny][nx][s.dir]) {\n            d[ny][nx][s.dir] = 1;\n            Q.push({nx, ny, s.dir, s.n});\n        }\n        \n        // turn\n        for (int i = 0; i < 4; i++) {\n            auto np = lower_bound(dir[i].begin(), dir[i].end(), s.n);\n            if (np == dir[i].end()) continue;\n            int nn = np - dir[i].begin();\n            if (!d[y][x][i]) {\n                d[y][x][i] = 1;\n                Q.push({x, y, i, nn});                \n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{\n    int N, sx, sy, gx, gy;\n    while (cin >> H >> W >> N, H) {\n        cin >> commands;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == 'S') { \n                    field[i][j] = '.';\n                    sx = j; sy = i;\n                } else if (field[i][j] == 'G') {\n                    field[i][j] = '.';\n                    gx = j; gy = i;\n                }\n            }\n        }\n        make(N);\n        cout << (solve(sx, sy, gx, gy) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include <queue>\nusing namespace std;\n\nconst int maxn = 1010;\nconst int inf = (1<<30);\nint W,H,N;\n\nchar mp[maxn][maxn];\nchar str[maxn*maxn];\nint dir[maxn*maxn];\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};\n\n\nint cost[maxn*maxn][4];\nint dis[maxn][maxn];\nbool vis[maxn][maxn];\n\nstruct node{\n    int x, y;\n    void init(int __x,int __y)\n    {\n        x = __x;y = __y;\n    }\n}Q[maxn*maxn*3];\n\nint Sx,Sy;\nint Gx,Gy;\n\nint main()\n{\n    while (scanf(\"%d%d%d\",&W,&H,&N)==3 && W)\n    {\n        scanf(\"%s\",str);\n\n\n        dir[0] = 0;\n        for (int i=1;i<=N;i++)\n        {\n            if (str[i-1]=='L'){\n                dir[i] = (dir[i-1] + 3) % 4;\n            }else{\n                dir[i] = (dir[i-1] + 1) % 4;\n            }\n        }\n\n\n        for (int i=0;i<=W+1;i++)\n        {\n            for (int j=0;j<=H+1;j++)\n            {\n                mp[i][j] = '#';\n            }\n        }\n        for (int i=1;i<=W;i++)\n        {\n            scanf(\"%s\",str);\n            for (int j=1;j<=H;j++)\n            {\n                mp[i][j] = str[j-1];\n                if (mp[i][j]=='S')\n                {\n                    Sx = i;\n                    Sy = j;\n                    mp[i][j] = '.';\n                }else if (mp[i][j]=='G'){\n                    Gx = i;Gy = j;\n                    mp[i][j] = '.';\n                }\n            }\n        }\n#ifdef debug\n        for (int i=0;i<=W+1;i++)\n        {\n            for (int j=0;j<=H+1;j++)\n            {\n                printf(\"%c\",mp[i][j]);\n            }\n            puts(\"\");\n        }\n        printf(\"%d %d %d %d\\n\",Sx,Sy,Gx,Gy);\n #endif\n\n        for (int i=N;i>=0;i--)\n        {\n            for (int j=0;j<4;j++)\n            {\n                if (dir[i]==j){\n                    cost[i][j] = 0;\n                }else{\n                    if (i==N){\n                        cost[i][j] = inf;\n                    }else{\n                        cost[i][j] = cost[i+1][j] + 1;\n                    }\n                }\n                //if (debug)printf(\"%d %d %d\\n\",i,j,cost[i][j]);\n            }\n        }\n\n        node now, cur;\n        int ans = 0;\n        int head = 0, tail = 0;\n        memset(dis, -1, sizeof(dis));\n        memset(vis, 0, sizeof(vis));\n        now.init(Sx,Sy);\n        dis[Sx][Sy] = 0;\n        vis[Sx][Sy] = 1;\n        Q[++tail] = now;\n\n        while (head < tail)\n        {\n            cur = Q[++head];\n            int dd = dis[cur.x][cur.y];\n            vis[cur.x][cur.y] = 0;\n            for (int k=0;k<4;k++)\n            {\n                int x = cur.x + dx[k];\n                int y = cur.y + dy[k];\n                if (mp[x][y]=='.' && cost[dd][k]<inf){\n                    int tmp = dd + cost[dd][k];\n                    if (dis[x][y]==-1 || tmp < dis[x][y]){\n                        dis[x][y] = tmp;\n                        if (!vis[x][y]){\n                            now.init(x,y);\n                            Q[++tail] = now;\n                            vis[x][y] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        ans = (dis[Gx][Gy] != -1);\n        puts(ans?\"Yes\":\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,N;\nstring o,s[1000];\nbool vis[1000][1000];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nbool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\ntypedef pair<int,int> P;\nvector<P> vc[1000001];\nint main(){\n\twhile(true){\n\t\tcin>>H>>W>>N;\n\t\tif(H==0) break;\n\t\trep(i,N+1) vc[i].clear();\n\t\trep(i,H) rep(j,W) vis[i][j]=0;\n\t\tcin>>o;\n\t\trep(i,H) cin>>s[i];\n\t\trep(i,H) rep(j,W) if(s[i][j]=='S'){\n\t\t\tint x=i,y=j;\n\t\t\twhile(is(x,y)){\n\t\t\t\tvc[0].pb(P(x,y)),vis[x][y]=1;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\tint e[4]={0,-1,-1,-1};\n\t\tint D=0;\n\t\trep1(i,N){\n\t\t\tD=(D+(o[i-1]=='L'?1:3))%4;\n\t\t\tfor(int j=e[D]+1;j<i;j++){\n\t\t\t\tfor(P p:vc[j]){\n\t\t\t\t\tint x=p.fs+dx[D],y=p.sc+dy[D];\n\t\t\t\t\twhile(is(x,y)&&!vis[x][y]){\n\t\t\t\t\t\tvis[x][y]=1;\n\t\t\t\t\t\tvc[i].pb(P(x,y));\n\t\t\t\t\t\tx+=dx[D],y+=dy[D];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te[D]=i;\n\t\t}\n\t\trep(i,H) rep(j,W) if(s[i][j]=='G'){\n\t\t\tif(vis[i][j]) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sst stringstream\n#define sz size()\n#define vc vector\ntypedef vc<int> vi;\ntypedef vc<ll> vl;\ntypedef vc<string> vs;\n\nint H,W,N;\nchar s[1000010],c[1010][1010];\nint sy,sx,gy,gx;\nint dir[1000010],cost[1000010][4],dist[1010][1010];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\ntypedef pair<int,pi> T;\n\nint main(){\n\twhile(cin>>H>>W>>N && H){\n\t\trep(i,N)cin>>s[i];\n\t\trep(i,H+2)rep(j,W+2)c[i][j]='#';\n\t\trep2(i,1,H+1)rep2(j,1,W+1){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]=='S')sy=i,sx=j,c[i][j]='.';\n\t\t\tif(c[i][j]=='G')gy=i,gx=j,c[i][j]='.';\n\t\t}\n\t\t\n\t\tdir[0]=3;\n\t\trep(i,N){\n\t\t\tif(s[i]=='L')dir[i+1]=(dir[i]+3)%4;\n\t\t\telse dir[i+1]=(dir[i]+1)%4;\n\t\t}\n\t\tfor(int i=N;i>=0;i--){\n\t\t\trep(j,4){\n\t\t\t\tif(j==dir[i])cost[i][j]=0;\n\t\t\t\telse{\n\t\t\t\t\tif(i==N)cost[i][j]=INF;\n\t\t\t\t\telse cost[i][j]=cost[i+1][j]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,H+2)rep(j,W+2)dist[i][j]=INF;\n\t\tdist[sy][sx]=0;\n\t\tpriority_queue<T,vector<T>,greater<T> > Q;\n\t\tQ.push(T(0,pi(sy,sx)));\n\t\twhile(Q.sz){\n\t\t\tT is=Q.top();\n\t\t\tQ.pop();\n\t\t\tint dis=is.fir;\n\t\t\tpi st=is.sec;\n\t\t\tif(dist[st.fir][st.sec] < dis)continue;\n\t\t\tcout<<dis<<\" \"<<st.fir<<\" \"<<st.sec<<endl;\n\t\t\tif(st.sec==gy && st.sec==gx){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,4){\n\t\t\t\tint ny=st.fir+dy[i],nx=st.sec+dx[i];\n\t\t\t\tif(c[ny][nx]=='#')continue;\n\t\t\t\tif(dis + cost[dis][i] < dist[ny][nx]){\n\t\t\t\t\tdist[ny][nx] = dis + cost[dis][i];\n\t\t\t\t\tQ.push(T(dist[ny][nx],pi(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint n;\n\tint w;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.n> r.n;\n\t}\n};\n\n\nvector<vector<int>>wheres(4);\nvector<vector<int>>anext;\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\tanext.clear();\n\t\twheres.resize(4);\n\t\tif (!H)break;\n\t\tstring st;\n\t\tcin >> st;\n\t\tint way = 3;\n\t\tvector<int>ways;\n\t\tways.push_back(way);\n\t\twheres[way].push_back(0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'L') {\n\t\t\t\tway = (way + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway = (way + 3) % 4;\n\t\t\t}\n\t\t\tways.push_back(way);\n\t\t\twheres[way].push_back(i + 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tvector<int>v;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tauto it = upper_bound(wheres[j].begin(), wheres[j].end(), i);\n\t\t\t\tif (it == wheres[j].end())v.push_back(1e8);\n\t\t\t\telse v.push_back(*it);\n\t\t\t}\n\t\t\tfor (int j = 0; j < ways[i]; ++j) {\n\t\t\t\trotate(v.begin(), v.end(),v.end());\n\t\t\t}\n\t\t\tanext.push_back(v);\n\t\t}\n\t\twheres.clear();\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int x = 0; x <= W + 1; ++x) {\n\t\t\tint y = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\ty = H + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tfor (int y = 0; y <= H + 1; ++y) {\n\t\t\tint x = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\tx = W + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tint memo[1001][1001][4];\n\t\tfor (int i = 0; i < 1001; ++i) {\n\t\t\tfor (int j = 0; j < 1001; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tmemo[i][j][k] = 1e8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint gx, gy;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring ast; cin >> ast;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (ast[j] == 'G') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == 'S') {\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == '#') {\n\t\t\t\t\tfield[i + 1][j+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sx,sy,0 ,3});\n\t\tmemo[sy][sx][3] = 0;\n\t\tstring ans = \"No\";\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int px = atop.x;\n\t\t\tconst int py = atop.y;\n\t\t\tconst int pn = atop.n;\n\t\t\tconst int pw = atop.w;\n\t\t\tif (px == gx&&py == gy) {\n\t\t\t\tans = \"Yes\"; break;\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nx = px + dx[pw];\n\t\t\t\tconst int ny = py + dy[pw];\n\t\t\t\tif (!field[ny][nx]) {\n\t\t\t\t\tif (memo[ny][nx][pw] > pn) {\n\t\t\t\t\t\tmemo[ny][nx][pw] = pn;\n\t\t\t\t\t\tque.push(aa{ nx,ny,pn,pw });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pn != N) {\n\t\t\t\tfor (int i = 0; i<4; ++i) {\n\t\t\t\t\tif (anext[pn][i]<1e8) {\n\t\t\t\t\t\tif (memo[py][px][i] >anext[pn][i]) {\n\t\t\t\t\t\t\tmemo[py][px][i] = anext[pn][i];\n\t\t\t\t\t\t\tque.push(aa{ px,py,anext[pn][i],i });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\nbool bfs(){\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t// cang==oagn\n\tfor(int i=0;i<4;i++)for(int j=0;j<=n;j++)toAng[i][i][j]=j;\n\t// cang!=oang&&pos==n\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n\tfor(int k=n-1;k>=0;k--){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tint nang;\n\t\t\t\tint cang=i;\n\t\t\t\tint oang=j;\n\t\t\t\tint pos=k;\n\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\t\t\t\telse nang=(cang+1)%4;\n\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n\t\t\t}\n\t\t}\n\t}\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii>,vector<pair<pii,pii> >,greater<pair<pii,pii> > > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(0,0),pii(sy,sx)));\n\td[0][sy][sx]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.second.second;\n\t\tint cy=p.second.first;\n\t\tint cang=p.first.second;\n\t\tint cpos=p.first.first;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cang][cy][cx]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=toAng[cang][nang][cpos];\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[nang][ny][nx]>npos){\n\t\t\t\td[nang][ny][nx]=npos;\n\t\t\t\tpq.push(make_pair(pii(npos,nang),pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[i][gy][gx]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct State{\n  int cur,h,w,dir;\n  bool operator < (const State& st) const {\n    return cur > st.cur;\n  }\n};\nconst int NORTH = 0;\nconst int EAST = 1;\nconst int SOUTH = 2;\nconst int WEST = 3;\nconst int SIZE = 1001;\nconst int INF = (1<<25);\nint H,W,N;\nint dh[] = {-1,0,1,0};\nint dw[] = {0,1,0,-1};\nstring command;\nchar field[SIZE][SIZE];\nint sh,sw,gh,gw;\nint T[SIZE][SIZE][4];\n\nbool isInside(int h, int w){return 0<=h&&h<H&&0<=w&&w<W;}\n\nvoid input(){\n  cin >> command;\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){sh=i;sw=j;}\n      if(field[i][j] == 'G'){gh=i;gw=j;}\n    }\n}\n\nvoid solve(){\n  fill(T[0][0], T[0][0]+SIZE*SIZE*4, INF);\n  priority_queue<State> Q;\n  Q.push((State){0,sh,sw,NORTH});\n  T[sh][sw][NORTH] = 0;\n\n  while(!Q.empty()){\n    const State now = Q.top(); Q.pop();\n\n    if(T[now.h][now.w][now.dir] > now.cur) continue;\n\n   \n    // turn around\n    if(now.cur < (int)command.length()){\n      State nex = now;\n      if(command[now.cur] == 'R') nex.dir = (nex.dir+1)%4;\n      else nex.dir = (nex.dir+3)%4;\n      nex.cur++;\n      if(T[nex.h][nex.w][nex.dir] > nex.cur && field[nex.h][nex.w] != '#'){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n    }\n    \n    // go forward\n    State nex = now;\n    while(isInside(nex.h,nex.w)){\n      if(T[nex.h][nex.w][nex.dir] > nex.cur && field[nex.h][nex.w] != '#'){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n      nex.h += dh[nex.dir];\n      nex.w += dw[nex.dir];\n    }\n  }\n  int ans = INF;\n  for(int i = 0; i < 4; i++) ans = min(ans,T[gh][gw][i]);\n  cout << (ans==INF?\"No\":\"Yes\") << endl;    \n}\n\nint main(){\n  while(cin >> H >> W >> N && (H|N|W)){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[1010][1010];\nchar com[1010100];\nint dx[]={-1,0,1,0};\nint dy[]={0,1,0,-1};\nint ijk[1010][1010][4];\nint v[1010][1010][4];\nint cost[1010100][4];\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tscanf(\"%s\",com);\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tint sr,sc;\n\t\tint gr,gc;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='S'){sr=i;sc=j;}\n\t\t\tif(str[i][j]=='G'){gr=i;gc=j;}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++)ijk[i][j][k]=999999999;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++)v[i][j][k]=0;\n\t\tfor(int i=0;i<=c;i++)for(int j=0;j<4;j++)cost[i][j]=999999999;\n\t\tfor(int i=c-1;i>=0;i--){\n\t\t\tif(com[i]=='R')cost[i][1]=i+1;\n\t\t\telse cost[i][3]=i+1;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(com[i]=='R')cost[i][(j+1)%4]=min(cost[i][(j+1)%4],cost[i+1][j]);\n\t\t\t\telse cost[i][(j+3)%4]=min(cost[i][(j+3)%4],cost[i+1][j]);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int> > >Q;\n\t\tijk[sr][sc][0]=0;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(sr,sc)));\n\t\twhile(Q.size()){\n\t\t\tint co=-Q.top().first.first;\n\t\t\tint dir=Q.top().first.second;\n\t\t\tint row=Q.top().second.first;\n\t\t\tint col=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[row][col][dir])continue;\n\t\t\tv[row][col][dir]=1;\n\t\t\tif(0<=row+dx[dir]&&row+dx[dir]<a&&0<=col+dy[dir]&&col+dy[dir]<b&&str[row+dx[dir]][col+dy[dir]]!='#'&&!v[row+dx[dir]][col+dy[dir]][dir]&&ijk[row+dx[dir]][col+dy[dir]][dir]>co){\n\t\t\t\tijk[row+dx[dir]][col+dy[dir]][dir]=co;\n\t\t\t\tQ.push(make_pair(make_pair(-co,dir),make_pair(row+dx[dir],col+dy[dir])));\n\t\t\t}\n\t\t\tif(!v[row][col][(dir+1)%4]&&ijk[row][col][(dir+1)%4]>cost[co][1]&&cost[co][1]<9999999){\n\t\t\t\tijk[row][col][(dir+1)%4]=cost[co][1];\n\t\t\t\tQ.push(make_pair(make_pair(-cost[co][1],(dir+1)%4),make_pair(row,col)));\n\t\t\t}\n\t\t\tif(!v[row][col][(dir+3)%4]&&ijk[row][col][(dir+3)%4]>cost[co][3]&&cost[co][3]<9999999){\n\t\t\t\tijk[row][col][(dir+3)%4]=cost[co][3];\n\t\t\t\tQ.push(make_pair(make_pair(-cost[co][3],(dir+3)%4),make_pair(row,col)));\n\t\t\t}\n\t\t}\n\t\tif(v[gr][gc][0]||v[gr][gc][1]||v[gr][gc][2]||v[gr][gc][3])printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <set>\n#include <stack>\n\nusing namespace std;\n#define ll long long \n#define eps 1e-8\n#define inf 0x3f3f3f3f\n#define N 1005\n#define M 1000010\n#define mod 1000000007\n#define MP make_pair\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, 1, 0, -1 };\nint n, m, L;\nchar str[M];\nchar s[N][N];\nint lft[M], rht[M];\nvoid init()\n{\n\tint i = 0, j = 0;\n\tint cnt = 0;\n\tfor( ; i < L; ++i ){\n\t\twhile( j < L && cnt < 1 ){\n\t\t\tif( str[j] == 'L' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 1 ) lft[i] = j;\n\t\telse lft[i] = M;\n\t\tif( str[i] == 'L' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = cnt = j = 0; i < L; ++i ){\n\t\twhile( j < L && cnt < 1 ){\n\t\t\tif( str[i] == 'R' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 1 ) rht[i] = j;\n\t\telse rht[i] = M;\n\t\tif( str[i] == 'R' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = j = cnt = 0; i < L; ++i ){\n\t\twhile( j < L && cnt < 3 ){\n\t\t\tif( str[j] == 'L' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 3 ) rht[i] = min( rht[i], j );\n\t\t//else lft[i] = M;\n\t\tif( str[i] == 'L' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = cnt = j = 0; i < L; ++i ){\n\t\twhile( j < L && cnt < 3 ){\n\t\t\tif( str[i] == 'R' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 3 ) lft[i] = min( lft[i], j );\n\t\t//else rht[i] = M;\n\t\tif( str[i] == 'R' ) --cnt;\n\t\telse ++cnt;\n\t}\n}\nint dis[N][N][4], vis[N][N][4];\nint in( int x, int y )\n{\n\treturn x >= 0 && x < n && y >= 0 && y < m;\n}\nint solve( int x, int y, int ex, int ey )\n{\n\tqueue<int> q;\n\tint x1, y1, d, d1;\n\tint tmp;\n\tq.push( x ), q.push( y ), q.push( 0 );\n\tmemset( dis, -1, sizeof(dis) );\n\tmemset( vis, 0, sizeof(vis) );\n\tdis[x][y][0] = 0;\n\twhile( !q.empty() ){\n\t\tx = q.front(), q.pop();\n\t\ty = q.front(), q.pop();\n\t\td = q.front(), q.pop();\n\t\tvis[x][y][d] = 0;\n\t\tx1 = x + dx[d];\n\t\ty1 = y + dy[d];\n\t\td1 = d;\n\t\tif( in( x1, y1 ) && s[x1][y1] != '#' ){\n\t\t\tif( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > dis[x][y][d] ){\n\t\t\t\tdis[x1][y1][d1] = dis[x][y][d];\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t\t}\n\t\t}\n\t\tif( dis[x][y][d] >= L ) continue;\n\t\tx1 = x, y1 = y;\n\t\ttmp = lft[dis[x][y][d]]; d1 = ( d - 1 + 4 ) % 4;\n\t\tif( tmp != M && ( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > tmp )  ){\n\t\t\t\tdis[x1][y1][d1] = tmp;\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t}\n\t\ttmp = rht[dis[x][y][d]], d1 = ( d + 1 ) % 4;\n\t\tif( tmp != M && ( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > tmp )  ){\n\t\t\t\tdis[x1][y1][d1] = tmp;\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint x, y, ex, ey;\n\twhile( scanf( \"%d%d%d\", &n, &m, &L ) == 3 && n+m+L ){\n\t\tscanf( \"%s\", str );\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf( \"%s\", s[i] );\n\t\t\tfor( int j = 0; j < m; ++j ){\n\t\t\t\tif( s[i][j] == 'S' ) x = i, y = j;\n\t\t\t\tif( s[i][j] == 'G' ) ex = i, ey = j;\n\t\t\t}\n\t\t}\n\t\tinit();\n\t\tif( solve( x, y, ex, ey ) ) puts( \"Yes\" );\n\t\telse puts( \"No\" );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {0, 1, 0, -1};\nconstexpr int dy[] = {-1, 0, 1, 0};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint turn[128];\n\tturn['L'] = -1;\n\tturn['R'] = 1;\n\n\tfor(int h, w, n; cin >> h >> w >> n && h;) {\n\t\tstring command;\n\t\tcin >> command;\n\n\t\tvector<int> dir(n + 1, 0);\n\t\tarray<vector<int>, 4> get_d;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tget_d[dir[i]].emplace_back(i);\n\t\t\tdir[i + 1] = (dir[i] + turn[command[i]] + 4) % 4;\n\t\t}\n\n\t\tget_d[dir.back()].emplace_back(n);\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\ttypedef pair<int, int> P;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tvector<vector<int>> dist(h, vector<int>(w, n + 1));\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'S') {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tque.push({j, i});\n\t\t\t\t\tgoto unloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tunloop:;\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int x = que.top().first;\n\t\t\tconst int y = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n\n\t\t\t\tconst auto it = lower_bound(get_d[d].begin(), get_d[d].end(), dist[y][x]);\n\t\t\t\tif(it == get_d[d].end()) continue;\n\n\t\t\t\tif(dist[ny][nx] > *it) {\n\t\t\t\t\tif(field[ny][nx] == 'G') goto ok;\n\t\t\t\t\tdist[ny][nx] = *it;\n\t\t\t\t\tque.push({nx, ny});\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tcout << \"No\" << endl;\n\t\tcontinue;\n\n\tok:;\n\t\tcout << \"Yes\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<vector>\n#include<cstdio>\n\nusing namespace std;\n\nstruct State{\n  int cur,h,w,dir;\n  bool operator < (const State& st) const {\n    return cur > st.cur;\n  }\n};\nconst int NORTH = 0;\nconst int EAST = 1;\nconst int SOUTH = 2;\nconst int WEST = 3;\nconst int SIZE = 1001;\nconst int INF = (1<<25);\nint H,W,N;\nint dh[] = {-1,0,1,0};\nint dw[] = {0,1,0,-1};\nstring command;\nchar field[SIZE][SIZE];\nint sh,sw,gh,gw;\nint T[SIZE][SIZE][4];\n\nbool isInside(int h, int w){return 0<=h&&h<H&&0<=w&&w<W;}\n\nvoid input(){\n  cin >> command;\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){sh=i;sw=j;}\n      if(field[i][j] == 'G'){gh=i;gw=j;}\n    }\n}\n\nbool solve(){\n  fill(T[0][0], T[0][0]+SIZE*SIZE*4, INF);\n  priority_queue<State> Q;\n  Q.push((State){0,sh,sw,NORTH});\n  T[sh][sw][NORTH] = 0;\n\n  while(!Q.empty()){\n    const State now = Q.top(); Q.pop();\n\n    if(now.h == gh && now.w == gw) return true;\n    if(T[now.h][now.w][now.dir] > now.cur) continue;\n   \n    // turn around\n    if(now.cur < (int)command.length()){\n      State nex = now;\n      if(command[now.cur] == 'R') nex.dir = (nex.dir+1)%4;\n      else nex.dir = (nex.dir+3)%4;\n      nex.cur++;\n      if(T[nex.h][nex.w][nex.dir] > nex.cur){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n    }\n    \n    // go forward\n    State nex = now;\n    while(isInside(nex.h,nex.w) && field[nex.h][nex.w] != '#'){\n      if(T[nex.h][nex.w][nex.dir] > nex.cur){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n      nex.h += dh[nex.dir];\n      nex.w += dw[nex.dir];\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H|N|W)){\n    input();\n    cout << (solve()?\"Yes\":\"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint n;\n\tint w;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.n> r.n;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\tif (!H)break;\n\t\tstring st;\n\t\tcin >> st;\n\t\tint way = 3;\n\t\tvector<vector<int>>wheres(4);\n\t\tvector<int>ways;\n\t\tways.push_back(way);\n\t\twheres[way].push_back(0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'L') {\n\t\t\t\tway = (way + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway = (way + 3) % 4;\n\t\t\t}\n\t\t\tways.push_back(way);\n\t\t\twheres[way].push_back(i + 1);\n\t\t}\n\t\tvector<vector<int>>next;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tvector<int>v;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tauto it = upper_bound(wheres[j].begin(), wheres[j].end(), i);\n\t\t\t\tif (it == wheres[j].end())v.push_back(1e8);\n\t\t\t\telse v.push_back(*it);\n\t\t\t}\n\t\t\tfor (int j = 0; j < ways[i]; ++j) {\n\t\t\t\trotate(v.begin(), v.end(),v.end());\n\t\t\t}\n\t\t\tnext.push_back(v);\n\t\t}\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int x = 0; x <= W + 1; ++x) {\n\t\t\tint y = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\ty = H + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tfor (int y = 0; y <= H + 1; ++y) {\n\t\t\tint x = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\tx = W + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tvector<vector<vector<int>>>memo(H + 2, vector<vector<int>>(W + 2,vector<int>(4,1e8)));\n\t\tint gx, gy;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring ast; cin >> ast;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (ast[j] == 'G') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == 'S') {\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == '#') {\n\t\t\t\t\tfield[i + 1][j+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sx,sy,0 ,3});\n\t\tmemo[sy][sx][3] = 0;\n\t\tstring ans = \"No\";\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int px = atop.x;\n\t\t\tconst int py = atop.y;\n\t\t\tconst int pn = atop.n;\n\t\t\tconst int pw = atop.w;\n\t\t\tif (px == gx&&py == gy) {\n\t\t\t\tans = \"Yes\"; break;\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nx = px + dx[pw];\n\t\t\t\tconst int ny = py + dy[pw];\n\t\t\t\tif (!field[ny][nx]) {\n\t\t\t\t\tif (memo[ny][nx][pw] > pn) {\n\t\t\t\t\t\tmemo[ny][nx][pw] = pn;\n\t\t\t\t\t\tque.push(aa{ nx,ny,pn,pw });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pn != N) {\n\t\t\t\tfor (int i = 0; i<4; ++i) {\n\t\t\t\t\tif (next[pn][i]<1e8) {\n\t\t\t\t\t\tif (memo[py][px][i] >next[pn][i]) {\n\t\t\t\t\t\t\tmemo[py][px][i] = next[pn][i];\n\t\t\t\t\t\t\tque.push(aa{ px,py,next[pn][i],i });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include <string>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#define INF 0xfffffff\n#define CL(x,v); memset(x,v,sizeof(x));\n#define LL long long\n#define REP(i,r,n) for(int i=r;i<=n;i++)\n#define RREP(i,n,r) for(int i=n;i>=r;i--)\n#define max(x,y) x>y?x:y\n#define min(x,y) x<y?x:y\n#define EPS 1e-8\nusing namespace std;\nint sx,sy,ex,ey;\nint ok=0;\nint d[4][2]={-1,0,0,1,1,0,0,-1};//蟾ヲ霓ャ譏ッ-1?悟承霓ャ+1\nchar Map[1001][1001];\nint vis[1001][1001];\nchar oper[1000001];\nint h,w,n;\nvoid dfs(int cur,int x,int y,int dir)\n{\n    if(x==ex&&y==ey)ok=1;\n    if(cur>n)return ;\n    for(int i=0;;i++){\n        int newx=x+d[dir][0]*i;\n        int newy=y+d[dir][1]*i;\n        if(newx<0||newx>=h||newy<0||newy>=w||Map[newx][newy]=='#'||vis[newx][newy])break;\n        int newDir=(dir+oper[cur]+4)%4;\n        vis[newx][newy]=1;\n        dfs(cur+1,newx,newy,newDir);\n        vis[newx][newy]=0;\n    }\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&h,&w,&n)!=EOF)\n    {\n        if(h==0&&w==0&&n==0)return 0;\n        memset(vis,0,sizeof(vis));\n        scanf(\"%s\",oper);\n        for(int i=0;i<strlen(oper);i++){\n            if(oper[i]=='L')oper[i]=-1;\n            else oper[i]=1;\n        }\n        for(int i=0;i<h;i++)\n        {\n            scanf(\"%s\",Map[i]);\n            for(int j=0;j<w;j++){\n                if(Map[i][j]=='S'){sx=i;sy=j;}\n                else if(Map[i][j]=='G'){ex=i;ey=j;}\n            }\n        }\n        ok=0;\n        dfs(0,sx,sy,0);\n        if(ok)printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sst stringstream\n#define sz size()\n#define vc vector\ntypedef vc<int> vi;\ntypedef vc<ll> vl;\ntypedef vc<string> vs;\n\nint H,W,N;\nchar s[1000010],c[1010][1010];\nint sy,sx,gy,gx;\nint dir[1000010],cost[1000010][4],dist[1010][1010];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\ntypedef pair<int,pi> T;\n\nint main(){\n\twhile(cin>>H>>W>>N && H){\n\t\trep(i,N)cin>>s[i];\n\t\trep(i,H+2)rep(j,W+2)c[i][j]='#';\n\t\trep2(i,1,H+1)rep2(j,1,W+1){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]=='S')sy=i,sx=j,c[i][j]='.';\n\t\t\tif(c[i][j]=='G')gy=i,gx=j,c[i][j]='.';\n\t\t}\n\t\t\n\t\tdir[0]=3;\n\t\trep(i,N){\n\t\t\tif(s[i]=='L')dir[i+1]=(dir[i]+3)%4;\n\t\t\telse dir[i+1]=(dir[i]+1)%4;\n\t\t}\n\t\tfor(int i=N;i>=0;i--){\n\t\t\trep(j,4){\n\t\t\t\tif(j==dir[i])cost[i][j]=0;\n\t\t\t\telse{\n\t\t\t\t\tif(i==N)cost[i][j]=INF;\n\t\t\t\t\telse cost[i][j]=cost[i+1][j]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,H+2)rep(j,W+2)dist[i][j]=INF;\n\t\tdist[sy][sx]=0;\n\t\tpriority_queue<T,vector<T>,greater<T> > Q;\n\t\tQ.push(T(0,pi(sy,sx)));\n\t\twhile(Q.sz){\n\t\t\tT is=Q.top();\n\t\t\tQ.pop();\n\t\t\tint dis=is.fir;\n\t\t\tpi st=is.sec;\n\t\t\tif(dist[st.fir][st.sec] < dis)continue;\n\t\t\tif(st.fir==gy && st.sec==gx){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,4){\n\t\t\t\tint ny=st.fir+dy[i],nx=st.sec+dx[i];\n\t\t\t\tif(c[ny][nx]=='#')continue;\n\t\t\t\tif(dis + cost[dis][i] < dist[ny][nx]){\n\t\t\t\t\tdist[ny][nx] = dis + cost[dis][i];\n\t\t\t\t\tQ.push(T(dist[ny][nx],pi(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar fie[1001][1001];\nint H,W,N;\nint memo[1001][1001];\nchar S[1000001];\nint Ds[1000001][4];\n\nint dx[]={0,1,0,-1};//R -> +1 , L -> +1\nint dy[]={-1,0,1,0};\n\nint sx,sy,gx,gy;\n\nstruct state{\n  int x,y,c;\n  bool operator>(const state &st) const{\n    return c > st.c;\n  }\n\n};\n\nbool check( int x,int y,int nc){\n  if( x < 0 || y < 0 || x >= W || y >= H ) return false;\n  if( fie[x][y] == '#' ) return false;\n  if( memo[x][y] == -1 ) return true;\n  if( memo[x][y] <= nc ) return false;\n  return true; \n}\n\n\n\nbool bfs(){\n\n  memset(memo,-1,sizeof(memo));\n\n  priority_queue<state,vector<state>,greater<state> > q;\n\n  q.push( (state){sx,sy,0} );\n  memo[sx][sy] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    int x = p.x;\n    int y = p.y;\n    int c = p.c;\n\n    //  cout << x<< \" \" << y << \" \"<< c << endl;\n\n    for(int i=0;i<4;i++){\n      int nd = i;\n      int nc = Ds[c][nd];\n      if( nc > N ) continue;\n      int nx = x+dx[nd];\n      int ny = y+dy[nd];\n      if( check(nx,ny,nc) ){\n\tq.push( (state){nx,ny,nc} );\n\tmemo[nx][ny] = nc;\n      }\n    }\n  }\n  if( memo[gx][gy] == -1 )\n    return false;\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H||W||N) ){\n    for(int i=1;i<=N;i++){\n      cin >> S[i];\n    }\n    S[0] = 0;\n    int dnc = 0;\n    for(int i=1;i<=N;i++){\n      if( S[i] == 'L' ){\n\tdnc+=3;\t \n      } else {\n\tdnc++;\n      }\n      dnc %= 4;\n      S[i] = (char)dnc;\n    }\n    \n    int dc[4] = {N+1,N+1,N+1,N+1};\n    for(int i=N;i>-1;i--){\n      dc[(int)S[i]] = i;\n      for(int j=0;j<4;j++){\n\tDs[i][j] = dc[j];\n\t//\tprintf(\"%d, %d  %d\\n\",i-1,j,(int)Ds[i-1][j]);\n      }\n    }\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[j][i];\n\tif( fie[j][i] == 'G' ){\n\t  gx=j;\n\t  gy=i;\n\t}\n\tif( fie[j][i] == 'S' ){\n\t  sx = j;\n\t  sy = i;\n\t}\n      }\n    }\n    \n    if( bfs() ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w, n, next[1000001][4];\nstring s, in[1000];\nbool v[1000][1000][4];\n\n\nint main(){\n\twhile(cin >> h >> w >> n, h){\n\t\tmemset(v, 0, sizeof(v));\n\t\tint y, x, d = 0;\n\t\tcin >> s;\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t\t}\n\t\trep(i, n) d = (d + (s[i] == 'L' ? 1 : 3)) % 4;\n\t\trep(i, 4) next[n][i] = n + 1;\n\t\tnext[n][d] = n;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\td = (d + (s[i] == 'L' ? 3 : 1)) % 4;\n\t\t\trep(j, 4) next[i][j] = j == d ? i : next[i + 1][j];\n\t\t}\n\t\t\n\t\tpriority_queue<pair<pi, pi> > q;\n\t\tq.push(mp(mp(0, 0), mp(y, x)));\n\t\twhile(!q.empty()){\n\t\t\ty = q.top().second.first; x = q.top().second.second;\n\t\t\tint co = q.top().first.first, d = q.top().first.second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(v[y][x][d]) continue;\n\t\t\tv[y][x][d] = 1;\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(0 <= ny && ny < h && 0 <= nx && nx < w){\n\t\t\t\tif(!v[ny][nx][d]) q.push(mp(mp(co, d), mp(ny, nx)));\n\t\t\t}\n\t\t\trep(i, 4) if(!v[y][x][i]){\n\t\t\t\tint nc = next[-co][i];\n\t\t\t\tif(nc <= n) q.push(mp(mp(-nc, i), mp(y, x)));\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct State{\n    int y,x,d;\n};\n\nconst int N = 1000;\nconst int INF = 19191919;\n\nconst int dx[4]={0,1,0,-1}, dy[4]={-1,0,1,0};\n\nint d[N][N][4];\nvector<int> dir[4];\n\n\n\nint main(){\n    int h,w,n;\n    while(cin >>h >>w >>n,h){\n        // initialize\n        rep(i,N)rep(j,N)rep(k,4) d[i][j][k]=INF;\n        rep(i,4) dir[i].clear();\n\n        string c;\n        cin >>c;\n        vector<string> f(h);\n        rep(i,h) cin >>f[i];\n\n        int nd = 0;\n        rep(i,n){\n            dir[nd].pb(i);\n            if(c[i]=='L') nd = (nd+3)%4;\n            else nd = (nd+1)%4;\n        }\n        dir[nd].pb(n);\n        rep(i,4) dir[i].pb(INF);\n\n        int sy,sx,gy,gx;\n        rep(i,h)rep(j,w){\n            if(f[i][j]=='S'){\n                sy = i;\n                sx = j;\n            }\n            if(f[i][j]=='G'){\n                gy = i;\n                gx = j;\n            }\n        }\n\n        auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n        queue<State> que;\n        que.push({sy,sx,0});\n        d[sy][sx][0] = 0;\n        while(!que.empty()){\n            State now = que.front();\n            que.pop();\n\n            int D = d[now.y][now.x][now.d];\n\n            // 今向いてる方に進む\n            int ny = now.y+dy[now.d], nx = now.x+dx[now.d];\n            if(IN(ny,nx) && f[ny][nx]!='#'){\n                if(d[ny][nx][now.d] > D){\n                    d[ny][nx][now.d] = D;\n                    que.push({ny,nx,now.d});\n                }\n            }\n\n            rep(i,4)if(i!=now.d){\n                int dd = *lower_bound(all(dir[i]), D);\n                if(d[now.y][now.x][i] > dd){\n                    d[now.y][now.x][i] = dd;\n                    que.push({now.y,now.x,i});\n                }\n            }\n        }\n\n        int ans = INF;\n        rep(i,4) ans = min(ans, d[gy][gx][i]);\n        cout << (ans<INF?\"Yes\":\"No\") << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w, n, d[N][N][4];\nstring o, s[N];\nint sy, sx;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint B[N], A[N][4];\n\npriority_queue<P2,vector<P2>,greater<P2> > q;\n\nbool dijkstra(){\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  \n  q.push(P2(P(0,0),P(sy,sx)));\n  \n  d[sy][sx][0]=0;\n\n  bool res=false;\n  \n  while(!q.empty()){\n\n    P2 t=q.top(); q.pop();\n\n    int cost=t.first.first;\n    int dir=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x][dir]<cost) continue;\n    \n    if(s[y][x]=='G') res=true;\n\n    for(int i=0;i<4;i++){\n\n      if(cost==o.size()||A[cost][i]==INF) continue;\n\n      if(d[y][x][i]>A[cost][i]+1){\n\t\n\td[y][x][i]=A[cost][i]+1;\n\n\tq.push(P2(P(A[cost][i]+1,i),P(y,x)));\n      }\n      \n    }\n    \n    int ny=y+dy[dir], nx=x+dx[dir];\n    \n    if(ny<0||nx<0||h<=ny||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n\n    if(d[ny][nx][dir]>cost){\n\n      d[ny][nx][dir]=cost;\n      \n      q.push(P2(P(cost,dir),P(ny,nx)));\n    }\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  while(1) {\n    \n    cin>>h>>w>>n;\n    if(!h&&!w&&!n) break;\n  \n    cin>>o;\n\n    for(int i=0;i<h;i++){\n    \n      cin>>s[i];\n\n      for(int j=0;j<w;j++)\n\tif(s[i][j]=='S') sy=i, sx=j;\n    \n    }\n\n    int dir=0;\n    \n    for(int i=0;i<n;i++){\n      \n      if(o[i]=='L') dir=(dir+3)%4;\n      else dir=(dir+1)%4;\n      \n      B[i]=dir;      \n    }\n    \n    int dir2[4];\n\n    for(int i=0;i<4;i++) dir2[i]=INF;\n    \n    for(int i=0;i<n;i++){\n      \n      dir2[B[i]] = min(dir2[B[i]],i);\n\n      for(int j=0;j<4;j++) A[i][j] = dir2[j];\n      \n    }\n    \n    if(dijkstra()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <set>\n#include <stack>\n\nusing namespace std;\n#define ll long long \n#define eps 1e-8\n#define inf 0x3f3f3f3f\n#define N 1005\n#define M 1000010\n#define mod 1000000007\n#define MP make_pair\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, 1, 0, -1 };\nint n, m, L;\nchar str[M];\nchar s[N][N];\nint lft[M], rht[M];\nvoid init()\n{\n\tint i = 0, j = 0;\n\tint cnt = 0;\n\tfor( ; i < L; ++i ){\n\t\twhile( j < L && cnt < 1 ){\n\t\t\tif( str[j] == 'L' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\twhile( cnt > 1 ){\n\t\t\tif( str[j-1] == 'L' ) --cnt;\n\t\t\telse ++cnt;\n\t\t\t--j;\n\t\t}\n\t\tif( cnt == 1 ) lft[i] = j;\n\t\telse lft[i] = M;\n\t\tif( str[i] == 'L' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = cnt = j = 0; i < L; ++i ){\n\t\twhile( j < L && cnt < 1 ){\n\t\t\tif( str[j] == 'R' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\twhile( cnt > 1 ){\n\t\t\tif( str[j-1] == 'R' ) --cnt;\n\t\t\telse ++cnt;\n\t\t}\n\t\tif( cnt == 1 ) rht[i] = j;\n\t\telse rht[i] = M;\n\t\tif( str[i] == 'R' ) --cnt;\n\t\telse ++cnt;\n\t}\n\n\tfor( i = j = cnt = 0; i < L; ++i ){\n\t\twhile( j < L && cnt < 3 ){\n\t\t\tif( str[j] == 'L' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\twhile( cnt > 3 ){\n\t\t\tif( str[j-1] == 'L' ) --cnt;\n\t\t\telse ++cnt;\n\t\t\t--j;\n\t\t}\n\t\tif( cnt == 3 ) rht[i] = min( rht[i], j );\n\t\tif( str[i] == 'L' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = cnt = j = 0; i < L; ++i ){\n\t\twhile( j < L && cnt < 3 ){\n\t\t\tif( str[j] == 'R' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\twhile( cnt > 3 ){\n\t\t\tif( str[j-1] == 'R' ) --cnt;\n\t\t\telse ++cnt;\n\t\t\t--j;\n\t\t}\n\t\tif( cnt == 3 ) lft[i] = min( lft[i], j );\n\t\t//else rht[i] = M;\n\t\tif( str[i] == 'R' ) --cnt;\n\t\telse ++cnt;\n\t}\n}\nint dis[N][N][4], vis[N][N][4];\nint in( int x, int y )\n{\n\treturn x >= 0 && x < n && y >= 0 && y < m;\n}\nint solve( int x, int y, int ex, int ey )\n{\n\tqueue<int> q;\n\tint x1, y1, d, d1;\n\tint tmp;\n\tq.push( x ), q.push( y ), q.push( 0 );\n\tmemset( dis, -1, sizeof(dis) );\n\tmemset( vis, 0, sizeof(vis) );\n\tdis[x][y][0] = 0;\n\twhile( !q.empty() ){\n\t\tx = q.front(), q.pop();\n\t\ty = q.front(), q.pop();\n\t\td = q.front(), q.pop();\n\t\tvis[x][y][d] = 0;\n\t\tx1 = x + dx[d];\n\t\ty1 = y + dy[d];\n\t\td1 = d;\n\t\tif( in( x1, y1 ) && s[x1][y1] != '#' ){\n\t\t\tif( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > dis[x][y][d] ){\n\t\t\t\tdis[x1][y1][d1] = dis[x][y][d];\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t\t}\n\t\t}\n\t\tif( dis[x][y][d] >= L ) continue;\n\t\tx1 = x, y1 = y;\n\t\ttmp = lft[dis[x][y][d]]; d1 = ( d - 1 + 4 ) % 4;\n\t\tif( tmp != M && ( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > tmp )  ){\n\t\t\t\tdis[x1][y1][d1] = tmp;\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t}\n\t\ttmp = rht[dis[x][y][d]], d1 = ( d + 1 ) % 4;\n\t\tif( tmp != M && ( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > tmp )  ){\n\t\t\t\tdis[x1][y1][d1] = tmp;\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint x, y, ex, ey;\n\twhile( scanf( \"%d%d%d\", &n, &m, &L ) == 3 && n+m+L ){\n\t\tscanf( \"%s\", str );\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf( \"%s\", s[i] );\n\t\t\tfor( int j = 0; j < m; ++j ){\n\t\t\t\tif( s[i][j] == 'S' ) x = i, y = j;\n\t\t\t\tif( s[i][j] == 'G' ) ex = i, ey = j;\n\t\t\t}\n\t\t}\n\t\tinit();\n\t\tif( solve( x, y, ex, ey ) ) puts( \"Yes\" );\n\t\telse puts( \"No\" );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MAX = 1000;\n\nstruct State {\n    int x, y, dir, n;\n    State(int x, int y, int dir, int n)\n        : x{x}, y{y}, dir{dir}, n{n} {}\n};\n\nint H, W;\nstring commands;\nchar field[MAX][MAX];\nvector<int> dir[4];\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nbool in_field(int x, int y)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid init()\n{\n    for (int i = 0; i < 4; i++) {\n        dir[i].clear();\n    }\n}\n\nvoid make(int N)\n{\n    init();\n    int nd = 1;\n    for (int i = 0; i < N; i++) {\n        if (commands[i] == 'L') {\n            nd = (nd + 3) % 4;\n        } else {\n            nd = (nd + 1) % 4;\n        }\n        dir[nd].emplace_back(i);\n    }    \n}\n\nbool solve(int sx, int sy, int gx, int gy)\n{\n    queue<State> Q;\n    Q.push({sx, sy, 1, 0});\n    vector<vector<vector<bool>>> d(H, vector<vector<bool>>(W, vector<bool>(4, 0)));\n    d[sy][sx][1] = 1;\n\n    while (!Q.empty()) {\n        State s = Q.front(); Q.pop();\n        int x = s.x, y = s.y;\n        if (x == gx && y == gy) return 1;\n        \n        // move forward\n        int nx = s.x + dx[s.dir], ny = s.y + dy[s.dir];\n        if (in_field(nx, ny) && field[ny][nx] != '#' && !d[ny][nx][s.dir]) {\n            d[ny][nx][s.dir] = 1;\n            Q.push({nx, ny, s.dir, s.n});\n        }\n        \n        // turn\n        for (int i = 0; i < 4; i++) {\n            auto np = lower_bound(dir[i].begin(), dir[i].end(), s.n);\n            if (np == dir[i].end()) continue;\n            int nn = np - dir[i].begin();\n            if (!d[y][x][i]) {\n                d[y][x][i] = 1;\n                Q.push({x, y, i, nn + 1});                \n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{\n    int N, sx, sy, gx, gy;\n    while (cin >> H >> W >> N, H) {\n        cin >> commands;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == 'S') { \n                    field[i][j] = '.';\n                    sx = j; sy = i;\n                } else if (field[i][j] == 'G') {\n                    field[i][j] = '.';\n                    gx = j; gy = i;\n                }\n            }\n        }\n        make(N);\n        cout << (solve(sx, sy, gx, gy) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct State{\n\tint x, y, dir;\n\tState(){}\n\tState(int a, int b, int c){\n\t\tx = a, y = b, dir = c;\n\t}\n\tbool operator<(const State& obj)const{\n\t\treturn x > obj.x || (x == obj.x && y > obj.y) || (x == obj.x && y == obj.y && dir > obj.dir);\n\t}\n};\ntypedef pair<int, State> P;\n\nint H, W, N;\nchar s[1000005];\nchar map[1005][1005];\nint sx, sy, gx, gy;\nint dist[1005][1005][4];\n\nint dir[1000005];\nint next[1000005][4];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dijkstra()\n{\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\tdist[x][y][d] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdist[sx][sy][1] = 0;\n\t\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tQ.push(make_pair(0, State(sx, sy, 1)));\n\t\n\tint x, y, dir, d;\n\tint nx, ny, ndir;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tx = Q.top().second.x;\n\t\ty = Q.top().second.y;\n\t\tdir = Q.top().second.dir;\n\t\tQ.pop();\n\t\t\n\t\tif(dist[x][y][dir] < d) continue;\n\t\t\n\t\tnx = x + dx[dir], ny = y + dy[dir], ndir = dir;\n\t\tif(nx <= 0 || nx > W || ny <= 0 || ny > H) goto pass;\n\t\tif(map[nx][ny] == '#') goto pass;\n\t\tif(dist[nx][ny][ndir] < inf) goto pass;\n\t\t\n\t\tdist[nx][ny][ndir] = dist[x][y][dir];\n\t\tQ.push(make_pair(dist[nx][ny][ndir], State(nx, ny, ndir)));\n\t\t\n\t\tpass:;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tnx = x, ny = y, ndir = i;\n\t\t\tif(dist[nx][ny][ndir] < inf) continue;\n\t\t\tif(next[d][ndir] >= inf) continue;\n\t\t\tif(dist[nx][ny][ndir] > next[d][ndir]){\n\t\t\t\tdist[nx][ny][ndir] = next[d][ndir];\n\t\t\t\tQ.push(make_pair(dist[nx][ny][ndir], State(nx, ny, ndir)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> H >> W >> N;\n\t\tif(H == 0 && W == 0 && N == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++) cin >> s[i];\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] == 'S'){\n\t\t\t\t\tmap[x][y] ='.';\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\t}\n\t\t\t\tif(map[x][y] == 'G'){\n\t\t\t\t\tmap[x][y] = '.';\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdir[0] = 1;\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(s[i] == 'L') dir[i] = (dir[i-1] + 1) % 4;\n\t\t\tif(s[i] == 'R') dir[i] = (dir[i-1] + 3) % 4;\n\t\t}\n\t\tint nx[4] = {inf, inf, inf, inf};\n\t\tfor(int i = N; i >= 0; i--){\n\t\t\tnx[dir[i]] = i;\n\t\t\tfor(int j = 0; j < 4; j++) next[i][j] = nx[j];\n\t\t}\n\t\t\n\t\tdijkstra();\n\t\t\n\t\tbool ans = false;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tans |= (dist[gx][gy][i] < inf); \n\t\t}\n\t\tif(ans) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Stat{\n\tint x,y,d; // d : Ì½ßÔ\n\tbool operator<(const Stat &S)const{ return d>S.d; }\n};\n\nint main(){\n\tfor(int h,w,n;scanf(\"%d%d%d\",&h,&w,&n),h;){\n\t\tchar cmd[1000001]; scanf(\"%s\",cmd);\n\t\tint sx,sy,gx,gy;\n\t\tstatic char B[1000][1001];\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",B[i]);\n\t\t\trep(j,w){\n\t\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t\t}\n\t\t}\n\n\t\t// precalc\n\t\tint len=strlen(cmd);\n\t\t// dir[i] := ÉÀs·é½ßª i Å éÆ«Éü¢Ä¢éûü\n\t\tstatic int dir[1000001];\n\t\tdir[0]=1;\n\t\trep(i,len) dir[i+1]=(dir[i]+(cmd[i]=='L'?1:3))%4;\n\n\t\t// next[i][k] := ÉÀs·é½ßª i Å éÆ«AÉßÄûü k ðü­æ¤È½ßÔ(+1)\n\t\tstatic int next[1000001][4];\n\t\trep(k,4) next[len][k]=(k==dir[len]?len:INF);\n\t\tfor(int i=len;i>0;i--) rep(k,4) {\n\t\t\tif(k==dir[i-1]) next[i-1][k]=i-1;\n\t\t\telse            next[i-1][k]=next[i][k];\n\t\t}\n\n\t\t// Dijkstra\n\t\tstatic int d[1000][1000][4];\n\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k]=INF;\n\t\td[sy][sx][1]=0;\n\n\t\tbool ok=false;\n\t\tpriority_queue<Stat> pq; pq.push((Stat){sx,sy,0});\n\t\twhile(!pq.empty()){\n\t\t\tStat S=pq.top(); pq.pop();\n\n\t\t\tif(d[S.y][S.x][dir[S.d]]<S.d) continue;\n\t\t\tif(S.x==gx && S.y==gy){ ok=true; break; }\n\n\t\t\trep(k,4){\n\t\t\t\tint xx=S.x+dx[k],yy=S.y+dy[k];\n\t\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]!='#'){\n\t\t\t\t\tif(next[S.d][k]<d[yy][xx][k]){\n\t\t\t\t\t\td[yy][xx][k]=next[S.d][k];\n\t\t\t\t\t\tpq.push((Stat){xx,yy,next[S.d][k]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass S{\npublic:\n  int y, x, d;\n  S(){}\n  S(int y, int x, int d) : y(y), x(x), d(d) {}\n  bool operator < (const S &s) const {\n    if(y == s.y){\n      if(x == s.x){\n        return d < s.d;\n      }\n      return x < s.x;\n    }\n    return y < s.y;\n  }\n};\n\ntypedef pair<int, S> P;\n\nconst int N = 1000;\nconst int M = 1000001;\nconst int MAX_V = N * N * 4;\nconst int INF = 1 << 28;\n\nint V, h, w, n, gx, gy;\nint G[M][4];\nint d[N][N][4];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nchar dat[N][N];\n\nbool dijkstra(S s){\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[0][0], d[N][0], INF);\n  d[s.y][s.x][s.d] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    S v = p.second;\n    if(v.y == gy && v.x == gx) return true;\n    if(d[v.y][v.x][v.d] < p.first) continue;\n    for(int i=0;i<4;i++){\n      int cost = G[p.first][i];\n      if(cost == -1) continue;\n      int ny = v.y + dy[i];\n      int nx = v.x + dx[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(dat[ny][nx] == '#') continue;\n      if(d[ny][nx][i] > cost){\n        d[ny][nx][i] = cost;\n        que.push(P(d[ny][nx][i], S(ny, nx, i)));\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> h >> w >> n && (h|w|n)){\n\t\tfill(G[0], G[M], -1);\n    string L;\n    cin >> L;\n    int sy, sx;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> dat[i][j];\n        if(dat[i][j] == 'S'){\n          sy = i;\n          sx = j;\n          dat[i][j] = '.';\n        }\n        if(dat[i][j] == 'G'){\n          gy = i;\n          gx = j;\n          dat[i][j] = '.';\n        }\n      }\n    }\n    vector<int> vec[4];\n    vec[0].push_back(0);\n\t\tvector<int> dir;\n\t\tdir.push_back(0);\n    for(int i=0;i<n;i++){\n\t\t\tint cdir = dir.back();\n      if(L[i] == 'L') dir.push_back((cdir + 3) % 4);\n      else dir.push_back((cdir + 1) % 4);\n      vec[dir.back()].push_back(i+1);\n    }\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint p = lower_bound(vec[j].begin(), vec[j].end(), i) - vec[j].begin();\n\t\t\t\tif(p < (int)vec[j].size()) G[i][j] = vec[j][p];\n\t\t\t}\n    }\n\t\t/*\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tcout << G[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << (dijkstra(S(sy, sx, 0)) ? \"Yes\" : \"No\") << endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dist[1001][1001][4];\nint todir[1000001][4][4];\nvs fld;\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tREP(i, 1001)REP(j, 1001)REP(k, 4) dist[i][j][k] = INF;\n\t\tREP(i, 1000001)REP(j, 4)REP(k, 4) todir[i][j][k] = INF;\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (dist[x][y][i] > tmp)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 1024\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[4]={0,1,0,-1};\nconst int dy[4]={-1,0,1,0};\n\nstring s;\nstring grid[MAX];\nint h,w,n;\nint d[MAX][MAX][4];\nint sy,sx,gx,gy;\nint a[1000001];\nint mem[1000001][4];\n\nclass State{\n  public:\n    int y,x,d,c;\n    State(int y,int x,int d,int c):y(y),x(x),d(d),c(c){}\n    bool operator<(State s)const{\n      return s.c<c;\n    }\n};\n\nbool in(int y,int x){\n  if(x<0 || y<0 || w<=x || h<=y)return false;\n  return true;\n}\n\nstring solve(){\n  fill(a,a+n,0);\n  FOR(i,1,n+1){\n    if(s[i-1]=='R')a[i]=a[i-1]+1;\n    else a[i]=a[i-1]+3;\n    a[i]%=4;\n  }\n  int A=-1,B=-1,C=-1,D=-1;\n  RFOR(i,n+1,0){\n    mem[i][0]=A;\n    mem[i][1]=B;\n    mem[i][2]=C;\n    mem[i][3]=D;\n    if(a[i]==0)A=i;\n    if(a[i]==1)B=i;\n    if(a[i]==2)C=i;\n    if(a[i]==3)D=i;\n  }\n\n  FOR(i,0,MAX)FOR(j,0,MAX)FOR(k,0,4)d[i][j][k]=inf;\n  priority_queue<State> pq;\n  FOR(i,0,h){\n    FOR(j,0,w){\n      if(grid[i][j]=='S'){ sy=i;sx=j; }\n      if(grid[i][j]=='G'){ gy=i;gx=j; }\n    }\n  }\n  d[sy][sx][0]=0;\n  pq.push(State(sy,sx,0,0));\n\n  while(pq.size()){\n    State u = pq.top();\n    pq.pop();\n\n    if(u.y==gy && u.x==gx)return \"Yes\";\n    if(d[u.y][u.x][u.d]<u.c)continue;\n\n    int ny=u.y+dy[u.d],nx=u.x+dx[u.d],nd=u.d;\n    if(in(ny,nx) && grid[ny][nx]!='#'){\n      if(u.c<d[ny][nx][nd]){\n        d[ny][nx][nd]=u.c;\n        pq.push(State(ny,nx,nd,u.c));\n      }\n    }\n    if(n<u.c)continue;\n    FOR(i,0,4){\n      if(mem[u.c][i]==-1)continue;\n      int cost=mem[u.c][i];\n      if(cost<d[u.y][u.x][i]){\n        d[u.y][u.x][i]=cost;\n        pq.push(State(u.y,u.x,i,cost));\n      }\n    }\n  }\n  return \"No\";\n}\n\nint main()\n{\n  while(cin>>h>>w>>n && h){\n    cin>>s;\n    FOR(i,0,h)cin>>grid[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct State{\n  int cur,h,w,dir;\n  bool operator < (const State& st) const {\n    return cur > st.cur;\n  }\n};\n\nconst int NORTH = 0;\nconst int SIZE = 1001;\nconst int INF = (1<<25);\nint H,W,N;\nint dh[] = {-1,0,1,0};\nint dw[] = {0,1,0,-1};\nstring command;\nchar field[SIZE][SIZE];\nint sh,sw,gh,gw;\nint T[SIZE][SIZE][4];\nvector<int> DIR[4];\n\nbool isInside(int h, int w){return 0<=h&&h<H&&0<=w&&w<W;}\n\nvoid input(){\n  cin >> command;\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){sh=i;sw=j;}\n      if(field[i][j] == 'G'){gh=i;gw=j;}\n    }\n  for(int i = 0; i < 4; i++) DIR[i].clear();\n  int d = 0;\n  for(int i = 0; i < (int)command.length(); i++){\n    if(command[i] == 'R') d = (d+1)%4;\n    else d = (d+3)%4;\n    DIR[d].push_back(i+1);\n  }\n}\n\nbool solve(){\n  fill(T[0][0], T[0][0]+SIZE*SIZE*4, INF);\n  priority_queue<State> Q;\n  Q.push((State){0,sh,sw,NORTH});\n  T[sh][sw][NORTH] = 0;\n\n  while(!Q.empty()){\n    const State now = Q.top(); Q.pop();\n\n    if(now.h == gh && now.w == gw) return true;\n    if(T[now.h][now.w][now.dir] < now.cur) continue;\n    \n    // turn around\n    State nex = now;    \n    for(int i = 0; i < 4; i++){\n      if(now.dir == i) continue;\n      \n      vector<int>::iterator ite = lower_bound(DIR[i].begin(),DIR[i].end(),now.cur);\n      if(ite == DIR[i].end()) continue;\n      \n      nex.cur = *ite;\n      nex.dir = i;\n      if(T[nex.h][nex.w][nex.dir] > nex.cur){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n    }\n    \n    // go forward\n    nex = now;\n    nex.h += dh[nex.dir];\n    nex.w += dw[nex.dir];\n    if(isInside(nex.h,nex.w) && field[nex.h][nex.w] != '#'){\n      if(T[nex.h][nex.w][nex.dir] > nex.cur){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H|N|W)){\n    input();\n    cout << (solve()?\"Yes\":\"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dist[1001][1001][4];\nint todir[1000001][4][4];\nvs fld;\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tREP(i, 1111)REP(j, 1111)REP(k, 4) dist[i][j][k] = INF;\n\t\tREP(i, 1111111)REP(j, 4)REP(k, 4) todir[i][j][k] = INF;\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (dist[x][y][i] > tmp)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass S{\npublic:\n  int y, x, d;\n  S(){}\n  S(int y, int x, int d) : y(y), x(x), d(d) {}\n  bool operator < (const S &s) const {\n    if(y == s.y){\n      if(x == s.x){\n        return d < s.d;\n      }\n      return x < s.x;\n    }\n    return y < s.y;\n  }\n};\n\ntypedef pair<int, S> P;\n\nconst int N = 1000;\nconst int M = 1000001;\nconst int MAX_V = N * N * 4;\nconst int INF = 1 << 28;\n\nint V, h, w, n, gx, gy;\nint G[M][4];\nint d[N][N][4];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nchar dat[N][N];\n\nbool dijkstra(S s){\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[0][0], d[N][0], INF);\n  d[s.y][s.x][s.d] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    S v = p.second;\n    if(v.y == gy && v.x == gx) return true;\n    if(d[v.y][v.x][v.d] < p.first) continue;\n    for(int i=0;i<4;i++){\n      int cost = G[p.first][i];\n      if(cost == -1) continue;\n      int ny = v.y + dy[i];\n      int nx = v.x + dx[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(dat[ny][nx] == '#') continue;\n      if(d[ny][nx][i] > d[v.y][v.x][v.d] + cost){\n        d[ny][nx][i] = d[v.y][v.x][v.d] + cost;\n        que.push(P(d[ny][nx][i], S(ny, nx, i)));\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> h >> w >> n && (h|w|n)){\n\t\tfill(G[0], G[M], -1);\n    string L;\n    cin >> L;\n    int sy, sx;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> dat[i][j];\n        if(dat[i][j] == 'S'){\n          sy = i;\n          sx = j;\n          dat[i][j] = '.';\n        }\n        if(dat[i][j] == 'G'){\n          gy = i;\n          gx = j;\n          dat[i][j] = '.';\n        }\n      }\n    }\n    vector<int> vec[4];\n    vec[0].push_back(0);\n\t\tvector<int> dir;\n\t\tdir.push_back(0);\n    for(int i=0;i<n;i++){\n\t\t\tint cdir = dir.back();\n      if(L[i] == 'L') dir.push_back((cdir + 3) % 4);\n      else dir.push_back((cdir + 1) % 4);\n      vec[dir.back()].push_back(i+1);\n    }\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint p = lower_bound(vec[j].begin(), vec[j].end(), i) - vec[j].begin();\n\t\t\t\tif(p < (int)vec[j].size()) G[i][j] = vec[j][p];\n\t\t\t}\n    }\n\t\t/*\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tcout << G[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << (dijkstra(S(sy, sx, 0)) ? \"Yes\" : \"No\") << endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\ntypedef pair<int,P2> P3;\nconst int MAX=1000000007;\n \nint dy[4]={-1,0,1,0},dx[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {\n  if(x<0 || x>=n) return false;\n  if(y<0 || y>=m) return false;\n  return true;\n}\nint d[1001][1001][4];\npriority_queue<P3,vector<P3>,greater<P3> > que;\n \nint main() {\n  int n,m,k;\n  while(cin >> n >> m >> k && (n||m||k)) {\n    while(!que.empty()) que.pop();\n \n    string c;\n    string s[n];\n    cin >> c;\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n    for(int l=0; l<4; l++) d[i][j][l]=MAX;\n      }\n    }\n \n    int sx,sy,tx,ty;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n    if(s[i][j]=='S') {\n      sx=i;sy=j;\n    }\n    if(s[i][j]=='G') {\n      tx=i;ty=j;\n    }\n      }\n    }\n \n    que.push(P3(0,P2(1,P(sx,sy))));\n    d[sx][sy][1]=0;\n    bool ck=false;\n    while(!que.empty()) {\n      P3 p=que.top();que.pop();\n      int j=p.F,z=p.S.F,nx=p.S.S.F,ny=p.S.S.S;\n      if(nx==tx && ny==ty) {\n    ck=true;\n    break;\n      }\n \n \n      int x=nx+dx[z],y=ny+dy[z];\n      if(check(n,m,x,y) && s[x][y]!='#' && d[x][y][z]>j) {\n    d[x][y][z]=j;\n    que.push(P3(j,P2(z,P(x,y))));\n      }\n       \n      x=nx;y=ny;\n      int z2=z;\n      bool b[4];\n      memset(b,false,sizeof(b));\n      b[z]=true;\n      for(int i=j; i<k; i++) {\n    if(c[i]=='L') z2--;\n    else z2++;\n    if(z2<0) z2+=4;\n    else if(z2>=4) z2-=4;\n    if(b[z2]) continue;\n    b[z2]=true;\n    if(d[x][y][z2]>i+1) {\n      d[x][y][z2]=i+1;\n      que.push(P3(i+1,P2(z2,P(x,y))));\n    }\n      }\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 1005\n#define MAX_N 1000005\n#define INF 1<<30\n#define eps 1.0e-10\n\n#define For(i,m,n) for(int i=(m);i<n;i++)\n\nusing namespace std;\n\nstruct point{\n    int x;\n    int y;\n    int step;\n    point(int x, int y, int step): x(x), y(y), step(step) {;}\n    bool operator<(const point &p) const {\n        return step > p.step;\n    }\n};\n\nint vis[MAXN][MAXN], cost[MAXN][MAXN], dir[MAX_N], g[4][MAX_N];\nint H,W,N,flag,sx,sy;\nint move[4][2]={-1,0,0,1,1,0,0,-1};\nchar str[MAX_N], _map[MAXN][MAXN];\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&H,&W,&N),H||W||N){\n        memset(vis,0,sizeof(vis));\n        memset(cost,0x0f,sizeof(cost));\n        memset(g,0x0f,sizeof(g));\n        flag=0;\n        dir[0]=0;\n        scanf(\"%s\",str);\n        For(i,0,N){\n            dir[i+1]=dir[i];\n            dir[i+1]+=(str[i]=='L'?3:1);\n            dir[i+1]%=4;\n        }\n        for(int i=N;i>=0;i--){\n            For(j,0,4) g[j][i]=g[j][i+1];\n            g[dir[i]][i]=i;\n        }\n        For(i,0,H){\n            scanf(\"%s\",_map[i]);\n            For(j,0,W) if(_map[i][j]=='S') sx=i, sy=j;\n        }\n        priority_queue<point> q;\n        q.push(point(sx,sy,0));\n        while(!q.empty()){\n            point tmp=q.top();\n            q.pop();\n            if(!vis[tmp.x][tmp.y]){\n                vis[tmp.x][tmp.y]=1;\n                if(_map[tmp.x][tmp.y]=='G') {flag=1; break;}\n                For(i,0,4){\n                    int tx=tmp.x+move[i][0];\n                    int ty=tmp.y+move[i][1];\n                    int tcost=g[i][tmp.step];\n                    if(tx>=0&&tx<H&&ty>=0&&ty<W&&_map[tx][ty]!='#'&&tcost<cost[tx][ty]){\n                        cost[tx][ty]=tcost;\n                        q.push(point(tx,ty,tcost));\n                    }\n                }\n            }\n        }\n        puts(flag?\"Yes\":\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w, n;\nstring s;\nvs fld;\nint dist[1111][1111][4];\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tMS(dist, -1);\n\t\tfld.clear(); fld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] == -1)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tif (p != n)\n\t\t\t{\n\t\t\t\tint ndir;\n\t\t\t\tif (s[p] == 'L')\n\t\t\t\t{\n\t\t\t\t\tif (dir == 0) ndir = 1;\n\t\t\t\t\tif (dir == 1) ndir = 3;\n\t\t\t\t\tif (dir == 2) ndir = 0;\n\t\t\t\t\tif (dir == 3) ndir = 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (dir == 0) ndir = 2;\n\t\t\t\t\tif (dir == 1) ndir = 0;\n\t\t\t\t\tif (dir == 2) ndir = 3;\n\t\t\t\t\tif (dir == 3) ndir = 1;\n\t\t\t\t}\n\t\t\t\tif (dist[x][y][ndir] == -1)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][ndir] = p + 1;\n\t\t\t\t\tque.push(make_tuple(x, y, ndir));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint H, W, N;\nstring s;\nstring c[1001];\nint nex[4][1001000];\nint mincost[1001][1001];\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nstruct State {\n  int y, x, cost;\n  State(){}\n  State(int y, int x, int cost):y(y), x(x), cost(cost){}\n  bool operator < (const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W&&c[y][x]!='#';\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> H >> W >> N, H) {\n    cin >> s;\n    rep(i, H) cin >> c[i];\n\n    vint sum(N+1);\n    rep(i, N) {\n      if(s[i] == 'L') sum[i+1] = sum[i]+1;\n      else sum[i+1] = sum[i]+3;\n      sum[i+1] %= 4;\n    }\n    memset(nex, -1, sizeof(nex));\n    rep(i, 4) {\n      int p = -1;\n      for(int j = N; j >= 0; --j) {\n\tif(sum[j] == i) p = j;\n\tif(~p) nex[i][j] = p-j;\n      }\n    }\n\n    int sy, sx, gy, gx;\n    rep(i, H) rep(j, W) {\n      if(c[i][j] == 'S') sy = i, sx = j;\n      else if(c[i][j] == 'G') gy = i, gx = j;\n    }\n\n    priority_queue<State> que;\n    fill(mincost[0], mincost[1001], inf);\n    mincost[sy][sx] = 0;\n    que.push(State(sy, sx, 0));\n    while(!que.empty()) {\n      State st = que.top(); que.pop();\n      if(st.y == gy && st.x == gx) break;\n      if(mincost[st.y][st.x] < st.cost) continue;\n      rep(i, 4) {\n\tint ny = st.y + dy[i], nx = st.x + dx[i];\n\tif(!in(ny, nx)) continue;\n\tif(nex[i][st.cost] == -1) continue;\n\tif(st.cost+nex[i][st.cost] < mincost[ny][nx]) {\n\t  mincost[ny][nx] = st.cost + nex[i][st.cost];\n\t  que.push(State(ny, nx, mincost[ny][nx]));\n\t}\n      }\n    }\n    cout << (mincost[gy][gx] == inf ? \"No\" : \"Yes\") << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint H,W,N;\nstring s,m[1000];\nint dis[4][1000][1000];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint nxt[4][1<<20];\nmain()\n{\n\twhile(cin>>H>>W>>N,H)\n\t{\n\t\tcin>>s;\n\t\tint sx,sy;\n\t\tfor(int i=0;i<H;i++)\n\t\t{\n\t\t\tcin>>m[i];\n\t\t\tfor(int j=0;j<W;j++)for(int r=0;r<4;r++)dis[r][i][j]=2*N;\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tsx=i;\n\t\t\t\t\tsy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nowr=0;\n\t\tfor(int i=0;i<N;i++)nowr+=s[i]=='L'?1:-1;\n\t\tnowr=(nowr%4+4)%4;\n\t\tint nowd[4];\n\t\tfor(int r=0;r<4;r++)nowd[r]=nxt[r][N]=r==nowr?N:2*N;\n\t\tfor(int i=N;i--;)\n\t\t{\n\t\t\tnowr-=s[i]=='L'?1:-1;\n\t\t\tnowr=(nowr%4+4)%4;\n\t\t\tnowd[nowr]=i;\n\t\t\tfor(int r=0;r<4;r++)nxt[r][i]=nowd[r];\n\t\t}\n\t\tdis[0][sx][sy]=0;\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int> > >P;\n\t\tP.push({{0,0},{sx,sy}});\n\t\tbool flag=false;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint d=-P.top().first.first;\n\t\t\tint nr=P.top().first.second;\n\t\t\tint x=P.top().second.first;\n\t\t\tint y=P.top().second.second;\n\t\t\tP.pop();\n\t\t\tif(dis[nr][x][y]<d)continue;\n\t\t\tif(m[x][y]=='G')\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[r],ty=y+dy[r];\n\t\t\t\tif(tx<0||ty<0||tx>=H||ty>=W||m[tx][ty]=='#'||dis[r][tx][ty]<=nxt[r][d])continue;\n\t\t\t\tdis[r][tx][ty]=nxt[r][d];\n\t\t\t\tP.push({{-nxt[r][d],r},{tx,ty}});\n\t\t\t}\n\t\t}\n\t\tcout<<(flag?\"Yes\":\"No\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n#define int long long\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a,int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now,int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr,backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int,int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    } \n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid,int) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        if (lazy[k] == OM0) return data[k];\n        for (int q = sz; q >= 0; q /= 2) {\n            if (q & k) {\n                return g(data[k], lazy[k], sz / q);\n            }\n        }\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nvoid solve(){\n    while (true) {\n        int h, w, n;\n        cin >> h >> w >> n;\n        if (h == 0) return;\n        string s;\n        cin >> s;\n        int dx[4] = { -1,0,1,0 };\n        int dy[4] = { 0,1,0,-1 };\n        vector<vector<int>> grid(h, vector<int>(w, 0));\n        queue<pair<int, int>> next[4];\n        pair<int, int> goal;\n        REP(i, h) {\n            string a;\n            cin >> a;\n            REP(q, w) {\n                if (a[q] == '#') {\n                    grid[i][q] = 1;\n                }\n                if (a[q] == 'G') {\n                    goal = mp(i, q);\n                }\n                if (a[q] == 'S') {\n                    REP(j,4)\n                    next[j].push(mp(i, q));\n                    grid[i][q] = 0;\n                }\n            }\n        }\n        int now = 0;\n        s.push_back('L');\n        REP(i, s.length()) {\n            while (next[now].empty() == false) {\n                pair<int, int> go = next[now].front();\n                next[now].pop();\n                int x = go.first + dx[now];\n                int y = go.second + dy[now];\n                if (x >= 0 && x < h && y >= 0 && y < w) {\n                    if (grid[x][y] == 0) {\n                        grid[x][y] = 1;\n                        REP(j, 4) {\n                            next[j].push(mp(x, y));\n                        }\n                    }\n                }\n            }\n            if (s[i] == 'L') {\n                now += 3;\n            }\n            else now++;\n            now %= 4;\n        }\n        if (grid[goal.first][goal.second] == 1) {\n            cout << \"Yes\" << endl;\n        }\n        else {\n            cout << \"No\" << endl;\n        }\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass S{\npublic:\n  int y, x, d;\n  S(){}\n  S(int y, int x, int d) : y(y), x(x), d(d) {}\n  bool operator < (const S &s) const {\n    if(y == s.y){\n      if(x == s.x){\n        return d < s.d;\n      }\n      return x < s.x;\n    }\n    return y < s.y;\n  }\n};\n\ntypedef pair<int, S> P;\n\nconst int N = 1000;\nconst int M = 1000001;\nconst int MAX_V = N * N * 4;\nconst int INF = 1 << 28;\n\nint V, h, w, n, gx, gy;\nint G[M][4];\nint d[N][N][4];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nchar dat[N][N];\n\nbool dijkstra(S s){\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[0][0], d[N][0], INF);\n  d[s.y][s.x][s.d] = 0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    S v = p.second;\n    if(v.y == gy && v.x == gx) return true;\n    if(d[v.y][v.x][v.d] < p.first) continue;\n    for(int i=0;i<4;i++){\n      int cost = G[p.first][i];\n      if(cost == -1) continue;\n      int ny = v.y + dy[i];\n      int nx = v.x + dx[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(dat[ny][nx] == '#') continue;\n      if(d[ny][nx][i] > d[v.y][v.x][v.d] + cost){\n        d[ny][nx][i] = d[v.y][v.x][v.d] + cost;\n        que.push(P(d[ny][nx][i], S(ny, nx, i)));\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> h >> w >> n && (h|w|n)){\n\t\tfill(G[0], G[M], -1);\n    string L;\n    cin >> L;\n    int sy, sx;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> dat[i][j];\n        if(dat[i][j] == 'S'){\n          sy = i;\n          sx = j;\n          dat[i][j] = '.';\n        }\n        if(dat[i][j] == 'G'){\n          gy = i;\n          gx = j;\n          dat[i][j] = '.';\n        }\n      }\n    }\n    vector<int> vec[4];\n    vec[0].push_back(0);\n\t\tvector<int> dir;\n\t\tdir.push_back(0);\n    for(int i=0;i<n;i++){\n\t\t\tint cdir = dir.back();\n      if(L[i] == 'L') dir.push_back((cdir + 3) % 4);\n      else dir.push_back((cdir + 1) % 4);\n      vec[dir.back()].push_back(i+1);\n    }\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint p = lower_bound(vec[j].begin(), vec[j].end(), i) - vec[j].begin();\n\t\t\t\tif(p < (int)vec[j].size()) G[i][j] = (dir[i] == j ? i : i + 1);\n\t\t\t}\n    }\n\t\t/*\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tcout << G[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << (dijkstra(S(sy, sx, 0)) ? \"Yes\" : \"No\") << endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};//RDLU\n\nint d[1010][1010][4];\nsigned main(){\n\tint n,m,q;\n\twhile(cin>>n>>m>>q,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tint sx,sy,gx,gy;\n\t\trep(i,n)rep(j,m)if(in[i][j]=='S'){\n\t\t\tsx=i,sy=j;\n\t\t}else if(in[i][j]=='G'){\n\t\t\tgx=i,gy=j;\n\t\t}\n\t\tvvi ne(s.size()+1,vi(4,inf));\n\t\tfor(int i=s.size()-1;i>=0;i--){\n\t\t\tint t=1;\n\t\t\tif(s[i]=='R')t=-1;\n\t\t\trep(j,4)ne[i][j]=ne[i+1][(j+4+t)%4];\n\t\t\tif(s[i]=='R')ne[i][1]=i+1;\n\t\t\tif(s[i]=='L')ne[i][3]=i+1;\n\t\t}\n\t\t// show2d(ne);\n\t\t\n\t\trep(i,1010)rep(j,1010)rep(k,4)\n\t\t\td[i][j][k]=inf;\n\t\td[sx][sy][3]=0;\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,sx,sy,3));\n\t\twhile(!q.empty()){\n\t\t\tDef cost,x,y,to;\n\t\t\ttie(cost,x,y,to)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[x][y][to])continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k];\n\t\t\t\tint ny=y+dy[k];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='#')continue;\n\t\t\t\tint nto=k;\n\t\t\t\tint ncost=ne[cost][(k-to+4)%4];\n\t\t\t\tif(k==to)ncost=cost;\n\t\t\t\tif(ncost==inf)continue;\n\t\t\t\tif(ncost<d[nx][ny][nto]){\n\t\t\t\t\td[nx][ny][nto]=ncost;\n\t\t\t\t\tq.push(tp(-ncost,nx,ny,nto));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,4)if(d[gx][gy][i]-inf){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tgoto end;\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t\tend:;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstring>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntemplate<class T> T getAs(){ T v; std::cin >> v; return v; }\nint getInt(){ return getAs<int>(); }\n\nusing namespace std;\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nconst int _dx[] = { 0, 1, 0,-1};\nconst int _dy[] = {-1, 0, 1, 0};\n\nenum DIR{\n  NORTH = 0,\n  EAST  = 1,\n  SOUTH = 2,\n  WEST  = 3\n};\n\nstring s;\nstring g[1000];\nint memo[1000][1000][4];\nint nextdir[1000010][4];\nint w, h, n;\n\nbool cango(int x, int y, int d){\n  int xx = x + _dx[d];\n  int yy = y + _dy[d];\n\n  return ISIN(xx, yy, w, h) && g[yy][xx] == '.';\n}\n\nstruct data{\n  int x;\n  int y;\n  int d;\n  int cnt;\n\n  data(int a, int b, int c, int e) : x(a), y(b), d(c), cnt(e) {}\n};\n\nbool operator < (const data &lhs, const data &rhs){\n  return lhs.cnt > rhs.cnt;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n    n = getInt();\n\n    int sx, sy, sd = NORTH;\n    int gx, gy;\n\n    if(h + w + n == 0) break;\n\n    cin >> s;\n\n    REP(i,h){\n      cin >> g[i];\n\n      REP(j,w){\n        if(g[i][j] == 'S'){\n          sx = j; sy = i; g[i][j] = '.';\n        }else if(g[i][j] == 'G'){\n          gx = j; gy = i; g[i][j] = '.';\n        }\n      }\n    }\n\n    memset(memo, -1, sizeof(memo));\n\n    for(int i = n - 1; i >= 0; i--){\n      REP(j,4) nextdir[i][j] = n + 2;\n\n      nextdir[i][s[i] == 'L' ? 3 : 1] = i + 1;\n      nextdir[i][0] = i;\n      if(i != n - 1){\n        REP(j,4){\n          int k = (j + (s[i] == 'L' ? 3 : 1)) % 4;\n          nextdir[i][k] = min(nextdir[i][k], nextdir[i + 1][j]);\n        }\n      }\n    }\n\n    /*\n    REP(j,n) printf(\"  %c\", s[j]); puts(\"\");\n    REP(i,4){\n      REP(j,n){\n        printf(\"%2d \", nextdir[j][i]);\n      }\n      puts(\"\");\n    }\n    REP(i,h) cout << g[i] << endl;\n    */\n\n    bool ans = false;\n    priority_queue<data> pq;\n    pq.push(data(sx, sy, sd, 0));\n\n    while(pq.size()){\n      data dt = pq.top(); pq.pop();\n      int x = dt.x;\n      int y = dt.y;\n      int d = dt.d;\n      int cnt = dt.cnt;\n\n      if(memo[y][x][d] != -1) continue;\n      memo[y][x][d] = cnt;\n      //printf(\"%d %d %d %d\\n\", x, y, d, cnt);\n\n      if(cnt != n){\n        REP(i,4) if(nextdir[cnt][i] != n + 2){\n          int dd = (d + i) % 4;\n          if(memo[y][x][dd] == -1) pq.push(data(x, y, dd, nextdir[cnt][i]));\n        }\n      }\n\n      while(cango(x, y, d)){\n        x += _dx[d]; y += _dy[d];\n        if(gx == x && gy == y){ ans = true; goto end; }\n        if(cnt != n){\n          int nextd = (d + (s[cnt] == 'L' ? 3 : 1)) % 4;\n          if(memo[y][x][nextd] == -1){\n            pq.push(data(x, y, nextd, cnt + 1));\n          }\n        }\n      }\n    }\n\n  end:;\n    puts(ans ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar fie[1001][1001];\nint H,W,N;\nint memo[1001][1001];\nchar S[1000001];\nint Ds[1000001][4];\n\nint dx[]={0,1,0,-1};//R -> +1 , L -> +1\nint dy[]={-1,0,1,0};\n\nint sx,sy,gx,gy;\n\nstruct state{\n  int x,y,c;\n};\n\nbool check( int x,int y){\n  if( x < 0 || y < 0 || x >= W || y >= H ) return false;\n  if( fie[x][y] == '#' ) return false;\n  if( memo[x][y] > -1 ) return false;\n  return true; \n}\n\n\n\nbool bfs(){\n\n  memset(memo,-1,sizeof(memo));\n\n  queue<state> q;\n  q.push( (state){sx,sy,0} );\n  memo[sx][sy] = 0;\n  while( !q.empty() ){\n    state p = q.front(); q.pop();\n    int x = p.x;\n    int y = p.y;\n    int c = p.c;\n    int d = S[c];\n\n    //  cout << x<< \" \" << y << \" \"<< c <<\" \" << d << endl;\n\n    for(int i=0;i<4;i++){\n      int nd = i;\n      int nc = d==i?0:Ds[c][nd];\n      if( nc > N ) continue;\n      int nx = x+dx[nd];\n      int ny = y+dy[nd];\n      while( check(nx,ny) ){\n\tif( nx == gx && ny == gy ) return true;\n\tq.push( (state){nx,ny,nc} );\n\tmemo[nx][ny] = nc;\n\tnx += dx[nd];\n\tny += dy[nd];\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H||W||N) ){\n    for(int i=1;i<=N;i++){\n      cin >> S[i];\n    }\n    S[0] = 0;\n    int dnc = 0;\n    for(int i=1;i<=N;i++){\n      if( S[i] == 'L' ){\n\tdnc+=3;\t \n      } else {\n\tdnc++;\n      }\n      dnc %= 4;\n      S[i] = (char)dnc;\n    }\n    \n    int dc[4] = {N+1,N+1,N+1,N+1};\n    for(int j=0;j<4;j++){\n      Ds[N][j] = dc[j];\n    }\n    for(int i=N;i>0;i--){\n      dc[(int)S[i]] = i;\n      for(int j=0;j<4;j++){\n\tDs[i-1][j] = dc[j];\n\t//\tprintf(\"%d, %d  %d\\n\",i-1,j,(int)Ds[i-1][j]);\n      }\n    }\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[j][i];\n\tif( fie[j][i] == 'G' ){\n\t  gx=j;\n\t  gy=i;\n\t}\n\tif( fie[j][i] == 'S' ){\n\t  sx = j;\n\t  sy = i;\n\t}\n      }\n    }\n    \n    if( bfs() ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint n;\n\tint w;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.n> r.n;\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\tif (!H)break;\n\t\tstring st;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tst.push_back(c);\n\t\t}\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int x = 0; x <= W + 1; ++x) {\n\t\t\tint y = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\ty = H + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tfor (int y = 0; y <= H + 1; ++y) {\n\t\t\tint x = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\tx = W + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tvector<vector<vector<int>>>memo(H + 2, vector<vector<int>>(W + 2,vector<int>(4,1e8)));\n\t\tint gx, gy;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == 'G') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'S') {\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == '#') {\n\t\t\t\t\tfield[i + 1][j+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sx,sy,0 ,3});\n\t\tmemo[sy][sx][3] = 0;\n\t\tstring ans = \"No\";\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int px = atop.x;\n\t\t\tconst int py = atop.y;\n\t\t\tconst int pn = atop.n;\n\t\t\tconst int pw = atop.w;\n\t\t\tif (px == gx&&py == gy) {\n\t\t\t\tans = \"Yes\"; break;\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nx = px + dx[pw];\n\t\t\t\tconst int ny = py + dy[pw];\n\t\t\t\tif (!field[ny][nx]) {\n\t\t\t\t\tif (memo[ny][nx][pw] > pn) {\n\t\t\t\t\t\tmemo[ny][nx][pw] = pn;\n\t\t\t\t\t\tque.push(aa{ nx,ny,pn,pw });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pn != N) {\n\t\t\t\tconst int nw = st[pn] == 'L' ? (pw + 1) % 4 : (pw + 3) % 4;\n\t\t\t\tif (memo[py][px][nw] > pn+1) {\n\t\t\t\t\tmemo[py][px][nw] = pn+1;\n\t\t\t\t\tque.push(aa{ px,py,pn+1,nw });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\n\nint main()\n{\n\tfor(int h,w,n;cin>>h>>w>>n && h|w|n;){\n\t\tvi ls,rs;\n\t\t{\n\t\t\tstring t; cin>>t;\n\t\t\trep(i,n)\n\t\t\t\t(t[i]=='L'?ls:rs).push_back(i);\n\t\t}\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tconst int di[]={0,1,0,-1},dj[]={1,0,-1,0}; // east,south,west,north\n\t\tqueue<tuple<int,int,int,int>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S') q.emplace(i,j,3,0);\n\t\tvvvi vis(4,vvi(h,vi(w)));\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tint i,j,d,p; tie(i,j,d,p)=q.front(); q.pop();\n\t\t\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[d][i][j]) continue;\n\t\t\tvis[d][i][j]=1;\n\t\t\tif(grid[i][j]=='G'){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.emplace(i+di[d],j+dj[d],d,p);\n\t\t\tint l=lower_bound(all(ls),p)-begin(ls);\n\t\t\tint r=lower_bound(all(rs),p)-begin(rs);\n\t\t\tif(l<ls.size() && (r+2>=rs.size() || ls[l]<rs[r+2])) q.emplace(i,j,(d+3)%4,ls[l]+1);\n\t\t\tif(r+2<rs.size() && (l>=ls.size() || rs[r+2]<ls[l])) q.emplace(i,j,(d+3)%4,rs[r+2]+1);\n\t\t\tif(r<rs.size() && (l+2>=ls.size() || rs[r]<ls[l+2])) q.emplace(i,j,(d+1)%4,rs[r]+1);\n\t\t\tif(l+2<ls.size() && (r>=rs.size() || ls[l+2]<rs[r])) q.emplace(i,j,(d+1)%4,ls[l+2]+1);\n\t\t}\n\t\tcout<<(res?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\ntypedef pair<int,P2> P3;\nconst int MAX=1000000007;\n\nint dy[4]={-1,0,1,0},dx[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {\n  if(x<0 || x>=n) return false;\n  if(y<0 || y>=m) return false;\n  return true;\n}\nint d[1001][1001][4];\npriority_queue<P3,vector<P3>,greater<P3> > que;\n\nint main() {\n  int n,m,k;\n  while(cin >> n >> m >> k && (n||m||k)) {\n    while(!que.empty()) que.pop();\n\n    string c;\n    string s[n];\n    cin >> c;\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tfor(int l=0; l<4; l++) d[i][j][l]=MAX;\n      }\n    }\n\n    int sx,sy,tx,ty;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tif(s[i][j]=='S') {\n\t  sx=i;sy=j;\n\t}\n\tif(s[i][j]=='G') {\n\t  tx=i;ty=j;\n\t}\n      }\n    }\n\n    que.push(P3(0,P2(1,P(sx,sy))));\n    d[sx][sy][1]=0;\n    bool ck=false;\n    while(!que.empty()) {\n      P3 p=que.top();que.pop();\n      int j=p.F,z=p.S.F,nx=p.S.S.F,ny=p.S.S.S;\n      if(nx==tx && ny==ty) {\n\tck=true;\n\tbreak;\n      }\n\n      //if(d[nx][ny][z]<j) continue;\n\n      int x=nx+dx[z],y=ny+dy[z];\n      if(check(n,m,x,y) && s[x][y]!='#' && d[x][y][z]>j) {\n\td[x][y][z]=j;\n\tque.push(P3(j,P2(z,P(x,y))));\n      }\n\n      if(j<k) {\n\tx=nx;y=ny;\n\tint z2=z;\n\tif(c[j]=='L') z2--;\n\telse z2++;\n\tif(z2<0) z2+=4;\n\telse if(z2>=4) z2-=4;\n\n\tif(d[x][y][z2]>j+1) {\n\t  d[x][y][z2]=j+1;\n\t  que.push(P3(j+1,P2(z2,P(x,y))));\n\t}\n      }\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {0, 1, 0, -1};\nconstexpr int dy[] = {-1, 0, 1, 0};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint turn[128];\n\tturn['L'] = -1;\n\tturn['R'] = 1;\n\n\tfor(int h, w, n; cin >> h >> w >> n && h;) {\n\t\tstring command;\n\t\tcin >> command;\n\n\t\tint dir = 0;\n\t\tarray<vector<int>, 4> get_d{{{0}, {}, {}, {}}};\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tdir = (dir + turn[command[i]] + 4) % 4;\n\t\t\tget_d[dir].emplace_back(i + 1);\n\t\t}\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\ttypedef tuple<int, int, int> P;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tvector<vector<int>> dist(h, vector<int>(w, n + 1));\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'S') {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tque.push(make_tuple(0, j, i));\n\t\t\t\t\tgoto unloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tunloop:;\n\n\t\twhile(!que.empty()) {\n\t\t\tint di, x, y;\n\t\t\ttie(di, x, y) = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(dist[y][x] < di) continue;\n\n\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || field[ny][nx] == '#') continue;\n\n\t\t\t\tconst auto it = lower_bound(get_d[d].begin(), get_d[d].end(), di);\n\t\t\t\tif(it == get_d[d].end()) continue;\n\n\t\t\t\tif(dist[ny][nx] > *it) {\n\t\t\t\t\tif(field[ny][nx] == 'G') goto ok;\n\t\t\t\t\tdist[ny][nx] = *it;\n\t\t\t\t\tque.push(make_tuple(*it, nx, ny));\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tcout << \"No\" << endl;\n\t\tcontinue;\n\n\tok:;\n\t\tcout << \"Yes\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\n//int dfs(int cang,int oang,int pos){\n//\tif(cang==oang)return pos;\n//\telse if(pos==n)return INF;\n//\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n//\tint nang;\n//\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n//\telse nang=(cang+1)%4;\n//\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n//}\n\nbool bfs(){\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t// cang==oagn\n\tfor(int i=0;i<4;i++)for(int j=0;j<n;j++)toAng[i][i][j]=i;\n\t// cang!=oang&&pos==n\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n\tfor(int k=n-1;k>=0;k--){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tint nang;\n\t\t\t\tint cang=i;\n\t\t\t\tint oang=j;\n\t\t\t\tint pos=k;\n\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\t\t\t\telse nang=(cang+1)%4;\n\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n\t\t\t}\n\t\t}\n\t}\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii>,vector<pair<pii,pii> >,greater<pair<pii,pii> > > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(0,0),pii(sy,sx)));\n\td[0][sy][sx]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.second.second;\n\t\tint cy=p.second.first;\n\t\tint cang=p.first.second;\n\t\tint cpos=p.first.first;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cang][cy][cx]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=toAng[cang][nang][cpos];\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[nang][ny][nx]>npos){\n\t\t\t\td[nang][ny][nx]=npos;\n\t\t\t\tpq.push(make_pair(pii(npos,nang),pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[i][gy][gx]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main(){\n  int H, W, N;\n  while(cin >> H >> W >> N && (H|W|N)){\n    string s;\n    char c[1000][1000];\n    cin >> s;\n    REP(i, H) REP(j, W) cin >> c[i][j];\n    int sx, sy, gx, gy;\n    REP(i, H) REP(j, W) if(c[i][j] == 'S') {\n      sx = j, sy = i;\n      c[i][j] = '.';\n    }\n    REP(i, H) REP(j, W) if(c[i][j] == 'G') {\n      gx = j, gy = i;\n      c[i][j] = '.';\n    }\n\n    vector<int> d(N + 1);\n    REP(i, N){\n      d[i + 1] = (d[i] + (s[i] == 'L' ? -1 : +1) + 4) % 4;\n    }\n    vector<int> indexes[4];\n    REP(i, N + 1) indexes[d[i]].push_back(i);\n    REP(i, 4) indexes[i].push_back(INF);\n\n    bool used[1000][1000] = {};\n    typedef pair<int, int> P;\n    typedef pair<int, P> S;\n    priority_queue<S, vector<S>, greater<S> > que;\n    que.push(S(0, P(sx, sy)));\n\n    bool ans = false;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      int x = s.second.first, y = s.second.second;\n      int k = s.first;\n      if(x == gx && y == gy){\n        ans = true;\n        break;\n      }\n      if(used[y][x]) continue;\n      used[y][x] = true;\n      REP(r, 4){\n        int nk = *lower_bound(indexes[r].begin(), indexes[r].end(), k);\n        if(nk == INF) continue;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(!valid(nx, ny, W, H)) continue;\n        if(used[ny][nx]) continue;\n        if(c[ny][nx] == '#') continue;\n        que.push(S(nk, P(nx, ny)));\n      }\n    }\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <set>\n#include <stack>\n\nusing namespace std;\n#define ll long long \n#define eps 1e-8\n#define inf 0x3f3f3f3f\n#define N 1005\n#define M 1000010\n#define mod 1000000007\n#define MP make_pair\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, 1, 0, -1 };\nint n, m, L;\nchar str[M];\nchar s[N][N];\nint lft[M], rht[M];\nvoid init()\n{\n\tint i = 0, j = 0;\n\tint cnt = 0;\n\tfor( ; i < L; ++i ){\n\t\twhile( j < L && cnt <= 1 ){\n\t\t\tif( str[j] == 'L' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 1 ) lft[i] = j;\n\t\telse lft[i] = M;\n\t\tif( str[i] == 'L' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = cnt = j = 0; i < L; ++i ){\n\t\twhile( j < L && cnt <= 1 ){\n\t\t\tif( str[i] == 'R' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 1 ) rht[i] = j;\n\t\telse rht[i] = M;\n\t\tif( str[i] == 'R' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = j = cnt = 0; i < L; ++i ){\n\t\twhile( j < L && cnt <= 3 ){\n\t\t\tif( str[j] == 'L' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 3 ) rht[i] = min( rht[i], j );\n\t\t//else lft[i] = M;\n\t\tif( str[i] == 'L' ) --cnt;\n\t\telse ++cnt;\n\t}\n\tfor( i = cnt = j = 0; i < L; ++i ){\n\t\twhile( j < L && cnt <= 1 ){\n\t\t\tif( str[i] == 'R' ) ++cnt;\n\t\t\telse --cnt;\n\t\t\t++j;\n\t\t}\n\t\tif( cnt >= 3 ) lft[i] = min( lft[i], j );\n\t\t//else rht[i] = M;\n\t\tif( str[i] == 'R' ) --cnt;\n\t\telse ++cnt;\n\t}\n}\nint dis[N][N][4], vis[N][N][4];\nint in( int x, int y )\n{\n\treturn x >= 0 && x < n && y >= 0 && y < m;\n}\nint solve( int x, int y, int ex, int ey )\n{\n\tqueue<int> q;\n\tint x1, y1, d, d1;\n\tint tmp;\n\tq.push( x ), q.push( y ), q.push( 0 );\n\tmemset( dis, -1, sizeof(dis) );\n\tmemset( vis, 0, sizeof(vis) );\n\tdis[x][y][0] = 0;\n\twhile( !q.empty() ){\n\t\tx = q.front(), q.pop();\n\t\ty = q.front(), q.pop();\n\t\td = q.front(), q.pop();\n\t\tvis[x][y][d] = 0;\n\t\tx1 = x + dx[d];\n\t\ty1 = y + dy[d];\n\t\td1 = d;\n\t\tif( in( x1, y1 ) && s[x1][y1] != '#' ){\n\t\t\tif( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > dis[x][y][d] ){\n\t\t\t\tdis[x1][y1][d1] = dis[x][y][d];\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t\t}\n\t\t}\n\t\tif( dis[x][y][d] >= L ) continue;\n\t\tx1 = x, y1 = y;\n\t\ttmp = lft[dis[x][y][d]]; d1 = ( d - 1 + 4 ) % 4;\n\t\tif( tmp != M && ( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > tmp )  ){\n\t\t\t\tdis[x1][y1][d1] = tmp;\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t}\n\t\ttmp = rht[dis[x][y][d]], d1 = ( d + 1 ) % 4;\n\t\tif( tmp != M && ( dis[x1][y1][d1] == -1 || dis[x1][y1][d1] > tmp )  ){\n\t\t\t\tdis[x1][y1][d1] = tmp;\n\t\t\t\tif( x1 == ex && y1 == ey ) return 1; \n\t\t\t\tif( !vis[x1][y1][d1] )\n\t\t\t\t\tvis[x1][y1][d1] = 1, q.push( x1 ), q.push( y1 ), q.push( d1 );\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint x, y, ex, ey;\n\twhile( scanf( \"%d%d%d\", &n, &m, &L ) == 3 && n+m+L ){\n\t\tscanf( \"%s\", str );\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tscanf( \"%s\", s[i] );\n\t\t\tfor( int j = 0; j < m; ++j ){\n\t\t\t\tif( s[i][j] == 'S' ) x = i, y = j;\n\t\t\t\tif( s[i][j] == 'G' ) ex = i, ey = j;\n\t\t\t}\n\t\t}\n\t\tinit();\n\t\tif( solve( x, y, ex, ey ) ) puts( \"Yes\" );\n\t\telse puts( \"No\" );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXH = 1001;\nconst int MAXW = 1001;\nconst int MAXN = 1000006;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nstruct State {\n  int pi, pj, d, step;\n  bool operator < (const State &s) const {\n    return step > s.step;\n  }\n};\n\nint H, W, N;\nchar G[MAXH][MAXW];\nstring S;\nint cost[MAXH][MAXW][4];\nint mem[MAXN][4];\n\nint minStep(int index, int dd) {\n  int &res = mem[index][dd];\n  if(res != -1) return res;\n  if(dd == 0) return res = 0;\n  if(index == N) return res = INF;\n  return res = 1 + minStep(index+1,\n                           (dd - (S[index] == 'R' ? 1 : -1) + 4) % 4);\n}\n\nint dijkstra(int si, int sj, int gi, int gj) {\n  memset(mem, -1, sizeof(mem));\n  priority_queue<State> que;\n  fill(cost[0][0], cost[MAXH][0], INF);\n  cost[si][sj][3] = 0;\n  que.push((State){si, sj, 3, 0});\n  while(que.size()) {\n    const State s = que.top();\n    que.pop();\n    do { // forward\n      State t = {s.pi + di[s.d], s.pj + dj[s.d], s.d, s.step};\n      if(t.pi < 0 || t.pi >= H) break;\n      if(t.pj < 0 || t.pj >= W) break;\n      if(G[t.pi][t.pj] == '#') break;\n      if(cost[t.pi][t.pj][t.d] <= t.step) break;\n      if(t.pi == gi && t.pj == gj) return true;\n      cost[t.pi][t.pj][t.d] = t.step;\n      que.push(t);\n    } while(0);\n\n    // turn\n    for(int nd = 0; nd < 4; ++nd) {\n      if(nd == s.d) continue;\n      State t = {s.pi, s.pj, nd, s.step + minStep(s.step, (nd-s.d+4)%4)};\n      if(cost[t.pi][t.pj][t.d] <= t.step) continue;\n      cost[t.pi][t.pj][t.d] = t.step;\n      que.push(t);\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> H >> W >> N && (H|W|N)) {\n    cin >> S;\n    int si, sj, gi, gj;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i; sj = j;\n        }\n        if(G[i][j] == 'G') {\n          gi = i; gj = j;\n        }\n      }\n    }\n    if(dijkstra(si, sj, gi, gj) != INF) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0},dy[] = {0,1,0,-1};\n\nint h,w,n,sx,sy,gx,gy;\nstring s,field[1010];\nconst int INF = 1e+9;\nint nxt[1000100][4],dir[1000100];\nint dist[1010][1010];\n\nvoid solve(){\n\tcin >> s;\n\tfor(int i = 0;i < 4;i++) nxt[n + 1][i] = -1;\n\tfor(int i = 0;i < n;i++) dir[i + 1] = (dir[i] + (s[i] == 'L' ? 3 : 1)) % 4;\n\tfor(int i = n;i >= 0;i--){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\tif(dir[i] == j) nxt[i][j] = i;\n\t\t\telse nxt[i][j] = nxt[i + 1][j];\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tcin >> field[i];\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(field[i][j] == 'S') sx = i,sy = j;\n\t\t\telse if(field[i][j] == 'G') gx = i,gy = j;\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) dist[i][j] = INF;\n\t}\n\tusing P = pair<int,pair<int,int>>;\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tdist[sx][sy] = 0;\n\tque.emplace(0,make_pair(sx,sy));\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint x = p.second.first,y = p.second.second;\n\t\tif(dist[x][y] < p.first) continue;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != '#'\n\t\t\t&& nxt[dist[x][y]][i] != -1 && dist[nx][ny] > nxt[dist[x][y]][i]){\n\t\t\t\tdist[nx][ny] = nxt[dist[x][y]][i];\n\t\t\t\tque.emplace(dist[nx][ny],make_pair(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[gx][gy] != INF) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl; \n}\n\nsigned main(){\n\twhile(cin >> h >> w >> n,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\t\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\t\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\t//using first_argument_type=decltype(helper(&Functor::operator()));\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nint main()\n{\n\tconst int di[]={-1,0,1,0},dj[]={0,-1,0,1};\n\t\n\tfor(int h,w,n;cin>>h>>w>>n && h|w|n;){\n\t\tstring t; cin>>t;\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tvi ds(n+1);\n\t\trep(i,n){\n\t\t\tif(t[i]=='L') ds[i+1]=(ds[i]+1)%4;\n\t\t\tif(t[i]=='R') ds[i+1]=(ds[i]+3)%4;\n\t\t}\n\t\tvvi next(n+1,vi(4));\n\t\t{\n\t\t\tvi tmp(4,INF);\n\t\t\tper(i,n+1){\n\t\t\t\ttmp[ds[i]]=i;\n\t\t\t\trep(j,4) next[i][j]=tmp[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// (i,j,d,p)\n\t\tauto pq=make_priority_queue(\n\t\t\t[](tuple<int,int,int,int> a,tuple<int,int,int,int> b){return get<3>(a)>get<3>(b);}\n\t\t);\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S') pq.emplace(i,j,0,0);\n\t\tvvi vis(h,vi(w));\n\t\tbool res=false;\n\t\twhile(pq.size()){\n\t\t\tint i,j,d,p; tie(i,j,d,p)=pq.top(); pq.pop();\n\t\t\tif(i<0 || h<=i || j<0 || w<=j || p==INF || grid[i][j]=='#' || (vis[i][j]>>d&1)) continue;\n\t\t\tvis[i][j]|=1<<d;\n\t\t\tif(grid[i][j]=='G'){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(k,4) pq.emplace(i+di[k],j+dj[k],k,next[p][k]);\n\t\t}\n\t\tcout<<(res?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\n\nint main()\n{\n\tfor(int h,w,n;cin>>h>>w>>n && h|w|n;){\n\t\tvi ls,rs;\n\t\t{\n\t\t\tstring t; cin>>t;\n\t\t\trep(i,n) (t[i]=='L'?ls:rs).push_back(i);\n\t\t}\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tconst int di[]={0,1,0,-1},dj[]={1,0,-1,0}; // east,south,west,north\n\t\tqueue<tuple<int,int,int,int>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S') q.emplace(i,j,3,0);\n\t\tvvvi vis(4,vvi(h,vi(w)));\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tint i,j,d,p; tie(i,j,d,p)=q.front(); q.pop();\n\t\t\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[d][i][j]) continue;\n\t\t\tvis[d][i][j]=1;\n\t\t\tif(grid[i][j]=='G'){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.emplace(i+di[d],j+dj[d],d,p);\n\t\t\tint l=lower_bound(all(ls),p)-begin(ls);\n\t\t\tint r=lower_bound(all(rs),p)-begin(rs);\n\t\t\tif(l<ls.size() && (r+2>=rs.size() || ls[l]<rs[r+2])) q.emplace(i,j,(d+3)%4,ls[l]+1);\n\t\t\tif(r+2<rs.size() && (l>=ls.size() || rs[r+2]<ls[l])) q.emplace(i,j,(d+3)%4,rs[r+2]+1);\n\t\t\tif(r<rs.size() && (l+2>=ls.size() || rs[r]<ls[l+2])) q.emplace(i,j,(d+1)%4,rs[r]+1);\n\t\t\tif(l+2<ls.size() && (r>=rs.size() || ls[l+2]<rs[r])) q.emplace(i,j,(d+1)%4,ls[l+2]+1);\n\t\t}\n\t\tcout<<(res?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint h, w, n, sx, sy;\nstring cmd;\nchar a[1001][1001];\nbool vis[1001][1001][4];\n\nint xdir[] = {0, 1, 0, -1};\nint ydir[] = {-1, 0, 1, 0};\n\nclass St{\npublic:\n  int x, y, d, tn;\n\n  St() {}\n  St(int _x, int _y, int _d, int _tn): x(_x), y(_y), d(_d), tn(_tn) {}\n};\n\nvoid aprint(St st)\n{\n  char ch[] = {'N', 'E', 'S', 'W'};\n  cout << \"turn : \" << st.tn << endl;\n\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j)\n      cout << ((i==st.y && j == st.x)? ch[st.d] : a[i][j]);\n    cout << endl;\n  }\n  cout << endl;\n}\n\nstring bfs()\n{\n  queue<St> que;\n  que.push(St(sx, sy, 0, 0));\n  St st;\n  int dx, dy, nd;\n\n  vis[sy][sx][0] = false;\n  while(!que.empty()){\n    st = que.front();\n    que.pop();\n\n    // aprint(st);\n\n    if(a[st.y][st.x] == 'G') return \"Yes\";\n    dx = st.x + xdir[st.d];\n    dy = st.y + ydir[st.d];\n\n    if(0 <= dx && dx < w && 0 <= dy && dy < h && a[dy][dx] != '#' && vis[dy][dx][st.d]){\n      vis[dy][dx][st.d] = false;\n      que.push(St(dx, dy, st.d, st.tn));\n    }\n\n    if(st.tn < n){\n      if(cmd[st.tn] == 'L'){\n\tnd = (st.d+3)%4;\n\t// if(vis[st.y][st.x][nd]){\n\t// vis[st.y][st.x][nd] = false;\n\t  que.push(St(st.x, st.y, nd, st.tn+1));\n\t  // }\n      }\n      else {\n\tnd = (st.d+1)%4;\n\t// if(vis[st.y][st.x][nd]){\n\t// vis[st.y][st.x][nd] = false;\n\t  que.push(St(st.x, st.y, nd, st.tn+1));\n\t  // }\n      }\n    }\n  }\n\n  return \"No\";\n}\n\nint main()\n{\n  while(cin>>h>>w>>n && h+w+n){\n    cin >> cmd;\n    fill(&vis[0][0][0], &vis[h][0][0], true);\n\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j){\n\tcin >> a[i][j];\n\tif(a[i][j] == 'S'){\n\t  a[i][j] = '.';\n\t  sx = j; sy = i;\n\t}\n      }\n\n    cout << bfs() << endl;\n    // break;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\n//int dfs(int cang,int oang,int pos){\n//\tif(cang==oang)return pos;\n//\telse if(pos==n)return INF;\n//\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n//\tint nang;\n//\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n//\telse nang=(cang+1)%4;\n//\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n//}\n\nbool bfs(){\n\t//memset(toAng,-1,sizeof(toAng));\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t// cang==oagn\n\tfor(int i=0;i<4;i++)for(int j=0;j<n;j++)toAng[i][i][j]=j;\n\t// cang!=oang&&pos==n\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n\tfor(int k=n-1;k>=0;k--){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tint nang;\n\t\t\t\tint cang=i;\n\t\t\t\tint oang=j;\n\t\t\t\tint pos=k;\n\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\t\t\t\telse nang=(cang+1)%4;\n\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n\t\t\t}\n\t\t}\n\t}\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii>,vector<pair<pii,pii> >,greater<pair<pii,pii> > > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(0,0),pii(sy,sx)));\n\td[0][sy][sx]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.second.second;\n\t\tint cy=p.second.first;\n\t\tint cang=p.first.second;\n\t\tint cpos=p.first.first;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cang][cy][cx]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=toAng[cang][nang][cpos];\n\t\t\t//int npos=dfs(cang,nang,cpos);\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[nang][ny][nx]>npos){\n\t\t\t\td[nang][ny][nx]=npos;\n\t\t\t\tpq.push(make_pair(pii(npos,nang),pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[i][gy][gx]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w, n;\nstring s;\nvs fld;\nint dist[1111][1111][4];\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tMS(dist, -1);\n\t\tfld.clear(); fld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] == -1)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tif (p != n)\n\t\t\t{\n\t\t\t\tint ndir;\n\t\t\t\tif (s[p] == 'L')\n\t\t\t\t{\n\t\t\t\t\tif (dir == 0) ndir = 1;\n\t\t\t\t\tif (dir == 1) ndir = 3;\n\t\t\t\t\tif (dir == 2) ndir = 0;\n\t\t\t\t\tif (dir == 3) ndir = 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (dir == 0) ndir = 2;\n\t\t\t\t\tif (dir == 1) ndir = 0;\n\t\t\t\t\tif (dir == 2) ndir = 3;\n\t\t\t\t\tif (dir == 3) ndir = 1;\n\t\t\t\t}\n\t\t\t\tdist[x][y][ndir] = p + 1;\n\t\t\t\tque.push(make_tuple(x, y, ndir));\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w, n, d[N][N][4];\nstring o, s[N];\nint sy, sx;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint B[N], A[N][4];\n\npriority_queue<P2,vector<P2>,greater<P2> > q;\n\nbool dijkstra(){\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  \n  q.push(P2(P(0,0),P(sy,sx)));\n  \n  d[sy][sx][0]=0;\n\n  bool res=false;\n  \n  while(!q.empty()){\n\n    P2 t=q.top(); q.pop();\n\n    int cost=t.first.first;\n    int dir=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x][dir]<cost) continue;\n    \n    if(s[y][x]=='G') res=true;\n\n    for(int i=0;i<4;i++){\n\n      if(cost==o.size()||A[cost][i]==INF) continue;\n\n      if(d[y][x][i]>A[cost][i]+1){\n\t\n\td[y][x][i]=A[cost][i]+1;\n\n\tq.push(P2(P(A[cost][i]+1,i),P(y,x)));\n      }\n      \n    }\n    \n    int ny=y+dy[dir], nx=x+dx[dir];\n    \n    if(ny<0||nx<0||h<=ny||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n\n    if(d[ny][nx][dir]>cost){\n\n      d[ny][nx][dir]=cost;\n      \n      q.push(P2(P(cost,dir),P(ny,nx)));\n    }\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  while(1) {\n    \n    cin>>h>>w>>n;\n    if(!h&&!w&&!n) break;\n  \n    cin>>o;\n\n    for(int i=0;i<h;i++){\n    \n      cin>>s[i];\n\n      for(int j=0;j<w;j++)\n\tif(s[i][j]=='S') sy=i, sx=j;\n    \n    }\n\n    int dir=0;\n    \n    for(int i=0;i<n;i++){\n      \n      if(o[i]=='L') dir=(dir+3)%4;\n      else dir=(dir+1)%4;\n      \n      B[i]=dir;\n     \n    }\n    \n    int dir2[4];\n    \n    for(int i=0;i<4;i++) dir2[i]=INF;\n    \n    for(int i=n-1;i>=0;i--){\n      \n      dir2[B[i]] = min(dir2[B[i]],i);\n\n      for(int j=0;j<4;j++) A[i][j] = dir2[j];\n      \n    }\n    \n    if(dijkstra()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int inf = 1e9;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nstruct state{\n    int cost;\n    int y;\n    int x;\n    state(int c, int y, int x):cost(c),y(y),x(x){}\n    state(){}\n    bool operator<(const state &a) const{\n        return cost > a.cost;\n    }\n};\n\nint main(){\n    while(1){\n        int h,w,n;\n        cin >> h >> w >> n;\n        if(h == 0) break;\n\n        string s;\n        cin >> s;\n        vector<string> grid(h+2, string(w+2, '#'));\n        for(int i=1; i<=h; i++){\n            cin >> grid[i];\n            grid[i] = \"#\" + grid[i] + \"#\";\n        }\n\n        vector<int> dir(n+1, 0);\n        for(int i=0; i<n; i++){\n            dir[i+1] = (s[i]=='L')? (dir[i]-1+4)%4: (dir[i]+1)%4;\n        }\n        vector<vector<int>> next(n+1, vector<int>(4, inf));\n        next[n][dir[n]] = n;\n        for(int i=n-1; i>=0; i--){\n            for(int j=0; j<4; j++){\n                next[i][j] = next[i+1][j];\n            }\n            next[i][dir[i]] = i;\n        }\n        int sy=-1,sx=-1;\n        int gy=-1,gx=-1;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                if(grid[i][j] == 'S'){\n                    sy = i;\n                    sx = j;\n                }\n                if(grid[i][j] == 'G'){\n                    gy = i;\n                    gx = j;\n                }\n            }\n        }\n\n        priority_queue<state> wait;\n        wait.push(state(0, sy, sx));\n        vector<vector<int>> dp(h+2, vector<int>(w+2, inf));\n        dp[sy][sx] = 0;\n        while(!wait.empty()){\n            int c = wait.top().cost;\n            int y = wait.top().y;\n            int x = wait.top().x;\n            wait.pop();\n            if(c > dp[y][x]) continue;\n\n            for(int d=0; d<4; d++){\n                int ny = y+dy[d];\n                int nx = x+dx[d];\n                int nc = next[c][d];\n                if(grid[ny][nx] == '#') continue;\n                if(nc == inf) continue;\n                if(nc < dp[ny][nx]){\n                    dp[ny][nx] = nc;\n                    wait.push(state(nc, ny, nx));\n                }\n            }\n        }\n        if(dp[gy][gx] != inf){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint h,w,n;\nstring str;\nint fie[1001][1001];\nint sx,sy,gx,gy;\nint dir[100005];\nint next[100005][4];\nint dp[1001][1001][4];\n\nvoid solve(void){\n\tint nowdir=0;\n\tdir[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(str[i]=='L'){\n\t\t\tnowdir=(nowdir+3)%4;\n\t\t}else{\n\t\t\tnowdir=(nowdir+1)%4;\n\t\t}\n\t\tdir[i+1]=nowdir;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tnext[n+1][i]=n+1;\n\t}\n\tfor(int i=n;i>=0;i--){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tnext[i][j]=next[i+1][j];\n\t\t}\n\t\tnext[i][dir[i]]=i;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tdp[i][j][k]=n+1;\n\t\t\t}\n\t\t}\n\t}\n\tdp[sy][sx][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(sy,sx)));\n\twhile(que.size()){\n\t\tPP q=que.top();\n\t\tque.pop();\n\t\tint v=q.first;\n\t\tint cy=q.second.first;\n\t\tint cx=q.second.second;\n\t\tif(dp[cy][cx][dir[v]]<v)continue;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nv=next[v][i];\n\t\t\tif(nv<dp[cy][cx][i]){\n\t\t\t\tdp[cy][cx][i]=nv;\n\t\t\t\tque.push(PP(nv,P(cy,cx)));\n\t\t\t}\n\t\t}\n\t\tint nx=cx+dx[dir[v]];\n\t\tint ny=cy+dy[dir[v]];\n\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\tif(fie[ny][nx]==0){\n\t\t\t\tif(v<dp[ny][nx][dir[v]]){\n\t\t\t\t\tdp[ny][nx][dir[v]]=v;\n\t\t\t\t\tque.push(PP(v,P(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool flag=false;\n\tfor(int i=0;i<4;i++){\n\t\tif(dp[gy][gx][i]<=n){\n\t\t\tflag=true;\n\t\t}\n\t}\n\tprintf(\"%s\\n\",flag?\"Yes\":\"No\");\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&h,&w,&n);\n\t\tif(h==0 && w==0 && n==0)break;\n\t\tcin >> str;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[j]=='#')fie[i][j]=-1;\n\t\t\t\tif(s[j]=='S'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(s[j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_N = 1000100;\nconst int IINF = INT_MAX;\n\nint H,W,N;\nchar opr[MAX_N];\nchar field[1010][1010];\nint dx[] = {+0,+1,+0,-1}; // 上 右 下 左\nint dy[] = {-1,+0,+1,+0};\nint G[MAX_N][4];\n\nvoid init(){\n  deque<int> deq[4]; \n  G[0][0] = 0;\n  REP(i,1,4) deq[i].push_back(0);\n  int dir = 0;\n\n  REP(i,1,N+1){\n    if( opr[i] == 'L' ) ( dir += 3 ) %= 4;\n    else                ( dir += 1 ) %= 4;\n    G[i][dir] = i;\n    rep(j,4) if( j != dir ) deq[j].push_back(i);\n    while( !deq[dir].empty() ) {\n      G[deq[dir].front()][dir] = min(G[deq[dir].front()][dir],i);\n      deq[dir].pop_front();\n    }\n  }\n}\n\nstruct Data {\n  int cur,dir;\n};\n\nint mindist[1010][1010][4],sp,ep;\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nvoid compute(){\n  rep(i,H) rep(j,W) rep(k,4) mindist[i][j][k] = IINF;\n  mindist[sp/W][sp%W][0] = 0;\n  deque<Data> deq;\n  deq.push_back((Data){sp,0});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    if( data.cur == ep ) { puts(\"Yes\"); return; }\n    rep(ndir,4){\n      if( ndir == data.dir ) {\n        int nx = data.cur % W + dx[ndir], ny = data.cur / W + dy[ndir];\n        if( !isValid(nx,ny) ) continue;\n        if( field[ny][nx] == '#' ) continue;\n        if( mindist[ny][nx][ndir] > mindist[data.cur/W][data.cur%W][data.dir] ) {\n          mindist[ny][nx][ndir] = mindist[data.cur/W][data.cur%W][data.dir];\n          deq.push_back((Data){nx+ny*W,ndir});\n        }\n      } else {\n        if( mindist[data.cur/W][data.cur%W][ndir] > G[mindist[data.cur/W][data.cur%W][data.dir]][ndir] ) {\n          mindist[data.cur/W][data.cur%W][ndir] = G[mindist[data.cur/W][data.cur%W][data.dir]][ndir];\n          deq.push_back((Data){data.cur,ndir});\n        }\n      }\n    }\n  }\n  puts(\"No\");\n}\n\nchar debug[4] = {'U','R','D','L'};\n\nint main(){\n  while( cin >> H >> W >> N, H|W|N ){\n    opr[0] = '*';\n    REP(i,1,N+1) cin >> opr[i];\n    rep(i,H) rep(j,W) {\n      cin >> field[i][j];\n      if( field[i][j] == 'S' ) { field[i][j] = '.'; sp = j + i * W; }\n      if( field[i][j] == 'G' ) { field[i][j] = '.'; ep = j + i * W; }\n    }\n    rep(i,N+1) rep(j,4) G[i][j] = IINF;\n    init();\n    /*\n    puts(\"---\");\n    rep(i,N+1) {\n      cout << i << \"-th\" << endl;\n      rep(j,4) {\n        cout << debug[j] << \" : \" << ((G[i][j]==IINF)?-1:G[i][j]) << \", \";\n      } cout << endl;\n    }\n    */\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dist[1001][1001][4];\nint todir[1000001][4][4];\nvs fld;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tREP(i, 1001)REP(j, 1001)REP(k, 4) dist[i][j][k] = INF;\n\t\tREP(i, 1000001)REP(j, 4)REP(k, 4) todir[i][j][k] = INF;\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;/*\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (dist[x][y][i] > tmp)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w, n, d[N][N][4],d2[N][N][4][4];\nstring o, s[N];\nint sy, sx;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\npriority_queue<P2,vector<P2>,greater<P2> > q;\n\nbool dijkstra(){\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  \n  q.push(P2(P(0,0),P(sy,sx)));\n\n  d[sy][sx][0]=0;\n\n  bool res=false;\n  \n  while(!q.empty()){\n\n    P2 t=q.top(); q.pop();\n\n    int cost=t.first.first;\n    int dir=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x][dir]<cost) continue;\n    \n    if(s[y][x]=='G') res=true;\n\n    if(cost<n&&o[cost]=='R'&&d[y][x][(dir+1)%4]>cost+1){\n\n      d[y][x][(dir+1)%4]=cost+1;\n      \n      q.push(P2(P(cost+1,(dir+1)%4),P(y,x)));\n    }\n\n    if(cost<n&&o[cost]=='L'&&d[y][x][(dir+3)%4]>cost+1){\n      \n      d[y][x][(dir+3)%4]=cost+1;\n      \n      q.push(P2(P(cost+1,(dir+3)%4),P(y,x)));\n    }\n    \n    int ny=y+dy[dir], nx=x+dx[dir];\n    \n    if(ny<0||nx<0||h<=ny||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n\n    if(d[ny][nx][dir]>cost){\n\n      d[ny][nx][dir]=cost;\n      \n      q.push(P2(P(cost,dir),P(ny,nx)));\n    }\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  while(1) {\n    \n    cin>>h>>w>>n;\n    if(!h&&!w&&!n) break;\n  \n    cin>>o;\n\n    for(int i=0;i<h;i++){\n    \n      cin>>s[i];\n\n      for(int j=0;j<w;j++)\n\tif(s[i][j]=='S') sy=i, sx=j;\n    \n    }\n\n    if(dijkstra()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2325.cc: Mysterious Maze\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 1000;\nconst int MAX_W = 1000;\nconst int MAX_N = 1000000;\n\nint dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Stat {\n  int d, x, y, di;\n  Stat() {}\n  Stat(int _d, int _x, int _y, int _di): d(_d), x(_x), y(_y), di(_di) {}\n  bool operator<(const Stat &s) const { return d < s.d; }\n  bool operator>(const Stat &s) const { return d > s.d; }\n};\n\n/* global variables */\n\nbool flds[MAX_H][MAX_W];\nint dirs[MAX_N + 1], nxtds[MAX_N + 1][4];\nint dists[MAX_H][MAX_W][4];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int h, w, n;\n    cin >> h >> w >> n;\n    if (h == 0) break;\n\n    string sop;\n    cin >> sop;\n\n    int nds[] = {INF, INF, INF, INF};\n    dirs[0] = 1;\n    for (int i = 0, di = 0; i < n; i++)\n      dirs[i + 1] =  (dirs[i] + (sop[i] == 'L' ? 1 : 3)) % 4;\n    for (int i = n; i >= 0; i--) {\n      nds[dirs[i]] = i;\n      for (int j = 0; j < 4; j++) nxtds[i][j] = nds[j];\n      //printf(\"%d:\", i);\n      //for (int j = 0; j < 4; j++) printf(\" %d\", nxtds[i][j]); putchar('\\n');\n    }\n\n    int sx, sy, gx, gy;\n    memset(flds, true, sizeof(flds));\n    \n    for (int y = 0; y < h; y++) {\n      string s;\n      cin >> s;\n      for (int x = 0; x < w; x++)\n\tswitch (s[x]) {\n\tcase 'S': sx = x; sy = y; break;\n\tcase 'G': gx = x; gy = y; break;\n\tcase '#': flds[y][x] = false; break;\n\t}\n    }\n\n    for (int y = 0; y < h; y++)\n      for (int x = 0; x < w; x++)\n\tfor (int di = 0; di < 4; di++) dists[y][x][di] = INF;\n    dists[sy][sx][1] = 0;\n    \n    priority_queue<Stat,vector<Stat>,greater<Stat> > q;\n    q.push(Stat(0, sx, sy, 1));\n    bool ans = false;\n    \n    while (! q.empty()) {\n      Stat u = q.top(); q.pop();\n      if (dists[u.y][u.x][u.di] != u.d) continue;\n      //printf(\"(%d,%d,%d)=%d\\n\", u.x, u.y, u.di, u.d);\n\n      if (u.x == gx && u.y == gy) {\n\tans = true;\n\tbreak;\n      }\n\n      for (int vdi = 0; vdi < 4; vdi++) {\n\tint vx = u.x + dxs[vdi], vy = u.y + dys[vdi];\n\tif (vx >= 0 && vx < w && vy >= 0 && vy < h && flds[vy][vx]) {\n\t  int vd = nxtds[u.d][vdi];\n\t  if (dists[vy][vx][vdi] > vd) {\n\t    dists[vy][vx][vdi] = vd;\n\t    q.push(Stat(vd, vx, vy, vdi));\n\t  }\n\t}\n      }\n    }\n\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\n//int dfs(int cang,int oang,int pos){\n//\tif(cang==oang)return pos;\n//\telse if(pos==n)return INF;\n//\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n//\tint nang;\n//\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n//\telse nang=(cang+1)%4;\n//\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n//}\n\nbool bfs(){\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t// cang==oagn\n\tfor(int i=0;i<4;i++)for(int j=0;j<n;j++)toAng[i][i][j]=i;\n\t// cang!=oang&&pos==n\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tfor(int k=n-1;k>=0;k--){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tint nang;\n\t\t\t\tint cang=i;\n\t\t\t\tint oang=j;\n\t\t\t\tint pos=k;\n\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\t\t\t\telse nang=(cang+1)%4;\n\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n\t\t\t}\n\t\t}\n\t}\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii> > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(0,0),pii(sy,sx)));\n\td[sy][sx][0]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.second.second;\n\t\tint cy=p.second.first;\n\t\tint cang=p.first.second;\n\t\tint cpos=p.first.first;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cy][cx][cang]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=toAng[cang][nang][cpos];\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[ny][nx][nang]>npos){\n\t\t\t\td[ny][nx][nang]=npos;\n\t\t\t\tpq.push(make_pair(pii(npos,nang),pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[gy][gx][i]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint n;\n\tint w;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.n> r.n;\n\t}\n};\n\n#define Seg_Max_N (1<<18) \nusing Value = vector<int>;\nValue dat[2 * Seg_Max_N];\nstruct segtree {\n\tint N;\n\tconst Value ini = vector<int>(4,1e9);\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, int place,int num) {\n\t\tk += N - 1; // leaf\n\t\tdat[k][num] = place;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tvector<int>ndat(4);\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tndat[i] = min(al[i], ar[i]);\n\t\t\t}\n\t\t\tdat[k] = ndat;\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\tvector<int>ndat(4);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tndat[i] = min(al[i], ar[i]);\n\t\t}\n\t\treturn ndat;\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\tsegtree seg(N+1);\n\t\tif (!H)break;\n\t\tstring st;\n\t\tcin >> st;\n\t\tseg.update(0, 0,0);\n\t\tint way = 3;\n\t\tvector<int>ways;\n\t\tways.push_back(way);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'L') {\n\t\t\t\tway = (way + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway = (way + 3) % 4;\n\t\t\t}\n\t\t\tways.push_back(way);\n\t\t\tseg.update(i + 1, i+1,way);\n\t\t}\n\t\tvector<vector<int>>next;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tvector<int>v(seg.query(i + 1, N + 1));\n\t\t\tfor (int j = 0; j < ways[i]; ++j) {\n\t\t\t\trotate(v.begin(), v.end(),v.end());\n\t\t\t}\n\t\t\tnext.push_back(v);\n\t\t}\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int x = 0; x <= W + 1; ++x) {\n\t\t\tint y = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\ty = H + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tfor (int y = 0; y <= H + 1; ++y) {\n\t\t\tint x = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\tx = W + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tvector<vector<vector<int>>>memo(H + 2, vector<vector<int>>(W + 2,vector<int>(4,1e8)));\n\t\tint gx, gy;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring ast; cin >> ast;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (ast[j] == 'G') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == 'S') {\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == '#') {\n\t\t\t\t\tfield[i + 1][j+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sx,sy,0 ,3});\n\t\tmemo[sy][sx][3] = 0;\n\t\tstring ans = \"No\";\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int px = atop.x;\n\t\t\tconst int py = atop.y;\n\t\t\tconst int pn = atop.n;\n\t\t\tconst int pw = atop.w;\n\t\t\tif (px == gx&&py == gy) {\n\t\t\t\tans = \"Yes\"; break;\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nx = px + dx[pw];\n\t\t\t\tconst int ny = py + dy[pw];\n\t\t\t\tif (!field[ny][nx]) {\n\t\t\t\t\tif (memo[ny][nx][pw] > pn) {\n\t\t\t\t\t\tmemo[ny][nx][pw] = pn;\n\t\t\t\t\t\tque.push(aa{ nx,ny,pn,pw });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pn != N) {\n\t\t\t\tfor (int i = 0; i<4; ++i) {\n\t\t\t\t\tif (next[pn][i]<1e8) {\n\t\t\t\t\t\tif (memo[py][px][i] >next[pn][i]) {\n\t\t\t\t\t\t\tmemo[py][px][i] = next[pn][i];\n\t\t\t\t\t\t\tque.push(aa{ px,py,next[pn][i],i });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000005\n#define MAX_H 1005\n#define MAX_W 1005\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint INF = 1e8;\nstruct state{\n  int y,x,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nint H,W,N;\nint si,sj,ti,tj;\nchar a[MAX_N];\nint b[MAX_N];\nset<int> c[4];\n\nchar t[MAX_H][MAX_W];\nint d[MAX_H][MAX_W];\n\nint func(int k,int dir){\n  set<int> :: iterator it;\n  it=c[dir].lower_bound(k);\n  if(it==c[dir].end())return INF;\n  else return *it;\n}\n\nbool solve(){\n  fill( (int*)d[0], (int*)d[MAX_H] , INF );\n  priority_queue< state > Q;\n  Q.push( (state){si,sj,0} );\n  d[si][sj]=0;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost > d[s.y][s.x])continue;\n    if(t[s.y][s.x]=='G')return true;\n    for(int ndir=0;ndir<4;ndir++){\n      int ncost=func(s.cost,ndir);\n      if(ncost==INF)continue;\n      int ny=s.y+dy[ndir];\n      int nx=s.x+dx[ndir];\n      if(ny<0 || nx<0 || ny>=H || nx>=W )continue;\n      if(t[ny][nx]=='#')continue;\n      if(ncost < d[ny][nx]){\n        d[ny][nx]=ncost; \n        Q.push( (state){ny,nx,ncost} );\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d\",&H,&W,&N);\n    if(H==0&&W==0&&N==0)break;\n    for(int i=0;i<4;i++)c[i].clear();\n    \n    scanf(\"%s\",a);\n    for(int i=0;i<N;i++){\n      b[i+1]=b[i]+(a[i]=='L'?3:1);\n      if(b[i+1]>=4)b[i+1]-=4;\n    }\n    for(int i=0;i<=N;i++)c[ b[i] ].insert(i);\n    \n    for(int i=0;i<H;i++){\n      scanf(\"%s\",t[i]);\n      for(int j=0;j<W;j++){\n        if(t[i][j]=='S')si=i,sj=j;\n      }\n    }\n    printf(solve() ? \"Yes\\n\" : \"No\\n\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\nint dfs(int cang,int oang,int pos){\n\tif(cang==oang)return pos;\n\telse if(pos==n)return INF;\n\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n\tint nang;\n\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\telse nang=(cang+1)%4;\n\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n}\n\nbool bfs(){\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t//memset(toAng,-1,sizeof(toAng));\n\tfor(int i=0;i<4;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\ttoAng[i][i][j]=i;\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tint nang;\n\t\t\t\tint cang=i;\n\t\t\t\tint oang=j;\n\t\t\t\tint pos=k;\n\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\t\t\t\telse nang=(cang+1)%4;\n\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n\t\t\t}\n\t\t}\n\t}\n\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii> > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(sy,sx),pii(0,0)));\n\td[sy][sx][0]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.first.second;\n\t\tint cy=p.first.first;\n\t\tint cang=p.second.first;\n\t\tint cpos=p.second.second;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cy][cx][cang]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=toAng[cang][nang][cpos];\n\t\t\tint cnt=npos-cpos;\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[ny][nx][nang]>npos){\n\t\t\t\td[ny][nx][nang]=npos;\n\t\t\t\tpq.push(make_pair(pii(ny,nx),pii(nang,npos)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[gy][gx][i]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w, n, d[N][N][4];\nstring o, s[N];\nint sy, sx;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\npriority_queue<P2,vector<P2>,greater<P2> > q;\n\nbool dijkstra(){\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  \n  q.push(P2(P(0,0),P(sy,sx)));\n\n  d[sy][sx][0]=0;\n\n  bool res=false;\n  \n  while(!q.empty()){\n\n    P2 t=q.top(); q.pop();\n\n    int cost=t.first.first;\n    int dir=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x][dir]<cost) continue;\n    \n    if(s[y][x]=='G') res=true;\n\n    if(cost<n&&o[cost]=='R'&&d[y][x][(dir+1)%4]>cost+1){\n\n      d[y][x][(dir+1)%4]=cost+1;\n      \n      q.push(P2(P(cost+1,(dir+1)%4),P(y,x)));\n    }\n\n    if(cost<n&&o[cost]=='L'&&d[y][x][(dir+3)%4]>cost+1){\n      \n      d[y][x][(dir+3)%4]=cost+1;\n      \n      q.push(P2(P(cost+1,(dir+3)%4),P(y,x)));\n    }\n    \n    int ny=y+dy[dir], nx=x+dx[dir];\n    \n    if(ny<0||nx<0||h<=ny||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n\n    if(d[ny][nx][dir]>cost){\n\n      d[ny][nx][dir]=cost;\n      \n      q.push(P2(P(cost,dir),P(ny,nx)));\n    }\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  while(1) {\n    \n    cin>>h>>w>>n;\n    if(!h&&!w&&!n) break;\n  \n    cin>>o;\n\n    for(int i=0;i<h;i++){\n    \n      cin>>s[i];\n\n      for(int j=0;j<w;j++)\n\tif(s[i][j]=='S') sy=i, sx=j;\n    \n    }\n\n    if(dijkstra()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,-1,0,1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 1000;\nint dp[N][N][4];\n\nvector<string> field;\nset<int> next_idx[4];\nvi dirs;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n    int h, w, n; cin >> h >> w >> n;\n    if(h == 0) break;\n\n    string commands; cin >> commands;\n    vector<string> field(h); rep(y, h) cin >> field[y];\n    int sx, sy, gx, gy;\n    rep(y, h){\n        rep(x, w){\n            if(field[y][x] == 'S'){\n                sx = x, sy = y;\n                field[y][x] = '.';\n            }\n            if(field[y][x] == 'G'){\n                gx = x, gy = y;\n                field[y][x] = '.';\n            }\n        }\n    }\n\n    rep(i, 4) next_idx[i].clear();\n    int d = 0; next_idx[0].insert(0);\n    dirs = vi(n + 1); dirs[0] = 0;\n    rep(i, n){\n        char c = commands[i];\n        if(c == 'L'){\n            (d += 1) %= 4;\n        }\n        else {\n            (d += 3) %= 4;\n        }\n        next_idx[d].insert(i + 1);\n        dirs[i + 1] = d;\n    }\n\n    rep(y, N) rep(x, N) rep(d, 4) dp[y][x][d] = inf;\n    using Elem = tuple<int, int, int, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    q.push(Elem(0, sx, sy, 1));\n    dp[sy][sx][1] = 0;\n\n    bool ok = false;\n    while(q.size()){\n        int x, y, d, idx; tie(idx, x, y, d) = q.top(); q.pop();\n        if(idx != dp[y][x][d]) continue;\n\n        if(x == gx and y == gy){\n            ok = true;\n            break;\n        }\n\n        rep(nd, 4){\n            int nx = x + dx[nd];\n            int ny = y + dy[nd];\n            if(nx < 0 or w <= nx or ny < 0 or h <= ny or field[y][x] == '#') continue;\n\n            int nidx = idx;\n            if(nd != d){\n                int ang = (nd - d + dirs[idx] + 4) % 4;\n                auto itr = next_idx[ang].lower_bound(idx);\n                if(itr == end(next_idx[ang])) continue;\n                nidx = *itr;\n            }\n            if(chmin(dp[ny][nx][nd], nidx)){\n                q.push(Elem(nidx, nx, ny, nd));\n            }\n        }\n    }\n\n    cout << (ok ? \"Yes\":\"No\") << endl;\n}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Data{\npublic:\n    int y, x, d;\n    Data(int y0, int x0, int d0){\n        y = y0;\n        x = x0;\n        d = d0;\n    }\n};\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint main()\n{\n    for(;;){\n        int h, w, n;\n        cin >> h >> w >> n;\n        if(h == 0)\n            return 0;\n\n        string command;\n        cin >> command;\n\n        vector<string> grid(h+2, string(w+2, '#'));\n        int sy, sx, gy, gx;\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] == 'S'){\n                    sy = i;\n                    sx = j;\n                    grid[i][j] = '.';\n                }\n                if(grid[i][j] == 'G'){\n                    gy = i;\n                    gx = j;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n\n        vector<vector<int> > minChange(n+1, vector<int>(4));\n        int d = (count(command.begin(), command.end(), 'R') + count(command.begin(), command.end(), 'L') * 3) % 4;\n        vector<int> tmp(4, INT_MAX);\n        for(int i=n; i>=0; --i){\n            tmp[d] = i;\n            minChange[i] = tmp;\n            if(i > 0){\n                if(command[i-1] == 'R')\n                    d += 3;\n                else\n                    ++ d;\n                d %= 4;\n            }\n        }\n\n        multimap<int, Data> mm;\n        mm.insert(make_pair(0, Data(sy, sx, 0)));\n        vector<vector<vector<int> > > minTurn(h+2, vector<vector<int> >(w+2, vector<int>(4, INT_MAX)));\n        minTurn[sy][sx][0] = 0;\n        bool ok = false;\n        while(!mm.empty()){\n            int turn0 = mm.begin()->first;\n            int y0 = mm.begin()->second.y;\n            int x0 = mm.begin()->second.x;\n            int d0 = mm.begin()->second.d;\n            mm.erase(mm.begin());\n            if(turn0 > minTurn[y0][x0][d0])\n                continue;\n\n            if(y0 == gy && x0 == gx){\n                ok = true;\n                break;\n            }\n\n            for(int i=0; i<4; ++i){\n                int turn = minChange[turn0][i];\n                if(turn < minTurn[y0][x0][i]){\n                    minTurn[y0][x0][i] = turn;\n                    mm.insert(make_pair(turn, Data(y0, x0, i)));\n                }\n            }\n            int y = y0 + dy[d0];\n            int x = x0 + dx[d0];\n            if(grid[y][x] != '#' && turn0 < minTurn[y][x][d0]){\n                minTurn[y][x][d0] = turn0;\n                mm.insert(make_pair(turn0, Data(y, x, d0)));\n            }\n        }\n\n        if(ok)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,N;\nstring o,s[1000];\nbool vis[1000][1000][4];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nbool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W>>N;\n\t\tif(H==0) break;\n\t\tcin>>o;\n\t\trep(i,H) cin>>s[i];\n\t\tvector<int> qx,qy,qd,Qx,Qy,Qd;\n\t\trep(i,H) rep(j,W) rep(d,4) vis[i][j][d]=0;\n\t\trep(i,H) rep(j,W) if(s[i][j]=='S'){\n\t\t\tint x=i,y=j;\n\t\t\twhile(is(x,y)){\n\t\t\t\tqx.pb(x),qy.pb(y),qd.pb(0),vis[x][y][0]=1;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\tif(qx.empty()) break;\n\t\t\trep(j,qx.size()){\n\t\t\t\tint x=qx[j],y=qy[j],d=qd[j];\n\t\t\t\tint nd=(d+(o[i]=='L'?1:3))%4;\n\t\t\t\tint a=x,b=y;\n\t\t\t\twhile(is(a,b)&&!vis[a][b][nd]){\n\t\t\t\t\tvis[a][b][nd]=1;\n\t\t\t\t\tQx.pb(a),Qy.pb(b),Qd.pb(nd);\n\t\t\t\t\ta+=dx[nd],b+=dy[nd];\n\t\t\t\t}\n\t\t\t}\n\t\t\tqx=Qx,qy=Qy,qd=Qd;\n\t\t\tQx.clear();Qy.clear();Qd.clear();\n\t\t}\n\t\trep(i,H) rep(j,W) if(s[i][j]=='G'){\n\t\t\tif(vis[i][j][0]||vis[i][j][1]||vis[i][j][2]||vis[i][j][3]) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n  int x,y,d,idx;\n  State(){}\n  State(int _x,int _y,int _d,int _idx){\n    x = _x;\n    y = _y;\n    d = _d;\n    idx = _idx;\n  }\n};\n\nint sx,sy;\nint gx,gy;\n\nint h,w,n;\nint next_dir[1000002][4];\nbool closed[1002][1002][4];\nchar t[1002][1002];\nstring s;\n\nint dir[1000002];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nbool solve(){\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n\n  open.push(State(sx,sy,0,0));\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y][st.d]){\n      continue;\n    }\n    closed[st.x][st.y][st.d] = true;\n\n    if(st.x == gx && st.y == gy){\n      return true;\n    }\n\n    rep(i,4){\n      if(next_dir[st.idx][i] != -1){\n        int nx = st.x + dx[i];\n        int ny = st.y + dy[i];\n\n        if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] == '#'){\n          nx -= dx[i];\n          ny -= dy[i];\n        }\n\n        open.push(State(nx,ny,i,next_dir[st.idx][i]));\n      }\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  while(cin>>h>>w>>n,h||w||n){\n    cin>>s;\n\n    rep(i,h){\n      cin>>t[i];\n      rep(j,w){\n        if(t[i][j] == 'S'){\n          sx = j;\n          sy = i;\n        }\n        else if(t[i][j] == 'G'){\n          gx = j;\n          gy = i;\n        }\n      }\n    }\n\n    memset(next_dir,-1,sizeof(next_dir));\n\n    int d = 0;\n\n    rep(i,n+1){\n      dir[i] = d;\n      if(s[i] == 'L'){\n        d = (d + 3) % 4;\n      }\n      else{\n        d = (d + 1) % 4;\n      }\n    }\n\n    int table[4];\n    memset(table,-1,sizeof(table));\n\n    for(int i=n;i>=0;i--){\n      table[dir[i]] = i;\n      rep(j,4){\n        next_dir[i][j] = table[j];\n      }\n    }\n\n    bool flg = solve();\n    cout<<(flg ? \"Yes\" : \"No\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nvector<vector<vi>> dist;\nvector<vector<vi>> todir;\nvs fld;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tdist.clear();\n\t\tdist.resize(h, vector<vi>(w, vi(4, INF)));\n\t\ttodir.resize(n + 1, vector<vi>(4, vi(4, INF)));\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tpriority_queue<tuple<int, int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(0, i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint p, x, y, dir;\n\t\t\ttie(p, x, y, dir) = que.top();\n\t\t\tque.pop();\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] == INF)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(p, nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (tmp < INF && dist[x][y][i] == INF)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp, x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000005\n#define MAX_H 1005\n#define MAX_W 1005\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint INF = 1e8;\nstruct state{\n  int y,x,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nint H,W,N;\nint si,sj,ti,tj;\nchar a[MAX_N];\nint b[4][MAX_N];\n\nchar t[MAX_H][MAX_W];\nint d[MAX_H][MAX_W];\n\n\nbool solve(){\n  fill( (int*)d[0], (int*)d[MAX_H] , INF );\n  priority_queue< state > Q;\n  Q.push( (state){si,sj,0} );\n  d[si][sj]=0;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost > d[s.y][s.x])continue;\n    if(t[s.y][s.x]=='G')return true;\n    for(int ndir=0;ndir<4;ndir++){\n      int ncost=b[ndir][s.cost];\n      if(ncost==-1)continue;\n      int ny=s.y+dy[ndir];\n      int nx=s.x+dx[ndir];\n      if(ny<0 || nx<0 || ny>=H || nx>=W )continue;\n      if(t[ny][nx]=='#')continue;\n      if(ncost < d[ny][nx]){\n        d[ny][nx]=ncost; \n        Q.push( (state){ny,nx,ncost} );\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d\",&H,&W,&N);\n    if(H==0&&W==0&&N==0)break;\n    \n    scanf(\"%s\",a);\n\n    memset(b,-1,sizeof(b));\n    int dir=0;\n    for(int i=0;i<=N;i++){\n      b[dir][i]=i;\n      if(i<N)dir=dir+(a[i]=='L'?3:1);\n      if(dir>=4)dir-=4;\n    }\n    for(int i=N-1;i>=0;i--){\n      for(int j=0;j<4;j++){\n        if(b[j][i]==-1)b[j][i]=b[j][i+1];\n      }\n    }\n    \n    for(int i=0;i<H;i++){\n      scanf(\"%s\",t[i]);\n      for(int j=0;j<W;j++){\n        if(t[i][j]=='S')si=i,sj=j;\n      }\n    }\n    printf(solve() ? \"Yes\\n\" : \"No\\n\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nchar fie[1001][1001];\nint H,W,N;\nint memo[1001][1001];\nchar S[1000001];\nint Ds[1000001][4];\n \nint dx[]={0,1,0,-1};//R -> +1 , L -> +1\nint dy[]={-1,0,1,0};\n \nint sx,sy,gx,gy;\n \nstruct state{\n  int x,y,c;\n  bool operator>(const state &st) const{\n    return c > st.c;\n  }\n \n};\n \nbool check( int x,int y,int nc){\n  if( x < 0 || y < 0 || x >= W || y >= H ) return false;\n  if( fie[x][y] == '#' ) return false;\n  if( memo[x][y] == -1 ) return true;\n  if( memo[x][y] <= nc ) return false;\n  return true;\n}\n \n \n \nbool bfs(){\n \n  memset(memo,-1,sizeof(memo));\n \n  priority_queue<state,vector<state>,greater<state> > q;\n \n  q.push( (state){sx,sy,0} );\n  memo[sx][sy] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    int x = p.x;\n    int y = p.y;\n    int c = p.c;\n \n    //  cout << x<< \" \" << y << \" \"<< c << endl;\n \n    for(int i=0;i<4;i++){\n      int nd = i;\n      int nc = Ds[c][nd];\n      if( nc > N ) continue;\n      int nx = x+dx[nd];\n      int ny = y+dy[nd];\n      if( check(nx,ny,nc) ){\n    q.push( (state){nx,ny,nc} );\n    memo[nx][ny] = nc;\n      }\n    }\n  }\n  if( memo[gx][gy] == -1 )\n    return false;\n  return true;\n}\n \nint main(){\n  while(cin >> H >> W >> N && (H||W||N) ){\n    for(int i=1;i<=N;i++){\n      cin >> S[i];\n    }\n    S[0] = 0;\n    int dnc = 0;\n    for(int i=1;i<=N;i++){\n      if( S[i] == 'L' ){\n    dnc+=3; \n      } else {\n    dnc++;\n      }\n      dnc %= 4;\n      S[i] = (char)dnc;\n    }\n     \n    int dc[4] = {N+1,N+1,N+1,N+1};\n    for(int i=N;i>-1;i--){\n      dc[(int)S[i]] = i;\n      for(int j=0;j<4;j++){\n    Ds[i][j] = dc[j];\n    //  printf(\"%d, %d  %d\\n\",i-1,j,(int)Ds[i-1][j]);\n      }\n    }\n \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n    cin >> fie[j][i];\n    if( fie[j][i] == 'G' ){\n      gx=j;\n      gy=i;\n    }\n    if( fie[j][i] == 'S' ){\n      sx = j;\n      sy = i;\n    }\n      }\n    }\n     \n    if( bfs() ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\n\nint main()\n{\n\tfor(int h,w,n;cin>>h>>w>>n && h|w|n;){\n\t\tvi ls,rs;\n\t\t{\n\t\t\tstring t; cin>>t;\n\t\t\trep(i,n)\n\t\t\t\t(t[i]=='L'?ls:rs).push_back(i);\n\t\t}\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tconst int di[]={0,1,0,-1},dj[]={1,0,-1,0}; // east,south,west,north\n\t\tqueue<tuple<int,int,int,int>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S') q.emplace(i,j,3,0);\n\t\tvvvi vis(4,vvi(h,vi(w)));\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tint i,j,d,p; tie(i,j,d,p)=q.front(); q.pop();\n\t\t\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[d][i][j]) continue;\n\t\t\tvis[d][i][j]=1;\n\t\t\tif(grid[i][j]=='G'){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.emplace(i+di[d],j+dj[d],d,p);\n\t\t\tint l=lower_bound(all(ls),p)-begin(ls);\n\t\t\tint r=lower_bound(all(rs),p)-begin(rs);\n\t\t\tif(l+1<=ls.size() && (r+3>rs.size() || ls[l+1]<rs[r+3])) q.emplace(i,j,(d+3)%4,l+1);\n\t\t\tif(r+3<=rs.size() && (l+1>ls.size() || rs[r+3]<ls[l+1])) q.emplace(i,j,(d+3)%4,r+3);\n\t\t\tif(r+1<=rs.size() && (l+3>ls.size() || rs[r+1]<ls[l+3])) q.emplace(i,j,(d+1)%4,r+1);\n\t\t\tif(l+3<=ls.size() && (r+1>rs.size() || ls[l+3]<rs[r+1])) q.emplace(i,j,(d+1)%4,l+3);\n\t\t}\n\t\tcout<<(res?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nconst int N = 1000;\nconst int inf = (1<<28);\nenum{NORTH=0,EAST=1,SOUTH=2,WEST=3};\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint cost[N][N][4];\nint dir[N*N+1];\nint next[N*N+1][4];\nchar m[N][N+1];\n\nvoid precalc(string in){\n  in=\" \"+in;\n  int td = NORTH;\n  for(int i=1;i<in.size();i++){\n    if (in[i] == 'R')td++;\n    else if (in[i] == 'L')td+=3;\n    td%=4;\n    dir[i]=td;\n  }\n  int last[4]={inf,inf,inf,inf};\n  for(int i=in.size()-1;i>=0;i--){\n    last[dir[i]]=i;\n    for(int j=0;j<4;j++){\n      next[i][j]=last[j];\n    }\n  }\n  /*\n  for(int i=0;i<in.size();i++){\n    cout <<\"dir of \" << i <<\" is \" << dir[i] << \" : next is \";\n    for(int j=0;j<4;j++)cout << next[i][j] <<\" \" ;cout << endl;\n  }cout << endl;\n  */\n}\n\nclass st{\npublic:\n  int y,x,d;\n  int cost;\n  bool operator<(const st & a)const{\n    return cost > a.cost;\n  }\n};\n\nvoid solve(int r,int c,int sy,int sx){\n  for(int i=0;i<r;i++)\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)cost[i][j][k]=inf;\n  cost[sy][sx][NORTH]=0;\n  priority_queue<st> Q;\n  Q.push((st){sy,sx,NORTH,0});\n  while(!Q.empty()){\n    st now = Q.top();Q.pop();\n    if (cost[now.y][now.x][now.d] != now.cost)continue;\n    if (m[now.y][now.x] == 'G'){\n      cout <<\"Yes\" << endl;\n      return;\n    }\n\n    {\n      int nex=now.x+dx[now.d],ney=now.y+dy[now.d];\n      int nec=now.cost;\n      if (nex != -1 && ney != -1 && nex != c && ney != r &&\n\t  m[ney][nex] != '#' && cost[ney][nex][now.d] > nec){\n\tcost[ney][nex][now.d] = nec;\n\tQ.push((st){ney,nex,now.d,nec});\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      int ned=i;\n      int nec=next[now.cost][i];\n      if (cost[now.y][now.x][ned] > nec){\n\tcost[now.y][now.x][ned] = nec;\n\tQ.push((st){now.y,now.x,ned,nec});\n      }\n    }\n  }\n  cout <<\"No\"<<endl;\n}\n\nmain(){\n  int r,c,n;\n  while(cin>>r>>c>>n && r){\n    string in;cin>>in;\n    for(int i=0;i<r;i++)cin>>m[i];\n    int sy,sx;\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tif (m[i][j] == 'S'){sy=i,sx=j;break;}\n      }\n    }\n    precalc(in);\n    solve(r,c,sy,sx);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint n;\n\tint w;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.n> r.n;\n\t}\n};\n\n\nvector<vector<int>>wheres(4);\nvector<vector<int>>anext;\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\tanext.clear();\n\t\twheres.resize(4);\n\t\tif (!H)break;\n\t\tstring st;\n\t\tcin >> st;\n\t\tint way = 3;\n\t\tvector<int>ways;\n\t\tways.push_back(way);\n\t\twheres[way].push_back(0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'L') {\n\t\t\t\tway = (way + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway = (way + 3) % 4;\n\t\t\t}\n\t\t\tways.push_back(way);\n\t\t\twheres[way].push_back(i + 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tvector<int>v;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tauto it = upper_bound(wheres[j].begin(), wheres[j].end(), i);\n\t\t\t\tif (it == wheres[j].end())v.push_back(1e8);\n\t\t\t\telse v.push_back(*it);\n\t\t\t}\n\t\t\tfor (int j = 0; j < ways[i]; ++j) {\n\t\t\t\trotate(v.begin(), v.end(),v.end());\n\t\t\t}\n\t\t\tanext.push_back(v);\n\t\t}\n\t\twheres.clear();\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int x = 0; x <= W + 1; ++x) {\n\t\t\tint y = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\ty = H + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tfor (int y = 0; y <= H + 1; ++y) {\n\t\t\tint x = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\tx = W + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tvector<vector<vector<int>>>memo(H + 1, vector<vector<int>>(W+1,vector<int>(4,1e8)));\n\t\tint gx, gy;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring ast; cin >> ast;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (ast[j] == 'G') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == 'S') {\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == '#') {\n\t\t\t\t\tfield[i + 1][j+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sx,sy,0 ,3});\n\t\tmemo[sy][sx][3] = 0;\n\t\tstring ans = \"No\";\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int px = atop.x;\n\t\t\tconst int py = atop.y;\n\t\t\tconst int pn = atop.n;\n\t\t\tconst int pw = atop.w;\n\t\t\tif (px == gx&&py == gy) {\n\t\t\t\tans = \"Yes\"; break;\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nx = px + dx[pw];\n\t\t\t\tconst int ny = py + dy[pw];\n\t\t\t\tif (!field[ny][nx]) {\n\t\t\t\t\tif (memo[ny][nx][pw] > pn) {\n\t\t\t\t\t\tmemo[ny][nx][pw] = pn;\n\t\t\t\t\t\tque.push(aa{ nx,ny,pn,pw });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pn != N) {\n\t\t\t\tfor (int i = 0; i<4; ++i) {\n\t\t\t\t\tif (anext[pn][i]<1e8) {\n\t\t\t\t\t\tif (memo[py][px][i] >anext[pn][i]) {\n\t\t\t\t\t\t\tmemo[py][px][i] = anext[pn][i];\n\t\t\t\t\t\t\tque.push(aa{ px,py,anext[pn][i],i });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nvector<vector<vi>> dist;\nvector<vector<vi>> todir;\nvs fld;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tdist.clear();\n\t\tdist.resize(1001, vector<vi>(1001, vi(4, INF)));\n\t\tdist.resize(1000001, vector<vi>(4, vi(4, INF)));\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (dist[x][y][i] > tmp)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\t\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\t\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\t//using first_argument_type=decltype(helper(&Functor::operator()));\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nint main()\n{\n\ttypedef vector<vvi> vvvi;\n\tconst int di[]={-1,0,1,0},dj[]={0,-1,0,1};\n\t\n\tfor(int h,w,n;cin>>h>>w>>n && h|w|n;){\n\t\tstring t; cin>>t;\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tvi ds(n+1);\n\t\trep(i,n){\n\t\t\tif(t[i]=='L') ds[i+1]=(ds[i]+1)%4;\n\t\t\tif(t[i]=='R') ds[i+1]=(ds[i]+3)%4;\n\t\t}\n\t\tvvi next(n+1,vi(4));\n\t\t{\n\t\t\tvi tmp(4,INF);\n\t\t\tper(i,n+1){\n\t\t\t\ttmp[ds[i]]=i;\n\t\t\t\trep(j,4) next[i][j]=tmp[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// (i,j,d,p)\n\t\tauto pq=make_priority_queue(\n\t\t\t[](tuple<int,int,int,int> a,tuple<int,int,int,int> b){return get<3>(a)>get<3>(b);}\n\t\t);\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S') pq.emplace(i,j,0,0);\n\t\tvvvi vis(h,vvi(w,vi(4)));\n\t\tbool res=false;\n\t\twhile(pq.size()){\n\t\t\tint i,j,d,p; tie(i,j,d,p)=pq.top(); pq.pop();\n\t\t\tif(i<0 || h<=i || j<0 || w<=j || p==INF || grid[i][j]=='#' || vis[i][j][d]) continue;\n\t\t\tvis[i][j][d]=true;\n\t\t\tif(grid[i][j]=='G'){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(k,4) pq.emplace(i+di[k],j+dj[k],k,next[p][k]);\n\t\t}\n\t\tcout<<(res?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\ntypedef pair<int,P2> P3;\nconst int MAX=1000000007;\n\nint dy[4]={-1,0,1,0},dx[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {\n  if(x<0 || x>=n) return false;\n  if(y<0 || y>=m) return false;\n  return true;\n}\n\nint main() {\n  int n,m,k;\n  while(cin >> n >> m >> k && (n||m||k)) {\n    string c;\n    string s[n];\n    cin >> c;\n    for(int i=0; i<n; i++) cin >> s[i];\n    int d[n][m][4];\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tfor(int l=0; l<4; l++) d[i][j][l]=MAX;\n      }\n    }\n    int sx,sy,tx,ty;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tif(s[i][j]=='S') {\n\t  sx=i;sy=j;\n\t}\n\tif(s[i][j]=='G') {\n\t  tx=i;ty=j;\n\t}\n      }\n    }\n    priority_queue<P3,vector<P3>,greater<P3> > que;\n    que.push(P3(0,P2(1,P(sx,sy))));\n    d[sx][sy][1]=0;\n    bool ck=false;\n    while(!que.empty()) {\n      P3 p=que.top();que.pop();\n      int j=p.first,z=p.second.first,nx=p.second.second.first,ny=p.second.second.second;\n      if(nx==tx && ny==ty) {\n\tck=true;\n\tbreak;\n      }\n      int x=nx+dx[z],y=ny+dy[z];\n      if(check(n,m,x,y) && s[x][y]!='#' && d[x][y][z]>j) {\n\td[x][y][z]=j;\n\tque.push(P3(j,P2(z,P(x,y))));\n      }\n      if(j<k) {\n\tx=nx;y=ny;\n\tint z2=z;\n\tif(c[j]=='L') z2--;\n\telse z2++;\n\tif(z2<0) z2+=4;\n\tif(z2>=4) z2-=4;\n\tif(check(n,m,x,y) && s[x][y]!='#' && d[x][y][z2]>j+1) {\n\t  d[x][y][z2]=j+1;\n\t  que.push(P3(j+1,P2(z2,P(x,y))));\n\t}\n      }\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct State{\n    int y,x,d;\n};\n\nconst int N = 1000;\nconst int INF = 19191919;\n\nconst int dx[4]={0,1,0,-1}, dy[4]={-1,0,1,0};\n\nint d[N][N][4];\nvector<int> dir[4];\n\n\n\nint main(){\n    int h,w,n;\n    while(cin >>h >>w >>n,h){\n        // initialize\n        rep(i,N)rep(j,N)rep(k,4) d[i][j][k]=INF;\n        rep(i,4) dir[i].clear();\n\n        string c;\n        cin >>c;\n        vector<string> f(h);\n        rep(i,h) cin >>f[i];\n\n        int nd = 0;\n        rep(i,n){\n            dir[nd].pb(i);\n            if(c[i]=='L') nd = (nd+3)%4;\n            else nd = (nd+1)%4;\n        }\n        dir[nd].pb(n);\n        rep(i,4) dir[i].pb(INF);\n\n        int sy,sx,gy,gx;\n        rep(i,h)rep(j,w){\n            if(f[i][j]=='S'){\n                sy = i;\n                sx = j;\n            }\n            if(f[i][j]=='G'){\n                gy = i;\n                gx = j;\n            }\n        }\n\n        auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n        queue<State> que;\n        que.push({sy,sx,0});\n        d[sy][sx][0] = 0;\n        while(!que.empty()){\n            State now = que.front();\n            que.pop();\n\n            if(now.y==gy && now.x==gx) break;\n\n            int D = d[now.y][now.x][now.d];\n\n            // 今向いてる方に進む\n            int ny = now.y+dy[now.d], nx = now.x+dx[now.d];\n            if(IN(ny,nx) && f[ny][nx]!='#'){\n                if(d[ny][nx][now.d] > D){\n                    d[ny][nx][now.d] = D;\n                    que.push({ny,nx,now.d});\n                }\n            }\n\n            rep(i,4)if(i!=now.d){\n                int dd = *lower_bound(all(dir[i]), D);\n                if(d[now.y][now.x][i] > dd){\n                    d[now.y][now.x][i] = dd;\n                    que.push({now.y,now.x,i});\n                }\n            }\n        }\n\n        int ans = INF;\n        rep(i,4) ans = min(ans, d[gy][gx][i]);\n        cout << (ans<INF?\"Yes\":\"No\") << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x;\n  int y;\n  int cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n  bool operator<(const Point &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nint sx, sy;\nint h, w, n;\nchar seq[1000010];\nint dir[1000010];\nint ndir[4][1000010];\nchar field[1010][1010];\nbool visit[1010][1010];\nint dist[1010][1010];\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &n), h|w|n) {\n    MEMSET(dir, 0x0f);\n    MEMSET(ndir, 0x0f);\n    MEMSET(visit, false);\n    MEMSET(dist, 0x0a);\n    scanf(\"%s\", seq);\n    dir[0] = 0;\n    REP(i, n) {\n      dir[i + 1] = (dir[i] + (seq[i] == 'R' ? 1 : 3)) % 4;\n    }\n    for (int i = n; i >= 0; i--) {\n      REP(d, 4) {\n        ndir[d][i] = ndir[d][i + 1];\n      }\n      ndir[dir[i]][i] = i;\n    }\n\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 'S') { sx = x; sy = y; }\n      }\n    }\n    priority_queue<Point> que;\n    que.push(Point(sx, sy, 0));\n    while (!que.empty()) {\n      Point p = que.top();\n      que.pop();\n      if (visit[p.y][p.x]) { continue; }\n      visit[p.y][p.x] = true;\n      if (field[p.y][p.x] == 'G') {\n        puts(\"Yes\");\n        goto next;\n      }\n      REP(d, 4) {\n        int nx = p.x + dx[d];\n        int ny = p.y + dy[d];\n        int ncost = ndir[d][p.cost];\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h || field[ny][nx] == '#') { continue; }\n        if (dist[ny][nx] <= ncost) { continue; }\n        dist[ny][nx] = ncost;\n        que.push(Point(nx, ny, ncost));\n      }\n    }\n    puts(\"No\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint n;\n\tint w;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.n> r.n;\n\t}\n};\n\n\nvector<vector<int>>wheres(4);\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\twheres.resize(4);\n\t\tif (!H)break;\n\t\tstring st;\n\t\tcin >> st;\n\t\tint way = 3;\n\t\tvector<int>ways;\n\t\tways.push_back(way);\n\t\twheres[way].push_back(0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'L') {\n\t\t\t\tway = (way + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway = (way + 3) % 4;\n\t\t\t}\n\t\t\tways.push_back(way);\n\t\t\twheres[way].push_back(i + 1);\n\t\t}\n\t\tvector<vector<int>>next;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tvector<int>v;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tauto it = upper_bound(wheres[j].begin(), wheres[j].end(), i);\n\t\t\t\tif (it == wheres[j].end())v.push_back(1e8);\n\t\t\t\telse v.push_back(*it);\n\t\t\t}\n\t\t\tfor (int j = 0; j < ways[i]; ++j) {\n\t\t\t\trotate(v.begin(), v.end(),v.end());\n\t\t\t}\n\t\t\tnext.push_back(v);\n\t\t}\n\t\twheres.clear();\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int x = 0; x <= W + 1; ++x) {\n\t\t\tint y = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\ty = H + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tfor (int y = 0; y <= H + 1; ++y) {\n\t\t\tint x = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\tx = W + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tvector<vector<vector<int>>>memo(H + 2, vector<vector<int>>(W + 2,vector<int>(4,1e8)));\n\t\tint gx, gy;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring ast; cin >> ast;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (ast[j] == 'G') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == 'S') {\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == '#') {\n\t\t\t\t\tfield[i + 1][j+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sx,sy,0 ,3});\n\t\tmemo[sy][sx][3] = 0;\n\t\tstring ans = \"No\";\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int px = atop.x;\n\t\t\tconst int py = atop.y;\n\t\t\tconst int pn = atop.n;\n\t\t\tconst int pw = atop.w;\n\t\t\tif (px == gx&&py == gy) {\n\t\t\t\tans = \"Yes\"; break;\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nx = px + dx[pw];\n\t\t\t\tconst int ny = py + dy[pw];\n\t\t\t\tif (!field[ny][nx]) {\n\t\t\t\t\tif (memo[ny][nx][pw] > pn) {\n\t\t\t\t\t\tmemo[ny][nx][pw] = pn;\n\t\t\t\t\t\tque.push(aa{ nx,ny,pn,pw });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pn != N) {\n\t\t\t\tfor (int i = 0; i<4; ++i) {\n\t\t\t\t\tif (next[pn][i]<1e8) {\n\t\t\t\t\t\tif (memo[py][px][i] >next[pn][i]) {\n\t\t\t\t\t\t\tmemo[py][px][i] = next[pn][i];\n\t\t\t\t\t\t\tque.push(aa{ px,py,next[pn][i],i });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct State{\n  int cur,h,w,dir;\n  bool operator < (const State& st) const {\n    return cur > st.cur;\n  }\n};\n\nconst int NORTH = 0;\nconst int SIZE = 1001;\nconst int INF = (1<<25);\nint H,W,N;\nint dh[] = {-1,0,1,0};\nint dw[] = {0,1,0,-1};\nstring command;\nchar field[SIZE][SIZE];\nint sh,sw,gh,gw;\nint T[SIZE][SIZE][4];\n\nbool isInside(int h, int w){return 0<=h&&h<H&&0<=w&&w<W;}\n\nvoid input(){\n  cin >> command;\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){sh=i;sw=j;}\n      if(field[i][j] == 'G'){gh=i;gw=j;}\n    }\n}\n\nbool solve(){\n  fill(T[0][0], T[0][0]+SIZE*SIZE*4, INF);\n  priority_queue<State> Q;\n  Q.push((State){0,sh,sw,NORTH});\n  T[sh][sw][NORTH] = 0;\n\n  while(!Q.empty()){\n    const State now = Q.top(); Q.pop();\n\n    if(now.h == gh && now.w == gw) return true;\n    if(T[now.h][now.w][now.dir] < now.cur) continue;\n   \n    // turn around\n    if(now.cur < (int)command.length()){\n      State nex = now;\n      if(command[now.cur] == 'R') nex.dir = (nex.dir+1)%4;\n      else nex.dir = (nex.dir+3)%4;\n      nex.cur++;\n      if(T[nex.h][nex.w][nex.dir] > nex.cur){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n    }\n    \n    // go forward\n    State nex = now;\n    nex.h += dh[nex.dir];\n    nex.w += dw[nex.dir];\n      if(isInside(nex.h,nex.w) && field[nex.h][nex.w] != '#'){\n\tif(T[nex.h][nex.w][nex.dir] > nex.cur){\n\t  T[nex.h][nex.w][nex.dir] = nex.cur;\n\t  Q.push(nex);\n\t}\n      }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H|N|W)){\n    input();\n    cout << (solve()?\"Yes\":\"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nchar s[1234567];\nchar c[1234][1234];\nbool p[4][1234][1234];\n\nint main(){\n  for(int H,W,N;cin>>H>>W>>N,H|W|N;){\n    fill(**begin(p),**end(p),false);\n    cin>>s;\n    int sy,sx;\n    for(int i=0;i<H;i++){\n      cin>>c[i];\n      for(int j=0;j<W;j++){\n\tif(c[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    set<int> r[4];\n    for(int i=0;i<4;i++){\n      r[i].insert(sy*1000+sx);\n      p[i][sy][sx]=true;\n    }\n    int d=0;\n    bool f=false;\n    for(int i=0;;i++){\n      for(auto e:r[d]){\n\tint y=e/1000;\n\tint x=e%1000;\n\tfor(;;){\n\t  static int dy[]={-1,0,1,0};\n\t  static int dx[]={0,1,0,-1};\n\t  int ny=y+dy[d];\n\t  int nx=x+dx[d];\n\t  if(ny<0||H<=ny||nx<0||W<=nx||c[ny][nx]=='#')break;\n\t  y=ny;\n\t  x=nx;\n\t  f|=c[y][x]=='G';\n\t  if(!p[d][y][x]++){\n\t    r[(d+1)%4].insert(y*1000+x);\n\t    r[(d+3)%4].insert(y*1000+x);\n\t  }\n\t}\n      }\n      r[d].clear();\n      if(i==N)break;\n      d=(d+((s[i]=='R')?1:3))%4;\n    }\n    cout<<(f?\"Yes\":\"No\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[4][1010][1010];\nInt di[1123456];\nInt nt[4][1123456];\nsigned main(){\n  Int h,w,n;\n  while(cin>>h>>w>>n,h){\n    string s;\n    cin>>s;\n    vector<string> c(h);\n    for(Int i=0;i<h;i++) cin>>c[i];\n\n    auto calc=[](char c){return c=='R'?1:-1;};\n    memset(di,0,sizeof(di));\n    memset(nt,-1,sizeof(nt));\n    di[0]=0;\n    for(Int i=0;i<n;i++)\n      di[i+1]=(di[i]+calc(s[i])+4)%4;\n    \n    //for(Int i=0;i<=n;i++) cout<<i<<\":\"<<di[i]<<endl;\n    {\n      Int nd[4]={-1,-1,-1,-1};\n      for(Int i=n;i>=0;i--){\n\tnd[di[i]]=i;\n\tfor(Int j=0;j<4;j++) nt[j][i]=nd[j];\n      }\n    }\n    \n    \n    using T = tuple<Int, Int, Int>;\n    memset(dp,-1,sizeof(dp));\n    vector<queue<T> > q(n+1);\n\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};\n    Int dy[]={-1,0,1,0};\n    Int dx[]={0,1,0,-1};\n    Int d=0,y,x;\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(c[i][j]=='S') y=i,x=j;\n\n    dp[d][y][x]=0;\n    q[0].emplace(d,y,x);\n\n    Int ans=0;\n    for(Int i=0;i<=n;i++){\n      while(!q[i].empty()){\n\ttie(d,y,x)=q[i].front();q[i].pop();\n\tif(dp[d][y][x]<i) continue;\n\tif(c[y][x]=='G'){\n\t  ans=1;\n\t  break;\n\t}\n\tfor(Int k=0;k<4;k++){\n\t  Int nd=k,ny=y+dy[k],nx=x+dx[k],ni=nt[k][i];\n\t  if(ni<0) continue;\n\t  if(!in(ny,nx)||c[ny][nx]=='#') continue;\n\t  if(dp[nd][ny][nx]<0||dp[nd][ny][nx]>ni){\n\t    dp[nd][ny][nx]=ni;\n\t    q[ni].emplace(nd,ny,nx);\n\t  }\n\t}\n      }\n      if(ans) break;\n    }\n    \n    cout<<(ans?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint h, w, n, sx, sy;\nstring cmd;\nchar a[1001][1001];\nbool vis[1001][1001][4];\n\nint xdir[] = {0, 1, 0, -1};\nint ydir[] = {-1, 0, 1, 0};\n\nclass St{\npublic:\n  int x, y, d, tn;\n\n  St() {}\n  St(int _x, int _y, int _d, int _tn): x(_x), y(_y), d(_d), tn(_tn) {}\n};\n\nvoid aprint(St st)\n{\n  char ch[] = {'N', 'E', 'S', 'W'};\n  cout << \"turn : \" << st.tn << endl;\n\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j)\n      cout << ((i==st.y && j == st.x)? ch[st.d] : a[i][j]);\n    cout << endl;\n  }\n  cout << endl;\n}\n\nstring bfs()\n{\n  queue<St> que;\n  que.push(St(sx, sy, 0, 0));\n  St st;\n  int dx, dy, nd;\n\n  vis[sy][sx][0] = false;\n  while(!que.empty()){\n    st = que.front();\n    que.pop();\n\n    // aprint(st);\n\n    if(a[st.y][st.x] == 'G') return \"Yes\";\n    dx = st.x + xdir[st.d];\n    dy = st.y + ydir[st.d];\n\n    if(0 <= dx && dx < w && 0 <= dy && dy < h && a[dy][dx] != '#' && vis[dy][dx][st.d]){\n      vis[dy][dx][st.d] = false;\n      que.push(St(dx, dy, st.d, st.tn));\n    }\n\n    if(st.tn < n){\n      if(cmd[st.tn] == 'L'){\n\tnd = (st.d+3)%4;\n\tif(vis[st.y][st.x][nd]){\n\t  vis[st.y][st.x][nd] = false;\n\t  que.push(St(st.x, st.y, nd, st.tn+1));\n\t}\n      }\n      else {\n\tnd = (st.d+1)%4;\n\tif(vis[st.y][st.x][nd]){\n\t  vis[st.y][st.x][nd] = false;\n\t  que.push(St(st.x, st.y, nd, st.tn+1));\n\t}\n      }\n    }\n  }\n\n  return \"No\";\n}\n\nint main()\n{\n  while(cin>>h>>w>>n && h+w+n){\n    cin >> cmd;\n    fill(&vis[0][0][0], &vis[h][0][0], true);\n\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j){\n\tcin >> a[i][j];\n\tif(a[i][j] == 'S'){\n\t  a[i][j] = '.';\n\t  sx = j; sy = i;\n\t}\n      }\n\n    cout << bfs() << endl;\n    // break;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 1024\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[4]={0,1,0,-1};\nconst int dy[4]={-1,0,1,0};\n\nstring s;\nstring grid[MAX];\nint h,w,n;\nint d[MAX][MAX][4];\nint sy,sx,gx,gy;\n\nclass State{\n  public:\n    int y,x,d,c;\n    State(int y,int x,int d,int c):y(y),x(x),d(d),c(c){}\n    bool operator<(State s)const{\n      return s.c<c;\n    }\n};\n\nbool in(int y,int x){\n  if(x<0 || y<0 || w<=x || h<=y)return false;\n  return true;\n}\n\nstring solve(){\n  FOR(i,0,MAX)FOR(j,0,MAX)FOR(k,0,4)d[i][j][k]=inf;\n  priority_queue<State> pq;\n  FOR(i,0,h){\n    FOR(j,0,w){\n      if(grid[i][j]=='S'){ sy=i;sx=j; }\n      if(grid[i][j]=='G'){ gy=i;gx=j; }\n    }\n  }\n  d[sy][sx][0]=0;\n  pq.push(State(sy,sx,0,0));\n\n  while(pq.size()){\n    State u = pq.top();\n    pq.pop();\n\n    if(u.y==gy && u.x==gx)return \"Yes\";\n    if(d[u.y][u.x][u.d]<u.c)continue;\n    if(n<u.c)break;\n\n    int ny=u.y+dy[u.d],nx=u.x+dx[u.d],nd=u.d;\n    if(in(ny,nx) && grid[ny][nx]!='#'){\n      if(u.c<d[ny][nx][nd]){\n        d[ny][nx][nd]=u.c;\n        pq.push(State(ny,nx,nd,u.c));\n      }\n    }\n    if(s[u.c]=='R')nd=(u.d+1)%4;\n    else nd=(u.d+3)%4;\n    ny=u.y;nx=u.x;\n    if(u.c+1<d[ny][nx][nd]){\n      d[ny][nx][nd]=u.c+1;\n      pq.push(State(ny,nx,nd,u.c+1));\n    }\n  }\n  return \"No\";\n}\n\nint main()\n{\n  while(cin>>h>>w>>n && h){\n    cin>>s;\n    FOR(i,0,h)cin>>grid[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\ntypedef pair<int,P2> P3;\nconst int MAX=1000000007;\n\nint dy[4]={-1,0,1,0},dx[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {\n  if(x<0 || x>=n) return false;\n  if(y<0 || y>=m) return false;\n  return true;\n}\nint d[1001][1001][4];\npriority_queue<P3,vector<P3>,greater<P3> > que;\n\nint main() {\n  int n,m,k;\n  while(cin >> n >> m >> k && (n||m||k)) {\n    while(!que.empty()) que.pop();\n\n    string c;\n    string s[n];\n    cin >> c;\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tfor(int l=0; l<4; l++) d[i][j][l]=MAX;\n      }\n    }\n\n    int sx,sy,tx,ty;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tif(s[i][j]=='S') {\n\t  sx=i;sy=j;\n\t}\n\tif(s[i][j]=='G') {\n\t  tx=i;ty=j;\n\t}\n      }\n    }\n\n    que.push(P3(0,P2(1,P(sx,sy))));\n    d[sx][sy][1]=0;\n    bool ck=false;\n    while(!que.empty()) {\n      P3 p=que.top();que.pop();\n      int j=p.F,z=p.S.F,nx=p.S.S.F,ny=p.S.S.S;\n      if(nx==tx && ny==ty) {\n\tck=true;\n\tbreak;\n      }\n\n\n      int x=nx+dx[z],y=ny+dy[z];\n      if(check(n,m,x,y) && s[x][y]!='#' && d[x][y][z]>j) {\n\td[x][y][z]=j;\n\tque.push(P3(j,P2(z,P(x,y))));\n      }\n      \n      x=nx;y=ny;\n      int z2=z;\n      bool b[4];\n      memset(b,false,sizeof(b));\n      b[z]=true;\n      for(int i=j; i<k; i++) {\n\tif(c[i]=='L') z2--;\n\telse z2++;\n\tif(z2<0) z2+=4;\n\telse if(z2>=4) z2-=4;\n\tif(b[z2]) continue;\n\tb[z2]=true;\n\tif(d[x][y][z2]>i+1) {\n\t  d[x][y][z2]=i+1;\n\t  que.push(P3(i+1,P2(z2,P(x,y))));\n\t}\n      }\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w, n, next[1000001][4];\nstring s, in[1000];\nbool v[1000][1000][4];\n\n\nint main(){\n\twhile(cin >> h >> w >> n, h){\n\t\tmemset(v, 0, sizeof(v));\n\t\tint y, x, d = 0;\n\t\tcin >> s;\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t\t}\n\t\trep(i, n) d = (d + (s[i] == 'L' ? 1 : 3)) % 4;\n\t\trep(i, 4) next[n][i] = n + 1;\n\t\tnext[n][d] = d;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\td = (d + (s[i] == 'L' ? 3 : 1)) % 4;\n\t\t\trep(j, 4) next[i][j] = j == d ? i : next[i + 1][j];\n\t\t}\n\t\t\n\t\tpriority_queue<pair<pi, pi> > q;\n\t\tq.push(mp(mp(0, 0), mp(y, x)));\n\t\twhile(!q.empty()){\n\t\t\ty = q.top().second.first; x = q.top().second.second;\n\t\t\tint co = q.top().first.first, d = q.top().first.second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(v[y][x][d]) continue;\n\t\t\tv[y][x][d] = 1;\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(0 <= ny && ny < h && 0 <= nx && nx < w){\n\t\t\t\tif(!v[ny][nx][d]) q.push(mp(mp(co, d), mp(ny, nx)));\n\t\t\t}\n\t\t\trep(i, 4) if(!v[y][x][i]){\n\t\t\t\tint nc = next[-co][i];\n\t\t\t\tif(nc <= n) q.push(mp(mp(-nc, i), mp(y, x)));\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint n;\n\tint w;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.n> r.n;\n\t}\n};\n\n#define Seg_Max_N (1<<20) \nusing Value = vector<int>;\nValue dat[2 * Seg_Max_N];\nstruct segtree {\n\tint N;\n\tconst Value ini = vector<int>(4,1e9);\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, int place,int num) {\n\t\tk += N - 1; // leaf\n\t\tdat[k][num] = place;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tvector<int>ndat(4);\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tndat[i] = min(al[i], ar[i]);\n\t\t\t}\n\t\t\tdat[k] = ndat;\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\tvector<int>ndat(4);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tndat[i] = min(al[i], ar[i]);\n\t\t}\n\t\treturn ndat;\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint H, W, N; cin >> H >> W >> N;\n\t\tsegtree seg(N+1);\n\t\tif (!H)break;\n\t\tstring st;\n\t\tcin >> st;\n\t\tseg.update(0, 0,0);\n\t\tint way = 3;\n\t\tvector<int>ways;\n\t\tways.push_back(way);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (st[i] == 'L') {\n\t\t\t\tway = (way + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway = (way + 3) % 4;\n\t\t\t}\n\t\t\tways.push_back(way);\n\t\t\tseg.update(i + 1, i+1,way);\n\t\t}\n\t\tvector<vector<int>>next;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tvector<int>v(seg.query(i + 1, N + 1));\n\t\t\tfor (int j = 0; j < ways[i]; ++j) {\n\t\t\t\trotate(v.begin(), v.end(),v.end());\n\t\t\t}\n\t\t\tnext.push_back(v);\n\t\t}\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 0));\n\t\tfor (int x = 0; x <= W + 1; ++x) {\n\t\t\tint y = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\ty = H + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tfor (int y = 0; y <= H + 1; ++y) {\n\t\t\tint x = 0;\n\t\t\tfield[y][x] = 1;\n\t\t\tx = W + 1;\n\t\t\tfield[y][x] = 1;\n\t\t}\n\t\tvector<vector<vector<int>>>memo(H + 2, vector<vector<int>>(W + 2,vector<int>(4,1e8)));\n\t\tint gx, gy;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring ast; cin >> ast;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (ast[j] == 'G') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == 'S') {\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (ast[j] == '#') {\n\t\t\t\t\tfield[i + 1][j+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ sx,sy,0 ,3});\n\t\tmemo[sy][sx][3] = 0;\n\t\tstring ans = \"No\";\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int px = atop.x;\n\t\t\tconst int py = atop.y;\n\t\t\tconst int pn = atop.n;\n\t\t\tconst int pw = atop.w;\n\t\t\tif (px == gx&&py == gy) {\n\t\t\t\tans = \"Yes\"; break;\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nx = px + dx[pw];\n\t\t\t\tconst int ny = py + dy[pw];\n\t\t\t\tif (!field[ny][nx]) {\n\t\t\t\t\tif (memo[ny][nx][pw] > pn) {\n\t\t\t\t\t\tmemo[ny][nx][pw] = pn;\n\t\t\t\t\t\tque.push(aa{ nx,ny,pn,pw });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pn != N) {\n\t\t\t\tfor (int i = 0; i<4; ++i) {\n\t\t\t\t\tif (next[pn][i]<1e8) {\n\t\t\t\t\t\tif (memo[py][px][i] >next[pn][i]) {\n\t\t\t\t\t\t\tmemo[py][px][i] = next[pn][i];\n\t\t\t\t\t\t\tque.push(aa{ px,py,next[pn][i],i });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\n//int dfs(int cang,int oang,int pos){\n//\tif(cang==oang)return pos;\n//\telse if(pos==n)return INF;\n//\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n//\tint nang;\n//\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n//\telse nang=(cang+1)%4;\n//\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n//}\n\nbool bfs(){\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t// cang==oagn\n\tfor(int i=0;i<4;i++)for(int j=0;j<n;j++)toAng[i][i][j]=i;\n\t// cang!=oang&&pos==n\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n\tfor(int k=n-1;k>=0;k--){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tint nang;\n\t\t\t\tint cang=i;\n\t\t\t\tint oang=j;\n\t\t\t\tint pos=k;\n\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\t\t\t\telse nang=(cang+1)%4;\n\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n\t\t\t}\n\t\t}\n\t}\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii> > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(0,0),pii(sy,sx)));\n\td[sy][sx][0]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.second.second;\n\t\tint cy=p.second.first;\n\t\tint cang=p.first.second;\n\t\tint cpos=p.first.first;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cy][cx][cang]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=toAng[cang][nang][cpos];\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[ny][nx][nang]>npos){\n\t\t\t\td[ny][nx][nang]=npos;\n\t\t\t\tpq.push(make_pair(pii(npos,nang),pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[gy][gx][i]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\ntypedef pair<int,P2> P3;\nconst int MAX=1000000007;\n\nint dy[4]={-1,0,1,0},dx[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {\n  if(x<0 || x>=n) return false;\n  if(y<0 || y>=m) return false;\n  return true;\n}\nint d[1001][1001][4];\npriority_queue<P3,vector<P3>,greater<P3> > que;\n\nint main() {\n  int n,m,k;\n  while(cin >> n >> m >> k && (n||m||k)) {\n    while(!que.empty()) que.pop();\n\n    string c;\n    string s[n];\n    cin >> c;\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tfor(int l=0; l<4; l++) d[i][j][l]=MAX;\n      }\n    }\n\n    int sx,sy,tx,ty;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tif(s[i][j]=='S') {\n\t  sx=i;sy=j;\n\t}\n\tif(s[i][j]=='G') {\n\t  tx=i;ty=j;\n\t}\n      }\n    }\n\n    que.push(P3(0,P2(1,P(sx,sy))));\n    d[sx][sy][1]=0;\n    bool ck=false;\n    while(!que.empty()) {\n      P3 p=que.top();que.pop();\n      int j=p.F,z=p.S.F,nx=p.S.S.F,ny=p.S.S.S;\n      if(nx==tx && ny==ty) {\n\tck=true;\n\tbreak;\n      }\n\n      if(d[nx][ny][z]<j) continue;\n\n      int x=nx+dx[z],y=ny+dy[z];\n      if(check(n,m,x,y) && s[x][y]!='#' && d[x][y][z]>j) {\n\td[x][y][z]=j;\n\tque.push(P3(j,P2(z,P(x,y))));\n      }\n\n      if(j<k) {\n\tx=nx;y=ny;\n\tint z2=z;\n\tif(c[j]=='L') z2--;\n\telse z2++;\n\tif(z2<0) z2+=4;\n\telse if(z2>=4) z2-=4;\n\n\tif(d[x][y][z2]>j+1) {\n\t  d[x][y][z2]=j+1;\n\t  que.push(P3(j+1,P2(z2,P(x,y))));\n\t}\n      }\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000\n#define MAX_N 1000000\n#define INF 1e9\n\nstruct State{\n  int d,x,y,dir;\n  State(int d,int x,int y,int dir) : d(d),x(x),y(y),dir(dir) {}\n  bool operator < (const State &s)const{\n    return d > s.d;\n  }\n};\n\nint H,W,N,sx,sy,gx,gy;\nint d[MAX][MAX][4];\nchar commands[MAX_N];\nchar field[MAX][MAX];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint dijkstra(){\n  fill(d[0][0],d[0][0]+MAX*MAX*4,INF);\n  priority_queue<State> Q;\n  Q.push(State(0,sx,sy,1));\n  d[sy][sx][1] = 0;\n  \n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int x = s.x, y = s.y, dir = s.dir;\n    if(x == gx && y == gy) return s.d;\n    \n    int nx = x + dx[dir], ny = y + dy[dir];\n    if(inField(nx,ny) && field[ny][nx] != '#' && d[y][x][dir] < d[ny][nx][dir]){\n      d[ny][nx][dir] = d[y][x][dir];\n      Q.push(State(d[ny][nx][dir],nx,ny,dir));\n    }\n    \n    if(s.d < N){\n      if(commands[s.d] == 'L'){\n        int ndir = (dir+3)%4;\n        if(d[y][x][dir]+1 < d[y][x][ndir]){\n          d[y][x][ndir] = d[y][x][dir]+1;\n          Q.push(State(d[y][x][ndir],x,y,ndir));\n        }\n      }else{\n        int ndir = (dir+1)%4;\n        if(d[y][x][dir]+1 < d[y][x][ndir]){\n          d[y][x][ndir] = d[y][x][dir]+1;\n          Q.push(State(d[y][x][ndir],x,y,ndir));\n        }\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  while(cin >> H >> W >> N, H){\n    cin >> commands;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == 'S'){\n          field[i][j] = '.';\n          sx = j; sy = i;\n        }else if(field[i][j] == 'G'){\n          field[i][j] = '.';\n          gx = j; gy = i;\n        }\n      }\n    }\n    cout << (dijkstra() != INF ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef pair<int, P>IP;\nint H, W, N;\nchar com[1000010];\nchar dir[1000010];\nchar mp[1010][1010];\nint sx, sy, gx, gy;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nint nxtT[4][1000010];\nint flg[1010][1010];\nint main(){\n\n    while(cin>>H>>W>>N, H){\n        for(int y=0;y<1010;y++){\n            for(int x=0;x<1010;x++){\n                mp[y][x] = '#';\n                flg[y][x] = 1234567;\n            }\n        }\n        for(int i=0;i<N;i++)cin>>com[i];\n        for(int y=1;y<=H;y++){\n            for(int x=1;x<=W;x++){\n                cin>>mp[y][x];\n                if(mp[y][x]=='S'){\n                    sx = x;\n                    sy = y;\n                }\n                if(mp[y][x]=='G'){\n                    gx = x;\n                    gy = y;\n                }\n            }\n        }\n        dir[0]=0;\n        for(int i=0;i<N;i++){\n            dir[i+1] = (4 + dir[i] + (com[i]=='R'?1:-1))%4;\n        }\n        for(int i=0;i<4;i++){\n            nxtT[i][N+1] = 1234567;\n            for(int j = N; j >= 0; j--){\n                if(dir[j]==i)nxtT[i][j] = j;\n                else nxtT[i][j] = nxtT[i][j+1];\n            }\n        }\n        priority_queue<IP, vector<IP>, greater<IP> > Q;\n        Q.push(IP(0, P(sx, sy)));\n        while(!Q.empty()){\n            int t = Q.top().first;\n            int x = Q.top().second.first;\n            int y = Q.top().second.second;\n            Q.pop();\n            if(t>N)break;\n            if(flg[y][x] < 1234567)continue;\n            flg[y][x] = t;\n            for(int i=0;i<4;i++){\n                if(mp[y+dy[i]][x+dx[i]]=='#')continue;\n                if(flg[y+dy[i]][x+dx[i]]<1234567)continue;\n                Q.push(IP(nxtT[i][t], P(x+dx[i], y+dy[i])));\n            }\n        }\n        if(flg[gy][gx]<1234567)cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct State {\n    int x, y, dir, n;\n    State(int x, int y, int dir, int n)\n        : x{x}, y{y}, dir{dir}, n{n} {}\n};\n\nint H, W;\nstring commands;\nvector<vector<char>> field;\nvector<int> dir[4];\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nbool in_field(int x, int y)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid init()\n{\n    for (int i = 0; i < 4; i++) {\n        dir[i].clear();\n    }\n}\n\nvoid make(int N)\n{\n    init();\n    int nd = 1;\n    for (int i = 0; i < N; i++) {\n        if (commands[i] == 'L') {\n            nd = (nd + 3) % 4;\n        } else {\n            nd = (nd + 1) % 4;\n        }\n        dir[nd].emplace_back(i);\n    }    \n}\n\nbool solve(int sx, int sy, int gx, int gy)\n{\n    queue<State> Q;\n    Q.push({sx, sy, 1, 0});\n    \n    vector<vector<vector<bool>>> d(H, vector<vector<bool>>(W, vector<bool>(4, 0)));\n    d[sy][sx][1] = 1;\n\n    while (!Q.empty()) {\n        State s = Q.front(); Q.pop();\n        int x = s.x, y = s.y;\n        if (x == gx && y == gy) return 1;\n        \n        // move forward\n        int nx = s.x + dx[s.dir], ny = s.y + dy[s.dir];\n        if (in_field(nx, ny) && field[ny][nx] != '#' && !d[ny][nx][s.dir]) {\n            d[ny][nx][s.dir] = 1;\n            Q.push({nx, ny, s.dir, s.n});\n        }\n        \n        // turn\n        for (int i = 0; i < 4; i++) {\n            if (i == s.dir) continue;\n            \n            auto np = lower_bound(dir[i].begin(), dir[i].end(), s.n);\n            if (np == dir[i].end()) continue;\n            int nn = np - dir[i].begin();\n            if (!d[y][x][i]) {\n                d[y][x][i] = 1;\n                Q.push({x, y, i, nn + 1});                \n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{\n    int N, sx, sy, gx, gy;\n    while (cin >> H >> W >> N, H) {\n        cin >> commands;\n        field.resize(H);\n        for (int i = 0; i < H; i++) {\n            field[i].resize(W);\n            for (int j = 0; j < W; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == 'S') { \n                    field[i][j] = '.';\n                    sx = j; sy = i;\n                } else if (field[i][j] == 'G') {\n                    field[i][j] = '.';\n                    gx = j; gy = i;\n                }\n            }\n        }\n        make(N);\n        cout << (solve(sx, sy, gx, gy) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nvector<vector<vi>> dist;\nvector<vector<vi>> todir;\nvs fld;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tdist.clear(), todir.clear();\n\t\tdist.resize(h, vector<vi>(w, vi(4, INF)));\n\t\ttodir.resize(n + 1, vector<vi>(4, vi(4, INF)));\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tpriority_queue<tuple<int, int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(0, i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint p, x, y, dir;\n\t\t\ttie(p, x, y, dir) = que.top();\n\t\t\tque.pop();\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] == INF)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(p, nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = todir[p][dir][i];\n\t\t\t\tif (tmp < INF && dist[x][y][i] == INF)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp, x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sst stringstream\n#define sz size()\n#define vc vector\ntypedef vc<int> vi;\ntypedef vc<ll> vl;\ntypedef vc<string> vs;\n\nint H,W,N;\nchar s[1000010],c[1010][1010];\nint sy,sx,gy,gx;\nint dir[1000010],cost[1000010][4],dist[1010][1010];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\ntypedef pair<int,pi> T;\n\nint main(){\n\twhile(cin>>H>>W>>N && H){\n\t\trep(i,N)cin>>s[i];\n\t\trep(i,H+2)rep(j,W+2)c[i][j]='#';\n\t\trep2(i,1,H+1)rep2(j,1,W+1){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]=='S')sy=i,sx=j,c[i][j]='.';\n\t\t\tif(c[i][j]=='G')gy=i,gx=j,c[i][j]='.';\n\t\t}\n\t\t\n\t\tdir[0]=3;\n\t\trep(i,N){\n\t\t\tif(s[i]=='L')dir[i+1]=(dir[i]+3)%4;\n\t\t\telse dir[i+1]=(dir[i]+1)%4;\n\t\t}\n\t\tfor(int i=N;i>=0;i--){\n\t\t\trep(j,4){\n\t\t\t\tif(j==dir[i])cost[i][j]=0;\n\t\t\t\telse{\n\t\t\t\t\tif(i==N)cost[i][j]=INF;\n\t\t\t\t\telse cost[i][j]=cost[i+1][j]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,H+2)rep(j,W+2)dist[i][j]=INF;\n\t\tdist[sy][sx]=0;\n\t\tpriority_queue<T,vector<T>,greater<T> > Q;\n\t\tQ.push(T(0,pi(sy,sx)));\n\t\twhile(Q.sz){\n\t\t\tT is=Q.top();\n\t\t\tQ.pop();\n\t\t\tint dis=is.fir;\n\t\t\tpi st=is.sec;\n\t\t\tif(dist[st.fir][st.sec] < dis)continue;\n\t\t\tif(st.sec==gy && st.sec==gx){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,4){\n\t\t\t\tint ny=st.fir+dy[i],nx=st.sec+dx[i];\n\t\t\t\tif(c[ny][nx]=='#')continue;\n\t\t\t\tif(dis + cost[dis][i] < dist[ny][nx]){\n\t\t\t\t\tdist[ny][nx] = dis + cost[dis][i];\n\t\t\t\t\tQ.push(T(dist[ny][nx],pi(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\n//int dfs(int cang,int oang,int pos){\n//\tif(cang==oang)return pos;\n//\telse if(pos==n)return INF;\n//\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n//\tint nang;\n//\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n//\telse nang=(cang+1)%4;\n//\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n//}\n\nbool bfs(){\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t//memset(toAng,-1,sizeof(toAng));\n\t// cang==oagn\n\tfor(int i=0;i<4;i++)for(int j=0;j<n;j++)toAng[i][i][j]=i;\n\t// cang!=oang&&pos==n\n\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tfor(int k=n-1;k>=0;k--){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tint nang;\n\t\t\t\tint cang=i;\n\t\t\t\tint oang=j;\n\t\t\t\tint pos=k;\n\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\t\t\t\telse nang=(cang+1)%4;\n\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n\t\t\t}\n\t\t}\n\t}\n\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii> > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(sy,sx),pii(0,0)));\n\td[sy][sx][0]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.first.second;\n\t\tint cy=p.first.first;\n\t\tint cang=p.second.first;\n\t\tint cpos=p.second.second;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cy][cx][cang]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=toAng[cang][nang][cpos];\n\t\t\tint cnt=npos-cpos;\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[ny][nx][nang]>npos){\n\t\t\t\td[ny][nx][nang]=npos;\n\t\t\t\tpq.push(make_pair(pii(ny,nx),pii(nang,npos)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[gy][gx][i]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint H,W,N;\nstring s,m[1000];\nint dis[4][1000][1000];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint nxt[4][1<<20];\nmain()\n{\n\twhile(cin>>H>>W>>N,H)\n\t{\n\t\tcin>>s;\n\t\tint sx,sy;\n\t\tfor(int i=0;i<H;i++)\n\t\t{\n\t\t\tcin>>m[i];\n\t\t\tfor(int j=0;j<W;j++)for(int r=0;r<4;r++)dis[r][i][j]=2*N;\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tsx=i;\n\t\t\t\t\tsy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nowr=0;\n\t\tfor(int i=0;i<N;i++)nowr+=s[i]=='L'?1:-1;\n\t\tnowr=(nowr%4+4)%4;\n\t\tint nowd[4];\n\t\tfor(int r=0;r<4;r++)nowd[r]=nxt[r][N]=r==nowr?N:2*N;\n\t\tfor(int i=N;i--;)\n\t\t{\n\t\t\tnowr-=s[i]=='L'?1:-1;\n\t\t\tnowr=(nowr%4+4)%4;\n\t\t\tnowd[nowr]=i;\n\t\t\tfor(int r=0;r<4;r++)nxt[r][i]=nowd[r];\n\t\t}\n\t\tdis[0][sx][sy]=0;\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int> > >P;\n\t\tP.push({{0,0},{sx,sy}});\n\t\tbool flag=false;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint d=-P.top().first.first;\n\t\t\tint nr=P.top().first.second;\n\t\t\tint x=P.top().second.first;\n\t\t\tint y=P.top().second.second;\n\t\t\tP.pop();\n\t\t\tif(dis[nr][x][y]<d)continue;\n\t\t\tif(m[x][y]=='G')\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[r],ty=y+dy[r];\n\t\t\t\tif(tx<0||ty<0||tx>=H||ty>=W||m[tx][ty]=='#'||dis[r][tx][ty]<=nxt[r][d])continue;\n\t\t\t\tdis[r][tx][ty]=nxt[r][d];\n\t\t\t\tP.push({{-nxt[r][d],r},{tx,ty}});\n\t\t\t}\n\t\t}\n\t\tcout<<(flag?\"Yes\":\"No\")<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {0, 1, 0, -1};\nconstexpr int dy[] = {-1, 0, 1, 0};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint turn[128];\n\tturn['L'] = -1;\n\tturn['R'] = 1;\n\n\tfor(int h, w, n; cin >> h >> w >> n && h;) {\n\t\tstring command;\n\t\tcin >> command;\n\n\t\tvector<int> dir(n + 1, 0);\n\t\tarray<vector<int>, 4> get_d;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tget_d[dir[i]].emplace_back(i);\n\t\t\tdir[i + 1] = (dir[i] + turn[command[i]] + 4) % 4;\n\t\t}\n\n\t\tget_d[dir.back()].emplace_back(n);\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\ttypedef tuple<int, int, int> P;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tvector<vector<int>> dist(h, vector<int>(w, n + 1));\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'S') {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tque.push(make_tuple(0, j, i));\n\t\t\t\t\tgoto unloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tunloop:;\n\n\t\twhile(!que.empty()) {\n\t\t\tint di, x, y;\n\t\t\ttie(di, x, y) = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(dist[y][x] < di) continue;\n\n\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || field[ny][nx] == '#') continue;\n\n\t\t\t\tconst auto it = lower_bound(get_d[d].begin(), get_d[d].end(), di);\n\t\t\t\tif(it == get_d[d].end()) continue;\n\n\t\t\t\tif(dist[ny][nx] > *it) {\n\t\t\t\t\tif(field[ny][nx] == 'G') goto ok;\n\t\t\t\t\tdist[ny][nx] = *it;\n\t\t\t\t\tque.push(make_tuple(*it, nx, ny));\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tcout << \"No\" << endl;\n\t\tcontinue;\n\n\tok:;\n\t\tcout << \"Yes\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main(){\n  int H, W, N;\n  while(cin >> H >> W >> N && (H|W|N)){\n    string s;\n    char c[1000][1000];\n    cin >> s;\n    REP(i, H) REP(j, W) cin >> c[i][j];\n    int sx, sy, gx, gy;\n    REP(i, H) REP(j, W) if(c[i][j] == 'S') {\n      sx = j, sy = i;\n      c[i][j] = '.';\n    }\n    REP(i, H) REP(j, W) if(c[i][j] == 'G') {\n      gx = j, gy = i;\n      c[i][j] = '.';\n    }\n\n    vector<int> d(N + 1);\n    REP(i, N){\n      d[i + 1] = (d[i] + (s[i] == 'L' ? -1 : +1) + 4) % 4;\n    }\n    vector<int> indexes[4];\n    REP(i, N + 1) indexes[d[i]].push_back(i);\n    REP(i, 4) indexes[i].push_back(INF);\n\n    bool used[1000][1000] = {};\n    typedef pair<int, int> P;\n    typedef pair<int, P> S;\n    priority_queue<S, vector<S>, greater<S> > que;\n    que.push(S(0, P(sx, sy)));\n\n    bool ans = false;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      int x = s.second.first, y = s.second.second;\n      int k = s.first;\n      if(x == gx && y == gy){\n        ans = true;\n        break;\n      }\n      if(used[y][x]) continue;\n      used[y][x] = true;\n      REP(r, 4){\n        int nk = *lower_bound(indexes[r].begin(), indexes[r].end(), k);\n        if(nk == INF) continue;\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(!valid(nx, ny, W, H)) continue;\n        if(used[ny][nx]) continue;\n        que.push(S(nk, P(nx, ny)));\n      }\n    }\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\nint dfs(int cang,int oang,int pos){\n\tif(cang==oang)return pos;\n\telse if(pos==n)return INF;\n\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n\tint nang;\n\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\telse nang=(cang+1)%4;\n\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n}\n\nbool bfs(){\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\tmemset(toAng,-1,sizeof(toAng));\n\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii> > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(sy,sx),pii(0,0)));\n\td[sy][sx][0]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.first.second;\n\t\tint cy=p.first.first;\n\t\tint cang=p.second.first;\n\t\tint cpos=p.second.second;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cy][cx][cang]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\tint npos=dfs(cang,nang,cpos);\n\t\t\tint cnt=npos-cpos;\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[ny][nx][nang]>npos){\n\t\t\t\td[ny][nx][nang]=npos;\n\t\t\t\tpq.push(make_pair(pii(ny,nx),pii(nang,npos)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[gy][gx][i]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1000000\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_turn_count,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tturn_count = arg_turn_count;\n\t\tdir = arg_dir;\n\t}\n\tbool operator<(const struct Info &arg) const{ //向き変更回数の昇順(PQ)\n\t\treturn turn_count > arg.turn_count;\n\t}\n\tint row,col,turn_count;\n\tDIR dir;\n};\n\nint H,W,N;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint min_cost[1000][1000][4],next_count[NUM+1][4];\nchar buf[NUM+1],base_map[1000][1001];\nDIR dir_array[4] = {North,West,East,South};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tnext_count[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tDIR dir = North;\n\tnext_count[0][North] = 0;\n\n\tscanf(\"%s\",buf);\n\tfor(int i = 0; i < N; i++){\n\t\tswitch(dir){\n\t\tcase North:\n\t\t\tif(buf[i] == 'L'){\n\t\t\t\tdir = West;\n\t\t\t}else{\n\t\t\t\tdir = East;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase East:\n\t\t\tif(buf[i] == 'L'){\n\t\t\t\tdir = North;\n\t\t\t}else{\n\t\t\t\tdir = South;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase South:\n\t\t\tif(buf[i] == 'L'){\n\t\t\t\tdir = East;\n\t\t\t}else{\n\t\t\t\tdir = West;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase West:\n\t\t\tif(buf[i] == 'L'){\n\t\t\t\tdir = South;\n\t\t\t}else{\n\t\t\t\tdir = North;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnext_count[i+1][dir] = i+1; //次にdirの方向になるのはi+1回目\n\t}\n\n\t//情報を右→左に伝える\n\tfor(int i = N-1; i >= 0; i--){\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tnext_count[i][k] = min(next_count[i][k],next_count[i+1][k]);\n\t\t}\n\t}\n\n\tint start_row,start_col,goal_row,goal_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] == 'S'){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}else if(base_map[row][col] == 'G'){\n\t\t\t\tgoal_row = row;\n\t\t\t\tgoal_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i < 4; i++)min_cost[row][col][i] = BIG_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tmin_cost[start_row][start_col][North] = 0;\n\tQ.push(Info(start_row,start_col,0,North));\n\n\tint adj_row,adj_col,next_turn_count;\n\tDIR next_dir;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().row == goal_row && Q.top().col == goal_col){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\treturn;\n\t\t}else if(Q.top().turn_count > min_cost[Q.top().row][Q.top().col][Q.top().dir]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] == '#')continue;\n\n\t\t\t\tnext_dir = dir_array[i];\n\n\t\t\t\tif(next_dir == Q.top().dir){ //回転不要\n\t\t\t\t\tnext_turn_count = Q.top().turn_count;\n\t\t\t\t}else{\n\t\t\t\t\tif(Q.top().turn_count >= N)continue; //これ以上回転できない場合\n\n\t\t\t\t\tnext_turn_count = next_count[Q.top().turn_count][next_dir];\n\n\t\t\t\t\tif(next_turn_count == BIG_NUM)continue; //今後、next_dirの向きに回転できない場合\n\t\t\t\t}\n\n\t\t\t\tif(min_cost[adj_row][adj_col][next_dir] > next_turn_count){\n\t\t\t\t\tmin_cost[adj_row][adj_col][next_dir] = next_turn_count;\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,next_turn_count,next_dir));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&N);\n\t\tif(H == 0 && W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dist[1111][1111][4];\nint todir[1111111][4][4];\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tREP(i, 1111)REP(j, 1111)REP(k, 4) dist[i][j][k] = INF;\n\t\tREP(i, 1111111)REP(j, 4)REP(k, 4) todir[i][j][k] = INF;\n\t\tvs fld;\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (dist[x][y][i] > tmp)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\nconst ll mod = 1000000007;\ntypedef pair<int, int> P;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\ntypedef pair<int, P> speP;\n\nint h, w, n;\nbool valid(int x, int y) {\n\tif (x < 0 || y < 0 || x >= h || y >= w)return false;\n\treturn true;\n}\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tvector<int> ra(n + 1,0);\n\trep(i, n) {\n\t\tint nex = 0;\n\t\tif (s[i] == 'L') {\n\t\t\tnex = ra[i] - 1;\n\t\t}\n\t\telse {\n\t\t\tnex = ra[i] + 1;\n\t\t}\n\t\tif (nex == 4)nex = 0;\n\t\telse if (nex < 0)nex = 3;\n\t\tra[i + 1] = nex;\n\t}\n\tvector<int> loc[4];\n\trep(i, n+1) {\n\t\tloc[ra[i]].push_back(i);\n\t}\n\trep(i, 4)loc[i].push_back(mod);\n\tvector<vector<int>> v(n+1);\n\trep(i, n+1) {\n\t\tv[i].resize(4);\n\t\trep(j, 4) {\n\t\t\tint id = lower_bound(loc[j].begin(), loc[j].end(), i) - loc[j].begin();\n\t\t\tv[i][j] = loc[j][id];\n\t\t}\n\t}\n\tvector<vector<char>> mp(h);\n\tint sx, sy, gx, gy;\n\trep(i, h) {\n\t\tmp[i].resize(w);\n\t\trep(j, w) {\n\t\t\tcin >> mp[i][j];\n\t\t\tif (mp[i][j] == 'S') {\n\t\t\t\tsx = i, sy = j;\n\t\t\t}\n\t\t\telse if(mp[i][j]=='G'){\n\t\t\t\tgx = i, gy = j;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> dist(h);\n\trep(i, h) {\n\t\tdist[i].resize(w, mod);\n\t}\n\tdist[sx][sy] = 0;\n\tpriority_queue<speP, vector<speP>, greater<speP>> q;\n\tq.push({ 0,{sx,sy} });\n\twhile (!q.empty()) {\n\t\tspeP p = q.top(); q.pop();\n\t\tint x = p.second.first, y = p.second.second;\n\t\tint t = p.first;\n\t\tif (dist[x][y] < t)continue;\n\t\trep(j, 4) {\n\t\t\tint nd = v[t][j];\n\t\t\tint cx = x, cy = y;\n\t\t\twhile (true) {\n\t\t\t\tcx += dx[j], cy += dy[j];\n\t\t\t\tif (!valid(cx, cy))break;\n\t\t\t\tif (mp[cx][cy] == '#')break;\n\t\t\t\tif (nd < dist[cx][cy]) {\n\t\t\t\t\tdist[cx][cy] = nd;\n\t\t\t\t\tq.push({ nd,{cx,cy} });\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\tif (dist[gx][gy] == mod) {\n\t\tcout << \"No\" << endl;\n\t}\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t}\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> h >> w >> n, h | w | n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct state {\n    int y, x, dir;\n    state(int y, int x, int dir) : y(y), x(x), dir(dir) {}\n};\n\nint main() {\n    // south, east, north, west \n    constexpr int dx[4] = {0, 1, 0, -1};\n    constexpr int dy[4] = {1, 0, -1, 0};\n    constexpr int inf = 1e9;\n\n    int H, W, N;\n    while(cin >> H >> W >> N, H) {\n        string s;\n        cin >> s;\n        vector<string> fld(H);\n        int sy, sx, gy, gx;\n        for(int i = 0; i < H; ++i) {\n            cin >> fld[i];\n            for(int j = 0; j < W; ++j) {\n                if(fld[i][j] == 'S') {\n                    sy = i;\n                    sx = j;\n                }\n                if(fld[i][j] == 'G') {\n                    gy = i;\n                    gx = j;\n                }\n            }\n        }\n\n        vector<vector<int>> next_idx(N + 1, vector<int>(4, inf));\n        {\n            int cur_dir = 2;\n            for(int i = 0; i < N; ++i) {\n                (cur_dir += (s[i] == 'L' ? 1 : 3)) %= 4;\n            }\n            for(int i = N - 1; i >= 0; --i) {\n                next_idx[i] = next_idx[i + 1];\n                next_idx[i][cur_dir] = i;\n                (cur_dir += s[i] == 'L' ? 3 : 1) %= 4;\n            }\n        }\n\n        vector<vector<vector<int>>> dist(H, vector<vector<int>>(W, vector<int>(4, inf)));\n        queue<state> que;\n        que.emplace(sy, sx, 2);\n        dist[sy][sx][2] = 0;\n        while(!que.empty()) {\n            auto now = que.front();\n            que.pop();\n\n            // turn\n            const int now_op_idx = dist[now.y][now.x][now.dir];\n            for(int ndir = 0; ndir < 4; ++ndir) {\n                const int next_op_idx = next_idx[now_op_idx][ndir] + 1;\n                if(dist[now.y][now.x][ndir] > next_op_idx) {\n                    dist[now.y][now.x][ndir] = next_op_idx;\n                    que.emplace(now.y, now.x, ndir);\n                }\n            }\n\n            // forward\n            const int ny = now.y + dy[now.dir];\n            const int nx = now.x + dx[now.dir];\n            if(ny < 0 || H <= ny || nx < 0 || W <= nx) continue;\n            if(fld[ny][nx] == '#') continue;\n            if(dist[ny][nx][now.dir] > dist[now.y][now.x][now.dir]) {\n                dist[ny][nx][now.dir] = dist[now.y][now.x][now.dir];\n                que.emplace(ny, nx, now.dir);\n            }\n        }\n\n        if(*min_element(begin(dist[gy][gx]), end(dist[gy][gx])) != inf) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nchar ba[1000][1000];\nint dirdis[1000001][4];\nint dirtable[1000001];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nbool visited[1000][1000][4];\n\nstruct P {\n  int y,x,d;\n  int i;\n};\n\nconst bool operator<(const P &a, const P &b) {\n  return a.i > b.i;\n}\n\nint main() {\n  int h,w,n;\n  while(cin>>h>>w>>n,h||w||n) {\n    string s;\n    cin >> s;\n    int sx,sy,gx,gy;\n    int sd = 0;\n    REP(i, h) {\n      REP(j, w) {\n        cin >> ba[i][j];\n        if (ba[i][j] == 'S') {\n          sy = i;\n          sx = j;\n        } else if (ba[i][j] == 'G') {\n          gy = i;\n          gx = j;\n        }\n      }\n    }\n    REP(i, n) {\n      if (s[i] == 'L')\n        dirtable[i+1] = (dirtable[i] + 3) % 4;\n      else\n        dirtable[i+1] = (dirtable[i] + 1) % 4;\n    }\n    int last[4];\n    memset(last, -1, sizeof(last));\n    for (int i=n; i>=0; --i) {\n      REP(j, 4) {\n        if (last[j] >= 0)\n          dirdis[i][j] = last[j] - i;\n        else\n          dirdis[i][j] = -1;\n      }\n      last[dirtable[i]] = i;\n    }\n    priority_queue<P> Q;\n    Q.push((P){sy,sx,sd,0});\n    memset(visited,0,sizeof(visited));\n    bool f = 0;\n    while(!Q.empty()) {\n      P now = Q.top(); Q.pop();\n      int y=now.y, x=now.x, d=now.d;\n      if (visited[y][x][d]) continue;\n      visited[y][x][d] = 1;\n\n      //printf(\"(%d,%d):%d:%d\\n\",x,y,d,now.i);\n      \n      if (y==gy&&x==gx) {\n        f = 1;\n        break;\n      }\n      \n      REP(k,4) {\n        if (d==k) continue;\n        if (dirdis[now.i][k] !=-1) {\n          Q.push((P){y,x,k,now.i+dirdis[now.i][k]});\n        }\n      }\n      int yy = y+dy[d];\n      int xx = x+dx[d];\n      if (yy<0||yy>=h||xx<0||xx>=w||ba[yy][xx]=='#') continue;\n      Q.push((P){yy,xx,d,now.i});\n    }\n    if (f)\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1000001\n#define M 1001\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,P> PP;\nint h,w,n;\nstring mp[M],str;\n\nint D[4][M][M];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint getCost(int x,int dir,int ndir){\n  while(x<n&&dir!=ndir){\n    if(str[x] == 'L') dir = (dir+3)%4;\n    else dir = (dir+1)%4;\n    x++;\n  }\n  if(dir!=ndir) return -1;\n  return x;\n}\n\nbool dijkstra(int sy,int sx){\n  for(int i=0;i<4;i++)\n    for(int j=0;j<h;j++)\n      for(int k=0;k<w;k++) D[i][j][k] = 1e9;\n  \n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sy,sx)));\n  D[0][sy][sx] = 0;\n\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int dir = t.first.second;\n    int y = t.second.first;\n    int x = t.second.second;\n    \n    if(mp[y][x] =='G') return 1;    \n    if(D[dir][y][x]<cost) continue;\n\n    \n    for(int i=0;i<4;i++){\n      int ncost = getCost(cost,dir,i);\n      if(ncost == -1 || D[i][y][x]<=ncost)continue;\n      Q.push(PP(P(ncost,i),P(y,x)));\n      D[i][y][x] = ncost;\n    }\n\n    int ny = y+dy[dir]; \n    int nx = x+dx[dir];\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#'||D[dir][ny][nx]<=cost)continue;\n    D[dir][ny][nx] = cost;\n    Q.push(PP(P(cost,dir),P(ny,nx)));\n    \n  }  \n  \n  return 0;\n}\n\nint main(){\n\n  while(1){\n  cin>>h>>w>>n;\n  if(!h&&!w&&!n)break;\n  cin>>str;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == 'S') cout<<(dijkstra(i,j)?\"Yes\":\"No\")<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\ntypedef pair<int,P2> P3;\nconst int MAX=1000000007;\n\nint dy[4]={-1,0,1,0},dx[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {\n  if(x<0 || x>=n) return false;\n  if(y<0 || y>=m) return false;\n  return true;\n}\n\nint main() {\n  int n,m,k;\n  while(cin >> n >> m >> k && (n||m||k)) {\n    string c;\n    string s[n];\n    cin >> c;\n    for(int i=0; i<n; i++) cin >> s[i];\n    int d[n][m][4];\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tfor(int l=0; l<4; l++) d[i][j][l]=MAX;\n      }\n    }\n\n    int sx,sy,tx,ty;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n\tif(s[i][j]=='S') {\n\t  sx=i;sy=j;\n\t}\n\tif(s[i][j]=='G') {\n\t  tx=i;ty=j;\n\t}\n      }\n    }\n\n    priority_queue<P3,vector<P3>,greater<P3> > que;\n    que.push(P3(0,P2(1,P(sx,sy))));\n    d[sx][sy][1]=0;\n    bool ck=false;\n    while(!que.empty()) {\n      P3 p=que.top();que.pop();\n      int j=p.F,z=p.S.F,nx=p.S.S.F,ny=p.S.S.S;\n      if(nx==tx && ny==ty) {\n\tck=true;\n\tbreak;\n      }\n      int x=nx+dx[z],y=ny+dy[z];\n      if(check(n,m,x,y) && s[x][y]!='#' && d[x][y][z]>j) {\n\td[x][y][z]=j;\n\tque.push(P3(j,P2(z,P(x,y))));\n      }\n\n      if(j<k) {\n\tx=nx;y=ny;\n\tint z2=z;\n\tif(c[j]=='L') z2--;\n\telse z2++;\n\tif(z2<0) z2+=4;\n\telse if(z2>=4) z2-=4;\n\n\tif(d[x][y][z2]>j+1) {\n\t  d[x][y][z2]=j+1;\n\t  que.push(P3(j+1,P2(z2,P(x,y))));\n\t}\n      }\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w, n;\nint prev[1000][1000][4];\nstring s, in[1000];\n\nint main(){\n\twhile(cin >> h >> w >> n, h){\n\t\tcin >> s;\n\t\tstring t = \".\";\n\t\tint y, x;\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') y = i, x = j;\n\t\t\t\trep(k, 4) prev[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<pi, pi> > q;\n\t\tq.push(mp(mp(0, 0), mp(y * w + x, 0)));\n\t\twhile(!q.empty()){\n\t\t\ty = q.top().second.first / w, x = q.top().second.first % w;\n\t\t\tint c = q.top().first.first, d = q.top().second.second;\n\t\t\tint pv = q.top().first.second; q.pop();\n\t\t\t\n\t\t\tif(prev[y][x][d] >= 0) continue;\n\t\t\tprev[y][x][d] = pv;\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tt = \"\";\n\t\t\t\twhile(c < 0){\n\t\t\t\t\tc++;\n\t\t\t\t\tint p = prev[y][x][d];\n\t\t\t\t\tif(p == 2){\n\t\t\t\t\t\ty -= dy[d]; x -= dx[d];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tt += p ? \"L\" : \"R\";\n\t\t\t\t\td = (d + (p ? 3 : 1)) % 4;\n\t\t\t\t}\n\t\t\t\treverse(all(t));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(0 <= ny && ny < h && 0 <= nx && nx < w &&\n\t\t\tin[ny][nx] != '#' && prev[ny][nx][d] < 0){\n\t\t\t\tq.push(mp(mp(c - 1, 2), mp(ny * w + nx, d)));\n\t\t\t}\n\t\t\trep(t, 2){\n\t\t\t\tint nd = (d + (t ? 1 : 3)) % 4;\n\t\t\t\tif(prev[y][x][nd] >= 0) continue;\n\t\t\t\tq.push(mp(mp(c - 1, t), mp(y * w + x, nd)));\n\t\t\t}\n\t\t}\n\t\tif(t == \".\"){\n\t\t\tcout << \"No\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint i = 0, j = 0, a = 0, b = 0;\n\t\tfor(; i < t.size(); i++){\n\t\t\ta += t[i] == 'L' ? 1 : 3;\n\t\t\ta %= 4;\n\t\t\twhile(j < n && a != b){\n\t\t\t\tb += s[j++] == 'L' ? 1 : 3;\n\t\t\t\tb %= 4;\n\t\t\t}\n\t\t\tif(a != b) break;\n\t\t}\n\t\tcout << (i == t.size() ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ninline bool inrange(int x, int y, int W, int H) {\n  return 0<=x&&x<W&&0<=y&&y<H;\n}\n\nstruct state {\n  int x, y, dir, rpos;\n};\n\nint main() {\n  \n  int H, W, N;\n  while(cin >> H >> W >> N && (H|W|N)) {\n    string rlist; cin >> rlist;\n    vector<vector<char> > M(H, vector<char>(W));\n    int sx, sy;\n    rep(i, H) rep(j, W) {\n      cin >> M[i][j];\n      if(M[i][j] == 'S') sx = j, sy = i;\n    }\n    \n    \n    bool vis[H][W][4][N+1];\n    memset(vis, 0, sizeof vis);\n    \n    bool ok = 0;\n    queue<state> q;\n    q.push((state){sx,sy,1,0});\n    vis[sy][sx][1][0] = 1;\n    int dx[4] = {-1,0,1,0};\n    int dy[4] = {0,-1,0,1};\n    while(!q.empty()) {\n      int x = q.front().x;\n      int y = q.front().y;\n      int dir = q.front().dir;\n      int rpos = q.front().rpos; q.pop();\n      // cout << x << \" \" << y << \" \" << dir << \" rpos: \" << rpos << \" \" << rlist[rpos] << endl;\n      \n      if(M[y][x] == 'G') { ok = 1; break; }\n      int nx = x+dx[dir], ny = y+dy[dir];\n      if(inrange(nx, ny, W, H)) {\n        if(M[ny][nx] == '#') { continue; }\n        if(vis[nx][ny][dir][rpos]) continue;\n        vis[ny][nx][dir][rpos] = 1;\n        q.push((state){nx, ny, dir, rpos});\n      }\n      if(rpos < N) {\n        if(rlist[rpos] == 'L') (dir += 3) %= 4;\n        if(rlist[rpos] == 'R') (dir += 1) %= 4;\n        if(vis[y][x][dir][rpos+1]) continue;\n        vis[y][x][dir][rpos+1] = 1;\n        q.push((state){x, y, dir, rpos+1});\n      }\n    }\n    \n    if(ok) cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nvector<vector<vi>> dist;\nvector<vector<vi>> todir;\nvs fld;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tdist.clear(), todir.clear();\n\t\tdist.resize(h, vector<vi>(w, vi(4, INF)));\n\t\ttodir.resize(n + 1, vector<vi>(4, vi(4, INF)));\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = todir[p][dir][i];\n\t\t\t\tif (tmp < INF && dist[x][y][i] > p)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w, n, next[1000001][4];\nstring s, in[1000];\nbool v[1000][1000][4];\n\n\nint main(){\n\twhile(cin >> h >> w >> n, h){\n\t\tmemset(v, 0, sizeof(v));\n\t\tint y, x, d = 0;\n\t\tcin >> s;\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w) if(in[i][j] == 'S') y = i, x = j;\n\t\t}\n\t\trep(i, n) d = (d + (s[i] == 'L' ? 1 : 3)) % 4;\n\t\trep(i, 4) next[n][i] = n + 1;\n\t\tnext[n][d] = n;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\td = (d + (s[i] == 'L' ? 3 : 1)) % 4;\n\t\t\trep(j, 4) next[i][j] = j == d ? i : next[i + 1][j];\n\t\t}\n\t\t\n\t\tpriority_queue<pair<pi, pi> > q;\n\t\tq.push(mp(mp(0, 0), mp(y, x)));\n\t\twhile(!q.empty()){\n\t\t\ty = q.top().second.first; x = q.top().second.second;\n\t\t\tint co = q.top().first.first, d = q.top().first.second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(v[y][x][d]) continue;\n\t\t\tv[y][x][d] = 1;\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\t\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(0 <= ny && ny < h && 0 <= nx && nx < w){\n\t\t\t\tif(!v[ny][nx][d] && in[ny][nx] != '#') q.push(mp(mp(co, d), mp(ny, nx)));\n\t\t\t}\n\t\t\trep(i, 4) if(!v[y][x][i]){\n\t\t\t\tint nc = next[-co][i];\n\t\t\t\tif(nc <= n) q.push(mp(mp(-nc, i), mp(y, x)));\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct State{\n  int cur,h,w,dir;\n  bool operator < (const State& st) const {\n    return cur > st.cur;\n  }\n};\n\nconst int NORTH = 0;\nconst int SIZE = 1001;\nconst int INF = (1<<25);\nint H,W,N;\nint dh[] = {-1,0,1,0};\nint dw[] = {0,1,0,-1};\nstring command;\nchar field[SIZE][SIZE];\nint sh,sw,gh,gw;\nint T[SIZE][SIZE][4];\n\nbool isInside(int h, int w){return 0<=h&&h<H&&0<=w&&w<W;}\n\nvoid input(){\n  cin >> command;\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){sh=i;sw=j;}\n      if(field[i][j] == 'G'){gh=i;gw=j;}\n    }\n}\n\nbool solve(){\n  fill(T[0][0], T[0][0]+SIZE*SIZE*4, INF);\n  priority_queue<State> Q;\n  Q.push((State){0,sh,sw,NORTH});\n  T[sh][sw][NORTH] = 0;\n\n  while(!Q.empty()){\n    const State now = Q.top(); Q.pop();\n\n    if(now.h == gh && now.w == gw) return true;\n    if(T[now.h][now.w][now.dir] < now.cur) continue;\n   \n    // turn around\n    if(now.cur < (int)command.length()){\n      State nex = now;\n      if(command[now.cur] == 'R') nex.dir = (nex.dir+1)%4;\n      else nex.dir = (nex.dir+3)%4;\n      nex.cur++;\n      if(T[nex.h][nex.w][nex.dir] > nex.cur){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n    }\n    \n    // go forward\n    State nex = now;\n    while(isInside(nex.h,nex.w) && field[nex.h][nex.w] != '#'){\n      if(T[nex.h][nex.w][nex.dir] > nex.cur){\n\tT[nex.h][nex.w][nex.dir] = nex.cur;\n\tQ.push(nex);\n      }\n      nex.h += dh[nex.dir];\n      nex.w += dw[nex.dir];\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H|N|W)){\n    input();\n    cout << (solve()?\"Yes\":\"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\n\nint main()\n{\n\tfor(int h,w,n;cin>>h>>w>>n && h|w|n;){\n\t\tvi ls,rs;\n\t\t{\n\t\t\tstring t; cin>>t;\n\t\t\trep(i,n) (t[i]=='L'?ls:rs).push_back(i);\n\t\t}\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tconst int di[]={0,1,0,-1},dj[]={1,0,-1,0}; // east,south,west,north\n\t\tqueue<tuple<int,int,int,int>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S') q.emplace(i,j,3,0);\n\t\tvvvi vis(4,vvi(h,vi(w)));\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tint i,j,d,p; tie(i,j,d,p)=q.front(); q.pop();\n\t\t\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[d][i][j]) continue;\n\t\t\tdump(vi({i,j,d,p}));\n\t\t\tvis[d][i][j]=1;\n\t\t\tif(grid[i][j]=='G'){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.emplace(i+di[d],j+dj[d],d,p);\n\t\t\tint l=lower_bound(all(ls),p)-begin(ls);\n\t\t\tint r=lower_bound(all(rs),p)-begin(rs);\n\t\t\tif(l<ls.size() && (r+2>=rs.size() || ls[l]<rs[r+2])) q.emplace(i,j,(d+3)%4,ls[l]+1);\n\t\t\tif(r+2<rs.size() && (l>=ls.size() || rs[r+2]<ls[l])) q.emplace(i,j,(d+3)%4,rs[r+2]+1);\n\t\t\tif(r<rs.size() && (l+2>=ls.size() || rs[r]<ls[l+2])) q.emplace(i,j,(d+1)%4,rs[r]+1);\n\t\t\tif(l+2<ls.size() && (r>=rs.size() || ls[l+2]<rs[r])) q.emplace(i,j,(d+1)%4,ls[l+2]+1);\n\t\t}\n\t\tcout<<(res?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[] = {0, 1, 0, -1};\nconstexpr int dy[] = {-1, 0, 1, 0};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint turn[128];\n\tturn['L'] = -1;\n\tturn['R'] = 1;\n\n\tfor(int h, w, n; cin >> h >> w >> n && h;) {\n\t\tstring command;\n\t\tcin >> command;\n\n\t\tint dir = 0;\n\t\tarray<vector<int>, 4> get_d{{{0}, {}, {}, {}}};\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tdir = (dir + turn[command[i]] + 4) % 4;\n\t\t\tget_d[dir].emplace_back(i);\n\t\t}\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\ttypedef tuple<int, int, int> P;\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tvector<vector<int>> dist(h, vector<int>(w, n + 1));\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'S') {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tque.push(make_tuple(0, j, i));\n\t\t\t\t\tgoto unloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tunloop:;\n\n\t\twhile(!que.empty()) {\n\t\t\tint di, x, y;\n\t\t\ttie(di, x, y) = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(dist[y][x] < di) continue;\n\n\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || field[ny][nx] == '#') continue;\n\n\t\t\t\tconst auto it = lower_bound(get_d[d].begin(), get_d[d].end(), di);\n\t\t\t\tif(it == get_d[d].end()) continue;\n\n\t\t\t\tif(dist[ny][nx] > *it) {\n\t\t\t\t\tif(field[ny][nx] == 'G') goto ok;\n\t\t\t\t\tdist[ny][nx] = *it;\n\t\t\t\t\tque.push(make_tuple(*it, nx, ny));\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tcout << \"No\" << endl;\n\t\tcontinue;\n\n\tok:;\n\t\tcout << \"Yes\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory.h>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 25;\nint direction[1000010][4];\nint memo[1010][1010][4];\nvector<int> direct[4];\nchar field[1010][1010];\nstring command;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1,  0, -1};\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> state;  // position, direcion\ntypedef pair<int, state> data;\n\n\nint main(){\n  int H, W, N;\n  int sy, sx;\n  int gy, gx;\n  while(cin >> H >> W >> N && (H || W || N)){\n    int dir = 0;\n    cin >> command;\n    \n    \n    for(int i = 0; i < 1000010; i++){\n      for(int j = 0; j < 4; j++){\n\tdirection[i][j] = INF;\n      }\n    }\n    for(int i = 0; i < 1010; i++){\n      for(int j = 0; j < 1010; j++){\n\tfield[i][j] = '#';\n\tfor(int k = 0; k < 4; k++){\n\t  memo[i][j][k] = INF;\n\t}\n      }\n    }\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 'S'){\n\t  sy = i + 1;\n\t  sx = j + 1;\n\t  field[i+1][j+1] = '.';\n\t}\n\tif(field[i+1][j+1] == 'G'){\n\t  gy = i + 1;\n\t  gx = j + 1;\n\t  field[i+1][j+1] = '.';\n\t}\n      }\n    }\n    \n    for(int i = 0; i < 4; i++) direct[i].clear();\n    for(int i = 0; i < N; i++){\n      direct[dir].push_back(i);\n      if(command[i] == 'R') dir = (dir + 1) %4 ;\n      else dir = (dir + 3) % 4;\n    }\n    direct[dir].push_back(N);\n    \n    for(int i = 0; i <= N; i++){\n      for(int j = 0; j < 4; j++){\n\tvector<int>::iterator iter\n\t  = upper_bound(direct[j].begin(), direct[j].end(), i);\n\tif(iter != direct[j].end()) direction[i][j] = *iter;\n      }\n    }\n    \n    memo[sy][sx][0] = 0;\n    priority_queue<data, vector<data>, greater<data> > que;\n \n    bool flag=false;\n    que.push(data(0, state(P(sy, sx), 0)));\n    while(!que.empty()){\n      data d = que.top();\n      int cost = d.first;\n      state s = d.second;\n      int y = s.first.first;\n      int x = s.first.second;\n      int dir = s.second;\n      que.pop();\n      \n      if(s.first.first == gy && s.first.second==gx){\n\tflag = true;\n\tbreak;\n      }\n      if(cost > memo[y][x][dir]) continue;\n\n      \n      \n      for(int i=0;i<4;i++){\n\tint nextturn = direction[cost][i];\n\tint y2 = y + dy[i];\n\tint x2 = x + dx[i];\n\tif(field[y2][x2] == '#') continue;\n\tif(memo[y2][x2][i] > nextturn){\n\t  memo[y2][x2][i] = nextturn;\n\t  que.push(data(nextturn, state(P(y2, x2), i)));\n\t}\n\t\n      }\n      int y2 = y + dy[dir];\n      int x2 = x + dx[dir];\n      if(field[y2][x2] != '#' && memo[y2][x2][dir] > cost){\n\tmemo[y2][x2][dir] = cost;\n\tque.push(data(cost, state(P(y2, x2), dir)));\n      }\n    }\n    if(flag){\n      cout << \"Yes\" << endl;\n    }else{\n      cout << \"No\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n  int x,y,d,idx;\n  State(){}\n  State(int _x,int _y,int _d,int _idx){\n    x = _x;\n    y = _y;\n    d = _d;\n    idx = _idx;\n  }\n};\n\nint sx,sy;\nint gx,gy;\n\nint h,w,n;\nint next_dir[1000002][4];\nbool closed[1002][1002][4];\nchar t[1002][1002];\nstring s;\n\nint dir[1000002];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nbool solve(){\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n\n  open.push(State(sx,sy,0,0));\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y][st.d]){\n      continue;\n    }\n    closed[st.x][st.y][st.d] = true;\n\n    if(st.x == gx && st.y == gy){\n      return true;\n    }\n\n    rep(i,4){\n      if(next_dir[st.idx][i] != -1){\n        int nx = st.x + dx[i];\n        int ny = st.y + dy[i];\n\n        if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] == '#'){\n          nx -= dx[i];\n          ny -= dy[i];\n        }\n\n        open.push(State(nx,ny,i,next_dir[st.idx][i]));\n      }\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  while(cin>>h>>w>>n,h||w||n){\n    cin>>s;\n\n    rep(i,h){\n      cin>>t[i];\n      rep(j,w){\n        if(t[i][j] == 'S'){\n          sx = j;\n          sy = i;\n        }\n        else if(t[i][j] == 'G'){\n          gx = j;\n          gy = i;\n        }\n      }\n    }\n\n    memset(next_dir,-1,sizeof(next_dir));\n\n    int d = 0;\n\n    rep(i,n+1){\n      dir[i] = d;\n      if(s[i] == 'L'){\n        d = (d + 3) % 4;\n      }\n      else{\n        d = (d + 1) % 4;\n      }\n    }\n\n    int table[4];\n    memset(table,-1,sizeof(table));\n\n    for(int i=n;i>=0;i--){\n      table[dir[i]] = i;\n      rep(j,4){\n        next_dir[i][j] = table[j];\n      }\n    }\n\n    rep(i,n+1){\n      rep(j,4){\n        printf(\"%3d\",next_dir[i][j]);\n      }\n      cout<<endl;\n    }\n\n    bool flg = solve();\n    cout<<(flg ? \"Yes\" : \"No\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Stat{\n\tint x,y,d;\n\tbool operator<(const Stat &S)const{ return d>S.d; }\n};\n\nint main(){\n\tfor(int h,w,n;scanf(\"%d%d%d\",&h,&w,&n),h;){\n\t\tchar cmd[1000001]; scanf(\"%s\",cmd);\n\t\tint sx,sy,gx,gy;\n\t\tstatic char B[1000][1001];\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",B[i]);\n\t\t\trep(j,w){\n\t\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t\t}\n\t\t}\n\n\t\tint len=strlen(cmd);\n\t\tstatic int dir[1000001];\n\t\tdir[0]=1;\n\t\trep(i,len) dir[i+1]=(dir[i]+(cmd[i]=='L'?1:3))%4;\n\n\t\tstatic int next[1000001][4];\n\t\trep(k,4) next[len][k]=(k==dir[len]?len:INF);\n\t\tfor(int i=len;i>0;i--) rep(k,4) {\n\t\t\tif(k==dir[i-1]) next[i-1][k]=i-1;\n\t\t\telse            next[i-1][k]=next[i][k];\n\t\t}\n\n\t\tstatic int d[1000][1000][4];\n\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k]=INF;\n\t\td[sy][sx][1]=0;\n\n\t\tbool ok=false;\n\t\tpriority_queue<Stat> pq; pq.push((Stat){sx,sy,0});\n\t\twhile(!pq.empty()){\n\t\t\tStat S=pq.top(); pq.pop();\n\n\t\t\tif(d[S.y][S.x][dir[S.d]]<S.d) continue;\n\t\t\tif(S.x==gx && S.y==gy){ ok=true; break; }\n\n\t\t\trep(k,4){\n\t\t\t\tint xx=S.x+dx[k],yy=S.y+dy[k];\n\t\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]!='#'){\n\t\t\t\t\tif(next[S.d][k]<d[yy][xx][k]){\n\t\t\t\t\t\td[yy][xx][k]=next[S.d][k];\n\t\t\t\t\t\tpq.push((Stat){xx,yy,next[S.d][k]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dist[1111][1111][4];\nint todir[1111111][4][4];\nvs fld;\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tREP(i, 1111)REP(j, 1111)REP(k, 4) dist[i][j][k] = INF;\n\t\tREP(i, 1111111)REP(j, 4)REP(k, 4) todir[i][j][k] = INF;\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (dist[x][y][i] > tmp)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\nenum class Direction {\n\tNorth, East, South, West\n};\nDirection from_int(const int n) {\n\tswitch (n % 4) {\n\tcase 0: return Direction::North;\n\tcase 1: return Direction::East;\n\tcase 2: return Direction::South;\n\tcase 3: return Direction::West;\n\tdefault: throw 0;\n\t}\n}\nint to_int(const Direction dir) {\n\tswitch (dir) {\n\tcase Direction::North: return 0;\n\tcase Direction::East: return 1;\n\tcase Direction::South: return 2;\n\tcase Direction::West: return 3;\n\tdefault: throw 0;\n\t}\n}\nDirection turn(const Direction current, const char order) {\n\tswitch (order) {\n\tcase 'L': return from_int(to_int(current) + 3);\n\tcase 'R': return from_int(to_int(current) + 1);\n\tdefault: throw 0;\n\t}\n}\nstruct Coordinate {\n\tint x, y;\n\tCoordinate move(const Direction dir) const {\n\t\tswitch (dir) {\n\t\tcase Direction::North: return Coordinate{ x, y - 1 };\n\t\tcase Direction::East: return Coordinate{ x + 1, y };\n\t\tcase Direction::South: return Coordinate{ x, y + 1 };\n\t\tcase Direction::West: return Coordinate{ x - 1, y };\n\t\tdefault: throw 0;\n\t\t}\n\t}\n};\nint main() {\n\twhile (true) {\n\t\tint h, w, n; std::cin >> h >> w >> n; if (h == 0 && w == 0 && n == 0) break;\n\t\tstd::string order; std::cin >> order;\n\t\tstd::vector<Direction> directions{ Direction::North };\n\t\tfor (const char c : order) {\n\t\t\tdirections.push_back(turn(directions.back(), c));\n\t\t}\n\t\tstd::vector<std::vector<int>> next_direction(n + 1);\n\t\t{\n\t\t\tstd::vector<int> prev{ n + 1, n + 1, n + 1, n + 1};\n\t\t\tfor (int i = n; i >= 0; --i) {\n\t\t\t\tprev[to_int(directions[i])] = i;\n\t\t\t\tnext_direction[i] = prev;\n\t\t\t}\n\t\t}\n\t\tstd::vector<std::string> state(h); for (auto& line : state) std::cin >> line;\n\t\tCoordinate start{ -1, -1 }, goal{ -1, -1 };\n\t\tfor (auto y = 0; y < h; ++y) for (auto x = 0; x < w; ++x) {\n\t\t\tif (state[y][x] == 'S') start = Coordinate{ x, y };\n\t\t\tif (state[y][x] == 'G') goal = Coordinate{ x, y };\n\t\t}\n\t\tstd::vector<std::vector<std::vector<int>>> min_step(h, std::vector<std::vector<int>>(w, std::vector<int>(4, INT_MAX))); min_step[start.y][start.x][to_int(Direction::North)] = 0;\n\t\tstd::vector<std::queue<Coordinate>> history(n + 1); history[0].push(start);\n\t\tbool can_reach = false;\n\t\tfor (auto i = 0; i <= n && !can_reach; ++i) {\n\t\t\twhile (!history[i].empty()) {\n\t\t\t\tconst auto top = history[i].front(); history[i].pop();\n\t\t\t\tif (min_step[top.y][top.x][to_int(directions[i])] != i) continue;\n\t\t\t\tconst auto next_pos = top.move(directions[i]);\n\t\t\t\tif (0 <= next_pos.y && next_pos.y < h && 0 <= next_pos.x && next_pos.x < w && state[next_pos.y][next_pos.x] != '#') {\n\t\t\t\t\tif (min_step[next_pos.y][next_pos.x][to_int(directions[i])] > i) {\n\t\t\t\t\t\tmin_step[next_pos.y][next_pos.x][to_int(directions[i])] = i;\n\t\t\t\t\t\tif (next_pos.x == goal.x && next_pos.y == goal.y) {\n\t\t\t\t\t\t\tcan_reach = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thistory[i].emplace(next_pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const auto next_dir : next_direction[i]) if (next_dir <= n) {\n\t\t\t\t\tif (min_step[top.y][top.x][to_int(directions[next_dir])] > next_dir) {\n\t\t\t\t\t\tmin_step[top.y][top.x][to_int(directions[next_dir])] = next_dir;\n\t\t\t\t\t\thistory[next_dir].emplace(top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (can_reach || std::any_of(min_step[goal.y][goal.x].begin(), min_step[goal.y][goal.x].end(), [](const int step) {return step != INT_MAX; })) {\n\t\t\tstd::cout << \"Yes\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"No\\n\";\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint H, W, N;\nstring s;\nstring c[1001];\nint nex[4][1001000];\nint mincost[1001][1001];\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nstruct State {\n  int y, x, cost;\n  State(){}\n  State(int y, int x, int cost):y(y), x(x), cost(cost){}\n  bool operator < (const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W&&c[y][x]!='#';\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> H >> W >> N, H) {\n    cin >> s;\n    rep(i, H) cin >> c[i];\n\n    vint sum(N+1);\n    rep(i, N) {\n      if(s[i] == 'L') sum[i+1] = sum[i]+1;\n      else sum[i+1] = sum[i]+3;\n      sum[i+1] %= 4;\n    }\n    memset(nex, -1, sizeof(nex));\n    rep(i, 4) {\n      int p = -1;\n      for(int j = N; j >= 0; --j) {\n\tif(sum[j] == i) p = j;\n\tif(~p) nex[i][j] = p-j;\n      }\n    }\n\n    int sy, sx, gy, gx;\n    rep(i, H) rep(j, W) {\n      if(c[i][j] == 'S') sy = i, sx = j;\n      else if(c[i][j] == 'G') gy = i, gx = j;\n    }\n\n    priority_queue<State> que;\n    fill(mincost[0], mincost[1001], inf);\n    mincost[sy][sx] = 0;\n    que.push(State(sy, sx, 0));\n    while(!que.empty()) {\n      State st = que.top(); que.pop();\n      if(st.y == gy && st.x == gx) break;\n      if(mincost[st.y][st.x] < st.cost) continue;\n      rep(i, 4) {\n\tint ny = st.y + dy[i], nx = st.x + dx[i];\n\tif(!in(ny, nx)) continue;\n\tif(nex[i][st.cost] == -1) continue;\n\tif(st.cost+nex[i][st.cost] < mincost[ny][nx]) {\n\t  mincost[ny][nx] = st.cost + nex[i][st.cost];\n\t  que.push(State(ny, nx, mincost[ny][nx]));\n\t}\n      }\n    }\n    cout << (mincost[gy][gx] == inf ? \"No\" : \"Yes\") << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint h,w,n;\nchar ss[1000001];\nchar field[1001][1001];\nint sx,sy;\nint gx,gy;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nint d[4][1001][1001];\nint toAng[4][4][1000001];\nconst int INF=1000000000;\n\ntypedef pair<int,int> pii;\n\nint dfs(int cang,int oang,int pos){\n\tif(cang==oang)return pos;\n\telse if(pos==n)return INF;\n\telse if(toAng[cang][oang][pos]!=-1)return toAng[cang][oang][pos];\n\tint nang;\n\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n\telse nang=(cang+1)%4;\n\treturn toAng[cang][oang][pos]=dfs(nang,oang,pos+1);\n}\n\nbool bfs(){\n\tmemset(toAng,-1,sizeof(toAng));\n\n\t// »ÝÌü«©çÚIÌü«ÖÚ®·éÌÉÇ±ÜÅ^[ðg¤Kvª é©vZ\n\t// ìêÈ¢ÈçÎINF\n\t// cang==oagn\n//\tfor(int i=0;i<4;i++)for(int j=0;j<n;j++)toAng[i][i][j]=i;\n//\t// cang!=oang&&pos==n\n//\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(i!=j)toAng[i][j][n]=INF;\n//\tfor(int k=n-1;k>=0;k--){\n//\t\tfor(int i=0;i<4;i++){\n//\t\t\tfor(int j=0;j<4;j++){\n//\t\t\t\tif(j==i)continue;\n//\t\t\t\tint nang;\n//\t\t\t\tint cang=i;\n//\t\t\t\tint oang=j;\n//\t\t\t\tint pos=k;\n//\t\t\t\tif(ss[pos]=='L')nang=(cang-1+4)%4;\n//\t\t\t\telse nang=(cang+1)%4;\n//\t\t\t\ttoAng[cang][oang][pos]=toAng[nang][oang][pos+1];\n//\t\t\t}\n//\t\t}\n//\t}\n\t//  éêÖB·éÌÉKvÈÅ¬^[\n\tpriority_queue<pair<pii,pii>,vector<pair<pii,pii> >,greater<pair<pii,pii> > > pq;\n\tfor(int i=0;i<4;i++)for(int j=0;j<1001;j++)for(int k=0;k<1001;k++)d[i][j][k]=INF;\n\tpq.push(make_pair(pii(0,0),pii(sy,sx)));\n\td[0][sy][sx]=0;\n\twhile(pq.size()){\n\t\tpair<pii,pii> p=pq.top();\n\t\tpq.pop();\n\t\tint cx=p.second.second;\n\t\tint cy=p.second.first;\n\t\tint cang=p.first.second;\n\t\tint cpos=p.first.first;\n\t\t// àµ»ÝÌRXgæè¬³¢àÌª·ÅÉ¶ÝµÄ¢½ÌÈçÎ\n\t\tif(d[cang][cy][cx]<cpos)continue;\n\t\t// 4ûüÖÚ®\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tint nang=i;\n\t\t\t// ÌûüðìêéÜÅposðißé\n\t\t\t//int npos=toAng[cang][nang][cpos];\n\t\t\tint npos=dfs(cang,nang,cpos);\n\t\t\tif(npos!=INF&&ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]=='.'&&d[nang][ny][nx]>npos){\n\t\t\t\td[nang][ny][nx]=npos;\n\t\t\t\tpq.push(make_pair(pii(npos,nang),pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++)if(d[i][gy][gx]!=INF)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>h>>w>>n&&(h|w|n)){\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t\telse if(field[i][j]=='G'){\n\t\t\t\tgx=j;\n\t\t\t\tgy=i;\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1000001\n#define M 1001\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,P> PP;\nint h,w,n;\nstring mp[M],str;\n\nint D[4][M][M];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint getCost(int x,int dir,int ndir){\n  while(x<n&&dir!=ndir){\n    if(str[x] == 'L') dir = (dir+3)%4;\n    else dir = (dir+1)%4;\n    x++;\n  }\n  if(dir!=ndir) return -1;\n  return x;\n}\n\nbool dijkstra(int sy,int sx){\n  for(int i=0;i<4;i++)\n    for(int j=0;j<h;j++)\n      for(int k=0;k<w;k++) D[i][j][k] = 1e9;\n  \n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sy,sx)));\n  D[0][sy][sx] = 0;\n\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int dir = t.first.second;\n    int y = t.second.first;\n    int x = t.second.second;\n    \n    if(mp[y][x] =='G') return 1;    \n    if(D[dir][y][x]<cost) continue;\n\n    \n    for(int i=0;i<4;i++){\n      int ncost = getCost(cost,dir,i);\n      if(ncost == -1 || D[i][y][x]<=ncost)continue;\n      Q.push(PP(P(ncost,i),P(y,x)));\n      D[i][y][x] = ncost;\n    }\n\n    int ny = y+dy[dir]; \n    int nx = x+dx[dir];\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#'||D[dir][ny][nx]<=cost)continue;\n    D[dir][ny][nx] = cost;\n    Q.push(PP(P(cost,dir),P(ny,nx)));\n    \n  }  \n  \n  return 0;\n}\n\nint main(){\n\n  while(1){\n  cin>>h>>w>>n;\n  if(!h&&!w&&!n)break;\n  cin>>str;\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == 'S') cout<<(dijkstra(i,j)?\"Yes\":\"No\")<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint dist[1111][1111][4];\nint todir[1111][4][4];\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w, n;\n\tstring s;\n\twhile (cin >> h >> w >> n, n)\n\t{\n\t\tREP(i, 1111)REP(j, 1111)REP(k, 4) dist[i][j][k] = INF;\n\t\tREP(i, 1111)REP(j, 4)REP(k, 4) todir[i][j][k] = INF;\n\t\tvs fld;\n\t\tfld.resize(h);\n\t\tcin >> s;\n\t\tREP(i, 4) todir[n][i][i] = n;\n\t\tfor (int i = n - 1; i >= 0; i--)REP(j, 4)REP(k, 4)\n\t\t{\n\t\t\tif (j == k)\n\t\t\t{\n\t\t\t\ttodir[i][j][k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nx;\n\t\t\tif (s[i] == 'L') nx = (j + 1) % 4;\n\t\t\telse nx = (j + 3) % 4;\n\t\t\ttodir[i][j][k] = todir[i + 1][nx][k];\n\t\t}\n\t\tREP(i, h) cin >> fld[i];\n\t\tpii go;\n\t\tqueue<tuple<int, int, int>> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'S')\n\t\t\t{\n\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t\tif (fld[i][j] == 'G')\n\t\t\t{\n\t\t\t\tgo = pii(i, j);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x, y, dir;\n\t\t\ttie(x, y, dir) = que.front();\n\t\t\tque.pop();\n\t\t\tint p = dist[x][y][dir];\n\t\t\tif (pii(x, y) == go)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != '#' && dist[nx][ny][dir] > p)\n\t\t\t{\n\t\t\t\tdist[nx][ny][dir] = p;\n\t\t\t\tque.push(make_tuple(nx, ny, dir));\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint tmp = p + todir[p][dir][i];\n\t\t\t\tif (dist[x][y][i] > tmp)\n\t\t\t\t{\n\t\t\t\t\tdist[x][y][i] = tmp;\n\t\t\t\t\tque.push(make_tuple(x, y, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000005\n#define MAX_H 1005\n#define MAX_W 1005\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nstruct state{\n  int y,x,dir;\n};\n\nint H,W,N;\nint si,sj,ti,tj;\nchar a[MAX_N];\nchar t[MAX_H][MAX_W];\nint d[MAX_H][MAX_W][4];\n\nbool solve(){\n  fill( (int*)d[0], (int*)d[MAX_H] , 1e9 );\n  deque< state > Q;\n  Q.push_front( (state){si,sj,0} );\n  d[si][sj][0]=0;\n  while(!Q.empty()){\n    state s=Q.front();Q.pop_front();\n    int cost=d[s.y][s.x][s.dir];\n    if(t[s.y][s.x]=='G')return true;\n    state tmp=s;\n    while(1){\n      s.y+=dy[s.dir];\n      s.x+=dx[s.dir];\n      if(s.y<0 || s.x<0)break;\n      if(s.y>=H || s.x>=W)break;\n      if(t[s.y][s.x]=='#')break;\n      if(cost < d[s.y][s.x][s.dir]){\n        d[s.y][s.x][s.dir]=cost;\n        Q.push_front(s);\n      }\n    }\n    if(cost==N)continue;\n    s=tmp;\n    int ndir=(s.dir+(a[cost]=='L'?3:1))%4;\n    if(cost+1 < d[s.y][s.x][ndir] ){\n      d[s.y][s.x][ndir]=cost+1;\n      Q.push_back( (state){s.y,s.x,ndir} );\n    }\n    \n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d\",&H,&W,&N);\n    if(H==0&&W==0&&N==0)break;\n    scanf(\"%s\",a);\n    for(int i=0;i<H;i++){\n      scanf(\"%s\",t[i]);\n      for(int j=0;j<W;j++){\n        if(t[i][j]=='S')si=i,sj=j;\n        if(t[i][j]=='G')ti=i,tj=j;\n      }\n    }\n    printf(solve() ? \"Yes\\n\" : \"No\\n\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w, n, d[N][N][4];\nstring o, s[N];\nint sy, sx;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\npriority_queue<P2,vector<P2>,greater<P2> > q;\n\nbool dijkstra(){\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++) d[i][j][k]=INF;\n  \n  q.push(P2(P(0,0),P(sy,sx)));\n\n  d[sy][sx][0]=0;\n\n  bool res=false;\n  \n  while(!q.empty()){\n\n    P2 t=q.top(); q.pop();\n\n    int cost=t.first.first;\n    int dir=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x][dir]<cost) continue;\n    \n    if(s[y][x]=='G') res=true;\n\n    if(cost<n&&o[cost]=='R'&&d[y][x][(dir+1)%4]>cost+1){\n\n      d[y][x][(dir+1)%4]=cost+1;\n      \n      q.push(P2(P(cost+1,(dir+1)%4),P(y,x)));\n    }\n\n    if(cost<n&&o[cost]=='L'&&d[y][x][(dir+3)%4]>cost+1){\n      \n      d[y][x][(dir+3)%4]=cost+1;\n      \n      q.push(P2(P(cost+1,(dir+3)%4),P(y,x)));\n    }\n    \n    int ny=y+dy[dir], nx=x+dx[dir];\n    \n    if(ny<0||nx<0||h<=ny||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n\n    if(d[ny][nx][dir]>cost){\n\n      d[ny][nx][dir]=cost;\n      \n      q.push(P2(P(cost,dir),P(ny,nx)));\n    }\n    \n  }\n  \n  return res;\n}\n\nint main(){\n  \n  while(1) {\n    \n    cin>>h>>w>>n;\n    if(!h&&!w&&!n) break;\n  \n    cin>>o;\n\n    for(int i=0;i<h;i++){\n    \n      cin>>s[i];\n\n      for(int j=0;j<w;j++)\n\tif(s[i][j]=='S') sy=i, sx=j;\n    \n    }\n\n    if(dijkstra()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nchar ba[1000][1000];\n\nstruct P {\n    int y,x;\n    int d;\n    int i;\n    int dist;\n};\nstruct P2 {\n    int y,x;\n    int d;\n};\nconst bool operator<(const P& a, const P &b) {\n    return a.dist > b.dist;\n}\n\nbool visited[1000][1000][4];\n\nint sx, sy, gx, gy;\nstring s;\n\n\nint main() {\n    int h,w,n;\n    while(cin>>h>>w>>n,h||w||n) {\n        cin >> s;\n        vector<int> L, R;\n        for (int i=0; i<s.size(); ++i) {\n            if (s[i] == 'L') L.push_back(i);\n            else R.push_back(i);\n        }\n        for (int i=0;i<h;++i) {\n            for (int j=0; j<w;++j) {\n                cin >> ba[i][j];\n                if (ba[i][j] == 'S') {\n                    sx = j;\n                    sy = i;\n                } else if (ba[i][j] == 'G'){\n                    gx = j;\n                    gy = i;\n                }\n            }\n        }\n        priority_queue<P> Q;\n        memset(visited, 0, sizeof(visited));\n        Q.push((P){sy,sx,0,0,0});\n        \n        bool f = 0;\n        \n        while(!Q.empty()) {\n            P now = Q.top(); Q.pop();            \n            //if (visited[now.y][now.x][now.d]) continue;\n            visited[now.y][now.x][now.d] = 1;\n            \n            //printf(\"(%d,%d) %d : %d\\n\", now.x, now.y, now.d, now.i);\n            \n            if (now.y == gy && now.x == gx) {\n                f = 1;\n                break;\n            }\n            \n            int l = lower_bound(L.begin(), L.end(), now.i) - L.begin();\n            if (l != L.size()) {\n                if (!visited[now.y][now.x][(now.d+3)%4]) {\n                    visited[now.y][now.x][(now.d+3)%4] = 1;\n                    Q.push((P){now.y, now.x, (now.d+3)%4, now.dist+1, l+1});\n                }\n            }\n            int r = lower_bound(R.begin(), R.end(), now.i) - R.begin();\n            if (r != R.size()) {\n                if (!visited[now.y][now.x][(now.d+1)%4]) {\n                    visited[now.y][now.x][(now.d+1)%4] = 1;\n                    Q.push((P){now.y, now.x, (now.d+1)%4, now.dist+1, r+1});\n                    \n                }\n            }\n           \n            int yy = now.y+dy[now.d];\n            int xx = now.x+dx[now.d];\n            if (yy<0||yy>=h||xx<0||xx>=w) continue;\n            if (ba[yy][xx] == '#') continue;\n\n            if (!visited[yy][xx][now.d]) {\n                visited[yy][xx][now.d] = 1;\n        \n                Q.push((P){yy, xx, now.d, now.dist});\n            }\n        }\n        if(f) {\n            cout << \"Yes\" << endl;\n        } else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar fie[1001][1001];\nint H,W,N;\nint memo[1001][1001];\nchar S[1000001];\nint Ds[1000001][4];\n\nint dx[]={0,1,0,-1};//R -> +1 , L -> +1\nint dy[]={-1,0,1,0};\n\nint sx,sy,gx,gy;\n\nstruct state{\n  int x,y,c;\n  bool operator>(const state &st) const{\n    return c > st.c;\n  }\n\n};\n\nbool check( int x,int y,int nc){\n  if( x < 0 || y < 0 || x >= W || y >= H ) return false;\n  if( fie[x][y] == '#' ) return false;\n  if( memo[x][y] == -1 ) return true;\n  if( memo[x][y] <= nc ) return false;\n  return true; \n}\n\n\n\nbool bfs(){\n\n  memset(memo,-1,sizeof(memo));\n\n  priority_queue<state,vector<state>,greater<state> > q;\n\n  q.push( (state){sx,sy,0} );\n  memo[sx][sy] = 0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    int x = p.x;\n    int y = p.y;\n    int c = p.c;\n\n    //  cout << x<< \" \" << y << \" \"<< c << endl;\n\n    for(int i=0;i<4;i++){\n      int nd = i;\n      int nc = Ds[c][nd];\n      if( nc > N ) continue;\n      int nx = x+dx[nd];\n      int ny = y+dy[nd];\n      if( check(nx,ny,nc) ){\n\tq.push( (state){nx,ny,nc} );\n\tmemo[nx][ny] = nc;\n      }\n    }\n  }\n  if( memo[gx][gy] == -1 )\n    return false;\n  return true;\n}\n\nint main(){\n  while(cin >> H >> W >> N && (H||W||N) ){\n    for(int i=1;i<=N;i++){\n      cin >> S[i];\n    }\n    S[0] = 0;\n    int dnc = 0;\n    for(int i=1;i<=N;i++){\n      if( S[i] == 'L' ){\n\tdnc+=3;\t \n      } else {\n\tdnc++;\n      }\n      dnc %= 4;\n      S[i] = (char)dnc;\n    }\n    \n    int dc[4] = {N+1,N+1,N+1,N+1};\n    for(int i=N;i>-1;i--){\n      dc[(int)S[i]] = i;\n      for(int j=0;j<4;j++){\n\tDs[i][j] = dc[j];\n\t//\tprintf(\"%d, %d  %d\\n\",i-1,j,(int)Ds[i-1][j]);\n      }\n    }\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[j][i];\n\tif( fie[j][i] == 'G' ){\n\t  gx=j;\n\t  gy=i;\n\t}\n\tif( fie[j][i] == 'S' ){\n\t  sx = j;\n\t  sy = i;\n\t}\n      }\n    }\n    \n    if( bfs() ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct State {\n    int x : 12;\n    int y : 12;\n    int dir : 4;\n    int n;\n    State(int x, int y, int dir, int n)\n        : x{x}, y{y}, dir{dir}, n{n} {}\n};\n\nint H, W;\nstring commands;\nvector<vector<char>> field;\nvector<int> dir[4];\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nbool in_field(int x, int y)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid init()\n{\n    for (int i = 0; i < 4; i++) {\n        dir[i].clear();\n    }\n}\n\nvoid make(int N)\n{\n    init();\n    int nd = 1;\n    for (int i = 0; i < N; i++) {\n        if (commands[i] == 'L') {\n            nd = (nd + 3) % 4;\n        } else {\n            nd = (nd + 1) % 4;\n        }\n        dir[nd].emplace_back(i);\n    }    \n}\n\nbool solve(int sx, int sy, int gx, int gy)\n{\n    queue<State> Q;\n    Q.push({sx, sy, 1, 0});\n    vector<vector<vector<bool>>> d(H, vector<vector<bool>>(W, vector<bool>(4, 0)));\n    d[sy][sx][1] = 1;\n\n    while (!Q.empty()) {\n        State s = Q.front(); Q.pop();\n        int x = s.x, y = s.y;\n        if (x == gx && y == gy) return 1;\n        \n        // move forward\n        int nx = s.x + dx[s.dir], ny = s.y + dy[s.dir];\n        if (in_field(nx, ny) && field[ny][nx] != '#' && !d[ny][nx][s.dir]) {\n            d[ny][nx][s.dir] = 1;\n            Q.push({nx, ny, s.dir, s.n});\n        }\n        \n        // turn\n        for (int i = 0; i < 4; i++) {\n            auto np = lower_bound(dir[i].begin(), dir[i].end(), s.n);\n            if (np == dir[i].end()) continue;\n            int nn = np - dir[i].begin();\n            if (!d[y][x][i]) {\n                d[y][x][i] = 1;\n                Q.push({x, y, i, nn + 1});                \n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{\n    int N, sx, sy, gx, gy;\n    while (cin >> H >> W >> N, H) {\n        cin >> commands;\n        field.resize(H);\n        for (int i = 0; i < H; i++) {\n            field[i].resize(W);\n            for (int j = 0; j < W; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == 'S') { \n                    field[i][j] = '.';\n                    sx = j; sy = i;\n                } else if (field[i][j] == 'G') {\n                    field[i][j] = '.';\n                    gx = j; gy = i;\n                }\n            }\n        }\n        make(N);\n        cout << (solve(sx, sy, gx, gy) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef include?(obj)\n\t\t@index.include?(obj)\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\ndij = [\n\t[-1, 0],\n\t[0, 1],\n\t[1, 0],\n\t[0, -1],\n]\n\nloop do\n\th, w, n = gets.split.map(&:to_i)\n\tbreak if h == 0\n\tcommands = gets.chomp\n\ta = (0..h-1).map { gets.chomp.split(\"\") }\n\n\tsi, sj, gi, gj = nil\n\t(0..h-1).each do |i|\n\t\t(0..w-1).each do |j|\n\t\t\tif a[i][j] == ?S\n\t\t\t\tsi, sj = i, j\n\t\t\tend\n\t\t\tif a[i][j] == ?G\n\t\t\t\tgi, gj = i, j\n\t\t\tend\n\t\tend\n\tend\n\n\tpq = Heap.new\n\n\ti, j = si, sj\n\tloop do\n\t\tpq.add([i, j, 0], 0)\n\t\ti -= 1\n\t\tbreak if i < 0 || a[i][j] == ?#\n\tend\n\n\tmin_command = {}\n\tloop do\n\t\tu, c = pq.del_min\n\t\tmin_command[u] = c\n\t\ti, j, dir = u\n\t\tif i == gi && j == gj\n\t\t\tbreak\n\t\tend\n\n\t\trest_dir = (0..3).to_a - [dir]\n\t\t(c..commands.size-1).each do |k|\n\t\t\tdir += 1 if commands[k] == ?R\n\t\t\tdir -= 1 if commands[k] == ?L\n\t\t\tdir %= 4\n\t\t\tnext if ! rest_dir.include?(dir)\n\t\t\trest_dir.delete(dir)\n\n\t\t\tdi, dj = dij[dir]\n\t\t\tstep = 1\n\t\t\tloop do\n\t\t\t\tnew_i, new_j = i + step * di, j + step * dj\n\t\t\t\tbreak if new_i < 0 || new_i >= a.size\n\t\t\t\tbreak if new_j < 0 || new_j >= a[0].size\n\t\t\t\tbreak if a[new_i][new_j] == ?#\n\t\t\t\tv = [new_i, new_j, k+1]\n\n\t\t\t\tnext if min_command[v]\n\t\t\t\tif pq.include?(v)\n\t\t\t\t\tpq.update_key(v, k+1)\n\t\t\t\telse\n\t\t\t\t\tpq.add(v, k+1)\n\t\t\t\tend\n\t\t\t\tstep += 1\n\t\t\tend\n\t\t\t\n\t\t\tbreak if rest_dir.empty?\n\t\tend\n\t\tbreak if pq.empty?\n\tend\n\n\tif (0..3).any? {|d| min_command[[gi, gj, d]]}\n\t\tputs 'Yes'\n\telse\n\t\tputs 'No'\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tac = Array.new(size + 1)\n\t\tac[0] = 0\n\t\t(1..size).each do |i|\n\t\t\tac[i] = ac[i-1] + self[i-1]\n\t\tend\n\t\tac\n\tend\nend\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@keys = []\n\t\t@items = []\n\t\t@index = {}\n\tend\n\n\tdef add(item, key)\n\t\t@items << item\n\t\t@keys << key\n\t\t@index[item] = @keys.size - 1\n\t\tlift_up(@keys.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @items[i]\n\t\tv = @items[j]\n\t\t@index[u], @index[v] = j, i\n\t\t@keys[i], @keys[j] = @keys[j], @keys[i]\n\t\t@items[i], @items[j] = @items[j], @items[i]\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@keys[i] <=> @keys[j]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin_key = @keys[0]\n\t\tmin_item = @items[0]\n\t\tif size > 1\n\t\t\tswap(0, @keys.size-1)\n\t\t\t@keys.pop\n\t\t\t@items.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@keys.pop\n\t\t\t@items.pop\n\t\tend\n\t\t@index.delete(min_item)\n\t\t[min_item, min_key]\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @keys[i]) >= 0\n\t\t@keys[i] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@keys[i] <=> @keys[j]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@keys[j] <=> @keys[k]) < 0 ? j : k)\n\t\t\tif (@keys[i] <=> @keys[l]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef include?(obj)\n\t\t@index.include?(obj)\n\tend\n\n\tdef key(obj)\n\t\t@keys[@index[obj]]\n\tend\n\n\tdef_delegators :@keys, :empty?, :size\nend\n\ndij = [\n\t[-1, 0],\n\t[0, 1],\n\t[1, 0],\n\t[0, -1],\n]\n\nloop do\n\th, w, n = gets.split.map(&:to_i)\n\tbreak if h == 0\n\tcommands = gets.chomp\n\n\tfoo = commands.each_char.map {|c| (c.ord - 79) / 3}.accum.map {|x| x % 4}\n\tbar = [{}]\n\tn.times do |i|\n\t\thash = bar[0].dup\n\t\thash[foo[n-i]] = n-i\n\t\tbar.unshift hash\n\tend\n\n\ta = (0..h-1).map { gets.chomp.split(\"\") }\n\n\tsi, sj, gi, gj = nil\n\t(0..h-1).each do |i|\n\t\t(0..w-1).each do |j|\n\t\t\tif a[i][j] == ?S\n\t\t\t\tsi, sj = i, j\n\t\t\tend\n\t\t\tif a[i][j] == ?G\n\t\t\t\tgi, gj = i, j\n\t\t\tend\n\t\tend\n\tend\n\n\tpq = Heap.new\n\n\ti, j = si, sj\n\tloop do\n\t\tpq.add([i, j], 0)\n\t\ti -= 1\n\t\tbreak if i < 0 || a[i][j] == ?#\n\tend\n\n\tmin_command = {}\n\twhile !pq.empty?\n\t\tu, c = pq.del_min\n\t\tmin_command[u] = c\n\t\ti, j = u\n\t\tif i == gi && j == gj\n\t\t\tbreak\n\t\tend\n\n\t\tbar[c].each do |dir, k|\n\t\t\tnext if dir == foo[c]\n\n\t\t\tdi, dj = dij[dir]\n\t\t\tstep = 1\n\t\t\tloop do\n\t\t\t\tnew_i, new_j = i + step * di, j + step * dj\n\t\t\t\tstep += 1\n\t\t\t\tbreak if new_i < 0 || new_i >= a.size\n\t\t\t\tbreak if new_j < 0 || new_j >= a[0].size\n\t\t\t\tbreak if a[new_i][new_j] == ?#\n\t\t\t\tv = [new_i, new_j]\n\n\t\t\t\tbreak if min_command[v]\n\n\t\t\t\tif pq.include?(v)\n\t\t\t\t\tbreak if pq.key(v) <= k\n\t\t\t\t\tpq.update_key(v, k)\n\t\t\t\telse\n\t\t\t\t\tpq.add(v, k)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tif min_command[[gi, gj]]\n\t\tputs 'Yes'\n\telse\n\t\tputs 'No'\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\nend\n\nextend Graphical\n\n$dij = [\n\t[-1, 0],\n\t[0, 1],\n\t[1, 0],\n\t[0, -1],\n]\n\ndef each_out_connection_of(u)\n\ti, j, c, dir = u\n\trest_dir = (0..3).to_a - [dir]\n\tnew_dir = dir\n\t(c..$commands.size-1).each do |k|\n\t\tnew_dir += 1 if $commands[k] == ?R\n\t\tnew_dir -= 1 if $commands[k] == ?L\n\t\tnew_dir %= 4\n\t\tnext if ! rest_dir.include?(new_dir)\n\t\trest_dir.delete(new_dir)\n\n\t\tdi, dj = $dij[new_dir]\n\t\tstep = 1\n\t\tloop do\n\t\t\tnew_i, new_j = i + step * di, j + step * dj\n\t\t\tbreak if new_i < 0 || new_i >= $a.size\n\t\t\tbreak if new_j < 0 || new_j >= $a[0].size\n\t\t\tbreak if $a[new_i][new_j] == ?#\n\t\t\tyield([new_i, new_j, k+1, new_dir], 1)\n\t\t\tstep += 1\n\t\tend\n\t\t\n\t\tbreak if rest_dir.empty?\n\tend\nend\n\nloop do\n\th, w, n = gets.split.map(&:to_i)\n\tbreak if h == 0\n\t$commands = gets.chomp\n\t$a = (0..h-1).map { gets.chomp.split(\"\") }\n\n\tstarts = []\n\tgi, gj = nil\n\t(0..h-1).each do |i|\n\t\t(0..w-1).each do |j|\n\t\t\tif $a[i][j] == ?S\n\t\t\t\tstarts << [i, j, 0, 0]\n\t\t\tend\n\t\t\tif $a[i][j] == ?G\n\t\t\t\tgi, gj = i, j\n\t\t\tend\n\t\tend\n\tend\n\n\ti, j, _, _ = starts[0]\n\tloop do\n\t\ti -= 1\n\t\tbreak if i < 0 || $a[i][j] == ?#\n\t\tstarts << [i, j, 0, 0]\n\tend\n\n\tputs bfs(starts){|v, _| v[0] == gi && v[1] == gj} ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n\ndef solve():\n    H, W, N = map(int, readline().split())\n    if H == 0:\n        return False\n    S = readline().strip()\n    C = [[0]*W for i in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        s = readline().strip()\n        for j, c in enumerate(s):\n            if c in '#.':\n                C[i][j] = (c == '#')\n            elif c == 'S':\n                sx = j; sy = i\n            else:\n                gx = j; gy = i\n    S0 = [1]*(N+1)\n    cur = 1\n    for i in range(N):\n        if S[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i+1] = cur\n    d = [N+1]*4\n    D = [None]*(N+1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n\n    T = [[N+1]*W for i in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        cost, x, y = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            dx, dy = dd[k]; n_cost = d[k]\n            nx = x + dx; ny = y + dy\n            if not 0 <= nx < W or not 0 <= ny < H or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    print(\"Yes\" if T[gy][gx] < N+1 else \"No\")\n    return True\nwhile solve():\n    ...\n"
  }
]