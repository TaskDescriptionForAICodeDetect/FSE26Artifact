[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y;\n    int dir; // 0: up, 1: right, 2: down, 3: left\n} Robot;\n\nint H, W;\nchar maze[100][100];\nRobot robot;\nint ex, ey;\n\nvoid initRobot(int sx, int sy, int sdir) {\n    robot.x = sx;\n    robot.y = sy;\n    robot.dir = sdir;\n}\n\nvoid turnLeft() {\n    robot.dir = (robot.dir - 1 + 4) % 4;\n}\n\nvoid turnRight() {\n    robot.dir = (robot.dir + 1) % 4;\n}\n\nbool moveForward() {\n    int nx = robot.x, ny = robot.y;\n    switch (robot.dir) {\n        case 0: nx--; break;\n        case 1: ny++; break;\n        case 2: nx++; break;\n        case 3: ny--; break;\n    }\n    if (nx < 0 || nx >= H || ny < 0 || ny >= W || maze[nx][ny] == '#') {\n        return false;\n    }\n    robot.x = nx;\n    robot.y = ny;\n    return true;\n}\n\nbool executeCommands(const char* commands) {\n    for (int i = 0; commands[i] != '\\0'; ++i) {\n        switch (commands[i]) {\n            case 'L': turnLeft(); break;\n            case 'R': turnRight(); break;\n            case 'F':\n                if (!moveForward()) {\n                    return false;\n                }\n                break;\n        }\n        if (robot.x == ex && robot.y == ey) {\n            return true;\n        }\n    }\n    return robot.x == ex && robot.y == ey;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    int sx, sy, sdir;\n    for (int i = 0; i < H; ++i) {\n        scanf(\"%s\", maze[i]);\n        for (int j = 0; j < W; ++j) {\n            if (maze[i][j] == 'S') {\n                sx = i;\n                sy = j;\n                sdir = 0;\n            } else if (maze[i][j] == 'E') {\n                ex = i;\n                ey = j;\n            }\n        }\n    }\n    char commands[1001];\n    scanf(\"%s\", commands);\n    initRobot(sx, sy, sdir);\n    if (executeCommands(commands)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nbool canReachExit(int H, int W, const vector<string>& maze, const string& commands) {\n    int sx = -1, sy = -1, ex = -1, ey = -1;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (maze[i][j] == 'S') {\n                sx = i;\n                sy = j;\n            } else if (maze[i][j] == 'E') {\n                ex = i;\n                ey = j;\n            }\n        }\n    }\n\n    queue<tuple<int, int, int, int>> q;\n    q.push({sx, sy, 0, 0});\n\n    while (!q.empty()) {\n        auto [x, y, cmd_idx, dir] = q.front();\n        q.pop();\n\n        if (x == ex && y == ey) {\n            return true;\n        }\n\n        if (cmd_idx >= commands.size()) {\n            continue;\n        }\n\n        char cmd = commands[cmd_idx];\n        if (cmd == 'F') {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && maze[nx][ny] != '#') {\n                q.push({nx, ny, cmd_idx + 1, dir});\n            } else {\n                q.push({x, y, cmd_idx + 1, dir});\n            }\n        } else if (cmd == 'L') {\n            int new_dir = (dir - 1 + 4) % 4;\n            q.push({x, y, cmd_idx + 1, new_dir});\n        } else if (cmd == 'R') {\n            int new_dir = (dir + 1) % 4;\n            q.push({x, y, cmd_idx + 1, new_dir});\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> maze(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> maze[i];\n    }\n    string commands;\n    cin >> commands;\n\n    if (canReachExit(H, W, maze, commands)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RobotMaze {\n    static class State {\n        int x, y, dir;\n        State(int x, int y, int dir) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n        }\n    }\n\n    public static boolean canReachExit(char[][] maze, int[] entrance, int[] exit, String commands) {\n        int H = maze.length;\n        int W = maze[0].length;\n        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // North, East, South, West\n        boolean[][][] visited = new boolean[H][W][4];\n        Queue<State> queue = new LinkedList<>();\n\n        for (int dir = 0; dir < 4; dir++) {\n            queue.add(new State(entrance[0], entrance[1], dir));\n            visited[entrance[0]][entrance[1]][dir] = true;\n        }\n\n        for (char cmd : commands.toCharArray()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                State current = queue.poll();\n                if (current.x == exit[0] && current.y == exit[1]) {\n                    return true;\n                }\n\n                if (cmd == 'F') {\n                    int nx = current.x + directions[current.dir][0];\n                    int ny = current.y + directions[current.dir][1];\n                    if (nx >= 0 && nx < H && ny >= 0 && ny < W && maze[nx][ny] != 'W') {\n                        if (!visited[nx][ny][current.dir]) {\n                            visited[nx][ny][current.dir] = true;\n                            queue.add(new State(nx, ny, current.dir));\n                        }\n                    } else {\n                        queue.add(current);\n                    }\n                } else {\n                    int newDir;\n                    if (cmd == 'L') {\n                        newDir = (current.dir + 3) % 4;\n                    } else { // 'R'\n                        newDir = (current.dir + 1) % 4;\n                    }\n                    if (!visited[current.x][current.y][newDir]) {\n                        visited[current.x][current.y][newDir] = true;\n                        queue.add(new State(current.x, current.y, newDir));\n                    }\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (current.x == exit[0] && current.y == exit[1]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 21:26:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public boolean canReachExit(int H, int W, char[][] maze, String commands) {\n        // Find entrance and exit\n        int[] start = findCell(maze, 'S');\n        int[] end = findCell(maze, 'E');\n        \n        // Initial robot state\n        int x = start[0], y = start[1];\n        int dir = 0; // 0: North, 1: East, 2: South, 3: West\n        \n        // Directions: North, East, South, West\n        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n        \n        for (char cmd : commands.toCharArray()) {\n            if (cmd == 'F') {\n                int nx = x + dirs[dir][0];\n                int ny = y + dirs[dir][1];\n                \n                // Check if move is valid\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W || maze[nx][ny] == '#') {\n                    continue;\n                }\n                \n                x = nx;\n                y = ny;\n                \n                // Check if reached exit\n                if (x == end[0] && y == end[1]) {\n                    return true;\n                }\n            } else if (cmd == 'L') {\n                dir = (dir - 1 + 4) % 4;\n            } else if (cmd == 'R') {\n                dir = (dir + 1) % 4;\n            }\n        }\n        \n        return false;\n    }\n    \n    private int[] findCell(char[][] maze, char target) {\n        for (int i = 0; i < maze.length; i++) {\n            for (int j = 0; j < maze[0].length; j++) {\n                if (maze[i][j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}",
    "timestamp": "2025-08-05 21:26:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\ntypedef struct {\n    int x, y;\n    int dir;  // 0: North, 1: East, 2: South, 3: West\n} Robot;\n\nint H, W;\nchar maze[MAX_H][MAX_W];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool is_valid_move(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && maze[x][y] != '#';\n}\n\nbool solve_maze(Robot start, int* commands, int command_count) {\n    Robot current = start;\n    \n    for (int i = 0; i < command_count; i++) {\n        if (commands[i] == 0) {  // Move forward\n            int new_x = current.x + dx[current.dir];\n            int new_y = current.y + dy[current.dir];\n            \n            if (!is_valid_move(new_x, new_y)) {\n                return false;\n            }\n            \n            current.x = new_x;\n            current.y = new_y;\n            \n            if (maze[current.x][current.y] == 'G') {\n                return true;\n            }\n        } else if (commands[i] == 1) {  // Turn left\n            current.dir = (current.dir - 1 + 4) % 4;\n        } else if (commands[i] == 2) {  // Turn right\n            current.dir = (current.dir + 1) % 4;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    Robot start;\n    int start_x, start_y, start_dir;\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", maze[i]);\n        for (int j = 0; j < W; j++) {\n            if (maze[i][j] == 'S') {\n                start.x = i;\n                start.y = j;\n            }\n        }\n    }\n    \n    scanf(\"%d\", &start_dir);\n    start.dir = start_dir;\n    \n    int command_count;\n    scanf(\"%d\", &command_count);\n    \n    int commands[command_count];\n    for (int i = 0; i < command_count; i++) {\n        scanf(\"%d\", &commands[i]);\n    }\n    \n    bool can_reach_exit = solve_maze(start, commands, command_count);\n    \n    printf(\"%s\\n\", can_reach_exit ? \"Yes\" : \"No\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct State {\n    int row, col, dir;\n    string path;\n    State(int r, int c, int d, string p) : row(r), col(c), dir(d), path(p) {}\n};\n\nint solve(int H, int W, vector<string>& maze, string commands) {\n    vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n    int start_r = -1, start_c = -1, end_r = -1, end_c = -1;\n\n    for (int r = 0; r < H; r++) {\n        for (int c = 0; c < W; c++) {\n            if (maze[r][c] == 'S') start_r = r, start_c = c;\n            if (maze[r][c] == 'E') end_r = r, end_c = c;\n        }\n    }\n\n    queue<State> q;\n    vector<vector<vector<bool>>> visited(H, vector<vector<bool>>(W, vector<bool>(4, false)));\n    q.push(State(start_r, start_c, 0, \"\"));\n\n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n\n        if (curr.row == end_r && curr.col == end_c) return 1;\n        if (curr.path.length() > commands.length()) continue;\n\n        for (int i = 0; i < 4; i++) {\n            int next_r = curr.row + directions[i].first;\n            int next_c = curr.col + directions[i].second;\n            int next_dir = i;\n\n            if (next_r < 0 || next_r >= H || next_c < 0 || next_c >= W || maze[next_r][next_c] == '#') continue;\n            if (visited[next_r][next_c][next_dir]) continue;\n\n            int turn = (next_dir - curr.dir + 4) % 4;\n            string next_path = curr.path;\n\n            if (turn == 1) next_path += \"R\";\n            else if (turn == 3) next_path += \"L\";\n\n            if (next_path.length() <= commands.length() && \n                (next_path.empty() || commands.substr(0, next_path.length()) == next_path)) {\n                visited[next_r][next_c][next_dir] = true;\n                q.push(State(next_r, next_c, next_dir, next_path));\n            }\n        }\n    }\n\n    return 0;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> maze(H);\n    for (int i = 0; i < H; i++) cin >> maze[i];\n    string commands;\n    cin >> commands;\n    \n    cout << solve(H, W, maze, commands) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def canReachExit(maze, start, exit, commands):\n    H, W = len(maze), len(maze[0])\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n    dir_index = 0  # Initial direction is 'Right'\n    x, y = start\n\n    for command in commands:\n        if command == 'F':\n            nx, ny = x + dirs[dir_index][0], y + dirs[dir_index][1]\n            if 0 <= nx < H and 0 <= ny < W and maze[nx][ny] != '#':\n                x, y = nx, ny\n        elif command == 'L':\n            dir_index = (dir_index - 1) % 4  # Turn left\n        elif command == 'R':\n            dir_index = (dir_index + 1) % 4  # Turn right\n\n    return (x, y) == exit\n\n# Example usage:\nmaze = [\n    ['.', '.', '.', '#', '.', '.'],\n    ['.', '#', '.', '#', '.', '#'],\n    ['.', '#', '.', '.', '.', '.'],\n    ['#', '.', '#', '#', '.', '.'],\n    ['.', '.', '.', '#', 'E', '.']\n]\n\nstart = (0, 0)  # Assuming (0, 0) is the entrance\nexit = (4, 4)  # Exit defined in the maze\ncommands = \"FFRFF\"\n\nprint(canReachExit(maze, start, exit, commands))  # Output depends on the maze configuration and commands",
    "timestamp": "2025-08-13 06:25:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MazeSolver {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // N, E, S, W\n    private static final int NORTH = 0;\n    private static final int EAST = 1;\n    private static final int SOUTH = 2;\n    private static final int WEST = 3;\n\n    public boolean canReachExit(char[][] maze, int startX, int startY, int endX, int endY, String commands) {\n        int dir = NORTH;\n        int x = startX;\n        int y = startY;\n\n        for (char command : commands.toCharArray()) {\n            if (command == 'L') {\n                dir = (dir + 3) % 4;\n            } else if (command == 'R') {\n                dir = (dir + 1) % 4;\n            } else if (command == 'F') {\n                int nx = x + DIRECTIONS[dir][0];\n                int ny = y + DIRECTIONS[dir][1];\n\n                if (nx >= 0 && nx < maze.length && ny >= 0 && ny < maze[0].length && maze[nx][ny] == '.') {\n                    x = nx;\n                    y = ny;\n                }\n            }\n\n            if (x == endX && y == endY) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 06:25:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\n// Directions: 0 = north, 1 = east, 2 = south, 3 = west\nconst int moveX[4] = {0, 1, 0, -1};\nconst int moveY[4] = {-1, 0, 1, 0};\n\nbool canReachExit(char maze[MAX_H][MAX_W], int H, int W, int startX, int startY, int endX, int endY, const char* commands) {\n    // Initial direction is north\n    int dir = 0;\n    int x = startX, y = startY;\n\n    for (int i = 0; commands[i] != '\\0'; i++) {\n        switch (commands[i]) {\n            case 'F':   // Move forward\n                x += moveX[dir];\n                y += moveY[dir];\n                \n                // Check bounds and walls\n                if (x < 0 || x >= W || y < 0 || y >= H || maze[y][x] == '#') {\n                    return false; // Hit wall or out of bounds\n                }\n                break;\n            case 'L':   // Turn left\n                dir = (dir + 3) % 4;\n                break;\n            case 'R':   // Turn right\n                dir = (dir + 1) % 4;\n                break;\n        }\n    }\n\n    return x == endX && y == endY;\n}\n\nint main() {\n    int H, W;\n    char maze[MAX_H][MAX_W];\n    int startX, startY, endX, endY;\n    char commands[1000];\n\n    // Input part (assume it's correct and values are given for testing)\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", maze[i]);\n    }\n    scanf(\"%d %d\", &startX, &startY);\n    scanf(\"%d %d\", &endX, &endY);\n    scanf(\"%s\", commands);\n\n    if (canReachExit(maze, H, W, startX, startY, endX, endY, commands)) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:25:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_reach_exit(maze, commands, entrance, exit):\n    H, W = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n    \n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and maze[x][y] != '#'\n    \n    def solve(x, y, dir_idx, cmd_idx):\n        if cmd_idx == len(commands):\n            return x == exit[0] and y == exit[1]\n        \n        if x == exit[0] and y == exit[1]:\n            return False\n        \n        cmd = commands[cmd_idx]\n        \n        if cmd == 'F':\n            nx, ny = x + directions[dir_idx][0], y + directions[dir_idx][1]\n            if is_valid(nx, ny):\n                return solve(nx, ny, dir_idx, cmd_idx + 1)\n            return False\n        \n        if cmd == 'L':\n            return solve(x, y, (dir_idx - 1) % 4, cmd_idx + 1)\n        \n        if cmd == 'R':\n            return solve(x, y, (dir_idx + 1) % 4, cmd_idx + 1)\n        \n        return False\n    \n    start_x, start_y = entrance\n    for dir_idx in range(4):\n        if solve(start_x, start_y, dir_idx, 0):\n            return True\n    \n    return False",
    "timestamp": "2025-08-13 06:26:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_maze(H, W, maze, commands):\n    # Find entrance (S) and exit (G)\n    start = None\n    goal = None\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == 'S':\n                start = (i, j)\n            elif maze[i][j] == 'G':\n                goal = (i, j)\n    if not start or not goal:\n        return False\n    \n    # Directions: North, East, South, West\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    dir_names = ['N', 'E', 'S', 'W']\n    current_dir = 0  # Start facing North\n    x, y = start\n    \n    for cmd in commands:\n        if cmd == 'F':\n            dx, dy = directions[current_dir]\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and maze[nx][ny] != '#':\n                x, y = nx, ny\n                if (x, y) == goal:\n                    return True\n        elif cmd == 'L':\n            current_dir = (current_dir - 1) % 4\n        elif cmd == 'R':\n            current_dir = (current_dir + 1) % 4\n    \n    return (x, y) == goal",
    "timestamp": "2025-08-13 06:26:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Position {\n    int x, y;\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> maze(H);\n\n    for (int i = 0; i < H; ++i) {\n        cin >> maze[i];\n    }\n\n    Position entrance, exit;\n    cin >> entrance.x >> entrance.y >> exit.x >> exit.y;\n\n    string commands;\n    cin >> commands;\n\n    // Directions: North, East, South, West\n    vector<int> dx = {-1, 0, 1, 0};\n    vector<int> dy = {0, 1, 0, -1};\n    int currentDirection = 0; // Start facing North\n\n    Position current = entrance;\n\n    for (char command : commands) {\n        if (command == 'L') {\n            currentDirection = (currentDirection + 3) % 4; // Turn left\n        } else if (command == 'R') {\n            currentDirection = (currentDirection + 1) % 4; // Turn right\n        } else if (command == 'M') { // Move forward\n            int newX = current.x + dx[currentDirection];\n            int newY = current.y + dy[currentDirection];\n            if (newX >= 0 && newX < H && newY >= 0 && newY < W &&\n                maze[newX][newY] != '#') { // Check boundaries and walls\n                current.x = newX;\n                current.y = newY;\n            }\n        }\n    }\n\n    if (current.x == exit.x && current.y == exit.y) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:02"
  }
]