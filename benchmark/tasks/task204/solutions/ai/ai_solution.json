[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LINE_LEN 1000\n#define MAX_LINES 10000\n\ntypedef struct {\n    char lines[MAX_LINES][MAX_LINE_LEN];\n    int count;\n} TextData;\n\nvoid process_text(int lines_per_col, int cols_per_page, int col_width, int spacing) {\n    TextData data = { .count = 0 };\n    char line[MAX_LINE_LEN];\n    \n    while (fgets(line, MAX_LINE_LEN, stdin)) {\n        if (line[0] == '\\n') continue;\n        line[strcspn(line, \"\\n\")] = '\\0';\n        strcpy(data.lines[data.count++], line);\n    }\n\n    int total_lines = data.count;\n    int lines_per_page = lines_per_col * cols_per_page;\n    int total_pages = (total_lines + lines_per_page - 1) / lines_per_page;\n\n    for (int page = 0; page < total_pages; ++page) {\n        int start_line = page * lines_per_page;\n        int end_line = (page + 1) * lines_per_page;\n        if (end_line > total_lines) end_line = total_lines;\n\n        for (int line_in_page = 0; line_in_page < lines_per_col; ++line_in_page) {\n            for (int col = 0; col < cols_per_page; ++col) {\n                int line_idx = start_line + col * lines_per_col + line_in_page;\n                if (line_idx < end_line) {\n                    char *text = data.lines[line_idx];\n                    int len = strlen(text);\n                    int pos = 0;\n                    \n                    while (pos < len) {\n                        int remaining = len - pos;\n                        int chunk_size = remaining > col_width ? col_width : remaining;\n                        \n                        for (int i = 0; i < chunk_size; ++i) {\n                            putchar(text[pos + i]);\n                        }\n                        \n                        if (chunk_size < col_width) {\n                            for (int i = 0; i < col_width - chunk_size; ++i) {\n                                putchar('.');\n                            }\n                        }\n                        \n                        pos += chunk_size;\n                        if (pos < len) putchar('\\n');\n                    }\n                } else {\n                    for (int i = 0; i < col_width; ++i) {\n                        putchar('.');\n                    }\n                }\n                \n                if (col < cols_per_page - 1) {\n                    for (int i = 0; i < spacing; ++i) {\n                        putchar(' ');\n                    }\n                }\n            }\n            putchar('\\n');\n        }\n        printf(\"#\\n\");\n    }\n    printf(\"|\\n\");\n}\n\nint main() {\n    int lines_per_col, cols_per_page, col_width, spacing;\n    \n    while (scanf(\"%d %d %d %d\", &lines_per_col, &cols_per_page, &col_width, &spacing) == 4) {\n        while (getchar() != '\\n');\n        process_text(lines_per_col, cols_per_page, col_width, spacing);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MultiColumnList {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNextInt()) {\n            int linesPerColumn = scanner.nextInt();\n            int columnsPerPage = scanner.nextInt();\n            int columnWidth = scanner.nextInt();\n            int columnSpacing = scanner.nextInt();\n            \n            if (linesPerColumn == 0 && columnsPerPage == 0 && columnWidth == 0 && columnSpacing == 0) {\n                break;\n            }\n            \n            List<String> inputLines = new ArrayList<>();\n            scanner.nextLine(); // Consume newline\n            \n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                if (line.isEmpty()) break;\n                inputLines.add(line);\n            }\n            \n            processDataSet(inputLines, linesPerColumn, columnsPerPage, columnWidth, columnSpacing);\n            System.out.println(\"=\" + \"=\".repeat(columnsPerPage * (columnWidth + columnSpacing) - columnSpacing));\n        }\n        \n        scanner.close();\n    }\n    \n    private static void processDataSet(List<String> inputLines, int linesPerColumn, int columnsPerPage, int columnWidth, int columnSpacing) {\n        List<List<String>> columns = new ArrayList<>();\n        \n        for (int i = 0; i < columnsPerPage; i++) {\n            columns.add(new ArrayList<>());\n        }\n        \n        int currentColumn = 0;\n        for (String line : inputLines) {\n            List<String> wrappedLines = wrapLine(line, columnWidth);\n            \n            for (String wrappedLine : wrappedLines) {\n                if (columns.get(currentColumn).size() >= linesPerColumn) {\n                    currentColumn++;\n                    if (currentColumn >= columnsPerPage) {\n                        printPage(columns, columnWidth, columnSpacing);\n                        \n                        for (List<String> column : columns) {\n                            column.clear();\n                        }\n                        currentColumn = 0;\n                    }\n                }\n                columns.get(currentColumn).add(wrappedLine);\n            }\n        }\n        \n        if (!columns.get(0).isEmpty()) {\n            printPage(columns, columnWidth, columnSpacing);\n        }\n    }\n    \n    private static List<String> wrapLine(String line, int columnWidth) {\n        List<String> wrappedLines = new ArrayList<>();\n        \n        while (line.length() > columnWidth) {\n            wrappedLines.add(line.substring(0, columnWidth));\n            line = line.substring(columnWidth);\n        }\n        \n        wrappedLines.add(String.format(\"%-\" + columnWidth + \"s\", line).replace(' ', '.'));\n        return wrappedLines;\n    }\n    \n    private static void printPage(List<List<String>> columns, int columnWidth, int columnSpacing) {\n        int maxLines = columns.stream().mapToInt(List::size).max().orElse(0);\n        \n        for (int i = 0; i < maxLines; i++) {\n            for (int j = 0; j < columns.size(); j++) {\n                String columnLine = i < columns.get(j).size() ? columns.get(j).get(i) : \n                    String.format(\"%-\" + columnWidth + \"s\", \"\").replace(' ', '.');\n                \n                System.out.print(columnLine);\n                \n                if (j < columns.size() - 1) {\n                    System.out.print(\" \".repeat(columnSpacing));\n                }\n            }\n            System.out.println();\n        }\n        \n        System.out.println(\"-\".repeat(columns.size() * (columnWidth + columnSpacing) - columnSpacing));\n    }\n}",
    "timestamp": "2025-08-05 19:04:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> splitLine(const string &line, int width) {\n    vector<string> parts;\n    int start = 0;\n    while (start < line.length()) {\n        int end = min(start + width, (int)line.length());\n        parts.push_back(line.substr(start, end - start));\n        start = end;\n    }\n    return parts;\n}\n\nvoid processDataSet(int linesPerCol, int colsPerPage, int colWidth, int colSpacing) {\n    vector<string> lines;\n    string line;\n    while (getline(cin, line) && !line.empty()) {\n        vector<string> parts = splitLine(line, colWidth);\n        lines.insert(lines.end(), parts.begin(), parts.end());\n    }\n\n    int totalLines = lines.size();\n    int linesPerPage = linesPerCol * colsPerPage;\n    int totalPages = (totalLines + linesPerPage - 1) / linesPerPage;\n\n    for (int page = 0; page < totalPages; ++page) {\n        int startLine = page * linesPerPage;\n        int endLine = min(startLine + linesPerPage, totalLines);\n        int colsThisPage = min(colsPerPage, (endLine - startLine + linesPerCol - 1) / linesPerCol);\n\n        for (int l = 0; l < linesPerCol; ++l) {\n            for (int c = 0; c < colsThisPage; ++c) {\n                int lineIdx = startLine + c * linesPerCol + l;\n                if (lineIdx < endLine) {\n                    string text = lines[lineIdx];\n                    cout << left << setw(colWidth) << setfill('.') << text;\n                } else {\n                    cout << string(colWidth, '.');\n                }\n                if (c < colsThisPage - 1) {\n                    cout << string(colSpacing, ' ');\n                }\n            }\n            cout << endl;\n        }\n        cout << \"#\" << endl;\n    }\n    cout << \"%\" << endl;\n}\n\nint main() {\n    int linesPerCol, colsPerPage, colWidth, colSpacing;\n    while (cin >> linesPerCol >> colsPerPage >> colWidth >> colSpacing) {\n        cin.ignore(); // Ignore newline after integers\n        processDataSet(linesPerCol, colsPerPage, colWidth, colSpacing);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LINE_LENGTH 1000\n\nvoid format_and_print_columns(int lines_per_column, int columns_per_page, \n                               int column_width, int column_spacing) {\n    char input[MAX_LINE_LENGTH];\n    char **columns = malloc(lines_per_column * columns_per_page * sizeof(char*));\n    int current_line = 0, current_column = 0, page_line = 0;\n\n    for (int i = 0; i < lines_per_column * columns_per_page; i++) {\n        columns[i] = malloc((column_width + 1) * sizeof(char));\n        columns[i][0] = '\\0';\n    }\n\n    while (fgets(input, sizeof(input), stdin)) {\n        if (input[0] == '\\n') break;\n\n        char *line = strdup(input);\n        line[strcspn(line, \"\\n\")] = 0;\n\n        while (strlen(line) > 0) {\n            // Handle line wrapping\n            char segment[column_width + 1];\n            strncpy(segment, line, column_width);\n            segment[column_width] = '\\0';\n\n            // Pad with dots if shorter than column width\n            int len = strlen(segment);\n            for (int i = len; i < column_width; i++) {\n                segment[i] = '.';\n            }\n            segment[column_width] = '\\0';\n\n            strcpy(columns[current_line * columns_per_page + current_column], segment);\n\n            line += column_width;\n            if (strlen(line) == 0) free(line - column_width);\n\n            current_line++;\n            if (current_line == lines_per_column) {\n                current_line = 0;\n                current_column++;\n            }\n\n            page_line++;\n            if (page_line == lines_per_column * columns_per_page) {\n                // Print page\n                for (int line = 0; line < lines_per_column; line++) {\n                    for (int col = 0; col < columns_per_page; col++) {\n                        printf(\"%s\", columns[line * columns_per_page + col]);\n                        \n                        // Add spacing between columns\n                        for (int space = 0; space < column_spacing; space++) {\n                            printf(\" \");\n                        }\n                    }\n                    printf(\"\\n\");\n                }\n                printf(\"---\\n\");\n                page_line = 0;\n\n                // Reset columns\n                for (int i = 0; i < lines_per_column * columns_per_page; i++) {\n                    columns[i][0] = '\\0';\n                }\n                current_line = 0;\n                current_column = 0;\n            }\n        }\n    }\n\n    // Print final page if not empty\n    if (page_line > 0) {\n        for (int line = 0; line < lines_per_column; line++) {\n            for (int col = 0; col < columns_per_page; col++) {\n                printf(\"%s\", columns[line * columns_per_page + col]);\n                \n                for (int space = 0; space < column_spacing; space++) {\n                    printf(\" \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        printf(\"---\\n\");\n    }\n\n    printf(\"=====\\n\");\n\n    // Free memory\n    for (int i = 0; i < lines_per_column * columns_per_page; i++) {\n        free(columns[i]);\n    }\n    free(columns);\n}\n\nint main() {\n    int lines_per_column, columns_per_page, column_width, column_spacing;\n\n    while (scanf(\"%d %d %d %d\\n\", &lines_per_column, &columns_per_page, \n                 &column_width, &column_spacing) == 4) {\n        format_and_print_columns(lines_per_column, columns_per_page, \n                                 column_width, column_spacing);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nvector<string> splitLine(const string& line, int columnWidth) {\n    vector<string> result;\n    for (size_t i = 0; i < line.length(); i += columnWidth) {\n        result.push_back(line.substr(i, columnWidth));\n    }\n    return result;\n}\n\nvoid printList(int linesPerColumn, int columnsPerPage, int columnWidth, int spaceBetweenColumns) {\n    int totalWidth = columnWidth * columnsPerPage + spaceBetweenColumns * (columnsPerPage - 1);\n    vector<vector<string>> columns(columnsPerPage);\n    string line;\n    int currentColumn = 0;\n    int currentLines = 0;\n    int pageCount = 1;\n\n    cout << \"Page \" << pageCount << \":\" << endl;\n\n    while (getline(cin, line) && !line.empty()) {\n        vector<string> wrappedLines = splitLine(line, columnWidth);\n        \n        for (const string& wrappedLine : wrappedLines) {\n            columns[currentColumn].push_back(wrappedLine);\n            currentLines++;\n\n            if (currentLines == linesPerColumn) {\n                currentColumn++;\n                currentLines = 0;\n\n                if (currentColumn == columnsPerPage) {\n                    for (int col = 0; col < columnsPerPage; ++col) {\n                        for (int row = 0; row < linesPerColumn; ++row) {\n                            if (row < columns[col].size()) {\n                                cout << left << setw(columnWidth) << columns[col][row];\n                            } else {\n                                cout << left << setw(columnWidth) << string(columnWidth, '.');\n                            }\n                            \n                            if (col < columnsPerPage - 1) {\n                                cout << string(spaceBetweenColumns, ' ');\n                            }\n                        }\n                        cout << endl;\n                    }\n\n                    cout << string(totalWidth, '-') << endl;\n                    columns = vector<vector<string>>(columnsPerPage);\n                    currentColumn = 0;\n                    pageCount++;\n                    cout << \"Page \" << pageCount << \":\" << endl;\n                }\n            }\n        }\n    }\n\n    if (!columns[0].empty()) {\n        for (int col = 0; col < columnsPerPage; ++col) {\n            for (int row = 0; row < linesPerColumn; ++row) {\n                if (row < columns[col].size()) {\n                    cout << left << setw(columnWidth) << columns[col][row];\n                } else {\n                    cout << left << setw(columnWidth) << string(columnWidth, '.');\n                }\n                \n                if (col < columnsPerPage - 1) {\n                    cout << string(spaceBetweenColumns, ' ');\n                }\n            }\n            cout << endl;\n        }\n        cout << string(totalWidth, '-') << endl;\n    }\n}\n\nint main() {\n    int linesPerColumn, columnsPerPage, columnWidth, spaceBetweenColumns;\n\n    while (cin >> linesPerColumn >> columnsPerPage >> columnWidth >> spaceBetweenColumns) {\n        if (linesPerColumn == 0 && columnsPerPage == 0 && columnWidth == 0 && spaceBetweenColumns == 0) {\n            break;\n        }\n        \n        cin.ignore();\n        printList(linesPerColumn, columnsPerPage, columnWidth, spaceBetweenColumns);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ColumnFormatter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextInt()) {\n            int linesPerCol = scanner.nextInt();\n            int colsPerPage = scanner.nextInt();\n            int colWidth = scanner.nextInt();\n            int spacing = scanner.nextInt();\n            scanner.nextLine(); // consume newline\n\n            List<String> inputLines = new ArrayList<>();\n            while (true) {\n                String line = scanner.nextLine();\n                if (line.isEmpty()) {\n                    break;\n                }\n                inputLines.add(line);\n            }\n\n            processDataSet(linesPerCol, colsPerPage, colWidth, spacing, inputLines);\n            System.out.println();\n        }\n        scanner.close();\n    }\n\n    private static void processDataSet(int linesPerCol, int colsPerPage, int colWidth, int spacing, List<String> inputLines) {\n        int totalLines = inputLines.size();\n        int linesPerPage = linesPerCol * colsPerPage;\n        int totalPages = (totalLines + linesPerPage - 1) / linesPerPage;\n\n        for (int page = 0; page < totalPages; page++) {\n            int startLine = page * linesPerPage;\n            int endLine = Math.min(startLine + linesPerPage, totalLines);\n            List<String> pageLines = inputLines.subList(startLine, endLine);\n\n            for (int lineInCol = 0; lineInCol < linesPerCol; lineInCol++) {\n                for (int col = 0; col < colsPerPage; col++) {\n                    int lineIdx = lineInCol + col * linesPerCol;\n                    String line = lineIdx < pageLines.size() ? pageLines.get(lineIdx) : \"\";\n                    String formattedLine = formatLine(line, colWidth);\n                    System.out.print(formattedLine);\n                    if (col < colsPerPage - 1) {\n                        System.out.print(\" \".repeat(spacing));\n                    }\n                }\n                System.out.println();\n            }\n            System.out.println(\"#\");\n        }\n        System.out.println(\"=\");\n    }\n\n    private static String formatLine(String line, int colWidth) {\n        if (line.length() > colWidth) {\n            return line.substring(0, colWidth);\n        } else if (line.length() < colWidth) {\n            return line + \".\".repeat(colWidth - line.length());\n        } else {\n            return line;\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:05:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def format_text(lines_per_column, columns_per_page, column_width, spacing_width, text_lines):\n    from textwrap import wrap\n\n    page_delimiter = \"--- End of page ---\"\n    dataset_delimiter = \"+++ End of input data set +++\"\n    wrapped_text = []\n\n    for line in text_lines:\n        wrapped_text.extend(wrap(line, column_width))\n\n    output_lines = []\n    current_line = 0\n    num_lines = len(wrapped_text)\n\n    while current_line < num_lines:\n        for page in range(columns_per_page):\n            for line in range(lines_per_column):\n                line_index = current_line + (line * columns_per_page) + page\n                line_content = ''\n\n                if line_index < num_lines:\n                    line_content = wrapped_text[line_index].ljust(column_width, '.')\n\n                if page < columns_per_page - 1:\n                    line_content += ' ' * spacing_width\n\n                output_lines.append(line_content)\n\n            current_line += lines_per_column\n        \n        if (current_line // lines_per_column) % columns_per_page == 0 or current_line >= num_lines:\n            current_line += (lines_per_column * (columns_per_page - 1))\n            output_lines.append(page_delimiter)\n\n    output_lines.append(dataset_delimiter)\n    return '\\n'.join(output_lines)\n\n\ndef main():\n    import sys\n    input_data = sys.stdin.read().strip()\n    data_sets = input_data.split('\\n\\n')\n\n    results = []\n\n    for data in data_sets:\n        lines = data.splitlines()\n        parameters = list(map(int, lines[0].split()))\n        text_lines = lines[1:]\n        result = format_text(*parameters, text_lines)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:19:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class MultiColumnFormatter {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<DataSet> dataSets = new ArrayList<>();\n\n        while (scanner.hasNext()) {\n            int linesPerColumn = scanner.nextInt();\n            int columnsPerPage = scanner.nextInt();\n            int columnWidth = scanner.nextInt();\n            int columnSpacing = scanner.nextInt();\n            scanner.nextLine(); // Consume the newline character\n            List<String> lines = new ArrayList<>();\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                if (line.isEmpty()) {\n                    break;\n                }\n                lines.add(line);\n            }\n            dataSets.add(new DataSet(linesPerColumn, columnsPerPage, columnWidth, columnSpacing, lines));\n        }\n\n        for (DataSet dataSet : dataSets) {\n            dataSet.formatAndPrint();\n        }\n    }\n\n    static class DataSet {\n        int linesPerColumn;\n        int columnsPerPage;\n        int columnWidth;\n        int columnSpacing;\n        List<String> lines;\n\n        DataSet(int linesPerColumn, int columnsPerPage, int columnWidth, int columnSpacing, List<String> lines) {\n            this.linesPerColumn = linesPerColumn;\n            this.columnsPerPage = columnsPerPage;\n            this.columnWidth = columnWidth;\n            this.columnSpacing = columnSpacing;\n            this.lines = lines;\n        }\n\n        void formatAndPrint() {\n            List<String> formattedLines = new ArrayList<>();\n            for (String line : lines) {\n                formattedLines.addAll(wrapText(line, columnWidth));\n            }\n\n            int totalLines = formattedLines.size();\n            int pages = (int) Math.ceil((double) totalLines / (linesPerColumn * columnsPerPage));\n            int currentLineIndex = 0;\n\n            for (int page = 0; page < pages; page++) {\n                for (int column = 0; column < columnsPerPage; column++) {\n                    for (int line = 0; line < linesPerColumn; line++) {\n                        if (currentLineIndex < totalLines) {\n                            System.out.print(padLine(formattedLines.get(currentLineIndex), columnWidth));\n                            currentLineIndex++;\n                        } else {\n                            System.out.print(dotLine(columnWidth));\n                        }\n                        if (column < columnsPerPage - 1) {\n                            System.out.print(padLine(\"\", columnSpacing));\n                        }\n                    }\n                    if (column < columnsPerPage - 1 || column == columnsPerPage - 1 && page < pages - 1) {\n                        System.out.print(\"\\n\");\n                    }\n                }\n                System.out.println();\n                System.out.println(\"====\");\n            }\n            System.out.println(\"----\");\n        }\n\n        List<String> wrapText(String text, int width) {\n            List<String> wrappedLines = new ArrayList<>();\n            while (text.length() > width) {\n                int breakPoint = width;\n                while (breakPoint > 0 && text.charAt(breakPoint) != ' ') {\n                    breakPoint--;\n                }\n                if (breakPoint == 0) {\n                    breakPoint = width;\n                }\n                wrappedLines.add(text.substring(0, breakPoint).trim());\n                text = text.substring(breakPoint).trim();\n            }\n            if (!text.isEmpty()) {\n                wrappedLines.add(text);\n            }\n            return wrappedLines;\n        }\n\n        String padLine(String line, int width) {\n            return line + \" \".repeat(width - line.length());\n        }\n\n        String dotLine(int width) {\n            return \".\".repeat(width);\n        }\n    }\n}",
    "timestamp": "2025-08-13 02:19:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_TEXT_LENGTH 1000\n#define MAX_LINE_LENGTH 100\n\nvoid printDotLine(int width) {\n    for (int i = 0; i < width; i++) {\n        putchar('.');\n    }\n    putchar('\\n');\n}\n\nvoid processDataSet(int linesPerCol, int colsPerPage, int colWidth, int colSpacing) {\n    char text[MAX_TEXT_LENGTH][MAX_LINE_LENGTH];\n    int lineCount = 0;\n\n    while (lineCount < MAX_TEXT_LENGTH && fgets(text[lineCount], MAX_LINE_LENGTH, stdin) != NULL) {\n        if (text[lineCount][0] == '\\n') break;\n        text[lineCount][strcspn(text[lineCount], \"\\n\")] = 0; // Remove newline character\n        lineCount++;\n    }\n\n    int totalLinesPerPage = linesPerCol * colsPerPage;\n    int pages = (lineCount + totalLinesPerPage - 1) / totalLinesPerPage;\n    for (int page = 0; page < pages; page++) {\n        for (int line = 0; line < linesPerCol; line++) {\n            for (int col = 0; col < colsPerPage; col++) {\n                int idx = page * totalLinesPerPage + col * linesPerCol + line;\n                if (idx < lineCount) {\n                    printf(\"%-*.*s\", colWidth, colWidth, text[idx]);\n                } else {\n                    printDotLine(colWidth);\n                }\n                if (col < colsPerPage - 1) {\n                    for (int i = 0; i < colSpacing; i++) putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n        if (page < pages - 1) {\n            printf(\"--- End of Page ---\\n\");\n        }\n    }\n    printf(\"*** End of Data Set ***\\n\");\n}\n\nint main() {\n    int linesPerCol, colsPerPage, colWidth, colSpacing;\n\n    while (scanf(\"%d %d %d %d\", &linesPerCol, &colsPerPage, &colWidth, &colSpacing) == 4) {\n        getchar(); // Consume the newline character after the parameters\n        processDataSet(linesPerCol, colsPerPage, colWidth, colSpacing);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:19:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def format_text(lines_per_col, cols_per_page, col_width, spacing_width):\n    while True:\n        try:\n            params = list(map(int, input().split()))\n            if len(params) != 4:\n                break\n\n            lines_per_col, cols_per_page, col_width, spacing_width = params\n            lines = []\n            \n            while True:\n                line = input().strip()\n                if not line:\n                    break\n                lines.append(line)\n\n            if not lines:\n                break\n\n            page_count = 0\n            line_count = 0\n            col_count = 0\n            page_output = []\n            current_col = []\n\n            for line in lines:\n                # Split long lines\n                while line:\n                    if len(current_col) == lines_per_col:\n                        col_count += 1\n                        page_output.append(current_col)\n                        current_col = []\n\n                    if col_count == cols_per_page:\n                        # Print page\n                        for row in range(lines_per_col):\n                            row_output = []\n                            for col in page_output:\n                                if row < len(col):\n                                    formatted = col[row].ljust(col_width, '.')\n                                    row_output.append(formatted)\n                                else:\n                                    row_output.append(' ' * col_width)\n                            print(''.join(row_output))\n                        \n                        # Page delimiter\n                        print('-' * ((col_width + spacing_width) * cols_per_page - spacing_width))\n                        page_count += 1\n                        page_output = []\n                        col_count = 0\n\n                    # Add line to current column\n                    current_part = line[:col_width]\n                    current_col.append(current_part)\n                    line = line[col_width:]\n\n            # Handle remaining columns\n            while len(current_col) < lines_per_col:\n                current_col.append('')\n            \n            if current_col:\n                col_count += 1\n                page_output.append(current_col)\n\n            # Final page\n            if page_output:\n                while col_count < cols_per_page:\n                    page_output.append(['' for _ in range(lines_per_col)])\n                    col_count += 1\n\n                for row in range(lines_per_col):\n                    row_output = []\n                    for col in page_output:\n                        if row < len(col):\n                            formatted = col[row].ljust(col_width, '.')\n                            row_output.append(formatted)\n                        else:\n                            row_output.append(' ' * col_width)\n                    print(''.join(row_output))\n                \n                # Page delimiter\n                print('-' * ((col_width + spacing_width) * cols_per_page - spacing_width))\n\n            # Dataset delimiter\n            print('=' * ((col_width + spacing_width) * cols_per_page - spacing_width))\n\n        except EOFError:\n            break\n\n# Run the program\nformat_text()",
    "timestamp": "2025-08-13 02:19:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef process_dataset(lines_per_col, cols_per_page, col_width, spacing_width, text_lines):\n    total_lines = len(text_lines)\n    lines_per_page = lines_per_col * cols_per_page\n    total_pages = (total_lines + lines_per_page - 1) // lines_per_page\n    \n    for page in range(total_pages):\n        start_line = page * lines_per_page\n        end_line = min(start_line + lines_per_page, total_lines)\n        page_lines = text_lines[start_line:end_line]\n        \n        # Split into columns\n        for col_start in range(0, len(page_lines), lines_per_col):\n            col_lines = page_lines[col_start:col_start + lines_per_col]\n            for line in col_lines:\n                # Wrap long lines\n                wrapped = []\n                for i in range(0, len(line), col_width):\n                    part = line[i:i+col_width]\n                    if len(part) < col_width:\n                        part += '.' * (col_width - len(part))\n                    wrapped.append(part)\n                if not wrapped:\n                    wrapped.append('.' * col_width)\n                col_lines[col_lines.index(line)] = wrapped\n            \n            # Pad columns with empty lines if needed\n            max_lines = max(len(wrapped) for wrapped in col_lines) if col_lines else 0\n            for i in range(len(col_lines)):\n                wrapped = col_lines[i]\n                if len(wrapped) < max_lines:\n                    wrapped.extend(['.' * col_width] * (max_lines - len(wrapped)))\n        \n        # Print columns side by side\n        for line_group in zip(*[col_lines[i::lines_per_col] for i in range(lines_per_col)]):\n            for col in line_group:\n                for wrapped_line in col:\n                    print(wrapped_line, end=' ' * spacing_width)\n            print()\n        \n        print('#' * ((col_width + spacing_width) * cols_per_page - spacing_width))\n    \n    print('*' * ((col_width + spacing_width) * cols_per_page - spacing_width))\n\ndef main():\n    while True:\n        header = sys.stdin.readline().strip()\n        if not header:\n            break\n        lines_per_col, cols_per_page, col_width, spacing_width = map(int, header.split())\n        text_lines = []\n        while True:\n            line = sys.stdin.readline().strip()\n            if line == '':\n                break\n            text_lines.append(line)\n        process_dataset(lines_per_col, cols_per_page, col_width, spacing_width, text_lines)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:20:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n\nvoid printPage(const std::vector<std::vector<std::string>>& page, int columns, int linesPerColumn, int width, int spacing) {\n    for (int line = 0; line < linesPerColumn; ++line) {\n        for (int col = 0; col < columns; ++col) {\n            if (col < page.size() && line < page[col].size()) {\n                std::cout << std::setw(width) << std::left << page[col][line];\n            } else {\n                std::cout << std::setw(width) << std::left << std::string(width, '.');\n            }\n            if (col < columns - 1) std::cout << std::setw(spacing) << std::left << \" \";\n        }\n        std::cout << std::endl;\n    }\n    std::cout << \"End of Page\" << std::endl;\n}\n\nvoid processText(const std::vector<std::string>& text, int linesPerColumn, int columnsPerPage, int columnWidth, int spacing) {\n    size_t textIndex = 0;\n    std::vector<std::vector<std::string>> page;\n    std::vector<std::string> currentColumn;\n\n    while (textIndex < text.size()) {\n        currentColumn.clear();\n        for (int i = 0; i < linesPerColumn && textIndex < text.size(); ++i) {\n            std::ostringstream wrappedLine;\n            size_t pos = 0;\n            while (pos < text[textIndex].size()) {\n                wrappedLine << text[textIndex].substr(pos, columnWidth);\n                pos += columnWidth;\n                if (pos < text[textIndex].size() || text[textIndex].size() % columnWidth == 0)\n                    wrappedLine << \"\\n\";\n            }\n            std::istringstream wrappedStream(wrappedLine.str());\n            std::string segment;\n            while (std::getline(wrappedStream, segment)) {\n                currentColumn.push_back(segment);\n                if (currentColumn.size() == linesPerColumn) break;\n            }\n            ++textIndex;\n            if (currentColumn.size() == linesPerColumn) break;\n        }\n\n        page.push_back(currentColumn);\n        if (page.size() == columnsPerPage) {\n            printPage(page, columnsPerPage, linesPerColumn, columnWidth, spacing);\n            page.clear();\n        }\n    }\n\n    if (!page.empty()) {\n        printPage(page, columnsPerPage, linesPerColumn, columnWidth, spacing);\n    }\n\n    std::cout << \"End of Data Set\" << std::endl;\n}\n\nint main() {\n    int linesPerColumn, columnsPerPage, columnWidth, spacing;\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        std::istringstream configStream(line);\n        if (!(configStream >> linesPerColumn >> columnsPerPage >> columnWidth >> spacing)) break;\n\n        std::vector<std::string> text;\n        while (std::getline(std::cin, line) && !line.empty()) {\n            text.push_back(line);\n        }\n\n        processText(text, linesPerColumn, columnsPerPage, columnWidth, spacing);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:05:22"
  }
]