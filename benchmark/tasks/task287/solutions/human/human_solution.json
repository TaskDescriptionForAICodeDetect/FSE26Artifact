[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n  val target = \"01+-*()=\"\n  val exp = readLine.trim.toList\n  val symbol = if (exp.contains('=')) target.filterNot(_ == '=') else target\n  val suspects = exp.filter(_.isLetter).distinct\n  var result = 0\n  for (usage ← symbol.combinations(suspects.length)){\n    for (map ← usage.permutations.map{u ⇒ suspects.zip(u).toMap.withDefault(c ⇒ c)}){\n      exp.map(map) match {\n        case Q() ⇒ result += 1\n        case _ ⇒\n      }\n    }\n  }\n  println(result)\n\n  object Q{\n    def unapply(arg: List[Char]): Boolean = {\n      arg match {\n        case l E '='::(r E Nil) ⇒ l == r\n        case _ ⇒ false\n      }\n    }\n  }\n  object E{\n    def unapply(arg: List[Char]): Option[(Int, List[Char])] = {\n      arg match {\n        case l T t ⇒ Some(takeAll(t, l))\n        case _ ⇒ None\n      }\n    }\n    @tailrec\n    private[this] def takeAll(arg: List[Char], left: Int): (Int, List[Char]) = {\n      arg match {\n        case '-'::(r T t) ⇒ takeAll(t, left - r)\n        case '+'::(r T t) ⇒ takeAll(t, left + r)\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n  object T{\n    def unapply(arg: List[Char]): Option[(Int, List[Char])] = {\n      arg match {\n        case l F t ⇒ Some(takeAll(t, l))\n        case _ ⇒ None\n      }\n    }\n    @tailrec\n    private[this] def takeAll(arg: List[Char], left: Int): (Int, List[Char]) = {\n      arg match {\n        case '*'::(r F t) ⇒ takeAll(t, left * r)\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n  object F{\n    def unapply(arg: List[Char]): Option[(Int, List[Char])] = {\n      arg match {\n        case n N t ⇒ Some(n, t)\n        case '-'::(f F t) ⇒ Some(-f, t)\n        case '('::(e E ')'::t) ⇒ Some(e, t)\n        case _ ⇒ None\n      }\n    }\n  }\n  object N{\n    def unapply(arg: List[Char]): Option[(Int, List[Char])] = {\n      arg.span(_.isDigit) match {\n        case ('0'::Nil, t) ⇒ Some(0, t)\n        case (n@'1'::_, t) ⇒ Some(n.foldLeft(0){(a, b) ⇒ a * 2 + b.asDigit}, t)\n        case _ ⇒ None\n      }\n    }\n  }\n  implicit class Extension[T](val value :T) extends AnyVal {\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nbool err;\n\nstring e;\n\nll N(int l, int r);\nll F(int l, int r);\nll T(int l, int r);\nll E(int l, int r);\n\nll N(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    ll ret = 0;\n    for(int i=l; i<=r; ++i){\n        if(e[i]=='0' || e[i]=='1') ret = ret*2 + e[i]-'0';\n        else{\n            err = true;\n            return 0;\n        }\n    }\n\n    if(e[l]=='0'){\n        if(l!=r) err = true;\n    }\n    return ret;\n}\n\nll F(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    if(e[l]=='('){\n        if(e[r]!=')') err = true;\n        return E(l+1,r-1);\n    }\n    else if(e[l]=='-'){\n        return -F(l+1,r);\n    }\n    else return N(l,r);\n}\n\nll T(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    int b = 0;\n\n    int a_pos = -1;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='*'){\n            if(b==0){\n                a_pos = i;\n                break;\n            }\n        }\n    }\n\n    if(a_pos == -1) return F(l,r);\n    else return T(l,a_pos-1)*F(a_pos+1,r);\n}\n\nll E(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    char op = '?';\n    int o_pos = -1;\n    int b = 0;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='+' && b==0){\n            o_pos = i;\n            op = '+';\n            break;\n        }\n\n        if(e[i]=='-' && b==0){\n            o_pos = i;\n            while(l<=o_pos && e[o_pos]=='-') --o_pos;\n\n            if(o_pos<l){\n                op = '?';\n                break;\n            }\n            else{\n                if(e[o_pos] == '+'){\n                    op = '+';\n                    break;\n                }\n                else if(e[o_pos] == '*') continue;\n                else{\n                    ++o_pos;\n                    op = '-';\n                    break;\n                }\n            }\n        }\n    }\n\n    if(op=='?') return T(l,r);\n    else if(op=='+') return E(l,o_pos-1)+T(o_pos+1,r);\n    else return E(l,o_pos-1)-T(o_pos+1,r);\n}\n\nbool Q(int l, int r){\n    int eq_pos = 0;\n    for(int i=l; i<=r; ++i){\n        if(e[i]=='=') eq_pos = i;\n    }\n\n    err = false;\n    ll L = E(l,eq_pos-1);\n    ll R = E(eq_pos+1,r);\n    return L==R;\n}\n\nint main(){\n    string s;\n    cin >>s;\n    int n = s.size();\n\n    set<char> a;\n    for(char c:s){\n        if(islower(c)||isupper(c)) a.insert(c);\n    }\n\n    if(a.size()>8){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    string x = \"01+-*()=\";\n    sort(all(x));\n\n    set<string> valid;\n    set<string> check;\n    do{\n        auto itr = x.begin();\n        map<char,char> cv;\n        for(char c:a){\n            cv[c] = *itr;\n            ++itr;\n        }\n\n        string t = s;\n        rep(i,n)if(cv.count(t[i])) t[i]=cv[t[i]];\n\n        int eq = 0;\n        rep(i,n) eq += (t[i]=='=');\n        if(eq!=1) continue;\n\n        e = t;\n        bool res = Q(0,e.size()-1);\n\n        if(!err && res) valid.insert(t);\n        if(!err) check.insert(t);\n    }while(next_permutation(all(x)));\n\n    // for(string V:valid) dbg(V);\n    // for(string C:check) dbg(C);\n    cout << valid.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <functional>\n#include <iostream>\n#include <set>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\n\n#define SIZE 500010\n#define INF 1000000000\n\nint term(char* &s);\nint number(char* &s);\nint factor(char* &s);\nint expr(char* &s);\n\nint term(char* &s){\n  int res = factor(s), r;\n  if(res == -INF) return res;\n  while(1){\n    if(*s == '*'){\n      r = factor(++s);\n      if(r == -INF) return r;\n      res *= r;\n    }else{\n      break;\n    }\n  }\n  return res;\n}\n\nint number(char* &s){\n  int res = 0;\n\n  if(!(*s)) return -INF;\n  \n  if(!('0' <= *s && *s <= '1')) return -INF;\n\n  if(*s == '0' && (*(s+1) == '0' || *(s+1) == '1')) return -INF;\n  \n  while('0' <= *s && *s <= '1')\n    res = res*2 + (*s++ - '0');\n\n  return res;\n}\n\n\nint factor(char* &s){\n  if(*s == ')') return -INF;\n  \n  if(*s == '-'){\n    int r = factor(++s);\n    if(r == -INF) return r;\n    return r * -1;\n  }\n  if(*s != '(') return number(s);\n  \n  int res = expr(++s);\n  if(*s != ')') return -INF;\n  s++;\n  return res;\n}\n\nint expr(char* &s) {\n  int res = term(s), r;\n  if(res == -INF) return res;\n  while(1){\n    if(*s == '+'){\n      r = term(++s);\n      if(r == -INF) return r;\n      res += r;\n    }else if(*s == '-'){\n      r = term(++s);\n      if(r == -INF) return r;\n      res -= r;\n    }else{\n      if(*s == '(') return -INF;\n      break;\n    }\n  }\n  return res;\n}\n\nbool check(char *s){\n  int counter = 0;\n  while(*s){\n    counter += (*s == '(') - (*s == ')');\n    if(counter < 0) return false;\n    s++;\n    if(*s == ')' && (*(s+1) == '1' || *(s+1) == '0')) return false;\n  }\n  return counter == 0;\n}\n\nbool isop(char x){\n  return x == '*' || x == '-' || x == '+' || x == '=' ||\n    x == '(' || x == ')' || x == '0' || x == '1';\n}\n\nint main(){\n  char s[50];\n  vector<char> vec;\n  map<char,int> dic;\n  \n  scanf(\"%s\", s);\n\n  for(int i=0;s[i];i++){\n    if(!isop(s[i]))\n      vec.push_back(s[i]);\n  }\n\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n  //for(int i=0;i<vec.size();i++) cerr << vec[i] << endl;\n  \n  if(vec.size() > 8){\n    puts(\"0\");\n    return 0;\n  }\n\n  for(int i=0;i<vec.size();i++) dic[vec[i]] = i;\n\n  char op[] = \"01+-*()=\";\n  sort(op, op+8);\n\n  int n = strlen(s);\n  int ans = 0;\n  \n  char d[50];\n  d[n] = '\\0';\n\n  set<string> ss;\n  \n  do{\n    string r = op;\n    r = r.substr(0, vec.size());\n    if(ss.find(r) != ss.end()) continue;\n    ss.insert(r);\n    \n    int eq = -1;\n    \n    for(int i=0;s[i];i++){\n      if(isop(s[i])) d[i] = s[i];\n      else d[i] = op[dic[s[i]]];\n\n      if(d[i] == '='){\n        if(eq == -1) eq = i;\n        else eq = -2;\n      }\n    }\n    \n    if(eq < 0 || eq == 0 || eq == n-1) continue;\n    d[eq] = '\\0';\n    \n    char *p = d, *q = d + eq + 1;\n    if(!check(p) || !check(q)) continue;\n    \n    int res1 = expr(p);\n    int res2 = expr(q);\n\n    //if(res1 != -INF) cerr << d << endl;\n    //if(res2 != -INF) cerr << d + eq + 1 << endl;\n    \n    if(res1 != -INF && res1 == res2){\n      ans++;\n      d[eq] = '=';\n    }\n  }while(next_permutation(op, op+8));\n \n  printf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    \n    //if(p<s.size()&&(s[p]=='*'||s[p]=='+')) flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    \n    return r;\n  }\n  \n  int res=0,minu=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n    \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(minu%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;    if(s[p]=='*'||s[p]=='+') flag=1;\n      \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n    \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    \n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n    \n  }while(next_permutation(idx,idx+8));\n  \n}\n\n\nmain(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ret_type = double;\nconstexpr ret_type eps = 1e-8;\n\nret_type expr(string const& s, int& p);\nret_type term(string const& s, int& p);\nret_type factor(string const& s, int& p);\nret_type number(string const& s, int& p);\n\nret_type expr(string const& s, int& p) {\n    ret_type val = term(s, p);\n    while(p < (int)s.size() && (s[p] == '+' || s[p] == '-')) {\n        if(s[p] == '-') {\n            val -= term(s, ++p);\n        } else {\n            val += term(s, ++p);\n        }\n    }\n    return val;\n}\n\nret_type term(string const& s, int& p) {\n    ret_type val = factor(s, p);\n    while(p < (int)s.size() && s[p] == '*') {\n        val *= factor(s, ++p);\n    }\n    return val;\n}\n\nret_type factor(string const& s, int& p) {\n    if(s[p] == '-') {\n        return -factor(s, ++p);\n    } else if(s[p] == '(') {\n        ret_type res = expr(s, ++p);\n        if(p >= (int)s.size() || s[p] != ')') throw std::logic_error(\"\");\n        ++p;\n        return res;\n    } else if(isdigit(s[p])) {\n        return number(s, p);\n    } else {\n        throw std::logic_error(\"\");\n    }\n}\n\nret_type number(string const& s, int& p) {\n    if(s[p] != '0' && s[p] != '1') throw std::logic_error(\"\");\n    if(p + 1 < (int)s.size() && s[p] == '0' && isdigit(s[p + 1])) throw std::logic_error(\"\");\n\n    ret_type res = 0;\n    while(p < (int)s.size() && isdigit(s[p])) {\n        res *= 2;\n        res += (s[p++] == '1');\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    const int n = s.size();\n    vector<char> cs;\n    for(auto c : s) {\n        if(isalpha(c)) {\n            cs.push_back(c);\n        }\n    }\n    sort(begin(cs), end(cs));\n    cs.erase(unique(begin(cs), end(cs)), end(cs));\n\n    vector<char> v = {'0', '1', '+', '-', '*', '=', '(', ')'};\n    sort(begin(v), end(v));\n\n    if(cs.size() > v.size()) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int ans = 0;\n    set<string> checked;\n    do {\n        string t;\n        for(auto c : s) {\n            if(isalpha(c)) {\n                t += v[find(begin(cs), end(cs), c) - begin(cs)];\n            } else {\n                t += c;\n            }\n        }\n        if(count(begin(t), end(t), '=') != 1) continue;\n        int lp = 0, rp = find(begin(t), end(t), '=') - begin(t) + 1;\n        if(rp == 1 || rp == n || checked.count(t) == 1) continue;\n\n        checked.insert(t);\n\n        try {\n            auto lval = expr(t, lp), rval = expr(t, rp);\n            if(t[lp] == '=' && rp == n && abs(lval - rval) < eps) {\n                ans += 1;\n            }\n        } catch(...) {\n            continue;\n        }\n    } while(next_permutation(begin(v), end(v)));\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 20) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n//#define INF 2147483600\n#define INF 214748360000000\n#define int long long\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  if(str[now+1]=='+'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t+p;\n  }\n  if(str[now+1]=='-'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t-p;\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size() + mm.size()>8 || m.size() + mm.size() <2){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do { //next_permutation moji\n    bool flg=true;\n\n    string newstr(s);\n    int idx=0;\n    if(flg){\n      for(auto c : m){\n        // str?????????c???moji[idx]???????????????\n        rep(i, newstr.size()) if(newstr[i]==c){\n          newstr[i] = moji[idx];\n        }\n        idx++;\n      }\n    }\n    idx = newstr.find('=');\n    if(newstr[0]=='=' || idx<0) flg=false;\n\n    if(flg){\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nstring s;\n\nint expr(int &i);\nint term(int &i);\nint factor(int &i);\nint number(int &i);\n\nint expr(int &i) {\n  int val = term(i);\n  while (true) {\n    if (s[i] == '+') {\n      val += term(++i);\n    } else if (s[i] == '-') {\n      val -= term(++i);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(int &i) {\n  int val = factor(i);\n  while (true) {\n    if (s[i] == '*') {\n      val *= factor(++i);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(int &i) {\n  if (s[i] == '-') {\n    return -factor(++i);\n  } else if (s[i] == '(') {\n    int val = expr(++i);\n    if (s[i] != ')') throw \"no right paren\";\n    ++i;\n    return val;\n  }\n  return number(i);\n}\n\nint number(int &i) {\n  if (not(s[i] == '0' || s[i] == '1')) throw \"not 0 or 1\";\n  if (i + 1 < s.size() && s[i] == '0' && isdigit(s[i + 1])) throw \"leading zero\";\n\n  int val = 0;\n  while (isdigit(s[i])) {\n    val <<= 1;\n    val += s[i++] - '0';\n  }\n  return val;\n}\n\nmain() {\n  string S;\n  cin >> S;\n  vector<char> cs;\n  for (auto &c : S) {\n    if (isalpha(c)) cs.emplace_back(c);\n  }\n  sort(all(cs));\n  cs.erase(unique(all(cs)), end(cs));\n  string v = \"01+-*=()\";\n  sort(all(v));\n  if (v.size() < cs.size()) return cout << 0 << endl, 0;\n  map<char, int> m;\n  {\n    int k = 0;\n    for (auto &c : S) {\n      if (isalpha(c) && not m.count(c)) m[c] = k++;\n    }\n  }\n  set<string> done;\n  int cnt = 0;\n  do {\n    s.clear();\n    for (auto &c : S) s += isalpha(c) ? v[m[c]] : c;\n    if (done.count(s)) continue;\n    if (count(all(s), '=') != 1) continue;\n    int l = 0, r = s.find('=') + 1, n = s.size();\n    if (r == 1 || r == n) continue;\n    done.emplace(s);\n    try {\n      int lhs = expr(l), rhs = expr(r);\n      cnt += s[l] == '=' && r == n && lhs == rhs;\n    } catch (...) {}\n  } while (next_permutation(all(v)));\n  cout << cnt << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  if(s[p]==')') flag=1;\n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n\n    return r;\n  }\n  \n  int res=0,min=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    while(s[p]=='-') min++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(min%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(min%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')') flag=1;\n      \n      int r=bnf3();\n\n      res*=r;\n\n      \n    }else{\n      break;\n    }\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;\n      \n    }\n    \n    else if(s[p]=='-'){\n\n      p++;\n      \n      if(s[p]==')') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else{\n\n      break;\n      \n    }\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n\n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2) ans++;\n    \n  }while(next_permutation(idx,idx+8));\n\n  \n}\n\n\nint main(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren++;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\t//cout << tmp << endl;\n\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\t//cout << lhs << \" \" << rhs << endl;\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\t/*\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tstring d = \"1*-1\";\n\tcout << \"xo\"[isE(d, m, d.begin(), d.end())] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1-11010=(10110)-10\", m)] << endl;\n\tcout << \"xo\"[isQ(\"--1001=1001\", m)] << endl;\n\tcout << \"xo\"[check(\"--1001=1001\", m)] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m)) {\n\t\t\t/*\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t\t//*/\n\t\t\tif (check(str, m)) {\n\t\t\t\t//cout << \"=======================\" << endl;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define int long long\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\t//cout << res1.second << \" \" << res2.second << endl;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tif (s[i] == '-') {\n\t\t\t\t\twhile (i >= 0 && s[i] == '-') i--;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t\treturn P(false, 0);\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nsigned main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n \nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n \nint bnf();\n \nint bnf3(){\n   \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n   \n  if(s[p]=='('){\n     \n    p++;\n    if(p<s.size()&&(s[p]=='*'||s[p]=='+')) flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n     \n    int r=bnf();\n     \n    if(p>=s.size()||s[p]!=')') flag=1;\n     \n    p++;\n     \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    return r;\n  }\n   \n  int res=0,minu=0;\n \n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n   \n  if(s[p]=='-'){\n     \n    while(s[p]=='-') minu++,p++;\n    \n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      p++;\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n     \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n   \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n   \n  if(s[p]=='(') flag=1;\n   \n  if(minu%2) res*=-1;\n   \n  return res;\n}\n \nint bnf2(){\n \n  int res=bnf3();\n \n  while(p<s.size()){\n \n    if(s[p]=='*'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf3();\n       \n      res*=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nint bnf(){\n \n  int res=bnf2();\n \n  while(p<s.size()){\n \n    if(s[p]=='+'){\n \n      p++;\n       \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n       \n      int r=bnf2();\n \n      res+=r;\n       \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf2();\n \n      res-=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nvoid check(){\n   \n  int cnt=0;\n   \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n \n      if(cnt==0){\n    flag=1;\n    return ;\n      }\n      else cnt--;\n    }\n  }\n \n  if(cnt) flag=1;\n}\n \nset<string> me;\n \nvoid solve(){\n   \n  set<char> S;\n   \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n \n  set<char>::iterator ite=S.begin();\n \n  vector<char> al;\n   \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n   \n  if(al.size()>8){\n    cout<<0<<endl;\n    exit(0);\n  }\n   \n  int idx[8];\n \n  for(int i=0;i<8;i++) idx[i]=i;\n   \n  do{\n     \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n \n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n     \n    if(me.count(s)) continue;\n    me.insert(s);\n     \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n     \n    string s1,s2;\n     \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n \n    int f=0;\n \n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n     \n    flag=0;\n    s=s1;\n    p=0;\n\n    int r1=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n     \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n \n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n     \n  }while(next_permutation(idx,idx+8));\n   \n}\n \n \nmain(){\n \n  cin>>s;\n  str=s;\n   \n  solve();\n \n  cout<<ans<<endl;\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  if(s[p]==')') flag=1;\n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n\n    return r;\n  }\n  \n  int res=0,min=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    while(s[p]=='-') min++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(min%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(min%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n\n      res*=r;\n\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;\n      \n    }\n    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n\n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2) ans++;\n    \n  }while(next_permutation(idx,idx+8));\n\n  \n}\n\n\nint main(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\n\npair<int, int> isE(const std::string &s, int start, int end);\n\npair<int,int> isB(const std::string &s, int start) {\n  // cout << \"isB \" << s << \" \" << start << endl;\n  pair<int, int> p;\n  int x = 0;\n  if (s[start] != '0' && s[start] != '1') {\n    return make_pair(-1, -1);\n  }\n  if (s[start] == '0') {\n    return make_pair(0, start + 1);\n  }\n\n  while (start < s.length() && (s[start] == '0' || s[start] == '1')) {\n    x = x << 1;\n    x += s[start] - '0';\n    start++;\n  }\n  return make_pair(x, start);\n}\n\npair<int, int> isF(const std::string &s, int start, int end) {\n  // cout << \"isF \" << s << \" \" << start << \" \" << end << endl;\n  if (start >= end) return make_pair(-1, -1);\n  if (s[start] == '(') {\n    if (s[end - 1] != ')') return make_pair(-1, -1);\n    pair<int, int> p = isE(s, start + 1, end - 1);\n    if (p.second == -1) return p;\n    return make_pair(p.first, p.second + 1);\n  }\n\n  if (s[start] == '-') {\n    pair<int, int> p = isF(s, start + 1, end);\n    // cout << \"isF return from - \" << p.first << \", \" << p.second << endl;\n    if (p.second == -1) return p;\n    if (p.second != end) return make_pair(-1, -1);\n    p.first *= -1;\n    return p;\n  }\n  pair<int, int> p = isB(s, start);\n  // cout << \"isF last \" << s << start << \" \" << end << \" \" << p.first << \",\" << p.second << \" \" << end << endl;\n  if (p.second == end) return p;\n  // cout << \"isF last \" << s << start << \" \" << end << \" \" << p.first << \",\" << p.second << \" \" << end << endl;\n  return make_pair(-1, -1);\n}\n\npair<int, int> isT(const std::string &s, int start, int end) {\n  for (int i = end - 1; i > start; --i) {\n    if (s[i] == '*') {\n      pair<int, int> p = isF(s, i+1, end);\n      if (p.second == -1) continue;\n      pair<int, int> q = isT(s, start, i);\n      if (q.second == -1) continue;\n      return make_pair(p.first * q.first, end);\n    }\n  }\n  pair<int, int> p = isF(s, start, end);\n  // cout << \"last isT \" << s << \" \" << start << \" \" << p.first << \" \" << p.second << endl;\n  return p;\n}\n\npair<int, int> isE(const std::string &s, int start, int end) {\n  if (start >= end) return make_pair(-1, -1);\n  for (int i = end - 1; i > start; --i) {\n    if (s[i] == '+' || s[i] == '-') {\n      pair<int, int> p = isT(s, i + 1, end);\n      if (p.second == -1) continue;\n      pair<int, int> q = isE(s, start, i);\n      if (q.second == -1) continue;\n      if (s[i] == '+') {\n        return make_pair(p.first + q.first, end);\n      }\n      if (s[i] == '-') {\n        return make_pair(q.first - p.first, end);\n      }\n    }\n  }\n  pair<int, int> p = isT(s, start, end);\n  // cout << \"last isE \" << s << \" \" << start << \" \" << p.first << \" \" << p.second << endl;\n  return p;\n}\n\nbool isQ(const std::string &s) {\n  int idx = -1;\n  for (int i = 1; i < s.length() - 1; ++i) {\n    if (s[i] == '=') {\n      idx = i;\n      break;\n    }\n  }\n  if (idx == -1) return false;\n\n  pair<int, int> p = isE(s, 0, idx);\n  if (p.second == -1 || s[p.second] != '=') return false;\n  // cout << \"isQ after p before q\" << endl;\n  pair<int, int> q = isE(s, p.second+1, s.length());\n  // cout << \"isQ last before \" << q.first << \", \" << q.first << \": \" << s << endl;\n  if (q.second == -1) return false;\n  // cout << \"isQ last \" << p.first << \", \" << q.first << \": \" << s << endl;\n  return p.first == q.first;\n}\n\nbool check(const std::string &s) {\n  return isQ(s);\n}\n\nint main() {\n  string s;\n  cin >> s;\n\n  std::vector<char> ops = {'=', '+', '-', '*', '(', ')', '0', '1'};\n  sort(ops.begin(), ops.end());\n\n  std::set<char> chars;\n  for (int i = 0; i < s.length(); ++i) {\n    if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n      chars.insert(s[i]);\n    }\n  }\n  std::vector<char> abc;\n  for (const char c : chars) abc.push_back(c);\n  if (abc.size() > ops.size()) {\n    cout << \"0\" << endl;\n    return 0;\n  }\n\n  std::map<char, char> m;\n  for (int i = 0; i < ops.size(); ++i) m[ops[i]] = ops[i];\n\n  std::set<string> ans;\n  do {\n    for (int i = 0; i < abc.size(); ++i) m[abc[i]] = ops[i];\n    string ss = s;\n    for (int i = 0; i < s.length(); ++i) ss[i] = m[s[i]];\n    if (check(ss)) {\n      ans.insert(ss);\n    }\n  } while (next_permutation(ops.begin(), ops.end()));\n  cout << ans.size() << endl;\n  // for (const std::string &s : ans) {\n  //   cout << s << endl;\n  // }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nbool flag;\n\nint B(string &s, int &n){\n\tint ret = 1;\n\twhile(1){\n\t\tif( s.size() <= n ){ break; }\n\t\telse if( s[n] == '0' ){ n++; ret<<=1; }\n\t\telse if( s[n] == '1' ){ n++; ret<<=1; ret += 1; }\n\t\telse { break; }\n\t}\n\t//cout << \"B \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint N(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\telse if( s[n] == '0' ){ n++; return 0; }\n\telse if( s[n] == '1' ){ n++; return B(s, n); }\n\tflag = false;\n\t//cout << \"flag N\" << endl;\n\treturn 0;\n}\n\nint E(string &s, int &n);\nint F(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\tint ret;\n\tif( s[n] == '0' || s[n] == '1' ){ ret = N(s, n); }\n\telse if( s[n] == '-' ){ n++; ret = -F(s, n); }\n\telse if( s[n] == '(' ){\n\t\tn++;\n\t\tret = E(s, n);\n\t\tif( s[n] == ')' ) n++;\n\t\telse flag = false;\n\t} else {\n\t\t//cout << \"flag F\" << endl;\n\t\tflag = false;\n\t}\n\t//cout << \"F \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint T(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\tint ret = F(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '*' ){ n++; ret *= T(s, n); }\n\t//cout << \"T \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint E(string &s, int &n){\n\tint ret = T(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '+' ){ n++; ret += E(s, n); }\n\telse if( s[n] == '-' ){ n++; ret -= E(s, n); }\n\t//cout << \"E \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nbool Q(string &s){\n\tflag = true;\n\tint n=0;\n\tint l = E(s,n);\n\tif( s.size() <= n ) return false;\n\t//cout << \"l = \" << l << endl;\n\tif( s[n] != '=' ) return false;\n\t//cout << \"n++\" << endl;\n\tn++;\n\tif( s.size() <= n ) return false;\n\tint r = E(s,n);\n\t//cout << \"r = \" << r << endl;\n\tif( s.size() != n ) flag = false;\n\treturn flag && l == r;\n}\n\nvector<char> ope = {'0', '1', '+', '-', '*', '(', ')', '='};\nint main(){\n\tset<string> ans;\n\tstring S;\n\tcin >> S;\n\t\n\t//cout << Q(S) << endl;\n\t//return 0;\n\t\n\tvector<char> v;\n\tfor(char c: S){\n\t\tif( 'A' <= c && c <= 'Z' ) v.push_back(c);\n\t\tif( 'a' <= c && c <= 'z' ) v.push_back(c);\n\t}\n\tv.erase( unique(all(v)), v.end() );\n\tif( v.size() > 8 ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tsort( all(ope) );\n\tdo{\n\t\tchar mp[256]={};\n\t\trep(i,v.size()) mp[v[i]] = ope[i];\n\t\tstring s;\n\t\tfor(char c: S) s += (mp[c] ? mp[c] : c);\n\t\t//cout << s << endl;\n\t\tif( Q(s) ) ans.insert(s);\n\t}while( next_permutation(all(ope)) );\n\n\t//for(auto p: ans) cout << p << endl;\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define int long long\nint n;\nint m;\nstring a;\n        \n\nvector<char> ch={'0','1','+','-','*','=','(',')'};\nset<char> stch={'0','1','+','-','*','=','(',')'}; \n\n\nbool subcheck(int l,int r){\n    if(l>r)return false;\n    if(l==r){\n        if(a[l]=='0'){\n            return true;\n        }\n        if(a[l]=='1'){\n            return true;\n        }\n        return false;\n    }\n    int dep=0;\n    for(int i=l;i<=r;i++){\n        if(a[i]=='('){\n            dep++;\n        }else if(a[i]==')'){\n            dep--;\n        }\n        if(dep<0)return false;\n    }\n    if(dep!=0)return false;\n    if(a[l]=='0'){\n        if(a[l+1]=='('){\n            return false;\n        }\n        if(a[l+1]==')'){\n            return false;\n        }\n        if(a[l+1]=='1'){\n            return false;\n        }\n        if(a[l+1]=='0'){\n            return false;\n        }\n        return subcheck(l+2,r);\n    }else if(a[l]=='1'){\n        int x =-1;\n        for(int i=l+1;i<=r;i++){\n            if(!isdigit(a[i])){\n                x = i;\n                break;\n            }\n        }\n        if(x==-1)return true;\n        if(a[x]=='('){\n            return false;\n        }\n        if(a[x]==')'){\n            return false;\n        }\n        return subcheck(x+1,r);\n    }else if(a[l]=='-'){\n        return subcheck(l+1,r);\n    }else if(a[l]=='('){\n        for(int i=l;i<=r;i++){\n            if(a[i]=='('){\n                dep++;\n            }else if(a[i]==')'){\n                dep--;\n            }\n            if(dep==0){\n                if(i==r){\n                    return subcheck(l+1,r-1);\n                }else{\n                    if(a[i+1]=='+'||a[i+1]=='-'||a[i+1]=='*'){\n                        return subcheck(l+1,i-1)&&subcheck(i+2,r);\n                    }else{\n                        return false;\n                    }\n                }\n            }\n        }\n    }else{\n        return false;\n    }\n\n}\n\nbool check(){\n    int cc = 0;\n    int pl = 0;\n    rep(i,a.size()){\n        if(a[i]=='='){\n            cc++;\n            pl = i;\n        }\n    }\n    if(cc!=1)return false;\n    return (subcheck(0,pl-1)&&subcheck(pl+1,n-1));\n}\n\nint calc(int l,int r);\nint calc2(int l,int r);\n\nint calc3(int l,int r){\n    int cnt =0;\n    int x =-1;\n    for(int i=l;i<=r;i++){\n        if(a[i]=='-'){\n            cnt++;\n        }else{\n            x = i;\n            break;\n        }\n    }\n    if(isdigit(a[x])){\n        int tmp = 0;\n        for(int i=x;i<=r;i++){\n            tmp *= 2;\n            tmp += a[i]-'0';\n        }\n        // cerr << cnt << endl;\n        //  cerr <<l << \"     \"<< x << \"       \" << r << endl;\n        // cerr << a.substr(l,2) << \" \" <<tmp << endl;\n        if(cnt%2==0){\n            return tmp;\n        }else{\n            return -tmp;\n        }\n    }else{\n        if(cnt%2==0){\n            return calc(x+1,r-1);\n        }else{\n            return -calc(x+1,r-1);\n        }   \n    }\n}\n\nint calc2(int l,int r){\n    int dep =0;\n    int tmp = 1;\n    int prel =l;\n    for(int i=l;i<=r;i++){\n        if(a[i]=='('){\n            dep++;\n        }else if(a[i]==')'){\n            dep--;\n        }\n        if(dep==0&&a[i]=='*'){\n            tmp *= calc3(prel,i-1);\n            prel=i+1;\n        }\n    }\n    tmp *= calc3(prel,r);\n    return tmp;\n}\n\nint calc(int l,int r){\n    if(l==r){\n        if(a[l]=='0'){\n            return 0;\n        }\n        if(a[l]=='1'){\n            return 1;\n        }\n    }\n    int dep=0;\n    int cnt=0;\n    int prel= l;\n    bool minusflag =0;\n    int tmp =0;\n    for(int i=l;i<=r;i++){\n        if(dep==0){\n            if(a[i]=='('){\n                cnt++;\n            }\n            if(isdigit(a[i])){\n                cnt++;\n            }\n            if(a[i]=='-'){\n                if(cnt != 0){\n                    if(minusflag){\n                        tmp -= calc2(prel,i-1);\n                    }else{\n                        tmp += calc2(prel,i-1);\n                    }\n                    cnt = 0;\n                    prel = i+1;\n                    minusflag = true;\n                }\n                \n            }\n            if(a[i]=='+'){\n                if(minusflag){\n                    tmp -= calc2(prel,i-1);\n                }else{\n                    tmp += calc2(prel,i-1);\n                }\n                cnt = 0;\n                prel = i+1;\n                minusflag =false;\n            }\n            if(a[i]=='*'){\n                cnt = 0;\n            }\n        }\n        if(a[i]=='('){\n            dep++;\n        }else if(a[i]==')'){\n            dep--;\n        }\n    }\n    if(minusflag){\n        tmp -= calc2(prel,r);\n    }else{\n        tmp += calc2(prel,r);\n    }\n    return tmp;\n}\n\n\nbool eqcheck(){\n    int cc = 0;\n    int pl = 0;\n    rep(i,a.size()){\n        if(a[i]=='='){\n            cc++;\n            pl = i;\n        }\n    }\n    if(cc!=1)return false;\n    //cerr << calc(0,pl-1) << \" \" << calc(pl+1,n-1) << endl;\n    return (calc(0,pl-1)==calc(pl+1,n-1));\n}\n\n\n\nsigned main(){\n    string s;\n    cin >> s;\n    map<char,int>mp;\n    for(int i=0;i<s.size();i++){\n        if(stch.count(s[i])==1)continue;\n        mp[s[i]]++;\n    }\n    \n    if(mp.size()>8){\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<char> ori;\n    for(auto x:mp){\n        ori.push_back(x.first);\n        \n    }\n    n = s.size();\n    m = mp.size();\n    vector<int>v(8);\n    rep(i,8)v[i] =i;\n    int ans =0;\n    a.resize(n);\n    set<string> st;\n    do{\n        map<char,char>trans;\n        for(int i=0;i<ori.size();i++){\n            trans[ori[i]] =  ch[v[i]];\n        }\n        for(int i=0;i<n;i++){\n            if(stch.count(s[i])==1){\n                a[i] = s[i];\n            }else{\n                a[i] = trans[s[i]];\n            }\n        }\n        if(st.count(a)==1){\n            continue;\n        }\n        st.insert(a);\n        if(check()){\n            //cerr << a << endl;\n            if(eqcheck()){\n                //cerr << a << endl;\n                ans++;\n            }\n        }\n    }while(next_permutation(v.begin(),v.end()));\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='*'||s[p]=='+') flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    \n    return r;\n  }\n  \n  int res=0,minu=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n    \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(minu%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;    if(s[p]=='*'||s[p]=='+') flag=1;\n      \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n    \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    \n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n    \n  }while(next_permutation(idx,idx+8));\n  \n}\n\n\nmain(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nllint readE();\n\nstring s, t;\nvector<char> vec;\n\nllint pos;\nbool err;\n\nllint readN()\n{\n\tif(t[pos] == '0'){\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif(t[pos] != '1'){\n\t\terr = true;\n\t\treturn 0;\n\t}\n\tllint ret = 0;\n\twhile(t[pos] == '0' || t[pos] == '1'){\n\t\tret *= 2;\n\t\tret += t[pos] - '0';\n\t\tpos++;\n\t}\n\treturn ret;\n}\n\nllint readF()\n{\n\tif(t[pos] == '-'){\n\t\tpos++;\n\t\treturn -readF();\n\t}\n\telse if(t[pos] == '('){\n\t\tpos++;\n\t\tint ret = readE();\n\t\tif(t[pos] == ')'){\n\t\t\tpos++;\n\t\t\treturn ret;\n\t\t}\n\t\terr = true;\n\t\treturn 0;\n\t}\n\telse if(t[pos] == '0' || t[pos] == '1') return readN();\n\t\n\terr = true;\n\treturn 0;\n}\n\nllint readT()\n{\n\tllint ret = 1;\n\twhile(1){\n\t\tret *= readF();\n\t\tif(t[pos] == '*') pos++;\n\t\telse return ret;\n\t}\n}\n\nllint readE()\n{\n\tllint ret = 0, sgn = 1;\n\twhile(1){\n\t\tret += sgn * readT();\n\t\tif(t[pos] == '+'){\n\t\t\tpos++;\n\t\t\tsgn = 1;\n\t\t}\n\t\telse if(t[pos] == '-'){\n\t\t\tpos++;\n\t\t\tsgn = -1;\n\t\t}\n\t\telse return ret;\n\t}\n}\n\nbool readQ()\n{\n\tllint l = readE();\n\tif(t[pos] != '='){\n\t\terr = true;\n\t\treturn false;\n\t}\n\tpos++;\n\tllint r = readE();\n\tif(t[pos] != '#'){\n\t\terr = true;\n\t\treturn false;\n\t}\n\treturn l == r;\n}\n\nint main(void)\n{\n\tcin >> s;\n\ts += \"#\";\n\t\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] >= 'A' && s[i] <= 'Z' || s[i] >= 'a' && s[i] <= 'z') vec.push_back(s[i]);\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\n\tint C = vec.size();\n\tif(C > 8){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] >= 'A' && s[i] <= 'Z' || s[i] >= 'a' && s[i] <= 'z'){\n\t\t\ts[i] = (int)(lower_bound(vec.begin(), vec.end(), s[i]) - vec.begin()) + 'a';\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tllint perm[8];\n\tfor(int i = 0; i < 8; i++) perm[i] = i;\n\tconst char c[] = {'0', '1', '+', '-', '*', '=', '(', ')'};\n\t\n\tt = s;\n\tdo{\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(s[i] >= 'a' && s[i] <= 'z') t[i] = c[perm[s[i]-'a']];\n\t\t\telse t[i] = s[i];\n\t\t}\n\t\tpos = 0;\n\t\terr = false;\n\t\tif(readQ() && !err) ans++;\n\t}while(next_permutation(perm, perm+8));\n\t\n\tllint div = 1;\n\tfor(int i = 1; i <= 8-C; i++) div *= i;\n\tcout << ans / div << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[8];\nint used[8];\nint res;\nmap<char,int> mp;\nstring keydata=\"01()+-*=\";\n\n\nint expression(State &begin);\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='-'){\n\t\tbegin++;\n\t\tint ret;\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tint ret=-expression(begin);\n\t\t\tbegin++;\n\t\t}else{\n\t\t\tret=-number(begin);\n\t\t}\n\t\treturn ret;\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint num[101];\n\nbool check(string s){\n\tint cc=0;\n\tbool bnum=false;\n\tmemset(num,0,sizeof(num));\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='-'){\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i==0)continue;\n\t\t}\n\t\tif(s[i]=='+' || s[i]=='*'){\n\t\t\tif(i==0 || i+1==s.size())return false;\n\t\t\tif(!(isdigit(s[i-1]) || s[i-1]==')'))return false;\n\t\t}\n\t\tif(s[i]=='('){\n\t\t\tcc++;\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i>=1 && (s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t}\n\t\tif(isdigit(s[i])){\n\t\t\tif(i>=1 && (s[i-1]==')'))return false;\n\t\t\tif(s[i]=='0'){\n\t\t\t\tif(i>=1 && isdigit(s[i-1]))continue;\n\t\t\t\tif(i<s.size() && isdigit(s[i+1]))return false;\n\t\t\t}\n\t\t\tnum[cc]++;\n\t\t}\n\t\tif(s[i]==')'){\n\t\t\tif(cc==0)return false;\n\t\t\tif(num[cc]==0)return false;\n\t\t\tif(!(s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t\tnum[cc]=0;\n\t\t\tcc--;\n\t\t}\n\t}\n\tif(cc!=0)return false;\n\treturn true;\n}\n\nstring str;\n\nvoid dfs(int v){\n\tif(v==mp.size()){\n\t\tstring tmp=\"\";\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\t\tint va=mp[str[i]];\n\t\t\t\ttmp+=keydata[data[va-1]];\n\t\t\t}else{\n\t\t\t\ttmp+=str[i];\n\t\t\t}\n\t\t}\n\t\tstring s1=\"\";\n\t\tstring s2=\"\";\n\t\tbool eq=false;\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tif(tmp[i]=='='){\n\t\t\t\tif(eq)return;\n\t\t\t\teq=true;\n\t\t\t}else{\n\t\t\t\tif(!eq)s1+=tmp[i];\n\t\t\t\telse s2+=tmp[i];\n\t\t\t}\n\t\t}\n\t\tif(!check(s1) || s1.size()==0)return;\n\t\tif(!check(s2) || s2.size()==0)return;\n\t\tState s=s1.begin();\n\t\tint val=expression(s);\n\t\ts=s2.begin();\n\t\tint val2=expression(s);\n\t\tif(val==val2){\n\t\t\tres++;\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(used[i]==0){\n\t\t\t\tused[i]=1;\n\t\t\t\tdata[v]=i;\n\t\t\t\tdfs(v+1);\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> str;\n\tfor(int i=0;i<str.size();i++){\n\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\tif(mp.find(str[i])==mp.end()){\n\t\t\t\tmp[str[i]]=mp.size();\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\nconst ll INF=3e9;\n\nll eval(string s){\n\tll ok=1;\n\tint n=s.size();\n\tint i=0;\n\tfunction<ll()> E,T,F,N;\n\tE=[&](){\n\t\t\tif(i==n) return ok=0;\n\t\t\tll re=0;\n\t\t\tll sgn=1,tmp;\n\t\t\twhile(1){\n\t\t\t\tre+=sgn*T();\n\t\t\t\tif(i<n){\n\t\t\t\t\tif(s[i]=='+'){\n\t\t\t\t\t\tsgn=1;\n\t\t\t\t\t}else if(s[i]=='-'){\n\t\t\t\t\t\tsgn=-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++i;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\treturn re;\n\t\t};\n\tT=[&](){\n\t\t\tif(i==n) return ok=0;\n\t\t\tll re=1,tmp;\n\t\t\twhile(1){\n\t\t\t\tre*=F();\n\t\t\t\tif(i==n || s[i]!='*') break;\n\t\t\t\t++i;\n\t\t\t}\n\t\t\treturn re;\n\t\t};\n\tF=[&](){\n\t\t\tif(i==n) return ok=0;\n\t\t\tif(s[i]=='('){\n\t\t\t\t++i;\n\t\t\t\tll tmp=E();\n\t\t\t\tif(s[i]!=')') return ok=0;\n\t\t\t\t++i;\n\t\t\t\treturn tmp;\n\t\t\t}else if(s[i]=='-'){\n\t\t\t\t++i;\n\t\t\t\treturn -F();\n\t\t\t}else{\n\t\t\t\tif(s[i]=='0'){\n\t\t\t\t\tif(i+1<n && isdigit(s[i+1])) return ok=0;\n\t\t\t\t}else if(s[i]!='1') ok=0;\n\t\t\t\tll re=0;\n\t\t\t\twhile(i<n && isdigit(s[i])){\n\t\t\t\t\tre*=2;\n\t\t\t\t\tif(s[i]=='1') ++re;\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t\treturn re;\n\t\t\t}\n\t\t};\n\tll re=E();\n\t// out(s,re,1);\n\tif(ok && i==n) return re;\n\telse return INF;\n}\n\nint main(){\n\t// out(eval(\"1\"),1);\n\t// out(eval(\"1+1\"),1);\n\t// out(eval(\"1+1101\"),1);\n\t// out(eval(\"10*1+1101\"),1);\n\t// out(eval(\"-0\"),eval(\"0\"),1);\n\t// out(eval(\"0*\"),1);\n\t// return 0;\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\t// cout<<INF*INF<<endl;\n\tstring s;\n\tcin>>s;\n\tstring opes=\"01+-*()=\";\n\tstring cs;\n\tfor(char c:s)if(isalpha(c)) cs+=c;\n\tsort(all(cs)); UNIQUE(cs);\n\tcs.resize(opes.size(),'.');\n\tsort(all(cs));\n\tint re=0;\n\tdo{\n\t\tstring str=s;\n\t\trep(i,opes.size())for(char &c:str)if(c==cs[i]) c=opes[i];\n\t\tint cnt=0,pos;\n\t\trep(i,str.size())if(str[i]=='=') ++cnt, pos=i;\n\t\tif(cnt!=1 || str[0]=='=' || str.back()=='=') continue;\n\t\tstring A=str.substr(0,pos);\n\t\tstring B=str.substr(pos+1);\n\t\tll a=eval(A);\n\t\tll b=eval(B);\n\t\tif(a!=INF && b!=INF && a==b) ++re;\n\t\tif(a!=INF && b!=INF && a==b) out(A,B,a,b,cs,opes,1);\n\t}while(next_permutation(all(cs)));\n\tcout<<re<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint Q(int&);\nint E(int&);\nint T(int&);\nint F(int&);\n\nstring S;\nint N;\n\nint err = 0;\nstring gs;\nint Q(int& p){\n  int l = E(p);\n  if(err || p >= N || gs[p] != '='){\n\terr = 1;\n\treturn 0;\n  }\n  ++p;\n  int r = E(p);\n  if(err || p != N){\n\terr = 1;\n\treturn 0;\n  }\n  return l == r;\n}\n\nint E(int& p){\n  int x = T(p);\n  while(p < N){\n    if(gs[p] == '+'){\n      ++p;\n      x += T(p);\n    }\n    else if(gs[p] == '-'){\n      ++p;\n      x -= T(p);\n    }\n    else\n      break;\n  }\n  return x;\n}\n \nint T(int& p){\n  int x = F(p);\n  while(p < N){\n    if(gs[p] == '*'){\n      ++p;\n      x *= F(p);\n    }\n    else\n      break;\n  }\n  return x;\n}\n\nint F(int& p){\n  if(err || p >= N){\n\terr = 1;\n\treturn 0;\n  }\n  int x = 0;\n  if(gs[p] == '-'){\n\t++p;\n\tx = -F(p);\n  }\n  else if(gs[p] == '('){\n\t++p;\n\tx = E(p);\n\tif(gs[p] != ')'){\n\t  err = 1;\n\t  return 0;\n\t}\n\t++p;\n  }\n  else if(gs[p] == '0'){\n\tx = 0;\n\t++p;\n  }\n  else if(gs[p] == '1'){\n\tx = 1;\n\t++p;\n\twhile(p<N){\n\t  if(gs[p] == '0')\n\t\tx *= 2;\n\t  else if(gs[p] == '1')\n\t\tx = x*2 + 1;\n\t  else\n\t\tbreak;\n\t  ++p;\n\t}\n  }\n  else{\n\terr = 1;\n\treturn 0;\n  }\n\n  return x;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n\n  set<char> s;\n\n  REP(i,N)\n\tif(('a' <= S[i] && S[i] <= 'z') || ('A' <= S[i] && S[i] <= 'Z'))\n\t  s.insert(S[i]);\n  if(SZ(s) > 8){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  char cs[9] = \"+-*=()01\";\n  sort(cs, cs+8);\n\n  set<string> ans;\n  do{\n\tstring tmp = S;\n\tint j = 0;\n\tREP(i,N){\n\t  char c = tmp[i];\n\t  if(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')){\n\t\tREP(k,N)\n\t\t  if(tmp[k] == c)\n\t\t\ttmp[k] = cs[j];\n\t\t++j;\n\t  }\n\t}\n\tint p = 0;\n\terr = 0;\n\tgs = tmp;\n\tint flag = Q(p);\n\tif(flag && !err)\n\t  ans.insert(gs);\n  }while(next_permutation(cs, cs+8));\n\n  cout << SZ(ans) << endl;\n  //for(auto&&s:ans)cout<<s<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define pb push_back\n\ntypedef string::const_iterator State;\nint ans;\nstring s;\nll exp(State &begin);\n\n\nll bin(State &begin){\n\tll ret=0;\n\t\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\n\nll number(State &begin){\n\tif(*begin=='0'){\n\t\tbegin++;\n\t\tif(isdigit(*begin))throw \"number error1\";\n\t\telse return 0;\n\t}\n\telse if(*begin=='1'){\n\t\treturn bin(begin);\n\t}else throw \"number error2\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nll factor(State &begin){\n\tif( isdigit(*begin) )return number(begin);\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\tif(isdigit(*begin)||*begin=='('||*begin=='-') return -1*factor(begin);\n\t\telse throw \"factor error1\";\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tll ret = exp(begin);\n\t\tif(*begin!=')')throw \"factor error2\";\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse throw \"factor error3\";\n\tassert(1);\n\treturn -1;\n}\n\n\nll term(State &begin){\n\tll ret = factor(begin);\n\t\n\tif(*begin=='+'||*begin=='-'||*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}\n\telse if(*begin=='*'){\n\t\tbegin++;\n\t\treturn ret*term(begin);\n\t}\n\telse throw \"term error\";\n\t\n\tassert(1);\n\treturn -1;\n\t\n}\n\n\nll exp(State &begin){\n\tll ret = term(begin);\n\t\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else if(*begin=='$'||*begin==')'){\n\t\t\treturn ret;\n\t\t}else throw \"exp error\";\n\t}\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nbool isValid(string tmp){\n\tint eqc=0;\n\trep(i,tmp.size())if(tmp[i]=='=')eqc++;\n\tif(eqc!=1)return false;\n\t\n\tstring str[2]={};\n\tbool f=false;\n\trep(i,tmp.size()){\n\t\tif(tmp[i]=='=')f=true;\n\t\telse if(f)str[1]+=tmp[i];\n\t\telse str[0]+=tmp[i];\n\t}\n\tif(str[0].size()==0||str[1].size()==0)return false;\n\t\n\tState b[2];\n\tll res[2];\n\ttry{\n\t\trep(i,2){\n\t\t\tstr[i] +='$';\n\t\t\tb[i] = str[i].begin();\n\t\t\tres[i] = exp(b[i]);\n\t\t}\n\t}catch(char const* e){ return false; }\n\tif(res[0]==res[1] && *b[0]=='$'&&*b[1]=='$'){\n\t\treturn true;\n\t}else return false;\n}\n\n\nvoid dfs(string tmp,vector<bool> used){\n\tchar alp='!';\n\tint pos=-1;\n\trep(i,tmp.size()){\n\t\tif(isalpha(tmp[i]))alp=tmp[i],pos=i;\n\t}\n\tif(pos==-1){ if(isValid(tmp))ans++; return; }\n\t\n\tassert(alp!='!');\n\tstring symbols = \"01+-*()=\";\n\trep(i,symbols.size()){\n\t\tif(used[i])continue;\n\t\tused[i]=true;\n\t\tstring ntmp = tmp;\n\t\trep(j,ntmp.size()){\n\t\t\tif(ntmp[j]==alp) ntmp[j] = symbols[i];\n\t\t}\n\t\tdfs(ntmp,used);\n\t\tused[i]=false;\n\t}\n}\n\n\nint main(){\n\tcin>>s;\n\tset<char> st;\n\tvector<char> vs;\n\t\n\trep(i,s.size())st.insert(s[i]);\n\tfor(auto &e:st)vs.pb(e);\n\t\n\tint count=0;\n\trep(i,vs.size())if(isalpha(vs[i]))count++;\n\tif(count>8){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tans=0;\n\tvector<bool> used(8,false);\n\tdfs(s,used);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nint expr(string &s, int &p);\nint term(string &s, int &p);\nint factor(string &s, int &p);\nint number(string &s, int &p);\n\nbool ng;\n// Q ::= E=E\nbool is_eq(string &s) {\n    if (count(s.begin(), s.end(), '=') != 1) return false;\n    int k = s.find('=');\n    string a = s.substr(0, k), b = s.substr(k + 1);\n    auto check = [](string &s) {\n        if (s.size() == 0) return false;\n        int br = 0;\n        for (char c: s) {\n            br += (c == '(') - (c == ')');\n            if (br < 0) return false;\n        }\n        return br == 0;\n    };\n    if (!check(a) || !check(b)) return false;\n    ng = false;\n    int p = 0, x = expr(a, p);\n    if (ng || p != a.size()) return false;\n    int q = 0, y = expr(b, q);\n    if (ng || q != b.size()) return false;\n    return x == y;\n}\n// E ::= T | E+T | E−T\nint expr(string &s, int &p) {\n    int res = term(s, p);\n    while (p < s.size()) {\n        if (s[p] == '+') { res += term(s, ++p); continue; }\n        if (s[p] == '-') { res -= term(s, ++p); continue; }\n        break;\n    }\n    return res;\n}\n// T ::= F | T*F\nint term(string &s, int &p) {\n    int res = factor(s, p);\n    while (p < s.size()) {\n        if (s[p] == '*') { res *= factor(s, ++p); continue; }\n        break;\n    }\n    return res;\n}\n// F ::= N | −F | (E)\nint factor(string &s, int &p) {\n    int res;\n    if (s[p] == '-') {\n        res = -factor(s, ++p);\n    } else if (s[p] == '(') {\n        ++p;\n        res = expr(s, p);\n        ++p;\n    } else if (isdigit(s[p])) {\n        res = number(s, p);\n    } else {\n        return ng = true;\n    }\n    return res;\n}\n// N ::= 0 | 1B\n// B ::= ϵ | 0B | 1B\nint number(string &s, int &p) {\n    if (s[p] == '0') {\n        if (p + 1 < s.size() && isdigit(s[p + 1])) return ng = true;\n        return p++, 0;\n    }\n    int res = 0;\n    while (p < s.size() && isdigit(s[p])) res = res * 2 + s[p++] - '0';\n    return res;\n}\n\nint main() {\n    string s; cin >> s;\n    vector<char> cs;\n    for (auto c: s) if (isalpha(c)) cs.emplace_back(c);\n    sort(cs.begin(), cs.end());\n    cs.erase(unique(cs.begin(), cs.end()), cs.end());\n    if (cs.size() > 8) return !(cout << 0 << endl);\n    int cnt = 0;\n    string p = \"=+-*()01\";\n    sort(p.begin(), p.end());\n    do {\n        string t = s;\n        for (auto &c: t) if (isalpha(c)) {\n            int k = lower_bound(begin(cs), end(cs), c) - begin(cs);\n            c = p[k];\n        }\n        cnt += is_eq(t);\n    } while (next_permutation(p.begin(), p.end()));\n    for (int i = 0; i < p.size() - cs.size(); i++) cnt /= i + 1;\n    cout << cnt << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdexcept>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw;\n  if(S[idx] != c) throw;\n  idx ++;\n}\n\nbool try_consume(char c) {\n  if(idx >= N) throw;\n  if(S[idx] != c) return false;\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (...) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    \n    //if((s[p]=='*'||s[p]=='+')) flag=1;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    \n    return r;\n  }\n  \n  int res=0,minu=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n    \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(minu%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;    if(s[p]=='*'||s[p]=='+') flag=1;\n      \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n    \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    \n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n    \n  }while(next_permutation(idx,idx+8));\n  \n}\n\n\nmain(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nstring temp = \"01+-*()=\";\n \nint A(string&, int&);\n \nint B(string&, int&);\n \nint C(string&, int&);\n \nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    if(S[idx] != ')') throw (0);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0);\n  }\n  return (ret);\n}\n \nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= C(S, ++idx);\n  }\n  return (ret);\n}\n \nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += B(S, ++idx);\n    else ret -= B(S, ++idx);\n  }\n  return (ret);\n}\n \nint main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n \n  cin >> S;\n \n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n \n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n \n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n \n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n \n \n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nsigned main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool flg;\nint expr(string s,int& p);\nint term(string s,int& p);\nint factor(string s,int& p);\nint number(string s,int& p);\nint expr(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(flg) return 0;\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(flg) return 0;\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='-'){\n    p++;\n    res=-factor(s,p);\n  }else if(s[p]=='('){\n    p++;\n    res=expr(s,p);\n    if(p>=(int)s.size()||s[p]!=')'){\n      flg=1;\n      return 0;\n    }\n    p++;\n  }else if(isdigit(s[p])){\n    res=number(s,p);\n  }else{\n    flg=1;\n    return 0;\n  }\n  return res;\n}\nint number(string s,int& p){\n  if(s[p]=='0'){\n    if(p+1<s.size()&&isdigit(s[p+1])){\n      flg=1;\n      return 0;\n    }\n    p++;\n    return 0;\n  }\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p])) res=res*2+s[p++]-'0';\n  return res;\n}\nbool check(string s){\n  if(s.size()==0) return 0;\n  int op=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(op<0) return 0;\n  }\n  if(op) return 0;\n  return 1;\n}\n//set<string> ss;\nint Q(string s){\n  if(count(s.begin(),s.end(),'=')!=1) return 0;\n  int k=s.find('=');\n  string a=s.substr(0,k);\n  string b=s.substr(k+1,s.size()-(k+1));\n  if(!check(a)) return 0;\n  if(!check(b)) return 0;\n  //cout<<s<<endl;\n  //cout<<a<<\" \"<<b<<endl;\n  flg=0;\n  int p=0;\n  int x=expr(a,p);\n  //cout<<flg<<\" \"<<p<<\" \"<<x<<endl;\n  if(flg||p!=(int)a.size()) return 0;\n  p=0;\n  int y=expr(b,p);\n  //cout<<flg<<\" \"<<p<<\" \"<<y<<endl;\n  if(flg||p!=(int)b.size()) return 0;\n  //cout<<a<<\" \"<<b<<endl;\n  //cout<<x<<\":\"<<y<<endl;\n  return x==y;\n}\nint ans=0;\nstring l=\"01+-*()=\";\nvoid dfs(string s,int b){\n  bool f=1;\n  for(int i=0;i<(int)s.size();i++){\n    if(!isalpha(s[i])) continue;\n    f=0;\n    char c=s[i];\n    for(int j=0;j<(int)l.size();j++){\n      if((b>>j)&1) continue;\n      string t=s;\n      for(int k=0;k<(int)s.size();k++){\n\tif(t[k]==c) t[k]=l[j];\n      }\n      dfs(t,b+(1<<j));\n    }\n    break;\n  }\n  if(f) ans+=Q(s);\n}\nsigned main(){\n  string s;\n  cin>>s;\n  \n  dfs(s,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[8];\nint used[8];\nint res;\nmap<char,int> mp;\nstring keydata=\"01()+-*=\";\n\n\nint expression(State &begin);\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='-'){\n\t\tbegin++;\n\t\tint ret;\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tret=-expression(begin);\n\t\t\tbegin++;\n\t\t}else{\n\t\t\tret=-number(begin);\n\t\t}\n\t\treturn ret;\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint num[101];\n\nbool check(string s){\n\tint cc=0;\n\tbool bnum=false;\n\tmemset(num,0,sizeof(num));\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='-'){\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i==0)continue;\n\t\t}\n\t\tif(s[i]=='+' || s[i]=='*'){\n\t\t\tif(i==0 || i+1==s.size())return false;\n\t\t\tif(!(isdigit(s[i-1]) || s[i-1]==')'))return false;\n\t\t}\n\t\tif(s[i]=='('){\n\t\t\tcc++;\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i>=1 && (s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t}\n\t\tif(isdigit(s[i])){\n\t\t\tif(i>=1 && (s[i-1]==')'))return false;\n\t\t\tif(s[i]=='0'){\n\t\t\t\tif(i>=1 && isdigit(s[i-1]))continue;\n\t\t\t\tif(i<s.size() && isdigit(s[i+1]))return false;\n\t\t\t}\n\t\t\tnum[cc]++;\n\t\t}\n\t\tif(s[i]==')'){\n\t\t\tif(cc==0)return false;\n\t\t\tif(num[cc]==0)return false;\n\t\t\tif(!(s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t\tnum[cc]=0;\n\t\t\tcc--;\n\t\t}\n\t}\n\tif(cc!=0)return false;\n\treturn true;\n}\n\nstring str;\n\nvoid dfs(int v){\n\tif(v==mp.size()){\n\t\tstring tmp=\"\";\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\t\tint va=mp[str[i]];\n\t\t\t\ttmp+=keydata[data[va-1]];\n\t\t\t}else{\n\t\t\t\ttmp+=str[i];\n\t\t\t}\n\t\t}\n\t\tstring s1=\"\";\n\t\tstring s2=\"\";\n\t\tbool eq=false;\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tif(tmp[i]=='='){\n\t\t\t\tif(eq)return;\n\t\t\t\teq=true;\n\t\t\t}else{\n\t\t\t\tif(!eq)s1+=tmp[i];\n\t\t\t\telse s2+=tmp[i];\n\t\t\t}\n\t\t}\n\t\tif(!check(s1) || s1.size()==0)return;\n\t\tif(!check(s2) || s2.size()==0)return;\n\t\tState s=s1.begin();\n\t\tint val=expression(s);\n\t\ts=s2.begin();\n\t\tint val2=expression(s);\n\t\tif(val==val2){\n\t\t\tres++;\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(used[i]==0){\n\t\t\t\tused[i]=1;\n\t\t\t\tdata[v]=i;\n\t\t\t\tdfs(v+1);\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> str;\n\tfor(int i=0;i<str.size();i++){\n\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\tif(mp.find(str[i])==mp.end()){\n\t\t\t\tmp[str[i]]=mp.size();\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nbool err;\n\nstring e;\n\nll N(int l, int r);\nll F(int l, int r);\nll T(int l, int r);\nll E(int l, int r);\n\nll N(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    ll ret = 0;\n    for(int i=l; i<=r; ++i){\n        if(e[i]=='0' || e[i]=='1') ret = ret*2 + e[i]-'0';\n        else{\n            err = true;\n            return 0;\n        }\n    }\n\n    if(e[l]=='0'){\n        if(l!=r) err = true;\n    }\n    return ret;\n}\n\nll F(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    if(e[l]=='('){\n        if(e[r]!=')') err = true;\n        return E(l+1,r-1);\n    }\n    else if(e[l]=='-'){\n        return -F(l+1,r);\n    }\n    else return N(l,r);\n}\n\nll T(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    int b = 0;\n\n    int a_pos = -1;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='*'){\n            if(b==0){\n                a_pos = i;\n                break;\n            }\n        }\n    }\n\n    if(a_pos == -1) return F(l,r);\n    else return T(l,a_pos-1)*F(a_pos+1,r);\n}\n\nll E(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    char op = '?';\n    int o_pos = -1;\n    int b = 0;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='+' && b==0){\n            o_pos = i;\n            op = '+';\n            break;\n        }\n\n        if(e[i]=='-' && b==0){\n            o_pos = i;\n            while(l<=o_pos && e[o_pos]=='-') --o_pos;\n\n            if(o_pos<l){\n                op = '?';\n                break;\n            }\n            else{\n                if(o_pos == '+'){\n                    op = '+';\n                    break;\n                }\n                else{\n                    ++o_pos;\n                    op = '-';\n                    break;\n                }\n            }\n        }\n    }\n\n    if(op=='?') return T(l,r);\n    else if(op=='+') return E(l,o_pos-1)+T(o_pos+1,r);\n    else return E(l,o_pos-1)-T(o_pos+1,r);\n}\n\nbool Q(int l, int r){\n    int eq_pos = 0;\n    for(int i=l; i<=r; ++i){\n        if(e[i]=='=') eq_pos = i;\n    }\n\n    err = false;\n    ll L = E(l,eq_pos-1);\n    ll R = E(eq_pos+1,r);\n    return L==R;\n}\n\nint main(){\n    string s;\n    cin >>s;\n    int n = s.size();\n\n    set<char> a;\n    for(char c:s){\n        if(islower(c)||isupper(c)) a.insert(c);\n    }\n\n    if(a.size()>8){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    string x = \"01+-*()=\";\n    sort(all(x));\n\n    set<string> valid;\n    set<string> check;\n    do{\n        auto itr = x.begin();\n        map<char,char> cv;\n        for(char c:a){\n            cv[c] = *itr;\n            ++itr;\n        }\n\n        string t = s;\n        rep(i,n)if(cv.count(t[i])) t[i]=cv[t[i]];\n\n        int eq = 0;\n        rep(i,n) eq += (t[i]=='=');\n        if(eq!=1) continue;\n\n        e = t;\n        bool res = Q(0,e.size()-1);\n\n        if(!err && res) valid.insert(t);\n        if(!err) check.insert(t);\n    }while(next_permutation(all(x)));\n\n    // for(string V:valid) dbg(V);\n    // for(string C:check) dbg(C);\n    cout << valid.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint len,p;\nstring S;\nbool flag;\n\nint compute();\n\nint getNum(){\n  if(p>=len){\n    flag=true;\n    return 0;\n  }\n  \n  if(S[p]=='-'){\n    p++;\n    return -getNum();\n  }else if(S[p]=='0'){\n    p++;\n    return 0;\n  }else if(S[p]=='1'){\n    int res=0;\n    while(p<len && (S[p]=='0'||S[p]=='1') ){\n      res*=2;\n      res+=(S[p]-'0');\n      p++;\n    }\n    return res;\n  }else if(S[p]=='('){\n    p++;\n    int res=compute();\n    if(S[p-1]!=')')flag=true;\n    return res;\n  }else{\n    flag=true;\n    return 0;\n  }\n}\n\nint compute(){\n  if(p>=len){\n    flag=true;\n    return 0;\n  }\n  \n  stack<int> st;\n  st.push( getNum() );\n  \n  while(p<len){\n    char ch=S[p];p++;\n    if(ch==')')break;\n\n    int num=getNum();\n    if(ch=='+'){\n      st.push(num);\n    }else if(ch=='-'){\n      st.push(-num);\n    }else if(ch=='*'){\n      int x=st.top();\n      st.pop();\n      st.push(x*num);\n    }else{\n      flag=true;\n      break;\n    }\n  }\n  int res=0;\n  while(st.size()>0){\n    res+=st.top();\n    st.pop();\n  }\n  return res;\n}\n\nint check(string str){\n\n  string le,ri;\n  \n  int cnt=0,index;\n  for(int i=0;i<(int)str.size();i++)\n    if(str[i]=='=')cnt++, index=i;\n\n  \n  if(cnt!=1)return 0;\n  if(index==0 || index+1==(int)str.size())return 0;\n\n  \n  flag=false;\n  S=str.substr(0,index);\n  p=0;\n  len=S.size();\n  le=S;\n  int lv=compute();\n  int ca=0,cb=0;\n  \n  for(int i=0;i<S.size();i++)\n    if(S[i]=='(')ca++;\n    else if(S[i]==')')cb++;\n  if( ca!=cb || flag || p<len)return 0;\n  \n  flag=false;\n  S=str.substr(index+1);\n  ri=S;\n  p=0;\n  len=S.size();\n  int rv=compute();\n  ca=0,cb=0;\n  for(int i=0;i<S.size();i++)\n    if(S[i]=='(')ca++;\n    else if(S[i]==')')cb++;\n  if( ca!=cb || flag || p<len)return 0;\n\n  \n  if(lv==rv){\n    //    cout<<le<<' '<<ri<<endl;\n    return 1;\n  }else return 0;\n}\n\n\nint solve(string str){\n\n  string tmp=\"01+-*()=\";\n  sort(tmp.begin(),tmp.end());\n  \n  map<string,bool> used;\n  int res=0;\n  do{\n    map<char,char> mp;\n    string s=str;\n    for(int i=0;i<(int)s.size();i++){\n      if( ('A'<=s[i]&&s[i]<='Z') || ('a'<=s[i]&&s[i]<='z') ){\n        if(mp.count( s[i] )>0){\n          s[i]=mp[ s[i] ];\n        }else{\n          int id=mp.size();\n          mp[ s[i] ]=tmp[id];\n          s[i]=tmp[id];\n        }\n      }\n    }\n    if(!used[s]){\n      used[s]=true;\n      res+=check(s);\n    }\n  }while(next_permutation(tmp.begin(),tmp.end()));\n    return res;\n}\n\nint main(){\n  string str;\n  cin>>str;\n  cout<<solve(str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nint bnf();\nset<P> used;\nmap<char,int> M;\nstring S;\nint idx,valid;\nchar ch[7]={'0','1','+','-','*','(',')'};\nint ord[7];\n\nbool check(string a){//?????????????????°??¨??????????????????????¢????\n  int par=0;\n  for(char s:a){\n    par += (s == '(') - (s == ')');\n    if(s == '=') return 0;\n    if(par < 0) return 0;\n  }\n  return par==0;\n}\n\nint getNum(){ //??????????????°????????????\n  int res = 0;\n  if(S[idx] == '0' && isdigit(S[idx+1])) valid  = 0;\n  while(isdigit(S[idx]))res = res*2 + S[idx++]-'0';\n  return res;\n}\n\nint cal(){\n  char ch = S[idx];\n  int res = 0,sign = 1;\n  if(ch == '+'||ch=='*'||ch==')'){ valid = 0;return 0;}\n  \n  while(S[idx] == '-') idx++, sign *= -1;\n  ch = S[idx];\n\n  if(isdigit(ch)){\n    res = sign*getNum();\n    if(S[idx] == '*'){idx++; return res * cal();}\n    return res;\n  }\n  else if(ch == '(') {\n    idx++;res = sign*bnf();idx++;\n    return res;\n  }\n  valid = 0;\n  return 0;\n}\n\nint bnf(){\n  int res = cal();\n  while(idx<(int)S.size()){\n    if(valid == 0) return -1;\n    char ch = S[idx];\n    if(ch == '('){valid = 0;}\n    else if(ch == '*'){idx++;res *= cal();}\n    else if(ch == '+'){idx++;res += cal();}\n    else if(ch == '-'){idx++;res -= cal();}\n    else if(ch != ')') valid = 0;\n    else break;\n  }\n  if(valid ==0) return -1;\n  return res;\n}\n\nstring mkS(string a){\n  string res;\n  for(char s:a){\n    if(isalpha(s))res += ch[ ord[ M[s] ] ];\n    else res += s;\n  }\n  return res;\n}\n\n\nint calc(string &a,string &b){\n  string A = mkS(a);\n  string B = mkS(b);\n  if(used.count(P(A,B)))return 0;\n  used.insert(P(A,B));\n  \n  valid = check(A) && check(B);\n  idx = 0;\n  S = A;\n  int ra = bnf();\n  idx=0;\n  S = B;\n  int rb = bnf();\n  //if(valid)cout<<A<<\"=\"<<B<<\" \"<<valid<<\" \"<<ra<<\" \"<<rb<<endl;\n  return ra == rb && valid;\n}\n\n\nint dfs(int num,string &a,string &b){\n  if(num == 7) return calc(a,b);\n  \n  int res = 0;\n  for(int i=0;i<7;i++){\n    if(ord[i] != -1)continue;\n    ord[i] = num;\n    res +=dfs(num+1,a,b);\n    ord[i] = -1;\n  }\n  return res;\n}\n\n\nint main(){\n  string str;\n  cin>>str;\n  if(str.size()<3)cout<<0<<endl,exit(0);\n\n  map<char,int> cnt;\n  for(int i=0;i<(int)str.size();i++)if(isalpha(str[i]))cnt[str[i]]++;\n  if(cnt.size()>8)cout<<0<<endl,exit(0);\n\n  int c = 0;\n  for(pair<char,int> p:cnt)if(isalpha(p.first)) M[p.first] = c++;\n  \n  memset(ord,-1,sizeof(ord));  \n  int ans = 0;\n  for(int i=1;i<(int)str.size()-1;i++){\n    if(str[i]=='='||(isalpha(str[i])&&cnt[str[i]] == 1)){\n      string a = str.substr(0,i);\n      string b = str.substr(i+1,str.size()-i-1);\n\n      ans+=dfs(0,a,b);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nbool consume(char c) {\n  if(idx >= N) return false;\n  if(S[idx] != c) return false;\n  idx ++;\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(consume('0')) {\n    return 0;\n  }\n  else if(consume('1')) {\n    return convert(\"1\" + B());\n  }\n  else {\n    return -inf;\n  }\n}\n\nint F() {\n  if(consume('-')) {\n    int r = F();\n    if(r == -inf) return -inf;\n    return -r;\n  }\n  else if(consume('(')) {\n    int r = E();\n    if(r == -inf) return -inf;\n    if(!consume(')')) return -inf;\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  if(num1 == -inf) return -inf;\n  while(consume('*')) {\n    int num2 = F();\n    if(num2 == -inf) return -inf;\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  if(term1 == -inf) return -inf;\n  while(1) {\n    bool cont = 0;\n    while(consume('+')) {\n      cont = 1;\n      int term2 = T();\n      if(term2 == -inf) return -inf;\n      term1 += term2;\n    }\n    while(consume('-')) {\n      cont = 1;\n      int term2 = T();\n      if(term2 == -inf) return -inf;\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  if(idx == N) return curr == 0;\n\n  int expr1 = E();\n  if(expr1 == -inf) return false;\n\n  if(!consume('=')) return false;\n\n  int expr2 = E();\n  if(expr2 == -inf) return false;\n  if(expr1 != expr2) return false;\n\n  return idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  int Tsize = T.size();\n\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  M = alphas.size();\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    exit(0);\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, Tsize)\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      ans += Q();\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <string>\n#include <cctype>\n#include <set>\n\n#define ALL(a) (a).begin(), (a).end()\n#define FOR(i, a ,b) for(int i = int(a); i < int(b); ++i)\n#define REP(i, a) FOR(i, 0, a)\n#define RFOR(i, a, b) for(int i = int(b)-1; i >= int(a); --i)\n#define RREP(i,a) RFOR(i, 0, a)\n#define IN(a, x , b) (a <= x && x <= b)\ntemplate<class T> inline void CHMIN(T& a, T& b){if(a<b)a=b;}\ntemplate<class T> inline void CHMAX(T& a, T& b){if(a>b)a=b;}\n\nusing ll = long long;\n\ntemplate<class T> using V = std::vector<T>;\nusing namespace std;\n\nstring ops = \"01+-*()=\";\n\nint n;\nbool ok;\n\nusing State = string::const_iterator;\n\nll E(State& it, const State& end);\nll T(State& it, const State& end);\nll F(State& it, const State& end);\nll N(State& it, const State& end);\n\nll E(State& it, const State& end) {\n  if(it >= end) {\n    ok = false;\n    return 0;\n  }\n\n  ll res = T(it, end);\n  while(it < end) {\n    if(*it == '+') {\n      ++it;\n      res += T(it, end);\n    }\n    else if(*it == '-') {\n      ++it;\n      res -= T(it, end);\n    }\n    else {\n      break;\n    }\n  }\n  return res;\n}\n\nll T(State& it, const State& end) {\n  if(it >= end) {\n    ok = false;\n    return 0;\n  }\n\n  ll res = F(it, end);\n  while(it < end) {\n    if(*it == '*') {\n      ++it;\n      res *= F(it, end);\n    }\n    else {\n      break;\n    }\n  }\n  return res;\n}\n\nll F(State& it, const State& end) {\n  if(it >= end) {\n    ok = false;\n    return 0;\n  }\n\n  if(*it == '0' || *it == '1') {\n    return N(it, end);\n  }\n  else if(*it == '-') {\n    ++it;\n    return -F(it, end);\n  }\n  else if(*it == '(') {\n    ++it;\n    ll res = E(it, end);\n    if(it >= end || *it != ')') {\n      ok = false;\n      return 0;\n    }\n    ++it;\n    return res;\n  }\n  else {\n    ok = false;\n    return 0;\n  }\n}\n\nll N(State& it, const State& end) {\n  if(it >= end) {\n    ok = false;\n    return 0;\n  }\n  if(*it == '0' && it + 1 < end && (*(it + 1) == '0' || *(it + 1) == '1')) {\n    ok = false;\n    return 0;\n  }\n\n  ll res = 0;\n  while(it < end) {\n    if(*it == '0') {\n      ++it;\n      res = res * 2;\n    }\n    else if(*it == '1') {\n      ++it;\n      res = res * 2 + 1;\n    }\n    else {\n      break;\n    }\n  }\n  return res;\n}\n\nbool isValid(const string& s) {\n  if(s[0] == '=' || s[n-1] == '=') return false;\n  int eqpos = -1;\n  REP(i, n) {\n    if(s[i] == '=') {\n      if(eqpos == -1) {\n        eqpos = i;\n      }\n      else {\n        return false;\n      }\n    }\n  }\n  if(eqpos == -1) return false;\n\n  string left = s.substr(0, eqpos);\n  string right = s.substr(eqpos + 1);\n  ok = true;\n\n  ll leftval;\n  {\n    auto start = s.cbegin();\n    auto end = s.cbegin() + eqpos;\n    leftval = E(start, end);\n    if(!ok || start != end) return false;\n  }\n  ll rightval;\n  {\n    auto start = s.cbegin() + eqpos + 1;\n    auto end = s.cend();\n    rightval = E(start, end);\n    if(!ok || start != end) return false;\n  }\n  return leftval == rightval;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  n = s.size();\n\n  V<int> mapto(256, -1);\n  int sz = 0;\n  {\n    map<char, char> mp;\n    REP(i, n) {\n      if(isalpha(s[i])) mp[s[i]];\n    }\n    if(mp.size() > ops.size()) {\n      cout << 0 << '\\n';\n      return 0;\n    }\n    for(auto& p : mp) {\n      p.second = sz++;\n      mapto[p.first] = p.second;\n    }\n  }\n  sort(ALL(ops));\n  V<int> o(ops.size(), 0);\n  REP(i, sz) o[i] = 1;\n  reverse(ALL(o));\n\n  int ans = 0;\n  do{\n    string ops2;\n    REP(i, o.size()) if(o[i]) ops2 += ops[i];\n    do{\n      string s2(s);\n      REP(i, n) {\n        if(isalpha(s2[i])) s2[i] = ops2[mapto[s2[i]]];\n      }\n      if(isValid(s2)) {\n        ++ans;\n        //cout << s2 << endl;\n      }\n    }while(next_permutation(ALL(ops2)));\n  }while(next_permutation(ALL(o)));\n\n\n\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nbool Q(string s, int idx);\npair<i64, int> E(string s, int idx);\npair<deque<i64>, int> E_(string s, int idx);\npair<i64, int> T(string s, int idx);\npair<i64, int> T_(string s, int idx);\npair<i64, int> F(string s, int idx);\npair<string, int> N(string s, int idx);\npair<string, int> B(string s, int idx);\n\nbool error = false;\nstring letters = \"01+-*()=\";\n\ni64 to_i64(string s){\n    i64 res = 0;\n    for(int i=0;i<s.size();++i){\n        res *= 2;\n        res += s[i] - '0';\n    }\n    return res;\n}\n\nbool Q(string s, int idx){\n    auto p = E(s, idx);\n    if(error || s[idx+p.second] != '=')return false;\n    auto p2 = E(s, idx+p.second+1);\n    if(error || p.first != p2.first || p.second+p2.second+1 != s.size())return false;\n    else return true;\n}\n\npair<i64, int> E(string s, int idx){\n    auto p = T(s, idx);\n    if(error){\n        return make_pair(-1, -1);\n    }\n    auto p2 = E_(s, idx+p.second);\n    if(error)return make_pair(-1, -1);\n\n    i64 res = p.first;\n    for(auto e: p2.first)res += e;\n    return make_pair(res, p.second+p2.second);\n}\n\npair<deque<i64>, int> E_(string s, int idx){\n    if(idx >= s.size())return make_pair(deque<i64>(), 0);\n    if(s[idx] == '+' || s[idx] == '-'){\n        auto p = T(s, idx+1);\n        if(error)return make_pair(deque<i64>(), -1);\n        auto p2 = E_(s, idx+p.second+1);\n        if(error)return make_pair(deque<i64>(), -1);\n        deque<i64> res = p2.first;\n        if(s[idx] == '+'){\n            res.push_front(p.first);\n            return make_pair(res, p.second+p2.second+1);\n        }else{\n            res.push_front(-p.first);\n            return make_pair(res, p.second+p2.second+1);\n        }\n    }\n    return make_pair(deque<i64>(), 0);\n}\n\npair<i64, int> T(string s, int idx){\n    auto p = F(s, idx);\n    if(error){\n        return make_pair(-1, -1);\n    }\n    auto p2 = T_(s, idx+p.second);\n    if(error)return p2;\n    if(p2.second == 0)p2.first = 1;\n    return make_pair(p.first*p2.first, p.second+p2.second);\n}\n\npair<i64, int> T_(string s, int idx){\n    if(idx >= s.size())return make_pair(0, 0);\n    if(s[idx] == '*'){\n        auto p = F(s, idx+1);\n        if(error)return p;\n        auto p2 = T_(s, idx+p.second+1);\n        if(error)return p2;\n        if(p2.second == 0)p2.first = 1;\n        return make_pair(p.first*p2.first, p.second+p2.second+1);\n    }\n    return make_pair(0, 0);\n}\n\npair<i64, int> F(string s, int idx){\n    if(s[idx] == '-'){\n        auto p = F(s, idx+1);\n        return make_pair(-p.first, p.second+1);\n    }\n    if(s[idx] == '('){\n        auto p = E(s, idx+1);\n        if(s[idx+p.second+1] != ')'){\n            error = true;\n            return make_pair(-1, -1);\n        }\n        return make_pair(p.first, p.second+2);\n    }\n    if(s[idx] == '1' || s[idx] == '0'){\n        auto p = N(s, idx);\n        i64 n = to_i64(p.first);\n        return make_pair(n, p.second);\n    }\n    error = true;\n    return make_pair(-1, -1);\n}\n\npair<string, int> N(string s, int idx){\n    if(s[idx] == '0')return make_pair(\"0\", 1);\n    if(s[idx] == '1'){\n        auto p = B(s, idx+1);\n        return make_pair(\"1\"+p.first, 1+p.second);\n    }\n    error = true;\n    return make_pair(\"\", -1);\n}\n\npair<string, int> B(string s, int idx){\n    if(idx >= s.size())return make_pair(\"\", 0);\n    if(s[idx] == '0'){\n        auto p = B(s, idx+1);\n        return make_pair(\"0\"+p.first, 1+p.second);\n    }\n    if(s[idx] == '1'){\n        auto p = B(s,idx+1);\n        return make_pair(\"1\"+p.first, 1+p.second);\n    }\n    return make_pair(\"\", 0);\n}\n\nint main(){\n    string s;\n    cin >> s;\n    set<char> st;\n    for(auto c: s){\n        bool f = false;\n        for(auto cc: letters)\n            if(cc == c){\n                f = true;\n                break;\n            }\n        if(f)continue;\n        st.insert(c);\n    }\n    if(st.size() > 8){\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<char> v;\n    for(auto c: st)v.push_back(c);\n    while(v.size() < 8)v.push_back('#');\n    sort(v.begin(), v.end());\n    int ans = 0;\n    do{\n        string q;\n        for(auto c: s){\n            bool flag = false;\n            for(int i=0;i<v.size();++i){\n                if(c == v[i]){\n                    q.push_back(letters[i]);\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag)q.push_back(c);\n        }\n        error = false;\n        bool f = Q(q, 0);\n        if(f)ans++;\n        //if(f)cout << q << endl;\n    }while(next_permutation(v.begin(), v.end()));\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint idx, len;\n\nint number();\nint factor();\nint term();\nint expression();\n\nint number(){\n    char c = f[idx++];\n    if(c != '0' and c != '1') throw 1;\n\n    if(c == '0') return 0;\n\n    int ret = 1;\n    while(idx < len and (f[idx] == '0' or f[idx] == '1')){\n        ret *= 2;\n        char c = f[idx++];\n        if(c == '1') ret += 1;\n    }\n    return ret;\n}\n\nint factor(){\n    int mcnt = 0;\n    while(idx < len and f[idx] == '-'){\n        mcnt++;\n        idx++;\n    }\n    if(idx >= len) throw 1;\n\n    int sign = (mcnt % 2 == 0 ? +1:-1);\n    if(f[idx] != '(') return sign * number();\n    idx++;\n\n    int ret = sign * expression();\n    if(idx >= len or f[idx] != ')') throw 1;\n    idx++;\n\n    return ret;\n}\n\nint term(){\n    int ret = factor();\n    while(idx < len and f[idx] == '*'){\n        idx++;\n        int rhs = factor();\n        ret *= rhs;\n    }\n    return ret;\n}\n\nint expression(){\n    int ret = term();\n    while(idx < len and (f[idx] == '+' or f[idx] == '-')){\n        char op = f[idx++];\n        int rhs = term();\n        switch(op){\n            case '+': { ret += rhs; break; }\n            case '-': { ret -= rhs; break; }\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    /*\n    while(cin >> f){\n        len = f.size(), idx = 0;\n        int ret = expression();\n        cerr << ret << \", idx = \" << idx << \", len = \" << len << endl;\n    }\n    return 0;\n    //*/\n\n    string in; cin >> in;\n    string T = \"01+-*()=\"; sort(_all(T));\n\n    set<string> s;\n    do {\n        map<char, bool> used;\n        map<char, char> c2t;\n        int j = 0;\n        f = in;\n        rep(i, in.size()){\n            char c = in[i];\n            if(not isupper(c) and not islower(c)) continue;\n\n            if(not used[c]){\n                used[c] = true;\n                assert(j < T.size());\n                c2t[c] = T[j++];\n            }\n            f[i] = c2t[c];\n        }\n\n        string equation = f;\n        string l, r;\n        rep(i, in.size()){\n            if(f[i] == '='){\n                l = f.substr(0, i);\n                r = f.substr(i + 1);\n                break;\n            }\n        }\n        if(l == \"\" or r == \"\") continue;\n\n        try {\n            idx = 0; f = l; len = f.size();\n            int lv = expression();\n            if(idx != len) continue;\n\n            idx = 0; f = r; len = f.size();\n            int rv = expression();\n            if(idx != len) continue;\n\n            if(lv != rv) continue;\n        }\n        catch(int e){\n            continue;\n        }\n        s.insert(equation);\n    } while(next_permutation(_all(T)));\n\n    // for(auto& e : s){\n    //     cerr << e << endl;\n    // }\n    cout << s.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????????§????????£??????????????±??????2???????????????\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar component_array[8] = {'0','1','+','-','*','(',')','=',};\nint table[40320][8];\nint num_of_type,table_index;\n\nint calc_E(char line[32],int left,int right);\nint calc_T(char line[32],int left,int right);\nint calc_F(char line[32],int left,int right);\nint calc_NUM(char line[32],int left,int right);\n\nbool is_component(char ch){\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(ch == component_array[i])return true;\n\t}\n\n\treturn false;\n}\n\nvoid makeTable(bool used[8],int change_list[8],int index){\n\n\tif(index == num_of_type){ //対応表の作成が完成した場合\n\t\tfor(int i = 0; i < num_of_type; i++){\n\t\t\ttable[table_index][i] = change_list[i];\n\t\t}\n\t\ttable_index++;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(used[i] == false){\n\n\t\t\tbool next_used[8];\n\t\t\tint next_change_list[8];\n\n\t\t\tfor(int k = 0; k < 8; k++)next_used[k] = used[k];\n\t\t\tfor(int k = 0; k < index; k++)next_change_list[k] = change_list[k];\n\n\t\t\tnext_used[i] = true;\n\t\t\tnext_change_list[index] = i;\n\n\t\t\tmakeTable(next_used,next_change_list,index+1);\n\t\t}\n\t}\n}\n\nbool is_OK(char work[32]){\n\n\tint length;\n\tfor(length = 0; work[length] != '\\0'; length++);\n\n\tint equal_count = 0;\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif(work[i] == '=')equal_count++;\n\t}\n\tif(equal_count != 1)return false; //'='の数が1でないなら不可\n\n\tint eq_pos;\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '='){\n\t\t\teq_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(eq_pos == 0 || eq_pos == length-1)return false; //'='の場所が左端、または右端なら不可\n\n\n\t//異種カッコが連続していないか調べる\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(' && work[i+1] == ')')return false;\n\t\tif(work[i] == ')' && work[i+1] == '(')return false;\n\t}\n\n\n\t//カッコの対応が取れているかチェック(左半分)\n\tstack<int> S;\n\tfor(int i = 0; i < eq_pos; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\t//カッコの対応が取れているかチェック(右半分)\n\tfor(int i = eq_pos+1; i < length; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\t//左端を調べる\n\tif(work[0] == '+' || work[0] == '*')return false;\n\tif(work[eq_pos+1] == '+' || work[eq_pos+1] == '*')return false;\n\n\t//数字と開きカッコ、開きカッコと(*or+)が連結していないか調べる\n\tfor(int i = 0; i < length; i++){\n\t\tif((work[i] == '0' || work[i] == '1') && work[i+1] == '(')return false;\n\t\tif((work[i] == '(') && (work[i+1] == '*' || work[i+1] == '+'))return false;\n\t}\n\n\n\t//バイナリが複数桁の場合、1スタートか調べる\n\tfor(int i = 0; work[i] != '\\0';){\n\t\tif(work[i] != '0' && work[i] != '1')i++;\n\t\telse{\n\t\t\tif(work[i] == '1'){\n\t\t\t\twhile(work[i] == '1' || work[i] == '0')i++;\n\t\t\t}else{ //左端の0\n\t\t\t\tif(work[i+1] == '1' || work[i+1] == '0')return false;\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//opの連結を調べる\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif((work[i] == '+' || work[i] == '*') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '='|| work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\n\t\tif((work[i] == '-') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '=' || work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\t}\n\n\n\n\treturn true;\n}\n\nint calc_E(char line[32],int left,int right){\n\n\t/*printf(\"E\\n\");\n\tfor(int i = left; i <= right; i++){\n\t\tprintf(\"%c\",line[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、プラスまたは-を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif((i != left) && (line[i-1] == '0' || line[i-1] == '1' || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の+-がない\n\t\treturn calc_T(line,left,right);\n\t}\n\n\tint tmp = calc_E(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(char line[32],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、*を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の*がない\n\t\treturn calc_F(line,left,right);\n\t}\n\n\tint tmp = calc_T(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\ttmp *= tmp_right;\n\t}\n\treturn tmp;\n}\n\nint calc_F(char line[32],int left,int right){\n\n\tif(line[left] == '1' || line[left] == '0'){\n\t\treturn calc_NUM(line,left,right);\n\t}else if(line[left] == '-'){\n\t\treturn -1*calc_F(line,left+1,right);\n\t}else if(line[left] == '('){\n\n\t\t/*printf(\"Minhi!\\n\");\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tprintf(\"%c\",line[i]);\n\t\t}\n\t\tprintf(\"\\n\");*/\n\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\treturn calc_E(line,left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(char line[32],int left,int right){\n\n\t//left～rightに0か1以外の文字が入っていたら不適\n\tfor(int i = left; i <= right; i++){\n\t\tif(line[i] != '0' && line[i] != '1')return BIG_NUM;\n\t}\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 2*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tchar buf[32];\n\tscanf(\"%s\",buf);\n\n\tint check_table[128];\n\tfor(int i = 0; i < 128; i++)check_table[i] = 0;\n\n\tvector<int> CHAR_LIST,REPLACE_LOC[128];\n\tnum_of_type = 0; //置き換える文字の種類数\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tif(!is_component(buf[i])){ //置き換える必要のある文字である場合\n\n\t\t\tREPLACE_LOC[buf[i]].push_back(i); //buf[i]が何文字目にあるかのリスト\n\n\t\t\tif(check_table[buf[i]] == 0){ //初登場\n\t\t\t\tnum_of_type++;\n\t\t\t\tcheck_table[buf[i]]++;\n\t\t\t\tCHAR_LIST.push_back(buf[i]); //置き換える文字のリストに追加\n\t\t\t}\n\t\t}\n\t}\n\n\tif(num_of_type > 8){ //構成要素は8種類しかないので、9種類以上置き換え文字があったら答えは0\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tchar work[32],left_table[32],right_table[32];\n\tint eq_pos,left_result,right_result,right_length,ans = 0;\n\n\tif(num_of_type == 0){ //置き換えるべき文字が無い場合\n\n\t\tif(!is_OK(buf)){ //入力の文字列が文法的に間違っている場合\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t//左辺と右辺に数式を分解する\n\t\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\t\tif(buf[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = buf[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; buf[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = buf[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\tif(abs(left_result) == BIG_NUM){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\n\t\tif(left_result == right_result){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tbool first_used[8];\n\tfor(int i = 0; i < 8; i++)first_used[i] = false;\n\tint first_change_list[8];\n\ttable_index = 0;\n\tmakeTable(first_used,first_change_list,0); //アルファベットと、文字の変換表を作る\n\n\tfor(int i = 0; i < table_index; i++){\n\n\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\t\t\twork[k] = buf[k];\n\t\t\twork[k+1] = '\\0';\n\t\t}\n\n\t\t//文字を置き換える\n\t\tfor(int k = 0; k < num_of_type; k++){\n\t\t\tint word = CHAR_LIST[k];\n\t\t\tfor(int a = 0; a < REPLACE_LOC[word].size(); a++){\n\t\t\t\tint loc = REPLACE_LOC[word][a];\n\t\t\t\twork[loc] = component_array[table[i][k]];\n\t\t\t}\n\t\t}\n\n\t\t//文法的に適切かどうかざっと確かめる(OKでも不適な場合が多数ある)\n\t\tif(!is_OK(work))continue;\n\n\t\t//左辺と右辺に数式を分解する\n\t\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\t\tif(work[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = work[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; work[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = work[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t\tprintf(\"left:%s\\n\",left_table);\n\t\t\t\t\tprintf(\"right:%s\\n\",right_table);\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\tprintf(\"left_res:%d\\n\",left_result);\n\t\tif(abs(left_result) == BIG_NUM)continue;\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\t\tprintf(\"right_res:%d\\n\\n\",right_result);\n\t\tif(abs(right_result) == BIG_NUM)continue;\n\n\t\tif(left_result == right_result){\n\t\t\t/*printf(\"left:%s\\n\",left_table);\n\t\t\tprintf(\"right:%s\\n\",right_table);*/\n\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nbool err;\n\nstring e;\n\nll N(int l, int r);\nll F(int l, int r);\nll T(int l, int r);\nll E(int l, int r);\n\nll N(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    ll ret = 0;\n    for(int i=l; i<=r; ++i){\n        if(e[i]=='0' || e[i]=='1') ret = ret*2 + e[i]-'0';\n        else{\n            err = true;\n            return 0;\n        }\n    }\n\n    if(e[l]=='0'){\n        if(l!=r) err = true;\n    }\n    return ret;\n}\n\nll F(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    if(e[l]=='('){\n        if(e[r]!=')') err = true;\n        return E(l+1,r-1);\n    }\n    else if(e[l]=='-'){\n        return -F(l+1,r);\n    }\n    else return N(l,r);\n}\n\nll T(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    int b = 0;\n\n    int a_pos = -1;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='*'){\n            if(b==0){\n                a_pos = i;\n                break;\n            }\n        }\n    }\n\n    if(a_pos == -1) return F(l,r);\n    else return T(l,a_pos-1)*F(a_pos+1,r);\n}\n\nll E(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    char op = '?';\n    int o_pos = -1;\n    int b = 0;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='+' && b==0){\n            o_pos = i;\n            op = '+';\n            break;\n        }\n        if(e[i]=='-' && b==0){\n            o_pos = i;\n            while(l<=o_pos && e[o_pos]=='-') --o_pos;\n\n            if(o_pos<l){\n                op = '?';\n                break;\n            }\n            else{\n                ++o_pos;\n                op = '-';\n                break;\n            }\n        }\n    }\n\n    if(op=='?') return T(l,r);\n    else if(op=='+') return E(l,o_pos-1)+T(o_pos+1,r);\n    else return E(l,o_pos-1)-T(o_pos+1,r);\n}\n\nint main(){\n    string s;\n    cin >>s;\n    int n = s.size();\n\n    set<char> a;\n    for(char c:s){\n        if(islower(c)||isupper(c)) a.insert(c);\n    }\n\n    if(a.size()>8){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    string x = \"01+-*()=\";\n    sort(all(x));\n\n    set<string> valid;\n    do{\n        auto itr = x.begin();\n        map<char,char> cv;\n        for(char c:a){\n            cv[c] = *itr;\n            ++itr;\n        }\n\n        string t = s;\n        rep(i,n)if(cv.count(t[i])) t[i]=cv[t[i]];\n\n        int eq = 0;\n        int e_pos = -1;\n        rep(i,n){\n            if(t[i]=='='){\n                ++eq;\n                e_pos = i;\n            }\n        }\n\n        if(eq!=1) continue;\n\n        string l = t.substr(0,e_pos);\n        string r = t.substr(e_pos+1);\n        if(l.size()==0 || r.size()==0) continue;\n\n        err = false;\n\n        e = l;\n        ll L = E(0,e.size()-1);\n\n        e = r;\n        ll R = E(0,e.size()-1);\n\n        if(!err && L==R) valid.insert(t);\n    }while(next_permutation(all(x)));\n\n    // for(string V:valid) dbg(V);\n    cout << valid.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\n\npair<int, int> isE(const std::string &s, int start, int end);\n\npair<int,int> isB(const std::string &s, int start) {\n  // cout << \"isB \" << s << \" \" << start << endl;\n  pair<int, int> p;\n  int x = 0;\n  if (s[start] != '0' && s[start] != '1') {\n    return make_pair(-1, -1);\n  }\n  if (s[start] == '0') {\n    return make_pair(0, start + 1);\n  }\n\n  while (start < s.length() && (s[start] == '0' || s[start] == '1')) {\n    x = x << 1;\n    x += s[start] - '0';\n    start++;\n  }\n  return make_pair(x, start);\n}\n\npair<int, int> isF(const std::string &s, int start, int end) {\n  // cout << \"isF \" << s << \" \" << start << \" \" << end << endl;\n  if (start >= end) return make_pair(-1, -1);\n  if (s[start] == '(') {\n    if (s[end - 1] != ')') return make_pair(-1, -1);\n    pair<int, int> p = isE(s, start + 1, end - 1);\n    if (p.second == -1) return p;\n    return make_pair(p.first, p.second + 1);\n  }\n\n  if (s[start] == '-') {\n    pair<int, int> p = isF(s, start + 1, end);\n    // cout << \"isF return from - \" << p.first << \", \" << p.second << endl;\n    if (p.second == -1) return p;\n    if (p.second != end) return make_pair(-1, -1);\n    p.first *= -1;\n    return p;\n  }\n  pair<int, int> p = isB(s, start);\n  // cout << \"isF last \" << s << start << \" \" << end << \" \" << p.first << \",\" << p.second << \" \" << end << endl;\n  if (p.second == end) return p;\n  // cout << \"isF last \" << s << start << \" \" << end << \" \" << p.first << \",\" << p.second << \" \" << end << endl;\n  return make_pair(-1, -1);\n}\n\npair<int, int> isT(const std::string &s, int start, int end) {\n  for (int i = end - 1; i > start; --i) {\n    if (s[i] == '*') {\n      pair<int, int> p = isF(s, i+1, end);\n      if (p.second == -1) continue;\n      pair<int, int> q = isT(s, start, i);\n      if (q.second == -1) continue;\n      return make_pair(p.first * q.first, end);\n    }\n  }\n  pair<int, int> p = isF(s, start, end);\n  // cout << \"last isT \" << s << \" \" << start << \" \" << p.first << \" \" << p.second << endl;\n  return p;\n}\n\npair<int, int> isE(const std::string &s, int start, int end) {\n  if (start >= end) return make_pair(-1, -1);\n  for (int i = end - 1; i > start; --i) {\n    if (s[i] == '+' || s[i] == '-') {\n      pair<int, int> p = isT(s, i + 1, end);\n      if (p.second == -1) continue;\n      pair<int, int> q = isE(s, start, i);\n      if (q.second == -1) continue;\n      if (s[i] == '+') {\n        return make_pair(p.first + q.first, end);\n      }\n      if (s[i] == '-') {\n        return make_pair(q.first - p.first, end);\n      }\n    }\n  }\n  pair<int, int> p = isT(s, start, end);\n  // cout << \"last isE \" << s << \" \" << start << \" \" << p.first << \" \" << p.second << endl;\n  return p;\n}\n\nbool isQ(const std::string &s) {\n  int idx = -1;\n  for (int i = 1; i < s.length() - 1; ++i) {\n    if (s[i] == '=') {\n      idx = i;\n      break;\n    }\n  }\n  if (idx == -1) return false;\n\n  pair<int, int> p = isE(s, 0, idx);\n  if (p.second == -1 || s[p.second] != '=') return false;\n  // cout << \"isQ after p before q\" << endl;\n  pair<int, int> q = isE(s, p.second+1, s.length());\n  // cout << \"isQ last before \" << q.first << \", \" << q.first << \": \" << s << endl;\n  if (q.second == -1) return false;\n  // cout << \"isQ last \" << p.first << \", \" << q.first << \": \" << s << endl;\n  return p.first == q.first;\n}\n\nbool check(const std::string &s) {\n  return isQ(s);\n}\n\nint main() {\n  string s;\n  cin >> s;\n\n  std::vector<char> ops = {'=', '+', '-', '*', '(', ')', '0', '1'};\n  sort(ops.begin(), ops.end());\n\n  std::set<char> chars;\n  for (int i = 0; i < s.length(); ++i) {\n    if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n      chars.insert(s[i]);\n    }\n  }\n  std::vector<char> abc;\n  for (const char c : chars) abc.push_back(c);\n  if (abc.size() > ops.size()) {\n    cout << \"0\" << endl;\n    return 0;\n  }\n\n  std::map<char, char> m;\n  for (int i = 0; i < ops.size(); ++i) m[ops[i]] = ops[i];\n\n  std::set<string> ans;\n  do {\n    for (int i = 0; i < abc.size(); ++i) m[abc[i]] = ops[i];\n    string ss = s;\n    for (int i = 0; i < s.length(); ++i) ss[i] = m[s[i]];\n    if (check(ss)) {\n      ans.insert(ss);\n    }\n  } while (next_permutation(ops.begin(), ops.end()));\n  cout << ans.size() << endl;\n  // for (const std::string &s : ans) {\n  //   cout << s << endl;\n  // }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\n\nbool OK(string s){\n  int cnt=0;\n  for(int i=0;i<s.size();i++){\n    if(s[i]=='-'){\n      if(i+1==s.size())return 0;\n      if(s[i+1]=='+')return 0;\n      if(s[i+1]=='*')return 0;\n      if(i&&s[i-1]=='('&&s[i+1]==')')return 0;\n      if(s[i+1]==')')return 0;\n    }\n    if(s[i]=='+'){\n      if(i==0)return 0;\n      if(i+1==s.size())return 0;\n      if(s[i+1]=='+')return 0;\n      //if(s[i+1]=='-')return 0;\n      if(s[i+1]=='*')return 0;\n      if(s[i+1]==')')return 0;\n    }\n     if(s[i]=='*'){\n      if(i==0)return 0;\n      if(i+1==s.size())return 0;\n      if(s[i+1]=='+')return 0;\n      //if(s[i+1]=='-')return 0;\n      if(s[i+1]=='*')return 0;\n      if(s[i+1]==')')return 0;\n    }\n    if(isdigit(s[i])){\n      if(i&&s[i-1]==')')return 0;\n      if(s[i]=='0'){\n        if(i==0&&isdigit(s[i+1]))return 0;\n        if(i&&i<s.size()&&!isdigit(s[i-1])&&isdigit(s[i+1]))return 0;\n      }\n      if(s[i+1]=='(')return 0;\n    }\n    if(s[i]=='('){\n      cnt++;\n      if(i==s.size())return 0;\n      if(s[i+1]=='+')return 0;\n      if(s[i+1]=='*')return 0;\n      if(s[i+1]==')')return 0;\n    }\n    if(s[i]==')'){\n      cnt--;\n      if(cnt<0)return 0;\n      if(!i)return 0;\n      if(isdigit(s[i+1]))return 0;\n      if(s[i+1]=='(')return 0;\n    }\n  }\n  if(cnt)return 0;\n  return 1;\n}\n\nstring str,s;\nset<char>st;\n\nstruct Parse{\n    string s;\n    int p;\n    int g_A(){\n        int r=0,x=1;\n        if(s[p]=='-'){\n          p++;\n          return -g_A();\n        }\n        else if(s[p]=='(')p++,r=bnf1(),p++;\n        else while(isdigit(s[p])) r=r*2+(s[p++]-'0');\n        return r;\n    }\n    int bnf2(){\n        int res=g_A();\n        while(s[p]=='*'){\n          int t=p++;\n          if(s[t]=='*')res*=g_A();\n        }\n        return res;\n    }\n    int bnf1(){\n        int res=bnf2();\n        while(s[p]=='+'||s[p]=='-'){\n            int t=p++;\n            if(s[t]=='+')res+=bnf2();\n            if(s[t]=='-')res-=bnf2();\n        }\n    return res;\n    }\n    int build(string t){\n        p=0;\n        s=t;\n        return bnf1();\n    }\n};\n\nint ans=0;\nstring t=\"01()+*-=\";\nmap<char,int>M1;\nint n;\n\nsigned main(){\n\n  Parse p;\n\n  cin>>s;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  n=st.size();\n  int cc=0;\n  for(set<char>::iterator it=st.begin();it!=st.end();it++){\n    char c=*it;\n    M1[c]=cc++;\n  }\n  set<string>S;\n  vector<int>v;\n  r(i,8)v.push_back(i);\n  do{\n    int sum=0,idx;\n    string x=s;\n    r(i,x.size()){\n      if(isalpha(x[i])){\n        int y=M1[x[i]];\n        x[i]=t[v[y]];\n      }\n    }\n\n    if(S.count(x))continue;\n    r(i,x.size())if(x[i]=='=')sum++,idx=i;\n    if(sum!=1)continue;\n    if(idx==0||idx==x.size()-1)continue;\n\n    string a=x.substr(0,idx);\n    string b=x.substr(idx+1);\n\n    if(!OK(a)||!OK(b))continue;\n\n    int A=p.build(a);\n    int B=p.build(b);\n    if(A==B){\n\n      S.insert(x);\n      ans++;\n    }\n  }while(next_permutation(v.begin(),v.end()));\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring temp = \"01+-*()=\";\nconst int INF = 1 << 30;\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw(0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nint main()\n{\n  sort(begin(temp), end(temp));\n\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) if(isalpha(c)) num.push_back(c);\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > 6) {\n    cout << 0 << endl;\n    return (0);\n  }\n\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L, R;\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n \nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n \nint bnf();\n \nint bnf3(){\n   \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n   \n  if(s[p]=='('){\n     \n    p++;\n    if(p<s.size()&&(s[p]=='*'||s[p]=='+')) flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n     \n    int r=bnf();\n     \n    if(p>=s.size()||s[p]!=')') flag=1;\n     \n    p++;\n     \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n     \n     \n    return r;\n  }\n   \n  int res=0,minu=0;\n \n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n   \n  if(s[p]=='-'){\n     \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n     \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n   \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n   \n  if(s[p]=='(') flag=1;\n   \n  if(minu%2) res*=-1;\n   \n  return res;\n}\n \nint bnf2(){\n \n  int res=bnf3();\n \n  while(p<s.size()){\n \n    if(s[p]=='*'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf3();\n       \n      res*=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nint bnf(){\n \n  int res=bnf2();\n \n  while(p<s.size()){\n \n    if(s[p]=='+'){\n \n      p++;\n       \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n       \n      int r=bnf2();\n \n      res+=r;\n       \n    }    \n    else if(s[p]=='-'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf2();\n \n      res-=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nvoid check(){\n   \n  int cnt=0;\n   \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n \n      if(cnt==0){\n    flag=1;\n    return ;\n      }\n      else cnt--;\n    }\n  }\n \n  if(cnt) flag=1;\n}\n \nset<string> me;\n \nvoid solve(){\n   \n  set<char> S;\n   \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n \n  set<char>::iterator ite=S.begin();\n \n  vector<char> al;\n   \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n   \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n   \n  int idx[8];\n \n  for(int i=0;i<8;i++) idx[i]=i;\n   \n  do{\n     \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n \n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n     \n    if(me.count(s)) continue;\n    me.insert(s);\n     \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n     \n    string s1,s2;\n     \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n \n    int f=0;\n \n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n     \n    flag=0;\n    s=s1;\n    p=0;\n     \n    int r1=bnf();\n    check();\n     \n    s=s2;\n    p=0;\n     \n    int r2=bnf();\n    check();\n \n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n     \n  }while(next_permutation(idx,idx+8));\n   \n}\n \n \nmain(){\n \n  cin>>s;\n  str=s;\n   \n  solve();\n \n  cout<<ans<<endl;\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <cstring>\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <map>\n#define FAIL (make_pair(0,0))\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nchar a[] = \"01+-*()=\";\nint pr[500];\nchar s[100];\nchar t[100];\nint n,ans;\nmap<char,char> m;\nbool work(stack<LL> &res,stack<char> & op){\n    if(res.empty())return 0;\n    if(res.top() == '(')return 0;\n    if(op.top() == '#'){\n        res.top() = -res.top();\n        op.pop();\n        return 1;\n    }\n    LL tem = res.top();\n    res.pop();\n    if(res.empty())return 0;\n    if(op.top() == '+'){\n        res.top() += tem;\n    }else if(op.top() == '-'){\n        res.top() -= tem;\n    }else{\n        res.top() *= tem;\n    }\n    op.pop();\n    return 1;\n}\npair<LL, bool>get(int l,int r){\n    if(l >= r)return make_pair(0, 0);\n    if(t[l] == '+' || t[l] == '*' || t[l] == ')')return FAIL;\n    if(t[r - 1] == '+' || t[r - 1] == '*' || t[r - 1] == '(' || t[r - 1] == '-')return FAIL;\n    stack<LL> res;\n    stack<char> op;\n    for(int i = l;i < r; ++i){\n        //cout << l <<\" \"<<i<<endl;\n        if(isdigit(t[i])){\n            LL tem = 0;\n            int st = i;\n            while(i < r && isdigit(t[i])){\n                tem = tem * 2 + t[i] - '0';\n                i++;\n            }\n            if(st + 1 < i && t[st] == '0')return FAIL;\n            res.push(tem);\n            i--;\n            continue;\n        }\n        if(t[i] == '('){\n            op.push('(');\n            continue;\n        }\n        if(t[i] == ')'){\n            //cout <<l <<endl;\n            while(op.empty() == false && op.top() != '('){\n                bool flag = work(res, op);\n                if(flag == 0)return FAIL;\n            }\n            if(op.empty() == true)return FAIL;\n            op.pop();\n            continue;\n        }\n        while(op.empty() == false && pr[op.top()] >= pr[t[i]]){\n            bool flag = work(res, op);\n            if(flag == 0)return FAIL;\n        }\n        op.push(t[i]);\n    }\n    while(!op.empty()){\n        bool flag = work(res, op);\n        if(flag == 0)return FAIL;\n    }\n    if(res.size() == 1)return make_pair(res.top(),1);\n    return FAIL;\n}\nbool check(){\n    for(int i = 0;i < n; ++i){\n        if(isalpha(s[i])){\n            t[i] = m[s[i]];\n        }else{\n            t[i] = s[i];\n        }\n    }\n    for(int i = 0;i < n; ++i){\n        if(t[i] != '-')continue;\n        if(i && (t[i - 1] == ')' || isdigit(t[i - 1]))){\n            continue;\n        }\n        t[i] = '#';\n    }\n    if(t[0] == '=' || t[n - 1] == '=')return 0;\n    int equal = 0,pos = -1;\n    for(int i = 0;i < n; ++i){\n        if(t[i] == '='){\n            equal++;\n            pos = i;\n        }\n    }\n    if(equal != 1)return 0;\n    pair<LL,bool> left = get(0,pos);\n    if(left.second == false)return 0;\n    pair<LL,bool> righ = get(pos + 1,n);\n    //cout << left.first<<\"  \"<<righ.first<<endl;\n    if(righ.second == false)return 0;\n    return left == righ;\n}\nvoid dfs(int o){\n    if(o == n){\n        ans += check();\n        return;\n    }\n    if(isalpha(s[o])){\n        if(m.find(s[o]) != m.end()){\n            dfs(o + 1);\n        }else{\n            for(int i = 0;i < 8; ++i){\n                if(m.find(a[i]) != m.end())continue;\n                m[s[o]] = a[i];\n                m[a[i]] = s[o];\n                dfs(o + 1);\n                m.erase(s[o]);\n                m.erase(a[i]);\n            }\n        }\n        \n    }else{\n        t[o] = s[o];\n        dfs(o + 1);\n    }\n}\nint main(){\n    pr['('] = -1;\n    pr['*'] = 1;\n    pr['+'] = 0;\n    pr['-'] = 0;\n    pr[')'] = -1;\n    pr['#'] = 3;\n    scanf(\"%s\",s);\n    n = int(strlen(s));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nstring S;\n\nint ei(string::iterator &it,int r){\n    if(r==0){\n        vint lis;\n        while(it!=S.end()){\n            int x=ei(it,1);\n            if(*it!='='||x==INF)return INF;\n            lis.pb(x);\n            it++;\n        }\n        if(lis.size()!=2||lis[0]!=lis[1])return INF;\n        return 114514;\n    }\n\n    if(r==1){\n        int ret=ei(it,2);\n        if(ret==INF)return INF;\n        while(true){\n            if(*it=='+'){\n                it++;\n                int x=ei(it,2);\n                if(x==INF)return INF;\n                ret+=x;\n            }\n            else if(*it=='-'){\n                it++;\n                int x=ei(it,2);\n                if(x==INF)return INF;\n                ret-=x;\n            }\n            else break;\n        }\n        return ret;\n    }\n\n    if(r==2){\n        int ret=ei(it,3);\n        if(ret==INF)return INF;\n        while(true){\n            if(*it=='*'){\n                it++;\n                int x=ei(it,3);\n                if(x==INF)return INF;\n                ret*=x;\n            }\n            else break;\n        }\n        return ret;\n    }\n    if(r==3){\n        if(*it=='-'){\n            it++;\n            int x=ei(it,3);\n            if(x==INF)return INF;\n            return -x;\n        }\n        if(*it=='('){\n            it++;\n            int x=ei(it,1);\n            if(*it!=')')return INF;\n            it++;\n            if(x==INF)return INF;\n            return x;\n        }\n        return ei(it,4);\n    }\n\n    if(r==4){\n        bool f=*it=='0';\n        int ret=0;\n        while(isdigit(*it)){\n            ret=ret*2+*it-'0';\n            it++;\n        }\n        if(!f&&ret==0)return INF;\n        if(f&&ret!=0)return INF;\n        return ret;\n    }\n}\n\nsigned main(){\n    string s;cin>>s;\n\n    vector<char>v;\n    rep(i,s.size())if(isalpha(s[i]))v.pb(s[i]);\n    sort(all(v));v.erase(unique(all(v)),v.end());\n\n    if(v.size()>8){\n        cout<<0<<endl;\n        return 0;\n    }\n\n    string x=\"+-*()=01\";\n    sort(all(x));\n\n    int ans=0;\n\n\n    set<string>st;\n    do{\n        S=s;\n        rep(i,S.size()){\n            if(isalpha(S[i])){\n                int k=lower_bound(all(v),S[i])-v.begin();\n                S[i]=x[k];\n            }\n        }\n        S+=\"=\";\n        auto it=S.begin();\n        if(ei(it,0)!=INF){\n            ans++;\n        }\n    }while(next_permutation(all(x)));\n\n\n    rep(i,(int)x.size()-(int)v.size())ans/=i+1;\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string &str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\tState state = str.begin();\n\tif (!isE(str, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(str, m, state, str.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string &str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = str.begin();\n\tlhs = E(str, m, state, state + index);\n\tstate++;\n\trhs = E(str, m, state, str.end());\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tcout << check(\"10=-0*10\", m) << endl;\n\tstring dummy = \"(-0)\";\n\tcout << \"xo\"[isT(dummy, m, dummy.begin(), dummy.end())] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m) && check(str, m)) {\n\t\t\tans++;\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nstring::iterator p;\nint fact();\nint term();\nint exp();\nint k;\nbool f[2];\n\nint fact() {\n  int x;string num;\n  int mi=1;\n  while(*p=='-') {\n    mi*=-1;\n    ++p;\n  }\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()>1&&num[0]=='0') f[k]=0;\n  if(num.size()) {\n    x=0;\n    for(int i=num.size()-1,j=0; i>=0; i--,j++) x+=(1<<j)*(num[i]=='1');\n  } else if(p!=s[k].end()){\n    if(*p!='(') f[k]=0;\n    bool ff=(*p=='(');\n    if(p!=s[k].end()&&*p=='(')++p;\n    x=exp();\n    if(ff&&*p!=')') f[k]=0;\n    if(p!=s[k].end()&&*p==')')++p;\n  } else f[k]=0;\n  return x*mi;\n}\n \nint term() {\n  int x=fact();\n  while(*p=='*') {\n    ++p;\n    x*=fact();\n  }\n  return x;\n}\n \nint exp() {\n  int x=term();\n  while(*p=='+'||*p=='-') {\n    if(*p=='+') {\n      ++p;\n      x+=term();\n    } else {\n      ++p;\n      x-=term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  string r=\"01+-*()=\";\n  sort(r.begin(),r.end());\n  string t;\n  cin >> t;\n  map<char,int> m;\n  for(int i=0; i<t.size(); i++) {\n    if(isalpha(t[i])&&!m.count(t[i])) {\n      int x=m.size();\n      m[t[i]]=x;\n    }\n  }\n  if(m.size()>r.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<string> se;\n  do {\n    string e=t;\n    for(int i=0; i<e.size(); i++) {\n      if(isalpha(e[i])) e[i]=r[m[e[i]]];\n    }\n    int c=0;\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') c++;\n    }\n    if(c!=1) continue;\n    c=0;\n    s[0]=s[1]=\"\";\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') {\n        c++;\n        continue;\n      }\n      s[c]+=e[i];\n    }\n    if(!s[0].size()||!s[1].size()) continue;\n    int x[2]={0,0};\n    for(k=0; k<2; k++) {\n      f[k]=1;\n      p=s[k].begin();\n      int d=0,z=0;\n      for(int i=0; i<s[k].size(); i++) {\n        if(isdigit(s[k][i])) z++;\n        if(s[k][i]=='(') {\n          d++;\n          if(i&&(isdigit(s[k][i-1])||s[k][i-1]==')')) f[k]=0;\n          if(i!=s[k].size()-1&&(!isdigit(s[k][i+1])&&s[k][i+1]!='('&&s[k][i+1]!='-')) f[k]=0;\n        }\n        if(s[k][i]==')') {\n          d--;\n          if(i&&(!isdigit(s[k][i-1])&&s[k][i-1]!=')')) f[k]=0;\n          if(i!=s[k].size()-1&&isdigit(s[k][i+1])) f[k]=0;\n        }\n        if(i) {\n          if(s[k][i]=='+'||s[k][i]=='*') {\n            if(s[k][i-1]=='+'||s[k][i-1]=='*'||s[k][i-1]=='-') f[k]=0;\n          }\n        } else if(s[k][i]=='+'||s[k][i]=='*') f[k]=0;\n        if(d<0) f[k]=0;\n      }\n      if(d||!z) f[k]=0;\n      if(f[k]) x[k]=exp();\n    }\n    if(f[0]&&f[1]&&x[0]==x[1]) {\n      se.insert(r.substr(0,m.size()));\n    }\n  } while(next_permutation(r.begin(),r.end()));\n  cout << se.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 10) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 12) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nbool flag;\n\nint B(string &s, int &n){\n\tint ret = 1;\n\twhile(1){\n\t\tif( s.size() <= n ){ break; }\n\t\telse if( s[n] == '0' ){ n++; ret<<=1; }\n\t\telse if( s[n] == '1' ){ n++; ret<<=1; ret += 1; }\n\t\telse { break; }\n\t}\n\t//cout << \"B \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint N(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\telse if( s[n] == '0' ){ n++; return 0; }\n\telse if( s[n] == '1' ){ n++; return B(s, n); }\n\tflag = false;\n\t//cout << \"flag N\" << endl;\n\treturn 0;\n}\n\nint E(string &s, int &n);\nint F(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\tint ret;\n\tif( s[n] == '0' || s[n] == '1' ){ ret = N(s, n); }\n\telse if( s[n] == '-' ){ n++; ret = -F(s, n); }\n\telse if( s[n] == '(' ){\n\t\tn++;\n\t\tret = E(s, n);\n\t\tif( s[n] == ')' ) n++;\n\t\telse flag = false;\n\t} else {\n\t\t//cout << \"flag F\" << endl;\n\t\tflag = false;\n\t}\n\t//cout << \"F \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint T(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\tint ret = F(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '*' ){ n++; ret += T(s, n); }\n\telse if( s[n] == '+' || s[n] == '-' || s[n] == '=' || s[n] == ')' );\n\telse flag = false;\n\t//cout << \"T \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint E(string &s, int &n){\n\tint ret = T(s,n);\n\tif( s.size() <= n ){ return ret; }\n\telse if( s[n] == '+' ){ n++; ret += E(s, n); }\n\telse if( s[n] == '-' ){ n++; ret -= E(s, n); }\n\telse if( s[n] == '=' ){ }\n\telse if( s[n] == ')' ){ }\n\telse flag = false;\n\t//cout << \"E \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nbool Q(string &s){\n\tflag = true;\n\tint n=0;\n\tint l = E(s,n);\n\t//cout << \"l = \" << l << endl;\n\tif( s[n] != '=' ) return false;\n\t//cout << \"n++\" << endl;\n\tn++;\n\tif( s.size() <= n ) return false;\n\tint r = E(s,n);\n\t//cout << \"r = \" << r << endl;\n\tif( s.size() != n ) flag = false;\n\treturn flag && l == r;\n}\n\nvector<char> ope = {'0', '1', '+', '-', '*', '(', ')', '='};\nint main(){\n\tset<string> ans;\n\tstring S;\n\tcin >> S;\n\t\n\t//cout << Q(S) << endl;\n\t//return 0;\n\t\n\tvector<char> v;\n\tfor(char c: S){\n\t\tif( 'A' <= c && c <= 'Z' ) v.push_back(c);\n\t\tif( 'a' <= c && c <= 'z' ) v.push_back(c);\n\t}\n\tv.erase( unique(all(v)), v.end() );\n\tif( v.size() > 8 ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tsort( all(ope) );\n\tdo{\n\t\tchar mp[256]={};\n\t\trep(i,v.size()) mp[v[i]] = ope[i];\n\t\tstring s;\n\t\tfor(char c: S) s += mp[c] ? mp[c] : c ;\n\t\t//cout << s << endl;\n\t\tif( Q(s) ) ans.insert(s);\n\t}while( next_permutation(all(ope)) );\n\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring temp = \"01+-*()=\";\nconst int INF = 1 << 30;\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw(0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nint main()\n{\n  sort(begin(temp), end(temp));\n\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) if(isalpha(c)) num.push_back(c);\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > 6) {\n    cout << 0 << endl;\n    return (0);\n  }\n\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L, R;\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\nint ans;\nstring s;\n\n\nll exp(State &begin);\n\n\n\nll bin(State &begin){\n\tll ret=0;\n\t\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\n\nll number(State &begin){\n\tif(*begin=='0'){\n\t\tbegin++;\n\t\tif(isdigit(*begin))throw \"number error1\";\n\t\telse return 0;\n\t}\n\telse if(*begin=='1'){\n\t\treturn bin(begin);\n\t}else throw \"number error2\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nll factor(State &begin){\n\tif( isdigit(*begin) )return number(begin);\n\telse if(*begin=='-'){\n\t\tint minus=0;\n\t\twhile(*begin=='-'){\n\t\t\tminus++;\n\t\t\tbegin++;\n\t\t}\n\t\tif(isdigit(*begin))return -(minus%2)*number(begin);\n\t\telse if(*begin=='(')return -(minus%2)*exp(begin);\n\t\telse throw \"factor error1\";\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tll ret = exp(begin);\n\t\tif(*begin!=')')throw \"factor error2\";\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse throw \"factor error3\";\n\tassert(1);\n\treturn -1;\n}\n\n\nll term(State &begin){\n\tll ret = factor(begin);\n\t\n\tif(*begin=='+'||*begin=='-'||*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}\n\telse if(*begin=='*'){\n\t\tbegin++;\n\t\treturn ret*term(begin);\n\t}\n\telse throw \"term error\";\n\t\n\tassert(1);\n\treturn -1;\n\t\n}\n\n\nll exp(State &begin){\n\tll ret = term(begin);\n\t\n\tif(*begin=='+'){\n\t\tbegin++;\n\t\treturn ret+exp(begin);\n\t}else if(*begin=='-'){\n\t\tbegin++;\n\t\treturn ret-exp(begin);\n\t}else if(*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}else throw \"exp error\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nbool isValid(string tmp){\n\tint eqc=0;\n\trep(i,tmp.size())if(tmp[i]=='=')eqc++;\n\tif(eqc!=1)return false;\n\t\n\tstring str[2]={};\n\tbool f=false;\n\trep(i,tmp.size()){\n\t\tif(tmp[i]=='=')f=true;\n\t\telse if(f)str[1]+=tmp[i];\n\t\telse str[0]+=tmp[i];\n\t}\n\tif(str[0].size()==0||str[1].size()==0)return false;\n\t\n\tState b[2];\n\tll res[2];\n\ttry{\n\t\trep(i,2){\n\t\t\tstr[i] +='$';\n\t\t\tb[i] = str[i].begin();\n\t\t\tres[i] = exp(b[i]);\n\t\t}\n\t}catch(char const* e){\n\t\treturn false;\n\t}\n\tif(res[0]==res[1] && *b[0]=='$'&&*b[1]=='$'){\n\t\treturn true;\n\t}else return false;\n}\n\nvoid dfs(string tmp,vector<bool> used){\n\tchar alp='!';\n\tint pos=-1;\n\trep(i,tmp.size()){\n\t\tif(isalpha(tmp[i]))alp=tmp[i],pos=i;\n\t}\n\tif(pos==-1){ if(isValid(tmp))ans++; return; }\n\t\n\tassert(alp!='!');\n\tstring symbols = \"01+-*()=\";\n\trep(i,symbols.size()){\n\t\tif(used[i])continue;\n\t\tused[i]=true;\n\t\tstring ntmp = tmp;\n\t\trep(j,ntmp.size()){\n\t\t\tif(ntmp[j]==alp) ntmp[j] = symbols[i];\n\t\t}\n\t\tdfs(ntmp,used);\n\t\tused[i]=false;\n\t}\n}\n\n\nint main(){\n\tcin>>s;\n\tset<char> st;\n\tvector<char> vs;\n\t\n\trep(i,s.size())st.insert(s[i]);\n\tint c=0;\n\tfor(auto &e:st)vs.pb(e);\n\t\n\tint count=0;\n\trep(i,vs.size())if(isalpha(vs[i]))count++;\n\tif(count>8){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tans=0;\n\tvector<bool> used(8,false);\n\tdfs(s,used);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint Q(int&);\nint E(int&);\nint T(int&);\nint F(int&);\n\nstring S;\nint N;\n\nint err = 0;\nstring gs;\nint Q(int& p){\n  int l = E(p);\n  if(err || p >= N || gs[p] != '='){\n\terr = 1;\n\treturn 0;\n  }\n  ++p;\n  int r = E(p);\n  if(err || p != N){\n\terr = 1;\n\treturn 0;\n  }\n  return l == r;\n}\n\nint E(int& p){\n  int x = T(p);\n  while(p < N){\n    if(gs[p] == '+'){\n      ++p;\n      x += T(p);\n    }\n    else if(gs[p] == '-'){\n      ++p;\n      x -= T(p);\n    }\n    else\n      break;\n  }\n  return x;\n}\n \nint T(int& p){\n  int x = F(p);\n  while(p < N){\n    if(gs[p] == '*'){\n      ++p;\n      x *= F(p);\n    }\n    else\n      break;\n  }\n  return x;\n}\n\nint F(int& p){\n  if(err || p >= N){\n\terr = 1;\n\treturn 0;\n  }\n  int x = 0;\n  if(gs[p] == '-'){\n\t++p;\n\tx = -F(p);\n  }\n  else if(gs[p] == '('){\n\t++p;\n\tx = E(p);\n\tif(gs[p] != ')'){\n\t  err = 1;\n\t  return 0;\n\t}\n\t++p;\n  }\n  else if(gs[p] == '0'){\n\tx = 0;\n\t++p;\n  }\n  else if(gs[p] == '1'){\n\tx = 1;\n\t++p;\n\twhile(p<N){\n\t  if(gs[p] == '0')\n\t\tx *= 2;\n\t  else if(gs[p] == '1')\n\t\tx = x*2 + 1;\n\t  else\n\t\tbreak;\n\t  ++p;\n\t}\n  }\n  else{\n\terr = 1;\n\treturn 0;\n  }\n\n  return x;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n\n  set<char> s;\n\n  REP(i,N)\n\tif(('a' <= S[i] && S[i] <= 'z') || ('A' <= S[i] && S[i] <= 'Z'))\n\ts.insert(S[i]);\n  if(SZ(s) > 8){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  char cs[9] = \"+-*=()01\";\n  sort(cs, cs+8);\n\n  set<string> ans;\n  do{\n\tstring tmp = S;\n\tint j = 0;\n\tREP(i,N){\n\t  char c = tmp[i];\n\t  if(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')){\n\t\tREP(k,N)\n\t\t  if(tmp[k] == c)\n\t\t\ttmp[k] = cs[j];\n\t\t++j;\n\t  }\n\t}\n\tint p = 0;\n\terr = 0;\n\tgs = tmp;\n\tint flag = Q(p);\n\tif(flag && !err)\n\t  ans.insert(gs);\n  }while(next_permutation(cs, cs+8));\n\n  cout << SZ(ans) << endl;\n  for(auto&&s:ans)cout<<s<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(V) (V).begin(),(V).end()\n#define ALLR(V) (V).rbegin(),(V).rend()\n#define endl '\\n'\nusing namespace std;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\nusing TLL = tuple<ll, ll, ll>;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\n\nbool success;\nbool Q(const string &S, ll &idx);\nll E(const string &S, ll &idx);\nll T(const string &S, ll &idx);\nll F(const string &S, ll &idx);\nll N(const string &S, ll &idx);\n// ll B(const string &S, ll &idx);\n\nbool calc(const string &S) {\n    ll idx = 0;\n    success = true;\n    return Q(S, idx);\n}\n\nbool Q(const string &S, ll &idx) {\n    ll left = E(S, idx);\n    if(!success) return false;\n    if(!(idx < S.size() && S[idx] == '=')) return false;\n    idx++;\n    ll right = E(S, idx);\n    return idx == S.size() && success && left == right;\n}\n\nll E(const string &S, ll &idx) {\n    ll ret = T(S, idx);\n    while(true) {\n        if(S.size() <= idx) break;\n        if(S[idx] == '+') {\n            idx++;\n            ll r = T(S, idx);\n            ret += r;\n        } else if(S[idx] == '-') {\n            idx++;\n            ll r = T(S, idx);\n            ret -= r;\n        } else {\n            if(!(S[idx] == '=' || S[idx] == ')')) success = false;\n            break;\n        }\n    }\n    if(!success) return 0;\n    return ret;\n}\n\nll T(const string &S, ll &idx) {\n    ll ret = F(S, idx);\n    while(true) {\n        if(S.size() <= idx) break;\n        if(S[idx] == '*') {\n            idx++;\n            ll r = F(S, idx);\n            ret *= r;\n        } else {\n            if(!(S[idx] == '+' || S[idx] == '-' || S[idx] == '=' || S[idx] == ')')) success = false;\n            break;\n        }\n    }\n    if(!success) return 0;\n    return ret;\n}\n\nbool is_digit(char c) { return c == '0' || c == '1'; };\n\nll F(const string &S, ll &idx) {\n    if(S.size() <= idx) {\n        success = false;\n        return 0;\n    }\n    if(is_digit(S[idx])) return N(S, idx);\n    if(S[idx] == '-') {\n        idx++;\n        return -F(S, idx);\n    }\n    if(S[idx] == '(') {\n        idx++;\n        ll ret = E(S, idx);\n        if(!(idx < S.size() && S[idx] == ')')) success = false;\n        else idx++;\n        return ret;\n    }\n    success = false;\n    return 0;\n}\n\nll N(const string &S, ll &idx) {\n    static auto check = [](char c) {\n        return (c == '=' ||\n                c == '+' ||\n                c == '-' ||\n                c == '*' ||\n                c == ')');\n    };\n\n    if(!is_digit(S[idx])) {\n        success = false;\n        return 0;\n    }\n    if(S[idx] == '0') {\n        idx++;\n        return 0;\n    }\n    ll ret = S[idx] - '0';\n    idx++;\n    while(true) {\n        if(idx == S.size()) break;\n        if(is_digit(S[idx])) {\n            ret = ret * 2 + (S[idx] - '0');\n            idx++;\n        } else {\n            if(!check(S[idx])) success = false;\n            break;\n        }\n    }\n    return ret;\n}\n\nll alp2idx(char c) {\n    if('a' <= c && c <= 'z') return c - 'a';\n    if('A' <= c && c <= 'Z') return c - 'A' + 26;\n    assert(false);\n}\n\nint main() {\n    string S;\n    cin >> S;\n    ll cnt = 0;\n    V<char> alp_lis;\n    for(char c : S) {\n        if('a' <= c && c <= 'z') alp_lis.push_back(c);\n        if('A' <= c && c <= 'Z') alp_lis.push_back(c);\n    }\n    {\n        sort(ALL(alp_lis));\n        auto ite = unique(ALL(alp_lis));\n        alp_lis.erase(ite, alp_lis.end());\n    }\n    V<char> op_lis = { '0', '1', '+', '-', '*', '=', '(', ')' };\n    if(op_lis.size() < alp_lis.size()) {\n        cout << 0 << endl;\n        return 0;\n    }\n    sort(ALL(op_lis));\n    ll chr_idx[52] = {};\n    ll ans = 0;\n    for(ll i = 0; i < alp_lis.size(); i++) chr_idx[alp2idx(alp_lis[i])] = i;\n    do {\n        auto T = S;\n        for(char &c : T) {\n            if(!(('a' <= c && c <= 'z') ||\n                 ('A' <= c && c <= 'Z'))) continue;\n            ll idx = chr_idx[alp2idx(c)];\n            c = op_lis[idx];\n        }\n        auto tmp = calc(T);\n        ans += tmp;\n        // if(tmp) cout << T << endl;\n    } while(next_permutation(ALL(op_lis)));\n    for(ll i = 1; i < op_lis.size() - alp_lis.size(); i++) ans /= (i + 1);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint idx, len;\n\nint number();\nint factor();\nint term();\nint expression();\n\nint number(){\n    char c = f[idx++];\n    if(c != '0' and c != '1') throw 1;\n\n    if(c == '0') return 0;\n\n    int ret = 1;\n    while(idx < len and (f[idx] == '0' or f[idx] == '1')){\n        ret *= 2;\n        char c = f[idx++];\n        if(c == '1') ret += 1;\n    }\n    return ret;\n}\n\nint factor(){\n    int mcnt = 0;\n    while(idx < len and f[idx] == '-'){\n        mcnt++;\n        idx++;\n    }\n    if(idx >= len) throw 1;\n\n    int sign = (mcnt % 2 == 0 ? +1:-1);\n    if(f[idx] != '(') return sign * number();\n    idx++;\n\n    int ret = sign * expression();\n    if(idx >= len or f[idx] != ')') throw 1;\n    idx++;\n\n    return ret;\n}\n\nint term(){\n    int ret = factor();\n    while(idx < len and f[idx] == '*'){\n        idx++;\n        int rhs = factor();\n        ret *= rhs;\n    }\n    return ret;\n}\n\nint expression(){\n    int ret = term();\n    while(idx < len and (f[idx] == '+' or f[idx] == '-')){\n        char op = f[idx++];\n        int rhs = term();\n        switch(op){\n            case '+': { ret += rhs; break; }\n            case '-': { ret -= rhs; break; }\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    /*\n    while(cin >> f){\n        len = f.size(), idx = 0;\n        int ret = expression();\n        cerr << ret << \", idx = \" << idx << \", len = \" << len << endl;\n    }\n    return 0;\n    //*/\n\n    string in; cin >> in;\n    string T = \"01+-*()=\"; sort(_all(T));\n\n    set<string> s;\n    do {\n        map<char, bool> used;\n        map<char, char> c2t;\n        int j = 0;\n        f = in;\n        rep(i, in.size()){\n            char c = in[i];\n            if(not isupper(c) and not islower(c)) continue;\n\n            if(not used[c]){\n                used[c] = true;\n                assert(j < T.size());\n                c2t[c] = T[j++];\n            }\n            f[i] = c2t[c];\n        }\n\n        string equation = f;\n        string l, r;\n        rep(i, in.size()){\n            if(f[i] == '='){\n                l = f.substr(0, i);\n                r = f.substr(i + 1);\n                break;\n            }\n        }\n        if(l == \"\" or r == \"\") continue;\n\n        try {\n            idx = 0; f = l; len = f.size();\n            int lv = expression();\n            if(idx != len) continue;\n\n            idx = 0; f = r; len = f.size();\n            int rv = expression();\n            if(idx != len) continue;\n\n            if(lv != rv) continue;\n        }\n        catch(int e){\n            continue;\n        }\n        s.insert(equation);\n    } while(next_permutation(_all(T)));\n\n    for(auto& e : s){\n        cerr << e << endl;\n    }\n    cout << s.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nint main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\nint ans;\nstring s;\n\n\nll exp(State &begin);\n\n\n\nll bin(State &begin){\n\tll ret=0;\n\t\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\n\nll number(State &begin){\n\tif(*begin=='0'){\n\t\tbegin++;\n\t\tif(isdigit(*begin))throw \"number error1\";\n\t\telse return 0;\n\t}\n\telse if(*begin=='1'){\n\t\treturn bin(begin);\n\t}else throw \"number error2\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nll factor(State &begin){\n\tif( isdigit(*begin) )return number(begin);\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\tif(isdigit(*begin)||*begin=='('||*begin=='-') return -1*factor(begin);\n\t\telse throw \"factor error1\";\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tll ret = exp(begin);\n\t\tif(*begin!=')')throw \"factor error2\";\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse throw \"factor error3\";\n\tassert(1);\n\treturn -1;\n}\n\n\nll term(State &begin){\n\tll ret = factor(begin);\n\t\n\tif(*begin=='+'||*begin=='-'||*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}\n\telse if(*begin=='*'){\n\t\tbegin++;\n\t\treturn ret*term(begin);\n\t}\n\telse throw \"term error\";\n\t\n\tassert(1);\n\treturn -1;\n\t\n}\n\n\nll exp(State &begin){\n\tll ret = term(begin);\n\t\n\tif(*begin=='+'){\n\t\tbegin++;\n\t\treturn ret+exp(begin);\n\t}else if(*begin=='-'){\n\t\tbegin++;\n\t\treturn ret-exp(begin);\n\t}else if(*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}else throw \"exp error\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nbool isValid(string tmp){\n\tint eqc=0;\n\trep(i,tmp.size())if(tmp[i]=='=')eqc++;\n\tif(eqc!=1)return false;\n\t\n\tstring str[2]={};\n\tbool f=false;\n\trep(i,tmp.size()){\n\t\tif(tmp[i]=='=')f=true;\n\t\telse if(f)str[1]+=tmp[i];\n\t\telse str[0]+=tmp[i];\n\t}\n\tif(str[0].size()==0||str[1].size()==0)return false;\n\t\n\tState b[2];\n\tll res[2];\n\ttry{\n\t\trep(i,2){\n\t\t\tstr[i] +='$';\n\t\t\tb[i] = str[i].begin();\n\t\t\tres[i] = exp(b[i]);\n\t\t}\n\t}catch(char const* e){\n\t\treturn false;\n\t}\n\tif(res[0]==res[1] && *b[0]=='$'&&*b[1]=='$'){\n\t\treturn true;\n\t}else return false;\n}\n\nvoid dfs(string tmp,vector<bool> used){\n\tchar alp='!';\n\tint pos=-1;\n\trep(i,tmp.size()){\n\t\tif(isalpha(tmp[i]))alp=tmp[i],pos=i;\n\t}\n\tif(pos==-1){ if(isValid(tmp))ans++; return; }\n\t\n\tassert(alp!='!');\n\tstring symbols = \"01+-*()=\";\n\trep(i,symbols.size()){\n\t\tif(used[i])continue;\n\t\tused[i]=true;\n\t\tstring ntmp = tmp;\n\t\trep(j,ntmp.size()){\n\t\t\tif(ntmp[j]==alp) ntmp[j] = symbols[i];\n\t\t}\n\t\tdfs(ntmp,used);\n\t\tused[i]=false;\n\t}\n}\n\n\nint main(){\n\tcin>>s;\n\tset<char> st;\n\tvector<char> vs;\n\t\n\trep(i,s.size())st.insert(s[i]);\n\tfor(auto &e:st)vs.pb(e);\n\t\n\tint count=0;\n\trep(i,vs.size())if(isalpha(vs[i]))count++;\n\tif(count>8){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tans=0;\n\tvector<bool> used(8,false);\n\tdfs(s,used);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\npair<string, string> split(const string &s) {\n  int p = s.find('=');\n  string l = s.substr(0, p);\n  string r = s.substr(p + 1);\n  return make_pair(l, r);\n}\nbool check(const string &s) {\n  int p = s.find('=');\n  if(p == -1) return false;\n  pair<string, string> sp = split(s);\n  if(sp.first.size() == 0 || sp.second.size() == 0) return false;\n  int k = 0;\n  for(char c : sp.first) {\n    if(c == '(') ++k;\n    if(c == ')') --k;\n    if(k < 0) return false;\n  }\n  if(k != 0) return false;\n  for(char c : sp.second) {\n    if(c == '(') ++k;\n    if(c == ')') --k;\n    if(k < 0) return false;\n  }\n  return true;\n}\ntypedef string::const_iterator iter;\nstruct Result {\n  bool valid;\n  int value;\n  Result(bool valid_, int value_) : valid(valid_), value(value_) {}\n};\nResult fail(false, 114514);\nbool Q(iter &p);\nResult E(iter &p);\nResult T(iter &p);\nResult F(iter &p);\nResult N(iter &p);\nResult B(iter &p);\nbool Q(iter &p) {\n  Result l = E(p);\n  // if(!l.valid) {\n  //   cerr << \"l = No\" << endl;\n  // }\n  // else {\n  //   cerr << \"l = \" << l.value << endl;\n  // }\n  if(!l.valid) return false;\n  if(*p != '=') return false;\n  ++p;\n  Result r = E(p);\n  // if(!l.valid) {\n  //   cerr << \"r = No\" << endl;\n  // }\n  // else {\n  //   cerr << \"r = \" << r.value << endl;\n  // }\n  if(!r.valid) return false;\n  if(*p != '\\0') return false;\n  return l.value == r.value;\n}\nResult E(iter &p) {\n  Result t = T(p);\n  if(!t.valid) return fail;\n  while(true) {\n    if(*p == '+') {\n      ++p;\n      Result s = T(p);\n      if(!s.valid) return fail;\n      t.value += s.value;\n    }\n    else if(*p == '-') {\n      ++p;\n      Result s = T(p);\n      if(!s.valid) return fail;\n      t.value -= s.value;\n    }\n    else {\n      break;\n    }\n  }\n  return t;\n}\nResult T(iter &p) {\n  Result t = F(p);\n  if(!t.valid) return fail;\n  while(true) {\n    if(*p == '*') {\n      ++p;\n      Result s = F(p);\n      if(!s.valid) return fail;\n      t.value *= s.value;\n    }\n    else {\n      break;\n    }\n  }\n  return t;\n}\nResult F(iter &p) {\n  if(*p == '(') {\n    ++p;\n    Result e = E(p);\n    if(*p != ')') {\n      return fail;\n    }\n    ++p;\n    return e;\n  }\n  else if(*p == '-') {\n    ++p;\n    Result e = F(p);\n    if(!e.valid) return fail;\n    e.value *= -1;\n    return e;\n  }\n  return N(p);\n}\nResult N(iter &p) {\n  if(!isdigit(*p)) {\n    return fail;\n  }\n  int n = 0;\n  int i = 0;\n  while(isdigit(*p)) {\n    n *= 2;\n    if(i > 0 && n == 0) return fail;\n    n += *p - '0';\n    ++p;\n    ++i;\n  }\n  // DEBUG(n);\n  return Result(true, n);\n}\nvoid dbg() {\n  string S; cin >> S;\n  iter p = S.cbegin();\n  bool r = Q(p);\n  cout << (r ? \"Yes\" : \"No\") << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  if(false) {\n    dbg();\n  }\n  else {\n    string S; cin >> S;\n    vector<char> ch;\n    string ops = \"01+-*=()\";\n    sort(ops.begin(), ops.end());\n    REP(i,S.size()) {\n      if(ops.find(S[i]) == string::npos) {\n        ch.push_back(S[i]);\n      }\n    }\n    sort(ch.begin(), ch.end());\n    ch.erase(unique(ch.begin(), ch.end()), ch.end());\n    if(ch.size() > 8) {\n      cout << 0 << endl;\n      return 0;\n    }\n    map<char, int> replacer;\n    REP(i,ch.size()) {\n      replacer[ch[i]] = i;\n      // DEBUG(ch[i]);\n    }\n    set<string> ans;\n    do {\n      string T = S;\n      REP(i,T.size()) {\n        if(replacer.count(T[i])) T[i] = ops[replacer[T[i]]];\n      }\n      // if(T == \"-0=(0)\") DEBUG(T);\n      iter p = T.cbegin();\n      bool r = Q(p);\n      if(r) {\n        ans.insert(ops.substr(0,ch.size()));\n        // DEBUG(T);\n      }\n    } while(next_permutation(ops.begin(), ops.end()));\n    cout << ans.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State &end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State &end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State &end);\n\nbool isF(string &str, map<char, char> &m, State &state, State &end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State &end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State &end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string &str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\tState state = str.begin();\n\tif (!isE(str, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(str, m, state, str.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State &end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State &end);\n\nint F(string &str, map<char, char> &m, State &state, State &end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State &end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State &end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string &str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = str.begin();\n\tlhs = E(str, m, state, state + index);\n\tstate++;\n\trhs = E(str, m, state, str.end());\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tcout << check(\"10=-0*10\", m) << endl;\n\tstring dummy = \"(-0)\";\n\tcout << \"xo\"[isT(dummy, m, dummy.begin(), dummy.end())] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m) && check(str, m)) {\n\t\t\tans++;\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[8];\nint used[8];\nint res;\nmap<char,int> mp;\nstring keydata=\"01()+-*=\";\n\n\nint expression(State &begin);\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='-'){\n\t\tbegin++;\n\t\tint ret;\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tret=-expression(begin);\n\t\t\tbegin++;\n\t\t}else{\n\t\t\tret=-number(begin);\n\t\t}\n\t\treturn ret;\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nbool check(string s){\n\tint cc=0;\n\tbool bnum=false;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='-'){\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i==0)continue;\n\t\t}\n\t\tif(s[i]=='+' || s[i]=='*'){\n\t\t\tif(i==0 || i+1==s.size())return false;\n\t\t\tif(!(isdigit(s[i-1]) || s[i-1]==')'))return false;\n\t\t}\n\t\tif(s[i]=='('){\n\t\t\tcc++;\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i>=1 && (s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t}\n\t\tif(isdigit(s[i])){\n\t\t\tif(i>=1 && (s[i-1]==')'))return false;\n\t\t\tif(s[i]=='0'){\n\t\t\t\tif(i>=1 && isdigit(s[i-1]))continue;\n\t\t\t\tif(i<s.size() && isdigit(s[i+1]))return false;\n\t\t\t}\n\t\t}\n\t\tif(s[i]==')'){\n\t\t\tif(cc==0)return false;\n\t\t\tif(s[i-1]=='(')return false;\n\t\t\tif(!(s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t\tcc--;\n\t\t}\n\t}\n\tif(cc!=0)return false;\n\treturn true;\n}\n\nstring str;\n\nvoid dfs(int v){\n\tif(v==mp.size()){\n\t\tstring tmp=\"\";\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\t\tint va=mp[str[i]];\n\t\t\t\ttmp+=keydata[data[va-1]];\n\t\t\t}else{\n\t\t\t\ttmp+=str[i];\n\t\t\t}\n\t\t}\n\t\tstring s1=\"\";\n\t\tstring s2=\"\";\n\t\tbool eq=false;\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tif(tmp[i]=='='){\n\t\t\t\tif(eq)return;\n\t\t\t\teq=true;\n\t\t\t}else{\n\t\t\t\tif(!eq)s1+=tmp[i];\n\t\t\t\telse s2+=tmp[i];\n\t\t\t}\n\t\t}\n\t\tif(!check(s1) || s1.size()==0)return;\n\t\tif(!check(s2) || s2.size()==0)return;\n\t\tState s=s1.begin();\n\t\tint val=expression(s);\n\t\ts=s2.begin();\n\t\tint val2=expression(s);\n\t\tif(val==val2){\n\t\t\tres++;\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(used[i]==0){\n\t\t\t\tused[i]=1;\n\t\t\t\tdata[v]=i;\n\t\t\t\tdfs(v+1);\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> str;\n\tfor(int i=0;i<str.size();i++){\n\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\tif(mp.find(str[i])==mp.end()){\n\t\t\t\tmp[str[i]]=mp.size();\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\nstring S=\"()01+-*=\";\n\nbool flag=false;\n\n#define NONE -1\nint n;\nstring s;\nint F(int &id);\nint E(int &id);\n\nint getnum(int &id){\n    int cnt=0,num=0;\n    bool firstzero=s[id]=='0';\n    while(id<n&&(s[id]=='0'||s[id]=='1')){\n        num*=2;\n        num+=(s[id]-'0');\n        id++;\n        cnt++;\n    }\n    if(firstzero&&cnt>1){\n        flag=false;\n    }\n    return num;\n}\n\nint F(int &id){\n    if(id<n){\n        if(s[id]=='0'||s[id]=='1')return getnum(id);\n        else if(s[id]=='('){\n                id++;\n                int num=E(id);\n                if(id<n&&s[id]==')'){\n                    id++;\n                    return num;\n                }\n        }\n        else if(s[id]=='-'){\n            id++;\n            return -F(id);\n        }\n    }\n    flag=false;\n    return 0;\n}\nint T(int &id){\n    int sum=1;\n    if(s[id]=='('||s[id]=='-'||s[id]=='0'||s[id]=='1')sum*=F(id);\n    else{\n        flag=false;\n        return 0;\n    }\n    if(!flag)return false;\n    if(id==n||s[id]==')'||s[id]=='='||s[id]=='+'||s[id]=='-'){\n        return sum;\n    }\n    if(s[id]=='*'){\n        id++;\n        return sum*T(id);\n    }\n    else{\n        flag=false;\n        return 0;\n    }    \n\n}\nint E(int &id){\n    int sum=0;\n    if(s[id]=='('||s[id]=='-'||s[id]=='0'||s[id]=='1')sum+=T(id);\n    else{\n        flag=false;\n        return 0;\n    }\n    if(!flag)return false;\n    if(id==n||s[id]==')'||s[id]=='='){\n        return sum;\n    }\n    if(s[id]=='+'){\n        id++;\n        return sum+E(id);\n    }\n    else if(s[id]=='-'){\n        id++;\n        return sum-E(id);\n    }\n    else{\n        flag=false;\n        return 0;\n    }    \n}\n\nbool Q(){\n    int L,R;flag=true;\n    int eq=NONE,id;\n    REP(i,n){\n        if(s[i]=='='){\n            if(eq==NONE)\n                eq=i;\n            else\n                return false;\n        }\n    }\n    if(eq==NONE)return false;\n    L=E(id=0);\n    if(!flag||id!=eq)return false;\n    R=E(id=eq+1);\n    if(!flag||id!=n)return false;\n    return L==R;\n}\nint main(){\n    flag=true;\n    map<char,int> m;\n    string input;\n    cin>>input;\n    n=input.size();\n    s=input;\n    REP(i,n){\n        bool exist=false;\n        REP(j,8)if(s[i]==S[j])exist=true;\n        if(!exist)m[s[i]]=0;\n    }\n    int cnt=0;\n    for(auto &it:m)it.second=cnt++;\n    if(cnt>8){\n        cout<<0<<endl;\n        return 0;\n    }\n    set<string> all;\n    vector<int> ord(8);\n    iota(ord.begin(),ord.end(),0);\n    do{\n        REP(i,n){\n            if(m.count(input[i]))\n                s[i]=S[ord[m[input[i]]]];   \n        }\n        all.insert(s);\n    }while(next_permutation(ord.begin(),ord.end()));\n    \n    int res=0;\n    for(auto &it:all){\n        s=it;\n        if(Q())res++;\n    \n    }\n    cout<<res<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nbool try_consume(char c) {\n  if(S[idx] != c) return false;\n  idx ++;\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  if(!try_consume('1')) return -inf;\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    int f = F();\n    if(f == -inf) return -inf;\n    return -f;\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    if(!try_consume(')')) return -inf;\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  if(num1 == -inf) return -inf;\n  while(try_consume('*')) {\n    int num2 = F();\n    if(num2 == -inf) return -inf;\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  if(term1 == -inf) return -inf;\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      if(term2 == -inf) return -inf;\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      if(term2 == -inf) return -inf;\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  if(expr1 == -inf) return false;\n  if(!try_consume('=')) return false;\n  int expr2 = E();\n  if(expr2 == -inf) return false;\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      ans += Q();\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 10) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\n\nstruct Parser{\n\tstring s;\n\tint N;\n\tint c;\n\n\tll parse(string s){\n\t\tthis->s = s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\ttry{\n\t\t\tll ret = expr();\n\t\t\tif(c != N) throw \"\";\n\t\t\treturn ret;\n\t\t}\n\t\tcatch(...){\n\t\t\treturn INF;\n\t\t}\n\t}\n\n\tvoid debug(string text){\n\t\treturn;\n\t\tcout << text + \" \";\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\t\telse cout << s[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tll expr(){\n\t\tdebug(\"expr\");\n\t\tll x = term();\n\t\twhile(c < N){\n\t\t\tif(s[c] == '+'){\n\t\t\t\tc++;\n\t\t\t\tx += term();\n\t\t\t}\n\t\t\telse if(s[c] == '-'){\n\t\t\t\tc++;\n\t\t\t\tx -= term();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll term(){\n\t\tdebug(\"term\");\n\t\tll x = factor();\n\t\twhile(c < N){\n\t\t\tif(s[c] == '*'){\n\t\t\t\tc++;\n\t\t\t\tx *= factor();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll factor(){\n\t\tdebug(\"factor\");\n\t\tif(s[c] == '-'){\n\t\t\tc++;\n\t\t\treturn -factor();\n\t\t}\n\t\tif(s[c] == '('){\n\t\t\tc++;\n\t\t\tll ret = expr();\n\t\t\tif(s[c] != ')') throw \"\";\n\t\t\t//assert(s[c] == ')');\n\t\t\tc++;\n\t\t\treturn ret;\n\t\t}\n\t\treturn num();\n\t}\n\n\tll num(){\n\t\tdebug(\"num\");\n\t\tif(!isdigit(s[c])) throw \"\";\n\t\tll ret = 0;\n\t\tstring digit;\n\t\twhile(c < N && isdigit(s[c])){\n\t\t\tret = ret * 2 + s[c] - '0';\n\t\t\tdigit += s[c];\n\t\t\tc++;\n\t\t}\n\t\tif(digit != \"0\" && digit[0] == '0') throw \"\";\n\t\treturn ret;\n\t}\n} parser;\n\nstring s;\nint ans;\n\nvector<char> cs;\nstring op = \"01+-*()=\";\nint used[10];\nmap<char, char> m;\n\nvoid dfs(int n){\n\tif(n == cs.size()){\n\t\tstring t = s;\n\t\tfor(int i = 0; i < t.size(); i++){\n\t\t\tif(m.count(t[i])) t[i] = m[t[i]];\n\t\t}\n\t\tint eq = t.find('=');\n\t\tif(eq == string::npos) return;\n\t\tstring e1 = t.substr(0, eq);\n\t\tstring e2 = t.substr(eq + 1);\n\t\tif(e1 == \"\" || e2 == \"\") return;\n\t\tll res1 = parser.parse(e1), res2 = parser.parse(e2);\n\t\tif(res1 != INF && res2 != INF && res1 == res2){\n\t\t\tans++;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < op.size(); i++){\n\t\tif(used[i]) continue;\n\t\tused[i] = 1;\n\t\tm[cs[n]] = op[i];\n\t\tdfs(n + 1);\n\t\tused[i] = 0;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> s){\n\t\tcs.clear();\n\t\tfor(auto c : s){\n\t\t\tif(isalpha(c)) cs.push_back(c);\n\t\t}\n\t\tsort(cs.begin(), cs.end());\n\t\tcs.erase(unique(cs.begin(), cs.end()), cs.end());\n\t\tm.clear();\n\n\t\tans = 0;\n\t\tdfs(0);\n\t\t//cout << s << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint Q(int&);\nint E(int&);\nint T(int&);\nint F(int&);\n\nstring S;\nint N;\n\nint err = 0;\nstring gs;\nint Q(int& p){\n  int l = E(p);\n  if(err || p >= N || gs[p] != '='){\n\terr = 1;\n\treturn 0;\n  }\n  ++p;\n  int r = E(p);\n  if(err || p != N){\n\terr = 1;\n\treturn 0;\n  }\n  return l == r;\n}\n\nint E(int& p){\n  if(err) return 0;\n  \n  int x = T(p);\n  if(p >= N) return x;\n  \n  if(gs[p] == '+'){\n\t++p;\n\tx += E(p);\n  }\n  else if(gs[p] == '-'){\n\t++p;\n\tx -= E(p);\n  }\n\n  return x;\n}\n\nint T(int& p){\n  if(err) return 0;\n  \n  int x = F(p);\n  if(p >= N) return x;\n  \n  if(gs[p] == '*'){\n\t++p;\n\tx *= T(p);\n  }\n\n  return x;\n}\n\nint F(int& p){\n  if(err || p >= N){\n\terr = 1;\n\treturn 0;\n  }\n  int x = 0;\n  if(gs[p] == '-'){\n\t++p;\n\tx = -F(p);\n  }\n  else if(gs[p] == '('){\n\t++p;\n\tx = E(p);\n\tif(gs[p] != ')'){\n\t  err = 1;\n\t  return 0;\n\t}\n\t++p;\n  }\n  else if(gs[p] == '0'){\n\tx = 0;\n\t++p;\n  }\n  else if(gs[p] == '1'){\n\tx = 1;\n\t++p;\n\twhile(p<N){\n\t  if(gs[p] == '0')\n\t\tx *= 2;\n\t  else if(gs[p] == '1')\n\t\tx = x*2 + 1;\n\t  else\n\t\tbreak;\n\t  ++p;\n\t}\n  }\n  else{\n\terr = 1;\n\treturn 0;\n  }\n\n  return x;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n\n  set<char> s;\n  REP(i,N) s.insert(S[i]);\n  if(SZ(s) > 8){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  char cs[9] = \"+-*=()01\";\n  sort(cs, cs+8);\n\n  set<string> ans;\n  do{\n\tstring tmp = S;\n\tint j = 0;\n\tREP(i,N){\n\t  char c = tmp[i];\n\t  if(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')){\n\t\tREP(k,N)\n\t\t  if(tmp[k] == c)\n\t\t\ttmp[k] = cs[j];\n\t\t++j;\n\t  }\n\t}\n\tint p = 0;\n\terr = 0;\n\tgs = tmp;\n\tint flag = Q(p);\n\tif(flag && !err)\n\t  ans.insert(gs);\n  }while(next_permutation(cs, cs+8));\n\n  cout << SZ(ans) << endl;\n  //for(auto&&s:ans)cout<<s<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 15) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdexcept>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw exception();\n  if(S[idx] != c) throw exception();\n  idx ++;\n}\n\nbool try_consume(char c) {\n  try {\n    consume(c);\n  } catch(exception e) {\n    return false;\n  }\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (exception e) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  if(str[now+1]=='+'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t+p;\n  }\n  if(str[now+1]=='-'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t-p;\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size() + mm.size()>8 || m.size() + mm.size() <2){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do { //next_permutation moji\n    bool flg=true;\n\n    string newstr(s);\n    int idx=0;\n    if(flg){\n      for(auto c : m){\n        // str?????????c???moji[idx]???????????????\n        rep(i, newstr.size()) if(newstr[i]==c){\n          newstr[i] = moji[idx];\n        }\n        idx++;\n      }\n    }\n    idx = newstr.find('=');\n    if(newstr[0]=='=' || idx<0) flg=false;\n\n    if(flg){\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\nusing namespace std;\ntypedef long long ll;\nconst ll NO=1e15;\nll ex(const string& s,int& it);\n\nll dig(const string& s,int &it){\n\tif(s[it]=='0'&&isdigit(s[it+1])) return NO;\n\tll x=0;\n\twhile(isdigit(s[it])){\n\t\tx=x*2+s[it]-'0';\n\t\tit++;\n\t}\n\treturn x;\n}\nll fac(const string& s,int& it){\n\tif(isdigit(s[it])){\n\t\treturn dig(s,it);\n\t}\n\tif(s[it]=='-'){\n\t\tit++;\n\t\tll ret=fac(s,it);\n\t\tif(ret==NO) return NO;\n\t\treturn -ret;\n\t}\n\tif(s[it]=='('){\n\t\tit++;\n\t\tll ret=ex(s,it);\n\t\tif(ret==NO) return NO;\n\t\tif(s[it]!=')') return NO;\n\t\tit++;\n\t\treturn ret;\n\t}\n\treturn NO;\n}\n\nll term(const string& s,int& it){\n\tll ret=fac(s,it);\n\tif(ret==NO) return NO;\n\twhile(s[it]=='*'){\n\t\tit++;\n\t\tll x=fac(s,it);\n\t\tif(x==NO) return NO;\n\t\tret*=x;\n\t}\n\treturn ret;\n}\n\nll ex(const string& s,int& it){\n\tll ret=term(s,it);\n\tif(ret==NO) return NO;\n\twhile(s[it]=='+' || s[it]=='-'){\n\t\tbool isp=(s[it]=='+');\n\t\tit++;\n\t\tll x=term(s,it);\n\t\tif(x==NO) return NO;\n\t\tif(isp) ret+=x;\n\t\telse ret-=x;\n\t}\n\tif(s[it]!=')' && s[it]!='$') return NO;\n\treturn ret;\n}\nbool eq(const string& s){\n//\tcout<<s<<endl;\n\tint N=s.size();\n\tint e=-1;\n\trep(i,N){\n\t\tif(s[i]=='='){\n\t\t\tif(e==-1) e=i;\n\t\t\telse return 0;\n\t\t}\n\t}\n\tif(e==-1) return 0;\n\tint it=0;\n\tstring X=s.substr(0,e)+\"$\";\n\tll x=ex(X,it);\n\tif(X[it]!='$') x=NO;\n\tif(x==NO) return 0;\n\tit=0;\n\tstring Y=s.substr(e+1)+\"$\";\n\tll y=ex(Y,it);\n\tif(Y[it]!='$') y=NO;\n\tif(y==NO) return 0;\n\treturn x==y;\n}\n\nstring S;\nstring rs=\"01+-*()=\";\nvector<char> cs;\nint sel[8];\nint K;\nint ans;\nvoid dfs(int d){\n\tif(d==K){\n\t\tstring s=S;\n\t\trep(i,K){\n\t\t\trep(j,s.size()) if(s[j]==cs[i]) s[j]=rs[sel[i]];\n\t\t}\n\t\tif(eq(s)) ans++;\n\t\treturn;\n\t}\n\trep(i,8){\n\t\tbool canuse=1;\n\t\trep(j,d) if(sel[j]==i) canuse=0;\n\t\tif(!canuse) continue;\n\t\tsel[d]=i;\n\t\tdfs(d+1);\n\t}\n}\nint main(){\n\tcin>>S;\n\trep(i,S.size()) if(isalpha(S[i])){\n\t\tcs.pb(S[i]);\n\t}\n\tsort(all(cs));\n\tcs.erase(unique(all(cs)),cs.end());\n\tK=cs.size();\n\tif(K>8){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tdfs(0);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX\n\nstring s,t;\nint n;\nvector<char> cs,match;\nstring cand=\"01+-*()=\";\nbool used[10];\nint res=0;\n\nint calc_e(int& l,int term);\n\nint calc_f(int& l,int term){\n  if(l>=term)return -INF;\n\n  if(isdigit(t[l])){\n    int v=0;\n    if(t[l]=='0'&&l+1<term&&isdigit(t[l+1]))return -INF;\n    while(l<term&&isdigit(t[l])){\n      v<<=1;\n      v+=t[l]-'0';\n      l++;\n    }\n    return v;\n  }else if(t[l]=='-'){\n    l++;\n    int v=calc_f(l,term);\n    if(v==-INF)return -INF;\n    return -v;\n  }else if(t[l]=='('){\n    l++;\n    int v=calc_e(l,term);\n    if(v==-INF||t[l]!=')')return -INF;\n    l++;\n    return v;\n  }else{\n    return -INF;\n  }\n}\n\nint calc_t(int& l,int term){\n  if(l>=term)return -INF;\n  int v=calc_f(l,term);\n  if(v==-INF||l>term)return -INF;\n  while(l<term&&t[l]=='*'){\n    l++;\n    int nv=calc_f(l,term);\n    if(nv==-INF)return -INF;\n    v*=nv;\n  }\n  return v;\n}\n\nint calc_e(int& l,int term){\n  if(l>=term)return -INF;\n  int v=calc_t(l,term);\n  if(v==-INF||l>term)return -INF;\n  while(l<term&&(t[l]=='+'||t[l]=='-')){\n    if(t[l]=='+'){\n      l++;\n      int nv=calc_t(l,term);\n      if(nv==-INF)return -INF;\n      v+=nv;\n    }else if(t[l]=='-'){\n      l++;\n      int nv=calc_t(l,term);\n      if(nv==-INF)return -INF;\n      v-=nv;\n    }\n  }\n  return v;\n}\n\nvoid dfs(int i){\n  if(i==cs.size()){\n    t=\"\";\n    rep(j,s.size()){\n      if(exist(cand,s[j])){\n        t+=s[j];\n        continue;\n      }\n      rep(k,cs.size()){\n        if(s[j]==cs[k]){\n          t+=match[k];\n          break;\n        }\n      }\n    }\n    int cnt=0;\n    rep(j,t.size()){\n      if(t[j]=='=')cnt++;\n    }\n    if(cnt!=1)return ;\n    rep(j,t.size()){\n      if(t[j]=='='){\n        int l=0,r=j+1;\n        int cntc=0;\n        bool ok=true;\n        repl(k,l,j){\n          if(t[k]=='(')cntc++;\n          if(t[k]==')')cntc--;\n          if(cntc<0)ok=false;\n        }\n        if(cntc!=0)ok=false;\n        cntc=0;\n        repl(k,r,n){\n          if(t[k]=='(')cntc++;\n          if(t[k]==')')cntc--;\n          if(cntc<0)ok=false;\n        }\n        if(cntc!=0)ok=false;\n        if(!ok)break;\n        int vl=calc_e(l,j); int vr=calc_e(r,n);\n        if(l==j&&r==n&&vl!=-INF&&vr!=-INF&&vl==vr){\n          res++;\n        }\n        break;\n      }\n    }\n    return ;\n  }\n  rep(j,cand.size()){\n    if(used[j])continue;\n    used[j]=true;\n    match.push_back(cand[j]);\n    dfs(i+1);\n    match.pop_back();\n    used[j]=false;\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  rep(i,n){\n    if(exist(cand,s[i]))continue;\n    cs.push_back(s[i]);\n  }\n  sort(all(cs));\n  uni(cs);\n  if(cs.size()>8){\n    cout<<0<<endl;\n    return 0;\n  }\n  dfs(0);\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nint bnf();\nset<P> used;\nmap<char,int> M;\nstring S;\nint idx,valid;\nchar ch[7]={'0','1','+','-','*','(',')'};\nint ord[7];\n\nbool check(string a){//テ」ツつ、テ」ツつウテ」ツδシテ」ツδォテ」ツ?ョテヲツ閉ーテ」ツ?ィテ」ツつォテ」ツδε」ツつウテ」ツ?ョテ・ツッツセテ・ツソツ愿」ツつ津ァツ「ツコティツェツ?\n  int par=0;\n  for(char s:a){\n    par += (s == '(') - (s == ')');\n    if(s == '=') return 0;\n    if(par < 0) return 0;\n  }\n  return par==0;\n}\n\nint getNum(){ //テヲツ鳴?・ツュツ療・ツ按療」ツつ津ヲツ閉ーテ・ツュツ療」ツ?ォテ」ツ?凖」ツつ?\n  int res = 0;\n  if(S[idx] == '0' && isdigit(S[idx+1])) valid  = 0;\n  while(isdigit(S[idx]))res = res*2 + S[idx++]-'0';\n  return res;\n}\n\nint cal(){\n  char ch = S[idx];\n  int res = 0,sign = 1;\n  if(ch == '+'||ch=='*'||ch==')'){ valid = 0;return 0;}\n  \n  while(S[idx] == '-') idx++, sign *= -1;\n  ch = S[idx];\n\n  if(isdigit(ch)){\n    res = sign*getNum();\n    if(S[idx] == '*'){idx++; return res * cal();}\n    return res;\n  }\n  else if(ch == '(') {\n    idx++;res = sign*bnf();idx++;\n    return res;\n  }\n  valid = 0;\n  return 0;\n}\n\nint bnf(){\n  int res = cal();\n  while(idx<(int)S.size()){\n    if(valid == 0) return -1;\n    char ch = S[idx];\n    if(ch == '('){valid = 0;}\n    else if(ch == '*'){idx++;res *= cal();}\n    else if(ch == '+'){idx++;res += cal();}\n    else if(ch == '-'){idx++;res -= cal();}\n    else if(ch != ')') valid = 0;\n    else break;\n  }\n  if(valid ==0) return -1;\n  return res;\n}\n\nstring mkS(string a){\n  string res;\n  for(char s:a){\n    if(isalpha(s))res += ch[ ord[ M[s] ] ];\n    else res += s;\n  }\n  return res;\n}\n\n\nint calc(string &a,string &b){\n  string A = mkS(a);\n  string B = mkS(b);\n  if(used.count(P(A,B)))return 0;\n  used.insert(P(A,B));\n  \n  valid = check(A) && check(B);\n  idx = 0;\n  S = A;\n  int ra = bnf();\n  idx=0;\n  S = B;\n  int rb = bnf();\n  //  if(valid)cout<<A<<\"=\"<<B<<\" \"<<valid<<\" \"<<ra<<\" \"<<rb<<endl;\n  return ra == rb && valid;\n}\n\n\nint dfs(int num,string &a,string &b){\n  if(num == 7) return calc(a,b);\n  \n  int res = 0;\n  for(int i=0;i<7;i++){\n    if(ord[i] != -1)continue;\n    ord[i] = num;\n    res +=dfs(num+1,a,b);\n    ord[i] = -1;\n  }\n  return res;\n}\n\n\nint main(){\n  string str;\n  cin>>str;\n  if(str.size()<3)cout<<0<<endl,exit(0);\n\n  map<char,int> cnt;\n  for(int i=0;i<(int)str.size();i++)cnt[str[i]]++;\n  if(cnt.size()>8)cout<<0<<endl,exit(0);\n\n  int c = 0;\n  for(pair<char,int> p:cnt) M[p.first] = c++;\n  \n  memset(ord,-1,sizeof(ord));  \n  int ans = 0;\n  for(int i=1;i<(int)str.size()-1;i++){\n    if(str[i]=='='||(isalpha(str[i])&&cnt[str[i]] == 1)){\n      string a = str.substr(0,i);\n      string b = str.substr(i+1,str.size()-i-1);\n      ans+=dfs(0,a,b);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nint bnf();\nset<P> used;\nmap<char,int> M;\nstring S;\nint idx,valid;\nchar ch[8]={'0','1','+','-','*','(',')','='};\nint ord[8];\n\nbool check(string a){//テ」ツつ、テ」ツつウテ」ツδシテ」ツδォテ」ツ?ョテヲツ閉ーテ」ツ?ィテ」ツつォテ」ツδε」ツつウテ」ツ?ョテ・ツッツセテ・ツソツ愿」ツつ津ァツ「ツコティツェツ?\n  int par=0;\n  for(char s:a){\n    par += (s == '(') - (s == ')');\n    if(s == '=') return 0;\n    if(par < 0) return 0;\n  }\n  return par==0;\n}\n//100-10*-(10+11*100)=100*1000\nint getNum(){ //テヲツ鳴?・ツュツ療・ツ按療」ツつ津ヲツ閉ーテ・ツュツ療」ツ?ォテ」ツ?凖」ツつ?\n  int res = 0;\n  if(S[idx] == '0' && isdigit(S[idx+1])) valid  = 0;\n  while(isdigit(S[idx]))res = res*2 + S[idx++]-'0';\n  return res;\n}\n\nint cal(){\n  char ch = S[idx];\n  int res = 0,sign = 1;\n  if(ch=='+'||ch=='*'||ch==')'){ valid = 0;return 0;}\n  \n  while(S[idx] == '-') idx++, sign *= -1;\n  ch = S[idx];\n\n  if(isdigit(ch)){\n    res = sign*getNum();\n    if(S[idx] == '*'){idx++; return res * cal();}\n    return res;\n  }\n  else if(ch == '(') {\n    idx++;res = sign*bnf();idx++;\n    return res;\n  }\n  valid = 0;\n  return 0;\n}\n\nint bnf(){\n  int res = cal();\n  while(idx<(int)S.size()){\n    if(valid == 0) return -1;\n    char ch = S[idx];\n    if(ch == '('){valid = 0;}\n    else if(ch == '*'){idx++;res *= cal();}\n    else if(ch == '+'){idx++;res += cal();}\n    else if(ch == '-'){idx++;res -= cal();}\n    else if(ch != ')') valid = 0;\n    else break;\n  }\n  if(valid ==0) return -1;\n  return res;\n}\n\nstring mkS(string a){\n  string res;\n  for(char s:a){\n    if(isalpha(s))res += ch[ ord[ M[s] ] ];\n    else res += s;\n  }\n  return res;\n}\n\n\nint calc(string A,string B){\n  if(A.size()==0 || B.size()==0) return 0;\n  if(used.count(P(A,B)))return 0;\n  used.insert(P(A,B));\n  valid = check(A) && check(B);\n  idx = 0;\n  S = A;\n  int ra = bnf();\n  idx = 0;\n  S = B;\n  int rb = bnf();\n  //if(valid)cout<<A<<\"=\"<<B<<\" \"<<valid<<\" \"<<ra<<\" \"<<rb<<endl;\n  return ra == rb && valid;\n}\n\nint calc(string s){\n  s = mkS(s);\n  for(int i=0;i<(int)s.size();i++)\n    if(s[i]=='=') return calc(s.substr(0,i),s.substr(i+1,s.size()-i-1));\n  return 0;\n}\n\nint dfs(int num,string &s){\n  if(num == 8) return calc(s);\n  \n  int res = 0;\n  for(int i=0;i<8;i++){\n    if(ord[i] != -1)continue;\n    ord[i] = num;\n    res +=dfs(num+1,s);\n    ord[i] = -1;\n  }\n  return res;\n}\n\n\nint main(){\n  string str;\n  cin>>str;\n  if(str.size()<3)cout<<0<<endl,exit(0);\n\n  map<char,int> cnt;\n  for(int i=0;i<(int)str.size();i++)if(isalpha(str[i]))cnt[str[i]]++;\n  if(cnt.size()>8)cout<<0<<endl,exit(0);\n\n  int c = 0;\n  for(pair<char,int> p:cnt)if(isalpha(p.first)) M[p.first] = c++;\n  \n  memset(ord,-1,sizeof(ord));  \n  cout<<dfs(0,str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n \nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n \nint bnf();\n \nint bnf3(){\n   \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n   \n  if(s[p]=='('){\n     \n    p++;\n    if(s[p]=='*'||s[p]=='+') flag=1;\n    if(s[p]==')') flag=1;\n     \n    int r=bnf();\n     \n    if(p>=s.size()||s[p]!=')') flag=1;\n     \n    p++;\n     \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n     \n     \n    return r;\n  }\n   \n  int res=0,minu=0;\n \n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n   \n  if(s[p]=='-'){\n     \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n     \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n   \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n   \n  if(s[p]=='(') flag=1;\n   \n  if(minu%2) res*=-1;\n   \n  return res;\n}\n \nint bnf2(){\n \n  int res=bnf3();\n \n  while(p<s.size()){\n \n    if(s[p]=='*'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf3();\n       \n      res*=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nint bnf(){\n \n  int res=bnf2();\n \n  while(p<s.size()){\n \n    if(s[p]=='+'){\n \n      p++;\n       \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n       \n      int r=bnf2();\n \n      res+=r;\n       \n    }    \n    else if(s[p]=='-'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf2();\n \n      res-=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nvoid check(){\n   \n  int cnt=0;\n   \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n \n      if(cnt==0){\n    flag=1;\n    return ;\n      }\n      else cnt--;\n    }\n  }\n \n  if(cnt) flag=1;\n}\n \nset<string> me;\n \nvoid solve(){\n   \n  set<char> S;\n   \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n \n  set<char>::iterator ite=S.begin();\n \n  vector<char> al;\n   \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n   \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n   \n  int idx[8];\n \n  for(int i=0;i<8;i++) idx[i]=i;\n   \n  do{\n     \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n \n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n     \n    if(me.count(s)) continue;\n    me.insert(s);\n     \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n     \n    string s1,s2;\n     \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n \n    int f=0;\n \n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n     \n    flag=0;\n    s=s1;\n    p=0;\n     \n    int r1=bnf();\n    check();\n     \n    s=s2;\n    p=0;\n     \n    int r2=bnf();\n    check();\n \n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n     \n  }while(next_permutation(idx,idx+8));\n   \n}\n \n \nmain(){\n \n  cin>>s;\n  str=s;\n   \n  solve();\n \n  cout<<ans<<endl;\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll LLINF = LLONG_MAX;\nconst string opr = \"01+-*=()\";\n\nstring context;\nint n;\n\nll parse_E(int&,string&);\n\nll parse_F(int &p,string &s) {\n  if( p >= (int)s.size() ) throw \"fail\";\n  if( s[p] == '+' ) throw \"fail\";\n  if( s[p] == '-' ) {\n    ++p;\n    ll v;\n    try { v = parse_F(p,s); } catch(...) { throw \"fail\"; }\n    return v * -1LL;\n  } \n  if( s[p] == '(' ) {\n    ++p;\n    ll v;\n    try { v = parse_E(p,s); } catch(...) { throw \"fail\"; }\n    if( p >= (int)s.size() ) throw \"fail\";\n    if( s[p] != ')' ) throw \"fail\";\n    ++p;\n    if( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) throw \"fail\";\n    return v;\n  }\n  int cnt = 0;\n  ll v = 0;\n  bool first_zero = ( s[p] == '0' );\n  while( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) {\n    v <<= 1;\n    v += (ll)( s[p] - '0' );\n    ++p;\n    ++cnt;\n  }\n  if( first_zero && cnt != 1 ) throw \"fail\";\n  if( cnt == 0 ) throw \"fail\";\n  if( p < (int)s.size() && s[p] == '(' ) throw \"fail\";\n  return v;\n}\n\nll parse_T(int &p,string &s) {\n  ll v;\n  try { v = parse_F(p,s); } catch(...) { throw \"fail\"; }\n  while( p < (int)s.size() && s[p] == '*' ) {\n    ++p;\n    ll tmp;\n    try { tmp = parse_T(p,s); } catch(...) { throw \"fail\"; }\n    v *= tmp;\n  }\n  return v;\n}\n\nll parse_E(int &p,string &s) {\n  ll v;\n  try { v = parse_T(p,s); } catch(...) { throw \"fail\"; }\n  while( p < (int)s.size() && ( s[p] == '+' || s[p] == '-' ) ) {\n    char op = s[p];\n    ++p;\n    ll tmp;\n    try { tmp = parse_T(p,s); } catch(...) { throw \"fail\"; }\n    if( op == '+' ) v += tmp;\n    if( op == '-' ) v -= tmp;\n  }\n  return v;\n}\n\nbool pari_check(string &s) {\n  int cnt = 0;\n  rep(i,(int)s.size()) {\n    if( s[i] == '(' ) ++cnt;\n    if( s[i] == ')' ) --cnt;\n    if( cnt < 0 ) return false;\n  }\n  return cnt == 0;\n}\n\nbool check() {\n  string s,t;\n  {\n    string tmp;\n    tmp = context;\n    rep(i,n) if( context[i] == '=' ) tmp[i] = ' ';\n    vector<string> vec;\n    stringstream ss;\n    ss << tmp;\n    while( ss >> s ) vec.push_back(s);\n    if( vec.size() != 2 ) return false;\n    s = vec[0];\n    t = vec[1];\n  }\n  if( !pari_check(s) || !pari_check(t) ) return false;\n  int p = 0;\n  ll sv,tv;\n  try {\n    sv = parse_E(p,s);\n    p = 0;\n    tv = parse_E(p,t);\n  } catch(...) {\n    return false;\n  }\n  if( sv == LLINF || tv == LLINF) return false;\n  return sv == tv;\n}\n\nint dfs(int ptr,int used,vector<char> &already) {\n  if( n <= ptr ) return check();\n  if( !isalpha(context[ptr]) ) return dfs(ptr+1,used,already);\n  int sum = 0;\n  int v = context[ptr] - 'a';\n  if( already[v] != '$' ) {\n    if( already[v] == '=' ) return 0;\n    char tmp = context[ptr];\n    context[ptr] = already[v];\n    sum += dfs(ptr+1,used,already);\n    context[ptr] = tmp;\n    return sum;\n  }\n  rep(i,(int)opr.size()) {\n    if( ( used >> i ) & 1 ) continue;\n    char tmp = context[ptr];\n    context[ptr] = opr[i];\n    already[v] = opr[i];\n    sum += dfs(ptr+1,used|(1<<i),already);\n    already[v] = '$';\n    context[ptr] = tmp;\n  }\n  return sum;\n}\n\nbool normalize() {\n  vector<char> vec;\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) vec.push_back(context[i]);\n  sort(all(vec));\n  vec.erase(unique(all(vec)),vec.end());\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) {\n    int pos = lower_bound(all(vec),context[i]) - vec.begin();\n    context[i] = (char)('a'+pos);\n  }\n  return (int)vec.size() <= 8;\n}\n\nvoid compute() {\n  if( !normalize() ) { puts(\"0\"); return; }\n  n = (int)context.size();\n  int used = 0;\n  rep(i,n) if( context[i] == '=' ) { used = (1<<5); break; }\n  vector<char> vec(8,'$');\n  cout << dfs(0,used,vec) << endl;\n}\n\nint main() {\n  if( 0 ) {\n    string s;\n    cin >> s;\n    int p = 0;\n    cout << parse_E(p,s) << endl;\n    return 0;\n  }\n  cin >> context;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\nstring S=\"()01+-*=\";\n\nbool flag=false;\n\n#define NONE -1\nint n;\nstring s;\nint F(int &id);\nint E(int &id,int sgn);\n\nint getnum(int &id){\n    int cnt=0,num=0;\n    bool firstzero=s[id]=='0';\n    while(id<n&&(s[id]=='0'||s[id]=='1')){\n        num*=2;\n        num+=(s[id]-'0');\n        id++;\n        cnt++;\n    }\n    if(firstzero&&cnt>1){\n        flag=false;\n    }\n    return num;\n}\n\nint F(int &id){\n    if(id<n){\n        if(s[id]=='0'||s[id]=='1')return getnum(id);\n        else if(s[id]=='('){\n                id++;\n                int num=E(id,1);\n                if(id<n&&s[id]==')'){\n                    id++;\n                    return num;\n                }\n        }\n        else if(s[id]=='-'){\n            id++;\n            return -F(id);\n        }\n    }\n    flag=false;\n    return 0;\n}\nint T(int &id){\n    int sum=1;\n    if(s[id]=='('||s[id]=='-'||s[id]=='0'||s[id]=='1')sum*=F(id);\n    else{\n        flag=false;\n        return 0;\n    }\n    if(!flag)return false;\n    if(id==n||s[id]==')'||s[id]=='='||s[id]=='+'||s[id]=='-'){\n        return sum;\n    }\n    if(s[id]=='*'){\n        id++;\n        return sum*T(id);\n    }\n    else{\n        flag=false;\n        return 0;\n    }    \n\n}\nint E(int &id,int sgn){\n    int sum=0;\n    if(s[id]=='('||s[id]=='-'||s[id]=='0'||s[id]=='1')sum=sgn*T(id);\n    else{\n        flag=false;\n        return 0;\n    }\n    if(!flag)return false;\n    if(id==n||s[id]==')'||s[id]=='='){\n        return sum;\n    }\n    if(s[id]=='+'){\n        id++;\n        return sum+E(id,1);\n    }\n    else if(s[id]=='-'){\n        id++;\n        return sum+E(id,-1);\n    }\n    else{\n        flag=false;\n        return 0;\n    }    \n}\n\nbool Q(){\n    int L,R;flag=true;\n    int eq=NONE,id;\n    REP(i,n){\n        if(s[i]=='='){\n            if(eq==NONE)\n                eq=i;\n            else\n                return false;\n        }\n    }\n    if(eq==NONE)return false;\n    L=E(id=0,1);\n    if(!flag||id!=eq)return false;\n    R=E(id=eq+1,1);\n    if(!flag||id!=n)return false;\n    return L==R;\n}\nint main(){\n    flag=true;\n    map<char,int> m;\n    string input;\n    cin>>input;\n    n=input.size();\n    s=input;\n    REP(i,n){\n        bool exist=false;\n        REP(j,8)if(s[i]==S[j])exist=true;\n        if(!exist)m[s[i]]=0;\n    }\n    int cnt=0;\n    for(auto &it:m)it.second=cnt++;\n    if(cnt>8){\n        cout<<0<<endl;\n        return 0;\n    }\n    set<string> all;\n    vector<int> ord(8);\n    iota(ord.begin(),ord.end(),0);\n    do{\n        REP(i,n){\n            if(m.count(input[i]))\n                s[i]=S[ord[m[input[i]]]];   \n        }\n        all.insert(s);\n    }while(next_permutation(ord.begin(),ord.end()));\n    \n    int res=0;\n    for(auto &it:all){\n        s=it;\n        if(Q())res++;\n    \n    }\n    cout<<res<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0LL);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0LL);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nsigned main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    \n    if(p<s.size()&&(s[p]=='*'||s[p]=='+')) flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    \n    return r;\n  }\n  \n  int res=0,minu=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n    \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(minu%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;    if(s[p]=='*'||s[p]=='+') flag=1;\n      \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n    \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    \n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n    \n  }while(next_permutation(idx,idx+8));\n  \n}\n\n\nmain(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar moji[] = \"01+-*()=\";\nstring s;\nchar cset[100];\nint idx[100];\nint length;\nvector<int> perm;\nint pos;\nbool correct;\nstring currents;\nchar get(int i){\n\tif(i >= length){\n\t\treturn '\\0';\n\t}\n\treturn currents[i];\n}\n\nbool Q();\nint E();\nint T();\nint F();\nint N();\nint B(int cur);\n\n\nbool Q(){\n\tint a = E();\n\tif(get(pos) != '='){\n\t\tcorrect  = false;\n\t\treturn false;\n\t}\n\tpos++;\n\tint b = E();\n\treturn a == b;\n}\n\nint E(){\n\tint t = T();\n\twhile(get(pos) == '+' || get(pos) == '-'){\n\t\tif(get(pos) == '+'){\n\t\t\tpos++;\n\t\t\tt += T();\n\t\t}else{\n\t\t\tpos++;\n\t\t\tt -= T();\n\t\t}\n\t}\n\treturn t;\n}\n\nint T(){\n\tint f = F();\n\twhile(get(pos) == '*'){\n\t\tpos++;\n\t\tf *= F();\n\t}\n\treturn f;\n}\n\nint F(){\n\tif(get(pos) == '-'){\n\t\tpos++;\n\t\treturn - F();\n\t}\n\tif(get(pos) == '('){\n\t\tpos++;\n\t\tint e = E();\n\t\tif(get(pos) != ')'){\n\t\t\tcorrect = false;\n\t\t}\n\t\tpos++;\n\t\treturn e;\n\t}\n\n\treturn N();\n}\n\nint N(){\n\tif(get(pos) == '0'){\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif(get(pos) == '1'){\n\t\tpos++;\n\t\treturn B(1);\n\t}\n\tcorrect = false;\n\treturn 0;\n}\n\nint B(int cur){\n\tif(get(pos) == '0'){\n\t\tpos++;\n\t\treturn B(cur * 2);\n\t}\n\tif(get(pos) == '1'){\n\t\tpos++;\n\t\treturn B(cur * 2 + 1);\n\t}\n\treturn cur;\n}\n\n\nint main(){\n\tcin >> s;\n\tlength = s.size();\n\tint si = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(!(('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z'))){\n\t\t\tidx[i] = s[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint j;\n\t\tfor(j = 0; j < si; j++){\n\t\t\tif(cset[j] == s[i]) break;\n\t\t}\n\t\tif(j == si){\n\t\t\tsi++;\n\t\t\tif(si > 8){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcset[j] = s[i];\n\t\t}\n\t\tidx[i] = j;\n\t}\n\t\n\tfor(int i = 0 ; i < 8; i++){\n\t\tperm.push_back(i);\t\n\t}\n\n\tset<string> smap;\n\n\tdo{\n\t\tstring ns = s;\n\t\tfor(int i = 0; i < ns.size(); i++){\n\t\t\tif(('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z')){\n\t\t\t\tns[i] = moji[perm[idx[i]]];\n\t\t\t}\n\t\t}\n\t\tsmap.insert(ns);\n\t}while(next_permutation(perm.begin(), perm.end()));\n\n\tint ans = 0;\n\tfor(string ss : smap){\n\t\tcurrents = ss;\n\t\tpos = 0;\n\t\tcorrect = true;\n\t\tif(Q() && correct && pos == ss.size()){\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<stack>\n#include<bitset>\n#include<map>\n#include<numeric>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\nconst ll mod = 1000000007;\nconst long double eps = 1e-8;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\n\ntypedef long double ld;\n\nbool isnum(char t) {\n\treturn '0' <= t && t <= '9';\n}\nbool isord(char t) {\n\treturn t == '+' || t == '-' || t == '*';\n}\n\nint trans(char t) {\n\tif ('a' <= t && t <= 'z')return t - 'a';\n\tif ('A' <= t && t <= 'Z')return 26 + (t - 'A');\n\treturn -1;\n}\nconst string str = \"01-+*()\";\nint n;\n\nll trans_num(string s) {\n\tint len = s.length();\n\tll ret = 0;\n\trep(i, len) {\n\t\tif (s[len - i - 1] == '1')ret += (ll)1 << i;\n\t}\n\treturn ret;\n}\n\nbool ok;\nll expr(string&s, int& i);\nll term(string&s, int& i);\nll factor(string&s, int& i);\nll number(string&s, int& i);\n\nll expr(string& s, int& i) {\n\tll val = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i]; i++;\n\t\tll val2 = term(s, i);\n\t\tif (op == '+')val += val2;\n\t\telse val -= val2;\n\t}\n\treturn val;\n}\nll term(string& s, int& i) {\n\tll val = factor(s, i);\n\twhile (s[i] == '*') {\n\t\ti++;\n\t\tll val2 = factor(s, i);\n\t\tval *= val2;\n\t}\n\treturn val;\n}\nll factor(string& s, int& i) {\n\tif (isnum(s[i]))return number(s, i);\n\tif (i<s.length()&&s[i] == '-') {\n\t\ti++;\n\t\tll ret = factor(s, i);\n\t\treturn -ret;\n\t}\n\tif (i==s.length()||s[i] != '(') {\n\t\tok = false; return 0;\n\t}\n\ti++;\n\tll ret = expr(s, i);\n\tif (i == s.length() || s[i] != ')') {\n\t\tok = false; return 0;\n\t}\n\ti++;\n\treturn ret;\n}\nll number(string& s, int& i) {\n\tint le = i;\n\twhile (i + 1 < s.length() && isnum(s[i + 1]))i++;\n\tstring u = s.substr(le, i - le + 1);\n\tif (u.size() > 1 && u[0] == '0') {\n\t\tok = false; return 0;\n\t}\n\ti++;\n\treturn trans_num(u);\n}\n\nbool query(string &s) {\n\tint len = s.length();\n\tok = true;\n\tstring le, ri;\n\trep(i, len) {\n\t\tif (s[i] == '=') {\n\t\t\tle = s.substr(0, i);\n\t\t\tri = s.substr(i+1, len-1-i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint i = 0;\n\tll cl = expr(le, i);\n\tif (i != le.length())return false;\n\ti = 0;\n\tll cr = expr(ri, i);\n\tif (i != ri.length())return false;\n\tif (!ok)return false;\n\treturn cl == cr;\n}\n\nvoid solve() {\n\tstring s;\n\tcin >> s; n = s.length();\n\tint c[52] = {};\n\tvector<int> a(n);\n\trep(i, n) {\n\t\ta[i] = trans(s[i]);\n\t\tif (a[i] >= 0) {\n\t\t\tc[a[i]]++;\n\t\t}\n\t}\n\tvector<int> v;\n\tvector<int> trans(52);\n\trep(i, 52) {\n\t\tif (c[i]) {\n\t\t\ttrans[i] = v.size();\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tif (v.size() > 8) {\n\t\tcout << 0 << endl; return;\n\t}\n\tbool exieq = false;\n\trep(i, n) {\n\t\tif (s[i] == '=')exieq = true;\n\t}\n\tint ans = 0;\n\tif (exieq) {\n\t\tif (v.size() > 7) {\n\t\t\tcout << 0 << endl; return;\n\t\t}\n\t\tint num = 0;\n\t\trep(i, n)if (s[i] == '=')num++;\n\t\tif (num > 1) {\n\t\t\tcout << 0 << endl; return;\n\t\t}\n\t\tvector<int> b(7,7); rep(i, 7)b[i] = i;\n\t\tmap<vector<int>, bool> used;\n\t\twhile (true) {\n\t\t\tbool f = true;\n\t\t\tvector<int> u = b; u.resize(v.size());\n\t\t\tif (used[u])f = false;\n\t\t\telse used[u] = true;\n\t\t\tif (f) {\n\t\t\t\tstring cop = s;\n\t\t\t\trep(i, n) {\n\t\t\t\t\tif (a[i] >= 0) {\n\t\t\t\t\t\tcop[i] = str[b[trans[a[i]]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << cop << endl;\n\t\t\t\tif (query(cop))ans++;\n\t\t\t}\n\t\t\tif (!next_permutation(b.begin(), b.end()))break;\n\t\t}\n\t}\n\telse {\n\t\trep(i, v.size()) {\n\t\t\tif (c[v[i]] != 1)continue;\n\t\t\tstring ss = s;\n\t\t\trep(j, n)if (a[j] == v[i])ss[j] = '=';\n\t\t\t//cout << v[i] << \" \" << ss << endl;\n\t\t\tvector<int> b(7, 7); rep(j, 7)b[j] = j;\n\t\t\tmap<vector<int>,bool> used;\n\t\t\twhile (true) {\n\t\t\t\tbool f = true;\n\t\t\t\tvector<int> u = b; u.resize((int)v.size() - 1);\n\t\t\t\tif (used[u])f = false;\n\t\t\t\telse used[u] = true;\n\t\t\t\tif (f) {\n\t\t\t\t\tstring cop = ss;\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tif (a[j] >= 0&&a[j]!=v[i]) {\n\t\t\t\t\t\t\tint z = trans[a[j]];\n\t\t\t\t\t\t\tif (a[j] > v[i])z--;\n\t\t\t\t\t\t\tcop[j] = str[b[z]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << i<<\" \"<<cop << endl;\n\t\t\t\t\tif (query(cop)) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\t//cout << \"this!!\" << \" \" << cop << endl;\n\t\t\t\t\t\t//cout << \"this!!\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!next_permutation(b.begin(), b.end()))break;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//string s = \"-0=0\";\n\t//cout << valid(s) << endl;\n\t//cout << fixed << setprecision(10);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint parse_formula(int &p, string &s);\nint parse_term(int &p, string &s);\nint parse_factor(int &p, string &s);\nint parse_number(int &p, string &s);\n\nint parse_formula(int &p, string &s){\n    int n = s.length();\n    if(p>=n or s[p]==')'){\n        throw exception();\n    }\n    int res = parse_term(p, s);\n    while(p<n and (s[p]=='+' or s[p]=='-')){\n        int sign = (s[p]=='+')? 1: -1;\n        res += sign*parse_term(++p, s);\n    }\n    if(p>=n or s[p]!=')'){\n        throw exception();\n    }\n    p++;\n    return res;\n}\nint parse_term(int &p, string &s){\n    int n = s.length();\n    int res = 1;\n    while(1){\n        res *= parse_factor(p, s);\n        if(p>=n or s[p]==')' or s[p]!='*') break;\n        p++;\n    }\n    return res;\n}\nint parse_factor(int &p, string &s){\n    int n = s.length();\n    int sign = 1;\n    while(p<n and s[p]=='-'){\n        sign *= -1;\n        p++;\n    }\n    if(p>=n or !(s[p]=='(' or s[p]=='0' or s[p]=='1')){\n        throw exception();\n    }\n    if(s[p]=='('){\n        return sign * parse_formula(++p, s);\n    }else{\n        return sign * parse_number(p, s);\n    }\n}\nint parse_number(int &p, string &s){\n    int n = s.length();\n    int res = 0;\n    if(p>=n or !(s[p]=='0' or s[p]=='1')){\n        throw exception();\n    }\n    bool leading_zero = s[p]=='0';\n    int firstp = p;\n    while(p<n and (s[p]=='0' or s[p]=='1')){\n        res *= 2;\n        res += s[p]-'0';\n        p++;\n    }\n    if(leading_zero and p-firstp > 1){\n        throw exception();\n    }\n    return res;\n}\n\nconst string alphabet = \"01+-*()=\";\n\nint main(){\n    string s;\n    cin >> s;\n    vector<char> assign;\n    for(char c: s){\n        if(('a'<=c and c<='z') or ('A'<=c and c<='Z')){\n            assign.push_back(c);\n        }\n    }\n    sort(assign.begin(), assign.end());\n    assign.erase(unique(assign.begin(), assign.end()), assign.end());\n    while(assign.size() < alphabet.length()){\n        assign.push_back('~');\n    }\n    int ans = 0;\n    do{\n        string t = s;\n        for(int i=0; i<8; i++){\n            for(int j=0; j<(int)t.length(); j++){\n                if(t[j] == assign[i]){\n                    t[j] = alphabet[i];\n                }\n            }\n        }\n        int poseq = -1;\n        for(int i=0; i<(int)t.length(); i++){\n            if(t[i] == '='){\n                if(poseq == -1) poseq = i;\n                else if(poseq > 0) poseq = -2;\n            }\n        }\n        if(poseq < 0) continue;\n        t[poseq] = ')';\n        t.push_back(')');\n        try{\n            int p = 0;\n            int ret1 = parse_formula(p, t);\n            if(p != poseq+1) continue;\n            int ret2 = parse_formula(p, t);\n            if(p != (int)t.length()) continue;\n            if(ret1 == ret2) ans++;\n        }catch(exception){\n            continue;\n        }\n    }while(next_permutation(assign.begin(), assign.end()));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint idx, len;\n\nint number();\nint factor();\nint term();\nint expression();\n\nint number(){\n    char c = f[idx++];\n    if(c != '0' and c != '1') throw 1;\n\n    if(c == '0') return 0;\n\n    int ret = 1;\n    while(idx < len and (f[idx] == '0' or f[idx] == '1')){\n        ret *= 2;\n        char c = f[idx++];\n        if(c == '1') ret += 1;\n    }\n    return ret;\n}\n\nint factor(){\n    int mcnt = 0;\n    while(idx < len and f[idx] == '-'){\n        mcnt++;\n        idx++;\n    }\n    if(idx >= len) throw 1;\n\n    int sign = (mcnt % 2 == 0 ? +1:-1);\n    if(f[idx] != '(') return sign * number();\n    idx++;\n\n    int ret = sign * expression();\n    if(idx >= len or f[idx] != ')') throw 1;\n    idx++;\n\n    return ret;\n}\n\nint term(){\n    int ret = factor();\n    while(idx < len and f[idx] == '*'){\n        idx++;\n        int rhs = factor();\n        ret *= rhs;\n    }\n    return ret;\n}\n\nint expression(){\n    int ret = term();\n    while(idx < len and (f[idx] == '+' or f[idx] == '-')){\n        char op = f[idx++];\n        int rhs = term();\n        switch(op){\n            case '+': { ret += rhs; break; }\n            case '-': { ret -= rhs; break; }\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    /*\n    while(cin >> f){\n        len = f.size(), idx = 0;\n        int ret = expression();\n        cerr << ret << \", idx = \" << idx << \", len = \" << len << endl;\n    }\n    return 0;\n    //*/\n\n    string in; cin >> in;\n    string T = \"01+-*()=\"; sort(_all(T));\n\n    set<string> s;\n    do {\n        map<char, bool> used;\n        map<char, char> c2t;\n        int j = 0;\n        f = in;\n        rep(i, in.size()){\n            char c = in[i];\n            if(not isupper(c)) continue;\n\n            if(not used[c]){\n                used[c] = true;\n                assert(j < T.size());\n                c2t[c] = T[j++];\n            }\n            f[i] = c2t[c];\n        }\n\n        string equation = f;\n        string l, r;\n        rep(i, in.size()){\n            if(f[i] == '='){\n                l = f.substr(0, i);\n                r = f.substr(i + 1);\n                break;\n            }\n        }\n        if(l == \"\" or r == \"\") continue;\n\n        try {\n            idx = 0; f = l; len = f.size();\n            int lv = expression();\n            if(idx != len) continue;\n\n            idx = 0; f = r; len = f.size();\n            int rv = expression();\n            if(idx != len) continue;\n\n            if(lv != rv) continue;\n        }\n        catch(int e){\n            continue;\n        }\n        s.insert(equation);\n    } while(next_permutation(_all(T)));\n\n    for(auto& e : s){\n        cerr << e << endl;\n    }\n    cout << s.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 1371.cc: Infallibly Crack Perplexing Cryptarithm\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int CN = 8;\nconst char cs[] = \"01+-*()=\";\n\nconst int MAX_PN = 40320; // = 8!\nconst long long LINF = 1LL << 62;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* global variables */\n\nchar s[64], t[64];\nint vmap[128], cns[CN], pss[MAX_PN][CN], ps[CN], pn = 0;\nbool used[CN];\n\n/* subroutines */\n\nvoid rec_perm(int u, int vn) {\n  if (u >= vn) {\n    memcpy(pss[pn++], ps, sizeof(pss[0]));\n    return;\n  }\n\n  for (int c = 0; c < CN; c++)\n    if (! used[c]) {\n      used[c] = true;\n      ps[u] = c;\n      rec_perm(u + 1, vn);\n      used[c] = false;\n    }\n}\n\nll expr(char *(&cpt));\n\nll num(char *(&cpt)) {\n  bool swz = (*cpt == '0');\n  ll v0 = 0;\n  int l = 0;\n  while (*cpt == '0' || *cpt == '1')\n    v0 = (v0 << 1) | (*(cpt++) - '0'), l++;\n  if (swz && l > 1) return LINF;\n  return v0;\n}\n\nll factor(char *(&cpt)) {\n  if (*cpt == '0' || *cpt == '1') return num(cpt);\n  if (*cpt == '-') {\n    cpt++; // '-;\n    ll v0 = factor(cpt);\n    if (v0 >= LINF) return LINF;\n    return -v0;\n  }\n  if (*cpt == '(') {\n    cpt++; // '('\n    ll v0 = expr(cpt);\n    if (v0 >= LINF || *cpt != ')') return LINF;\n    cpt++; // ')'\n    return v0;\n  }\n  return LINF;\n}\n\nll term(char *(&cpt)) {\n  ll v0 = factor(cpt);\n  if (v0 >= LINF) return LINF;\n\n  while (*cpt == '*') {\n    cpt++; // '*'\n    ll v1 = factor(cpt);\n    if (v1 >= LINF) return LINF;\n    v0 *= v1;\n  }\n  return v0;\n}\n\nll expr(char *(&cpt)) {\n  ll v0 = term(cpt);\n  if (v0 >= LINF) return LINF;\n\n  while (*cpt == '+' || *cpt == '-') {\n    char op = *(cpt++); // '+' || '-'\n    ll v1 = term(cpt);\n    if (v1 >= LINF) return LINF;\n    if (op == '+') v0 += v1;\n    else v0 -= v1;\n  }\n  return v0;\n}\n\n/* main */\n\nint main() {\n  scanf(\"%s\", s);\n\n  memset(vmap, -1, sizeof(vmap));\n  int vn = 0;\n  for (int i = 0; s[i]; i++) {\n    if ((s[i] >= 'A' && s[i] <= 'Z') || (s[i] >= 'a' && s[i] <= 'z')) {\n      int vid = vmap[s[i]];\n      if (vid < 0) vid = vmap[s[i]] = vn++;\n      s[i] = vid + 1;\n      cns[vid]++;\n    }\n\n    //if (s[i] < vn) printf(\"[%d]\", s[i]);\n    //else putchar(s[i]);\n  }\n  //putchar('\\n');\n\n  if (vn > CN) {\n    puts(\"0\");\n    return 0;\n  }\n\n  rec_perm(0, vn);\n  //printf(\"pn=%d\\n\", pn);\n\n  int cnt = 0;\n  for (int pi = 0; pi < pn; pi++) {\n    int eql = 0, obr = 0, cbr = 0;\n    for (int i = 0; s[i]; i++) {\n      if (s[i] <= vn) t[i] = cs[pss[pi][s[i] - 1]];\n      else t[i] = s[i];\n      switch (t[i]) {\n      case '=': eql++; break;\n      case '(': obr++; break;\n      case ')': cbr++; break;\n      }\n    }\n    if (eql != 1 || obr != cbr) continue;\n    //puts(t);\n\n    char *cpt = t;\n    ll v0 = expr(cpt);\n    if (v0 < LINF && *cpt == '=') {\n      cpt++; // '='\n      ll v1 = expr(cpt);\n      if (v1 < LINF && v0 == v1 && *cpt == '\\0') {\n\tcnt++;\n\t//puts(t);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", cnt);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nstring s;\n\nint expr(int &i);\nint term(int &i);\nint factor(int &i);\nint number(int &i);\n\nint expr(int &i) {\n  int val = term(i);\n  while (true) { // size\n    if (s[i] == '+') {\n      val += term(++i);\n    } else if (s[i] == '-') {\n      val -= term(++i);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(int &i) {\n  int val = factor(i);\n  while (true) {\n    if (s[i] == '*') {\n      val *= factor(++i);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(int &i) {\n  if (s[i] == '-') {\n    return -factor(++i);\n  } else if (s[i] == '(') {\n    int val = expr(++i);\n    if (s[i] != ')') throw \"no right paren\";\n    ++i;\n    return val;\n  }\n  return number(i);\n}\n\nint number(int &i) {\n  if (not(s[i] == '0' || s[i] == '1')) throw \"not 0 or 1\";\n  if (i + 1 < s.size() && s[i] == '0' && isdigit(s[i + 1])) throw \"leading zero\";\n\n  int val = 0;\n  while (isdigit(s[i])) {\n    val <<= 1;\n    val += s[i++] - '0';\n  }\n  return val;\n}\n\nmain() {\n  string S;\n  cin >> S;\n  vector<char> cs;\n  for (auto &c : S) {\n    if (isalpha(c)) cs.emplace_back(c);\n  }\n  sort(all(cs));\n  // cs.erase(unique(all(cs)), end(cs));\n  cs.erase(unique(all(cs)), end(cs));\n  string v = \"01+-*=()\";\n  sort(all(v));\n  if (v.size() < cs.size()) return cout << 0 << endl, 0;\n  map<char, int> m;\n  {\n    int k = 0;\n    for (auto &c : S) {\n      if (isalpha(c) && not m.count(c)) m[c] = k++;\n    }\n  }\n  set<string> done;\n  int cnt = 0;\n  do {\n    s.clear();\n    for (auto &c : S) s += isalpha(c) ? v[m[c]] : c;\n    if (done.count(s)) continue;\n    if (count(all(s), '=') != 1) continue;\n    int l = 0, r = s.find('=') + 1, n = s.size();\n    if (r == 1 || r == n) continue;\n    done.emplace(s);\n    try {\n      int lhs = expr(l), rhs = expr(r);\n      cnt += s[l] == '=' && r == n && lhs == rhs;\n    } catch (...) {}\n  } while (next_permutation(all(v)));\n  cout << cnt << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <cstring>\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <map>\n#define FAIL (make_pair(0,0))\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nchar a[] = \"01+-*()=\";\nint pr[500];\nchar s[100];\nchar t[100];\nint n,ans;\nmap<char,char> m;\nbool work(stack<LL> &res,stack<char> & op){\n    if(res.empty())return 0;\n    if(res.top() == '(')return 0;\n    if(op.top() == '#'){\n        res.top() = -res.top();\n        op.pop();\n        return 1;\n    }\n    LL tem = res.top();\n    res.pop();\n    if(res.empty())return 0;\n    if(op.top() == '+'){\n        res.top() += tem;\n    }else if(op.top() == '-'){\n        res.top() -= tem;\n    }else{\n        res.top() *= tem;\n    }\n    op.pop();\n    return 1;\n}\npair<LL, bool>get(int l,int r){\n    if(l >= r)return make_pair(0, 0);\n    if(t[l] == '+' || t[l] == '*' || t[l] == ')')return FAIL;\n    if(t[r - 1] == '+' || t[r - 1] == '*' || t[r - 1] == '(' || t[r - 1] == '-')return FAIL;\n    stack<LL> res;\n    stack<char> op;\n    for(int i = l;i < r; ++i){\n        //cout << l <<\" \"<<i<<endl;\n        if(isdigit(t[i])){\n            LL tem = 0;\n            int st = i;\n            while(i < r && isdigit(t[i])){\n                tem = tem * 2 + t[i] - '0';\n                i++;\n            }\n            if(st + 1 < i && t[st] == '0')return FAIL;\n            res.push(tem);\n            i--;\n            continue;\n        }\n        if(t[i] == '('){\n            op.push('(');\n            if(i > l && (isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            if(i < r -1 && !(isdigit(t[i + 1]) || t[i + 1] == '(' || t[i + 1] == '#'))return FAIL;\n            continue;\n        }\n        if(t[i] == ')'){\n            //cout <<l <<endl;\n            if(i > l && !(isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            if(i < r - 1 && (isdigit(t[i + 1]) || t[i + 1] == '('))return FAIL;\n            while(op.empty() == false && op.top() != '('){\n                bool flag = work(res, op);\n                if(flag == 0)return FAIL;\n            }\n            if(op.empty() == true)return FAIL;\n            op.pop();\n            continue;\n        }\n        while(op.empty() == false && pr[op.top()] >= pr[t[i]]){\n            bool flag = work(res, op);\n            if(flag == 0)return FAIL;\n        }\n        op.push(t[i]);\n    }\n    while(!op.empty()){\n        bool flag = work(res, op);\n        if(flag == 0)return FAIL;\n    }\n    if(res.size() == 1)return make_pair(res.top(),1);\n    return FAIL;\n}\nbool check(){\n    for(int i = 0;i < n; ++i){\n        if(isalpha(s[i])){\n            t[i] = m[s[i]];\n        }else{\n            t[i] = s[i];\n        }\n    }\n    int n = ::n;\n    for(int i = 0;i < n; ++i){\n        if(t[i] != '-')continue;\n        if(i && (t[i - 1] == ')' || isdigit(t[i - 1]))){\n            continue;\n        }\n        t[i] = '#';\n    }\n    for(int i = 1; i < n; ++i){\n        if(t[i - 1] == '#' && t[i] == '#'){\n            for(int j = i + 1; j < n; ++j){\n                t[j - 2] = t[j];\n            }\n            n -= 2;\n            i --;\n        }\n    }\n    if(t[0] == '=' || t[n - 1] == '=')return 0;\n    int equal = 0,pos = -1;\n    for(int i = 0;i < n; ++i){\n        if(t[i] == '='){\n            equal++;\n            pos = i;\n        }\n    }\n    if(equal != 1)return 0;\n    pair<LL,bool> left = get(0,pos);\n    if(left.second == false)return 0;\n    pair<LL,bool> righ = get(pos + 1,n);\n    if(righ.second == false)return 0;\n//    if(left == righ){\n//        for(int i = 0;i < n; ++i){\n//            cout << t[i];\n//        }\n//        cout << endl;\n//    }\n    return left == righ;\n}\nvoid dfs(int o){\n    if(o == n){\n        ans += check();\n        return;\n    }\n    if(isalpha(s[o])){\n        if(m.find(s[o]) != m.end()){\n            dfs(o + 1);\n        }else{\n            for(int i = 0;i < 8; ++i){\n                if(m.find(a[i]) != m.end())continue;\n                m[s[o]] = a[i];\n                m[a[i]] = s[o];\n                dfs(o + 1);\n                m.erase(s[o]);\n                m.erase(a[i]);\n            }\n        }\n        \n    }else{\n        t[o] = s[o];\n        dfs(o + 1);\n    }\n}\nint main(){\n    pr['('] = -1;\n    pr['*'] = 1;\n    pr['+'] = 0;\n    pr['-'] = 0;\n    pr[')'] = -1;\n    pr['#'] = 3;\n    scanf(\"%s\",s);\n    n = int(strlen(s));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0LL);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0LL);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= A(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nsigned main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 0) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\ntypedef std::pair<bool,int> RES;\n\nbool parseQ(State* s);\nRES parseE(State* s);\nRES parseT(State* s);\nRES parseF(State* s);\nRES parseN(State* s);\n\nbool parseQ(State* s) {\n    RES eres1 = parseE(s);\n    if(!eres1.first || s->seek() != '=') return false;\n    s->eat('=');\n    \n    RES eres2 = parseE(s);\n    if(!eres2.first || s->isNotEOF()) return false;\n\n    return eres1.second == eres2.second;\n}\n\n//E ::= T|E+T|E???T\n//E ::= T {(+|-) T}*\nRES parseE(State* s) {\n    RES tres = parseT(s);\n    if(!tres.first) return tres;\n\n    int ans = tres.second;\n    while(s->seek() == '+' || s->seek() == '-') {\n        char op = s->getCh();\n\n        tres = parseT(s);\n        if(!tres.first) return tres;\n\n        ans += (op == '+' ? 1 : -1) * tres.second;\n    }\n    return std::make_pair(true, ans);\n}\n\n//T ::= F|T???F\n//T ::= F ('*' F)*\nRES parseT(State* s) {\n    RES fres = parseF(s);\n    if(!fres.first) return fres;\n\n    int ans = fres.second;\n    while(s->seek() == '*') {\n        s->eat('*');\n        fres = parseF(s);\n        if(!fres.first) return fres;\n\n        ans *= fres.second;\n    }\n    return std::make_pair(true, ans);\n}\n\nRES parseF(State* s) {\n    char c = s->seek();\n    if(c == '0' || c == '1') return parseN(s);\n    if(c == '-') {\n        s->eat('-');\n        auto fres = parseF(s);\n        fres.second *= -1;\n        return fres;\n    }\n    if(c == '(') {\n        s->eat('(');\n        auto eres = parseE(s);\n        if(!eres.first || s->seek() != ')') {\n            return std::make_pair(false, 0);\n        }\n        s->eat(')');\n        return eres;\n    }\n    return std::make_pair(false, 0);\n}\n\nRES parseN(State* s) {\n    if(s->seek() == '0' && (s->seek(1) == '0' || s->seek(1) == '1')) {\n        return std::make_pair(false, 0);\n    }\n\n    int v = 0;\n    while(s->isNotEOF()) {\n        char c = s->seek();\n        if(c != '0' && c != '1') {\n            break;\n        }\n        s->getCh();\n\n        v = (v << 1) + (int)(c - '0');\n    }\n    return std::make_pair(true, v);\n}\n\nVC symbol {{'0', '1', '+', '-', '*', '(', ')', '='}};\nVI used(8, 0);\nstd::string chars;\nint input_size;\nint chars_size;\n\nstd::set< std::map<char,char> > pattern;\nvoid dfs(int i, std::map<char,char>& map) {\n    if(i >= chars_size) {\n        pattern.insert(map);\n        return;\n    }\n    if(std::find(ALL(symbol), chars[i]) != symbol.end()) {\n        map[chars[i]] = chars[i];\n        dfs(i+1, map);\n    } else {\n        REP(j, 8) {\n            if(used[j] == 0) {\n                used[j] = 1;\n                map[chars[i]] = symbol[j];\n                dfs(i+1, map);\n                used[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    std::string input;\n    std::cin >> input;\n    input_size = input.size();\n\n    chars = input;\n    UNIQUE(chars);\n    chars_size = chars.size();\n\n    std::map<char,char> m;\n    dfs(0, m);\n\n    LL ans = 0;\n    for(auto p: pattern) {\n        std::string str = input;\n        REP(i, input_size) {\n            str[i] = p[str[i]];\n        }\n\n        State state = State{0, input_size, str};\n        if(parseQ(&state)) {\n            ans++;\n        }\n\n    }\n    std::cout << ans << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nstring::iterator p;\nint fact();\nint term();\nint exp();\nint k;\nbool f[2];\n\nint fact() {\n  int x;string num;\n  int mi=1;\n  if(*p=='-') {\n    mi=-1;\n    p++;\n  }\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()>1&&num[0]=='0') f[k]=0;\n  if(num.size()) {\n    x=0;\n    for(int i=num.size()-1,j=0; i>=0; i--,j++) x+=(1<<j)*(num[i]=='1');\n  } else if(p!=s[k].end()){\n    if(*p!='(') f[k]=0;\n    if(p!=s[k].end())++p;\n    x=exp();\n    if(*p!=')') f[k]=0;\n    if(p!=s[k].end())++p;\n  } else f[k]=0;\n  return x*mi;\n}\n \nint term() {\n  int x=fact();\n  while(*p=='*') {\n    if(*p=='*') {\n      ++p;\n      x*=fact();\n    }\n  }\n  return x;\n}\n \nint exp() {\n  int x=term();\n  while(*p=='+'||*p=='-') {\n    if(*p=='+') {\n      ++p;\n      x+=term();\n    } else {\n      ++p;\n      x-=term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  string r=\"01+-*()=\";\n  sort(r.begin(),r.end());\n  string t;\n  cin >> t;\n  map<char,int> m;\n  for(int i=0; i<t.size(); i++) {\n    if(isalpha(t[i])&&!m.count(t[i])) {\n      int x=m.size();\n      m[t[i]]=x;\n    }\n  }\n  if(m.size()>r.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<string> se;\n  do {\n    string e=t;\n    for(int i=0; i<e.size(); i++) {\n      if(isalpha(e[i])) e[i]=r[m[e[i]]];\n    }\n    int c=0;\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') c++;\n    }\n    if(c!=1) continue;\n    c=0;\n    s[0]=s[1]=\"\";\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') {\n        c++;\n        continue;\n      }\n      s[c]+=e[i];\n    }\n    if(!s[0].size()||!s[1].size()) continue;\n    int x[2];\n    for(k=0; k<2; k++) {\n      f[k]=1;\n      p=s[k].begin();\n      x[k]=exp();\n      int d=0;\n      for(int i=0; i<s[k].size(); i++) {\n        if(s[k][i]=='(') {\n          d++;\n          if(i&&(isdigit(s[k][i-1])||s[k][i-1]==')')) f[k]=0;\n          if(i!=s[k].size()-1&&(!isdigit(s[k][i+1])&&s[k][i+1]!='('&&s[k][i+1]!='-')) f[k]=0;\n        }\n        if(s[k][i]==')') {\n          d--;\n          if(i&&(!isdigit(s[k][i-1])&&s[k][i-1]!=')')) f[k]=0;\n          if(i!=s[k].size()-1&&isdigit(s[k][i+1])) f[k]=0;\n        }\n        if(d<0) f[k]=0;\n      }\n      if(d) f[k]=0;\n    }\n    if(f[0]&&f[1]&&x[0]==x[1]) {\n      se.insert(r.substr(0,m.size()));\n    }\n  } while(next_permutation(r.begin(),r.end()));\n  cout << se.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nbool err;\n\nstring e;\n\nll N(int l, int r);\nll F(int l, int r);\nll T(int l, int r);\nll E(int l, int r);\n\nll N(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    ll ret = 0;\n    for(int i=l; i<=r; ++i){\n        if(e[i]=='0' || e[i]=='1') ret = ret*2 + e[i]-'0';\n        else{\n            err = true;\n            return 0;\n        }\n    }\n\n    if(e[l]=='0'){\n        if(l!=r) err = true;\n    }\n    return ret;\n}\n\nll F(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    if(e[l]=='('){\n        if(e[r]!=')') err = true;\n        return E(l+1,r-1);\n    }\n    else if(e[l]=='-'){\n        return -F(l+1,r);\n    }\n    else return N(l,r);\n}\n\nll T(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    int b = 0;\n\n    int a_pos = -1;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='*'){\n            if(b==0){\n                a_pos = i;\n                break;\n            }\n        }\n    }\n\n    if(a_pos == -1) return F(l,r);\n    else return T(l,a_pos-1)*F(a_pos+1,r);\n}\n\nll E(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    char op = '?';\n    int o_pos = -1;\n    int b = 0;\n    for(int i=r; i>=l; --i){\n        if(e[i]==')') ++b;\n        else if(e[i]=='(') --b;\n\n        if(e[i]=='+' && b==0){\n            o_pos = i;\n            op = '+';\n            break;\n        }\n    }\n\n    if(op != '+'){\n        b = 0;\n        for(int i=r; i>=l; --i){\n            if(e[i]==')') ++b;\n            else if(e[i]=='(') --b;\n\n            if(e[i]=='-' && b==0){\n                o_pos = i;\n                while(l<=o_pos && e[o_pos]=='-') --o_pos;\n\n                if(o_pos<l){\n                    op = '?';\n                    break;\n                }\n                else{\n                    ++o_pos;\n                    op = '-';\n                    break;\n                }\n            }\n        }\n    }\n\n    if(op=='?') return T(l,r);\n    else if(op=='+') return E(l,o_pos-1)+T(o_pos+1,r);\n    else return E(l,o_pos-1)-T(o_pos+1,r);\n}\n\nint main(){\n    string s;\n    cin >>s;\n    int n = s.size();\n\n    set<char> a;\n    for(char c:s){\n        if(islower(c)||isupper(c)) a.insert(c);\n    }\n\n    if(a.size()>8){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    string x = \"01+-*()=\";\n    sort(all(x));\n\n    set<string> valid;\n    set<string> check;\n    do{\n        auto itr = x.begin();\n        map<char,char> cv;\n        for(char c:a){\n            cv[c] = *itr;\n            ++itr;\n        }\n\n        string t = s;\n        rep(i,n)if(cv.count(t[i])) t[i]=cv[t[i]];\n\n        int eq = 0;\n        int e_pos = -1;\n        rep(i,n){\n            if(t[i]=='='){\n                ++eq;\n                e_pos = i;\n            }\n        }\n\n        if(eq!=1) continue;\n\n        string l = t.substr(0,e_pos);\n        string r = t.substr(e_pos+1);\n        if(l.size()==0 || r.size()==0) continue;\n\n        err = false;\n\n        e = l;\n        ll L = E(0,e.size()-1);\n\n        e = r;\n        ll R = E(0,e.size()-1);\n\n        if(!err && L==R) valid.insert(t);\n        if(!err) check.insert(t);\n    }while(next_permutation(all(x)));\n\n    // for(string V:valid) dbg(V);\n    // for(string C:check) dbg(C);\n    cout << valid.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <cstring>\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <map>\n#define FAIL (make_pair(0,0))\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nchar a[] = \"01+-*()=\";\nint pr[500];\nchar s[100];\nchar t[100];\nint n,ans;\nmap<char,char> m;\nbool work(stack<LL> &res,stack<char> & op){\n    if(res.empty())return 0;\n    if(res.top() == '(')return 0;\n    if(op.top() == '#'){\n        res.top() = -res.top();\n        op.pop();\n        return 1;\n    }\n    LL tem = res.top();\n    res.pop();\n    if(res.empty())return 0;\n    if(op.top() == '+'){\n        res.top() += tem;\n    }else if(op.top() == '-'){\n        res.top() -= tem;\n    }else{\n        res.top() *= tem;\n    }\n    op.pop();\n    return 1;\n}\npair<LL, bool>get(int l,int r){\n    if(l >= r)return make_pair(0, 0);\n    if(t[l] == '+' || t[l] == '*' || t[l] == ')')return FAIL;\n    if(t[r - 1] == '+' || t[r - 1] == '*' || t[r - 1] == '(' || t[r - 1] == '-')return FAIL;\n    stack<LL> res;\n    stack<char> op;\n    for(int i = l;i < r; ++i){\n        //cout << l <<\" \"<<i<<endl;\n        if(isdigit(t[i])){\n            LL tem = 0;\n            int st = i;\n            while(i < r && isdigit(t[i])){\n                tem = tem * 2 + t[i] - '0';\n                i++;\n            }\n            if(st + 1 < i && t[st] == '0')return FAIL;\n            res.push(tem);\n            i--;\n            continue;\n        }\n        if(t[i] == '('){\n            op.push('(');\n            if(i > l && (isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            if(i < r -1 && !(isdigit(t[i + 1]) || t[i + 1] == '(' || t[i + 1] == '#'))return FAIL;\n            continue;\n        }\n        if(t[i] == ')'){\n            //cout <<l <<endl;\n            if(i > l && !(isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            if(i < r - 1 && (isdigit(t[i + 1]) || t[i + 1] == '('))return FAIL;\n            while(op.empty() == false && op.top() != '('){\n                bool flag = work(res, op);\n                if(flag == 0)return FAIL;\n            }\n            if(op.empty() == true)return FAIL;\n            op.pop();\n            continue;\n        }\n        while(op.empty() == false && pr[op.top()] >= pr[t[i]]){\n            bool flag = work(res, op);\n            if(flag == 0)return FAIL;\n        }\n        op.push(t[i]);\n    }\n    while(!op.empty()){\n        bool flag = work(res, op);\n        if(flag == 0)return FAIL;\n    }\n    if(res.size() == 1)return make_pair(res.top(),1);\n    return FAIL;\n}\nbool check(){\n    for(int i = 0;i < n; ++i){\n        if(isalpha(s[i])){\n            t[i] = m[s[i]];\n        }else{\n            t[i] = s[i];\n        }\n    }\n    int n = ::n;\n    for(int i = 0;i < n; ++i){\n        if(t[i] != '-')continue;\n        if(i && (t[i - 1] == ')' || isdigit(t[i - 1]))){\n            continue;\n        }\n        t[i] = '#';\n    }\n    for(int i = 1; i < n; ++i){\n        if(t[i - 1] == '#' && t[i] == '#'){\n            for(int j = i + 1; j < n; ++j){\n                t[j - 2] = t[j];\n            }\n            n -= 2;\n            i --;\n        }\n    }\n    if(t[0] == '=' || t[n - 1] == '=')return 0;\n    int equal = 0,pos = -1;\n    for(int i = 0;i < n; ++i){\n        if(t[i] == '='){\n            equal++;\n            pos = i;\n        }\n    }\n    if(equal != 1)return 0;\n    pair<LL,bool> left = get(0,pos);\n    if(left.second == false)return 0;\n    pair<LL,bool> righ = get(pos + 1,n);\n    if(righ.second == false)return 0;\n//    if(left == righ){\n//        for(int i = 0;i < n; ++i){\n//            cout << t[i];\n//        }\n//        cout << endl;\n//    }\n    return left == righ;\n}\nvoid dfs(int o){\n    if(o == n){\n        ans += check();\n        return;\n    }\n    if(isalpha(s[o])){\n        if(m.find(s[o]) != m.end()){\n            dfs(o + 1);\n        }else{\n            for(int i = 0;i < 8; ++i){\n                if(m.find(a[i]) != m.end())continue;\n                m[s[o]] = a[i];\n                m[a[i]] = s[o];\n                dfs(o + 1);\n                m.erase(s[o]);\n                m.erase(a[i]);\n            }\n        }\n        \n    }else{\n        t[o] = s[o];\n        dfs(o + 1);\n    }\n}\nint main(){\n    pr['('] = -1;\n    pr['*'] = 1;\n    pr['+'] = 0;\n    pr['-'] = 0;\n    pr[')'] = -1;\n    pr['#'] = 3;\n    scanf(\"%s\",s);\n    n = int(strlen(s));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0LL);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= C(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nsigned main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 11) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren++;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// +?????§??????\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '+') {\n\t\t\tif (i == 0 || !(m[str[i - 1]] == '0' || m[str[i - 1]] == '1' || m[str[i - 1]] == ')'))return false;\n\t\t}\n\t}\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && (m[tmp[tmp.size() - 1]] == '=' || m[tmp[tmp.size() - 1]] == '(' || m[tmp[tmp.size() - 1]] == '*') && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\t//cout << tmp << endl;\n\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\t//cout << lhs << \" \" << rhs << endl;\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\t/*\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tstring d = \"(0)\";\n\tcout << \"xo\"[isE(d, m, d.begin(), d.end())] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1-11010=(10110)-10\", m)] << endl;\n\tcout << \"xo\"[isQ(\"(--0)=0\", m)] << endl;\n\tcout << \"xo\"[check(\"(--0)=0\", m)] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m)) {\n\t\t\t/*\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t\t//*/\n\t\t\tif (check(str, m)) {\n\t\t\t\t//cout << \"=======================\" << endl;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar component_array[8] = {'0','1','+','-','*','(',')','=',};\nint table[40320][8];\nint num_of_type,table_index;\n\nint calc_E(char line[32],int left,int right);\nint calc_T(char line[32],int left,int right);\nint calc_F(char line[32],int left,int right);\nint calc_NUM(char line[32],int left,int right);\n\nbool is_component(char ch){\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(ch == component_array[i])return true;\n\t}\n\n\treturn false;\n}\n\nvoid makeTable(bool used[8],int change_list[8],int index){\n\n\tif(index == num_of_type){\n\t\tfor(int i = 0; i < num_of_type; i++){\n\t\t\ttable[table_index][i] = change_list[i];\n\t\t}\n\t\ttable_index++;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(used[i] == false){\n\n\t\t\tbool next_used[8];\n\t\t\tint next_change_list[8];\n\n\t\t\tfor(int k = 0; k < 8; k++)next_used[k] = used[k];\n\t\t\tfor(int k = 0; k < index; k++)next_change_list[k] = change_list[k];\n\n\t\t\tnext_used[i] = true;\n\t\t\tnext_change_list[index] = i;\n\n\t\t\tmakeTable(next_used,next_change_list,index+1);\n\t\t}\n\t}\n}\n\nbool is_OK(char work[32]){\n\n\tint length;\n\tfor(length = 0; work[length] != '\\0'; length++);\n\n\tint equal_count = 0;\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif(work[i] == '=')equal_count++;\n\t}\n\tif(equal_count != 1)return false;\n\n\tint eq_pos;\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '='){\n\t\t\teq_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(eq_pos == 0 || eq_pos == length-1)return false;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(' && work[i+1] == ')')return false;\n\t\tif(work[i] == ')' && work[i+1] == '(')return false;\n\t}\n\n\n\tstack<int> S;\n\tfor(int i = 0; i < eq_pos; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\tfor(int i = eq_pos+1; i < length; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif((work[i] == '0' || work[i] == '1') && work[i+1] == '(')return false;\n\t\tif((work[i] == '(') && (work[i+1] == '*' || work[i+1] == '+'))return false;\n\t}\n\n\tfor(int i = 0; work[i] != '\\0';){\n\t\tif(work[i] != '0' && work[i] != '1')i++;\n\t\telse{\n\t\t\tif(work[i] == '1'){\n\t\t\t\twhile(work[i] == '1' || work[i] == '0')i++;\n\t\t\t}else{\n\t\t\t\tif(work[i+1] == '1' || work[i+1] == '0')return false;\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif((work[i] == '+' || work[i] == '*') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '-' || work[i+1] == '=' || work[i+1] == '\\0'))return false;\n\n\t\tif((work[i] == '-') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '=' || work[i+1] == '\\0'))return false;\n\n\t\tif((work[i] == '=') && (work[i+1] == '+' || work[i+1] == '*'))return false;\n\t}\n\n\tif(work[0] == '+' || work[0] == '*')return false;\n\n\treturn true;\n}\n\nint calc_E(char line[32],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif(i != left){\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\twhile(line[i] == '-')i++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_T(line,left,right);\n\t}\n\n\tint tmp = calc_E(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(char line[32],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_F(line,left,right);\n\t}\n\n\tint tmp = calc_T(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\ttmp *= tmp_right;\n\t}\n\treturn tmp;\n}\n\nint calc_F(char line[32],int left,int right){\n\n\tif(line[left] == '1' || line[left] == '0'){\n\t\treturn calc_NUM(line,left,right);\n\t}else if(line[left] == '-'){\n\t\treturn -1*calc_F(line,left+1,right);\n\t}else if(line[left] == '('){\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM)return BIG_NUM;\n\n\t\treturn calc_E(line,left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(char line[32],int left,int right){\n\n\tfor(int i = left; i <= right; i++){\n\t\tif(line[i] != '0' && line[i] != '1')return BIG_NUM;\n\t}\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 2*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tchar buf[32];\n\tscanf(\"%s\",buf);\n\n\tint check_table[128];\n\tfor(int i = 0; i < 128; i++)check_table[i] = 0;\n\n\tvector<int> CHAR_LIST,REPLACE_LOC[128];\n\tnum_of_type = 0;\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tif(!is_component(buf[i])){\n\n\t\t\tREPLACE_LOC[buf[i]].push_back(i);\n\n\t\t\tif(check_table[buf[i]] == 0){\n\t\t\t\tnum_of_type++;\n\t\t\t\tcheck_table[buf[i]]++;\n\t\t\t\tCHAR_LIST.push_back(buf[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(num_of_type > 8){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tchar work[32],left_table[32],right_table[32];\n\tint eq_pos,left_result,right_result,right_length,ans = 0;\n\n\tif(num_of_type == 0){\n\n\t\tif(!is_OK(buf)){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\t\tif(buf[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = buf[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; buf[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = buf[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\tif(abs(left_result) == BIG_NUM){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\n\t\tif(left_result == right_result){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tbool first_used[8];\n\tfor(int i = 0; i < 8; i++)first_used[i] = false;\n\tint first_change_list[8];\n\ttable_index = 0;\n\tmakeTable(first_used,first_change_list,0);\n\n\tfor(int i = 0; i < table_index; i++){\n\n\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\t\t\twork[k] = buf[k];\n\t\t\twork[k+1] = '\\0';\n\t\t}\n\n\t\tfor(int k = 0; k < num_of_type; k++){\n\t\t\tint word = CHAR_LIST[k];\n\t\t\tfor(int a = 0; a < REPLACE_LOC[word].size(); a++){\n\t\t\t\tint loc = REPLACE_LOC[word][a];\n\t\t\t\twork[loc] = component_array[table[i][k]];\n\t\t\t}\n\t\t}\n\t\tif(!is_OK(work))continue;\n\n\t\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\t\tif(work[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = work[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; work[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = work[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\tif(abs(left_result) == BIG_NUM)continue;\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\t\tif(abs(right_result) == BIG_NUM)continue;\n\n\t\tif(left_result == right_result){\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdexcept>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw;\n  if(S[idx] != c) throw;\n  idx ++;\n}\n\nbool try_consume(char c) {\n  if(idx >= N) return false;\n  if(S[idx] != c) return false;\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (...) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tif (ans == 4) { assert(0); }\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\ntypedef std::pair<bool,int> RES;\n\nbool parseQ(State* s);\nRES parseE(State* s);\nRES parseT(State* s);\nRES parseF(State* s);\nRES parseN(State* s);\n\nbool parseQ(State* s) {\n    RES eres1 = parseE(s);\n    if(!eres1.first || s->seek() != '=') return false;\n    s->eat('=');\n    \n    RES eres2 = parseE(s);\n    if(!eres2.first || s->isNotEOF()) return false;\n\n    return eres1.second == eres2.second;\n}\n\n//E ::= T|E+T|E???T\n//E ::= T {(+|-) T}*\nRES parseE(State* s) {\n    RES tres = parseT(s);\n    if(!tres.first) return tres;\n\n    int ans = tres.second;\n    while(s->seek() == '+' || s->seek() == '-') {\n        char op = s->getCh();\n\n        tres = parseT(s);\n        if(!tres.first) return tres;\n\n        ans += (op == '+' ? 1 : -1) * tres.second;\n    }\n    return std::make_pair(true, ans);\n}\n\n//T ::= F|T???F\n//T ::= F ('*' F)*\nRES parseT(State* s) {\n    RES fres = parseF(s);\n    if(!fres.first) return fres;\n\n    int ans = fres.second;\n    while(s->seek() == '*') {\n        s->eat('*');\n        fres = parseF(s);\n        if(!fres.first) return fres;\n\n        ans *= fres.second;\n    }\n    return std::make_pair(true, ans);\n}\n\nRES parseF(State* s) {\n    char c = s->seek();\n    if(c == '0' || c == '1') return parseN(s);\n    if(c == '-') {\n        s->eat('-');\n        auto fres = parseF(s);\n        fres.second *= -1;\n        return fres;\n    }\n    if(c == '(') {\n        s->eat('(');\n        auto eres = parseE(s);\n        if(!eres.first || s->seek() != ')') {\n            return std::make_pair(false, 0);\n        }\n        s->eat(')');\n        return eres;\n    }\n    return std::make_pair(false, 0);\n}\n\nRES parseN(State* s) {\n    if(s->seek() == '0' && (s->seek(1) == '0' || s->seek(1) == '1')) {\n        return std::make_pair(false, 0);\n    }\n\n    int v = 0;\n    while(s->isNotEOF()) {\n        char c = s->seek();\n        if(c != '0' && c != '1') {\n            break;\n        }\n        s->getCh();\n\n        v = (v << 1) + (int)(c - '0');\n    }\n    return std::make_pair(true, v);\n}\n\nVC symbol {{'0', '1', '+', '-', '*', '(', ')', '='}};\nVI used(8, 0);\nstd::string chars;\nint input_size;\nint chars_size;\n\nstd::set< std::map<char,char> > pattern;\nvoid dfs(int i, std::map<char,char>& map) {\n    if(i >= chars_size) {\n        pattern.insert(map);\n        return;\n    }\n    if(std::find(ALL(symbol), chars[i]) != symbol.end()) {\n        map[chars[i]] = chars[i];\n        dfs(i+1, map);\n    } else {\n        REP(j, 8) {\n            if(used[j] == 0) {\n                used[j] = 1;\n                map[chars[i]] = symbol[j];\n                dfs(i+1, map);\n                used[j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    std::string input;\n    std::cin >> input;\n    input_size = input.size();\n\n    chars = input;\n    UNIQUE(chars);\n    chars_size = chars.size();\n\n    std::map<char,char> m;\n    dfs(0, m);\n\n    LL ans = 0;\n    for(auto p: pattern) {\n        std::string str = input;\n        REP(i, input_size) {\n            str[i] = p[str[i]];\n        }\n\n        State state = State{0, input_size, str};\n        if(parseQ(&state)) {\n            ans++;\n            std::cout << str << std::endl;\n        }\n\n    }\n    std::cout << ans << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<sstream>\n#include<deque>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdlib>\n#include<climits>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll LLINF = LLONG_MAX;\nconst bool debug = false;\nconst string opr = \"01+-*=()\";\n\nstring context;\nint n;\n\nll parse_E(int&,string&);\n\nll parse_F(int &p,string &s) {\n  if( p >= (int)s.size() ) return LLINF;\n  if( s[p] == '+' ) return LLINF;\n  if( s[p] == '-' ) {\n    ++p;\n    ll v = parse_F(p,s);\n    if( v == LLINF ) return LLINF;\n    return v * -1LL;\n  } \n  if( s[p] == '(' ) {\n    ++p;\n    ll v = parse_E(p,s);\n    if( v == LLINF ) return LLINF;\n    if( p >= (int)s.size() ) return LLINF;\n    if( s[p] != ')' ) return LLINF;\n    ++p;\n    if( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) return LLINF;\n    return v;\n  }\n  int cnt = 0;\n  ll v = 0;\n  bool first_zero = ( s[p] == '0' );\n  while( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) {\n    v <<= 1;\n    v += (ll)( s[p] - '0' );\n    ++p;\n    ++cnt;\n  }\n  if( first_zero && cnt != 1 ) return LLINF;\n  if( cnt == 0 ) return LLINF;\n  if( p < (int)s.size() && s[p] == '(' ) return LLINF;\n  return v;\n}\n\nll parse_T(int &p,string &s) {\n  ll v = parse_F(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && s[p] == '*' ) {\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    v *= tmp;\n  }\n  return v;\n}\n\nll parse_E(int &p,string &s) {\n  ll v = parse_T(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && ( s[p] == '+' || s[p] == '-' ) ) {\n    char op = s[p];\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    if( op == '+' ) v += tmp;\n    if( op == '-' ) v -= tmp;\n  }\n  return v;\n}\n\nbool pari_check(string &s) {\n  int cnt = 0;\n  rep(i,(int)s.size()) {\n    if( s[i] == '(' ) ++cnt;\n    if( s[i] == ')' ) --cnt;\n    if( cnt < 0 ) return false;\n  }\n  return cnt == 0;\n}\n\nbool check() {\n  string s,t;\n  {\n    string tmp;\n    tmp = context;\n    rep(i,n) if( context[i] == '=' ) tmp[i] = ' ';\n    vector<string> vec;\n    stringstream ss;\n    ss << tmp;\n    while( ss >> s ) vec.push_back(s);\n    if( vec.size() != 2 ) return false;\n    s = vec[0];\n    t = vec[1];\n  }\n  if( !pari_check(s) || !pari_check(t) ) return false;\n  int p = 0;\n  ll sv = parse_E(p,s);\n  p = 0;\n  ll tv = parse_E(p,t);\n  if( sv == LLINF || tv == LLINF) return false;\n  return sv == tv;\n}\n\nint dfs(int ptr,int used,vector<char> &already) {\n  if( n <= ptr ) {\n    if( debug ) {\n      if( check() ) {\n\tcout << \"succeeded : \" << context << endl;\n\treturn true;\n      } else {\n\t//cout << \"failed    : \" << context << endl;\n\treturn false;\n      }\n    } else {\n      return check();\n    }\n  }\n  if( !isalpha(context[ptr]) ) return dfs(ptr+1,used,already);\n  int sum = 0;\n  int v = context[ptr] - 'a';\n  if( already[v] != '$' ) {\n    if( already[v] == '=' ) return 0;\n    char tmp = context[ptr];\n    context[ptr] = already[v];\n    sum += dfs(ptr+1,used,already);\n    context[ptr] = tmp;\n    return sum;\n  }\n  rep(i,(int)opr.size()) {\n    if( ( used >> i ) & 1 ) continue;\n    char tmp = context[ptr];\n    context[ptr] = opr[i];\n    already[v] = opr[i];\n    sum += dfs(ptr+1,used|(1<<i),already);\n    already[v] = '$';\n    context[ptr] = tmp;\n  }\n  return sum;\n}\n\nbool normalize() {\n  vector<char> vec;\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) vec.push_back(context[i]);\n  sort(all(vec));\n  vec.erase(unique(all(vec)),vec.end());\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) {\n    int pos = lower_bound(all(vec),context[i]) - vec.begin();\n    context[i] = (char)('a'+pos);\n  }\n  return (int)vec.size() <= 8;\n}\n\nvoid compute() {\n  if( debug ) cout << \"      context : \" << context << endl;\n  if( !normalize() ) { puts(\"0\"); return; }\n  if( debug ) cout << \"fixed context : \" << context << endl;\n  n = (int)context.size();\n  int used = 0;\n  rep(i,n) if( context[i] == '=' ) { used = (1<<5); break; }\n  vector<char> vec(8,'$');\n  cout << dfs(0,used,vec) << endl;\n}\n\nint main() {\n  if( 0 ) {\n    string s;\n    cin >> s;\n    int p = 0;\n    cout << parse_E(p,s) << endl;\n    return 0;\n  }\n  cin >> context;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nstruct ConsumeException{};\n\nvoid consume(char c) {\n  if(idx >= N) throw ConsumeException();\n  if(S[idx] != c) throw ConsumeException();\n  idx ++;\n}\n\nbool try_consume(char c) {\n  try {\n    consume(c);\n  } catch(ConsumeException e) {\n    return false;\n  }\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (...) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren++;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// +?????§??????\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '+') {\n\t\t\tif (i == 0 || !(m[str[i - 1]] == '0' || m[str[i - 1]] == '1' || m[str[i - 1]] == ')'))return false;\n\t\t}\n\t}\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\t//cout << tmp << endl;\n\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\t//cout << lhs << \" \" << rhs << endl;\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\t/*\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tstring d = \"1*-1\";\n\tcout << \"xo\"[isE(d, m, d.begin(), d.end())] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1-11010=(10110)-10\", m)] << endl;\n\tcout << \"xo\"[isQ(\"--1001=1001\", m)] << endl;\n\tcout << \"xo\"[check(\"--1001=1001\", m)] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m)) {\n\t\t\t/*\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t\t//*/\n\t\t\tif (check(str, m)) {\n\t\t\t\t//cout << \"=======================\" << endl;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nstring S;\n\nint ei(string::iterator &it,int r){\n    if(r==0){\n        vint lis;\n        while(it!=S.end()){\n            int x=ei(it,1);\n            if(*it!='='||x==INF)return INF;\n            lis.pb(x);\n            it++;\n        }\n        if(lis.size()!=2||lis[0]!=lis[1])return INF;\n        return 114514;\n    }\n\n    if(r==1){\n        int ret=ei(it,2);\n        if(ret==INF)return INF;\n        while(true){\n            if(*it=='+'){\n                it++;\n                int x=ei(it,2);\n                if(x==INF)return INF;\n                ret+=x;\n            }\n            else if(*it=='-'){\n                it++;\n                int x=ei(it,2);\n                if(x==INF)return INF;\n                ret-=x;\n            }\n            else break;\n        }\n        return ret;\n    }\n\n    if(r==2){\n        int ret=ei(it,3);\n        if(ret==INF)return INF;\n        while(true){\n            if(*it=='*'){\n                it++;\n                int x=ei(it,3);\n                if(x==INF)return INF;\n                ret*=x;\n            }\n            else break;\n        }\n        return ret;\n    }\n    if(r==3){\n        if(*it=='-'){\n            it++;\n            int x=ei(it,3);\n            if(x==INF)return INF;\n            return -x;\n        }\n        if(*it=='('){\n            it++;\n            int x=ei(it,1);\n            if(*it!=')')return INF;\n            it++;\n            if(x==INF)return INF;\n            return x;\n        }\n        return ei(it,4);\n    }\n\n    if(r==4){\n        bool f=*it=='0';\n        if(!isdigit(*it))return INF;\n        int ret=0;\n        int cnt=0;\n        while(isdigit(*it)){\n            ret=ret*2+*it-'0';\n            it++;\n            cnt++;\n        }\n        \n        if(f&&cnt!=1)return INF;\n        return ret;\n    }\n}\n\nsigned main(){\n    string s;cin>>s;\n\n    vector<char>v;\n    rep(i,s.size())if(isalpha(s[i]))v.pb(s[i]);\n    sort(all(v));v.erase(unique(all(v)),v.end());\n\n    if(v.size()>8){\n        cout<<0<<endl;\n        return 0;\n    }\n\n    string x=\"+-*()=01\";\n    sort(all(x));\n\n    int ans=0;\n\n\n    set<string>st;\n    do{\n        S=s;\n        rep(i,S.size()){\n            if(isalpha(S[i])){\n                int k=lower_bound(all(v),S[i])-v.begin();\n                S[i]=x[k];\n            }\n        }\n        S+=\"=\";\n        auto it=S.begin();\n        if(ei(it,0)!=INF){\n            ans++;\n        }\n    }while(next_permutation(all(x)));\n\n\n    rep(i,(int)x.size()-(int)v.size())ans/=i+1;\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  if(str[now+1]=='+'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t+p;\n  }\n  if(str[now+1]=='-'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t-p;\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size()>moji.size()){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do { //next_permutation moji\n    bool flg=true;\n\n    string newstr(s);\n    int idx=0;\n    if(flg){\n      for(auto c : m){\n        // str?????????c???moji[idx]???????????????\n        rep(i, newstr.size()) if(newstr[i]==c){\n          newstr[i] = moji[idx];\n        }\n        idx++;\n      }\n    }\n    idx = newstr.find('=');\n    if(newstr[0]=='=' || idx<0) flg=false;\n\n    if(flg){\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <cstring>\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <map>\n#define FAIL (make_pair(0,0))\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nchar a[] = \"01+-*()=\";\nint pr[500];\nchar s[100];\nchar t[100];\nint n,ans;\nmap<char,char> m;\nbool work(stack<LL> &res,stack<char> & op){\n    if(res.empty())return 0;\n    if(res.top() == '(')return 0;\n    if(op.top() == '#'){\n        res.top() = -res.top();\n        op.pop();\n        return 1;\n    }\n    LL tem = res.top();\n    res.pop();\n    if(res.empty())return 0;\n    if(op.top() == '+'){\n        res.top() += tem;\n    }else if(op.top() == '-'){\n        res.top() -= tem;\n    }else{\n        res.top() *= tem;\n    }\n    op.pop();\n    return 1;\n}\npair<LL, bool>get(int l,int r){\n    if(l >= r)return make_pair(0, 0);\n    if(t[l] == '+' || t[l] == '*' || t[l] == ')')return FAIL;\n    if(t[r - 1] == '+' || t[r - 1] == '*' || t[r - 1] == '(' || t[r - 1] == '-')return FAIL;\n    stack<LL> res;\n    stack<char> op;\n    for(int i = l;i < r; ++i){\n        //cout << l <<\" \"<<i<<endl;\n        if(isdigit(t[i])){\n            LL tem = 0;\n            int st = i;\n            while(i < r && isdigit(t[i])){\n                tem = tem * 2 + t[i] - '0';\n                i++;\n            }\n            if(st + 1 < i && t[st] == '0')return FAIL;\n            res.push(tem);\n            i--;\n            continue;\n        }\n        if(t[i] == '('){\n            op.push('(');\n            if(i > l && (isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            if(i < r -1 && !(isdigit(t[i + 1]) || t[i + 1] == '(' || t[i + 1] == '#'))return FAIL;\n            continue;\n        }\n        if(t[i] == ')'){\n            //cout <<l <<endl;\n            if(i > l && !(isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            if(i < r - 1 && (isdigit(t[i + 1] || t[i + 1] == '(')))return FAIL;\n            while(op.empty() == false && op.top() != '('){\n                bool flag = work(res, op);\n                if(flag == 0)return FAIL;\n            }\n            if(op.empty() == true)return FAIL;\n            op.pop();\n            continue;\n        }\n        while(op.empty() == false && pr[op.top()] >= pr[t[i]]){\n            bool flag = work(res, op);\n            if(flag == 0)return FAIL;\n        }\n        op.push(t[i]);\n    }\n    while(!op.empty()){\n        bool flag = work(res, op);\n        if(flag == 0)return FAIL;\n    }\n    if(res.size() == 1)return make_pair(res.top(),1);\n    return FAIL;\n}\nbool check(){\n    for(int i = 0;i < n; ++i){\n        if(isalpha(s[i])){\n            t[i] = m[s[i]];\n        }else{\n            t[i] = s[i];\n        }\n    }\n    int n = ::n;\n    for(int i = 0;i < n; ++i){\n        if(t[i] != '-')continue;\n        if(i && (t[i - 1] == ')' || isdigit(t[i - 1]))){\n            continue;\n        }\n        t[i] = '#';\n    }\n    for(int i = 1; i < n; ++i){\n        if(t[i - 1] == '#' && t[i] == '#'){\n            for(int j = i + 1; j < n; ++j){\n                t[j - 2] = t[j];\n            }\n            n -= 2;\n            i --;\n        }\n    }\n    if(t[0] == '=' || t[n - 1] == '=')return 0;\n    int equal = 0,pos = -1;\n    for(int i = 0;i < n; ++i){\n        if(t[i] == '='){\n            equal++;\n            pos = i;\n        }\n    }\n    if(equal != 1)return 0;\n    pair<LL,bool> left = get(0,pos);\n    if(left.second == false)return 0;\n    pair<LL,bool> righ = get(pos + 1,n);\n    if(righ.second == false)return 0;\n//    if(left == righ){\n//        for(int i = 0;i < n; ++i){\n//            cout << t[i];\n//        }\n//        cout << endl;\n//    }\n    return left == righ;\n}\nvoid dfs(int o){\n    if(o == n){\n        ans += check();\n        return;\n    }\n    if(isalpha(s[o])){\n        if(m.find(s[o]) != m.end()){\n            dfs(o + 1);\n        }else{\n            for(int i = 0;i < 8; ++i){\n                if(m.find(a[i]) != m.end())continue;\n                m[s[o]] = a[i];\n                m[a[i]] = s[o];\n                dfs(o + 1);\n                m.erase(s[o]);\n                m.erase(a[i]);\n            }\n        }\n        \n    }else{\n        t[o] = s[o];\n        dfs(o + 1);\n    }\n}\nint main(){\n    pr['('] = -1;\n    pr['*'] = 1;\n    pr['+'] = 0;\n    pr['-'] = 0;\n    pr[')'] = -1;\n    pr['#'] = 3;\n    scanf(\"%s\",s);\n    n = int(strlen(s));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <stdexcept>\n\nconst std::string TERMINAL = \"01+-*()=\";\nconst std::vector<std::string> OPS = {\"+-\", \"*\"};\n\nint parse(const std::string& s, size_t& i, size_t preced=0) {\n  if (preced == OPS.size()) {\n    if (s[i] == '(') {\n      int res = parse(s, ++i, 0);\n      if (s[i] != ')') throw std::logic_error(\"expected: closing parenthesis\");\n      ++i;\n      return res;\n    }\n    if (s[i] == '-') {\n      return -parse(s, ++i, preced);\n    }\n    if (s[i] == '0') {\n      ++i;\n      if (isdigit(s[i]))\n        throw std::logic_error(\"expected: leading-zero-free number\");\n\n      return 0;\n    }\n    if (isdigit(s[i])) {\n      int res = s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        res = res*2 + s[i]-'0';\n      return res;\n    }\n    throw std::logic_error(\"unexpected token\");\n  }\n\n  int lhs = parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op = s[i];\n    if (!std::count(OPS[preced].begin(), OPS[preced].end(), op)) break;\n    int rhs = parse(s, ++i, preced+1);\n    if (op == '+') lhs += rhs;\n    if (op == '-') lhs -= rhs;\n    if (op == '*') lhs *= rhs;\n  }\n  return lhs;\n}\n\nvoid validate(const std::string& s) {\n  size_t i = 0;\n  int lhs = parse(s, i);\n  if (s[i] != '=') throw std::logic_error(\"excepted: equal sign\");\n  ++i;\n  int rhs = parse(s, i);\n  if (i != s.length()) throw std::logic_error(\"expected: EOL\");\n  if (lhs != rhs) throw std::logic_error(\"not equal\");\n\n  // validated\n}\n\nint main() {\n  char buf[32];\n  scanf(\"%s\", buf);\n  std::string s = buf;\n\n  std::set<char> alpha;\n  for (char ch: s)\n    if (isalpha(ch)) alpha.insert(ch);\n\n  if (alpha.size() > TERMINAL.size())\n    return puts(\"0\"), 0;\n\n  std::vector<char> t;\n  for (char ch: TERMINAL) t.push_back(ch);\n  std::sort(t.begin(), t.end());\n  std::set<std::string> eq;\n  do {\n    std::map<char, char> enc;\n    {\n      size_t i = 0;\n      for (auto it=alpha.begin(); it!=alpha.end(); ++it)\n        enc[*it] = t[i++];\n    }\n\n    std::string s1 = s;\n    for (char &c: s1)\n      if (isalpha(c)) c = enc[c];\n\n    try {\n      validate(s1);\n      eq.insert(s1);\n    } catch (std::logic_error&) {\n      void(0);\n    }\n  } while (std::next_permutation(t.begin() ,t.end()));\n\n  printf(\"%zu\\n\", eq.size());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  if(str[now+1]=='+'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t+p;\n  }\n  if(str[now+1]=='-'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t-p;\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size()>moji.size()){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do { //next_permutation moji\n    string newstr(s);\n\n    auto itr = m.begin();\n    rep(i, m.size()){\n      rep(j, newstr.size()) if(newstr[j]==*itr){\n        newstr[j] = moji[i];\n      }\n      itr++;\n    }\n\n    int idx = newstr.find('=');\n    if(idx>0 && idx<newstr.size()-1){ // not ('=' is not found or at the head of string)\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++ i)\nusing namespace std;\n\nvoid Q();\nint E();\nint T();\nint F();\nint N();\nint B();\n\nint m;\nstring s;\nsize_t cur;\nbool failed;\n\n//Q::=E=E\nvoid Q(){\n\tcur = 0,failed = 0;\n\tm = s.size();\n\tint l = E();\n\tif(s[cur]!='=') failed = 1;\n\tcur++;\n\tint r = E();\n\tif(cur != m or l != r) failed = 1;\n}\n\n// E::=T|E+T|E???T\nint E(){\n\tint res = T();\n\n\twhile(cur < m and s[cur] == '+' or s[cur] == '-'){\n\t\tchar op = s[cur];\n\t\tcur++;\n\t\tconst int arg = T();\n\t\tif(op == '+')\n\t\t\tres += arg;\n\t\telse\n\t\t\tres -= arg;\n\t}\n\n\treturn res;\n}\n\n// T::=F|T???F\n\nint T(){\n\tint res = F();\n\n\twhile(cur < m and s[cur] == '*'){\n\t\tcur++;\n\t\tconst int arg = F();\n\t\tres *= arg;\n\t}\n\t\n\treturn res;\n\n}\n\n// F::=N|???F|(E)\nint F(){\n\tif(cur < m and isdigit(s[cur])){\n\t\treturn N();\n\t}else if(cur < m and s[cur]=='-'){\n\t\tcur++;\n\t\treturn -F();\n\t}else if(cur < m and s[cur]=='('){\n\t\tcur++;\n\t\tconst int res = E();\n\t\tif(s[cur]!=')') failed = true;\n\t\tcur++;\n\t\treturn res;\n\t}else{\n\t\tfailed = true;\n\t\treturn 0;\n\t}\n}\n\n// N::=0|1B\nint N(){\n\tif(cur < m and s[cur]=='0'){\n\t\tcur++;\n\t\treturn 0;\n\t}else if(cur < m and s[cur]=='1'){\n\t\tcur++;\n\t\treturn B();\n\t}else{\n\t\tfailed = true;\n\t\treturn 0;\n\t}\n}\n\n// B::=??|0B|1B\nint B(){\n\tint res = 1;\n\twhile(cur < m and isdigit(s[cur])){\n\t\tres = 2 * res + (s[cur] - '0');\n\t\tcur++;\n\t}\n\t//cerr << res << endl;\n\treturn res;\n}\n\nchar letter[8] = {'0','1','+','-','*','(',')','='};\n\n\nint main(void){\n\tstring t;\n\tcin >> t;\n\n\tconst int n = t.size();\n\tvector<char> ary;\n\trep(i,n) if(isalpha(t[i])) ary.push_back(t[i]);\n\n\tsort(begin(ary),end(ary));\n\tary.erase(unique(begin(ary),end(ary)),end(ary));\n\n\tconst int l = ary.size();\n\n\tif(l > 8){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tset<string> eq;\n\n\tsort(letter,letter+8);\n\tdo{\n\t\tstring nt = t;\n\t\trep(i,n){\n\t\t\tif(isalpha(nt[i])){\n\t\t\t\trep(j,l) if(nt[i] == ary[j]) nt[i] = letter[j];\n\t\t\t}\n\t\t}\n\t\teq.insert(nt);\n\t}while(next_permutation(letter,letter+8));\n\n\tint ans = 0;\n\tfor(auto &it:eq){\n\t\t//cerr << it << endl;\n\t\ts = it;\n\t\tQ();\n\t\tans += (failed == 0);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw(0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nint main()\n{\n  sort(begin(temp), end(temp));\n\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) if(isalpha(c)) num.push_back(c);\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > 6) {\n    cout << 0 << endl;\n    return (0);\n  }\n\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdint>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <stdexcept>\n#include <string>\n#include <utility>\n\nusing Num = std::int64_t;\n\nclass Solver {\n  public:\n    std::string s;\n    Num solve() {\n      std::map<char, int> char_idx;\n      std::string symbols = \"=+-*01()\";\n      Num num = 0;\n      for (auto c : s) {\n        if (std::isalpha(c) and char_idx.count(c) == 0) {\n          int x = char_idx.size();\n          char_idx[c] = x;\n        }\n      }\n      if (char_idx.size() > 8) return 0;\n      s_ = s;\n      s_.push_back('\\0');\n      std::sort(symbols.begin(), symbols.end());\n      do {\n        for (std::size_t i = 0; i < s_.size(); ++i) {\n          s_[i] = (isalpha(s[i])? symbols[char_idx[s[i]]]: s[i]);\n        }\n        if (eval_q()) ++num;\n        std::reverse(symbols.begin() + char_idx.size(), symbols.end());\n      } while (std::next_permutation(symbols.begin(), symbols.end()));\n      return num;\n    }\n  private:\n    std::string s_;\n    bool eval_q() {\n      // std::cerr << \"TRY: \" << s_ << std::endl;\n      try {\n        std::size_t i = 0;\n        Num left, right;\n        left = eval_e(i);\n        if (s_[i] != '=') throw std::runtime_error(\"left\");\n        ++i;\n        right = eval_e(i);\n        if (i < s.size()) throw std::runtime_error(\"right\");\n        // std::cerr << left << (left == right? \" == \": \" != \") << right << std::endl;\n        return left == right;\n      } catch (std::runtime_error &e) {\n        // std::cerr << \"FAIL: \" << e.what() << std::endl;\n        return false;\n      }\n    }\n    Num eval_e(std::size_t &i) {\n      Num n = eval_t(i);\n      while (i < s.size()) {\n        if (s_[i] == '+') {\n          ++i;\n          n += eval_t(i);\n        } else if (s_[i] == '-') {\n          ++i;\n          n -= eval_t(i);\n        } else {\n          break;\n        }\n      }\n      return n;\n    }\n    Num eval_t(std::size_t &i) {\n      Num n = eval_f(i);\n      while (s_[i] == '*') {\n        ++i;\n        n *= eval_f(i);\n      }\n      return n;\n    }\n    Num eval_f(std::size_t &i) {\n      Num n;\n      if (s_[i] == '-') {\n        ++i;\n        n = -eval_f(i);\n      } else if (s_[i] == '(') {\n        ++i;\n        n = eval_e(i);\n        if (s_[i] != ')') throw std::runtime_error(\")\");\n        ++i;\n      } else {\n        n = eval_n(i);\n      }\n      return n;\n    }\n    Num eval_n(std::size_t &i) {\n      if (s_[i] == '0' or s_[i] == '1') {\n        Num n = s_[i] - '0';\n        ++i;\n        if (n == 0 and (s_[i] == '0' or s_[i] == '1')) throw std::runtime_error(\"leading zero\");\n        while (true) {\n          if (s_[i] == '0' or s_[i] == '1') {\n            n = 2 * n + s_[i] - '0';\n            ++i;\n          } else {\n            break;\n          }\n        }\n        return n;\n      } else {\n        throw std::runtime_error(\"N\");\n      }\n    }\n};\n\nint main() {\n  Solver s;\n  std::cin >> s.s;\n  std::cout << s.solve() << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nstring::iterator p;\nint fact();\nint term();\nint exp();\nint k;\nbool f[2];\n \nint fact() {\n  int x;string num;\n  int mi=1;\n  while(*p=='-') {\n    mi*=-1;\n    ++p;\n  }\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()>1&&num[0]=='0') f[k]=0;\n  if(num.size()) {\n    x=0;\n    for(int i=num.size()-1,j=0; i>=0; i--,j++) x+=(1<<j)*(num[i]=='1');\n  } else if(p!=s[k].end()){\n    if(*p!='(') f[k]=0;\n    if(p!=s[k].end())++p;\n    x=exp();\n    if(*p!=')') f[k]=0;\n    if(p!=s[k].end())++p;\n  } else f[k]=0;\n  return x*mi;\n}\n  \nint term() {\n  int x=fact();\n  while(*p=='*') {\n    ++p;\n    x*=fact();\n  }\n  return x;\n}\n  \nint exp() {\n  int x=term();\n  while(*p=='+'||*p=='-') {\n    if(*p=='+') {\n      ++p;\n      x+=term();\n    } else {\n      ++p;\n      x-=term();\n    }\n  }\n  return x;\n}\n \nint main() {\n  string r=\"01+-*()=\";\n  sort(r.begin(),r.end());\n  string t;\n  cin >> t;\n  map<char,int> m;\n  for(int i=0; i<t.size(); i++) {\n    if(isalpha(t[i])&&!m.count(t[i])) {\n      int x=m.size();\n      m[t[i]]=x;\n    }\n  }\n  if(m.size()>r.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<string> se;\n  do {\n    string e=t;\n    for(int i=0; i<e.size(); i++) {\n      if(isalpha(e[i])) e[i]=r[m[e[i]]];\n    }\n    int c=0;\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') c++;\n    }\n    if(c!=1) continue;\n    c=0;\n    s[0]=s[1]=\"\";\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') {\n        c++;\n        continue;\n      }\n      s[c]+=e[i];\n    }\n    if(!s[0].size()||!s[1].size()) continue;\n    int x[2]={0,0};\n    for(k=0; k<2; k++) {\n      f[k]=1;\n      p=s[k].begin();\n      int d=0,z=0;\n      for(int i=0; i<s[k].size(); i++) {\n        if(isdigit(s[k][i])) z++;\n        if(s[k][i]=='(') {\n          d++;\n          if(i&&(isdigit(s[k][i-1])||s[k][i-1]==')')) f[k]=0;\n          if(i!=s[k].size()-1&&(!isdigit(s[k][i+1])&&s[k][i+1]!='('&&s[k][i+1]!='-')) f[k]=0;\n        }\n        if(s[k][i]==')') {\n          d--;\n          if(i&&(!isdigit(s[k][i-1])&&s[k][i-1]!=')')) f[k]=0;\n          if(i!=s[k].size()-1&&isdigit(s[k][i+1])) f[k]=0;\n        }\n        if(i) {\n          if(s[k][i]=='+'||s[k][i]=='*') {\n            if(s[k][i-1]=='+'||s[k][i-1]=='*'||s[k][i-1]=='-') f[k]=0;\n          }\n        } else if(s[k][i]=='+'||s[k][i]=='*') f[k]=0;\n        if(d<0) f[k]=0;\n      }\n      if(d||!z) f[k]=0;\n      if(f[k]) x[k]=exp();\n    }\n    if(f[0]&&f[1]&&x[0]==x[1]) {\n      se.insert(r.substr(0,m.size()));\n    }\n  } while(next_permutation(r.begin(),r.end()));\n  cout << se.size() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint Q(int&);\nint E(int&);\nint T(int&);\nint F(int&);\n\nstring S;\nint N;\n\nint err = 0;\nstring gs;\nint Q(int& p){\n  int l = E(p);\n  if(p >= N || gs[p] != '='){\n\terr = 1;\n\treturn 0;\n  }\n  ++p;\n  int r = E(p);\n  if(p != N){\n\terr = 1;\n\treturn 0;\n  }\n  return l == r;\n}\n\nint E(int& p){\n  int x = T(p);\n  while(p < N){\n\tif(gs[p] == '+'){\n\t  ++p;\n\t  x += T(p);\n\t}\n\telse if(gs[p] == '-'){\n\t  ++p;\n\t  x -= T(p);\n\t}\n\telse\n\t  break;\n  }\n  return x;\n}\n\nint T(int& p){\n  int x = F(p);\n  while(p < N){\n\tif(gs[p] == '*'){\n\t  ++p;\n\t  x *= F(p);\n\t}\n\telse\n\t  break;\n  }\n  return x;\n}\n\nint F(int& p){\n  if(p >= N){\n\terr = 1;\n\treturn 0;\n  }\n  int x = 0;\n  if(gs[p] == '-'){\n\t++p;\n\tx = -F(p);\n  }\n  else if(gs[p] == '('){\n\t++p;\n\tx = E(p);\n\tif(gs[p] != ')'){\n\t  err = 1;\n\t  return 0;\n\t}\n\t++p;\n  }\n  else if(gs[p] == '0'){\n\tx = 0;\n\t++p;\n  }\n  else if(gs[p] == '1'){\n\tx = 1;\n\t++p;\n\twhile(p<N){\n\t  if(gs[p] == '0')\n\t\tx *= 2;\n\t  else if(gs[p] == '1')\n\t\tx = x*2 + 1;\n\t  else\n\t\tbreak;\n\t  ++p;\n\t}\n  }\n  else{\n\terr = 1;\n\treturn 0;\n  }\n\n  return x;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n\n  map<char,int> s;\n  REP(i,N) s[S[i]]++;\n  if(SZ(s) > 8){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  char cs[9] = \"+-*=()01\";\n  sort(cs, cs+8);\n\n  set<string> ans;\n  do{\n\tstring tmp = S;\n\tint j = 0;\n\tREP(i,N){\n\t  char c = tmp[i];\n\t  if(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')){\n\t\tREP(k,N)\n\t\t  if(tmp[k] == c)\n\t\t\ttmp[k] = cs[j];\n\t\t++j;\n\t  }\n\t}\n\tint p = 0;\n\terr = 0;\n\tgs = tmp;\n\tint flag = Q(p);\n\tif(flag && !err)\n\t  ans.insert(gs);\n  }while(next_permutation(cs, cs+8));\n\n  cout << SZ(ans) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring t = \"01+-*()\";\n\nint A(string &, int &);\n\nint B(string &, int &);\n\nint C(string &, int &);\n\nint C(string &s, int &idx)\n{\n  int ret = 0;\n  if(isdigit(s[idx])) {\n    if(isdigit(s[idx + 1]) && s[idx] == '0') throw (0);\n    while(isdigit(s[idx])) ret = ret * 2 + s[idx++] - '0';\n  } else if(s[idx] == '(') {\n    ret = A(s, ++idx);\n    if(s[idx++] != ')') throw (0);\n  } else if(s[idx] == '-') ret = -C(s, ++idx);\n  else throw (0);\n  return (ret);\n}\n\nint B(string &s, int &idx)\n{\n  int ret = C(s, idx);\n  while(s[idx] == '*') ret *= C(s, ++idx);\n  return (ret);\n}\n\nint A(string &s, int &idx)\n{\n  int ret = B(s, idx);\n  while(s[idx] == '+' || s[idx] == '-') {\n    if(s[idx] == '+') ret += B(s, ++idx);\n    else ret -= B(s, ++idx);\n  }\n  return (ret);\n}\n\nint main()\n{\n  string S;\n  cin >> S;\n  int ret = 0;\n  for(int i = 1; i < S.size() - 1; i++) {\n    if(isalpha(S[i]) || S[i] == '=') {\n      string L = S.substr(0, i);\n      string R = S.substr(i + 1);\n\n      map< char, int > cd;\n      int ptr = 0;\n      for(char &c : L) if(isalpha(c) && !cd.count(c)) cd[c] = ptr++;\n      for(char &c : R) if(isalpha(c) && !cd.count(c)) cd[c] = ptr++;\n      vector< pair< string, string > > data;\n      do {\n        string x = L, y = R;\n        for(char &c : x) if(isalpha(c)) c = t[cd[c]];\n        for(char &c : y) if(isalpha(c)) c = t[cd[c]];\n        data.emplace_back(x + \"`\", y + \"`\");\n      } while(next_permutation(begin(t), end(t)));\n      sort(begin(data), end(data));\n      data.erase(unique(begin(data), end(data)), end(data));\n\n      for(auto &LR: data) {\n        try {\n          int idx;\n          int a = A(LR.first, idx = 0);\n          if(idx + 1 != LR.first.size()) continue;\n          int b = A(LR.second, idx = 0);\n          if(idx + 1 != LR.second.size()) continue;\n          ret += a == b;\n        } catch(int e) {}\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n      \n    return r;\n  }\n  \n  int res=0,min=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    while(s[p]=='-') min++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(min%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(min%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;\n      \n    }\n    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n\n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2) ans++;\n    \n  }while(next_permutation(idx,idx+8));\n\n  \n}\n\n\nint main(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define int long long\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nsigned main() {\n\tcin >> s;\n\t\n\tbool used[512] = {false};\n\tint toId[512];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint Q(int&);\nint E(int&);\nint T(int&);\nint F(int&);\n\nstring S;\nint N;\n\nint err = 0;\nstring gs;\nint Q(int& p){\n  int l = E(p);\n  if(err || p >= N || gs[p] != '='){\n\terr = 1;\n\treturn 0;\n  }\n  ++p;\n  int r = E(p);\n  if(err || p != N){\n\terr = 1;\n\treturn 0;\n  }\n  return l == r;\n}\n\nint E(int& p){\n  if(err) return 0;\n  \n  int x = T(p);\n  while(p < N && !err){\n\tif(gs[p] == '+'){\n\t  ++p;\n\t  x += T(p);\n\t}\n\telse if(gs[p] == '-'){\n\t  ++p;\n\t  x -= T(p);\n\t}\n\telse\n\t  break;\n  }\n  return x;\n}\n\nint T(int& p){\n  if(err) return 0;\n  \n  int x = F(p);\n  while(p < N && !err){\n\tif(gs[p] == '*'){\n\t  ++p;\n\t  x *= F(p);\n\t}\n\telse\n\t  break;\n  }\n  return x;\n}\n\nint F(int& p){\n  if(err || p >= N){\n\terr = 1;\n\treturn 0;\n  }\n  int x = 0;\n  if(gs[p] == '-'){\n\t++p;\n\tx = -F(p);\n  }\n  else if(gs[p] == '('){\n\t++p;\n\tx = E(p);\n\tif(gs[p] != ')'){\n\t  err = 1;\n\t  return 0;\n\t}\n\t++p;\n  }\n  else if(gs[p] == '0'){\n\tx = 0;\n\t++p;\n  }\n  else if(gs[p] == '1'){\n\tx = 1;\n\t++p;\n\twhile(p<N){\n\t  if(gs[p] == '0')\n\t\tx *= 2;\n\t  else if(gs[p] == '1')\n\t\tx = x*2 + 1;\n\t  else\n\t\tbreak;\n\t  ++p;\n\t}\n  }\n  else{\n\terr = 1;\n\treturn 0;\n  }\n\n  return x;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n\n  set<char> s;\n  REP(i,N) s.insert(S[i]);\n  if(SZ(s) > 8){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n\n  char cs[9] = \"+-*=()01\";\n  sort(cs, cs+8);\n\n  set<string> ans;\n  do{\n\tstring tmp = S;\n\tint j = 0;\n\tREP(i,N){\n\t  char c = tmp[i];\n\t  if(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')){\n\t\tREP(k,N)\n\t\t  if(tmp[k] == c)\n\t\t\ttmp[k] = cs[j];\n\t\t++j;\n\t  }\n\t}\n\tint p = 0;\n\terr = 0;\n\tgs = tmp;\n\tint flag = Q(p);\n\tif(flag && !err)\n\t  ans.insert(gs);\n  }while(next_permutation(cs, cs+8));\n\n  cout << SZ(ans) << endl;\n  //for(auto&&s:ans)cout<<s<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    \n    if((s[p]=='*'||s[p]=='+')) flag=1;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    \n    return r;\n  }\n  \n  int res=0,minu=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n    \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(minu%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;    if(s[p]=='*'||s[p]=='+') flag=1;\n      \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n    \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    \n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n    \n  }while(next_permutation(idx,idx+8));\n  \n}\n\n\nmain(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n  \nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n  \nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n  \nint bnf();\n  \nint bnf3(){\n    \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n    \n  if(s[p]=='('){\n      \n    p++;\n    if(p<s.size()&&(s[p]=='*'||s[p]=='+')) flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n      \n    int r=bnf();\n      \n    if(p>=s.size()||s[p]!=')') flag=1;\n      \n    p++;\n      \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n     \n    return r;\n  }\n    \n  int res=0,minu=0;\n  \n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n    \n  if(s[p]=='-'){\n      \n    while(s[p]=='-') minu++,p++;\n     \n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      p++;\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n      \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n    \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n    \n  if(s[p]=='(') flag=1;\n    \n  if(minu%2) res*=-1;\n    \n  return res;\n}\n  \nint bnf2(){\n  \n  int res=bnf3();\n  \n  while(p<s.size()){\n  \n    if(s[p]=='*'){\n        \n      p++;\n  \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n        \n      int r=bnf3();\n        \n      res*=r;\n        \n    }else break;\n      \n  }\n  \n  return res;\n}\n  \nint bnf(){\n  \n  int res=bnf2();\n  \n  while(p<s.size()){\n  \n    if(s[p]=='+'){\n  \n      p++;\n        \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n        \n      int r=bnf2();\n  \n      res+=r;\n        \n    }    \n    else if(s[p]=='-'){\n       \n      p++;\n  \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n        \n      int r=bnf2();\n  \n      res-=r;\n        \n    }else break;\n      \n  }\n  \n  return res;\n}\n  \nvoid check(){\n    \n  int cnt=0;\n    \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n  \n      if(cnt==0){\n    flag=1;\n    return ;\n      }\n      else cnt--;\n    }\n  }\n  \n  if(cnt) flag=1;\n}\n  \nset<string> me;\n  \nvoid solve(){\n    \n  set<char> S;\n    \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n  \n  set<char>::iterator ite=S.begin();\n  \n  vector<char> al;\n    \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n    \n  if(al.size()>8){\n    cout<<0<<endl;\n    exit(0);\n  }\n    \n  int idx[8];\n  \n  for(int i=0;i<8;i++) idx[i]=i;\n    \n  do{\n      \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n  \n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n      \n    if(me.count(s)) continue;\n    me.insert(s);\n      \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n      \n    string s1,s2;\n      \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n  \n    int f=0;\n  \n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n      \n    flag=0;\n    s=s1;\n    p=0;\n \n    int r1=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n      \n    s=s2;\n    p=0;\n     \n    int r2=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n  \n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n      \n  }while(next_permutation(idx,idx+8));\n    \n}\n  \n  \nmain(){\n  \n  cin>>s;\n  str=s;\n    \n  solve();\n  \n  cout<<ans<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = a; i < n; ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n// nPr の列挙\ntemplate <typename BidirectionalIterator>\ninline bool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\nbool Q(const string& s, int& i);\nint E(const string& s, int& i, bool& ng);\nint T(const string& s, int& i, bool& ng);\nint F(const string& s, int& i, bool& ng);\nint N(const string& s, int& i, bool& ng);\n\nbool Q(const string& s, int& i) {\n    bool ng = false;\n    int val = E(s, i, ng);\n    if (ng || s[i] != '=') return false;\n    ++i; // '='\n    ng = false;\n    int val2 = E(s, i, ng);\n    if (ng || i != s.size()) return false;\n    return (val == val2);\n}\n\nint E(const string& s, int& i, bool& ng) {\n    int val = T(s, i, ng);\n    while (s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        ++i;\n        int val2 = T(s, i, ng);\n        if (op == '+') val += val2;\n        else val -= val2;\n    }\n    return val;\n}\n\nint T(const string& s, int& i, bool& ng) {\n    int val = F(s, i, ng);\n    while (s[i] == '*') {\n        ++i;\n        int val2 = F(s, i, ng);\n        val *= val2;\n    }\n    return val;\n}\n\nint F(const string& s, int& i, bool& ng) {\n    if (isdigit(s[i])) return N(s, i, ng);\n    if (s[i] == '-') {\n        ++i;\n        return -F(s, i, ng);\n    }\n    if (s[i] != '(') return (ng = true);\n    ++i;\n    int val = E(s, i, ng);\n    if (s[i] != ')') return (ng = true);\n    ++i;\n    return val;\n}\n\nint N(const string& s, int& i, bool& ng) {\n    if (s[i] == '0') {\n        ++i;\n        return 0;\n    }\n    if (s[i] == '1') {\n        int val = 1;\n        ++i;\n        while (s[i] == '0' || s[i] == '1') {\n            val = val * 2 + (s[i] - '0');\n            ++i;\n        }\n        return val;\n    }\n    return (ng = true);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    string s;\n    cin >> s;\n    const int n = s.size();\n    vector<char> alphabets;\n    for (char c : s) if (isalpha(c)) alphabets.push_back(c);\n    sort(alphabets.begin(), alphabets.end());\n    alphabets.erase(unique(alphabets.begin(), alphabets.end()), alphabets.end());\n    const int alphabets_size = alphabets.size();\n    string symbols = \"()*+-01=\";  // ソート済み\n    int ans = 0;\n    do {\n        map<char, char> mp;\n        for (int i = 0; i < alphabets_size; ++i) {\n            mp[alphabets[i]] = symbols[i];\n        }\n        int equal_cnt = 0;\n        string t;\n        t.reserve(100);\n        t = s;\n        for (int i = 0; i < n; ++i) {\n            if (isalpha(s[i])) t[i] = mp[s[i]];\n            if (t[i] == '=') ++equal_cnt;\n        }\n        if (equal_cnt != 1) continue;\n        const int equal_pos = t.find('=');\n        int i = 0;\n        ans += Q(t, i);\n    } while (next_partial_permutation(symbols.begin(), symbols.begin() + alphabets_size, symbols.end()));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nint bnf();\nset<P> used;\nmap<char,int> M;\nstring S;\nint idx,valid;\nchar ch[7]={'0','1','+','-','*','(',')'};\nint ord[7];\n\nbool check(string a){//?????????????????°??¨??????????????????????¢????\n  int par=0;\n  for(char s:a){\n    par += (s == '(') - (s == ')');\n    if(s == '=') return 0;\n    if(par < 0) return 0;\n  }\n  return par==0;\n}\n\nint getNum(){ //??????????????°????????????\n  int res = 0;\n  if(S[idx] == '0' && isdigit(S[idx+1])) valid  = 0;\n  while(isdigit(S[idx]))res = res*2 + S[idx++]-'0';\n  return res;\n}\n\nint cal(){\n  char ch = S[idx];\n  int res = 0,sign = 1;\n  if(ch == '+'||ch=='*'||ch==')'){ valid = 0;return 0;}\n  \n  while(S[idx] == '-') idx++, sign *= -1;\n  ch = S[idx];\n\n  if(isdigit(ch)){\n    res = sign*getNum();\n    if(S[idx] == '*'){idx++; return res * cal();}\n    return res;\n  }\n  else if(ch == '(') {\n    idx++;res = sign*bnf();idx++;\n    return res;\n  }\n  valid = 0;\n  return 0;\n}\n\nint bnf(){\n  int res = cal();\n  while(idx<(int)S.size()){\n    if(valid == 0) return -1;\n    char ch = S[idx];\n    if(ch == '('){valid = 0;}\n    else if(ch == '*'){idx++;res *= cal();}\n    else if(ch == '+'){idx++;res += cal();}\n    else if(ch == '-'){idx++;res -= cal();}\n    else if(ch != ')') valid = 0;\n    else break;\n  }\n  if(valid ==0) return -1;\n  return res;\n}\n\nstring mkS(string a){\n  string res;\n  for(char s:a){\n    if(isalpha(s))res += ch[ ord[ M[s] ] ];\n    else res += s;\n  }\n  return res;\n}\n\n\nint calc(string &a,string &b){\n  string A = mkS(a);\n  string B = mkS(b);\n  if(used.count(P(A,B)))return 0;\n  used.insert(P(A,B));\n  \n  valid = check(A) && check(B);\n  idx = 0;\n  S = A;\n  int ra = bnf();\n  idx=0;\n  S = B;\n  int rb = bnf();\n  //if(valid)cout<<A<<\"=\"<<B<<\" \"<<valid<<\" \"<<ra<<\" \"<<rb<<endl;\n  return ra == rb && valid;\n}\n\n\nint dfs(int num,string &a,string &b){\n  if(num == 7) return calc(a,b);\n  \n  int res = 0;\n  for(int i=0;i<7;i++){\n    if(ord[i] != -1)continue;\n    ord[i] = num;\n    res +=dfs(num+1,a,b);\n    ord[i] = -1;\n  }\n  return res;\n}\n\n\nint main(){\n  string str;\n  cin>>str;\n  if(str.size()<3)cout<<0<<endl,exit(0);\n\n  map<char,int> cnt;\n  for(int i=0;i<(int)str.size();i++)cnt[str[i]]++;\n  if(cnt.size()>8)cout<<0<<endl,exit(0);\n\n  int c = 0;\n  for(pair<char,int> p:cnt)if(isalpha(p.first)) M[p.first] = c++;\n  \n  memset(ord,-1,sizeof(ord));  \n  int ans = 0;\n  for(int i=1;i<(int)str.size()-1;i++){\n    if(str[i]=='='||(isalpha(str[i])&&cnt[str[i]] == 1)){\n      string a = str.substr(0,i);\n      string b = str.substr(i+1,str.size()-i-1);\n\n      ans+=dfs(0,a,b);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n    \n    return r;\n  }\n  \n  int res=0,min=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    while(s[p]=='-') min++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(min%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(min%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;\n      \n    }\n    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n\n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2) ans++;\n    \n  }while(next_permutation(idx,idx+8));\n\n  \n}\n\n\nmain(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar moji[] = \"01+-*()=\";\nstring s;\nchar cset[100];\nint idx[100];\nint length;\nvector<int> perm;\nint pos;\nbool correct;\nstring currents;\nchar get(int i){\n\tif(i >= length){\n\t\treturn '\\0';\n\t}\n\treturn currents[i];\n}\n\nbool Q();\nint E();\nint T();\nint F();\nint N();\nint B(int cur);\n\n\nbool Q(){\n\tint a = E();\n\tif(get(pos) != '='){\n\t\tcorrect  = false;\n\t\treturn false;\n\t}\n\tpos++;\n\tint b = E();\n\treturn a == b;\n}\n\nint E(){\n\tint t = T();\n\twhile(get(pos) == '+' || get(pos) == '-'){\n\t\tif(get(pos) == '+'){\n\t\t\tpos++;\n\t\t\tt += T();\n\t\t}else{\n\t\t\tpos++;\n\t\t\tt -= T();\n\t\t}\n\t}\n\treturn t;\n}\n\nint T(){\n\tint f = F();\n\twhile(get(pos) == '*'){\n\t\tpos++;\n\t\tf *= F();\n\t}\n\treturn f;\n}\n\nint F(){\n\tif(get(pos) == '-'){\n\t\tpos++;\n\t\treturn - F();\n\t}\n\tif(get(pos) == '('){\n\t\tpos++;\n\t\tint e = E();\n\t\tif(get(pos) != ')'){\n\t\t\tcorrect = false;\n\t\t}\n\t\tpos++;\n\t\treturn e;\n\t}\n\n\treturn N();\n}\n\nint N(){\n\tif(get(pos) == '0'){\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif(get(pos) == '1'){\n\t\tpos++;\n\t\treturn B(1);\n\t}\n\tcorrect = false;\n\treturn 0;\n}\n\nint B(int cur){\n\tif(get(pos) == '0'){\n\t\tpos++;\n\t\treturn B(cur * 2);\n\t}\n\tif(get(pos) == '1'){\n\t\tpos++;\n\t\treturn B(cur * 2 + 1);\n\t}\n\treturn cur;\n}\n\n\nint main(){\n\tcin >> s;\n\tlength = s.size();\n\tint si = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(!(('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z'))){\n\t\t\tidx[i] = s[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint j;\n\t\tfor(j = 0; j < si; j++){\n\t\t\tif(cset[j] == s[i]) break;\n\t\t}\n\t\tif(j == si){\n\t\t\tsi++;\n\t\t\tif(si > 8){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcset[j] = s[i];\n\t\t}\n\t\tidx[i] = j;\n\t}\n\t\n\tfor(int i = 0 ; i < 8; i++){\n\t\tperm.push_back(i);\t\n\t}\n\n\tset<string> smap;\n/*\n\tdo{\n\t\tstring ns = s;\n\t\tfor(int i = 0; i < ns.size(); i++){\n\t\t\tif(('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z')){\n\t\t\t\tns[i] = moji[perm[idx[i]]];\n\t\t\t}\n\t\t}\n\t\tsmap.insert(ns);\n\t}while(next_permutation(perm.begin(), perm.end()));\n*/\n\tint ans = 0;\n\tfor(string ss : smap){\n\t\tcurrents = ss;\n\t\tpos = 0;\n\t\tcorrect = true;\n\t\tif(Q() && correct && pos == ss.size()){\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 100) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren++;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// +?????§??????\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '+') {\n\t\t\tif (i == 0 || !(m[str[i]] == '0' || m[str[i]] == '1'))return false;\n\t\t}\n\t}\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\t//cout << tmp << endl;\n\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\t//cout << lhs << \" \" << rhs << endl;\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\t/*\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tstring d = \"1*-1\";\n\tcout << \"xo\"[isE(d, m, d.begin(), d.end())] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1-11010=(10110)-10\", m)] << endl;\n\tcout << \"xo\"[isQ(\"--1001=1001\", m)] << endl;\n\tcout << \"xo\"[check(\"--1001=1001\", m)] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m)) {\n\t\t\t/*\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t\t//*/\n\t\t\tif (check(str, m)) {\n\t\t\t\t//cout << \"=======================\" << endl;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  if(s[p]==')') flag=1;\n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n\n    return r;\n  }\n  \n  int res=0,min=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    while(s[p]=='-') min++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(min%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(min%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      int r=bnf3();\n\n      res*=r;\n      \n    }else{\n      break;\n    }\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      int r=bnf2();\n\n      res+=r;\n      \n    }\n    \n    else if(s[p]=='-'){\n\n      p++;\n      int r=bnf2();\n\n      res-=r;\n      \n    }else{\n\n      break;\n      \n    }\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n\n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n\n    if(p<s.size()) flag=1;\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n    \n    if(p<s.size()) flag=1;\n    \n    if(!flag&&s1.size()&&s2.size()&&r1==r2) ans++;\n    \n  }while(next_permutation(idx,idx+8));\n\n  \n}\n\n\nint main(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint len,p;\nstring S;\nbool flag;\n\nint compute();\n\nint getNum(){\n  if(p>=len){\n    flag=true;\n    return 0;\n  }\n  \n  if(S[p]=='-'){\n    p++;\n    return -getNum();\n  }else if(S[p]=='0'){\n    p++;\n    return 0;\n  }else if(S[p]=='1'){\n    int res=0;\n    while(p<len && (S[p]=='0'||S[p]=='1') ){\n      res*=2;\n      res+=(S[p]-'0');\n      p++;\n    }\n    return res;\n  }else if(S[p]=='('){\n    p++;\n    int res=compute();\n    if(S[p-1]!=')')flag=true;\n    return res;\n  }else{\n    flag=true;\n    return 0;\n  }\n}\n\nint compute(){\n  if(p>=len){\n    flag=true;\n    return 0;\n  }\n  \n  stack<int> st;\n  while(p<len){\n    char ch=S[p];p++;\n    if(ch==')')break;\n\n    int num=getNum();\n    if(ch=='+'){\n      st.push(num);\n    }else if(ch=='-'){\n      st.push(-num);\n    }else if(ch=='*'){\n      int x=st.top();\n      st.pop();\n      st.push(x*num);\n    }else{\n      flag=true;\n      break;\n    }\n  }\n  int res=0;\n  while(st.size()>0){\n    res+=st.top();\n    st.pop();\n  }\n  return res;\n}\n\nint check(string str){\n  int cnt=0,index;\n  for(int i=0;i<(int)str.size();i++)\n    if(str[i]=='=')cnt++, index=i;\n  \n  if(cnt!=1)return 0;\n  if(index==0 || index+1==(int)str.size())return 0;\n  \n  flag=false;\n  S=str.substr(0,index);\n  p=0;\n  len=S.size();\n  int lv=compute();\n  if(flag || p<len)return 0;\n\n  \n  flag=false;\n  S=str.substr(index+1);\n  p=0;\n  int rv=compute();\n  if(flag || p<len)return 0;\n\n  if(lv==rv)return 1;\n  else return 0;\n}\n\n\nint solve(string str){\n  len=str.size();\n  string tmp=\"01+-*()=\";\n  sort(tmp.begin(),tmp.end());\n  \n  map<string,bool> used;\n  int res=0;\n  do{\n    map<char,char> mp;\n    string s=str;\n    for(int i=0;i<len;i++){\n      if(s[i]<'A')continue;\n      if(s[i]>'Z')continue;\n      if(mp.count( s[i] )>0) s[i]=mp[ s[i] ];\n      else{\n        int id=mp.size();\n        mp[ s[i] ]=tmp[id];\n        s[i]=tmp[id];\n      }\n      if(!used[s]){\n        used[s]=true;\n        res+=check(s);\n      }\n    }\n  }while(next_permutation(tmp.begin(),tmp.end()));\n    return res;\n}\n\nint main(){\n  string str;\n  cin>>str;\n  cout<<solve(str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nint bnf();\nset<P> used;\nmap<char,int> M;\nstring S;\nint idx,valid;\nchar ch[8]={'0','1','+','-','*','(',')','='};\nint ord[8];\n\nbool check(string a){//?????????????????°??¨??????????????????????¢????\n  int par=0;\n  for(char s:a){\n    par += (s == '(') - (s == ')');\n    if(s == '=') return 0;\n    if(par < 0) return 0;\n  }\n  return par==0;\n}\n\nint getNum(){ //??????????????°????????????\n  int res = 0;\n  if(S[idx] == '0' && isdigit(S[idx+1])) valid  = 0;\n  while(isdigit(S[idx]))res = res*2 + S[idx++]-'0';\n  return res;\n}\n\nint cal(){\n  char ch = S[idx];\n  int res = 0,sign = 1;\n  if(ch=='+'||ch=='*'||ch==')'){ valid = 0;return 0;}\n\n  while(S[idx] == '-') idx++, sign *= -1;\n  ch = S[idx];\n\n  if(isdigit(ch)){\n    res = sign*getNum();\n    if(S[idx] == '*'){idx++; return res * cal();}\n    return res;\n  }\n  else if(ch == '(') {\n    idx++;res = sign*bnf();idx++;\n    return res;\n  }\n\n  valid = 0;\n  return 0;\n}\n\nint bnf(){\n  int res = cal();\n  while(idx<(int)S.size()){\n    if(valid == 0) return -1;\n    char ch = S[idx];\n    if(ch == '('){valid = 0;}\n    else if(ch == '*'){idx++;res *= cal();}\n    else if(ch == '+'){idx++;res += cal();}\n    else if(ch == '-'){idx++;res -= cal();}\n    else if(ch != ')') valid = 0;\n    else break;\n  }\n  if(valid ==0) return -1;\n  return res;\n}\n\nstring mkS(string a){\n  string res;\n  for(char s:a){\n    if(isalpha(s))res += ch[ ord[ M[s] ] ];\n    else res += s;\n  }\n  return res;\n}\n\nint calc(string A,string B){\n  if(A.size()==0 || B.size()==0) return 0;\n  if(used.count(P(A,B)))return 0;\n  used.insert(P(A,B));\n  valid = check(A) && check(B);\n  idx = 0;\n  S = A;\n  int ra = bnf();\n  idx = 0;\n  S = B;\n  int rb = bnf();\n  //if(valid)cout<<A<<\"=\"<<B<<\" \"<<valid<<\" \"<<ra<<\" \"<<rb<<endl;\n  return ra == rb && valid;\n}\n\nint calc(string s){\n  s = mkS(s);\n  for(int i=0;i<(int)s.size();i++)\n    if(s[i]=='=') return calc(s.substr(0,i),s.substr(i+1,s.size()-i-1));\n  return 0;\n}\n\nint dfs(int num,string &s){\n  if(num == 8) return calc(s);\n  \n  int res = 0;\n  for(int i=0;i<8;i++){\n    if(ord[i] != -1)continue;\n    ord[i] = num;\n    res +=dfs(num+1,s);\n    ord[i] = -1;\n  }\n  return res;\n}\n\n\nint main(){\n  string str;\n  cin>>str;\n  if(str.size()<3)cout<<0<<endl,exit(0);\n\n  map<char,int> cnt;\n  for(int i=0;i<(int)str.size();i++)if(isalpha(str[i]))cnt[str[i]]++;\n  if(cnt.size()>8)cout<<0<<endl,exit(0);\n\n  int c = 0;\n  for(pair<char,int> p:cnt)if(isalpha(p.first)) M[p.first] = c++;\n  \n  memset(ord,-1,sizeof(ord));  \n  cout<<dfs(0,str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans + 114514 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nbool flag;\n\nint B(string &s, int &n){\n\tint ret = 0;\n\twhile(1){\n\t\tif( !isdigit(s[n]) ){ break; }\n\t\telse if( s[n] == '0' ){ n++; ret<<=1; }\n\t\telse if( s[n] == '1' ){ n++; ret<<=1; ret += 1; }\n\t}\n\t//cout << \"B \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint N(string &s, int &n){\n\tif( !isdigit(s[n]) ){ flag = false; }\n\telse if( s[n] == '0' ){ n++; return 0; }\n\telse if( s[n] == '1' ){ return B(s, n); }\n\t//cout << \"flag N\" << endl;\n\treturn 0;\n}\n\nint E(string &s, int &n, int ret=0, int d=1);\nint F(string &s, int &n){\n\tint ret;\n\tif( isdigit(s[n]) ){ ret = N(s, n); }\n\telse if( s[n] == '-' ){ n++; ret = -F(s, n); }\n\telse if( s[n] == '(' ){\n\t\tn++;\n\t\tret = E(s, n);\n\t\tif( s[n] == ')' ) n++;\n\t\telse flag = false;\n\t} else {\n\t\t//cout << \"flag F\" << endl;\n\t\tflag = false;\n\t}\n\t//cout << \"F \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint T(string &s, int &n){\n\tint ret = F(s,n);\n\tif( s[n] == '*' ){ n++; ret *= T(s, n); }\n\t//cout << \"T \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint E(string &s, int &n, int ret, int d){\n\tret += T(s,n) * d;\n\tif( s.size() <= n ){}\n\telse if( s[n] == '+' ){ n++; ret = E(s, n, ret,  1); }\n\telse if( s[n] == '-' ){ n++; ret = E(s, n, ret, -1); }\n\t//cout << \"E \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nbool Q(string &s){\n\tflag = true;\n\tint n=0;\n\tint l = E(s,n);\n\t//cout << \"l = \" << l << endl;\n\tif( s[n] == '=' ) n++;\n\telse return false;\n\tint r = E(s,n);\n\t//cout << \"r = \" << r << endl;\n\tif( s[n] != '$' ) flag = false;\n\treturn flag && l == r;\n}\n\nstring ope = \"01+-*()=\";\nint main(){\n\tset<string> ans;\n\tstring S;\n\tcin >> S;\n\t\n\tvector<char> v;\n\tfor(char c: S){\n\t\tif( 'A' <= c && c <= 'Z' ) v.push_back(c);\n\t\tif( 'a' <= c && c <= 'z' ) v.push_back(c);\n\t}\n\tsort(all(v));\n\tv.erase( unique(all(v)), v.end() );\n\tif( v.size() > 8 ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tsort( all(ope) );\n\tdo{\n\t\tchar mp[127]={};\n\t\trep(i,v.size()) mp[v[i]] = ope[i];\n\t\tstring s;\n\t\tfor(char c: S) s += (mp[c] ? mp[c] : c);\n\t\ts += '$';\n\t\t//cout << s << endl;\n\t\tif( Q(s) ) ans.insert(s);\n\t}while( next_permutation(all(ope)) );\n\n\t//for(auto p: ans) cout << p << endl;\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint idx, len;\n\nint number();\nint factor();\nint term();\nint expression();\n\nint number(){\n    char c = f[idx++];\n    if(c != '0' and c != '1') throw 1;\n\n    if(c == '0') return 0;\n\n    int ret = 1;\n    while(idx < len and (f[idx] == '0' or f[idx] == '1')){\n        ret *= 2;\n        char c = f[idx++];\n        if(c == '1') ret += 1;\n    }\n    return ret;\n}\n\nint factor(){\n    int mcnt = 0;\n    while(idx < len and f[idx] == '-'){\n        mcnt++;\n        idx++;\n    }\n    if(idx >= len) throw 1;\n\n    int sign = (mcnt % 2 == 0 ? +1:-1);\n    if(f[idx] != '(') return sign * number();\n    idx++;\n\n    int ret = sign * expression();\n    if(idx >= len or f[idx] != ')') throw 1;\n    idx++;\n\n    return ret;\n}\n\nint term(){\n    int ret = factor();\n    while(idx < len and f[idx] == '*'){\n        idx++;\n        int rhs = factor();\n        ret *= rhs;\n    }\n    return ret;\n}\n\nint expression(){\n    int ret = term();\n    while(idx < len and (f[idx] == '+' or f[idx] == '-')){\n        char op = f[idx++];\n        int rhs = term();\n        switch(op){\n            case '+': { ret += rhs; break; }\n            case '-': { ret -= rhs; break; }\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    /*\n    while(cin >> f){\n        len = f.size(), idx = 0;\n        int ret = expression();\n        cerr << ret << \", idx = \" << idx << \", len = \" << len << endl;\n    }\n    return 0;\n    //*/\n\n    string in; cin >> in;\n    string T = \"01+-*()=\"; sort(_all(T));\n\n    set<string> s;\n    do {\n        map<char, bool> used;\n        map<char, char> c2t;\n        int j = 0;\n        f = in;\n        rep(i, in.size()){\n            char c = in[i];\n            if(not isupper(c) and not islower(c)) continue;\n\n            if(not used[c]){\n                used[c] = true;\n                if(j >= T.size()){\n                    cout << 0 << endl;\n                    return 0;\n                }\n                c2t[c] = T[j++];\n            }\n            f[i] = c2t[c];\n        }\n\n        string equation = f;\n        string l, r;\n        rep(i, in.size()){\n            if(f[i] == '='){\n                l = f.substr(0, i);\n                r = f.substr(i + 1);\n                break;\n            }\n        }\n        if(l == \"\" or r == \"\") continue;\n\n        try {\n            idx = 0; f = l; len = f.size();\n            int lv = expression();\n            if(idx != len) continue;\n\n            idx = 0; f = r; len = f.size();\n            int rv = expression();\n            if(idx != len) continue;\n\n            if(lv != rv) continue;\n        }\n        catch(int e){\n            continue;\n        }\n        s.insert(equation);\n    } while(next_permutation(_all(T)));\n\n    // for(auto& e : s){\n    //     cerr << e << endl;\n    // }\n    cout << s.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nstring::iterator p;\nint fact();\nint term();\nint exp();\nint k;\nbool f[2];\n\nint fact() {\n  int x;string num;\n  int mi=1;\n  if(*p=='-') {\n    mi=-1;\n    ++p;\n  }\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()>1&&num[0]=='0') f[k]=0;\n  if(num.size()) {\n    x=0;\n    for(int i=num.size()-1,j=0; i>=0; i--,j++) x+=(1<<j)*(num[i]=='1');\n  } else if(p!=s[k].end()){\n    if(*p!='('&&*p!='-') f[k]=0;\n    bool ff=(*p=='(');\n    if(p!=s[k].end()&&*p=='(')++p;\n    x=exp();\n    if(ff&&*p!=')') f[k]=0;\n    if(p!=s[k].end()&&*p==')')++p;\n  } else f[k]=0;\n  return x*mi;\n}\n \nint term() {\n  int x=fact();\n  while(*p=='*') {\n    ++p;\n    x*=fact();\n  }\n  return x;\n}\n \nint exp() {\n  int x=term();\n  while(*p=='+'||*p=='-') {\n    if(*p=='+') {\n      ++p;\n      x+=term();\n    } else {\n      ++p;\n      x-=term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  string r=\"01+-*()=\";\n  sort(r.begin(),r.end());\n  string t;\n  cin >> t;\n  map<char,int> m;\n  for(int i=0; i<t.size(); i++) {\n    if(isalpha(t[i])&&!m.count(t[i])) {\n      int x=m.size();\n      m[t[i]]=x;\n    }\n  }\n  if(m.size()>r.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<string> se;\n  do {\n    string e=t;\n    for(int i=0; i<e.size(); i++) {\n      if(isalpha(e[i])) e[i]=r[m[e[i]]];\n    }\n    int c=0;\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') c++;\n    }\n    if(c!=1) continue;\n    c=0;\n    s[0]=s[1]=\"\";\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') {\n        c++;\n        continue;\n      }\n      s[c]+=e[i];\n    }\n    if(!s[0].size()||!s[1].size()) continue;\n    int x[2]={0,0};\n    for(k=0; k<2; k++) {\n      f[k]=1;\n      p=s[k].begin();\n      int d=0;\n      for(int i=0; i<s[k].size(); i++) {\n        if(s[k][i]=='(') {\n          d++;\n          if(i&&(isdigit(s[k][i-1])||s[k][i-1]==')')) f[k]=0;\n          if(i!=s[k].size()-1&&(!isdigit(s[k][i+1])&&s[k][i+1]!='('&&s[k][i+1]!='-')) f[k]=0;\n        }\n        if(s[k][i]==')') {\n          d--;\n          if(i&&(!isdigit(s[k][i-1])&&s[k][i-1]!=')')) f[k]=0;\n          if(i!=s[k].size()-1&&isdigit(s[k][i+1])) f[k]=0;\n        }\n        if(i) {\n          if(s[k][i]=='+'||s[k][i]=='*') {\n            if(s[k][i-1]=='+'||s[k][i-1]=='*'||s[k][i-1]=='-') f[k]=0;\n          }\n        } else if(s[k][i]=='+'||s[k][i]=='*') f[k]=0;\n        if(d<0) f[k]=0;\n      }\n      if(d) f[k]=0;\n      if(f[k]) x[k]=exp();\n    }\n    //cout << s[0] << \" \" << s[1] << \" \" << x[0] << \" \" << x[1] << endl;\n    if(f[0]&&f[1]&&x[0]==x[1]) {\n      //if(!se.count(r.substr(0,m.size()))) cerr << s[0] << \" \" << s[1] << \" \" << f[0] << \" \" << f[1] << endl;\n      se.insert(r.substr(0,m.size()));\n    }\n  } while(next_permutation(r.begin(),r.end()));\n  cout << se.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0LL);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    if(S[idx] != ')') throw (0LL);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0LL);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= C(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += B(S, ++idx);\n    else ret -= B(S, ++idx);\n  }\n  return (ret);\n}\n\nsigned main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconstexpr int SIZE=8;\nstring symbol=\"01+-*()=\";\n\nusing Flag=bitset<SIZE>;\nusing Er=runtime_error;\n\nusing ll=long long;\nll E(int &p,string &exp);\nll N(int &p,string &exp){\n    char dig=exp[p++];\n    if(dig=='0') return 0;\n    ll res=1;\n    while(p<exp.size() && isdigit(exp[p])){\n        res*=2;\n        res+=(exp[p++]-'0');\n    }\n    return res;\n}\nll F(int &p,string &exp){\n    if(p>=exp.size()) throw Er(\"F_iter\");\n    if(isdigit(exp[p])){\n        return N(p,exp);\n    }\n    if(exp[p]=='-'){\n        p++;\n        return -(F(p,exp));\n    }\n    if(exp[p]=='('){\n        p++;\n        ll res=E(p,exp);\n        if(p>=exp.size() || exp[p]!=')') throw Er(\"F_par\");\n        p++;\n        return res;\n    }\n    throw Er(\"F_no \"+to_string(p));    \n\n}\nll T(int &p,string &exp){\n    ll res=F(p,exp);\n    while(p<exp.size() && exp[p]!='=' && exp[p]!='+' && exp[p]!='-' && exp[p]!=')'){\n        char op=exp[p++];\n        if(op!='*') throw Er(\"T \"+to_string(p));\n        ll rhs=F(p,exp);\n        res*=rhs;\n    }\n    return res;\n}\nll E(int &p,string &exp){\n    ll res=T(p,exp);\n    while(p<exp.size() && exp[p]!='=' && exp[p]!=')'){\n        char op=exp[p++];\n        if(op!='+' && op!='-') throw Er(\"E\");\n        ll rhs=T(p,exp);\n        if(op=='+') res+=rhs;\n        else res-=rhs;\n    }\n    return res;\n}\nbool Q(int &p,string& exp){\n    try{\n        ll lhs=E(p,exp);\n        if(p>=exp.size() || exp[p]!='=') return false;\n        p++;\n        ll rhs=E(p,exp);\n        if(p!=exp.size()) return false;\n        else{\n            return lhs==rhs;\n        }\n    }\n    catch(std::runtime_error re){\n        // cerr<<re.what()<<endl;\n        return false;\n    }\n}\nint judge(string exp){\n    int p=0;\n    return Q(p,exp);\n}\nint dfs(int p,string str,map<char,char> mp,Flag used){\n    if(p==str.size()){\n        return judge(str);\n    }\n    if(find(symbol.begin(),symbol.end(),str[p])!=symbol.end()){\n        return dfs(p+1,str,mp,used);\n    }\n    if(mp.count(str[p])){\n        str[p]=mp[str[p]];\n        return dfs(p+1,str,mp,used);\n    }    \n    int res=0;\n    char org=str[p];\n    for(int i=0;i<SIZE;i++){\n        if(!used[i]){\n            used[i]=true;\n            mp[str[p]]=symbol[i];\n            str[p]=symbol[i];\n            res+=dfs(p+1,str,mp,used);\n            str[p]=org;\n            mp.erase(org);\n            used[i]=false;\n        }\n    }\n    return res;\n}\nint solve(string str){\n    map<char,char> mp;\n    return dfs(0,str,mp,Flag());\n}\nint main(){\n    string str;\n    cin>>str;\n    cout<<solve(str)<<endl;    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX\n\nstring s,t;\nint n;\nvector<char> cs,match;\nstring cand=\"01+-*()=\";\nbool used[10];\nint res=0;\n\nint calc_e(int& l,int term);\n\nint calc_f(int& l,int term){\n  if(l>=term)return -INF;\n\n  if(isdigit(t[l])){\n    int v=0;\n    if(t[l]=='0'&&l+1<term&&isdigit(t[l+1]))return -INF;\n    while(l<term&&isdigit(t[l])){\n      v<<=1;\n      v+=t[l]-'0';\n      l++;\n    }\n    return v;\n  }else if(t[l]=='-'){\n    l++;\n    int v=calc_f(l,term);\n    if(v==-INF)return -INF;\n    return -v;\n  }else if(t[l]=='('){\n    l++;\n    int v=calc_e(l,term);\n    if(v==-INF||t[l]!=')')return -INF;\n    l++;\n    return v;\n  }else{\n    return -INF;\n  }\n}\n\nint calc_t(int& l,int term){\n  if(l>=term)return -INF;\n  int v=calc_f(l,term);\n  if(v==-INF||l>term)return -INF;\n  while(l<term&&t[l]=='*'){\n    l++;\n    int nv=calc_f(l,term);\n    if(nv==-INF)return -INF;\n    v*=nv;\n  }\n  return v;\n}\n\nint calc_e(int& l,int term){\n  if(l>=term)return -INF;\n  int v=calc_t(l,term);\n  if(v==-INF||l>term)return -INF;\n  while(l<term&&(t[l]=='+'||t[l]=='-')){\n    if(t[l]=='+'){\n      l++;\n      int nv=calc_t(l,term);\n      if(nv==-INF)return -INF;\n      v+=nv;\n    }else if(t[l]=='-'){\n      l++;\n      int nv=calc_t(l,term);\n      if(nv==-INF)return -INF;\n      v-=nv;\n    }\n  }\n  return v;\n}\n\nvoid dfs(int i){\n  if(i==cs.size()){\n    t=\"\";\n    rep(j,s.size()){\n      if(exist(cand,s[j])){\n        t+=s[j];\n        continue;\n      }\n      rep(k,cs.size()){\n        if(s[j]==cs[k]){\n          t+=match[k];\n          break;\n        }\n      }\n    }\n    int cnt=0;\n    rep(j,t.size()){\n      if(t[j]=='=')cnt++;\n    }\n    if(cnt!=1)return ;\n    rep(j,t.size()){\n      if(t[j]=='='){\n        int l=0,r=j+1;\n        int cntc=0;\n        bool ok=true;\n        repl(k,l,j){\n          if(t[k]=='(')cntc++;\n          if(t[k]==')')cntc--;\n          if(cntc<0)ok=false;\n        }\n        if(cntc!=0)ok=false;\n        cntc=0;\n        repl(k,r,n){\n          if(t[k]=='(')cntc++;\n          if(t[k]==')')cntc--;\n          if(cntc<0)ok=false;\n        }\n        if(cntc!=0)ok=false;\n        if(!ok)break;\n        int vl=calc_e(l,j); int vr=calc_e(r,n);\n        if(vl!=-INF&&vr!=-INF&&vl==vr){\n          res++;\n        }\n        break;\n      }\n    }\n    return ;\n  }\n  rep(j,cand.size()){\n    if(used[j])continue;\n    used[j]=true;\n    match.push_back(cand[j]);\n    dfs(i+1);\n    match.pop_back();\n    used[j]=false;\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  rep(i,n){\n    if(exist(cand,s[i]))continue;\n    cs.push_back(s[i]);\n  }\n  sort(all(cs));\n  uni(cs);\n  if(cs.size()>8){\n    cout<<0<<endl;\n    return 0;\n  }\n  dfs(0);\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 0) cassert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\npair<string, string> split(const string &s) {\n  int p = s.find('=');\n  string l = s.substr(0, p);\n  string r = s.substr(p + 1);\n  return make_pair(l, r);\n}\nbool check(const string &s) {\n  int p = s.find('=');\n  if(p == -1) return false;\n  pair<string, string> sp = split(s);\n  if(sp.first.size() == 0 || sp.second.size() == 0) return false;\n  int k = 0;\n  for(char c : sp.first) {\n    if(c == '(') ++k;\n    if(c == ')') --k;\n    if(k < 0) return false;\n  }\n  if(k != 0) return false;\n  for(char c : sp.second) {\n    if(c == '(') ++k;\n    if(c == ')') --k;\n    if(k < 0) return false;\n  }\n  return true;\n}\ntypedef string::const_iterator iter;\nstruct Result {\n  bool valid;\n  int value;\n  Result(bool valid_, int value_) : valid(valid_), value(value_) {}\n};\nResult fail(false, 114514);\nbool Q(iter &p);\nResult E(iter &p);\nResult T(iter &p);\nResult F(iter &p);\nResult N(iter &p);\nResult B(iter &p);\nbool Q(iter &p) {\n  Result l = E(p);\n  // if(!l.valid) {\n  //   cerr << \"l = No\" << endl;\n  // }\n  // else {\n  //   cerr << \"l = \" << l.value << endl;\n  // }\n  if(!l.valid) return false;\n  if(*p != '=') return false;\n  ++p;\n  Result r = E(p);\n  // if(!l.valid) {\n  //   cerr << \"r = No\" << endl;\n  // }\n  // else {\n  //   cerr << \"r = \" << r.value << endl;\n  // }\n  if(!r.valid) return false;\n  if(*p != '\\0') return false;\n  return l.value == r.value;\n}\nResult E(iter &p) {\n  Result t = T(p);\n  if(!t.valid) return fail;\n  while(true) {\n    if(*p == '+') {\n      ++p;\n      Result s = T(p);\n      if(!s.valid) return fail;\n      t.value += s.value;\n    }\n    else if(*p == '-') {\n      ++p;\n      Result s = T(p);\n      if(!s.valid) return fail;\n      t.value -= s.value;\n    }\n    else {\n      break;\n    }\n  }\n  return t;\n}\nResult T(iter &p) {\n  Result t = F(p);\n  if(!t.valid) return fail;\n  while(true) {\n    if(*p == '*') {\n      ++p;\n      Result s = F(p);\n      if(!s.valid) return fail;\n      t.value *= s.value;\n    }\n    else {\n      break;\n    }\n  }\n  return t;\n}\nResult F(iter &p) {\n  if(*p == '(') {\n    ++p;\n    Result e = E(p);\n    if(*p != ')') {\n      return fail;\n    }\n    ++p;\n    return e;\n  }\n  else if(*p == '-') {\n    ++p;\n    Result e = F(p);\n    if(!e.valid) return fail;\n    e.value *= -1;\n    return e;\n  }\n  return N(p);\n}\nResult N(iter &p) {\n  if(!isdigit(*p)) {\n    return fail;\n  }\n  int n = 0;\n  int i = 0;\n  while(isdigit(*p)) {\n    n *= 2;\n    if(i > 0 && n == 0) return fail;\n    n += *p - '0';\n    ++p;\n    ++i;\n  }\n  // DEBUG(n);\n  return Result(true, n);\n}\nvoid dbg() {\n  string S; cin >> S;\n  iter p = S.cbegin();\n  bool r = Q(p);\n  cout << (r ? \"Yes\" : \"No\") << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  if(false) {\n    dbg();\n  }\n  else {\n    string S; cin >> S;\n    vector<char> ch;\n    string ops = \"01+-*=()\";\n    sort(ops.begin(), ops.end());\n    REP(i,S.size()) {\n      if(ops.find(S[i]) == string::npos) {\n        ch.push_back(S[i]);\n      }\n    }\n    sort(ch.begin(), ch.end());\n    ch.erase(unique(ch.begin(), ch.end()), ch.end());\n    if(ch.size() > 8) {\n      cout << 0 << endl;\n      return 0;\n    }\n    map<char, int> replacer;\n    REP(i,ch.size()) {\n      replacer[ch[i]] = i;\n      // DEBUG(ch[i]);\n    }\n    set<string> ans;\n    do {\n      string T = S;\n      REP(i,T.size()) {\n        if(replacer.count(T[i])) T[i] = ops[replacer[T[i]]];\n      }\n      // if(T == \"-0=(0)\") DEBUG(T);\n      iter p = T.cbegin();\n      bool r = Q(p);\n      if(r) {\n        ans.insert(ops.substr(0,ch.size()));\n        // DEBUG(T);\n      }\n    } while(next_permutation(ops.begin(), ops.end()));\n    cout << ans.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int64)1e9\n#define REP(i, n) for(int64 i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int64 i = (a); i < (b); i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint32_t;\nusing int64 = int64_t;\nusing uint64 = uint64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if (a > b) a = b; }\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if (a < b) a = b; }\n#define double long double\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersectSC(Segment3D s,Sphere c){\n  double d=getDistanceSP(s,c.c);\n  if(d>c.r) return 0;\n  return !((abs(s.p1-c.c)<=c.r)&&(abs(s.p2-c.c)<=c.r));\n}\n\nstruct ConvexHull3D{\n  struct face{\n    int a,b,c;\n    bool ok;\n    face(){}\n    face(int a,int b,int c,bool ok):a(a),b(b),c(c),ok(ok){}\n  };\n  int n,num;\n  vector<Point3D> p;\n  vector<face> f;\n  vector<vector<int> >  g;\n\n  ConvexHull3D(int n):n(n),p(n),f(n*8),g(n,vector<int>(n)){}\n\n  void input(){\n    for(int i=0;i<n;i++) cin>>p[i];\n  }\n\n  double dblcmp(Point3D q,face f){\n    Point3D m=p[f.b]-p[f.a];\n    Point3D n=p[f.c]-p[f.a];\n    Point3D t=q-p[f.a];\n    return (m*n)^t;\n  }\n\n  void deal(int q,int a,int b){\n    int idx=g[a][b];\n    face add;\n    if(f[idx].ok){\n      if(dblcmp(p[q],f[idx])>EPS) dfs(q,idx);\n      else{\n        add=face(b,a,q,1);\n        g[q][b]=g[a][q]=g[b][a]=num;\n        f[num++]=add;\n      }\n    }\n  }\n\n  void dfs(int q,int now){\n    f[now].ok=0;\n    deal(q,f[now].b,f[now].a);\n    deal(q,f[now].c,f[now].b);\n    deal(q,f[now].a,f[now].c);\n  }\n\n  void build(){\n    num=0;\n    if(n<4) return;\n    bool flg=1;\n    for(int i=1;i<n;i++){\n      if(abs(p[0]-p[i])>EPS){\n        swap(p[1],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    flg=1;\n    for(int i=2;i<n;i++){\n      if(abs((p[0]-p[1])*(p[1]-p[i]))>EPS){\n        swap(p[2],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    flg=1;\n    for(int i=3;i<n;i++){\n      if(abs(((p[0]-p[1])*(p[1]-p[2]))^(p[0]-p[i]))>EPS){\n        swap(p[3],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    face add;\n    for(int i=0;i<4;i++){\n      add=face((i+1)%4,(i+2)%4,(i+3)%4,1);\n      if(dblcmp(p[i],add)>0) swap(add.b,add.c);\n      g[add.a][add.b]=g[add.b][add.c]=g[add.c][add.a]=num;\n      f[num++]=add;\n    }\n    for(int i=4;i<n;i++){\n      for(int j=0;j<num;j++){\n        if(f[j].ok&&dblcmp(p[i],f[j])>EPS){\n          dfs(i,j);\n          break;\n        }\n      }\n    }\n    int tmp=num;\n    num=0;\n    for(int i=0;i<tmp;i++)\n      if(f[i].ok) f[num++]=f[i];\n  }\n\n  double volume(Point3D a,Point3D b,Point3D c,Point3D d){\n    return ((b-a)*(c-a))^(d-a);\n  }\n\n  bool same(int s,int t){\n    Point3D &a=p[f[s].a];\n    Point3D &b=p[f[s].b];\n    Point3D &c=p[f[s].c];\n    return  (abs(volume(a,b,c,p[f[t].a]))<EPS)\n            &&    (abs(volume(a,b,c,p[f[t].b]))<EPS)\n            &&    (abs(volume(a,b,c,p[f[t].c]))<EPS);\n  }\n\n  int polygon(){\n    int res=0;\n    for(int i=0;i<num;i++){\n      int flg=1;\n      for(int j=0;j<i;j++)\n        flg&=!same(i,j);\n      res+=flg;\n    }\n    return res;\n  }\n\n  int triangle(){\n    return num;\n  }\n\n  double area(Point3D a,Point3D b,Point3D c){\n    return abs((b-a)*(c-a));\n  }\n\n  Point3D cross(Point3D a,Point3D b,Point3D c){\n    return Point3D((b.y-a.y)*(c.z-a.z)-(b.z-a.z)*(c.y-a.y),\n                   (b.z-a.z)*(c.x-a.x)-(b.x-a.x)*(c.z-a.z),\n                   (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x));\n  }\n\n  double area(){\n    double res=0;\n    if(n==3){\n      Point3D q=cross(p[0],p[1],p[2]);\n      res=abs(q)/2.0;\n      return res;\n    }\n    return res;\n    for(int i=0;i<num;i++)\n      res+=area(p[f[i].a],p[f[i].b],p[f[i].c]);\n    return res/2.0;\n  }\n};\n\nint64 N(int64& d, const string &s=\"\") {\n  int64 ret = s[d]-'0';\n  d++;\n  while (d < s.size() && (s[d] == '0' || s[d] == '1')) {\n    if (ret == 0) return -INF_LL;\n    ret = (ret << 1) + s[d] -'0';\n    d++;\n  }\n  return ret;\n}\n\nint64 E(int64&, const string&);\n\nint64 F(int64& d, const string &s=\"\") {\n  if (s[d] == '-') {\n    d++;\n    int64 ret = F(d, s);\n//    cout << \"F_-_d \" << ret << \" \" << d << endl;\n    if (ret == -INF_LL) return ret;\n    return -ret;\n  } else if (s[d] == '(') {\n    d++;\n    int64 ret = E(d, s);\n    if (s[d] != ')') return -INF_LL;\n    d++;\n    return ret;\n  } else if (s[d] == '0' || s[d] == '1'){\n    return N(d, s);\n  } else {\n    return -INF_LL;\n  }\n}\n\nint64 T(int64& d, const string &s=\"\") {\n  int64 ret = F(d, s);\n//  cout << \"T_d \" << ret << \" \" << d << endl;\n  if (ret == -INF_LL) return -INF_LL;\n  while (d < s.size() && s[d] == '*') {\n    d++;\n    int64 r = F(d, s);\n    if (r == -INF_LL) return r;\n    ret *= r;\n  }\n  return ret;\n}\n\nint64 E(int64& d, const string &s=\"\") {\n  int64 ret = T(d, s);\n  if (ret == -INF_LL) return ret;\n//  cout << \"E_d \" << ret << \" \" << d << endl;\n  while (d < s.size() && (s[d] == '+' || s[d] == '-')) {\n    if (s[d] == '+') {\n      d++;\n      int64 r = T(d, s);\n      if (r == -INF_LL) return r;\n      ret += r;\n    } else if (s[d] == '-') {\n      d++;\n      int64 r = T(d, s);\n      if (r == -INF_LL) return r;\n      ret -= r;\n    }\n  }\n  return ret;\n}\n\nbool ok(int64 d = 0, const string &s=\"\") {\n  int64 lhs = E(d, s);\n//  cout << \"ok\" << lhs << endl;\n  if (lhs == -INF_LL) return 0;\n//  cout << \"ok_d \" << d << endl;\n  if (s[d] != '=') return 0;\n  d++;\n  int64 rhs = E(d, s);\n//  cout << \"ok\" << rhs << endl;\n  if (rhs == -INF_LL || d != s.size()) return 0;\n  return (lhs == rhs);\n}\n\nint main(void) {\n  string s;\n  string symbol = \"=+-*()01\";\n  cin >> s;\n  string chs = \"\";\n  REP(i, s.size()) {\n    if (symbol.find(s[i]) == string::npos && chs.find(s[i]) == string::npos) {\n      chs += s[i];\n    }\n  }\n  vector<int> idx(symbol.size(), -1);\n  REP(i, chs.size()) {\n    idx[symbol.size() - chs.size() + i] = i;\n  }\n  int64 res = 0;\n  do {\n    string t = \"\";\n    char cvt[256] = {};\n    REP(i, idx.size()) {\n      if (idx[i] != -1) {\n        cvt[chs[idx[i]]] = symbol[i];\n      }\n    }\n    REP(i, s.size()) {\n      if (symbol.find(s[i]) == string::npos) {\n        t += cvt[s[i]];\n      } else {\n        t += s[i];\n      }\n    }\n//    cout << t << \" \" << ok(0, t) << endl;\n    if (ok(0, t)) {\n//      cout << t << endl;\n      res++;\n    }\n  } while (next_permutation(all(idx)));\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nbool flag;\n\nint B(string &s, int &n){\n\tint ret = 1;\n\twhile(1){\n\t\tif( s.size() <= n ){ break; }\n\t\telse if( s[n] == '0' ){ n++; ret<<=1; }\n\t\telse if( s[n] == '1' ){ n++; ret<<=1; ret += 1; }\n\t\telse { break; }\n\t}\n\t//cout << \"B \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint N(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\telse if( s[n] == '0' ){ n++; return 0; }\n\telse if( s[n] == '1' ){ n++; return B(s, n); }\n\tflag = false;\n\t//cout << \"flag N\" << endl;\n\treturn 0;\n}\n\nint E(string &s, int &n);\nint F(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\tint ret;\n\tif( s[n] == '0' || s[n] == '1' ){ ret = N(s, n); }\n\telse if( s[n] == '-' ){ n++; ret = -F(s, n); }\n\telse if( s[n] == '(' ){\n\t\tn++;\n\t\tret = E(s, n);\n\t\tif( s[n] == ')' ) n++;\n\t\telse flag = false;\n\t} else {\n\t\t//cout << \"flag F\" << endl;\n\t\tflag = false;\n\t}\n\t//cout << \"F \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint T(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\tint ret = F(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '*' ){ n++; ret *= T(s, n); }\n\t//cout << \"T \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint E(string &s, int &n){\n\tint ret = T(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '+' ){ n++; ret += E(s, n); }\n\telse if( s[n] == '-' ){ n++; ret -= E(s, n); }\n\t//cout << \"E \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nbool Q(string &s){\n\tflag = true;\n\tint n=0;\n\tint l = E(s,n);\n\t//cout << \"l = \" << l << endl;\n\tif( s[n] != '=' ) return false;\n\t//cout << \"n++\" << endl;\n\tn++;\n\tif( s.size() <= n ) return false;\n\tint r = E(s,n);\n\t//cout << \"r = \" << r << endl;\n\tif( s.size() != n ) flag = false;\n\treturn flag && l == r;\n}\n\nvector<char> ope = {'0', '1', '+', '-', '*', '(', ')', '='};\nint main(){\n\tset<string> ans;\n\tstring S;\n\tcin >> S;\n\t\n\t//cout << Q(S) << endl;\n\t//return 0;\n\t\n\tvector<char> v;\n\tfor(char c: S){\n\t\tif( 'A' <= c && c <= 'Z' ) v.push_back(c);\n\t\tif( 'a' <= c && c <= 'z' ) v.push_back(c);\n\t}\n\tv.erase( unique(all(v)), v.end() );\n\tif( v.size() > 8 ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tsort( all(ope) );\n\tdo{\n\t\tchar mp[256]={};\n\t\trep(i,v.size()) mp[v[i]] = ope[i];\n\t\tstring s;\n\t\tfor(char c: S) s += mp[c] ? mp[c] : c ;\n\t\t//cout << s << endl;\n\t\tif( Q(s) ) ans.insert(s);\n\t}while( next_permutation(all(ope)) );\n\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    if(S[idx] != ')') throw (0);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= C(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += B(S, ++idx);\n    else ret -= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdexcept>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw exception();\n  if(S[idx] != c) throw exception();\n  idx ++;\n}\n\nbool try_consume(char c) {\n  try {\n    consume(c);\n  } catch(...) {\n    return false;\n  }\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (...) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool error = false;\nstring errorName = \"\";\nint errorIndex = -1;\n\nbool Q(string& s, int& index);\nint E(string& s, int& index); \nint T(string& s, int& index);\nint F(string& s, int& index);\nint N(string& s, int& index);\n\nbool Q(string& s, int& index){\n    int l = E(s, index);\n    if(error){\n        return false;\n    }\n\n    if(s[index] != '='){\n        errorName = \"Qnot=\";\n        errorIndex = index;\n        return false;\n    }\n    index++;\n    int r = E(s, index);\n    if(error){\n        return false;\n    }\n\n    if(s[index] != '#'){\n        errorName = \"Qend2\";\n        errorIndex = index;\n        return false;\n    }\n\n    return (l == r);\n}\n\nint E(string& s, int& index){\n    int ret = T(s, index);\n    if(error){\n        return -1;\n    }\n\n    while(true){\n        if(s[index] == '+'){\n            index++;\n            int temp = T(s, index);\n            if(error){\n                return -1;\n            }\n            ret += temp;\n        }\n        else if(s[index] == '-'){\n            index++;\n            int temp = T(s, index);\n            if(error){\n                return -1;\n            }\n            ret -= temp;\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint T(string& s, int& index){\n    int ret = F(s, index);\n    if(error){\n        return -1;\n    }\n\n    while(true){\n        if(s[index] == '*'){\n            index++;\n            int temp = F(s, index);\n            if(error){\n                return -1;\n            }\n            ret *= temp;\n        }\n        else{\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nint F(string& s, int& index){\n\n    if(s[index] == '-'){\n        index++;\n        int f = F(s, index);\n        if(error){\n            return -1;\n        }\n        return -f;\n    }\n    else if(s[index] == '('){\n        index++;\n        int ret = E(s, index);\n        if(error){\n            return -1;\n        }\n        if(index == (int)s.size() || s[index] != ')'){\n            error = true;\n            errorName = \"Fnot)\";\n            errorIndex = index;\n            return -1;\n        }\n        index++;\n        return ret;\n    }\n\n    int ret = N(s, index);\n    if(error){\n        return -1;\n    }\n    return ret;\n}\n\nint N(string& s, int& index){\n\n    if(s[index] == '0'){\n        index++;\n        return 0;\n    }\n    else if(s[index] == '1'){\n        index++;\n        int ret = 1;\n        while(index != (int)s.size() && isdigit(s[index])){\n            ret *= 2;\n            ret += s[index] - '0';\n            index++;\n        }\n        return ret;\n    }\n    else{\n        error = true;\n        errorName = \"Nend2\";\n        errorIndex = index;\n        return -1;\n    }\n}\nint main(){\n\n    string s;\n    cin >> s;\n\n    set<char> cSet;\n    for(char c: s){\n        if(('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')){\n            cSet.insert(c);\n        }\n    }\n\n    vector<char> cList(cSet.begin(), cSet.end());\n    int cSize = (int)cList.size();\n    if(cSize > 8){\n        cout << 0 << endl;;\n    }\n    else{\n\n        int ans = 0;\n\n        char replaceList[] = {'0', '1', '+', '-', '*', '(', ')', '='};\n        vector<int> com(8, 0);\n        for(int i = 0; i < cSize; i++){\n            com[8 - i - 1] = 1;\n        }\n\n        vector<int> order(cSize);\n        for(int i = 0; i < cSize; i++){\n            order[i] = i;\n        }\n\n        do{\n            vector<char> useList;\n            for(int i = 0; i < 8; i++){\n                if(com[i] == 1){\n                    useList.push_back(replaceList[i]);\n                }\n            }\n\n            do{\n                string temp = s + '#';\n                for(int i = 0; i < cSize; i++){\n                    replace(temp.begin(), temp.end(), cList[i], useList[order[i]]);\n                }\n                int begin = 0;\n                error = false;\n                errorName = \"\";\n                bool isOk = Q(temp, begin);\n\n                if(isOk){\n                    ans++;\n                }\n                else{\n                    if(errorName != \"Qnot=\"){\n                        //cout << temp << \" \" << errorName << \" \" << errorIndex << endl;\n                    }\n                }\n\n            }while(next_permutation(order.begin(), order.end()));\n        }while(next_permutation(com.begin(), com.end()));\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n \nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n \nint bnf();\n \nint bnf3(){\n   \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n   \n  if(s[p]=='('){\n     \n    p++;\n    if(p<s.size()&&(s[p]=='*'||s[p]=='+')) flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n     \n    int r=bnf();\n     \n    if(p>=s.size()||s[p]!=')') flag=1;\n     \n    p++;\n     \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n     \n     \n    return r;\n  }\n   \n  int res=0,minu=0;\n \n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n   \n  if(s[p]=='-'){\n     \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n     \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n   \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n   \n  if(s[p]=='(') flag=1;\n   \n  if(minu%2) res*=-1;\n   \n  return res;\n}\n \nint bnf2(){\n \n  int res=bnf3();\n \n  while(p<s.size()){\n \n    if(s[p]=='*'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf3();\n       \n      res*=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nint bnf(){\n \n  int res=bnf2();\n \n  while(p<s.size()){\n \n    if(s[p]=='+'){\n \n      p++;\n       \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n       \n      int r=bnf2();\n \n      res+=r;\n       \n    }    \n    else if(s[p]=='-'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf2();\n \n      res-=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nvoid check(){\n   \n  int cnt=0;\n   \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n \n      if(cnt==0){\n    flag=1;\n    return ;\n      }\n      else cnt--;\n    }\n  }\n \n  if(cnt) flag=1;\n}\n \nset<string> me;\n \nvoid solve(){\n   \n  set<char> S;\n   \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n \n  set<char>::iterator ite=S.begin();\n \n  vector<char> al;\n   \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n   \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n   \n  int idx[8];\n \n  for(int i=0;i<8;i++) idx[i]=i;\n   \n  do{\n     \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n \n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n     \n    if(me.count(s)) continue;\n    me.insert(s);\n     \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n     \n    string s1,s2;\n     \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n \n    int f=0;\n \n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n     \n    flag=0;\n    s=s1;\n    p=0;\n\n    int r1=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n     \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n \n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n     \n  }while(next_permutation(idx,idx+8));\n   \n}\n \n \nmain(){\n \n  cin>>s;\n  str=s;\n   \n  solve();\n \n  cout<<ans<<endl;\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar moji[] = \"01+-*()=\";\nstring s;\nchar cset[100];\nint idx[100];\nint length;\nvector<int> perm;\nint pos;\nbool correct;\nstring currents;\nchar get(int i){\n\tif(i >= length){\n\t\treturn '\\0';\n\t}\n\treturn currents[i];\n}\n\nbool Q();\nint E();\nint T();\nint F();\nint N();\nint B(int cur);\n\n\nbool Q(){\n\tint a = E();\n\tif(get(pos) != '='){\n\t\tcorrect  = false;\n\t\treturn false;\n\t}\n\tpos++;\n\tint b = E();\n\treturn a == b;\n}\n\nint E(){\n\tint t = T();\n\twhile(get(pos) == '+' || get(pos) == '-'){\n\t\tif(get(pos) == '+'){\n\t\t\tpos++;\n\t\t\tt += T();\n\t\t}else{\n\t\t\tpos++;\n\t\t\tt -= T();\n\t\t}\n\t}\n\treturn t;\n}\n\nint T(){\n\tint f = F();\n\twhile(get(pos) == '*'){\n\t\tpos++;\n\t\tf *= F();\n\t}\n\treturn f;\n}\n\nint F(){\n\tif(get(pos) == '-'){\n\t\tpos++;\n\t\treturn - F();\n\t}\n\tif(get(pos) == '('){\n\t\tpos++;\n\t\tint e = E();\n\t\tif(get(pos) != ')'){\n\t\t\tcorrect = false;\n\t\t}\n\t\tpos++;\n\t\treturn e;\n\t}\n\n\treturn N();\n}\n\nint N(){\n\tif(get(pos) == '0'){\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif(get(pos) == '1'){\n\t\tpos++;\n\t\treturn B(1);\n\t}\n\tcorrect = false;\n\treturn 0;\n}\n\nint B(int cur){\n\tif(get(pos) == '0'){\n\t\tpos++;\n\t\treturn B(cur * 2);\n\t}\n\tif(get(pos) == '1'){\n\t\tpos++;\n\t\treturn B(cur * 2 + 1);\n\t}\n\treturn cur;\n}\n\n\nint main(){\n\tcin >> s;\n\tlength = s.size();\n\tint si = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(!(('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z'))){\n\t\t\tidx[i] = s[i];\n\t\t\tcontinue;\n\t\t}\n\t\tint j;\n\t\tfor(j = 0; j < si; j++){\n\t\t\tif(cset[j] == s[i]) break;\n\t\t}\n\t\tif(j == si){\n\t\t\tsi++;\n\t\t\tif(si > 8){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcset[j] = s[i];\n\t\t}\n\t\tidx[i] = j;\n\t}\n\t\n\tfor(int i = 0 ; i < 8; i++){\n\t\tperm.push_back(i);\t\n\t}\n\n\tset<string> smap;\n\n\tdo{\n\t\tstring ns = s;\n\t\tfor(int i = 0; i < ns.size(); i++){\n\t\t\tif(('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z')){\n\t\t\t\tns[i] = moji[perm[idx[i]]];\n\t\t\t}\n\t\t}\n\t\tsmap.insert(ns);\n\t}while(next_permutation(perm.begin(), perm.end()));\n\n\tint ans = 0;\n\tfor(string ss : smap){\n\t\tcurrents = ss;\n\t\tpos = 0;\n\t\tcorrect = true;\n\t\tif(Q() && correct && pos == ss.size()){\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint idx, len;\n\nint number();\nint factor();\nint term();\nint expression();\n\nint number(){\n    char c = f[idx++];\n    if(c != '0' and c != '1') throw 1;\n\n    if(c == '0') return 0;\n\n    int ret = 1;\n    while(idx < len and (f[idx] == '0' or f[idx] == '1')){\n        ret *= 2;\n        char c = f[idx++];\n        if(c == '1') ret += 1;\n    }\n    return ret;\n}\n\nint factor(){\n    int mcnt = 0;\n    while(idx < len and f[idx] == '-'){\n        mcnt++;\n        idx++;\n    }\n    if(idx >= len) throw 1;\n\n    int sign = (mcnt % 2 == 0 ? +1:-1);\n    if(f[idx] != '(') return sign * number();\n    idx++;\n\n    int ret = sign * expression();\n    if(idx >= len or f[idx] != ')') throw 1;\n    idx++;\n\n    return ret;\n}\n\nint term(){\n    int ret = factor();\n    while(idx < len and f[idx] == '*'){\n        idx++;\n        int rhs = factor();\n        ret *= rhs;\n    }\n    return ret;\n}\n\nint expression(){\n    int ret = term();\n    while(idx < len and (f[idx] == '+' or f[idx] == '-')){\n        char op = f[idx++];\n        int rhs = term();\n        switch(op){\n            case '+': { ret += rhs; break; }\n            case '-': { ret -= rhs; break; }\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    /*\n    while(cin >> f){\n        len = f.size(), idx = 0;\n        int ret = expression();\n        cerr << ret << \", idx = \" << idx << \", len = \" << len << endl;\n    }\n    return 0;\n    //*/\n\n    string in; cin >> in;\n    string T = \"01+-*()=\"; sort(_all(T));\n\n    set<string> s;\n    do {\n        map<char, bool> used;\n        map<char, char> c2t;\n        int j = 0;\n        f = in;\n        rep(i, in.size()){\n            char c = in[i];\n            if(not isupper(c) and not islower(c)) continue;\n\n            if(not used[c]){\n                used[c] = true;\n                assert(j < T.size());\n                c2t[c] = T[j++];\n            }\n            f[i] = c2t[c];\n        }\n\n        string equation = f;\n        string l, r;\n        rep(i, in.size()){\n            if(f[i] == '='){\n                l = f.substr(0, i);\n                r = f.substr(i + 1);\n                break;\n            }\n        }\n        if(l == \"\" or r == \"\") continue;\n\n        try {\n            idx = 0; f = l; len = f.size();\n            int lv = expression();\n            if(idx != len) continue;\n\n            idx = 0; f = r; len = f.size();\n            int rv = expression();\n            if(idx != len) continue;\n\n            if(lv != rv) continue;\n        }\n        catch(int e){\n            continue;\n        }\n        s.insert(equation);\n    } while(next_permutation(_all(T)));\n\n    for(auto& e : s){\n        cerr << e << endl;\n    }\n    cout << s.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <map>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\n\nconst string charset = \"01+-*()=\";\nstring input;\nint sz;\nint ans;\nmap<char,int> mp;\nvector<char> tbl;\nconst char *p;\n\nLL expr();\nLL term();\nLL factor();\n\nLL expr(){\n\tLL x = term();\n\twhile(1){\n\t\tif(*p == '+'){\n\t\t\t++p;\n\t\t\tLL y = term();\n\t\t\tx += y;\n\t\t}\n\t\telse if(*p == '-'){\n\t\t\t++p;\n\t\t\tLL y = term();\n\t\t\tx -= y;\n\t\t}\n\t\telse{ break; }\n\t}\n\treturn x;\n}\n\nLL term(){\n\tLL x = factor();\n\twhile(*p == '*'){\n\t\t++p;\n\t\tLL y = factor();\n\t\tx *= y;\n\t}\n\treturn x;\n}\n\nLL factor(){\n\tif(*p == '-'){\n\t\t++p;\n\t\tLL x = factor();\n\t\treturn -x;\n\t}\n\tif(*p == '('){\n\t\t++p;\n\t\tLL x = expr();\n\t\tif(*p != ')'){ throw 1; }\n\t\t++p;\n\t\treturn x;\n\t}\n\tif(*p == '0'){\n\t\t++p;\n\t\treturn 0;\n\t}\n\tif(*p == '1'){\n\t\tchar *endp;\n\t\tLL x = strtoll(p, &endp, 2);\n\t\tp = endp;\n\t\treturn x;\n\t}\n\tthrow 2;\n}\n\nvoid check() try{\n\tstring e;\n\tfor(char c : input){\n\t\tif(isalpha(c)){\n\t\t\te += tbl[mp[c]];\n\t\t}\n\t\telse{\n\t\t\te += c;\n\t\t}\n\t}\n\tp = e.c_str();\n\t\n\tLL lt = expr();\n\tif(*p == '='){\n\t\t++p;\n\t\tLL rt = expr();\n\t\tif(!*p && lt == rt){\n\t\t\t++ans;\n\t\t}\n\t}\n}\ncatch(...){}\n\nvoid dfs(int i, int u){\n\tif(i == sz){\n\t\tcheck();\n\t}\n\telse{\n\t\tfor(int j = 0; j < 8; ++j){\n\t\t\tif(!(u >> j & 1)){\n\t\t\t\ttbl[i] = charset[j];\n\t\t\t\tdfs(i + 1, u | 1 << j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> input;\n\tfor(char c : input){\n\t\tif(isalpha(c)){\n\t\t\tmp.emplace(c, mp.size());\n\t\t}\n\t}\n\tsz = mp.size();\n\tif(sz <= 8){\n\t\ttbl.assign(sz, 0);\n\t\tdfs(0, 0);\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nbool Q();\nint E();\nint T();\nint F();\nint N();\nstring B();\n\nstring enc;\nstring str;\nstring alpha;\nint idx;\nint ans;\n\nbool flag;\n\nstring sign = \"01+-*()=\";\n\nbool isok(char c) {\n  return idx < (int)str.size() && str[idx] == c;\n}\n\nbool Q() {\n  flag = true;\n  if(count(all(str), '=') != 1) return false;\n\n  int lh = E();\n  if(!flag) return false;\n  if(!isok('=')) return false;\n  idx++; // =\n\n  int rh = E();\n  if(!flag) return false;\n  if(idx != (int)str.size()) return false;\n\n  return lh == rh;\n}\n\nint E() {\n  int res = T();\n  if(!flag) return 0;\n  while(flag && (isok('+') || isok('-'))) {\n    int ope = (str[idx] == '+' ? 1 : -1);\n    idx++; // +/-\n    int ri = T();\n    if(!flag) return 0;\n    res += ope*ri;\n  }\n  return res;\n}\n\nint T() {\n  int res = F();\n  if(!flag) return 0;\n  while(flag && isok('*')) {\n    idx++;\n    int ri = F();\n    if(!flag) return 0;\n    res *= ri;\n  }\n  return res;\n}\n\nint F() {\n  if(isok('-')) {\n    idx++;\n    int res = F();\n    if(!flag) return 0;\n    return -res;\n  }\n  if(isok('(')) {\n    idx++;\n    int res = E();\n    if(!flag) return 0;\n    if(!isok(')')) { flag = false; return 0; }\n    idx++; // )\n    return res;\n  }\n  int res = N();\n  if(!flag) return 0;\n  return res;\n}\n\nint N() {\n  string tmp = B();\n  if(tmp.empty() || (tmp.size() > 1 && tmp[0] == '0')) { flag = false; return 0; }\n  reverse(all(tmp));\n  int res = 0, p = 1;\n  rep(i, tmp.size()) {\n    res += (tmp[i]-'0')*p;\n    p *= 2;\n  }\n  return res;\n}\n\nstring B() {\n  string res = \"\";\n  while(idx < (int)str.size() && isdigit(str[idx])) res += str[idx++];\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> enc;\n  for(char c : enc) {\n    if(isalpha(c)) alpha.push_back(c);\n  }\n  sort(all(alpha));\n  alpha.erase(unique(all(alpha)), alpha.end());\n  if(alpha.size() > sign.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  ans = 0;\n  sort(all(sign));\n  set<string> st;\n  do {\n    //cout<<sign<<endl;\n    idx = 0;\n    str = enc;\n    for(char &c : str) {\n      if(isalpha(c)) c = sign[alpha.find(c)];\n    }\n    if(st.count(str)) continue;\n    st.insert(str);\n    if(Q()) {\n      //cout << idx << \" \" << str << endl;\n      ans++;\n    }\n  } while(next_permutation(all(sign)));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar c[8]={'0','1','+','-','*','(',')','='};\n\nvector<char> alph;\nmap<char,char> ralph;\n\nstring s;\nint p;\n\nint bnf();\n\nint get_num(){\n\n  if(s[p]=='('){\n\n    p++;\n    \n    int res=bnf();\n    \n    p++;\n    \n    return res;\n  }\n  \n  int res=0;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0', p++;\n  \n  return res;\n}\n\nint bnf2(){\n  \n  int res=get_num();\n  \n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      res=res*get_num();\n      \n    }\n    else break;\n    \n  }\n  \n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n  cout<<res<<' '<<p<<endl;\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n\n      res=res+bnf2();\n      \n    }\n    else if(s[p]=='-'){\n      \n      p++;\n      \n      res=res-bnf2();\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nbool check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++)\n    if(s[i]=='=') cnt++;\n  \n  if(cnt!=1) return false;\n  \n  cnt=0;\n  \n  int idx;\n  \n  for(int i=0;i<s.size();i++){\n    \n    if(s[i]=='='){\n      idx=i;\n      break;\n    }\n    \n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n      if(!cnt) return false;\n      cnt--;\n    }\n    \n  }\n  \n  if(cnt) return false;\n  \n  cnt=0;\n  \n  for(int i=idx;i<s.size();i++){\n    \n    if(s[i]=='='){\n      idx=i;\n      break;\n    }\n    \n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n      if(!cnt) return false;\n      cnt--;\n    }\n    \n  }\n  \n  if(cnt) return false;\n\n  for(int i=0;i<s.size();i++){\n\n    if(i&&s[i]=='*'&&(s[i-1]=='*'||s[i-1]=='-'||s[i-1]=='+')) return false;\n\n    if(s[i]=='='&&(!i||i==s.size()-1)) return false;\n    \n    if(s[i]=='='&&(s[i-1]=='*'||s[i-1]=='-'||s[i-1]=='+'||s[i-1]=='(')) return false;\n    if(s[i]=='='&&(s[i+1]=='*'||s[i+1]=='-'||s[i+1]=='+'||s[i+1]==')')) return false;\n    \n  }\n  \n  return true;\n}\n\nset<string> memo;\n\nint solve(string t){\n\n  if(alph.size()>8) return 0;\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n\n  int res=0;\n  \n  do{\n    \n    for(int i=0;i<alph.size();i++)\n\n      ralph[alph[i]]=c[idx[i]];\n    \n    s=t;\n\n    if(memo.count(s)) continue;\n    memo.insert(s);\n    \n    for(int i=0;i<s.size();i++)\n\n      if(ralph.count(s[i])) s[i]=ralph[s[i]];\n      \n    if(!check()) continue;\n    \n    string s1,s2;\n    int f=0;\n    \n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') f=1;\n      else if(!f) s1+=s[i];\n      else s2+=s[i];\n    \n    s=s1;\n\n    p=0;\n    \n    int r=bnf();\n\n    s=s2;\n\n    p=0;\n    \n    if(r==bnf()) res++;\n    \n  }while(next_permutation(idx,idx+8));\n  \n  return res;\n}\n\nbool isalph(char A){\n  return ('a'<=A&&A<='z')||('A'<=A&&A<='Z');\n}\n\nint main(){\n  \n  string t;\n  \n  cin>>t;\n\n  //  s=t;\n\n  //cout<<bnf()<<endl;\n  \n  for(int i=0;i<t.size();i++)\n    if(isalph(t[i])) alph.push_back(t[i]);\n  \n  solve(t);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool flg;\nint expr(string s,int& p);\nint term(string s,int& p);\nint factor(string s,int& p);\nint number(string s,int& p);\nint expr(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(flg) return 0;\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(flg) return 0;\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='-'){\n    p++;\n    res=-factor(s,p);\n  }else if(s[p]=='('){\n    p++;\n    res=expr(s,p);\n    if(p>=(int)s.size()||s[p]!=')'){\n      flg=1;\n      return 0;\n    }\n    p++;\n  }else if(isdigit(s[p])){\n    res=number(s,p);\n  }else{\n    flg=1;\n    return 0;\n  }\n  return res;\n}\nint number(string s,int& p){\n  if(s[p]=='0'){\n    if(p+1<(int)s.size()&&isdigit(s[p+1])){\n      flg=1;\n      return 0;\n    }\n    p++;\n    return 0;\n  }\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p])) res=res*2+s[p++]-'0';\n  return res;\n}\nbool check(string s){\n  if(s.size()==0) return 0;\n  int op=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(op<0) return 0;\n  }\n  if(op) return 0;\n  return 1;\n}\n//set<string> ss;\nint Q(string s){\n  if(count(s.begin(),s.end(),'=')!=1) return 0;\n  int k=s.find('=');\n  string a=s.substr(0,k);\n  string b=s.substr(k+1,s.size()-(k+1));\n  if(!check(a)) return 0;\n  if(!check(b)) return 0;\n  //cout<<s<<endl;\n  //cout<<a<<\" \"<<b<<endl;\n  flg=0;\n  int p=0;\n  int x=expr(a,p);\n  //cout<<flg<<\" \"<<p<<\" \"<<x<<endl;\n  if(flg||p!=(int)a.size()) return 0;\n  p=0;\n  int y=expr(b,p);\n  //cout<<flg<<\" \"<<p<<\" \"<<y<<endl;\n  if(flg||p!=(int)b.size()) return 0;\n  //cout<<a<<\" \"<<b<<endl;\n  //cout<<x<<\":\"<<y<<endl;\n  return x==y;\n}\nint ans=0;\nstring l=\"01+-*()=\";\nvoid dfs(string s,int b){\n  bool f=1;\n  for(int i=0;i<(int)s.size();i++){\n    if(!isalpha(s[i])) continue;\n    f=0;\n    char c=s[i];\n    for(int j=0;j<(int)l.size();j++){\n      if((b>>j)&1) continue;\n      string t=s;\n      for(int k=0;k<(int)s.size();k++){\n\tif(t[k]==c) t[k]=l[j];\n      }\n      dfs(t,b+(1<<j));\n    }\n    break;\n  }\n  if(f) ans+=Q(s);\n}\nsigned main(){\n  string s;\n  cin>>s;\n   \n  dfs(s,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool flg;\nint expr(string s,int& p);\nint term(string s,int& p);\nint factor(string s,int& p);\nint number(string s,int& p);\nint expr(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(flg) return 0;\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(flg) return 0;\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='-'){\n    p++;\n    res=-factor(s,p);\n  }else if(s[p]=='('){\n    p++;\n    res=expr(s,p);\n    if(p>=(int)s.size()||s[p]!=')'){\n      flg=1;\n      return 0;\n    }\n    p++;\n  }else if(isdigit(s[p])){\n    res=number(s,p);\n  }else{\n    flg=1;\n    return 0;\n  }\n  return res;\n}\nint number(string s,int& p){\n  if(s[p]=='0'){\n    if(p+1<(int)s.size()&&isdigit(s[p+1])){\n      flg=1;\n      return 0;\n    }\n    p++;\n    return 0;\n  }\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p])) res=res*2+s[p++]-'0';\n  return res;\n}\nbool check(string s){\n  if(s.size()==0) return 0;\n  int op=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(op<0) return 0;\n  }\n  if(op) return 0;\n  return 1;\n}\n//set<string> ss;\nint Q(string s){\n  if(count(s.begin(),s.end(),'=')!=1) return 0;\n  int k=s.find('=');\n  string a=s.substr(0,k);\n  string b=s.substr(k+1,s.size()-(k+1));\n  if(!check(a)) return 0;\n  if(!check(b)) return 0;\n  //cout<<s<<endl;\n  //cout<<a<<\" \"<<b<<endl;\n  flg=0;\n  int p=0;\n  int x=expr(a,p);\n  //cout<<flg<<\" \"<<p<<\" \"<<x<<endl;\n  if(flg||p!=(int)a.size()) return 0;\n  p=0;\n  int y=expr(b,p);\n  //cout<<flg<<\" \"<<p<<\" \"<<y<<endl;\n  if(flg||p!=(int)b.size()) return 0;\n  //cout<<a<<\" \"<<b<<endl;\n  //cout<<x<<\":\"<<y<<endl;\n  return x==y;\n}\nint ans=0;\nstring l=\"01+-*()=\";\nvoid dfs(string s,int b){\n  bool f=1;\n  for(int i=0;i<(int)s.size();i++){\n    if(!isalpha(s[i])) continue;\n    f=0;\n    char c=s[i];\n    for(int j=0;j<(int)l.size();j++){\n      if((b>>j)&1) continue;\n      string t=s;\n      for(int k=0;k<(int)s.size();k++){\n    if(t[k]==c) t[k]=l[j];\n      }\n      dfs(t,b+(1<<j));\n    }\n    break;\n  }\n  if(f) ans+=Q(s);\n}\nsigned main(){\n  string s;\n  cin>>s;\n    \n  dfs(s,0);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren++;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\t//cout << tmp << endl;\n\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\t//cout << lhs << \" \" << rhs << endl;\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\t/*\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\t//string d = \"(10110)-10\";\n\t//cout << \"xo\"[isE(d, m, d.begin(), d.end())] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1-11010=(10110)-10\", m)] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1+-11010=(10110)-10\", m)] << endl;\n\tcout << \"xo\"[check(\"1+11*1+-11*10=(1*110)+-10\", m)] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m)) {\n\t\t\t/*\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t\t//*/\n\t\t\tif (check(str, m)) {\n\t\t\t\t//cout << \"=======================\" << endl;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren++;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// +?????§??????\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '+') {\n\t\t\tif (i == 0 || !(m[str[i - 1]] == '0' || m[str[i - 1]] == '1'))return false;\n\t\t}\n\t}\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\t//cout << tmp << endl;\n\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\tif (tmp.size() == 0 && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (tmp.size() > 0 && m[tmp[tmp.size() - 1]] == '=' && charr[i] == '+') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\t//cout << lhs << \" \" << rhs << endl;\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\t/*\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tstring d = \"1*-1\";\n\tcout << \"xo\"[isE(d, m, d.begin(), d.end())] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1-11010=(10110)-10\", m)] << endl;\n\tcout << \"xo\"[isQ(\"--1001=1001\", m)] << endl;\n\tcout << \"xo\"[check(\"--1001=1001\", m)] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m)) {\n\t\t\t/*\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t\t//*/\n\t\t\tif (check(str, m)) {\n\t\t\t\t//cout << \"=======================\" << endl;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nint bnf();\nset<P> used;\nmap<char,int> M;\nstring S;\nint idx,valid;\nchar ch[8]={'0','1','+','-','*','(',')','='};\nint ord[8];\n  \nbool check(string a){//???????????????????°????¨????????????????????????¢????\n  int par=0;\n  for(char s:a){\n    par += (s == '(') - (s == ')');\n    if(s == '=') return 0;\n    if(par < 0) return 0;\n  }\n  return par==0;\n}\n  \nint getNum(){ //????????????????°????????????\n  int res = 0;\n  if(S[idx] == '0' && isdigit(S[idx+1])) valid  = 0;\n  while(isdigit(S[idx]))res = res*2 + S[idx++]-'0';\n  return res;\n}\n  \nint cal(){\n  char ch = S[idx];\n  int res = 0,sign = 1;\n  if(ch=='+'||ch=='*'||ch==')'){ valid = 0;return 0;}\n  \n  while(S[idx] == '-') idx++, sign *= -1;\n  ch = S[idx];\n  \n  if(isdigit(ch)){\n    res = sign*getNum();\n    if(S[idx] == '*'){idx++; return res * cal();}\n    return res;\n  }\n  else if(ch == '(') {\n    idx++;res = sign*bnf();idx++;\n    return res;\n  }\n  \n  valid = 0;\n  return 0;\n}\n  \nint bnf(){\n  int res = cal();\n  while(idx<(int)S.size()){\n    if(valid == 0) return -1;\n    char ch = S[idx];\n    if(ch == '('){valid = 0;}\n    else if(ch == '*'){idx++;res *= cal();}\n    else if(ch == '+'){idx++;res += cal();}\n    else if(ch == '-'){idx++;res -= cal();}\n    else if(ch != ')') valid = 0;\n    else break;\n  }\n  if(valid ==0) return -1;\n  return res;\n}\n  \nstring mkS(string a){\n  string res;\n  for(char s:a){\n    if(isalpha(s))res += ch[ ord[ M[s] ] ];\n    else res += s;\n  }\n  return res;\n}\n  \nint calc(string A,string B){\n  if(A.size()==0 || B.size()==0) return 0;\n  if(used.count(P(A,B)))return 0;\n  used.insert(P(A,B));\n  valid = check(A) && check(B);\n  idx = 0;\n  S = A;\n  int ra = bnf();\n  idx = 0;\n  S = B;\n  int rb = bnf();\n  //if(valid)cout<<A<<\"=\"<<B<<\" \"<<valid<<\" \"<<ra<<\" \"<<rb<<endl;\n  return ra == rb && valid;\n}\n  \nint calc(string s){\n  s = mkS(s);\n  for(int i=0;i<(int)s.size();i++)\n    if(s[i]=='=') return calc(s.substr(0,i),s.substr(i+1,s.size()-i-1));\n  return 0;\n}\n  \nint dfs(int num,string &s){\n  if(num == 8) return calc(s);\n    \n  int res = 0;\n  for(int i=0;i<8;i++){\n    if(ord[i] != -1)continue;\n    ord[i] = num;\n    res +=dfs(num+1,s);\n    ord[i] = -1;\n  }\n  return res;\n}\n  \n  \nint main(){\n  string str;\n  cin>>str;\n  if(str.size()<3)cout<<0<<endl,exit(0);\n  \n  map<char,int> cnt;\n  for(int i=0;i<(int)str.size();i++)if(isalpha(str[i]))cnt[str[i]]++;\n  if(cnt.size()>8)cout<<0<<endl,exit(0);\n  \n  int c = 0;\n  for(pair<char,int> p:cnt)if(isalpha(p.first)) M[p.first] = c++;\n    \n  memset(ord,-1,sizeof(ord));  \n  cout<<dfs(0,str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing State = string::const_iterator;\n\nbool equation(State &itr);\nint expr(State &itr);\nint term(State &itr);\nint factor(State &itr);\nint number(State &itr);\n\n\nbool valid;\n\nvoid error(State &itr){\n    valid = false;\n    while(*itr){\n        itr++;\n    }\n}\n\nvoid next_char(State &itr, char expected){\n    if(*itr == expected){\n        itr++;\n    }else{\n        error(itr);\n    }\n}\n\nbool equation(State &itr){\n    int lhs = expr(itr);\n    next_char(itr, '=');\n    int rhs = expr(itr);\n    return lhs == rhs;\n}\n\nint expr(State &itr){\n    int res = term(itr);\n    while(1){\n        if(*itr == '+'){\n            itr++;\n            res += term(itr);\n        }else if(*itr == '-'){\n            itr++;\n            res -= term(itr);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\nint term(State &itr){\n    int res = factor(itr);\n    while(1){\n        if(*itr == '*'){\n            itr++;\n            res *= factor(itr);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nint factor(State &itr){\n    int res;\n    if(*itr == '-'){\n        itr++;\n        res = -factor(itr);\n    }else if(*itr == '('){\n        next_char(itr, '(');\n        res = expr(itr);\n        next_char(itr, ')');\n    }else{\n        res = number(itr);\n    }\n    return res;\n}\n\nint number(State &itr){\n    if(isdigit(*itr)){\n        if(*itr == '0'){\n            itr++;\n            return 0;\n        }\n        int res = 0;\n        while(isdigit(*itr)){\n            res <<= 1;\n            res |= *itr-'0';\n            itr++;\n        }\n        return res;\n    }else{\n        error(itr);\n        return 0;\n    }\n}\n\nconstexpr char chs[] = {'=','+','-','*','(',')','0','1'};\nmap<char,int> mp;\nstring s;\nvector<char> v;\nvector<bool> used;\nstring formula;\n\nint rec(int n){\n    if(n==0){\n        State begin = formula.begin();\n        valid = true;\n        valid &= equation(begin);\n        valid &= begin == formula.end();\n        return (valid ? 1 : 0);\n    }\n    int res = 0;\n    if(isalpha(s[n-1])){\n        int idx = mp[s[n-1]];\n        if(v[idx] == '#'){\n            for(int i=0;i<8;i++){\n                if(!used[i]){\n                    used[i] = true;\n                    v[idx] = chs[i];\n                    formula[n-1] = chs[i];\n                    res += rec(n-1);\n                    used[i] = false;\n                    v[idx] = '#';\n                }\n            }\n        }\n        else{\n            formula[n-1] = v[idx];\n            res += rec(n-1);\n        }\n    }else{\n        formula[n-1] = s[n-1];\n        res = rec(n-1);\n    }\n    return res;\n}\n\nint main(){\n    cin >> s;\n    int n = 0;\n    for(auto c : s){\n        if(isalpha(c) && mp.find(c) == mp.end()){\n            mp[c] = n;\n            n++;\n        }\n    }\n    v.resize(n, '#');\n    used.resize(n, false);\n    formula.resize(s.size());\n    cout << rec(int(s.size())) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nbool Q();\nint E();\nint T();\nint F();\nint N();\nstring B();\n\nstring enc;\nstring str;\nstring alpha;\nint idx;\nint ans;\n\nbool flag;\n\nstring sign = \"01+-*()=\";\n\nbool isok(char c) {\n  return idx < (int)str.size() && str[idx] == c;\n}\n\nbool Q() {\n  flag = true;\n  if(count(all(str), '=') != 1) return false;\n\n  int lh = E();\n  if(!flag) return false;\n  if(!isok('=')) return false;\n  idx++; // =\n\n  int rh = E();\n  if(!flag) return false;\n  if(idx != (int)str.size()) return false;\n\n  return lh == rh;\n}\n\nint E() {\n  int res = T();\n  if(!flag) return 0;\n  while(flag && (isok('+') || isok('-'))) {\n    int ope = (str[idx] == '+' ? 1 : -1);\n    idx++; // +/-\n    int ri = T();\n    if(!flag) return 0;\n    res += ope*ri;\n  }\n  return res;\n}\n\nint T() {\n  int res = F();\n  if(!flag) return 0;\n  while(flag && isok('*')) {\n    idx++;\n    int ri = F();\n    if(!flag) return 0;\n    res *= ri;\n  }\n  return res;\n}\n\nint F() {\n  if(isok('-')) {\n    idx++;\n    int res = F();\n    if(!flag) return 0;\n    return -res;\n  }\n  if(isok('(')) {\n    idx++;\n    int res = E();\n    if(!flag) return 0;\n    if(!isok(')')) { flag = false; return 0; }\n    idx++; // )\n    return res;\n  }\n  int res = N();\n  if(!flag) return 0;\n  return res;\n}\n\nint N() {\n  string tmp = B();\n  if(tmp.empty() || (tmp.size() > 1 && tmp[0] == '0')) { flag = false; return 0; }\n  reverse(all(tmp));\n  int res = 0, p = 1;\n  rep(i, tmp.size()) {\n    res += (tmp[i]-'0')*p;\n    p *= 2;\n  }\n  return res;\n}\n\nstring B() {\n  string res = \"\";\n  while(idx < (int)str.size() && isdigit(str[idx])) res += str[idx++];\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> enc;\n  for(char c : enc) {\n    if(isalpha(c)) alpha.push_back(c);\n  }\n  sort(all(alpha));\n  alpha.erase(unique(all(alpha)), alpha.end());\n  if(alpha.size() > sign.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  ans = 0;\n  sort(all(sign));\n  set<string> st;\n  do {\n    //cout<<sign<<endl;\n    idx = 0;\n    str = enc;\n    for(char &c : str) {\n      if(isalpha(c)) c = sign[alpha.find(c)];\n    }\n    if(st.count(str)) continue;\n    st.insert(str);\n    if(Q()) {\n      //cout << idx << \" \" << str << endl;\n      ans++;\n    }\n  } while(next_permutation(all(sign)));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nstring::iterator p;\nint fact();\nint term();\nint exp();\nint k,d;\nbool f[2];\n\nint fact() {\n  int x;string num;\n  int mi=1;\n  if(*p=='-') {\n    mi=-1;\n    p++;\n  }\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()>1&&num[0]=='0') f[k]=0;\n  if(num.size()) {\n    x=0;\n    for(int i=num.size()-1,j=0; i>=0; i--,j++) x+=(1<<j)*(num[i]=='1');\n  } else if(p!=s[k].end()){\n    if(*p!='(') f[k]=0;\n    d++;\n    if(p!=s[k].end())++p;\n    x=exp();\n    if(*p!=')') f[k]=0;\n    d--;\n    if(p!=s[k].end())++p;\n  } else f[k]=0;\n  return x*mi;\n}\n \nint term() {\n  int x=fact();\n  while(*p=='*') {\n    if(*p=='*') {\n      ++p;\n      x*=fact();\n    }\n  }\n  return x;\n}\n \nint exp() {\n  int x=term();\n  if(p!=s[k].end()&&*p!='+'&&*p!='-'&&*p!=')') f[k]=0;\n  if(*p==')'&&!d) f[k]=0;\n  while(*p=='+'||*p=='-') {\n    if(*p=='+') {\n      ++p;\n      x+=term();\n    } else {\n      ++p;\n      x-=term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  string r=\"01+-*()=\";\n  sort(r.begin(),r.end());\n  string t;\n  cin >> t;\n  map<char,int> m;\n  for(int i=0; i<t.size(); i++) {\n    if(isalpha(t[i])&&!m.count(t[i])) {\n      int x=m.size();\n      m[t[i]]=x;\n    }\n  }\n  if(m.size()>r.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<string> se;\n  do {\n    string e=t;\n    for(int i=0; i<e.size(); i++) {\n      if(isalpha(e[i])) e[i]=r[m[e[i]]];\n    }\n    int c=0;\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') c++;\n    }\n    if(c!=1) continue;\n    c=0;\n    s[0]=s[1]=\"\";\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') {\n        c++;\n        continue;\n      }\n      s[c]+=e[i];\n    }\n    if(!s[0].size()||!s[1].size()) continue;\n    int x[2];\n    for(k=0; k<2; k++) {\n      d=0;\n      f[k]=1;\n      p=s[k].begin();\n      x[k]=exp();\n      if(d) f[k]=0;\n    }\n    if(f[0]&&f[1]&&x[0]==x[1]) se.insert(r.substr(0,m.size()));\n  } while(next_permutation(r.begin(),r.end()));\n  cout << se.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nbool flag;\n\nint B(string &s, int &n){\n\tint ret = 0;\n\twhile(1){\n\t\tif( !isdigit(s[n]) ){ break; }\n\t\telse if( s[n] == '0' ){ n++; ret<<=1; }\n\t\telse if( s[n] == '1' ){ n++; ret<<=1; ret += 1; }\n\t}\n\t//cout << \"B \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint N(string &s, int &n){\n\tif( !isdigit(s[n]) ){ flag = false; }\n\telse if( s[n] == '0' ){ n++; return 0; }\n\telse if( s[n] == '1' ){ return B(s, n); }\n\t//cout << \"flag N\" << endl;\n\treturn 0;\n}\n\nint E(string &s, int &n, int ret=0);\nint F(string &s, int &n){\n\tint ret;\n\tif( isdigit(s[n]) ){ ret = N(s, n); }\n\telse if( s[n] == '-' ){ n++; ret = -F(s, n); }\n\telse if( s[n] == '(' ){\n\t\tn++;\n\t\tret = E(s, n);\n\t\tif( s[n] == ')' ) n++;\n\t\telse flag = false;\n\t} else {\n\t\t//cout << \"flag F\" << endl;\n\t\tflag = false;\n\t}\n\t//cout << \"F \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint T(string &s, int &n){\n\tint ret = F(s,n);\n\tif( s[n] == '*' ){ n++; ret *= T(s, n); }\n\t//cout << \"T \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint E(string &s, int &n, int ret){\n\tret += T(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '+' ){ n++; ret =  E(s, n, ret); }\n\telse if( s[n] == '-' ){ n++; ret = -E(s, n, ret); }\n\t//cout << \"E \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nbool Q(string &s){\n\tflag = true;\n\tint n=0;\n\tint l = E(s,n);\n\t//cout << \"l = \" << l << endl;\n\tif( s[n] == '=' ) n++;\n\telse return false;\n\tint r = E(s,n);\n\t//cout << \"r = \" << r << endl;\n\tif( s[n] != '$' ) flag = false;\n\treturn flag && l == r;\n}\n\nstring ope = \"01+-*()=\";\nint main(){\n\tset<string> ans;\n\tstring S;\n\tcin >> S;\n\t\n\tvector<char> v;\n\tfor(char c: S){\n\t\tif( 'A' <= c && c <= 'Z' ) v.push_back(c);\n\t\tif( 'a' <= c && c <= 'z' ) v.push_back(c);\n\t}\n\tsort(all(v));\n\tv.erase( unique(all(v)), v.end() );\n\tif( v.size() > 8 ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tsort( all(ope) );\n\tdo{\n\t\tchar mp[127]={};\n\t\trep(i,v.size()) mp[v[i]] = ope[i];\n\t\tstring s;\n\t\tfor(char c: S) s += (mp[c] ? mp[c] : c);\n\t\ts += '$';\n\t\t//cout << s << endl;\n\t\tif( Q(s) ) ans.insert(s);\n\t}while( next_permutation(all(ope)) );\n\n\t//for(auto p: ans) cout << p << endl;\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<sstream>\n#include<deque>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdlib>\n#include<climits>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll LLINF = LLONG_MAX;\nconst bool debug = false\nconst string opr = \"01+-*=()\";\n\nstring context;\nint n;\n\nll parse_E(int&,string&);\n\nll parse_F(int &p,string &s) {\n  if( p >= (int)s.size() ) return LLINF;\n  if( s[p] == '+' ) return LLINF;\n  if( s[p] == '-' ) {\n    ++p;\n    ll v = parse_F(p,s);\n    if( v == LLINF ) return LLINF;\n    return v * -1LL;\n  } \n  if( s[p] == '(' ) {\n    ++p;\n    ll v = parse_E(p,s);\n    if( v == LLINF ) return LLINF;\n    if( p >= (int)s.size() ) return LLINF;\n    if( s[p] != ')' ) return LLINF;\n    ++p;\n    if( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) return LLINF;\n    return v;\n  }\n  int cnt = 0;\n  ll v = 0;\n  bool first_zero = ( s[p] == '0' );\n  while( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) {\n    v <<= 1;\n    v += (ll)( s[p] - '0' );\n    ++p;\n    ++cnt;\n  }\n  if( first_zero && cnt != 1 ) return LLINF;\n  if( cnt == 0 ) return LLINF;\n  if( p < (int)s.size() && s[p] == '(' ) return LLINF;\n  return v;\n}\n\nll parse_T(int &p,string &s) {\n  ll v = parse_F(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && s[p] == '*' ) {\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    v *= tmp;\n  }\n  return v;\n}\n\nll parse_E(int &p,string &s) {\n  ll v = parse_T(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && ( s[p] == '+' || s[p] == '-' ) ) {\n    char op = s[p];\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    if( op == '+' ) v += tmp;\n    if( op == '-' ) v -= tmp;\n  }\n  return v;\n}\n\nbool pari_check(string &s) {\n  int cnt = 0;\n  rep(i,(int)s.size()) {\n    if( s[i] == '(' ) ++cnt;\n    if( s[i] == ')' ) --cnt;\n    if( cnt < 0 ) return false;\n  }\n  return cnt == 0;\n}\n\nbool check() {\n  string s,t;\n  {\n    string tmp;\n    tmp = context;\n    rep(i,n) if( context[i] == '=' ) tmp[i] = ' ';\n    vector<string> vec;\n    stringstream ss;\n    ss << tmp;\n    while( ss >> s ) vec.push_back(s);\n    if( vec.size() != 2 ) return false;\n    s = vec[0];\n    t = vec[1];\n  }\n  if( !pari_check(s) || !pari_check(t) ) return false;\n  int p = 0;\n  ll sv = parse_E(p,s);\n  p = 0;\n  ll tv = parse_E(p,t);\n  if( sv == LLINF || tv == LLINF) return false;\n  return sv == tv;\n}\n\nint dfs(int ptr,int used,vector<char> &already) {\n  if( n <= ptr ) {\n    if( debug ) {\n      if( check() ) {\n\tcout << \"succeeded : \" << context << endl;\n\treturn true;\n      } else {\n\t//cout << \"failed    : \" << context << endl;\n\treturn false;\n      }\n    } else {\n      return check();\n    }\n  }\n  if( !isalpha(context[ptr]) ) return dfs(ptr+1,used,already);\n  int sum = 0;\n  int v = context[ptr] - 'a';\n  if( already[v] != '$' ) {\n    if( already[v] == '=' ) return 0;\n    char tmp = context[ptr];\n    context[ptr] = already[v];\n    sum += dfs(ptr+1,used,already);\n    context[ptr] = tmp;\n    return sum;\n  }\n  rep(i,(int)opr.size()) {\n    if( ( used >> i ) & 1 ) continue;\n    char tmp = context[ptr];\n    context[ptr] = opr[i];\n    already[v] = opr[i];\n    sum += dfs(ptr+1,used|(1<<i),already);\n    already[v] = '$';\n    context[ptr] = tmp;\n  }\n  return sum;\n}\n\nbool normalize() {\n  vector<char> vec;\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) vec.push_back(context[i]);\n  sort(all(vec));\n  vec.erase(unique(all(vec)),vec.end());\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) {\n    int pos = lower_bound(all(vec),context[i]) - vec.begin();\n    context[i] = (char)('a'+pos);\n  }\n  return (int)vec.size() <= 8;\n}\n\nvoid compute() {\n  if( debug ) cout << \"      context : \" << context << endl;\n  if( !normalize() ) { puts(\"0\"); return; }\n  if( debug ) cout << \"fixed context : \" << context << endl;\n  n = (int)context.size();\n  int used = 0;\n  rep(i,n) if( context[i] == '=' ) { used = (1<<5); break; }\n  vector<char> vec(8,'$');\n  cout << dfs(0,used,vec) << endl;\n}\n\nint main() {\n  if( 0 ) {\n    string s;\n    cin >> s;\n    int p = 0;\n    cout << parse_E(p,s) << endl;\n    return 0;\n  }\n  cin >> context;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  if(str[now+1]=='+'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t+p;\n  }\n  if(str[now+1]=='-'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t-p;\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size() + mm.size()>8 ){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do {\n    bool flg=true;\n    /*\n    rep(i, m.size()){\n      if(mm.find(moji[i]) != mm.end()){\n        flg = false;\n      }\n    }*/\n\n    string newstr(s);\n    int idx=0;\n    if(flg){\n      for(auto c : m){\n        // str?????????c???moji[idx]???????????????\n        rep(i, newstr.size()) if(newstr[i]==c){\n          newstr[i] = moji[idx];\n        }\n        idx++;\n      }\n    }\n    idx = newstr.find('=');\n    if(newstr[0]=='=' || idx<0) flg=false;\n\n    if(flg){\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdint>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <stdexcept>\n#include <string>\n#include <utility>\n\nusing Num = std::int64_t;\n\nclass Solver {\n  public:\n    std::string s;\n    Num solve() {\n      std::map<char, int> char_idx;\n      std::string symbols = \"=+-*01()\";\n      Num num = 0;\n      for (auto c : s) {\n        if (std::isalpha(c) and char_idx.count(c) == 0) {\n          int x = char_idx.size();\n          char_idx[c] = x;\n        }\n      }\n      if (char_idx.size() > 8) return 0;\n      s_ = s;\n      std::sort(symbols.begin(), symbols.end());\n      do {\n        for (std::size_t i = 0; i < s_.size(); ++i) {\n          s_[i] = (isalpha(s[i])? symbols[char_idx[s[i]]]: s[i]);\n        }\n        if (eval_q()) ++num;\n        std::reverse(symbols.begin() + char_idx.size(), symbols.end());\n      } while (std::next_permutation(symbols.begin(), symbols.end()));\n      return num;\n    }\n  private:\n    std::string s_;\n    bool eval_q() {\n      // std::cerr << \"TRY: \" << s_ << std::endl;\n      try {\n        std::size_t i = 0;\n        Num left, right;\n        left = eval_e(i);\n        if (s_[i] != '=') throw std::runtime_error(\"left\");\n        ++i;\n        right = eval_e(i);\n        if (i < s_.size()) throw std::runtime_error(\"right\");\n        std::cerr << left << (left == right? \" == \": \" != \") << right << std::endl;\n        return left == right;\n      } catch (std::runtime_error &e) {\n        // std::cerr << \"FAIL: \" << e.what() << std::endl;\n        return false;\n      }\n    }\n    Num eval_e(std::size_t &i) {\n      Num n = eval_t(i);\n      while (i < s_.size()) {\n        if (s_[i] == '+') {\n          ++i;\n          n += eval_t(i);\n        } else if (s_[i] == '-') {\n          ++i;\n          n -= eval_t(i);\n        } else {\n          break;\n        }\n      }\n      return n;\n    }\n    Num eval_t(std::size_t &i) {\n      Num n = eval_f(i);\n      while (s_[i] == '*') {\n        ++i;\n        n *= eval_f(i);\n      }\n      return n;\n    }\n    Num eval_f(std::size_t &i) {\n      Num n;\n      if (s_[i] == '-') {\n        ++i;\n        n = -eval_f(i);\n      } else if (s_[i] == '(') {\n        ++i;\n        n = eval_e(i);\n        if (s_[i] != ')') throw std::runtime_error(\")\");\n        ++i;\n      } else {\n        n = eval_n(i);\n      }\n      return n;\n    }\n    Num eval_n(std::size_t &i) {\n      if (s_[i] == '0' or s_[i] == '1') {\n        Num n = s_[i] - '0';\n        ++i;\n        if (n == 0 and (s_[i] == '0' or s_[i] == '1')) throw std::runtime_error(\"leading zero\");\n        while (true) {\n          if (s_[i] == '0' or s_[i] == '1') {\n            n = 2 * n + s_[i] - '0';\n            ++i;\n          } else {\n            break;\n          }\n        }\n        return n;\n      } else {\n        throw std::runtime_error(\"N\");\n      }\n    }\n};\n\nint main() {\n  Solver s;\n  std::cin >> s.s;\n  std::cout << s.solve() << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Parser {\n\tusing itr = string::const_iterator;\n\titr now;\n\tint ans;\n\t// E ::= {T{+|-}}+T  T|E+T|E−T\n\t// T ::= {F*}+F F|T*F\n\t// F ::= N|{-}+F|(E)\n\t// N ::= 0|1B\n\t// B ::= {0|1}* ϵ|0B|1B\n\tParser(const string &s) {\n\t\tnow = s.begin();\n\t\tans = E(now);\n\t\tif(*now != '\\0') {\n\t\t\tthrow \"INVALID\";\n\t\t}\n\t}\n\tint E(itr &now) {\n\t\t// cerr << \"E\" << endl;\n\t\t// E ::= {T{+|-}}+T  T|E+T|E−T\n\t\tint ret = T(now);\n\t\twhile(*now != '\\0') {\n\t\t\tif(*now == '+') {\n\t\t\t\tnext(now, '+');\n\t\t\t\tret += T(now);\n\t\t\t} else if(*now == '-') {\n\t\t\t\tnext(now, '-');\n\t\t\t\tret -= T(now);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint T(itr &now) {\n\t\t// cerr << \"T\" << endl;\n\t\t// T ::= {F*}+F F|T*F\n\t\tint ret = F(now);\n\t\twhile(*now != '\\0') {\n\t\t\tif(*now == '*') {\n\t\t\t\tnext(now, '*');\n\t\t\t\tret *= T(now);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint F(itr &now) {\n\t\t// cerr << \"F\" << endl;\n\t\t// F ::= N|{-}+F|(E)\n\t\tif(*now == '-') {\n\t\t\tnext(now, '-');\n\t\t\treturn -F(now);\n\t\t} else if(*now == '(') {\n\t\t\tnext(now, '(');\n\t\t\tint ret = E(now);\n\t\t\tnext(now, ')');\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn N(now);\n\t\t}\n\t}\n\tint N(itr &now) {\n\t\t// cerr << \"N\" << endl;\n\t\t// N ::= 0|1B\n\t\tif(*now == '0') {\n\t\t\tnext(now, '0');\n\t\t\treturn 0;\n\t\t} else if(*now == '1') {\n\t\t\treturn B(now);\n\t\t} else {\n\t\t\tthrow \"INVALID\";\n\t\t}\n\t}\n\tint B(itr &now) {\n\t\t// cerr << \"B\" << endl;\n\t\t// B ::= {0|1}* ϵ|0B|1B\n\t\tint ret = 0;\n\t\twhile(*now != '\\0') {\n\t\t\tif(*now == '0' or *now == '1') {\n\t\t\t\tret <<= 1;\n\t\t\t\tret += (*now) - '0';\n\t\t\t\tnext(now, {'0', '1'});\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid next(itr &now, const char expected) {\n\t\tvector<char> req = {expected};\n\t\tnext(now, req);\n\t}\n\tvoid next(itr &now, const vector<char> &expected) {\n\t\tfor(char c: expected){\n\t\t\tif(*now == c){\n\t\t\t\tnow++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow \"INVALID\";\n\t\t// デバッグ用\n\t\tfprintf(stderr, \"Expected: \");\n\t\tfor(char c: expected) fprintf(stderr, \"%c\", c);\n\t\tfprintf(stderr, \"\\nGot: %c\\n\", *now);\n\t\tfprintf(stderr, \"Rest: \");\n\t\twhile(*now) fprintf(stderr, \"%c\", *now++);\n\t}\n};\n\nint main() {\n\tvector<char> ex = {'0', '1', '+', '-', '*', '(', ')', '='};\n\tstring s; cin >> s;\n\tmap<char, char> mp;\n\tfor(char c : s) {\n\t\tbool flg = true;\n\t\tfor(char cc : ex) {\n\t\t\tif(c == cc) flg = false;\n\t\t}\n\t\tif(flg) mp[c] = '?';\n\t}\n\tif(mp.size() > 8) {\n\t\tcout << 0 << '\\n';\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tsort(ex.begin(), ex.end());\n\t// reverse(ex.begin(), ex.end());\n\tdo {\n\t\tint idx = 0;\n\t\tfor(auto &e : mp) {\n\t\t\te.second = ex[idx];\n\t\t\t++idx;\n\t\t}\n\t\tstring str[2];\n\t\tint nxt = 0;\n\t\tbool valid = true;\n\t\tfor(char c : s) {\n\t\t\tif(nxt == 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(mp.count(c)) {\n\t\t\t\tif(mp[c] == '=') {\n\t\t\t\t\t++nxt;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstr[nxt].push_back(mp[c]);\n\t\t\t} else {\n\t\t\t\tif(c == '=') {\n\t\t\t\t\t++nxt;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstr[nxt].push_back(c);\n\t\t\t}\n\t\t}\n\t\tif(nxt == 1 and valid) {\n\t\t\tif(str[0].size() == 0) continue;\n\t\t\tif(str[1].size() == 0) continue;\n\t\t\ttry {\n\t\t\t\t// cerr << str[0] << endl;\n\t\t\t\t// cerr << str[1] << endl;\n\t\t\t\tParser parse0(str[0]);\n\t\t\t\tParser parse1(str[1]);\n\t\t\t\t// cerr << parse0.ans << endl;\n\t\t\t\t// cerr << parse1.ans << endl;\n\t\t\t\tif(parse0.ans == parse1.ans) {\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(...) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t} while(next_permutation(ex.begin(), ex.end()));\n\tint div = 1;\n\tfor(int i = 1; i <= 8 - mp.size(); ++i) {\n\t\tdiv *= i;\n\t}\n\tcout << ans / div << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\n//#define int long long\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nsigned main() {\n\tcin >> s;\n\t\n\tbool used[512] = {false};\n\tint toId[512];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw;\n  if(S[idx] != c) throw;\n  idx ++;\n}\n\nbool try_consume(char c) {\n  try {\n    consume(c);\n  } catch(...) {\n    return false;\n  }\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (...) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren++;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\t//cout << tmp << endl;\n\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\tbool prod = false;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (prod) {\n\t\t\t\tprod = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprod = false;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tprod = false;\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tprod = false;\n\t\t\tparen--;\n\t\t}\n\t\telse if (m[*state] == '*') {\n\t\t\tprod = true;\n\t\t}\n\t\telse {\n\t\t\tprod = false;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\t//cout << lhs << \" \" << rhs << endl;\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\t/*\n\tofstream ofs(\"output.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tstring d = \"1*-1\";\n\tcout << \"xo\"[isE(d, m, d.begin(), d.end())] << endl;\n\t//cout << \"xo\"[isQ(\"1+11*1-11010=(10110)-10\", m)] << endl;\n\tcout << \"xo\"[isQ(\"1+11*1=(11*100-1*110)+-10\", m)] << endl;\n\tcout << \"xo\"[check(\"1+11*1=(11*100-1*110)+-10\", m)] << endl;\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m)) {\n\t\t\t/*\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t\t//*/\n\t\t\tif (check(str, m)) {\n\t\t\t\t//cout << \"=======================\" << endl;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<sstream>\n#include<deque>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdlib>\n#include<climits>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll LLINF = LLONG_MAX;\nconst bool debug = false;\nconst string opr = \"01+-*=()\";\n\nstring context;\nint n;\n\nll parse_E(int&,string&);\n\nll parse_F(int &p,string &s) {\n  if( p >= (int)s.size() ) return LLINF;\n  if( s[p] == '+' ) return LLINF;\n  if( s[p] == '-' ) {\n    ++p;\n    ll v = parse_F(p,s);\n    if( v == LLINF ) return LLINF;\n    return v * -1LL;\n  } \n  if( s[p] == '(' ) {\n    ++p;\n    ll v = parse_E(p,s);\n    if( v == LLINF ) return LLINF;\n    if( p >= (int)s.size() ) return LLINF;\n    if( s[p] != ')' ) return LLINF;\n    ++p;\n    return v;\n  }\n  int cnt = 0;\n  ll v = 0;\n  bool first_zero = ( s[p] == '0' );\n  while( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) {\n    v <<= 1;\n    v += (ll)( s[p] - '0' );\n    ++p;\n    ++cnt;\n  }\n  if( first_zero && cnt != 1 ) return LLINF;\n  if( cnt == 0 ) return LLINF;\n  if( p < (int)s.size() && ( s[p] == '(' || s[p] == ')' ) ) return LLINF;\n  return v;\n}\n\nll parse_T(int &p,string &s) {\n  ll v = parse_F(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && s[p] == '*' ) {\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    v *= tmp;\n  }\n  return v;\n}\n\nll parse_E(int &p,string &s) {\n  ll v = parse_T(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && ( s[p] == '+' || s[p] == '-' ) ) {\n    char op = s[p];\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    if( op == '+' ) v += tmp;\n    if( op == '-' ) v -= tmp;\n  }\n  return v;\n}\n\nbool pari_check(string &s) {\n  int cnt = 0;\n  rep(i,(int)s.size()) {\n    if( s[i] == '(' ) ++cnt;\n    if( s[i] == ')' ) --cnt;\n    if( cnt < 0 ) return false;\n  }\n  return cnt == 0;\n}\n\nbool check() {\n  string s,t;\n  {\n    string tmp;\n    tmp = context;\n    rep(i,n) if( context[i] == '=' ) tmp[i] = ' ';\n    vector<string> vec;\n    stringstream ss;\n    ss << tmp;\n    while( ss >> s ) vec.push_back(s);\n    if( vec.size() != 2 ) return false;\n    s = vec[0];\n    t = vec[1];\n  }\n  if( !pari_check(s) || !pari_check(t) ) return false;\n  int p = 0;\n  ll sv = parse_E(p,s);\n  p = 0;\n  ll tv = parse_E(p,t);\n  if( sv == LLINF || tv == LLINF) return false;\n  return sv == tv;\n}\n\nint dfs(int ptr,int used,vector<char> &already) {\n  if( n <= ptr ) {\n    if( debug ) {\n      if( check() ) {\n\tcout << \"succeeded : \" << context << endl;\n\treturn true;\n      } else {\n\t//cout << \"failed    : \" << context << endl;\n\treturn false;\n      }\n    } else {\n      return check();\n    }\n  }\n  if( !isalpha(context[ptr]) ) return dfs(ptr+1,used,already);\n  int sum = 0;\n  int v = context[ptr] - 'a';\n  if( already[v] != '$' ) {\n    if( already[v] == '=' ) return 0;\n    char tmp = context[ptr];\n    context[ptr] = already[v];\n    sum += dfs(ptr+1,used,already);\n    context[ptr] = tmp;\n    return sum;\n  }\n  rep(i,(int)opr.size()) {\n    if( ( used >> i ) & 1 ) continue;\n    char tmp = context[ptr];\n    context[ptr] = opr[i];\n    already[v] = opr[i];\n    sum += dfs(ptr+1,used|(1<<i),already);\n    already[v] = '$';\n    context[ptr] = tmp;\n  }\n  return sum;\n}\n\nbool normalize() {\n  vector<char> vec;\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) vec.push_back(context[i]);\n  sort(all(vec));\n  vec.erase(unique(all(vec)),vec.end());\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) {\n    int pos = lower_bound(all(vec),context[i]) - vec.begin();\n    context[i] = (char)('a'+pos);\n  }\n  return (int)vec.size() <= 8;\n}\n\nvoid compute() {\n  if( debug ) cout << \"      context : \" << context << endl;\n  if( !normalize() ) { puts(\"0\"); return; }\n  if( debug ) cout << \"fixed context : \" << context << endl;\n  n = (int)context.size();\n  int used = 0;\n  rep(i,n) if( context[i] == '=' ) { used = (1<<5); break; }\n  vector<char> vec(8,'$');\n  cout << dfs(0,used,vec) << endl;\n}\n\nint main() {\n  cin >> context;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXN 100\n//#define INF 0x3f3f3f3f\ntypedef long long LL;\nconst LL INF = 1e18;\n\nchar s[MAXN], t[MAXN], a[] = \"=()+*-01\";\nint flag, R[MAXN], sta[MAXN];\nint n, cnt[MAXN], ans;\nint b[MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%s\", s);\n    n = strlen(s);\n    for(i = 0; i < n; ++i){\n        if(s[i] >= 'a' && s[i] <= 'z'){\n            if(cnt[s[i] - 'a' + 1] == 0) ++cnt[0];\n            ++cnt[s[i] - 'a' + 1];\n        }\n        else if(s[i] >= 'A' && s[i] <= 'Z'){\n            if(cnt[s[i] - 'A' + 27] == 0) ++cnt[0];\n            ++cnt[s[i] - 'A' + 27];\n        }\n        else if(s[i] == '=') ++flag;\n    }\n}\n\nLL Calc(int l, int r)\n{\n    if(l > r || l >= n) return INF;\n    int i, q[MAXN] = {}, d = 0;\n    LL a = INF;\n    char c, pre = 0;\n    for(i = l; i <= r; ++i){\n        if(s[i] >= 'a' && s[i] <= 'z') c = t[s[i] - 'a' + 1];\n        else if(s[i] >= 'A' && s[i] <= 'Z') c = t[s[i] - 'A' + 27];\n        else c = s[i];\n        if(c == '('){\n            if(pre == '1' || pre == '0') return INF;\n            a = Calc(i + 1, R[i] - 1);\n            if(a == INF) return INF;\n            i = R[i];\n            if(i > r) return INF;\n        }\n        else if(c == '+'){\n            if(a == INF) return INF;\n            if(d == 0){\n                q[++q[0]] = a;\n            }\n            else if(d == 1){\n                q[++q[0]] = -a;\n            }\n            else{\n                q[q[0]] *= a;\n            }\n            a = INF;\n            d = 0;\n        }\n        else if(c == '-'){\n            if(a == INF) d ^= 1;\n            else{\n                if(d == 0){\n                    q[++q[0]] = a;\n                }\n                else if(d == 1){\n                    q[++q[0]] = -a;\n                }\n                else{\n                    q[q[0]] *= a;\n                }\n                a = INF;\n                d = 1;\n            }\n        }\n        else if(c == '*'){\n            if(a == INF) return INF;\n            if(d == 0){\n                q[++q[0]] = a;\n            }\n            else if(d == 1){\n                q[++q[0]] = -a;\n            }\n            else{\n                q[q[0]] *= a;\n            }\n            a = INF;\n            d = 2;\n        }\n        else{\n            if(pre == '(') return INF;\n            if(a == INF) a = c - '0';\n            else{\n                if(a == 0) return INF;\n                a = a * 2 + c - '0';\n            }\n        }\n        pre = c;\n    }\n    if(a == INF) return INF;\n    if(d == 0){\n        q[++q[0]] = a;\n    }\n    else if(d == 1){\n        q[++q[0]] = -a;\n    }\n    else{\n        q[q[0]] *= a;\n    }\n    for(i = 1, a = 0; i <= q[0]; ++i)\n        a += q[i];\n    return a;\n}\n\nvoid Check()\n{\n    int i, j; LL res1, res2;\n    for(i = 0, sta[0] = 0; i < n; ++i){\n        R[i] = -1;\n        if(s[i] >= 'a' && s[i] <= 'z' && t[s[i] - 'a' + 1] == '(')\n            sta[++sta[0]] = i;\n        else if(s[i] >= 'A' && s[i] <= 'Z' && t[s[i] - 'A' + 27] == '(')\n            sta[++sta[0]] = i;\n        else if(s[i] == '(')\n            sta[++sta[0]] = i;\n\n        if(s[i] >= 'a' && s[i] <= 'z' && t[s[i] - 'a' + 1] == ')'){\n            if(!sta[0]) return;\n            R[sta[sta[0]--]] = i;\n        }\n        else if(s[i] >= 'A' && s[i] <= 'Z' && t[s[i] - 'A' + 27] == ')'){\n            if(!sta[0]) return;\n            R[sta[sta[0]--]] = i;\n        }\n        else if(s[i] == ')'){\n            if(!sta[0]) return;\n            R[sta[sta[0]--]] = i;\n        }\n    }\n    if(sta[0]) return;\n\n    for(i = 0; i < n; ++i){\n        if(s[i] >= 'a' && s[i] <= 'z' && t[s[i] - 'a' + 1] == '='){\n            j = i;\n        }\n        else if(s[i] >= 'A' && s[i] <= 'Z' && t[s[i] - 'A' + 27] == '='){\n            j = i;\n        }\n        else if(s[i] == '='){\n            j = i;\n        }\n    }\n\n    res1 = Calc(0, j - 1);\n    res2 = Calc(j + 1, n - 1);\n    if(res1 == INF || res2 == INF) return;\n    if(res1 == res2){\n//        for(i = 1; i <= 52; ++i){\n//            if(t[i] && i <= 26) printf(\"%c %c\\n\", 'a' + i - 1, t[i]);\n//            if(t[i] && i > 26) printf(\"%c %c\\n\", 'A' + i - 27, t[i]);\n//        }\n//        printf(\"\\n\");\n    ++ans;}\n}\n\nvoid DFS(int i)\n{\n    if(cnt[0] > 8 - i) return;\n    if(i >= 8){\n//        for(int j = 0; j < 8; ++j)\n//            printf(\"%d \", b[j]);\n//        printf(\"%d\\n\", cnt[0]);\n        if(cnt[0] == 0)\n            Check();\n        return;\n    }\n    if(i == 0){\n        if(flag) b[i] = 0, DFS(i + 1);\n        else{\n            for(int j = 1; j <= 52; ++j){\n                if(cnt[j] != 1) continue;\n                t[j] = '='; --cnt[0];\n                b[i] = j, DFS(i + 1);\n                t[j] = 0; ++cnt[0];\n            }\n        }\n\n    }\n    else{\n        b[i] = 0, DFS(i + 1);\n        for(int j = 1; j <= 52; ++j){\n            if(!cnt[j] || t[j] != 0) continue;\n            t[j] = a[i]; --cnt[0];\n            b[i] = j, DFS(i + 1);\n            t[j] = 0; ++cnt[0];\n        }\n    }\n}\n\nint main()\n{\n    Init();\n    if(flag > 1 || cnt[0] > 8 - flag){\n        printf(\"0\\n\");\n        return 0;\n    }\n    DFS(0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  while(str[now+1]=='+' || str[now+1]=='-'){\n    if(str[now+1]=='+'){\n      now++;\n      int p = T();\n      if(p==INF) return INF;\n      else t = t+p;\n    }\n    if(str[now+1]=='-'){\n      now++;\n      int p = T();\n      if(p==INF) return INF;\n      else t = t-p;\n    }\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size()>moji.size()){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do { //next_permutation moji\n    string newstr(s);\n\n    auto itr = m.begin();\n    rep(i, m.size()){\n      rep(j, newstr.size()) if(newstr[j]==*itr){\n        newstr[j] = moji[i];\n      }\n      itr++;\n    }\n\n    int idx = newstr.find('=');\n    if(idx>0 && idx<newstr.size()-1){ // not ('=' is not found or at the head of string)\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdexcept>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw exception();\n  if(S[idx] != c) throw exception();\n  idx ++;\n}\n\nbool try_consume(char c) {\n  if(idx >= N) return false;\n  if(S[idx] != c) return false;\n  idx ++;\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (...) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nbool flag;\n\nint B(string &s, int &n){\n\tint ret = 1;\n\twhile(1){\n\t\tif( s.size() <= n ){ break; }\n\t\telse if( s[n] == '0' ){ n++; ret<<=1; }\n\t\telse if( s[n] == '1' ){ n++; ret<<=1; ret += 1; }\n\t\telse { break; }\n\t}\n\t//cout << \"B \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint N(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\telse if( s[n] == '0' ){ n++; return 0; }\n\telse if( s[n] == '1' ){ n++; return B(s, n); }\n\tflag = false;\n\t//cout << \"flag N\" << endl;\n\treturn 0;\n}\n\nint E(string &s, int &n);\nint F(string &s, int &n){\n\tif( s.size() <= n ){ flag = false; return 0; }\n\tint ret;\n\tif( s[n] == '0' || s[n] == '1' ){ ret = N(s, n); }\n\telse if( s[n] == '-' ){ n++; ret = -F(s, n); }\n\telse if( s[n] == '(' ){\n\t\tn++;\n\t\tret = E(s, n);\n\t\tif( s[n] == ')' ) n++;\n\t\telse flag = false;\n\t} else {\n\t\t//cout << \"flag F\" << endl;\n\t\tflag = false;\n\t}\n\t//cout << \"F \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint T(string &s, int &n){\n\tint ret = F(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '*' ){ n++; ret *= T(s, n); }\n\t//cout << \"T \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nint E(string &s, int &n){\n\tint ret = T(s,n);\n\tif( s.size() <= n ){}\n\telse if( s[n] == '+' ){ n++; ret += E(s, n); }\n\telse if( s[n] == '-' ){ n++; ret -= E(s, n); }\n\t//cout << \"E \" << ret << \"  \" << flag << endl;\n\treturn ret;\n}\n\nbool Q(string &s){\n\tflag = true;\n\tint n=0;\n\tint l = E(s,n);\n\tif( s.size() <= n ) return false;\n\t//cout << \"l = \" << l << endl;\n\tif( s[n] != '=' ) return false;\n\t//cout << \"n++\" << endl;\n\tn++;\n\tif( s.size() <= n ) return false;\n\tint r = E(s,n);\n\t//cout << \"r = \" << r << endl;\n\tif( s.size() != n ) flag = false;\n\treturn flag && l == r;\n}\n\nvector<char> ope = {'0', '1', '+', '-', '*', '(', ')', '='};\nint main(){\n\tset<string> ans;\n\tstring S;\n\tcin >> S;\n\t\n\tvector<char> v;\n\tfor(char c: S){\n\t\tif( 'A' <= c && c <= 'Z' ) v.push_back(c);\n\t\tif( 'a' <= c && c <= 'z' ) v.push_back(c);\n\t}\n\tsort(all(v));\n\tv.erase( unique(all(v)), v.end() );\n\tif( v.size() > 8 ){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tsort( all(ope) );\n\tdo{\n\t\tchar mp[256]={};\n\t\trep(i,v.size()) mp[v[i]] = ope[i];\n\t\tstring s;\n\t\tfor(char c: S) s += (mp[c] ? mp[c] : c);\n\t\t//cout << s << endl;\n\t\tif( Q(s) ) ans.insert(s);\n\t}while( next_permutation(all(ope)) );\n\n\t//for(auto p: ans) cout << p << endl;\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n\npair<int, int> n(const string &s, int i) {\n  int nv = 0;\n  if (s[i] == '0') return make_pair(0, i+1);\n  if (!isdigit(s[i])) throw \"invalid\";\n  while (i < s.size() && isdigit(s[i])) {\n    nv *= 2;\n    nv += s[i] - '0';\n    ++i;\n  }\n  return make_pair(nv, i);\n}\n\npair<int, int> e(const string &s, int i);\n\npair<int, int> f(const string &s, int i) {\n  if (i >= s.size()) throw \"invalid\";\n  if (s[i] == '-') {\n    int fv;\n    tie(fv, i) = f(s, i+1);\n    return make_pair(-fv, i);\n  } else if (s[i] == '(') {\n    int ev;\n    tie(ev, i) = e(s, i+1);\n    if (i >= s.size() || s[i] != ')') throw \"invalid\";\n    return make_pair(ev, i+1);\n  }\n  return n(s, i);\n}\n\npair<int, int> t(const string &s, int i) {\n  int fl;\n  tie(fl, i) = f(s, i);\n  while (i < s.size()-1 && s[i] == '*') {\n    int fr;\n    tie(fr, i) = f(s, i+1);\n    fl *= fr;\n  }\n  return make_pair(fl, i);\n}\n\npair<int, int> e(const string &s, int i) {\n  int tl;\n  tie(tl, i) = t(s, i);\n  while (i < s.size()-1 && (s[i] == '+' || s[i] == '-')) {\n    char op = s[i];\n    int tr;\n    tie(tr, i) = t(s, i+1);\n    if (op == '+') {\n      tl += tr;\n    } else {\n      tl -= tr;\n    }\n  }\n  return make_pair(tl, i);\n}\n\nbool valid(const string &s) {\n  int i = 0;\n  int e1, e2;\n  tie(e1, i) = e(s, i);\n  if (i >= s.size() || s[i] != '=') throw \"invalid\";\n  tie(e2, i) = e(s, i+1);\n  if (i != s.size()) throw \"invalid\";\n  return e1 == e2;\n}\n\nint frac(int i) {\n  if (i == 0) return 1;\n  return i * frac(i-1);\n}\n\nint main(){\n  string ch = \"01()+-=*\";\n  sort(ALL(ch));\n  string s;\n  cin>>s;\n  int cnt=0;\n  vector<char> let;\n  for (char c : s) {\n    if (find(ALL(ch), c) == end(ch)) {\n      let.push_back(c);\n    }\n  }\n  sort(ALL(let));\n  let.erase(unique(ALL(let)), end(let));\n  if (let.size() > 8) {\n    cout << 0 << endl;\n    return 0;\n  }\n  map<char, int> idx;\n  REP(i,let.size()) {\n    idx[let[i]] = i;\n  }\n  do {\n    string t = s;\n    for (char &c : t) {\n      if (idx.count(c)) {\n        c = ch[idx[c]];\n      }\n    }\n    try {\n      if (valid(t)) {\n        ++cnt;\n      }\n    } catch(...) {\n    }\n  } while (next_permutation(ALL(ch)));\n  cout << cnt/frac(ch.size() - let.size()) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  if(s[p]==')') flag=1;\n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n\n    return r;\n  }\n  \n  int res=0,min=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    while(s[p]=='-') min++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(min%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(min%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      int r=bnf3();\n\n      res*=r;\n      \n    }else{\n      break;\n    }\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      int r=bnf2();\n\n      res+=r;\n      \n    }\n    \n    else if(s[p]=='-'){\n\n      p++;\n      int r=bnf2();\n\n      res-=r;\n      \n    }else{\n\n      break;\n      \n    }\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n\n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2) ans++;\n    \n  }while(next_permutation(idx,idx+8));\n\n  \n}\n\n\nint main(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<sstream>\n#include<deque>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdlib>\n#include<climits>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll LLINF = LLONG_MAX;\nconst bool debug = false;\nconst string opr = \"01+-*=()\";\n\nstring context;\nint n;\n\nll parse_E(int&,string&);\n\nll parse_F(int &p,string &s) {\n  if( p >= (int)s.size() ) return LLINF;\n  if( s[p] == '+' ) return LLINF;\n  if( s[p] == '-' ) {\n    ++p;\n    ll v = parse_F(p,s);\n    if( v == LLINF ) return LLINF;\n    return v * -1LL;\n  } \n  if( s[p] == '(' ) {\n    ++p;\n    ll v = parse_E(p,s);\n    if( v == LLINF ) return LLINF;\n    if( p >= (int)s.size() ) return LLINF;\n    if( s[p] != ')' ) return LLINF;\n    ++p;\n    return v;\n  }\n  int cnt = 0;\n  ll v = 0;\n  bool first_zero = ( s[p] == '0' );\n  while( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) {\n    v <<= 1;\n    v += (ll)( s[p] - '0' );\n    ++p;\n    ++cnt;\n  }\n  if( first_zero && cnt != 1 ) return LLINF;\n  if( cnt == 0 ) return LLINF;\n  if( p < (int)s.size() && s[p] == '(' ) return LLINF;\n  return v;\n}\n\nll parse_T(int &p,string &s) {\n  ll v = parse_F(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && s[p] == '*' ) {\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    v *= tmp;\n  }\n  return v;\n}\n\nll parse_E(int &p,string &s) {\n  ll v = parse_T(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && ( s[p] == '+' || s[p] == '-' ) ) {\n    char op = s[p];\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    if( op == '+' ) v += tmp;\n    if( op == '-' ) v -= tmp;\n  }\n  return v;\n}\n\nbool pari_check(string &s) {\n  int cnt = 0;\n  rep(i,(int)s.size()) {\n    if( s[i] == '(' ) ++cnt;\n    if( s[i] == ')' ) --cnt;\n    if( cnt < 0 ) return false;\n  }\n  return cnt == 0;\n}\n\nbool check() {\n  string s,t;\n  {\n    string tmp;\n    tmp = context;\n    rep(i,n) if( context[i] == '=' ) tmp[i] = ' ';\n    vector<string> vec;\n    stringstream ss;\n    ss << tmp;\n    while( ss >> s ) vec.push_back(s);\n    if( vec.size() != 2 ) return false;\n    s = vec[0];\n    t = vec[1];\n  }\n  if( !pari_check(s) || !pari_check(t) ) return false;\n  int p = 0;\n  ll sv = parse_E(p,s);\n  p = 0;\n  ll tv = parse_E(p,t);\n  if( sv == LLINF || tv == LLINF) return false;\n  return sv == tv;\n}\n\nint dfs(int ptr,int used,vector<char> &already) {\n  if( n <= ptr ) {\n    if( debug ) {\n      if( check() ) {\n\tcout << \"succeeded : \" << context << endl;\n\treturn true;\n      } else {\n\t//cout << \"failed    : \" << context << endl;\n\treturn false;\n      }\n    } else {\n      return check();\n    }\n  }\n  if( !isalpha(context[ptr]) ) return dfs(ptr+1,used,already);\n  int sum = 0;\n  int v = context[ptr] - 'a';\n  if( already[v] != '$' ) {\n    if( already[v] == '=' ) return 0;\n    char tmp = context[ptr];\n    context[ptr] = already[v];\n    sum += dfs(ptr+1,used,already);\n    context[ptr] = tmp;\n    return sum;\n  }\n  rep(i,(int)opr.size()) {\n    if( ( used >> i ) & 1 ) continue;\n    char tmp = context[ptr];\n    context[ptr] = opr[i];\n    already[v] = opr[i];\n    sum += dfs(ptr+1,used|(1<<i),already);\n    already[v] = '$';\n    context[ptr] = tmp;\n  }\n  return sum;\n}\n\nbool normalize() {\n  vector<char> vec;\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) vec.push_back(context[i]);\n  sort(all(vec));\n  vec.erase(unique(all(vec)),vec.end());\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) {\n    int pos = lower_bound(all(vec),context[i]) - vec.begin();\n    context[i] = (char)('a'+pos);\n  }\n  return (int)vec.size() <= 8;\n}\n\nvoid compute() {\n  if( debug ) cout << \"      context : \" << context << endl;\n  if( !normalize() ) { puts(\"0\"); return; }\n  if( debug ) cout << \"fixed context : \" << context << endl;\n  n = (int)context.size();\n  int used = 0;\n  rep(i,n) if( context[i] == '=' ) { used = (1<<5); break; }\n  vector<char> vec(8,'$');\n  cout << dfs(0,used,vec) << endl;\n}\n\nint main() {\n  if( 0 ) {\n    string s;\n    cin >> s;\n    int p = 0;\n    cout << parse_E(p,s) << endl;\n    return 0;\n  }\n  cin >> context;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\n\nstring str;\nbool Q(size_t &i);\nll E(size_t &i);\nll T(size_t &i);\nll F(size_t &i);\nll N(size_t &i);\n\nbool Q(size_t &i){\n\tll lhs = 1, rhs = 0;\n\ttry{\n\t\tlhs = E(i);\n\t\tif(i == str.size() || str[i] != '=')return false;\n\t\trhs = E(++i);\n\t} catch(int){\n\t\treturn false;\n\t}\n//\tcerr << lhs << \" \" << rhs << endl;\n\tif(i < str.size())return false;\n\tif(lhs == rhs)return true;\n\telse return false;\n}\n\nll E(size_t &i){\n\tauto lhs = T(i);\n//\tcerr << lhs << \";\";\n\twhile(i < str.size()){\n\t\tauto ope = str[i];\n\t\tif(ope != '+' && ope != '-')return lhs;\n\t\tauto rhs = T(++i);\n\t\tif(ope == '+')lhs = lhs + rhs;\n\t\telse if(ope == '-')lhs = lhs - rhs;\n\t\telse return lhs;\n\t}\n\treturn lhs;\n}\n\nll T(size_t &i){\n\tll lhs = F(i);\n\twhile(i < str.size() && str[i] == '*'){\n\t\tauto rhs = F(++i);\n\t\tlhs = lhs * rhs;\n\t}\n\treturn lhs;\n}\n\nll F(size_t &i){\n\tif(i >= str.size())throw -1;\n\tif(str[i] == '('){\n\t\tll ret = E(++i);\n\t\tif(i >= str.size() || str[i] != ')')throw -1;\n\t\ti++;\n\t\treturn ret;\n\t}\n\tif(str[i] == '-'){\n\t\tauto ret = F(++i);\n\t\treturn -ret;\n\t}\n\treturn N(i);\n}\n\nll N(size_t &i){\n\tif(str[i] == '0'){i++; return 0;}\n\tif(str[i] != '1')throw -1;\n\tll ret = 1;\n\ti++;\n\tfor(;i < str.size() && isdigit(str[i]);i++){\n\t\tret <<= 1;\n\t\tif(str[i] == '1')ret += 1;\n\t}\n\treturn ret;\n}\n\nbool next_combination(const vector<int>::iterator begin, const vector<int>::iterator end, const int r){\n\tif(r == 0)return false;\n\tauto target = upper_bound(begin, begin+r, *(end-1));\n\tif(target != begin)--target;\n\tif(target == begin && *target >= *(end-1)){\n\t\trotate(begin, begin+r, end);\n\t\treturn false;\n\t}\n//\tcerr << \"hi\";\n\tauto next = upper_bound(begin+r, end, *target);\n\tswap(*target, *next);\n\t++target; ++next;\n\tvector<int> arr;\n\tfor(auto itr = next; itr != end; ++itr)arr.push_back(*itr);\n\tfor(auto itr = target; itr != begin+r; ++itr)arr.push_back(*itr);\n\tsize_t idx = 0;\n\tfor(auto itr = target; itr != end && idx < arr.size(); ++itr){\n\t\tif(itr == begin+r && next != end)itr = next;\n\t\tswap(arr[idx], *itr);\n\t\tidx++;\n\t}\n\treturn true;\n}\n\nsigned main(){\n\tstring raw;\n\tcin >> raw;\n\tmap<char, int> m;\n\tint cnt = 0;\n\tfor(auto e : raw){\n\t\tif(isalpha(e) && m.find(e) == m.end()){\n\t\t\tm[e] = cnt++;\n\t\t}\n\t}\n//\tcerr << cnt << endl;\n\tif(cnt > 8){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<char> c = {'0', '1', '+', '-', '*', '(', ')', '='};\n\tvector<int> idx={0,1,2,3,4,5,6,7};\n\tint ans = 0;\n\tdo{\t\n\t\tdo{\n\t\t\tsize_t i = 0;\n\t\t\tfor(auto &e : raw){\n\t\t\t\tif(m.find(e) != m.end()){\n\t\t\t\t\tstr.push_back(c[idx[m[e]]]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstr.push_back(e);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr << str << endl;\n\t\t\tif(Q(i)){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tstr.resize(0);\n\t\t}while(next_permutation(idx.begin(), idx.begin()+cnt));\n\t}while(cnt != 8  && next_combination(ALL(idx),cnt));\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nbool consume(char c) {\n  if(idx >= N) return false;\n  if(S[idx] != c) return false;\n  idx ++;\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(consume('0')) {\n    return 0;\n  }\n  else if(consume('1')) {\n    return convert(\"1\" + B());\n  }\n  else {\n    return -inf;\n  }\n}\n\nint F() {\n  if(consume('-')) {\n    int r = F();\n    if(r == -inf) return -inf;\n    return -r;\n  }\n  else if(consume('(')) {\n    int r = E();\n    if(r == -inf) return -inf;\n    if(!consume(')')) return -inf;\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  if(num1 == -inf) return -inf;\n  while(consume('*')) {\n    int num2 = F();\n    if(num2 == -inf) return -inf;\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  if(term1 == -inf) return -inf;\n  while(1) {\n    bool cont = 0;\n    while(consume('+')) {\n      cont = 1;\n      int term2 = T();\n      if(term2 == -inf) return -inf;\n      term1 += term2;\n    }\n    while(consume('-')) {\n      cont = 1;\n      int term2 = T();\n      if(term2 == -inf) return -inf;\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  if(idx == N) return curr == 0;\n\n  int expr1 = E();\n  if(expr1 == -inf) return false;\n\n  if(!consume('=')) return false;\n\n  int expr2 = E();\n  if(expr2 == -inf) return false;\n  if(expr1 != expr2) return false;\n\n  return idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  int Tsize = T.size();\n\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    exit(0);\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N)\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      ans += Q();\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\ntypedef std::pair<bool,int> RES;\n\nbool parseQ(State* s);\nRES parseE(State* s);\nRES parseT(State* s);\nRES parseF(State* s);\nRES parseN(State* s);\n\nbool parseQ(State* s) {\n    RES eres1 = parseE(s);\n    if(!eres1.first || s->seek() != '=') return false;\n    s->eat('=');\n    \n    RES eres2 = parseE(s);\n    if(!eres2.first || s->isNotEOF()) return false;\n\n    return eres1.second == eres2.second;\n}\n\n//E ::= T|E+T|E???T\n//E ::= T {(+|-) T}*\nRES parseE(State* s) {\n    RES tres = parseT(s);\n    if(!tres.first) return tres;\n\n    int ans = tres.second;\n    while(s->seek() == '+' || s->seek() == '-') {\n        char op = s->getCh();\n\n        tres = parseT(s);\n        if(!tres.first) return tres;\n\n        ans += (op == '+' ? 1 : -1) * tres.second;\n    }\n    return std::make_pair(true, ans);\n}\n\n//T ::= F|T???F\n//T ::= F ('*' F)*\nRES parseT(State* s) {\n    RES fres = parseF(s);\n    if(!fres.first) return fres;\n\n    int ans = fres.second;\n    while(s->seek() == '*') {\n        s->eat('*');\n        fres = parseF(s);\n        if(!fres.first) return fres;\n\n        ans *= fres.second;\n    }\n    return std::make_pair(true, ans);\n}\n\nRES parseF(State* s) {\n    char c = s->seek();\n    if(c == '0' || c == '1') return parseN(s);\n    if(c == '-') {\n        s->eat('-');\n        auto fres = parseF(s);\n        fres.second *= -1;\n        return fres;\n    }\n    if(c == '(') {\n        s->eat('(');\n        auto eres = parseE(s);\n        if(!eres.first || s->seek() != ')') {\n            return std::make_pair(false, 0);\n        }\n        s->eat(')');\n        return eres;\n    }\n    return std::make_pair(false, 0);\n}\n\nRES parseN(State* s) {\n    if(s->seek() == '0' && (s->seek(1) == '0' || s->seek(1) == '1')) {\n        return std::make_pair(false, 0);\n    }\n\n    int v = 0;\n    while(s->isNotEOF()) {\n        char c = s->seek();\n        if(c != '0' && c != '1') {\n            break;\n        }\n        s->getCh();\n\n        v = (v << 1) + (int)(c - '0');\n    }\n    return std::make_pair(true, v);\n}\n\n\nint main() {\n    std::string input;\n    std::cin >> input;\n    int input_size = input.size();\n\n    VC symbol {{'0', '1', '+', '-', '*', '(', ')', '='}};\n    SORT(symbol);\n\n    std::string chars = input;\n    UNIQUE(chars);\n    int chars_size = chars.size();\n\n    int ans = 0;\n    std::set< std::map<char,char> > pattern;\n    do {\n        std::map<char,char> map;\n        REP(i, chars_size) {\n            map[chars[i]] = symbol[i];\n        }\n        if(pattern.count(map) > 0) continue;\n        pattern.insert(map);\n\n        std::string str = input;\n        REP(i, input_size) {\n            str[i] = map[str[i]];\n        }\n        \n        State state = State{0, input_size, str};\n        if(parseQ(&state)) {\n            std::cout << str << std::endl;\n            ans++;\n        }\n\n    }while(std::next_permutation(ALL(symbol)));\n    \n    std::cout << ans << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdexcept>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw exception();\n  if(S[idx] != c) throw exception();\n  idx ++;\n}\n\nbool try_consume(char c) {\n  try {\n    consume(c);\n  } catch(...) {\n    return false;\n  }\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (...) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nchar codes[] = \"=01()-+*\";\nint l = 0;\n\nint used[8];\nint contain[256];\nint ans = 0, cnt = 0;\nint counter[8];\nchar mpc[8];\n\nmap<int, int> mp;\n\nint ok = 1;\nint cur = 0;\nstring s;\n\nint expr();\n\nchar get(int i) {\n    if(i >= l) return '$';\n    if(contain[(int)s[i]] == -1) return s[i];\n    return mpc[mp[(int) s[i]]];\n}\n\nint number() {\n    int first = 1; char fc, c;\n    int val = 0;\n    c = get(cur);\n    if(c != '0' && c != '1') {\n        ok = 2;\n    }\n\n    while(1) {\n        c = get(cur);\n        if(c != '0' && c != '1') {\n            break;\n        }\n        if(first) fc = c;\n        else if(fc == '0') {\n            ok = 3;\n        }\n        val = 2*val + (c - '0');\n        first = 0;\n        cur ++;\n    }\n    return val;\n}\n\nint factor() {\n    char c = get(cur);\n    if(c == '-') {\n        cur++;\n        return -factor();\n    } else if(c == '(') {\n        cur++; // '('\n        if(get(cur) == ')') {\n            ok = 4;\n        }\n        int val = expr();\n        if(get(cur) != ')') {\n            ok = 5;\n            return val;\n        }\n        cur++; // ')'\n        return val;\n    }\n    return number();\n}\n\nint term() {\n    char c;\n    int res = 1;\n    while(1) {\n        if(get(cur) == '*') ok = 6;\n        res *= factor();\n        c = get(cur);\n        if(c == '*') {\n            cur++; // '*'\n        } else {\n            break;\n        }\n    }\n    return res;\n}\n\nint expr() {\n    int res = 0;\n    char c = 0, op = '+';\n    while(1) {\n        if(get(cur) == '+') {\n            ok = 7;\n        }\n        if(op == '+') {\n            res += term();\n        } else {\n            res -= term();\n        }\n        c = get(cur);\n        if(c == '+' || c == '-') {\n            op = c;\n            cur ++; // \"+\", \"-\"\n        } else {\n            break;\n        }\n    }\n    return res;\n}\n\nvoid check() {\n    //for(int i=0; i<l; ++i) {cout << get(i);}cout << endl;\n    cur = 0; ok = 1;\n    int left = expr();\n    if(get(cur) != '=') {\n        return;\n    }\n    cur++; // '='\n    int right = expr();\n    //cout << \"result \" << left << \" - \" << right << \" cur \" << cur << \" ok \" << ok<< endl;\n    if(cur == l && ok == 1) {\n        if(left == right) {\n            ans++;\n        }\n    }\n}\n\n// index c\nvoid dfs(int c) {\n    if(c == cnt) {\n        check();\n        return;\n    }\n    for(int i=0; i<8; ++i) {\n        if(used[i]) continue;\n        if(i==0) {\n            if(counter[c] == 1) {\n                used[i] = 1;\n                mpc[c] = codes[i];\n                dfs(c+1);\n                used[i] = 0;\n            }\n        } else {\n            used[i] = 1;\n            mpc[c] = codes[i];\n            dfs(c+1);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    cin >> s;\n    l = s.length();\n    for(int i=0; i<8; ++i) {\n        contain[(int) codes[i]] = -1;\n    }\n    for(int i=0; i<l; ++i) {\n        int v = (int) s[i];\n        if(contain[v] == -1) continue;\n        if(contain[v] == 0) {\n            contain[v] = 1;\n            mp[v] = cnt++;\n            counter[mp[v]] = 1;\n        } else {\n            counter[mp[v]] += 1;\n        }\n    }\n    if(cnt > 8) {\n        cout << 0 << endl;\n    } else {\n        dfs(0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[8];\nint used[8];\nint res;\nmap<char,int> mp;\nstring keydata=\"01()+-*=\";\n\n\nint expression(State &begin);\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='-'){\n\t\tbegin++;\n\t\tint ret;\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tint ret=-expression(begin);\n\t\t\tbegin++;\n\t\t}else{\n\t\t\tret=-number(begin);\n\t\t}\n\t\treturn ret;\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint num[101];\n\nbool check(string s){\n\tint cc=0;\n\tmemset(num,0,sizeof(num));\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='-'){\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i==0)continue;\n\t\t\tif((s[i-1]=='+' || s[i-1]=='*'))return false;\n\t\t}\n\t\tif(s[i]=='+' || s[i]=='*'){\n\t\t\tif(i==0 || i+1==s.size())return false;\n\t\t\tif(!(isdigit(s[i-1]) || s[i-1]==')'))return false;\n\t\t}\n\t\tif(s[i]=='('){\n\t\t\tcc++;\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i>=1 && (s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t}\n\t\tif(isdigit(s[i])){\n\t\t\tif(i>=1 && (s[i-1]==')'))return false;\n\t\t\tif(i>=1 && s[i]=='1' && s[i-1]=='0')return false;\n\t\t\tif(i>=1 && s[i]=='0' && s[i-1]=='0')return false;\n\t\t\tnum[cc]++;\n\t\t}\n\t\tif(s[i]==')'){\n\t\t\tif(cc==0)return false;\n\t\t\tif(num[cc]==0)return false;\n\t\t\tif(!(s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t\tnum[cc]=0;\n\t\t\tcc--;\n\t\t}\n\t}\n\tif(cc!=0)return false;\n\treturn true;\n}\n\nstring str;\n\nvoid dfs(int v){\n\tif(v==mp.size()){\n\t\tstring tmp=\"\";\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\t\tint va=mp[str[i]];\n\t\t\t\ttmp+=keydata[data[va-1]];\n\t\t\t}else{\n\t\t\t\ttmp+=str[i];\n\t\t\t}\n\t\t}\n\t\tstring s1=\"\";\n\t\tstring s2=\"\";\n\t\tbool eq=false;\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tif(tmp[i]=='='){\n\t\t\t\tif(eq)return;\n\t\t\t\teq=true;\n\t\t\t}else{\n\t\t\t\tif(!eq)s1+=tmp[i];\n\t\t\t\telse s2+=tmp[i];\n\t\t\t}\n\t\t}\n\t\tif(!check(s1) || s1.size()==0)return;\n\t\tif(!check(s2) || s2.size()==0)return;\n\t\tState s=s1.begin();\n\t\tint val=expression(s);\n\t\ts=s2.begin();\n\t\tint val2=expression(s);\n\t\tif(val==val2){\n\t\t\tres++;\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(used[i]==0){\n\t\t\t\tused[i]=1;\n\t\t\t\tdata[v]=i;\n\t\t\t\tdfs(v+1);\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> str;\n\tfor(int i=0;i<str.size();i++){\n\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\tif(mp.find(str[i])==mp.end()){\n\t\t\t\tmp[str[i]]=mp.size();\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nint main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\t\n\tif (s.length() > 4 && ans >= 5) assert(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[8];\nint used[8];\nint res;\nmap<char,int> mp;\nstring keydata=\"01()+-*=\";\n\n\nint expression(State &begin);\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='-'){\n\t\tint pm=1;\n\t\twhile(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tpm*=-1;\n\t\t}\n\t\tint ret;\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tret=pm*expression(begin);\n\t\t\tbegin++;\n\t\t}else{\n\t\t\tret=pm*number(begin);\n\t\t}\n\t\treturn ret;\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nbool check(string s){\n\tint cc=0;\n\tbool bnum=false;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='-'){\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i==0)continue;\n\t\t}\n\t\tif(s[i]=='+' || s[i]=='*'){\n\t\t\tif(i==0 || i+1==s.size())return false;\n\t\t\tif(!(isdigit(s[i-1]) || s[i-1]==')'))return false;\n\t\t}\n\t\tif(s[i]=='('){\n\t\t\tcc++;\n\t\t\tif(i+1==s.size())return false;\n\t\t\tif(i>=1 && (s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t}\n\t\tif(isdigit(s[i])){\n\t\t\tif(i>=1 && (s[i-1]==')'))return false;\n\t\t\tif(s[i]=='0'){\n\t\t\t\tif(i>=1 && isdigit(s[i-1]))continue;\n\t\t\t\tif(i<s.size() && isdigit(s[i+1]))return false;\n\t\t\t}\n\t\t}\n\t\tif(s[i]==')'){\n\t\t\tif(cc==0)return false;\n\t\t\tif(s[i-1]=='(')return false;\n\t\t\tif(!(s[i-1]==')' || isdigit(s[i-1])))return false;\n\t\t\tcc--;\n\t\t}\n\t}\n\tif(cc!=0)return false;\n\treturn true;\n}\n\nstring str;\n\nvoid dfs(int v){\n\tif(v==mp.size()){\n\t\tstring tmp=\"\";\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\t\tint va=mp[str[i]];\n\t\t\t\ttmp+=keydata[data[va-1]];\n\t\t\t}else{\n\t\t\t\ttmp+=str[i];\n\t\t\t}\n\t\t}\n\t\tstring s1=\"\";\n\t\tstring s2=\"\";\n\t\tbool eq=false;\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tif(tmp[i]=='='){\n\t\t\t\tif(eq)return;\n\t\t\t\teq=true;\n\t\t\t}else{\n\t\t\t\tif(!eq)s1+=tmp[i];\n\t\t\t\telse s2+=tmp[i];\n\t\t\t}\n\t\t}\n\t\tif(!check(s1) || s1.size()==0)return;\n\t\tif(!check(s2) || s2.size()==0)return;\n\t\tState s=s1.begin();\n\t\tint val=expression(s);\n\t\ts=s2.begin();\n\t\tint val2=expression(s);\n\t\tif(val==val2){\n\t\t\tres++;\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(used[i]==0){\n\t\t\t\tused[i]=1;\n\t\t\t\tdata[v]=i;\n\t\t\t\tdfs(v+1);\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> str;\n\tfor(int i=0;i<str.size();i++){\n\t\tif((str[i]>='a' && str[i]<='z') ||(str[i]>='A' && str[i]<='Z')){\n\t\t\tif(mp.find(str[i])==mp.end()){\n\t\t\t\tmp[str[i]]=mp.size();\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdexcept>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstring S;\nint idx;\nint N, M;\nstring alphas;\nint curr;\n\nvoid consume(char c) {\n  if(idx >= N) throw std::logic_error(\"failed consuming\");\n  if(S[idx] != c) throw std::logic_error(\"failed consuming\");\n  idx ++;\n}\n\nbool try_consume(char c) {\n  try {\n    consume(c);\n  } catch(std::logic_error const& e) {\n    return false;\n  }\n  return true;\n}\n\nint E();\n\nint convert(string const& b) {\n  int n = b.size();\n  int ret = 0;\n  for(int i=0; i<n; i++) {\n    ret *= 2;\n    assert(isdigit(b[i]));\n    ret += b[i] - '0';\n  }\n  return ret;\n}\n\nstring B() {\n  string ret;\n  while(1) {\n    if(S[idx] == '0') ret += '0';\n    else if(S[idx] == '1') ret += '1';\n    else break;\n    idx++;\n  }\n  return ret;\n}\n\nint Nu() {\n  if(try_consume('0')) return 0;\n  consume('1');\n  return convert(\"1\" + B());\n}\n\nint F() {\n  if(try_consume('-')) {\n    return -F();\n  }\n  else if(try_consume('(')) {\n    int r = E();\n    consume(')');\n    return r;\n  }\n  else {\n    return Nu();\n  }\n}\n\nint T() {\n  int num1 = F();\n  while(try_consume('*')) {\n    int num2 = F();\n    num1 *= num2;\n  }\n  return num1;\n}\n\nint E() {\n  int term1 = T();\n  while(1) {\n    bool cont = 0;\n    while(try_consume('+')) {\n      cont = 1;\n      int term2 = T();\n      term1 += term2;\n    }\n    while(try_consume('-')) {\n      cont = 1;\n      int term2 = T();\n      term1 -= term2;\n    }\n    if(!cont) break;\n  }\n  return term1;\n}\n\nbool Q() {\n  int expr1 = E();\n  consume('=');\n  int expr2 = E();\n  return expr1 == expr2 && idx == N;\n}\n\nint main() {\n\n  string T = \"01+-*()=\";\n  sort(T.begin(), T.end());\n  string RS; cin >> RS;\n  N = RS.size();\n  for(auto c: RS) if(isalpha(c)) alphas.push_back(c);\n  sort(alphas.begin(), alphas.end());\n  alphas.erase(unique(alphas.begin(), alphas.end()), alphas.end());\n  M = alphas.size();\n\n  if(M > T.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  int ans = 0;\n  set<string> st;\n  do {\n    S = RS;\n    rep(i, N) {\n      if(isalpha(S[i])) S[i] = T[alphas.find(S[i])];\n    }\n    if(!st.count(S)) {\n      st.insert(S);\n      idx = curr = 0;\n      try { ans += Q(); } catch (std::logic_error const& e) {}\n    }\n  } while(next_permutation(T.begin(), T.end()));\n  \n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  if(str[now+1]=='+'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t+p;\n  }\n  if(str[now+1]=='-'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t-p;\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size()>8 || m.size() + mm.size() <2){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do { //next_permutation moji\n    bool flg=true;\n\n    string newstr(s);\n    int idx=0;\n    if(flg){\n      for(auto c : m){\n        // str?????????c???moji[idx]???????????????\n        rep(i, newstr.size()) if(newstr[i]==c){\n          newstr[i] = moji[idx];\n        }\n        idx++;\n      }\n    }\n    idx = newstr.find('=');\n    if(newstr[0]=='=' || idx<0) flg=false;\n\n    if(flg){\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n \nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n \nint bnf();\n \nint bnf3(){\n   \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n   \n  if(s[p]=='('){\n     \n    p++;\n    if(p<s.size()&&(s[p]=='*'||s[p]=='+')) flag=1;\n    if(p<s.size()&&s[p]==')') flag=1;\n     \n    int r=bnf();\n     \n    if(p>=s.size()||s[p]!=')') flag=1;\n     \n    p++;\n     \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    return r;\n  }\n   \n  int res=0,minu=0;\n \n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n   \n  if(s[p]=='-'){\n     \n    while(s[p]=='-') minu++,p++;\n    \n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      p++;\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n     \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n   \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n   \n  if(s[p]=='(') flag=1;\n   \n  if(minu%2) res*=-1;\n   \n  return res;\n}\n \nint bnf2(){\n \n  int res=bnf3();\n \n  while(p<s.size()){\n \n    if(s[p]=='*'){\n       \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf3();\n       \n      res*=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nint bnf(){\n \n  int res=bnf2();\n \n  while(p<s.size()){\n \n    if(s[p]=='+'){\n \n      p++;\n       \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n       \n      int r=bnf2();\n \n      res+=r;\n       \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n \n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n       \n      int r=bnf2();\n \n      res-=r;\n       \n    }else break;\n     \n  }\n \n  return res;\n}\n \nvoid check(){\n   \n  int cnt=0;\n   \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n \n      if(cnt==0){\n    flag=1;\n    return ;\n      }\n      else cnt--;\n    }\n  }\n \n  if(cnt) flag=1;\n}\n \nset<string> me;\n \nvoid solve(){\n   \n  set<char> S;\n   \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n \n  set<char>::iterator ite=S.begin();\n \n  vector<char> al;\n   \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n   \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n   \n  int idx[8];\n \n  for(int i=0;i<8;i++) idx[i]=i;\n   \n  do{\n     \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n \n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n     \n    if(me.count(s)) continue;\n    me.insert(s);\n     \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n     \n    string s1,s2;\n     \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n \n    int f=0;\n \n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n     \n    flag=0;\n    s=s1;\n    p=0;\n\n    int r1=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n     \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    if(p!=s.size()) flag=1;\n    check();\n \n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n     \n  }while(next_permutation(idx,idx+8));\n   \n}\n \n \nmain(){\n \n  cin>>s;\n  str=s;\n   \n  solve();\n \n  cout<<ans<<endl;\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar component_array[8] = {'0','1','+','-','*','(',')','=',};\nint table[40320][8];\nint num_of_type,table_index;\n\nint calc_E(char line[32],int left,int right);\nint calc_T(char line[32],int left,int right);\nint calc_F(char line[32],int left,int right);\nint calc_NUM(char line[32],int left,int right);\n\nbool is_component(char ch){\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(ch == component_array[i])return true;\n\t}\n\n\treturn false;\n}\n\nvoid makeTable(bool used[8],int change_list[8],int index){\n\n\tif(index == num_of_type){ //対応表の作成が完成した場合\n\t\tfor(int i = 0; i < num_of_type; i++){\n\t\t\ttable[table_index][i] = change_list[i];\n\t\t}\n\t\ttable_index++;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(used[i] == false){\n\n\t\t\tbool next_used[8];\n\t\t\tint next_change_list[8];\n\n\t\t\tfor(int k = 0; k < 8; k++)next_used[k] = used[k];\n\t\t\tfor(int k = 0; k < index; k++)next_change_list[k] = change_list[k];\n\n\t\t\tnext_used[i] = true;\n\t\t\tnext_change_list[index] = i;\n\n\t\t\tmakeTable(next_used,next_change_list,index+1);\n\t\t}\n\t}\n}\n\nbool is_OK(char work[32]){\n\n\tint length;\n\tfor(length = 0; work[length] != '\\0'; length++);\n\n\tint equal_count = 0;\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif(work[i] == '=')equal_count++;\n\t}\n\tif(equal_count != 1)return false; //'='の数が1でないなら不可\n\n\tint eq_pos;\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '='){\n\t\t\teq_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(eq_pos == 0 || eq_pos == length-1)return false; //'='の場所が左端、または右端なら不可\n\n\n\t//異種カッコが連続していないか調べる\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(' && work[i+1] == ')')return false;\n\t\tif(work[i] == ')' && work[i+1] == '(')return false;\n\t}\n\n\n\t//カッコの対応が取れているかチェック(左半分)\n\tstack<int> S;\n\tfor(int i = 0; i < eq_pos; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\t//カッコの対応が取れているかチェック(右半分)\n\tfor(int i = eq_pos+1; i < length; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\t//左端を調べる\n\tif(work[0] == '+' || work[0] == '*')return false;\n\tif(work[eq_pos+1] == '+' || work[eq_pos+1] == '*')return false;\n\n\t//数字と開きカッコ、開きカッコと(*or+)が連結していないか調べる\n\tfor(int i = 0; i < length; i++){\n\t\tif((work[i] == '0' || work[i] == '1') && work[i+1] == '(')return false;\n\t\tif((work[i] == '(') && (work[i+1] == '*' || work[i+1] == '+'))return false;\n\t}\n\n\n\t//バイナリが複数桁の場合、1スタートか調べる\n\tfor(int i = 0; work[i] != '\\0';){\n\t\tif(work[i] != '0' && work[i] != '1')i++;\n\t\telse{\n\t\t\tif(work[i] == '1'){\n\t\t\t\twhile(work[i] == '1' || work[i] == '0')i++;\n\t\t\t}else{ //左端の0\n\t\t\t\tif(work[i+1] == '1' || work[i+1] == '0')return false;\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//opの連結を調べる\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif((work[i] == '+' || work[i] == '*') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '='|| work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\n\t\tif((work[i] == '-') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '=' || work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\t}\n\n\n\n\treturn true;\n}\n\nint calc_E(char line[32],int left,int right){\n\n\t/*printf(\"E\\n\");\n\tfor(int i = left; i <= right; i++){\n\t\tprintf(\"%c\",line[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、プラスまたは-を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif((i != left) && (line[i-1] == '0' || line[i-1] == '1' || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の+-がない\n\t\treturn calc_T(line,left,right);\n\t}\n\n\tint tmp = calc_E(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(char line[32],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、*を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の*がない\n\t\treturn calc_F(line,left,right);\n\t}\n\n\tint tmp = calc_T(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\ttmp *= tmp_right;\n\t}\n\treturn tmp;\n}\n\nint calc_F(char line[32],int left,int right){\n\n\tif(line[left] == '1' || line[left] == '0'){\n\t\treturn calc_NUM(line,left,right);\n\t}else if(line[left] == '-'){\n\t\treturn -1*calc_F(line,left+1,right);\n\t}else if(line[left] == '('){\n\n\t\t/*printf(\"Minhi!\\n\");\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tprintf(\"%c\",line[i]);\n\t\t}\n\t\tprintf(\"\\n\");*/\n\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\treturn calc_E(line,left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(char line[32],int left,int right){\n\n\t//left～rightに0か1以外の文字が入っていたら不適\n\tfor(int i = left; i <= right; i++){\n\t\tif(line[i] != '0' && line[i] != '1')return BIG_NUM;\n\t}\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 2*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tchar buf[32];\n\tscanf(\"%s\",buf);\n\n\tint check_table[128];\n\tfor(int i = 0; i < 128; i++)check_table[i] = 0;\n\n\tvector<int> CHAR_LIST,REPLACE_LOC[128];\n\tnum_of_type = 0; //置き換える文字の種類数\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tif(!is_component(buf[i])){ //置き換える必要のある文字である場合\n\n\t\t\tREPLACE_LOC[buf[i]].push_back(i); //buf[i]が何文字目にあるかのリスト\n\n\t\t\tif(check_table[buf[i]] == 0){ //初登場\n\t\t\t\tnum_of_type++;\n\t\t\t\tcheck_table[buf[i]]++;\n\t\t\t\tCHAR_LIST.push_back(buf[i]); //置き換える文字のリストに追加\n\t\t\t}\n\t\t}\n\t}\n\n\tif(num_of_type > 8){ //構成要素は8種類しかないので、9種類以上置き換え文字があったら答えは0\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tchar work[32],left_table[32],right_table[32];\n\tint eq_pos,left_result,right_result,right_length,ans = 0;\n\n\tif(num_of_type == 0){ //置き換えるべき文字が無い場合\n\n\t\tif(!is_OK(buf)){ //入力の文字列が文法的に間違っている場合\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t//左辺と右辺に数式を分解する\n\t\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\t\tif(buf[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = buf[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; buf[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = buf[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\tif(abs(left_result) == BIG_NUM){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\n\t\tif(left_result == right_result){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tbool first_used[8];\n\tfor(int i = 0; i < 8; i++)first_used[i] = false;\n\tint first_change_list[8];\n\ttable_index = 0;\n\tmakeTable(first_used,first_change_list,0); //アルファベットと、文字の変換表を作る\n\n\tfor(int i = 0; i < table_index; i++){\n\n\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\t\t\twork[k] = buf[k];\n\t\t\twork[k+1] = '\\0';\n\t\t}\n\n\t\t//文字を置き換える\n\t\tfor(int k = 0; k < num_of_type; k++){\n\t\t\tint word = CHAR_LIST[k];\n\t\t\tfor(int a = 0; a < REPLACE_LOC[word].size(); a++){\n\t\t\t\tint loc = REPLACE_LOC[word][a];\n\t\t\t\twork[loc] = component_array[table[i][k]];\n\t\t\t}\n\t\t}\n\n\t\t//文法的に適切かどうかざっと確かめる(OKでも不適な場合が多数ある)\n\t\tif(!is_OK(work))continue;\n\n\t\t//左辺と右辺に数式を分解する\n\t\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\t\tif(work[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = work[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; work[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = work[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t/*\tprintf(\"left:%s\\n\",left_table);\n\t\t\t\t\tprintf(\"right:%s\\n\",right_table);*/\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\t//printf(\"left_res:%d\\n\",left_result);\n\t\tif(abs(left_result) == BIG_NUM)continue;\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\t\t//printf(\"right_res:%d\\n\\n\",right_result);\n\t\tif(abs(right_result) == BIG_NUM)continue;\n\n\t\tif(left_result == right_result){\n\t\t\t/*printf(\"left:%s\\n\",left_table);\n\t\t\tprintf(\"right:%s\\n\",right_table);*/\n\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <cstring>\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <map>\n#define FAIL (make_pair(0,0))\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nchar a[] = \"01+-*()=\";\nint pr[500];\nchar s[100];\nchar t[100];\nint n,ans;\nmap<char,char> m;\nbool work(stack<LL> &res,stack<char> & op){\n    if(res.empty())return 0;\n    if(res.top() == '(')return 0;\n    if(op.top() == '#'){\n        res.top() = -res.top();\n        op.pop();\n        return 1;\n    }\n    LL tem = res.top();\n    res.pop();\n    if(res.empty())return 0;\n    if(op.top() == '+'){\n        res.top() += tem;\n    }else if(op.top() == '-'){\n        res.top() -= tem;\n    }else{\n        res.top() *= tem;\n    }\n    op.pop();\n    return 1;\n}\npair<LL, bool>get(int l,int r){\n    if(l >= r)return make_pair(0, 0);\n    if(t[l] == '+' || t[l] == '*' || t[l] == ')')return FAIL;\n    if(t[r - 1] == '+' || t[r - 1] == '*' || t[r - 1] == '(' || t[r - 1] == '-')return FAIL;\n    stack<LL> res;\n    stack<char> op;\n    for(int i = l;i < r; ++i){\n        //cout << l <<\" \"<<i<<endl;\n        if(isdigit(t[i])){\n            LL tem = 0;\n            int st = i;\n            while(i < r && isdigit(t[i])){\n                tem = tem * 2 + t[i] - '0';\n                i++;\n            }\n            if(st + 1 < i && t[st] == '0')return FAIL;\n            res.push(tem);\n            i--;\n            continue;\n        }\n        if(t[i] == '('){\n            op.push('(');\n            if(i > l && (isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            continue;\n        }\n        if(t[i] == ')'){\n            //cout <<l <<endl;\n            if(i < r - 1 && (isdigit(t[i + 1] || t[i + 1] == '(')))return FAIL;\n            while(op.empty() == false && op.top() != '('){\n                bool flag = work(res, op);\n                if(flag == 0)return FAIL;\n            }\n            if(op.empty() == true)return FAIL;\n            op.pop();\n            continue;\n        }\n        while(op.empty() == false && pr[op.top()] >= pr[t[i]]){\n            bool flag = work(res, op);\n            if(flag == 0)return FAIL;\n        }\n        op.push(t[i]);\n    }\n    while(!op.empty()){\n        bool flag = work(res, op);\n        if(flag == 0)return FAIL;\n    }\n    if(res.size() == 1)return make_pair(res.top(),1);\n    return FAIL;\n}\nbool check(){\n    for(int i = 0;i < n; ++i){\n        if(isalpha(s[i])){\n            t[i] = m[s[i]];\n        }else{\n            t[i] = s[i];\n        }\n    }\n    int n = ::n;\n    for(int i = 0;i < n; ++i){\n        if(t[i] != '-')continue;\n        if(i && (t[i - 1] == ')' || isdigit(t[i - 1]))){\n            continue;\n        }\n        t[i] = '#';\n    }\n    for(int i = 1; i < n; ++i){\n        if(t[i - 1] == '#' && t[i] == '#'){\n            for(int j = i + 1; j < n; ++j){\n                t[j - 2] = t[j];\n            }\n            n -= 2;\n            i --;\n        }\n    }\n    if(t[0] == '=' || t[n - 1] == '=')return 0;\n    int equal = 0,pos = -1;\n    for(int i = 0;i < n; ++i){\n        if(t[i] == '='){\n            equal++;\n            pos = i;\n        }\n    }\n    if(equal != 1)return 0;\n    pair<LL,bool> left = get(0,pos);\n    if(left.second == false)return 0;\n    pair<LL,bool> righ = get(pos + 1,n);\n    if(righ.second == false)return 0;\n    return left == righ;\n}\nvoid dfs(int o){\n    if(o == n){\n        ans += check();\n        return;\n    }\n    if(isalpha(s[o])){\n        if(m.find(s[o]) != m.end()){\n            dfs(o + 1);\n        }else{\n            for(int i = 0;i < 8; ++i){\n                if(m.find(a[i]) != m.end())continue;\n                m[s[o]] = a[i];\n                m[a[i]] = s[o];\n                dfs(o + 1);\n                m.erase(s[o]);\n                m.erase(a[i]);\n            }\n        }\n        \n    }else{\n        t[o] = s[o];\n        dfs(o + 1);\n    }\n}\nint main(){\n    pr['('] = -1;\n    pr['*'] = 1;\n    pr['+'] = 0;\n    pr['-'] = 0;\n    pr[')'] = -1;\n    pr['#'] = 3;\n    scanf(\"%s\",s);\n    n = int(strlen(s));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<sstream>\n#include<deque>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdlib>\n#include<climits>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll LLINF = LLONG_MAX;\nconst string opr = \"01+-*=()\";\n\nstring context;\nint n;\n\nll parse_E(int&,string&);\n\nll parse_F(int &p,string &s) {\n  if( p >= (int)s.size() ) throw \"fail\";\n  if( s[p] == '+' ) throw \"fail\";\n  if( s[p] == '-' ) {\n    ++p;\n    ll v;\n    try { v = parse_F(p,s); } catch(...) { throw \"fail\"; }\n    return v * -1LL;\n  } \n  if( s[p] == '(' ) {\n    ++p;\n    ll v;\n    try { v = parse_E(p,s); } catch(...) { throw \"fail\"; }\n    if( p >= (int)s.size() ) throw \"fail\";\n    if( s[p] != ')' ) throw \"fail\";\n    ++p;\n    if( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) throw \"fail\";\n    return v;\n  }\n  int cnt = 0;\n  ll v = 0;\n  bool first_zero = ( s[p] == '0' );\n  while( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) {\n    v <<= 1;\n    v += (ll)( s[p] - '0' );\n    ++p;\n    ++cnt;\n  }\n  if( first_zero && cnt != 1 ) throw \"fail\";\n  if( cnt == 0 ) throw \"fail\";\n  if( p < (int)s.size() && s[p] == '(' ) throw \"fail\";\n  return v;\n}\n\nll parse_T(int &p,string &s) {\n  ll v;\n  try { v = parse_F(p,s); } catch(...) { throw \"fail\"; }\n  while( p < (int)s.size() && s[p] == '*' ) {\n    ++p;\n    ll tmp;\n    try { tmp = parse_T(p,s); } catch(...) { throw \"fail\"; }\n    v *= tmp;\n  }\n  return v;\n}\n\nll parse_E(int &p,string &s) {\n  ll v;\n  try { v = parse_T(p,s); } catch(...) { throw \"fail\"; }\n  while( p < (int)s.size() && ( s[p] == '+' || s[p] == '-' ) ) {\n    char op = s[p];\n    ++p;\n    ll tmp;\n    try { tmp = parse_T(p,s); } catch(...) { throw \"fail\"; }\n    if( op == '+' ) v += tmp;\n    if( op == '-' ) v -= tmp;\n  }\n  return v;\n}\n\nbool pari_check(string &s) {\n  int cnt = 0;\n  rep(i,(int)s.size()) {\n    if( s[i] == '(' ) ++cnt;\n    if( s[i] == ')' ) --cnt;\n    if( cnt < 0 ) return false;\n  }\n  return cnt == 0;\n}\n\nbool check() {\n  string s,t;\n  {\n    string tmp;\n    tmp = context;\n    rep(i,n) if( context[i] == '=' ) tmp[i] = ' ';\n    vector<string> vec;\n    stringstream ss;\n    ss << tmp;\n    while( ss >> s ) vec.push_back(s);\n    if( vec.size() != 2 ) return false;\n    s = vec[0];\n    t = vec[1];\n  }\n  if( !pari_check(s) || !pari_check(t) ) return false;\n  int p = 0;\n  ll sv,tv;\n  try {\n    sv = parse_E(p,s);\n    p = 0;\n    tv = parse_E(p,t);\n  } catch(...) {\n    return false;\n  }\n  if( sv == LLINF || tv == LLINF) return false;\n  return sv == tv;\n}\n\nint dfs(int ptr,int used,vector<char> &already) {\n  if( n <= ptr ) return check();\n  if( !isalpha(context[ptr]) ) return dfs(ptr+1,used,already);\n  int sum = 0;\n  int v = context[ptr] - 'a';\n  if( already[v] != '$' ) {\n    if( already[v] == '=' ) return 0;\n    char tmp = context[ptr];\n    context[ptr] = already[v];\n    sum += dfs(ptr+1,used,already);\n    context[ptr] = tmp;\n    return sum;\n  }\n  rep(i,(int)opr.size()) {\n    if( ( used >> i ) & 1 ) continue;\n    char tmp = context[ptr];\n    context[ptr] = opr[i];\n    already[v] = opr[i];\n    sum += dfs(ptr+1,used|(1<<i),already);\n    already[v] = '$';\n    context[ptr] = tmp;\n  }\n  return sum;\n}\n\nbool normalize() {\n  vector<char> vec;\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) vec.push_back(context[i]);\n  sort(all(vec));\n  vec.erase(unique(all(vec)),vec.end());\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) {\n    int pos = lower_bound(all(vec),context[i]) - vec.begin();\n    context[i] = (char)('a'+pos);\n  }\n  return (int)vec.size() <= 8;\n}\n\nvoid compute() {\n  if( !normalize() ) { puts(\"0\"); return; }\n  n = (int)context.size();\n  int used = 0;\n  rep(i,n) if( context[i] == '=' ) { used = (1<<5); break; }\n  vector<char> vec(8,'$');\n  cout << dfs(0,used,vec) << endl;\n}\n\nint main() {\n  if( 0 ) {\n    string s;\n    cin >> s;\n    int p = 0;\n    cout << parse_E(p,s) << endl;\n    return 0;\n  }\n  cin >> context;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\" = \"<<(x)<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstring str;\nint now;\n\nint E();\nint T();\nint F();\nint N();\n\nint E(){\n  int t = T();\n  if(t==INF) return INF;\n  if(str[now+1]=='+'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t+p;\n  }\n  if(str[now+1]=='-'){\n    now++;\n    int p = E();\n    if(p==INF) return INF;\n    return t-p;\n  }\n  return t;\n}\n\nint T(){\n  int f = F();\n  if(f==INF) return INF;\n\n  if(str[now+1]=='*'){\n    now++;\n    int g = T();\n    if(g==INF) return INF;\n    else return f*g;\n  }\n  return f;\n}\n\nint F(){\n  int n;\n  switch(str[now+1]){\n    case '0':\n    case '1':\n      n=N();\n      if(n==INF) return INF;\n      else return n;\n    case '-':\n      now++;\n      n=F();\n      if(n==INF) return INF;\n      else return -n;\n    case '(':\n      now++;\n      n = E();\n      if(str[now+1]!=')' || n==INF) return INF;\n      now++;\n      return n;\n    default:\n      return INF;\n  }\n}\n\nint N(){\n  if(str[now+1]=='0'){\n    now++;\n    return 0;\n  }\n  if(str[now+1]!='1') return INF;\n  now++;\n  int res=1;\n  while(str[now+1]=='1' || str[now+1]=='0'){\n    now++;\n    res = res*2 + str[now] - '0';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  set<char> m, mm;\n  string moji = \"=+-*()01\";\n  sort(all(moji));\n\n  rep(i,s.size()){\n    bool found=false;\n    rep(j,moji.size()) if(s[i]==moji[j]){\n      mm.insert(s[i]);\n      found=true;\n    }\n    if(!found) m.insert(s[i]);\n  }\n\n  if(m.size() + mm.size()>8 ){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  do {\n    bool flg=true;\n    /*\n    rep(i, m.size()){\n      if(mm.find(moji[i]) != mm.end()){\n        flg = false;\n      }\n    }*/\n\n    string newstr(s);\n    int idx=0;\n    if(flg){\n      for(auto c : m){\n        // str?????????c???moji[idx]???????????????\n        rep(i, newstr.size()) if(newstr[i]==c){\n          newstr[i] = moji[idx];\n        }\n        idx++;\n      }\n    }\n    idx = newstr.find('=');\n    if(newstr[0]=='=' || idx<0) flg=false;\n\n    if(flg){\n      str = newstr.substr(0, idx) + '\\0';\n      now = -1;\n      int l = E();\n\n      if(l!=INF && now==idx-1){\n        str = newstr.substr(idx+1) + '\\0';\n        now = -1;\n        int r= E();\n\n        if(now==str.size()-2 && r==l) ans++;\n      }\n    }\n\n    reverse(moji.begin()+m.size(), moji.end());\n\n  } while(next_permutation(all(moji)));\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n\n    return r;\n  }\n  \n  int res=0,min=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    while(s[p]=='-') min++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(min%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(min%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n\n      res*=r;\n\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;\n      \n    }\n    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n\n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2) ans++;\n    \n  }while(next_permutation(idx,idx+8));\n\n  \n}\n\n\nint main(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,string> P;\nint bnf();\nset<P> used;\nmap<char,int> M;\nstring S;\nint idx,valid;\nchar ch[8]={'0','1','+','-','*','(',')','='};\nint ord[8];\n \nbool check(string a){//??????????????????°???¨???????????????????????¢????\n  int par=0;\n  for(char s:a){\n    par += (s == '(') - (s == ')');\n    if(s == '=') return 0;\n    if(par < 0) return 0;\n  }\n  return par==0;\n}\n \nint getNum(){ //???????????????°????????????\n  int res = 0;\n  if(S[idx] == '0' && isdigit(S[idx+1])) valid  = 0;\n  while(isdigit(S[idx]))res = res*2 + S[idx++]-'0';\n  return res;\n}\n \nint cal(){\n  char ch = S[idx];\n  int res = 0,sign = 1;\n  if(ch=='+'||ch=='*'||ch==')'){ valid = 0;return 0;}\n \n  while(S[idx] == '-') idx++, sign *= -1;\n  ch = S[idx];\n \n  if(isdigit(ch)){\n    res = sign*getNum();\n    if(S[idx] == '*'){idx++; return res * cal();}\n    return res;\n  }\n  else if(ch == '(') {\n    idx++;res = sign*bnf();idx++;\n    return res;\n  }\n \n  valid = 0;\n  return 0;\n}\n \nint bnf(){\n  int res = cal();\n  while(idx<(int)S.size()){\n    if(valid == 0) return -1;\n    char ch = S[idx];\n    if(ch == '('){valid = 0;}\n    else if(ch == '*'){idx++;res *= cal();}\n    else if(ch == '+'){idx++;res += cal();}\n    else if(ch == '-'){idx++;res -= cal();}\n    else if(ch != ')') valid = 0;\n    else break;\n  }\n  if(valid ==0) return -1;\n  return res;\n}\n \nstring mkS(string a){\n  string res;\n  for(char s:a){\n    if(isalpha(s))res += ch[ ord[ M[s] ] ];\n    else res += s;\n  }\n  return res;\n}\n \nint calc(string A,string B){\n  if(A.size()==0 || B.size()==0) return 0;\n  if(used.count(P(A,B)))return 0;\n  used.insert(P(A,B));\n  valid = check(A) && check(B);\n  idx = 0;\n  S = A;\n  int ra = bnf();\n  idx = 0;\n  S = B;\n  int rb = bnf();\n  //if(valid)cout<<A<<\"=\"<<B<<\" \"<<valid<<\" \"<<ra<<\" \"<<rb<<endl;\n  return ra == rb && valid;\n}\n \nint calc(string s){\n  s = mkS(s);\n  for(int i=0;i<(int)s.size();i++)\n    if(s[i]=='=') return calc(s.substr(0,i),s.substr(i+1,s.size()-i-1));\n  return 0;\n}\n \nint dfs(int num,string &s){\n  if(num == 8) return calc(s);\n   \n  int res = 0;\n  for(int i=0;i<8;i++){\n    if(ord[i] != -1)continue;\n    ord[i] = num;\n    res +=dfs(num+1,s);\n    ord[i] = -1;\n  }\n  return res;\n}\n \n \nint main(){\n  string str;\n  cin>>str;\n  if(str.size()<3)cout<<0<<endl,exit(0);\n \n  map<char,int> cnt;\n  for(int i=0;i<(int)str.size();i++)if(isalpha(str[i]))cnt[str[i]]++;\n  if(cnt.size()>8)cout<<0<<endl,exit(0);\n \n  int c = 0;\n  for(pair<char,int> p:cnt)if(isalpha(p.first)) M[p.first] = c++;\n   \n  memset(ord,-1,sizeof(ord));  \n  cout<<dfs(0,str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\nint ans;\nstring s;\n\n\nll exp(State &begin);\n\n\n\nll bin(State &begin){\n\tll ret=0;\n\t\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\n\nll number(State &begin){\n\tif(*begin=='0'){\n\t\tbegin++;\n\t\tif(isdigit(*begin))throw \"number error1\";\n\t\telse return 0;\n\t}\n\telse if(*begin=='1'){\n\t\treturn bin(begin);\n\t}else throw \"number error2\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nll factor(State &begin){\n\tif( isdigit(*begin) )return number(begin);\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\tif(isdigit(*begin)||*begin=='('||*begin=='-') return -1*factor(begin);\n\t\telse throw \"factor error1\";\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tll ret = exp(begin);\n\t\tif(*begin!=')')throw \"factor error2\";\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse throw \"factor error3\";\n\tassert(1);\n\treturn -1;\n}\n\n\nll term(State &begin){\n\tll ret = factor(begin);\n\t\n\tif(*begin=='+'||*begin=='-'||*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}\n\telse if(*begin=='*'){\n\t\tbegin++;\n\t\treturn ret*term(begin);\n\t}\n\telse throw \"term error\";\n\t\n\tassert(1);\n\treturn -1;\n\t\n}\n\n\nll exp(State &begin){\n\tll ret = term(begin);\n\t\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else if(*begin=='$'||*begin==')'){\n\t\t\treturn ret;\n\t\t}else throw \"exp error\";\n\t}\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nbool isValid(string tmp){\n\tint eqc=0;\n\trep(i,tmp.size())if(tmp[i]=='=')eqc++;\n\tif(eqc!=1)return false;\n\t\n\tstring str[2]={};\n\tbool f=false;\n\trep(i,tmp.size()){\n\t\tif(tmp[i]=='=')f=true;\n\t\telse if(f)str[1]+=tmp[i];\n\t\telse str[0]+=tmp[i];\n\t}\n\tif(str[0].size()==0||str[1].size()==0)return false;\n\t\n\tState b[2];\n\tll res[2];\n\ttry{\n\t\trep(i,2){\n\t\t\tstr[i] +='$';\n\t\t\tb[i] = str[i].begin();\n\t\t\tres[i] = exp(b[i]);\n\t\t}\n\t}catch(char const* e){\n\t\treturn false;\n\t}\n\tif(res[0]==res[1] && *b[0]=='$'&&*b[1]=='$'){\n\t\treturn true;\n\t}else return false;\n}\n\nvoid dfs(string tmp,vector<bool> used){\n\tchar alp='!';\n\tint pos=-1;\n\trep(i,tmp.size()){\n\t\tif(isalpha(tmp[i]))alp=tmp[i],pos=i;\n\t}\n\tif(pos==-1){ if(isValid(tmp))ans++; return; }\n\t\n\tassert(alp!='!');\n\tstring symbols = \"01+-*()=\";\n\trep(i,symbols.size()){\n\t\tif(used[i])continue;\n\t\tused[i]=true;\n\t\tstring ntmp = tmp;\n\t\trep(j,ntmp.size()){\n\t\t\tif(ntmp[j]==alp) ntmp[j] = symbols[i];\n\t\t}\n\t\tdfs(ntmp,used);\n\t\tused[i]=false;\n\t}\n}\n\n\nint main(){\n\tcin>>s;\n\tset<char> st;\n\tvector<char> vs;\n\t\n\trep(i,s.size())st.insert(s[i]);\n\tfor(auto &e:st)vs.pb(e);\n\t\n\tint count=0;\n\trep(i,vs.size())if(isalpha(vs[i]))count++;\n\tif(count>8){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tans=0;\n\tvector<bool> used(8,false);\n\tdfs(s,used);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstring s,str;\nint p,ans,flag;\nchar c[8]={'0','1','+','-','*','(',')','='};\nchar memo[400];\n\nbool isalph(char ch){\n  return (('a'<=ch&&ch<='z')||('A'<=ch&&ch<='Z'));  \n}\n\nint bnf();\n\nint bnf3(){\n  \n  if(s[p]==')') flag=1;\n  if(s[p]=='*'||s[p]=='+') flag=1;\n  \n  if(s[p]=='('){\n    \n    p++;\n    if(s[p]==')') flag=1;\n    \n    int r=bnf();\n    \n    if(p>=s.size()||s[p]!=')') flag=1;\n    \n    p++;\n    \n    if(p<s.size()&&s[p]=='(') flag=1;\n    if(p<s.size()&&'0'<=s[p]&&s[p]<='1') flag=1;\n    \n    \n    return r;\n  }\n  \n  int res=0,minu=0;\n\n  if(s[p]=='0'&&p+1<s.size()&&(s[p+1]=='0'||s[p+1]=='1')) flag=1;\n  \n  if(s[p]=='-'){\n    \n    while(s[p]=='-') minu++,p++;\n    if(s[p]=='('){\n      p++;\n      int r=bnf();\n      if(minu%2) r*=-1;\n      return r;\n    }\n    else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n    \n  }else if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0',p++;\n  \n  if(s[p]=='(') flag=1;\n  \n  if(minu%2) res*=-1;\n  \n  return res;\n}\n\nint bnf2(){\n\n  int res=bnf3();\n\n  while(p<s.size()){\n\n    if(s[p]=='*'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf3();\n      \n      res*=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n\n  while(p<s.size()){\n\n    if(s[p]=='+'){\n\n      p++;\n      \n      if(s[p]==')'||s[p]=='+'||s[p]=='*') flag=1;\n      \n      int r=bnf2();\n\n      res+=r;\n      \n    }    \n    else if(s[p]=='-'){\n      \n      p++;\n\n      if(s[p]==')'||s[p]=='*'||s[p]=='+') flag=1;\n      \n      int r=bnf2();\n\n      res-=r;\n      \n    }else break;\n    \n  }\n\n  return res;\n}\n\nvoid check(){\n  \n  int cnt=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')'){\n\n      if(cnt==0){\n\tflag=1;\n\treturn ;\n      }\n      else cnt--;\n    }\n  }\n\n  if(cnt) flag=1;\n}\n\nset<string> me;\n\nvoid solve(){\n  \n  set<char> S;\n  \n  for(int i=0;i<s.size();i++)\n    if(isalph(s[i])) S.insert(s[i]);\n\n  set<char>::iterator ite=S.begin();\n\n  vector<char> al;\n  \n  while(ite!=S.end()){\n    al.push_back((*ite));\n    ite++;\n  }\n  \n  if(al.size()>8){\n    cout<<0<<endl;\n    return ;\n  }\n  \n  int idx[8];\n\n  for(int i=0;i<8;i++) idx[i]=i;\n  \n  do{\n    \n    for(int i=0;i<al.size();i++)\n      memo[al[i]]=c[idx[i]];\n\n    s=\"\";\n    for(int i=0;i<str.size();i++){\n      if(S.count(str[i])) s+=memo[str[i]];\n      else s+=str[i];\n    }\n    \n    if(me.count(s)) continue;\n    me.insert(s);\n    \n    int cnt=0;\n    for(int i=0;i<s.size();i++)\n      if(s[i]=='=') cnt++;\n    if(cnt!=1) continue;\n    \n    string s1,s2;\n    \n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=') break;\n      s1+=s[i];\n    }\n\n    int f=0;\n\n    for(int i=0;i<s.size();i++){\n      if(f) s2+=s[i];\n      if(s[i]=='=')f=1;\n    }\n    \n    flag=0;\n    s=s1;\n    p=0;\n    \n    int r1=bnf();\n    check();\n    \n    s=s2;\n    p=0;\n    \n    int r2=bnf();\n    check();\n\n    if(!flag&&s1.size()&&s2.size()&&r1==r2){\n      // cout<<s1<<' '<<s2<<endl;\n      ans++;\n    }\n    \n  }while(next_permutation(idx,idx+8));\n  \n}\n\n\nmain(){\n\n  cin>>s;\n  str=s;\n  \n  solve();\n\n  cout<<ans<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint len,p;\nstring S;\nbool flag;\n \nint compute();\n \nint getNum(){\n  if(p>=len){\n    flag=true;\n    return 0;\n  }\n   \n  if(S[p]=='-'){\n    p++;\n    return -getNum();\n  }else if(S[p]=='0'){\n    p++;\n    return 0;\n  }else if(S[p]=='1'){\n    int res=0;\n    while(p<len && (S[p]=='0'||S[p]=='1') ){\n      res*=2;\n      res+=(S[p]-'0');\n      p++;\n    }\n    return res;\n  }else if(S[p]=='('){\n    p++;\n    int res=compute();\n    if(S[p-1]!=')')flag=true;\n    return res;\n  }else{\n    flag=true;\n    return 0;\n  }\n}\n \nint compute(){\n  if(p>=len){\n    flag=true;\n    return 0;\n  }\n   \n  stack<int> st;\n  st.push( getNum() );\n   \n  while(p<len){\n    char ch=S[p];p++;\n    if(ch==')')break;\n \n    int num=getNum();\n    if(ch=='+'){\n      st.push(num);\n    }else if(ch=='-'){\n      st.push(-num);\n    }else if(ch=='*'){\n      int x=st.top();\n      st.pop();\n      st.push(x*num);\n    }else{\n      flag=true;\n      break;\n    }\n  }\n  int res=0;\n  while(st.size()>0){\n    res+=st.top();\n    st.pop();\n  }\n  return res;\n}\n \nint check(string str){\n \n  string le,ri;\n   \n  int cnt=0,index;\n  for(int i=0;i<(int)str.size();i++)\n    if(str[i]=='=')cnt++, index=i;\n \n   \n  if(cnt!=1)return 0;\n  if(index==0 || index+1==(int)str.size())return 0;\n \n   \n  flag=false;\n  S=str.substr(0,index);\n  p=0;\n  len=S.size();\n  le=S;\n  int lv=compute();\n  int ca=0,cb=0;\n   \n  for(int i=0;i<S.size();i++)\n    if(S[i]=='(')ca++;\n    else if(S[i]==')')cb++;\n  if( ca!=cb || flag || p<len)return 0;\n   \n  flag=false;\n  S=str.substr(index+1);\n  ri=S;\n  p=0;\n  len=S.size();\n  int rv=compute();\n  ca=0,cb=0;\n  for(int i=0;i<S.size();i++)\n    if(S[i]=='(')ca++;\n    else if(S[i]==')')cb++;\n  if( ca!=cb || flag || p<len)return 0;\n \n   \n  if(lv==rv){\n    //    cout<<le<<' '<<ri<<endl;\n    return 1;\n  }else return 0;\n}\n \n \nint solve(string str){\n \n  string tmp=\"01+-*()=\";\n  sort(tmp.begin(),tmp.end());\n   \n  map<string,bool> used;\n  int res=0;\n  do{\n    map<char,char> mp;\n    string s=str;\n    for(int i=0;i<(int)s.size();i++){\n      if( ('A'<=s[i]&&s[i]<='Z') || ('a'<=s[i]&&s[i]<='z') ){\n        if(mp.count( s[i] )>0){\n          s[i]=mp[ s[i] ];\n        }else{\n          int id=mp.size();\n          mp[ s[i] ]=tmp[id];\n          s[i]=tmp[id];\n        }\n      }\n    }\n    if(!used[s]){\n      used[s]=true;\n      res+=check(s);\n    }\n  }while(next_permutation(tmp.begin(),tmp.end()));\n    return res;\n}\n \nint main(){\n  string str;\n  cin>>str;\n  cout<<solve(str)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool isB(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return true;\n\tif (m[*state] == '0' || m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nbool isN(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '0') {\n\t\tstate++;\n\t\tif (state == end)return true;\n\t\telse return false;\n\t}\n\telse if (m[*state] == '1') {\n\t\tstate++;\n\t\treturn isB(str, m, state, end);\n\t}\n\telse return false;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end);\n\nbool isF(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn isF(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tif (isE(str, m, state, end)) {\n\t\t\tstate++;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstate++;\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn isN(str, m, state, end);\n\t}\n}\n\nbool isT(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isF(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isF(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isE(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint paren = 0;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+' || m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (!isT(str, m, tmp, state)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (!isT(str, m, tmp, state)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool isQ(string str, map<char, char> &m) {\n\tint index = -1;\n\trep(i, str.size()) {\n\t\tif (m[str[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (index == -1)return false;\n\n\t// ??????????????§??????\n\tint num = 0;\n\trep(i, index) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\trepl(i, index + 1, str.size()) {\n\t\tif (m[str[i]] == '(')num++;\n\t\telse if (m[str[i]] == ')')num--;\n\t\tif (num < 0)return false;\n\t}\n\tif (num != 0)return false;\n\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tState state = tmp.begin();\n\tif (!isE(tmp, m, state, state + index))return false;\n\tstate++;\n\tif (!isE(tmp, m, state, tmp.end()))return false;\n\treturn true;\n}\n\nint N(string &str, map<char, char> &m, State &state, State end) {\n\tint val = 0;\n\twhile (state != end) {\n\t\tval <<= 1;\n\t\tif (m[*state] == '1') {\n\t\t\tval += 1;\n\t\t}\n\t\tstate++;\n\t}\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end);\n\nint F(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tif (m[*state] == '-') {\n\t\tstate++;\n\t\treturn -F(str, m, state, end);\n\t}\n\telse if (m[*state] == '(') {\n\t\tstate++;\n\t\tif (state == end)return false;\n\t\tend--;\n\t\tint val = E(str, m, state, end);\n\t\tstate++;\n\t\treturn val;\n\t}\n\telse {\n\t\treturn N(str, m, state, end);\n\t}\n}\n\nint T(string &str, map<char, char> &m, State &state, State end) {\n\tif (state == end)return false;\n\tState tmp = state;\n\tint val = 1;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '*') {\n\t\t\tif (paren > 0)continue;\n\t\t\tval *= F(str, m, tmp, state);\n\t\t\ttmp = state + 1;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tval *= F(str, m, tmp, state);\n\treturn val;\n}\n\nint E(string &str, map<char, char> &m, State &state, State end) {\n\tState tmp = state;\n\tint val = 0;\n\tbool plus = true;\n\tint paren = 0;\n\tif (m[*state] == '(')paren = 1;\n\n\twhile (++state != end) {\n\t\tif (m[*state] == '+') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = true;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '-') {\n\t\t\tif (paren > 0)continue;\n\t\t\tif (plus) {\n\t\t\t\tval += T(str, m, tmp, state);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval -= T(str, m, tmp, state);\n\t\t\t}\n\t\t\tplus = false;\n\t\t\ttmp = state + 1;\n\t\t\t//state++;\n\t\t}\n\t\telse if (m[*state] == '(') {\n\t\t\tparen++;\n\t\t}\n\t\telse if (m[*state] == ')') {\n\t\t\tparen--;\n\t\t}\n\t}\n\tif (plus) {\n\t\tval += T(str, m, tmp, state);\n\t}\n\telse {\n\t\tval -= T(str, m, tmp, state);\n\t}\n\treturn val;\n}\n\nbool check(string str, map<char, char> &m) {\n\t// --,+-???????????????\n\tstring tmp = \"\";\n\tvc charr(str.size());\n\trep(i, str.size()) {\n\t\tcharr[i] = str[i];\n\t}\n\trep(i, charr.size() - 1) {\n\t\tif (m[charr[i]] == '-'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '+';\n\t\t}\n\t\telse if (m[charr[i]] == '+'&&m[charr[i + 1]] == '-') {\n\t\t\tcharr[i + 1] = '-';\n\t\t}\n\t\telse {\n\t\t\ttmp += charr[i];\n\t\t}\n\t}\n\ttmp += charr[charr.size() - 1];\n\n\tint index = -1;\n\trep(i, tmp.size()) {\n\t\tif (m[tmp[i]] == '=') {\n\t\t\tif (index != -1)return false;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tint lhs = 0, rhs = 0;\n\tState state = tmp.begin();\n\tlhs = E(tmp, m, state, state + index);\n\tstate++;\n\trhs = E(tmp, m, state, tmp.end());\n\n\treturn lhs == rhs;\n}\n\nint main(void) {\n\tstring str;\n\tcin >> str;\n\n\tvc ch;\n\tset<char> st;\n\tfor (char c : str) {\n\t\tif (c == '0' || c == '1' || c == '+' || c == '-' || c == '*' || c == '(' || c == ')' || c == '=')continue;\n\t\tif (st.find(c) == st.end()) {\n\t\t\tst.insert(c);\n\t\t\tch.push_back(c);\n\t\t}\n\t}\n\tif (ch.size() > 8) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tchar simbol[] = { '0','1','+','-','*','(',')','=' };\n\n\tvi perm(8);\n\trep(i, 8)perm[i] = i;\n\tmap<char, char>m;\n\tm['0'] = '0';\n\tm['1'] = '1';\n\tm['+'] = '+';\n\tm['-'] = '-';\n\tm['*'] = '*';\n\tm['('] = '(';\n\tm[')'] = ')';\n\tm['='] = '=';\n\t/*\n\tstring dum1 = \"1+1\";\n\tcout << \"xo\"[isE(dum1, m,dum1.begin(),dum1.end())] << endl;\n\tcout << \"xo\"[isQ(\"1=1+1\", m)] << endl;\n\tcout << \"xo\"[isQ(\"10+100*11=1010--1*10+10\", m)] << endl;\n\tcout << \"xo\"[check(\"10+100*11=1010--1*10+10\", m)] << endl;\n\tstring lhs = \"10+100*11\", rhs = \"1010--1*10+10\";\n\tcout << E(lhs, m, lhs.begin(), lhs.end()) << endl;\n\tcout << E(rhs, m, rhs.begin(), rhs.end()) << endl;\n\n\n\treturn 0;\n\t//*/\n\tint count = 0;\n\tint ans = 0;\n\tdo {\n\t\trep(i, ch.size()) {\n\t\t\tm[ch[i]] = simbol[perm[i]];\n\t\t}\n\t\tif (isQ(str, m) && check(str, m)) {\n\t\t\tans++;\n\t\t}\n\t\t/*\n\t\tif (count % 720 == 0) {\n\t\t\tfor (char c : str) {\n\t\t\t\tcout << m[c];\n\t\t\t}\n\t\t\tcout << \" : \" << \"xo\"[isQ(str, m) ? 1 : 0] << \" \";\n\t\t\tif (isQ(str, m)) {\n\t\t\t\tcout << \"xo\"[check(str, m) ? 1 : 0] << \" \";\n\t\t\t}\n\t\t\tcout << count << endl;\n\t\t}\n\t\tcount++;\n\t\t//*/\n\t} while (next_permutation(perm.begin(), perm.end()));\n\n\trepl(i, 1, 9 - ch.size()) {\n\t\tans /= i;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define int long long\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\t//cout << res1.second << \" \" << res2.second << endl;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t\treturn P(false, 0);\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nsigned main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar *s;\nbool error;\n\nbool equation();\nint64_t expr();\nint64_t mul();\nint64_t unary();\nint64_t num();\n\nbool consume(char c){\n    if(*s != c) return false;\n    ++s;\n    return true;\n}\n\nbool equation(){\n    error = false;\n    int64_t lhs, rhs;\n    lhs = expr();\n    if(error || !consume('=')) return false;\n    rhs = expr();\n    if(error || *s != '\\0') return false;\n    return lhs == rhs;\n}\n\nint64_t expr(){\n    if(error) return 0;\n    int64_t value = mul();\n    while(*s == '+' || *s == '-'){\n        if(error) return 0;\n        if(consume('+')) value += mul();\n        else if(consume('-')) value -= mul();\n    }\n    return value;\n}\n\nint64_t mul(){\n    if(error) return 0;\n    int64_t value = unary();\n    while(consume('*')){\n        if(error) return 0;\n        value *= unary();\n    }\n    return value;\n}\n\nint64_t unary(){\n    if(error) return 0;\n    int64_t value;\n    if(consume('-')) return -unary();\n    else if(consume('(')){\n        value = expr();\n        if(!consume(')')) error = true;\n        return value;\n    }\n    else return num();\n}\n\nint64_t num(){\n    if(error) return 0;\n    int64_t value = 0;\n    switch(*s){\n    case '0':\n        ++s;\n        return 0;\n    case '1':\n        while(*s == '0' || *s == '1'){\n            value = value * 2 + (*s - '0');\n            ++s;\n        }\n        return value;\n    default:\n        error = true;\n        return 0;\n    }\n}\n\nint main(){\n    char code[32], *ss = new char[32];\n    map<char, int> decl;\n    int cnt = 0;\n    scanf(\"%s\", code);\n    for(int i=0;i < 32 && code[i] != '\\0';++i){\n        if('A' <= code[i] && code[i] <= 'Z' || 'a' <= code[i] && code[i] <= 'z'){\n            if(decl.count(code[i]) == 0) decl[code[i]] = cnt++;\n        }\n    }\n\n    if(cnt > 8){\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    int ptn[] = {0, 1, 2, 3, 4, 5, 6, 7};\n    int64_t ans = 0;\n    \n    do{\n        int i;\n        s = ss;\n        for(i=0;i < 32 && code[i] != '\\0';++i){\n            if(decl.count(code[i])) s[i] = \"01+-*()=\"[ptn[decl[code[i]]]];\n            else s[i] = code[i];\n        }\n        for(;i<32;++i) s[i] = '\\0';\n        if(equation()) ++ans;\n    }while(next_permutation(ptn, ptn + 8));\n\n    int64_t fact[9];\n    fact[0] = 1;\n    for(int i=1;i<=8;++i) fact[i] = i * fact[i-1];\n    printf(\"%\" PRId64 \"\\n\", ans / fact[8-cnt]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <cstring>\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <map>\n#define FAIL (make_pair(0,0))\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nchar a[] = \"01+-*()=\";\nint pr[500];\nchar s[100];\nchar t[100];\nint n,ans;\nmap<char,char> m;\nbool work(stack<LL> &res,stack<char> & op){\n    if(res.empty())return 0;\n    if(res.top() == '(')return 0;\n    if(op.top() == '#'){\n        res.top() = -res.top();\n        op.pop();\n        return 1;\n    }\n    LL tem = res.top();\n    res.pop();\n    if(res.empty())return 0;\n    if(op.top() == '+'){\n        res.top() += tem;\n    }else if(op.top() == '-'){\n        res.top() -= tem;\n    }else{\n        res.top() *= tem;\n    }\n    op.pop();\n    return 1;\n}\npair<LL, bool>get(int l,int r){\n    if(l >= r)return make_pair(0, 0);\n    if(t[l] == '+' || t[l] == '*' || t[l] == ')')return FAIL;\n    if(t[r - 1] == '+' || t[r - 1] == '*' || t[r - 1] == '(' || t[r - 1] == '-')return FAIL;\n    stack<LL> res;\n    stack<char> op;\n    for(int i = l;i < r; ++i){\n        //cout << l <<\" \"<<i<<endl;\n        if(isdigit(t[i])){\n            LL tem = 0;\n            int st = i;\n            while(i < r && isdigit(t[i])){\n                tem = tem * 2 + t[i] - '0';\n                i++;\n            }\n            if(st + 1 < i && t[st] == '0')return FAIL;\n            res.push(tem);\n            i--;\n            continue;\n        }\n        if(t[i] == '('){\n            op.push('(');\n            if(i > l && (isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            continue;\n        }\n        if(t[i] == ')'){\n            //cout <<l <<endl;\n            if(i < r - 1 && (isdigit(t[i + 1] || t[i + 1] == '(')))return FAIL;\n            while(op.empty() == false && op.top() != '('){\n                bool flag = work(res, op);\n                if(flag == 0)return FAIL;\n            }\n            if(op.empty() == true)return FAIL;\n            op.pop();\n            continue;\n        }\n        while(op.empty() == false && pr[op.top()] > pr[t[i]]){\n            bool flag = work(res, op);\n            if(flag == 0)return FAIL;\n        }\n        op.push(t[i]);\n    }\n    while(!op.empty()){\n        bool flag = work(res, op);\n        if(flag == 0)return FAIL;\n    }\n    if(res.size() == 1)return make_pair(res.top(),1);\n    return FAIL;\n}\nbool check(){\n    for(int i = 0;i < n; ++i){\n        if(isalpha(s[i])){\n            t[i] = m[s[i]];\n        }else{\n            t[i] = s[i];\n        }\n    }\n    for(int i = 0;i < n; ++i){\n        if(t[i] != '-')continue;\n        if(i && (t[i - 1] == ')' || isdigit(t[i - 1]))){\n            continue;\n        }\n        t[i] = '#';\n    }\n    if(t[0] == '=' || t[n - 1] == '=')return 0;\n    int equal = 0,pos = -1;\n    for(int i = 0;i < n; ++i){\n        if(t[i] == '='){\n            equal++;\n            pos = i;\n        }\n    }\n    if(equal != 1)return 0;\n    pair<LL,bool> left = get(0,pos);\n    if(left.second == false)return 0;\n    pair<LL,bool> righ = get(pos + 1,n);\n    if(righ.second == false)return 0;\n    return left == righ;\n}\nvoid dfs(int o){\n    if(o == n){\n        ans += check();\n        return;\n    }\n    if(isalpha(s[o])){\n        if(m.find(s[o]) != m.end()){\n            dfs(o + 1);\n        }else{\n            for(int i = 0;i < 8; ++i){\n                if(m.find(a[i]) != m.end())continue;\n                m[s[o]] = a[i];\n                m[a[i]] = s[o];\n                dfs(o + 1);\n                m.erase(s[o]);\n                m.erase(a[i]);\n            }\n        }\n        \n    }else{\n        t[o] = s[o];\n        dfs(o + 1);\n    }\n}\nint main(){\n    pr['('] = -1;\n    pr['*'] = 1;\n    pr['+'] = 0;\n    pr['-'] = 0;\n    pr[')'] = -1;\n    pr['#'] = 3;\n    scanf(\"%s\",s);\n    n = int(strlen(s));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <cstring>\n#include <stack>\n#include <iostream>\n#include <vector>\n#include <map>\n#define FAIL (make_pair(0,0))\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nchar a[] = \"01+-*()=\";\nint pr[500];\nchar s[100];\nchar t[100];\nint n,ans;\nmap<char,char> m;\nbool work(stack<LL> &res,stack<char> & op){\n    if(res.empty())return 0;\n    if(res.top() == '(')return 0;\n    if(op.top() == '#'){\n        res.top() = -res.top();\n        op.pop();\n        return 1;\n    }\n    LL tem = res.top();\n    res.pop();\n    if(res.empty())return 0;\n    if(op.top() == '+'){\n        res.top() += tem;\n    }else if(op.top() == '-'){\n        res.top() -= tem;\n    }else{\n        res.top() *= tem;\n    }\n    op.pop();\n    return 1;\n}\npair<LL, bool>get(int l,int r){\n    if(l >= r)return make_pair(0, 0);\n    if(t[l] == '+' || t[l] == '*' || t[l] == ')')return FAIL;\n    if(t[r - 1] == '+' || t[r - 1] == '*' || t[r - 1] == '(' || t[r - 1] == '-')return FAIL;\n    stack<LL> res;\n    stack<char> op;\n    for(int i = l;i < r; ++i){\n        //cout << l <<\" \"<<i<<endl;\n        if(isdigit(t[i])){\n            LL tem = 0;\n            int st = i;\n            while(i < r && isdigit(t[i])){\n                tem = tem * 2 + t[i] - '0';\n                i++;\n            }\n            if(st + 1 < i && t[st] == '0')return FAIL;\n            res.push(tem);\n            i--;\n            continue;\n        }\n        if(t[i] == '('){\n            op.push('(');\n            if(i > l && (isdigit(t[i - 1]) || t[i - 1] == ')'))return FAIL;\n            continue;\n        }\n        if(t[i] == ')'){\n            //cout <<l <<endl;\n            if(i < r - 1 && (isdigit(t[i + 1] || t[i + 1] == '(')))return FAIL;\n            while(op.empty() == false && op.top() != '('){\n                bool flag = work(res, op);\n                if(flag == 0)return FAIL;\n            }\n            if(op.empty() == true)return FAIL;\n            op.pop();\n            continue;\n        }\n        while(op.empty() == false && pr[op.top()] >= pr[t[i]]){\n            bool flag = work(res, op);\n            if(flag == 0)return FAIL;\n        }\n        op.push(t[i]);\n    }\n    while(!op.empty()){\n        bool flag = work(res, op);\n        if(flag == 0)return FAIL;\n    }\n    if(res.size() == 1)return make_pair(res.top(),1);\n    return FAIL;\n}\nbool check(){\n    for(int i = 0;i < n; ++i){\n        if(isalpha(s[i])){\n            t[i] = m[s[i]];\n        }else{\n            t[i] = s[i];\n        }\n    }\n    for(int i = 0;i < n; ++i){\n        if(t[i] != '-')continue;\n        if(i && (t[i - 1] == ')' || isdigit(t[i - 1]))){\n            continue;\n        }\n        t[i] = '#';\n    }\n    if(t[0] == '=' || t[n - 1] == '=')return 0;\n    int equal = 0,pos = -1;\n    for(int i = 0;i < n; ++i){\n        if(t[i] == '='){\n            equal++;\n            pos = i;\n        }\n    }\n    if(equal != 1)return 0;\n    pair<LL,bool> left = get(0,pos);\n    if(left.second == false)return 0;\n    pair<LL,bool> righ = get(pos + 1,n);\n    if(righ.second == false)return 0;\n    return left == righ;\n}\nvoid dfs(int o){\n    if(o == n){\n        ans += check();\n        return;\n    }\n    if(isalpha(s[o])){\n        if(m.find(s[o]) != m.end()){\n            dfs(o + 1);\n        }else{\n            for(int i = 0;i < 8; ++i){\n                if(m.find(a[i]) != m.end())continue;\n                m[s[o]] = a[i];\n                m[a[i]] = s[o];\n                dfs(o + 1);\n                m.erase(s[o]);\n                m.erase(a[i]);\n            }\n        }\n        \n    }else{\n        t[o] = s[o];\n        dfs(o + 1);\n    }\n}\nint main(){\n    pr['('] = -1;\n    pr['*'] = 1;\n    pr['+'] = 0;\n    pr['-'] = 0;\n    pr[')'] = -1;\n    pr['#'] = 3;\n    scanf(\"%s\",s);\n    n = int(strlen(s));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nstring::iterator p;\nint fact();\nint term();\nint exp();\nint k,d;\nbool f[2];\n\nint fact() {\n  int x;string num;\n  int mi=1;\n  if(*p=='-') {\n    mi=-1;\n    p++;\n  }\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()>1&&num[0]=='0') f[k]=0;\n  if(num.size()) {\n    x=0;\n    for(int i=num.size()-1,j=0; i>=0; i--,j++) x+=(1<<j)*(num[i]=='1');\n  } else {\n    if(*p!='(') f[k]=0;\n    d++;\n    ++p;\n    x=exp();\n    if(*p!=')') f[k]=0;\n    d--;\n    ++p;\n  }\n  return x*mi;\n}\n \nint term() {\n  int x=fact();\n  while(*p=='*') {\n    if(*p=='*') {\n      ++p;\n      x*=fact();\n    }\n  }\n  return x;\n}\n \nint exp() {\n  int x=term();\n  if(p!=s[k].end()&&*p!='+'&&*p!='-'&&*p!=')') f[k]=0;\n  if(*p==')'&&!d) f[k]=0;\n  while(*p=='+'||*p=='-') {\n    if(*p=='+') {\n      ++p;\n      x+=term();\n    } else {\n      ++p;\n      x-=term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  string r=\"01+-*()=\";\n  sort(r.begin(),r.end());\n  string t;\n  cin >> t;\n  map<char,int> m;\n  for(int i=0; i<t.size(); i++) {\n    if(isalpha(t[i])&&!m.count(t[i])) {\n      int x=m.size();\n      m[t[i]]=x;\n    }\n  }\n  if(m.size()>r.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<string> se;\n  do {\n    string e=t;\n    for(int i=0; i<e.size(); i++) {\n      if(isalpha(e[i])) e[i]=r[m[e[i]]];\n    }\n    int c=0;\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') c++;\n    }\n    if(c!=1) continue;\n    c=0;\n    s[0]=s[1]=\"\";\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') {\n        c++;\n        continue;\n      }\n      s[c]+=e[i];\n    }\n    if(!s[0].size()||!s[1].size()) continue;\n    int x[2];\n    for(k=0; k<2; k++) {\n      d=0;\n      f[k]=1;\n      p=s[k].begin();\n      x[k]=exp();\n      if(d) f[k]=0;\n    }\n    if(f[0]&&f[1]&&x[0]==x[1]) se.insert(r.substr(0,m.size()));\n  } while(next_permutation(r.begin(),r.end()));\n  cout << se.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\nint ans;\nstring s;\n\n\nll exp(State &begin);\n\n\n\nll bin(State &begin){\n\tll ret=0;\n\t\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\n\nll number(State &begin){\n\tif(*begin=='0'){\n\t\tbegin++;\n\t\tif(isdigit(*begin))throw \"number error1\";\n\t\telse return 0;\n\t}\n\telse if(*begin=='1'){\n\t\treturn bin(begin);\n\t}else throw \"number error2\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nll factor(State &begin){\n\tif( isdigit(*begin) )return number(begin);\n\telse if(*begin=='-'){\n\t\tint minus=0;\n\t\twhile(*begin=='-'){\n\t\t\tminus++;\n\t\t\tbegin++;\n\t\t}\n\t\tif(isdigit(*begin))return -(minus%2)*number(begin);\n\t\telse if(*begin=='(')return -(minus%2)*exp(begin);\n\t\telse throw \"factor error1\";\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tll ret = exp(begin);\n\t\tif(*begin!=')')throw \"factor error2\";\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse throw \"factor error3\";\n\tassert(1);\n\treturn -1;\n}\n\n\nll term(State &begin){\n\tll ret = factor(begin);\n\t\n\tif(*begin=='+'||*begin=='-'||*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}\n\telse if(*begin=='*'){\n\t\tbegin++;\n\t\treturn ret*term(begin);\n\t}\n\telse throw \"term error\";\n\t\n\tassert(1);\n\treturn -1;\n\t\n}\n\n\nll exp(State &begin){\n\tll ret = term(begin);\n\t\n\tif(*begin=='+'){\n\t\tbegin++;\n\t\treturn ret+exp(begin);\n\t}else if(*begin=='-'){\n\t\tbegin++;\n\t\treturn ret-exp(begin);\n\t}else if(*begin=='$'||*begin==')'){\n\t\treturn ret;\n\t}else throw \"exp error\";\n\t\n\tassert(1);\n\treturn -1;\n}\n\n\nbool isValid(string tmp){\n\tint eqc=0;\n\trep(i,tmp.size())if(tmp[i]=='=')eqc++;\n\tif(eqc!=1)return false;\n\t\n\tstring str[2]={};\n\tbool f=false;\n\trep(i,tmp.size()){\n\t\tif(tmp[i]=='=')f=true;\n\t\telse if(f)str[1]+=tmp[i];\n\t\telse str[0]+=tmp[i];\n\t}\n\tif(str[0].size()==0||str[1].size()==0)return false;\n\t\n\tState b[2];\n\tll res[2];\n\ttry{\n\t\trep(i,2){\n\t\t\tstr[i] +='$';\n\t\t\tb[i] = str[i].begin();\n\t\t\tres[i] = exp(b[i]);\n\t\t}\n\t}catch(char const* e){\n\t\treturn false;\n\t}\n\tif(res[0]==res[1] && *b[0]=='$'&&*b[1]=='$'){\n\t\treturn true;\n\t}else return false;\n}\n\t\n\tvoid dfs(string tmp,vector<bool> used){\n\t\tchar alp='!';\n\t\tint pos=-1;\n\t\trep(i,tmp.size()){\n\t\t\tif(isalpha(tmp[i]))alp=tmp[i],pos=i;\n\t\t}\n\t\tif(pos==-1){ if(isValid(tmp))ans++; return; }\n\t\t\n\t\tassert(alp!='!');\n\t\tstring symbols = \"01+-*()=\";\n\t\trep(i,symbols.size()){\n\t\t\tif(used[i])continue;\n\t\t\tused[i]=true;\n\t\t\tstring ntmp = tmp;\n\t\t\trep(j,ntmp.size()){\n\t\t\t\tif(ntmp[j]==alp) ntmp[j] = symbols[i];\n\t\t\t}\n\t\t\tdfs(ntmp,used);\n\t\t\tused[i]=false;\n\t\t}\n\t}\n\t\n\t\n\tint main(){\n\t\tcin>>s;\n\t\tset<char> st;\n\t\tvector<char> vs;\n\t\t\n\t\trep(i,s.size())st.insert(s[i]);\n\t\tint c=0;\n\t\tfor(auto &e:st)vs.pb(e);\n\t\tif(vs.size()>8){\n\t\t\tcout<<0<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tans=0;\n\t\tvector<bool> used(8,false);\n\t\tdfs(s,used);\n\t\tcout<<ans<<endl;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring t = \"01+-*()\";\n\nint A(string &, int &);\n\nint B(string &, int &);\n\nint C(string &, int &);\n\nint C(string &s, int &idx)\n{\n  int ret = 0;\n  if(isdigit(s[idx])) {\n    if(isdigit(s[idx + 1]) && s[idx] == '0') throw (0);\n    while(isdigit(s[idx])) ret = ret * 2 + s[idx++] - '0';\n  } else if(s[idx] == '(') {\n    ret = A(s, ++idx);\n    if(s[idx++] != ')') throw (0);\n  } else if(s[idx] == '-') ret = -C(s, ++idx);\n  else throw (0);\n  return (ret);\n}\n\nint B(string &s, int &idx)\n{\n  int ret = C(s, idx);\n  while(s[idx] == '*') ret *= C(s, ++idx);\n  return (ret);\n}\n\nint A(string &s, int &idx)\n{\n  int ret = B(s, idx);\n  while(s[idx] == '+' || s[idx] == '-') {\n    if(s[idx] == '+') ret += B(s, ++idx);\n    else ret -= B(s, ++idx);\n  }\n  return (ret);\n}\n\nint main()\n{\n  string S;\n  cin >> S;\n  int ret = 0;\n  for(int i = 1; i < S.size() - 1; i++) {\n    if(isalpha(S[i]) || S[i] == '=') {\n      string L = S.substr(0, i);\n      string R = S.substr(i + 1);\n      if(L.find(S[i]) != string::npos) continue;\n      if(R.find(S[i]) != string::npos) continue;\n\n      map< char, int > cd;\n      for(char &c : L) if(isalpha(c) && !cd.count(c)) cd[c] = cd.size();\n      for(char &c : R) if(isalpha(c) && !cd.count(c)) cd[c] = cd.size();\n      vector< pair< string, string > > data;\n      do {\n        string x = L, y = R;\n        for(char &c : x) if(isalpha(c)) c = t[cd[c]];\n        for(char &c : y) if(isalpha(c)) c = t[cd[c]];\n        data.emplace_back(x + \"`\", y + \"`\");\n      } while(next_permutation(begin(t), end(t)));\n      sort(begin(data), end(data));\n      data.erase(unique(begin(data), end(data)), end(data));\n\n      for(auto &LR: data) {\n        try {\n          int idx;\n          int a = A(LR.first, idx = 0);\n          if(idx + 1 != LR.first.size()) continue;\n          int b = A(LR.second, idx = 0);\n          if(idx + 1 != LR.second.size()) continue;\n          ret += a == b;\n        } catch(int e) {}\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar component_array[8] = {'0','1','+','-','*','(',')','=',};\nint table[40320][8];\nint num_of_type,table_index;\n\nint calc_E(char line[32],int left,int right);\nint calc_T(char line[32],int left,int right);\nint calc_F(char line[32],int left,int right);\nint calc_NUM(char line[32],int left,int right);\n\nbool is_component(char ch){\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(ch == component_array[i])return true;\n\t}\n\n\treturn false;\n}\n\nvoid makeTable(bool used[8],int change_list[8],int index){\n\n\tif(index == num_of_type){\n\t\tfor(int i = 0; i < num_of_type; i++){\n\t\t\ttable[table_index][i] = change_list[i];\n\t\t}\n\t\ttable_index++;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 8; i++){\n\t\tif(used[i] == false){\n\n\t\t\tbool next_used[8];\n\t\t\tint next_change_list[8];\n\n\t\t\tfor(int k = 0; k < 8; k++)next_used[k] = used[k];\n\t\t\tfor(int k = 0; k < index; k++)next_change_list[k] = change_list[k];\n\n\t\t\tnext_used[i] = true;\n\t\t\tnext_change_list[index] = i;\n\n\t\t\tmakeTable(next_used,next_change_list,index+1);\n\t\t}\n\t}\n}\n\nbool is_OK(char work[32]){\n\n\tint length;\n\tfor(length = 0; work[length] != '\\0'; length++);\n\n\tint equal_count = 0;\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif(work[i] == '=')equal_count++;\n\t}\n\tif(equal_count != 1)return false;\n\n\tint eq_pos;\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '='){\n\t\t\teq_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(eq_pos == 0 || eq_pos == length-1)return false;\n\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(' && work[i+1] == ')')return false;\n\t\tif(work[i] == ')' && work[i+1] == '(')return false;\n\t}\n\n\n\tstack<int> S;\n\tfor(int i = 0; i < eq_pos; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\tfor(int i = eq_pos+1; i < length; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\tif(work[0] == '+' || work[0] == '*')return false;\n\tif(work[eq_pos+1] == '+' || work[eq_pos+1] == '*')return false;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif((work[i] == '0' || work[i] == '1') && work[i+1] == '(')return false;\n\t\tif((work[i] == '(') && (work[i+1] == '*' || work[i+1] == '+'))return false;\n\t}\n\n\tfor(int i = 0; work[i] != '\\0';){\n\t\tif(work[i] != '0' && work[i] != '1')i++;\n\t\telse{\n\t\t\tif(work[i] == '1'){\n\t\t\t\twhile(work[i] == '1' || work[i] == '0')i++;\n\t\t\t}else{\n\t\t\t\tif(work[i+1] == '1' || work[i+1] == '0')return false;\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif((work[i] == '+' || work[i] == '*') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '='|| work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\n\t\tif((work[i] == '-') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '=' || work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\t}\n\n\n\n\treturn true;\n}\n\nint calc_E(char line[32],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif((i != left) && (line[i-1] == '0' || line[i-1] == '1' || line[i-1] == ')')){\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\twhile(i <=right && line[i] == '-')i++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_T(line,left,right);\n\t}\n\n\tint tmp = calc_E(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(char line[32],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_F(line,left,right);\n\t}\n\n\tint tmp = calc_T(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\ttmp *= tmp_right;\n\t}\n\treturn tmp;\n}\n\nint calc_F(char line[32],int left,int right){\n\n\tif(line[left] == '1' || line[left] == '0'){\n\t\treturn calc_NUM(line,left,right);\n\t}else if(line[left] == '-'){\n\t\treturn -1*calc_F(line,left+1,right);\n\t}else if(line[left] == '('){\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\treturn calc_E(line,left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(char line[32],int left,int right){\n\n\tfor(int i = left; i <= right; i++){\n\t\tif(line[i] != '0' && line[i] != '1')return BIG_NUM;\n\t}\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 2*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tchar buf[32];\n\tscanf(\"%s\",buf);\n\n\tint check_table[128];\n\tfor(int i = 0; i < 128; i++)check_table[i] = 0;\n\n\tvector<int> CHAR_LIST,REPLACE_LOC[128];\n\tnum_of_type = 0;\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tif(!is_component(buf[i])){\n\n\t\t\tREPLACE_LOC[buf[i]].push_back(i);\n\n\t\t\tif(check_table[buf[i]] == 0){\n\t\t\t\tnum_of_type++;\n\t\t\t\tcheck_table[buf[i]]++;\n\t\t\t\tCHAR_LIST.push_back(buf[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(num_of_type > 8){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tchar work[32],left_table[32],right_table[32];\n\tint eq_pos,left_result,right_result,right_length,ans = 0;\n\n\tif(num_of_type == 0){\n\n\t\tif(!is_OK(buf)){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\t\tif(buf[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = buf[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; buf[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = buf[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\tif(abs(left_result) == BIG_NUM){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\n\t\tif(left_result == right_result){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tbool first_used[8];\n\tfor(int i = 0; i < 8; i++)first_used[i] = false;\n\tint first_change_list[8];\n\ttable_index = 0;\n\tmakeTable(first_used,first_change_list,0);\n\n\tfor(int i = 0; i < table_index; i++){\n\n\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\t\t\twork[k] = buf[k];\n\t\t\twork[k+1] = '\\0';\n\t\t}\n\n\t\tfor(int k = 0; k < num_of_type; k++){\n\t\t\tint word = CHAR_LIST[k];\n\t\t\tfor(int a = 0; a < REPLACE_LOC[word].size(); a++){\n\t\t\t\tint loc = REPLACE_LOC[word][a];\n\t\t\t\twork[loc] = component_array[table[i][k]];\n\t\t\t}\n\t\t}\n\n\t\tif(!is_OK(work))continue;\n\n\t\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\t\tif(work[i] == '='){\n\t\t\t\teq_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft_table[i] = work[i];\n\t\t\tleft_table[i+1] = '\\0';\n\t\t}\n\n\t\tright_length = 0;\n\t\tfor(int i = 0; work[eq_pos+1+i] != '\\0'; i++){\n\t\t\tright_table[i] = work[eq_pos+1+i];\n\t\t\tright_length++;\n\t\t\tright_table[i+1] = '\\0';\n\t\t}\n\n\t\tleft_result = calc_E(left_table,0,eq_pos-1);\n\t\tif(abs(left_result) == BIG_NUM)continue;\n\n\t\tright_result = calc_E(right_table,0,right_length-1);\n\t\tif(abs(right_result) == BIG_NUM)continue;\n\n\t\tif(left_result == right_result){\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define int long long\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nsigned main() {\n\tcin >> s;\n\t\n\tbool used[512] = {false};\n\tint toId[512];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0LL);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    if(S[idx] != ')') throw (0LL);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0LL);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= B(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nsigned main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\npublic:\n\tvoid init(string s) { this->s = s; }\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\t//cout << res1.second << \" \" << res2.second << endl;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t\treturn P(false, 0);\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nsigned main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring temp = \"01+-*()=\";\n\nint A(string&, int&);\n\nint B(string&, int&);\n\nint C(string&, int&);\n\nint C(string& S, int& idx)\n{\n  int ret = 0;\n  if(isdigit(S[idx])) {\n    if(isdigit(S[idx + 1]) && S[idx] == '0') throw (0LL);\n    while(isdigit(S[idx])) ret = ret * 2 + S[idx++] - '0';\n  } else if(S[idx] == '(') {\n    ret = A(S, ++idx);\n    ++idx;\n  } else if(S[idx] == '-') {\n    ret = -C(S, ++idx);\n  } else {\n    throw (0LL);\n  }\n  return (ret);\n}\n\nint B(string& S, int& idx)\n{\n  int ret = C(S, idx);\n  while(S[idx] == '*') {\n    ret *= C(S, ++idx);\n  }\n  return (ret);\n}\n\nint A(string& S, int& idx)\n{\n  int ret = B(S, idx);\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') ret += A(S, ++idx);\n    else ret -= A(S, ++idx);\n  }\n  return (ret);\n}\n\nsigned main()\n{\n  string S;\n  int conv[32];\n  memset(conv, -1, sizeof(conv));\n\n  cin >> S;\n\n  vector< char > num;\n  for(char& c : S) {\n    if(isalpha(c)) num.push_back(c);\n  }\n  sort(begin(num), end(num));\n  num.erase(unique(begin(num), end(num)), end(num));\n  for(int i = 0; i < S.size(); i++) {\n    if(isalpha(S[i])) conv[i] = lower_bound(begin(num), end(num), S[i]) - begin(num);\n  }\n\n  if(num.size() > temp.size()) {\n    cout << 0 << endl;\n    return (0);\n  }\n  sort(begin(temp), end(temp));\n\n  vector< string > ss;\n  do {\n    string T = S;\n    for(int i = 0; i < S.size(); i++) {\n      if(~conv[i]) T[i] = temp[conv[i]];\n    }\n    if(count(begin(T), end(T), '=') == 1 && T.front() != '=' && T.back() != '=') {\n      ss.push_back(T);\n    }\n  } while(next_permutation(begin(temp), end(temp)));\n  sort(begin(ss), end(ss));\n  ss.erase(unique(begin(ss), end(ss)), end(ss));\n\n  int ret = 0;\n  for(string& al : ss) {\n    string L = \"\", R = \"\";\n    bool which = false;\n    for(int i = 0; i < al.size(); i++) {\n      if(al[i] == '=') {\n        which = true;\n        continue;\n      }\n      (which ? R : L) += al[i];\n    }\n    R += \"$\";\n    L += \"$\";\n    int idx;\n\n\n    try {\n      int ll = A(L, idx = 0);\n      if(idx + 1 != L.size()) continue;\n      int rr = A(R, idx = 0);\n      if(idx + 1 != R.size()) continue;\n\n\n      ret += ll == rr;\n    } catch(int e) {}\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define int long long\ntypedef pair<bool, int> P;\n\nstring letters = \"01+-*()=\";\nstring s;\n\nclass Equation {\n\tstring s;\n\npublic:\n\tvoid init(string s) {\n\t\tthis->s = s;\n\t}\n\t\n\t//[l, r)\n\tbool Q(int l, int r) {\n\t\tint i;\n\t\tint cnt = 0;\n\t\tfor (i = l; i < r; i++) cnt += (s[i] == '=');\n\t\tif (cnt != 1) return false;\n\t\tfor (i = l; i < r; i++) {\n\t\t\tif (s[i] == '=') break;\n\t\t}\n\t\tP res1 = E(l ,i); if (!res1.first) return false;\n\t\tP res2 = E(i + 1, r); if (!res2.first) return false;\n\t\t//cout << res1.second << \" \" << res2.second << endl;\n\t\treturn (res1.second == res2.second);\n\t}\n\n\tP E(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (T(l, r).first) return T(l, r);\n\t\tint lv = 0, i;\n\t\tfor (i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\t\tP res1 = E(l, i); if (!res1.first) continue;\n\t\t\t\tP res2 = T(i + 1, r); if (!res2.first) continue;\n\t\t\t\tif (s[i] == '+') return P(true, res1.second + res2.second);\n\t\t\t\treturn P(true, res1.second - res2.second);\n\t\t\t}\n\t\t}\n\t\treturn P(false, 0);\n\t}\n\t\n\tP T(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tint lv = 0, i;\n\t\tfor (int i = r - 1; i >= l; i--) {\n\t\t\tif (s[i] == ')') lv++;\n\t\t\tif (s[i] == '(') lv--;\n\t\t\tif (lv == 0 && s[i] == '*') {\n\t\t\t\tP res1 = T(l, i); if (!res1.first) return P(false, 0);\n\t\t\t\tP res2 = F(i + 1, r); if (!res2.first) return P(false, 0);\n\t\t\t\treturn P(true, res1.second * res2.second);\n\t\t\t}\n\t\t}\n\t\treturn F(l, r);\n\t}\n\t\n\tP F(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tif (s[l] == '(' && s[r - 1] == ')') return E(l + 1, r - 1);\n\t\tif (s[l] == '-') {\n\t\t\tP res = F(l + 1, r);\n\t\t\treturn P(res.first, -res.second);\n\t\t}\n\t\treturn N(l, r);\n\t}\n\t\n\tP N(int l, int r) {\n\t\tif (l >= r) return P(false, 0);\n\t\tfor (int i = l; i < r; i++) if (s[i] != '0' && s[i] != '1') return P(false, 0);\n\t\tif (s[l] == '0') {\n\t\t\tif (r - l == 1) return P(true, 0);\n\t\t\treturn P(false, 0);\n\t\t}\n\t\t\n\t\tint val = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tval *= 2;\n\t\t\tval += s[i] - '0';\n\t\t}\n\t\treturn P(true, val);\n\t}\n};\n\nEquation equation;\n\nsigned main() {\n\tcin >> s;\n\t\n\tbool used[256] = {false};\n\tint toId[256];\n\tint uCnt = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (used[s[i]] == false) {\n\t\t\tused[s[i]] = true;\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 8; j++) if (letters[j] == s[i]) break;\n\t\t\tif (j < 8) { toId[s[i]] = -1; }\t//?????????????????¢\n\t\t\telse { toId[s[i]] = uCnt++; }\n\t\t}\n\t\tif (uCnt > 8) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tset<string> dict;\n\tvector<int> perm;\n\tfor (int i = 0; i < 8; i++) perm.push_back(i);\n\tdo {\n\t\tstring letters2;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tletters2 += letters[perm[i]];\n\t\t}\n\t\t\n\t\tstring ss;\t//??????????????????\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (toId[s[i]] == -1) { ss += s[i]; }\n\t\t\telse { ss += letters2[toId[s[i]]]; }\n\t\t}\n\t\t\n\t\tdict.insert(ss);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tint ans = 0;\n\tfor (set<string>::iterator it = dict.begin(); it != dict.end(); it++) {\n\t\tequation.init((*it));\n\t\tif (equation.Q(0, (*it).length())) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nstring::iterator p;\nint fact();\nint term();\nint exp();\nint k;\nbool f[2];\n\nint fact() {\n  int x;string num;\n  int mi=1;\n  if(*p=='-') {\n    mi=-1;\n    p++;\n  }\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()>1&&num[0]=='0') f[k]=0;\n  if(num.size()) {\n    x=0;\n    for(int i=num.size()-1,j=0; i>=0; i--,j++) x+=(1<<j)*(num[i]=='1');\n  } else if(p!=s[k].end()){\n    if(*p!='('&&*p!='-') f[k]=0;\n    bool ff=*p=='(';\n    if(p!=s[k].end())++p;\n    x=exp();\n    if(ff&&*p!=')') f[k]=0;\n    if(p!=s[k].end())++p;\n  } else f[k]=0;\n  return x*mi;\n}\n \nint term() {\n  int x=fact();\n  while(*p=='*') {\n    if(*p=='*') {\n      ++p;\n      x*=fact();\n    }\n  }\n  return x;\n}\n \nint exp() {\n  int x=term();\n  while(*p=='+'||*p=='-') {\n    if(*p=='+') {\n      ++p;\n      x+=term();\n    } else {\n      ++p;\n      x-=term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  string r=\"01+-*()=\";\n  sort(r.begin(),r.end());\n  string t;\n  cin >> t;\n  map<char,int> m;\n  for(int i=0; i<t.size(); i++) {\n    if(isalpha(t[i])&&!m.count(t[i])) {\n      int x=m.size();\n      m[t[i]]=x;\n    }\n  }\n  if(m.size()>r.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  set<string> se;\n  do {\n    string e=t;\n    for(int i=0; i<e.size(); i++) {\n      if(isalpha(e[i])) e[i]=r[m[e[i]]];\n    }\n    int c=0;\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') c++;\n    }\n    if(c!=1) continue;\n    c=0;\n    s[0]=s[1]=\"\";\n    for(int i=0; i<e.size(); i++) {\n      if(e[i]=='=') {\n        c++;\n        continue;\n      }\n      s[c]+=e[i];\n    }\n    if(!s[0].size()||!s[1].size()) continue;\n    int x[2];\n    for(k=0; k<2; k++) {\n      f[k]=1;\n      p=s[k].begin();\n      x[k]=exp();\n      int d=0;\n      for(int i=0; i<s[k].size(); i++) {\n        if(s[k][i]=='(') {\n          d++;\n          if(i&&(isdigit(s[k][i-1])||s[k][i-1]==')')) f[k]=0;\n          if(i!=s[k].size()-1&&(!isdigit(s[k][i+1])&&s[k][i+1]!='('&&s[k][i+1]!='-')) f[k]=0;\n        }\n        if(s[k][i]==')') {\n          d--;\n          if(i&&(!isdigit(s[k][i-1])&&s[k][i-1]!=')')) f[k]=0;\n          if(i!=s[k].size()-1&&isdigit(s[k][i+1])) f[k]=0;\n        }\n        if(d<0) f[k]=0;\n      }\n      if(d) f[k]=0;\n    }\n    if(f[0]&&f[1]&&x[0]==x[1]) {\n      //if(!se.count(r.substr(0,m.size()))) cerr << s[0] << \" \" << s[1] << \" \" << f[0] << \" \" << f[1] << endl;\n      se.insert(r.substr(0,m.size()));\n    }\n  } while(next_permutation(r.begin(),r.end()));\n  cout << se.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<sstream>\n#include<deque>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdlib>\n#include<climits>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll LLINF = LLONG_MAX;\nconst bool debug = false;\nconst string opr = \"01+-*=()\";\n\nstring context;\nint n;\n\nll parse_E(int&,string&);\n\nll parse_F(int &p,string &s) {\n  if( p >= (int)s.size() ) return LLINF;\n  if( s[p] == '+' ) return LLINF;\n  if( s[p] == '-' ) {\n    ++p;\n    ll v = parse_F(p,s);\n    if( v == LLINF ) return LLINF;\n    return v * -1LL;\n  } \n  if( s[p] == '(' ) {\n    ++p;\n    ll v = parse_E(p,s);\n    if( v == LLINF ) return LLINF;\n    if( p >= (int)s.size() ) return LLINF;\n    if( s[p] != ')' ) return LLINF;\n    ++p;\n    return v;\n  }\n  int cnt = 0;\n  ll v = 0;\n  bool first_zero = ( s[p] == '0' );\n  while( p < (int)s.size() && ( s[p] == '0' || s[p] == '1' ) ) {\n    v <<= 1;\n    v += (ll)( s[p] - '0' );\n    ++p;\n    ++cnt;\n  }\n  if( first_zero && cnt != 1 ) return LLINF;\n  if( cnt == 0 ) return LLINF;\n  return v;\n}\n\nll parse_T(int &p,string &s) {\n  ll v = parse_F(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && s[p] == '*' ) {\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    v *= tmp;\n  }\n  return v;\n}\n\nll parse_E(int &p,string &s) {\n  ll v = parse_T(p,s);\n  if( v == LLINF ) return v;\n  while( p < (int)s.size() && ( s[p] == '+' || s[p] == '-' ) ) {\n    char op = s[p];\n    ++p;\n    ll tmp = parse_T(p,s);\n    if( tmp == LLINF ) return tmp;\n    if( op == '+' ) v += tmp;\n    if( op == '-' ) v -= tmp;\n  }\n  return v;\n}\n\nbool pari_check(string &s) {\n  int cnt = 0;\n  rep(i,(int)s.size()) {\n    if( s[i] == '(' ) ++cnt;\n    if( s[i] == ')' ) --cnt;\n    if( cnt < 0 ) return false;\n  }\n  return cnt == 0;\n}\n\nbool check() {\n  string s,t;\n  {\n    string tmp;\n    tmp = context;\n    rep(i,n) if( context[i] == '=' ) tmp[i] = ' ';\n    vector<string> vec;\n    stringstream ss;\n    ss << tmp;\n    while( ss >> s ) vec.push_back(s);\n    if( vec.size() != 2 ) return false;\n    s = vec[0];\n    t = vec[1];\n  }\n  if( debug ) {\n    //cout << \"s = \" << s << endl;\n    //cout << \"t = \" << t << endl;\n    //puts(\"\");\n  }\n  if( !pari_check(s) || !pari_check(t) ) return false;\n  int p = 0;\n  ll sv = parse_E(p,s);\n  p = 0;\n  ll tv = parse_E(p,t);\n  if( debug ) {\n    cout << \"sv = \" << sv << endl;\n    cout << \"tv = \" << tv << endl;\n    puts(\"\");\n  }\n  if( sv == LLINF || tv == LLINF) return false;\n  return sv == tv;\n}\n\nint dfs(int ptr,int used,vector<char> &already) {\n  if( n <= ptr ) {\n    if( debug ) {\n      if( check() ) {\n\tcout << \"succeeded : \" << context << endl;\n\treturn true;\n      } else {\n\t//cout << \"failed    : \" << context << endl;\n\treturn false;\n      }\n    } else {\n      return check();\n    }\n  }\n  if( !isalpha(context[ptr]) ) return dfs(ptr+1,used,already);\n  int sum = 0;\n  int v = context[ptr] - 'a';\n  if( already[v] != '$' ) {\n    if( already[v] == '=' ) return 0;\n    char tmp = context[ptr];\n    context[ptr] = already[v];\n    sum += dfs(ptr+1,used,already);\n    context[ptr] = tmp;\n    return sum;\n  }\n  rep(i,(int)opr.size()) {\n    if( ( used >> i ) & 1 ) continue;\n    char tmp = context[ptr];\n    context[ptr] = opr[i];\n    already[v] = opr[i];\n    sum += dfs(ptr+1,used|(1<<i),already);\n    already[v] = '$';\n    context[ptr] = tmp;\n  }\n  return sum;\n}\n\nbool normalize() {\n  vector<char> vec;\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) vec.push_back(context[i]);\n  sort(all(vec));\n  vec.erase(unique(all(vec)),vec.end());\n  rep(i,(int)context.size()) if( isalpha(context[i]) ) {\n    int pos = lower_bound(all(vec),context[i]) - vec.begin();\n    context[i] = (char)('a'+pos);\n  }\n  return (int)vec.size() <= 8;\n}\n\nvoid compute() {\n  if( debug ) cout << \"      context : \" << context << endl;\n  if( !normalize() ) { puts(\"0\"); return; }\n  if( debug ) cout << \"fixed context : \" << context << endl;\n  n = (int)context.size();\n  int used = 0;\n  rep(i,n) if( context[i] == '=' ) { used = (1<<5); break; }\n  vector<char> vec(8,'$');\n  cout << dfs(0,used,vec) << endl;\n}\n\nint main() {\n  cin >> context;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1371: Infallibly Crack Perplexing Cryptarithm\n// 2018.1.8 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define INF 0x7fffffff\n\nint sz;\nchar org[35], str[35], *p; int len;\nchar tr[128];\nchar token[9] = \"()01+-*=\"; int tlen = 8;\nchar assign[8];\nchar used[8];\nint ans;\n\nint expr();\n\nint num()\n{\n\tint n = 0;\n\n\tif (*p == '0') { p++; if (*p == '0' || *p == '1') return INF; }\n\telse if (*p == '1') {\n\t\twhile (*p == '0' || *p == '1') n = (n << 1) + (*p++ & 1);\n\t} else n = INF;\n\treturn n;\n}\n\nint factor()\n{\n\tint x;\n\n\tif (*p == '-') {\n\t\tp++;\n\t\tif ((x = factor()) == INF) return INF;\n\t\treturn -x;\n\t}\n\tif (*p == '(') {\n\t\tp++; if ((x = expr()) == INF) return INF;\n\t\tif (*p++ != ')') return INF;\n\t} else x = num();\n\treturn x;\n}\n\nint term()\n{\n\tint x, y;\n\n\tif ((x = factor()) == INF) return INF;\n\twhile (1) {\n\t\tif (*p != '*') break;\n\t\tp++;\n\t\tif ((y = factor()) == INF) return INF;\n\t\tx *= y;\n\t}\n\treturn x;\n}\n\nint expr()\n{\n\tint x, y, op;\n\n\tif ((x = term()) == INF) return INF;\n\twhile (1) {\n\t\tif      (*p == '+') op = 1;\n\t\telse if (*p == '-') op = 0;\n\t\telse break;\n\t\tp++;\n\t\tif ((y = term()) == INF) return INF;\n\t\tif (op) x += y; else x -= y;\n\t}\n\treturn x;\n}\n\nvoid calc()\n{\n\tint par, eq, a, b;\n\tchar *eq_p;\n\n\tstrcpy(str, org);\n\tpar = 0, eq = 0;\n\tfor (p = str; *p; p++) {\n\t\tif (isalpha(*p)) *p = assign[tr[*p]];\n\t\tif (*p == '=') eq = 1, eq_p = p;\n\t\telse if (*p == '(') par++;\n\t\telse if (*p == ')') par--;\n\t}\n\n\tif (!eq || par) return;\n\tif (*str == '=' || *(str+len-1) == '=') return;\n\n//printf(\"str %s\\n\", str);\n\t*eq_p++ = 0;\n\tp = str, a = expr();\n\tif (a == INF || *p != 0) return;\n\tp = eq_p, b = expr();\n\tif (b == INF || *p != 0) return;\n\tif (a == b) ans++;\n//printf(\"a %d, b %d, ans %d\\n\", a, b, ans);\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tif (k == sz) { calc(); return; }\n\tfor (i = 0; i < tlen; i++) {\n\t\tif (used[i]) continue;\n\t\tused[i] = 1;\n\t\tassign[k] = token[i];\n\t\trec(k+1);\n\t\tused[i] = 0;\n\t}\n}\n\nint main()\n{\n\tint eq;\n\n\teq = 0;\n\tmemset(tr, -1, sizeof(tr));\n\tfgets(org, 35, stdin);\n\tfor (p = org; *p > ' '; p++) {\n\t\tif (*p == '=') eq = 1;\n\t\telse if (isalpha(*p)) { if (tr[*p] < 0) tr[*p] = sz++; }\n\t}\n\t*p = 0, len = p-str;\n\n\tif (sz + eq > 8) { puts(\"0\"); return 0; }\n\tif (eq) tlen = 7;\n\trec(0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1371: Infallibly Crack Perplexing Cryptarithm\n// 2018.1.8 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define INF 0x7ffffff\n\nint sz;\nchar org[35], str[35], *p; int len;\nchar tr[128];\nchar token[9] = \"()01+-*=\"; int tlen = 8;\nchar assign[8];\nchar used[8];\nint ans;\n\nint expr();\n\nint num()\n{\n\tint n = 0;\n\n\tif (*p == '0') { p++; if (*p == '0' || *p == '1') return INF; }\n\telse if (*p == '1') {\n\t\twhile (*p == '0' || *p == '1') n = (n << 1) + (*p++ & 1);\n\t} else n = INF;\n\treturn n;\n}\n\nint factor()\n{\n\tint x;\n\n\tif (*p == '-') { p++; return -factor(); }\n\tif (*p == '(') {\n\t\tp++; if ((x = expr()) == INF) return INF;\n\t\tif (*p++ != ')') return INF;\n\t} else x = num();\n\treturn x;\n}\n\nint term()\n{\n\tint x, y;\n\n\tif ((x = factor()) == INF) return INF;\n\twhile (1) {\n\t\tif (*p != '*') break;\n\t\tp++;\n\t\tif ((y = factor()) == INF) return INF;\n\t\tx *= y;\n\t}\n\treturn x;\n}\n\nint expr()\n{\n\tint x, y, op;\n\n\tif ((x = term()) == INF) return INF;\n\twhile (1) {\n\t\tif      (*p == '+') op = 1;\n\t\telse if (*p == '-') op = 0;\n\t\telse break;\n\t\tp++;\n\t\tif ((y = term()) == INF) return INF;\n\t\tif (op) x += y; else x -= y;\n\t}\n\treturn x;\n}\n\nvoid calc()\n{\n\tint par, eq, a, b;\n\tchar *eq_p;\n\n\tstrcpy(str, org);\n\tpar = 0, eq = 0;\n\tfor (p = str; *p; p++) {\n\t\tif (isalpha(*p)) *p = assign[tr[*p]];\n\t\tif (*p == '=') eq = 1, eq_p = p;\n\t\telse if (*p == '(') par++;\n\t\telse if (*p == ')') par--;\n\t}\n\n\tif (!eq || par) return;\n\tif (*str == '=' || *(str+len-1) == '=') return;\n\n\t*eq_p++ = 0;\n\tp = str, a = expr();\n\tif (a == INF || *p != 0) return;\n\tp = eq_p, b = expr();\n\tif (b == INF || *p != 0) return;\n\tif (a == b) ans++;\n\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tif (k == sz) { calc(); return; }\n\tfor (i = 0; i < tlen; i++) {\n\t\tif (used[i]) continue;\n\t\tused[i] = 1;\n\t\tassign[k] = token[i];\n\t\trec(k+1);\n\t\tused[i] = 0;\n\t}\n}\n\nint main()\n{\n\tint eq;\n\n\teq = 0;\n\tmemset(tr, -1, sizeof(tr));\n\tfgets(org, 35, stdin);\n\tfor (p = org; *p > ' '; p++) {\n\t\tif (*p == '=') eq = 1;\n\t\telse if (isalpha(*p)) { if (tr[*p] < 0) tr[*p] = sz++; }\n\t}\n\t*p = 0, len = p-str;\n\n\tif (sz + eq > 8) { puts(\"0\"); return 0; }\n\tif (eq) tlen = 7;\n\trec(0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1371: Infallibly Crack Perplexing Cryptarithm\n// 2018.1.8 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define INF 0x7ffffff\n\nint sz;\nchar org[35], str[35], *p; int len;\nchar tr[128];\nchar token[9] = \"()01+-*=\"; int tlen = 8;\nchar assign[8];\nchar used[8];\nint ans;\n\nint expr();\n\nint num()\n{\n\tint n = 0;\n\n\tif (*p == '0') { p++; if (*p == '0' || *p == '1') return INF; }\n\telse if (*p == '1') {\n\t\twhile (*p == '0' || *p == '1') n = (n << 1) + (*p++ & 1);\n\t} else n = INF;\n\treturn n;\n}\n\nint factor()\n{\n\tint x;\n\n\tif (*p == '-') {\n\t\tp++;\n\t\tif ((x = factor()) == INF) return INF;\n\t\treturn -x;\n\t}\n\tif (*p == '(') {\n\t\tp++; if ((x = expr()) == INF) return INF;\n\t\tif (*p++ != ')') return INF;\n\t} else x = num();\n\treturn x;\n}\n\nint term()\n{\n\tint x, y;\n\n\tif ((x = factor()) == INF) return INF;\n\twhile (1) {\n\t\tif (*p != '*') break;\n\t\tp++;\n\t\tif ((y = factor()) == INF) return INF;\n\t\tx *= y;\n\t}\n\treturn x;\n}\n\nint expr()\n{\n\tint x, y, op;\n\n\tif ((x = term()) == INF) return INF;\n\twhile (1) {\n\t\tif      (*p == '+') op = 1;\n\t\telse if (*p == '-') op = 0;\n\t\telse break;\n\t\tp++;\n\t\tif ((y = term()) == INF) return INF;\n\t\tif (op) x += y; else x -= y;\n\t}\n\treturn x;\n}\n\nvoid calc()\n{\n\tint par, eq, a, b;\n\tchar *eq_p;\n\n\tstrcpy(str, org);\n\tpar = 0, eq = 0;\n\tfor (p = str; *p; p++) {\n\t\tif (isalpha(*p)) *p = assign[tr[*p]];\n\t\tif (*p == '=') eq = 1, eq_p = p;\n\t\telse if (*p == '(') par++;\n\t\telse if (*p == ')') par--;\n\t}\n\n\tif (!eq || par) return;\n\tif (*str == '=' || *(str+len-1) == '=') return;\n\n//printf(\"str %s\\n\", str);\n\t*eq_p++ = 0;\n\tp = str, a = expr();\n\tif (a == INF || *p != 0) return;\n\tp = eq_p, b = expr();\n\tif (b == INF || *p != 0) return;\n\tif (a == b) ans++;\n//printf(\"a %d, b %d, ans %d\\n\", a, b, ans);\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tif (k == sz) { calc(); return; }\n\tfor (i = 0; i < tlen; i++) {\n\t\tif (used[i]) continue;\n\t\tused[i] = 1;\n\t\tassign[k] = token[i];\n\t\trec(k+1);\n\t\tused[i] = 0;\n\t}\n}\n\nint main()\n{\n\tint eq;\n\n\teq = 0;\n\tmemset(tr, -1, sizeof(tr));\n\tfgets(org, 35, stdin);\n\tfor (p = org; *p > ' '; p++) {\n\t\tif (*p == '=') eq = 1;\n\t\telse if (isalpha(*p)) { if (tr[*p] < 0) tr[*p] = sz++; }\n\t}\n\t*p = 0, len = p-str;\n\n\tif (sz + eq > 8) { puts(\"0\"); return 0; }\n\tif (eq) tlen = 7;\n\trec(0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1371: Infallibly Crack Perplexing Cryptarithm\n// 2018.1.8 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define INF 0x7fffffff\n\nint sz;\nchar raw[35], str[35], *p; int len;\nchar tr[128];\nchar token[9] = \"()01+-*=\"; int tlen = 8;\nchar assign[8];\nchar used[8];\nint ans;\n\nint expr();\n\nint factor()\n{\n\tint x, f;\n\n\tf = 0; if (*p == '-') { while (*p == '-') p++, f = !f;\t}\n\tif (*p == '(') {\n\t\tp++; if ((x = expr()) == INF) return INF;\n\t\tif (*p++ != ')') return INF;\n\t} else {\n\t\tx = 0;\n\t\tif (*p == '0') { p++; if (*p == '0' || *p == '1') return INF; }\n\t\telse if (*p == '1') {\n\t\t\twhile (*p == '0' || *p == '1') x = (x << 1) + (*p++ & 1);\n\t\t} else return INF;\n\t}\n\tif (f) x = -x;\n\treturn x;\n}\n\nint term()\n{\n\tint x, y;\n\n\tif ((x = factor()) == INF) return INF;\n\twhile (1) {\n\t\tif (*p != '*') break;\n\t\tp++;\n\t\tif ((y = factor()) == INF) return INF;\n\t\tx *= y;\n\t}\n\treturn x;\n}\n\nint expr()\n{\n\tint x, y, op;\n\n\tif ((x = term()) == INF) return INF;\n\twhile (1) {\n\t\tif      (*p == '+') op = 1;\n\t\telse if (*p == '-') op = 0;\n\t\telse break;\n\t\tp++;\n\t\tif ((y = term()) == INF) return INF;\n\t\tif (op) x += y; else x -= y;\n\t}\n\treturn x;\n}\n\nvoid calc()\n{\n\tint par, eq, a, b;\n\tchar *eq_p;\n\n\tmemcpy(str, raw, len+1);\n\tpar = 0, eq = 0;\n\tfor (p = str; *p; p++) {\n\t\tif (isalpha(*p)) *p = assign[tr[*p]];\n\t\tif (*p == '=') {\n\t\t\teq = 1, eq_p = p;\n\t\t\tif (par) return;\n\t\t}\n\t\telse if (*p == '(') par++;\n\t\telse if (*p == ')') par--;\n\t}\n\tif (!eq || par) return;\n\tif (*str == '=' || *(str+len-1) == '=') return;\n\n\t*eq_p++ = 0;\n\tp = str, a = expr();\n\tif (a == INF || *p != 0) return;\n\tp = eq_p, b = expr();\n\tif (b == INF || *p != 0) return;\n\tif (a == b) ans++;\n}\n\nvoid rec(int k)\n{\n\tint i;\n\n\tif (k == sz) { calc(); return; }\n\tfor (i = 0; i < tlen; i++) {\n\t\tif (used[i]) continue;\n\t\tused[i] = 1;\n\t\tassign[k] = token[i];\n\t\trec(k+1);\n\t\tused[i] = 0;\n\t}\n}\n\nint main()\n{\n\tint eq;\n\n\teq = 0;\n\tmemset(tr, -1, sizeof(tr));\n\tfgets(raw, 35, stdin);\n\tfor (p = raw; *p > ' '; p++) {\n\t\tif (*p == '=') eq = 1;\n\t\telse if (isalpha(*p)) { if (tr[*p] < 0) tr[*p] = sz++; }\n\t}\n\t*p = 0, len = p-raw;\n\n\tif (sz + eq > 8) { puts(\"0\"); return 0; }\n\tif (eq) tlen = 7;\n\trec(0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "// ID:61516672\nimport java.util.*;\nimport java.io.*;\nimport java.text.*;\n//import javax.script.*;\n\npublic class E {\n//\tstatic ScriptEngineManager sem = new ScriptEngineManager();\n//\tstatic ScriptEngine engine = sem.getEngineByName(\"javascript\");\n\n\tpublic static void main(String[] args){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString equation = \"\";\n\t\ttry{\n\t\t\tequation = br.readLine();\n\t\t} catch (IOException ioe){\n\t\t\tSystem.err.println(ioe.getMessage());\n\t\t}\n\t\tif(equation.equals(\"\")){ \n\t\t\tSystem.err.println(\"Null Input\");\n\t\t\tSystem.exit(-1);\t\n\t\t}\n\n\t\t// make a list of replacement letter;\n\t\tString sign = \"+*-01()=\";\n\t\tString replet = \"\";\n\t\tfor(int i = 0; i < equation.length(); i++){\n\t\t\tString letter = equation.substring(i,i+1);\n\t\t\tif(!sign.contains(letter) && !replet.contains(letter)){\n\t\t\t\treplet += letter;\n\t\t\t}\n\t\t}\n\n\t\tif(replet.length() > 8){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\n\t\tArrayList<String> decript = new ArrayList<String>();\n\t\tif(replet.length() == 0){\n\t\t\tdecript.add(equation);\n\t\t}\n\t\t\t\n\t\tSystem.out.println(decrypt(sign, replet, equation));\n\t}\n\n\tpublic static int decrypt(String sign, String letter, String equation){\n\t\tif(letter.length() == 0){\n/*\n\t\t\tequation = \"-0=0\";\n\t\t\tString script = equation.replaceAll(\"-+\",\"-\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replaceAll(\"=\",\"==\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replaceAll(\"([^01])([01]+)\",\"$10b$2\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replaceAll(\"^([01]+)\",\"0b$1\");\nSystem.out.println(script);\n\t\t\ttry{\n\t\t\t\tObject result = engine.eval(\"-0b0==0b0\");\n\t\t\t\tboolean ans = ((Boolean)result).booleanValue();\nSystem.out.println(equation);\n\t\t\t\tif(ans){ return 1; }\n\t\t\t\telse{ return 0; }\n\t\t\t} catch(ScriptException se){\n\t\t\t\treturn 0;\n\t\t\t} catch(ClassCastException cce){\n\t\t\t\treturn 0;\n\t\t\t}\n*/\n//System.out.println(equation);\n\t\t\tif(solve(equation)){\n//System.out.println(equation);\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(sign.length() == 0){\n\t\t\treturn 0;\n\t\t}\n\n\t\tint count = 0;\n\t\tfor(int k = 0; k < sign.length(); k++){\n\t\t\tString s = sign.substring(k,k+1);\n\t\t\tif(\"+*()\".contains(s)){ s = \"\\\\\" + s; }\n\t\t\t\n\t\t\tcount += decrypt(\tsign.replaceAll(s,\"\"), \n\t\t\t\t\t\t\t\t\t\t\t\tletter.substring(1,letter.length()),\n\t\t\t\t\t\t\t\t\t\t\t\tequation.replaceAll(letter.substring(0,1),s));\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static boolean solve(String equation){\n\t\tint cnt_eq = 0;\n\t\tfor(int i = 0; i < equation.length(); i++){\n\t\t\tif(equation.substring(i,i+1).equals(\"=\")){ cnt_eq++; }\n\t\t}\n\t\tif(cnt_eq != 1){ return false; }\n\n\t\tString[] expr = equation.split(\"=\");\n\t\tif(expr.length != 2){ return false; }\n\t\tint[] ans = new int[2];\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\ttry{\n\t\t\t\tNode n = Node.construct(expr[i]);\n\t\t\t\tans[i] = Node.calculate(n);\n\t\t\t} catch(ParseException pe){\n//if(equation.equals(\"0=-(0)\") || equation.equals(\"0=(-0)\") || equation.equals(\"-0=(0)\")){\n//if(Integer.parseInt(pe.getMessage().replaceAll(\"error\", \"\")) > 10){\n//System.out.println(pe.getMessage() + \":\" + equation);\n//System.out.println(pe.getMessage());\n//}\n//}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n//System.out.println(equation);\n//System.out.println(ans[0] + \", \" + ans[1]);\n\t\treturn ans[0] == ans[1];\n\t}\n}\nclass Node {\n\tpublic Node parent;\n\tNode left;\n\tNode right;\n\tString letter;\n\tboolean numFlg;\n\tboolean locked;\n\n\tNode(Node parent, Node left, Node right, String letter){\n\t\tthis.parent = parent;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.letter = letter;\n\t\tif(\"+*-\".contains(letter)){ \n\t\t\tnumFlg = false; \n\t\t} else { \n\t\t\tnumFlg = true; \n\t\t}\n\t\tlocked = false;\n\t}\n\n\tpublic Node put(String let){\n\t\tNode n = new Node(null, null, null, let);\n\t\tif(this.parent != null){ \n\t\t\tn.parent = this.parent.parent;\n\t\t\tif(n.parent != null){\n\t\t\t\tn.parent.right = n;\n\t\t\t}\n\t\t\tn.left = this.parent;\n\t\t\tthis.parent.parent = n; \n\t\t} else {\n\t\t\tn.left = this;\n\t\t\tthis.parent = n;\n\t\t}\n\t\treturn n;\n\t}\n\n\tpublic Node insert(String let){\n\t\tNode n = new Node(this.parent, this, null, let);\n\t\tif(this.parent != null){\n\t\t\tthis.parent.right = n;\n\t\t}\n\t\tthis.parent = n;\n\t\treturn n;\n\t}\n\n\tpublic Node add(String let){\n\t\tNode n = new Node(this, null, null, let);\n\t\tthis.right = n;\n\t\treturn n;\n\t}\n\n\tpublic static Node construct(String equation) throws ParseException {\n\t\tNode node = null;\n\t\tfor(int index = 0; index < equation.length(); index++){\n//try{\n//Node tmp = node;\n//if(tmp != null){ while(tmp.parent != null){ tmp = tmp.parent; }}\n//calculate(tmp);\n//}catch(ParseException pe){}\n//System.out.println();\n\t\t\tString letter = equation.substring(index,index+1);\n\t\t\tswitch(letter){\n\t\t\t\tcase \"+\":\n\t\t\t\t\tif(node == null){ throw new ParseException(\"error1\", 0); }\n\t\t\t\t\tif(!node.numFlg && node.right == null){ throw new ParseException(\"error2\", 0); }\n\t\t\t\t\t// put\n\t\t\t\t\tnode = node.put(letter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"*\":\n\t\t\t\t\tif(node == null){ throw new ParseException(\"error3\", 0); }\n\t\t\t\t\tif(!node.numFlg && node.right == null){ throw new ParseException(\"error4\", 0); }\n\t\t\t\t\tif(node.parent == null || node.parent.letter.equals(\"*\")){\n\t\t\t\t\t\tnode = node.put(letter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = node.insert(letter);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"-\":\n\t\t\t\t\tif(node == null){\n\t\t\t\t\t\tnode = new Node(null, null, null, letter);\n\t\t\t\t\t\tnode.numFlg = true;\n\t\t\t\t\t} else if(!node.numFlg){\n\t\t\t\t\t\tif(node.right == null){\n\t\t\t\t\t\t\tnode = node.add(letter);\n\t\t\t\t\t\t\tnode.numFlg = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//node = node.insert(letter);\n\t\t\t\t\t\t\tnode = node.put(letter);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(node.letter.matches(\"^-+$\")){\n\t\t\t\t\t\t\tnode.letter += letter;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode = node.put(letter);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"0\":\t\n\t\t\t\tcase \"1\":\n\t\t\t\t\tif(node == null){\n\t\t\t\t\t\tnode = new Node(null, null, null, letter);\n\t\t\t\t\t} else if(!node.numFlg){\n\t\t\t\t\t\tif(node.right == null){\n\t\t\t\t\t\t\tnode = node.add(letter);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new ParseException(\"error8\", 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(!node.locked){\n\t\t\t\t\t\tnode.letter += letter;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new ParseException(\"error16\", 0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"(\":\n\t\t\t\t\tint begin=0;\n\t\t\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\t\t\tdo{\n\t\t\t\t\t\tif(index >= equation.length()){\n\t\t\t\t\t\t\tthrow new ParseException(\"error6\", 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch(equation.substring(index,index+1)){\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tstack.push(index);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tbegin = stack.pop();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} while(!stack.empty());\n\t\t\t\t\tindex--;\n\t\t\t\t\tNode n = construct(equation.substring(begin+1,index));\n\t\t\t\t\tif(!n.numFlg && n.right == null){\n\t\t\t\t\t\tthrow new ParseException(\"error15\", 0);\n\t\t\t\t\t} else if(n.numFlg){\n\t\t\t\t\t\tn.locked = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(node == null){\n\t\t\t\t\t\tnode = n;\n\t\t\t\t\t} else if(!node.numFlg && node.right == null){\n\t\t\t\t\t\tnode.right = n;\n\t\t\t\t\t\tn.parent = node;\n\t\t\t\t\t\tnode = n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(node.letter.matches(\"^-+$\")){\n\t\t\t\t\t\t\tnode.letter += \"1\";\n\t\t\t\t\t\t\tnode = node.insert(\"*\");\n\t\t\t\t\t\t\tnode.right = n;\n\t\t\t\t\t\t\tn.parent = node;\n\t\t\t\t\t\t\tnode = n;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new ParseException(\"error9\", 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \")\":\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ParseException(\"error5\", 0);\n\t\t\t}\n\t\t}\n\t\t// return root\n\t\tif(node == null){ throw new ParseException(\"error7\", 0); }\n\t\twhile(node.parent != null){ node = node.parent; }\n\t\treturn node;\n\t}\n\n\tpublic static int calculate(Node node) throws ParseException {\n\t\tif(node == null){ throw new ParseException(\"error12\", 0); }\n//System.out.println(\"node:\" + node.letter);\n\t\tif(!node.numFlg){\n\t\t\tswitch(node.letter){\n\t\t\t\tcase \"+\":\n\t\t\t\t\treturn calculate(node.left) + calculate(node.right);\n\t\t\t\tcase \"*\":\n\t\t\t\t\treturn calculate(node.left) * calculate(node.right);\n\t\t\t\tcase \"-\":\n\t\t\t\t\treturn calculate(node.left) - calculate(node.right);\n\t\t\t}\n\t\t}\n\t\tif(node.letter.matches(\"^-*0+[01]+$\") || node.letter.matches(\"^-+$\")){\n\t\t\tthrow new ParseException(\"error10\", 0);\n\t\t}\n\t\tString val = node.letter.replaceAll(\"--\", \"\");\n//System.out.println(val);\n\t\tint num = 0;\n\t\ttry{\n\t\t\tnum = Integer.parseInt(val, 2);\n\t\t} catch(NumberFormatException nfe){\n\t\t\tthrow new ParseException(\"error11\", 0);\n\t\t}\n\t\treturn num;\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nbase = \"=+-*()01\"\ns = input()\nl = len(s)\nmapping = {}\ncounter = {}\ncnt = 0\nfor c in s:\n    if c in base:\n        continue\n    if c not in mapping:\n        mapping[c] = cnt\n        cnt += 1\n    v = mapping[c]\n    counter[v] = counter.get(v, 0) + 1\nif cnt > 8:\n    print(0)\n    exit(0)\n\ndef solve(read):\n    cur = failed = 0\n    def next():\n        nonlocal cur\n        cur += 1\n    def error():\n        nonlocal failed\n        failed = 1\n    def number():\n        res = 0\n        if read(cur) not in \"01\":\n            error()\n        first = 1\n        while 1:\n            c = read(cur)\n            if c not in \"01\":\n                break\n            if not first and res == 0:\n                error()\n            res = (res << 1) ^ int(c)\n            next() # \"0\" or \"1\"\n            first = 0\n        return res\n    def factor():\n        c = read(cur)\n        if c == \"-\":\n            next() # \"-\"\n            return -factor()\n        elif c == \"(\":\n            next() # \"(\"\n            val = expr()\n            if read(cur) != \")\":\n                error()\n            next() # \")\"\n            return val\n        return number()\n    def term():\n        res = 1\n        while 1:\n            res *= factor()\n            c = read(cur)\n            if c != \"*\":\n                break\n            next() # \"*\"\n        return res\n    def expr():\n        res = 0\n        op = \"+\"\n        while 1:\n            if op == \"+\":\n                res += term()\n            else:\n                res -= term()\n            c = read(cur)\n            if c not in \"+-\":\n                break\n            next() # \"+\" or \"-\"\n            op = c\n        return res\n    lv = expr()\n    next() # \"=\"\n    rv = expr()\n    if not failed and cur == l:\n        return lv == rv\n    return 0\n\ndef get(b):\n    def read(cur):\n        if l <= cur:\n            return \"$\"\n        if s[cur] in base:\n            return s[cur]\n        return b[mapping[s[cur]]]\n    return read\n\nans = 0\nif cnt == 0:\n    ans += solve(get(None))\nfor b in permutations(base, cnt):\n    if \"=\" in b and counter[b.index(\"=\")] > 1:\n        continue\n    ans += solve(get(b))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = \"\"\nans = 0\nslen = 0\nd = {}\nu = {\n    \"+\": False,\n    \"-\": False,\n    \"*\": False,\n    \"0\": False,\n    \"1\": False,\n    \"=\": False,\n    \"(\": False,\n    \")\": False\n}\n\ndef dfs(p):\n    global slen, ans, s\n    if p == slen:\n        tmp = \"\"\n        cnte = 0\n        for i in s:\n            if i in d:\n                tmp = tmp + d[i]\n                if d[i] == \"=\":\n                    cnte = cnte + 1\n            else:\n                tmp = tmp + i\n                if i == \"=\":\n                    cnte = cnte + 1\n\n        if cnte != 1:\n            return\n        if tmp[0] == \"=\" or tmp[slen - 1] == \"=\":\n            return\n        if tmp[0] == \"+\":\n            return\n        for i in range(1, slen):\n            if tmp[i] == tmp[i - 1] and tmp[i] == \"*\":\n                return\n            if tmp[i] == \"+\" and tmp[i - 1] == \"-\":\n                return\n            if tmp[i] == \"+\" and tmp[i - 1] == \"+\":\n                return\n            if tmp[i] == \"+\" and tmp[i - 1] == \"*\":\n                return\n            if tmp[i] == \"+\" and tmp[i - 1] == \"=\":\n                return\n            if tmp[i] == \"+\" and tmp[i - 1] == \"(\":\n                return\n\n        lst = 2\n        for i in range(slen):\n            if tmp[i] == \"0\" or tmp[i] == \"1\":\n                if lst == 0:\n                    return\n                if lst == 2 and tmp[i] == \"0\":\n                    lst = 0\n                else: lst = 1\n            else: lst = 2\n\n        tt = \"\"\n        lastnum = False\n        for i in tmp:\n            if i == \"0\" or i == \"1\":\n                if lastnum == False:\n                    tt = tt + \"0b\"\n                lastnum = True\n            else: lastnum = False\n            tt = tt + i\n\n        try:\n            (le, re) = tt.split(\"=\")\n            if eval(le) == eval(re):\n                ans = ans + 1\n        except Exception as e:\n            pass\n        return\n\n    flag = False\n    for (key, value) in u.items():\n        if s[p] == key:\n            flag = True\n            break\n\n    if flag or s[p] in d:\n        dfs(p + 1)\n    else:\n        for (key, value) in u.items():\n            if not value:\n                d[s[p]] = key\n                u[key] = True\n                dfs(p + 1)\n                del d[s[p]]\n                u[key] = False\n\ns = input()\nslen = len(s)\ndfs(0)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nbase = \"=+-*()01\"\ns = input()\nl = len(s)\nmapping = {}\ncounter = {}\ncnt = 0\nfor c in s:\n    if c in base:\n        continue\n    if c not in mapping:\n        mapping[c] = cnt\n        cnt += 1\n    v = mapping[c]\n    counter[v] = counter.get(v, 0) + 1\nif cnt > 8:\n    print(0)\n    exit(0)\n\ndef solve(read):\n    cur = failed = 0\n    def next():\n        nonlocal cur\n        cur += 1\n    def error():\n        nonlocal failed\n        failed = 1\n    def number():\n        res = 0\n        if read(cur) not in \"01\":\n            error()\n        first = 1\n        while 1:\n            c = read(cur)\n            if c not in \"01\":\n                break\n            if not first and res == 0:\n                error()\n            res = (res << 1) ^ int(c)\n            next() # \"0\" or \"1\"\n            first = 0\n        return res\n    def factor():\n        c = read(cur)\n        if c == \"-\":\n            next() # \"-\"\n            return -factor()\n        elif c == \"(\":\n            next() # \"(\"\n            val = expr()\n            if read(cur) != \")\":\n                error()\n            next() # \")\"\n            return val\n        return number()\n    def term():\n        res = 1\n        while 1:\n            res *= factor()\n            c = read(cur)\n            if c != \"*\":\n                break\n            next() # \"*\"\n        return res\n    def expr():\n        res = 0\n        op = \"+\"\n        while 1:\n            if op == \"+\":\n                res += term()\n            else:\n                res -= term()\n            c = read(cur)\n            if c not in \"+-\":\n                break\n            next() # \"+\" or \"-\"\n            op = c\n        return res\n    if sum(read(i) == \"=\" for i in range(l)) != 1:\n        return 0\n    lv = expr()\n    next() # \"=\"\n    rv = expr()\n    for i in range(l):\n        print(end=read(i))\n    print(\" \", lv, rv, failed)\n    if not failed and cur == l:\n        return lv == rv\n    return 0\n\ndef get(b):\n    def read(cur):\n        if l <= cur:\n            return \"$\"\n        if s[cur] in base:\n            return s[cur]\n        return b[mapping[s[cur]]]\n    return read\n\nans = 0\nfor b in permutations(base, cnt):\n    ans += solve(get(b))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nbase = \"=+-*()01\"\ns = input()\nl = len(s)\nmapping = {}\ncounter = {}\ncnt = 0\nfor c in s:\n    if c in base:\n        continue\n    if c not in mapping:\n        mapping[c] = cnt\n        cnt += 1\n    v = mapping[c]\n    counter[v] = counter.get(v, 0) + 1\nif cnt > 8:\n    print(0)\n    exit(0)\n\ndef solve(read):\n    cur = failed = 0\n    def next():\n        nonlocal cur\n        cur += 1\n    def error():\n        nonlocal failed\n        failed = 1\n    def number():\n        res = 0\n        if read(cur) not in \"01\":\n            error()\n        first = 1\n        while 1:\n            c = read(cur)\n            if c not in \"01\":\n                break\n            if not first and res == 0:\n                error()\n            res = (res << 1) ^ int(c)\n            next() # \"0\" or \"1\"\n            first = 0\n        return res\n    def factor():\n        c = read(cur)\n        if c == \"-\":\n            next() # \"-\"\n            return -factor()\n        elif c == \"(\":\n            next() # \"(\"\n            val = expr()\n            if read(cur) != \")\":\n                error()\n            next() # \")\"\n            return val\n        return number()\n    def term():\n        res = 1\n        while 1:\n            res *= factor()\n            c = read(cur)\n            if c != \"*\":\n                break\n            next() # \"*\"\n        return res\n    def expr():\n        res = 0\n        op = \"+\"\n        while 1:\n            if op == \"+\":\n                res += term()\n            else:\n                res -= term()\n            c = read(cur)\n            if c not in \"+-\":\n                break\n            next() # \"+\" or \"-\"\n            op = c\n        return res\n    if sum(read(i) == \"=\" for i in range(l)) != 1:\n        return 0\n    lv = expr()\n    next() # \"=\"\n    rv = expr()\n    if not failed and cur == l:\n        return lv == rv\n    return 0\n\ndef get(b):\n    def read(cur):\n        if l <= cur:\n            return \"$\"\n        if s[cur] in base:\n            return s[cur]\n        return b[mapping[s[cur]]]\n    return read\n\nans = 0\nfor b in permutations(base, cnt):\n    ans += solve(get(b))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nbase = \"=+-*()01\"\ns = input()\nl = len(s)\nmapping = {}\ncounter = {}\ncnt = 0\nfor c in s:\n    if c in base:\n        continue\n    if c not in mapping:\n        mapping[c] = cnt\n        cnt += 1\n    v = mapping[c]\n    counter[v] = counter.get(v, 0) + 1\nif cnt > 8:\n    print(0)\n    exit(0)\n\ndef solve(read):\n    cur = failed = 0\n    def next():\n        nonlocal cur\n        cur += 1\n    def error():\n        nonlocal failed\n        failed = 1\n    def number():\n        res = 0\n        if read(cur) not in \"01\":\n            error()\n        first = 1\n        while 1:\n            c = read(cur)\n            if c not in \"01\":\n                break\n            if not first and res == 0:\n                error()\n            res = (res << 1) ^ int(c)\n            next() # \"0\" or \"1\"\n            first = 0\n        return res\n    def factor():\n        c = read(cur)\n        if c == \"-\":\n            next() # \"-\"\n            return -factor()\n        elif c == \"(\":\n            next() # \"(\"\n            val = expr()\n            if read(cur) != \")\":\n                error()\n            next() # \")\"\n            return val\n        return number()\n    def term():\n        res = 1\n        while 1:\n            res *= factor()\n            c = read(cur)\n            if c != \"*\":\n                break\n            next() # \"*\"\n        return res\n    def expr():\n        res = 0\n        op = \"+\"\n        while 1:\n            if op == \"+\":\n                res += term()\n            else:\n                res -= term()\n            c = read(cur)\n            if c not in \"+-\":\n                break\n            next() # \"+\" or \"-\"\n            op = c\n        return res\n    lv = expr()\n    next() # \"=\"\n    rv = expr()\n    if not failed and cur == l:\n        return lv == rv\n    return 0\n\ndef get(b):\n    def read(cur):\n        if l <= cur:\n            return \"$\"\n        if s[cur] in base:\n            return s[cur]\n        return b[mapping[s[cur]]]\n    return read\n\nans = 0\nif cnt == 0:\n    ans += solve(get(None))\nfor b in permutations(base, cnt):\n    if \"=\" not in b or counter[b.index(\"=\")] > 1:\n        continue\n    ans += solve(get(b))\nprint(ans)"
  }
]