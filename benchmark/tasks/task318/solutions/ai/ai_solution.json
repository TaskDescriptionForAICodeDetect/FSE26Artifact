[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 128\n\ntypedef struct {\n    int grid[MAX_SIZE][MAX_SIZE];\n    int rows, cols;\n} Paper;\n\nvoid initPaper(Paper *p, int rows, int cols) {\n    p->rows = rows;\n    p->cols = cols;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            p->grid[i][j] = 0;\n        }\n    }\n}\n\nvoid foldLeft(Paper *p) {\n    int newCols = p->cols / 2;\n    for (int i = 0; i < p->rows; i++) {\n        for (int j = 0; j < newCols; j++) {\n            p->grid[i][j] += p->grid[i][p->cols - 1 - j];\n        }\n    }\n    p->cols = newCols;\n}\n\nvoid foldRight(Paper *p) {\n    int newCols = p->cols / 2;\n    for (int i = 0; i < p->rows; i++) {\n        for (int j = 0; j < newCols; j++) {\n            p->grid[i][p->cols - 1 - j] += p->grid[i][j];\n        }\n    }\n    p->cols = newCols;\n}\n\nvoid foldUp(Paper *p) {\n    int newRows = p->rows / 2;\n    for (int i = 0; i < newRows; i++) {\n        for (int j = 0; j < p->cols; j++) {\n            p->grid[i][j] += p->grid[p->rows - 1 - i][j];\n        }\n    }\n    p->rows = newRows;\n}\n\nvoid foldDown(Paper *p) {\n    int newRows = p->rows / 2;\n    for (int i = 0; i < newRows; i++) {\n        for (int j = 0; j < p->cols; j++) {\n            p->grid[p->rows - 1 - i][j] += p->grid[i][j];\n        }\n    }\n    p->rows = newRows;\n}\n\nvoid punch(Paper *p, int row, int col) {\n    p->grid[row][col] = 1;\n}\n\nint countHoles(Paper *p) {\n    int count = 0;\n    for (int i = 0; i < p->rows; i++) {\n        for (int j = 0; j < p->cols; j++) {\n            if (p->grid[i][j] > 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int N, M;\n        scanf(\"%d %d\", &N, &M);\n        Paper paper;\n        initPaper(&paper, N, M);\n        \n        int K;\n        scanf(\"%d\", &K);\n        while (K--) {\n            char operation[10];\n            scanf(\"%s\", operation);\n            if (strcmp(operation, \"fold\") == 0) {\n                char direction[10];\n                scanf(\"%s\", direction);\n                if (strcmp(direction, \"left\") == 0) {\n                    foldLeft(&paper);\n                } else if (strcmp(direction, \"right\") == 0) {\n                    foldRight(&paper);\n                } else if (strcmp(direction, \"up\") == 0) {\n                    foldUp(&paper);\n                } else if (strcmp(direction, \"down\") == 0) {\n                    foldDown(&paper);\n                }\n            } else if (strcmp(operation, \"punch\") == 0) {\n                int row, col;\n                scanf(\"%d %d\", &row, &col);\n                punch(&paper, row - 1, col - 1);\n            }\n        }\n        printf(\"%d\\n\", countHoles(&paper));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:03:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, m, t, p;\n    while (cin >> n >> m >> t >> p) {\n        if (n == 0 && m == 0 && t == 0 && p == 0) break;\n        vector<vector<int>> grid(n, vector<int>(m, 1));\n        for (int i = 0; i < t; ++i) {\n            int d, c;\n            cin >> d >> c;\n            if (d == 1) {\n                int new_n = max(c, (int)grid.size() - c);\n                vector<vector<int>> new_grid(new_n, vector<int>(grid[0].size(), 0));\n                for (int y = 0; y < grid[0].size(); ++y) {\n                    for (int x = 0; x < c; ++x) {\n                        if (c - x - 1 >= 0 && c + x < grid.size()) {\n                            new_grid[x][y] = grid[c - x - 1][y] + grid[c + x][y];\n                        } else if (c - x - 1 >= 0) {\n                            new_grid[x][y] = grid[c - x - 1][y];\n                        } else {\n                            new_grid[x][y] = grid[c + x][y];\n                        }\n                    }\n                }\n                grid = new_grid;\n            } else {\n                int new_m = max(c, (int)grid[0].size() - c);\n                vector<vector<int>> new_grid(grid.size(), vector<int>(new_m, 0));\n                for (int x = 0; x < grid.size(); ++x) {\n                    for (int y = 0; y < c; ++y) {\n                        if (c - y - 1 >= 0 && c + y < grid[0].size()) {\n                            new_grid[x][y] = grid[x][c - y - 1] + grid[x][c + y];\n                        } else if (c - y - 1 >= 0) {\n                            new_grid[x][y] = grid[x][c - y - 1];\n                        } else {\n                            new_grid[x][y] = grid[x][c + y];\n                        }\n                    }\n                }\n                grid = new_grid;\n            }\n        }\n        for (int i = 0; i < p; ++i) {\n            int x, y;\n            cin >> x >> y;\n            cout << grid[x][y] << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:04:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PaperHoles {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        \n        List<String> folds = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            folds.add(scanner.nextLine());\n        }\n        \n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        List<String> punches = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            punches.add(scanner.nextLine());\n        }\n        \n        int layers = 1;\n        int width = 1;\n        int height = 1;\n        \n        for (String fold : folds) {\n            if (fold.equals(\"L\") || fold.equals(\"R\")) {\n                width *= 2;\n            } else if (fold.equals(\"T\") || fold.equals(\"B\")) {\n                height *= 2;\n            }\n            layers *= 2;\n        }\n        \n        boolean[][] grid = new boolean[height][width];\n        \n        for (String punch : punches) {\n            String[] parts = punch.split(\" \");\n            int x = Integer.parseInt(parts[0]);\n            int y = Integer.parseInt(parts[1]);\n            grid[y][x] = true;\n        }\n        \n        boolean[][] unfolded = new boolean[height][width];\n        \n        for (String fold : folds) {\n            if (fold.equals(\"L\")) {\n                boolean[][] newGrid = new boolean[height][width / 2];\n                for (int i = 0; i < height; i++) {\n                    for (int j = 0; j < width / 2; j++) {\n                        newGrid[i][j] = grid[i][j] || grid[i][width - 1 - j];\n                    }\n                }\n                grid = newGrid;\n                width /= 2;\n            } else if (fold.equals(\"R\")) {\n                boolean[][] newGrid = new boolean[height][width / 2];\n                for (int i = 0; i < height; i++) {\n                    for (int j = 0; j < width / 2; j++) {\n                        newGrid[i][j] = grid[i][width / 2 + j] || grid[i][width / 2 - 1 - j];\n                    }\n                }\n                grid = newGrid;\n                width /= 2;\n            } else if (fold.equals(\"T\")) {\n                boolean[][] newGrid = new boolean[height / 2][width];\n                for (int i = 0; i < height / 2; i++) {\n                    for (int j = 0; j < width; j++) {\n                        newGrid[i][j] = grid[i][j] || grid[height - 1 - i][j];\n                    }\n                }\n                grid = newGrid;\n                height /= 2;\n            } else if (fold.equals(\"B\")) {\n                boolean[][] newGrid = new boolean[height / 2][width];\n                for (int i = 0; i < height / 2; i++) {\n                    for (int j = 0; j < width; j++) {\n                        newGrid[i][j] = grid[height / 2 + i][j] || grid[height / 2 - 1 - i][j];\n                    }\n                }\n                grid = newGrid;\n                height /= 2;\n            }\n        }\n        \n        int holes = 0;\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                if (grid[i][j]) {\n                    holes++;\n                }\n            }\n        }\n        \n        System.out.println(holes);\n    }\n}",
    "timestamp": "2025-08-05 21:04:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PaperHoleCounter {\n    public static int countHoles(int width, int height, List<String> instructions) {\n        boolean[][] paper = new boolean[height][width];\n        \n        for (String instruction : instructions) {\n            String[] parts = instruction.split(\" \");\n            String type = parts[0];\n            \n            switch (type) {\n                case \"FOLD\":\n                    paper = fold(paper, parts[1], Integer.parseInt(parts[2]));\n                    break;\n                case \"PUNCH\":\n                    paper = punch(paper, Integer.parseInt(parts[1]), Integer.parseInt(parts[2]));\n                    break;\n            }\n        }\n        \n        return countActualHoles(paper);\n    }\n    \n    private static boolean[][] fold(boolean[][] paper, String direction, int position) {\n        int rows = paper.length;\n        int cols = paper[0].length;\n        \n        if (direction.equals(\"H\")) {\n            boolean[][] newPaper = new boolean[position][cols];\n            for (int i = 0; i < position; i++) {\n                for (int j = 0; j < cols; j++) {\n                    newPaper[i][j] = paper[i][j] || paper[rows - 1 - i][j];\n                }\n            }\n            return newPaper;\n        } else {\n            boolean[][] newPaper = new boolean[rows][position];\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < position; j++) {\n                    newPaper[i][j] = paper[i][j] || paper[i][cols - 1 - j];\n                }\n            }\n            return newPaper;\n        }\n    }\n    \n    private static boolean[][] punch(boolean[][] paper, int row, int col) {\n        if (row < paper.length && col < paper[0].length) {\n            paper[row][col] = true;\n        }\n        return paper;\n    }\n    \n    private static int countActualHoles(boolean[][] paper) {\n        int holes = 0;\n        for (boolean[] row : paper) {\n            for (boolean hole : row) {\n                if (hole) {\n                    holes++;\n                }\n            }\n        }\n        return holes;\n    }\n    \n    public static void main(String[] args) {\n        int width = 5;\n        int height = 5;\n        List<String> instructions = Arrays.asList(\n            \"PUNCH 1 2\",\n            \"FOLD H 3\",\n            \"PUNCH 0 1\"\n        );\n        \n        System.out.println(countHoles(width, height, instructions));\n    }\n}",
    "timestamp": "2025-08-05 21:05:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FOLDS 10\n#define MAX_PUNCHES 100\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Rectangle;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nRectangle fold_paper(Rectangle paper, char direction, int position) {\n    Rectangle new_paper;\n    if (direction == 'H') {\n        if (position < paper.y1 || position > paper.y2) return paper;\n        new_paper.x1 = paper.x1;\n        new_paper.x2 = paper.x2;\n        if (position <= (paper.y1 + paper.y2) / 2) {\n            new_paper.y1 = paper.y1;\n            new_paper.y2 = 2 * position - paper.y1;\n        } else {\n            new_paper.y1 = 2 * position - paper.y2;\n            new_paper.y2 = paper.y2;\n        }\n    } else {\n        if (position < paper.x1 || position > paper.x2) return paper;\n        new_paper.y1 = paper.y1;\n        new_paper.y2 = paper.y2;\n        if (position <= (paper.x1 + paper.x2) / 2) {\n            new_paper.x1 = paper.x1;\n            new_paper.x2 = 2 * position - paper.x1;\n        } else {\n            new_paper.x1 = 2 * position - paper.x2;\n            new_paper.x2 = paper.x2;\n        }\n    }\n    return new_paper;\n}\n\nint is_point_in_rectangle(Point point, Rectangle rect) {\n    return (point.x >= rect.x1 && point.x <= rect.x2 &&\n            point.y >= rect.y1 && point.y <= rect.y2);\n}\n\nint main() {\n    int width, height, num_folds, num_punches;\n    scanf(\"%d %d %d %d\", &width, &height, &num_folds, &num_punches);\n\n    Rectangle paper = {0, 0, width, height};\n    Rectangle folded_paper = paper;\n\n    for (int i = 0; i < num_folds; i++) {\n        char direction;\n        int position;\n        scanf(\" %c %d\", &direction, &position);\n        folded_paper = fold_paper(folded_paper, direction, position);\n    }\n\n    int hole_count = 0;\n    for (int i = 0; i < num_punches; i++) {\n        Point punch;\n        scanf(\"%d %d\", &punch.x, &punch.y);\n        if (is_point_in_rectangle(punch, folded_paper)) {\n            hole_count++;\n        }\n    }\n\n    printf(\"%d\\n\", hole_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nclass PaperHoleCounter {\nprivate:\n    int width, height;\n    vector<vector<bool>> paper;\n    \n    void fold(char direction, int line) {\n        if (direction == 'H') {\n            for (int i = line + 1; i < height; i++) {\n                int mirrorRow = 2 * line - i;\n                if (mirrorRow >= 0) {\n                    for (int j = 0; j < width; j++) {\n                        paper[mirrorRow][j] |= paper[i][j];\n                    }\n                }\n            }\n            height = line + 1;\n        } else {\n            for (int j = line + 1; j < width; j++) {\n                int mirrorCol = 2 * line - j;\n                if (mirrorCol >= 0) {\n                    for (int i = 0; i < height; i++) {\n                        paper[i][mirrorCol] |= paper[i][j];\n                    }\n                }\n            }\n            width = line + 1;\n        }\n    }\n    \n    void punch(int row, int col) {\n        if (row < height && col < width) {\n            paper[row][col] = true;\n        }\n    }\n\npublic:\n    PaperHoleCounter(int w, int h) : width(w), height(h) {\n        paper = vector<vector<bool>>(h, vector<bool>(w, false));\n    }\n    \n    int countHoles(vector<pair<char, int>>& folds, vector<pair<int, int>>& punches) {\n        for (auto& fold : folds) {\n            fold(fold.first, fold.second);\n        }\n        \n        for (auto& punch : punches) {\n            punch(punch.first, punch.second);\n        }\n        \n        int holeCount = 0;\n        unordered_set<string> uniqueHoles;\n        \n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                if (paper[i][j]) {\n                    string holeKey = to_string(i) + \",\" + to_string(j);\n                    uniqueHoles.insert(holeKey);\n                }\n            }\n        }\n        \n        return uniqueHoles.size();\n    }\n};\n\nint main() {\n    int w = 8, h = 8;\n    PaperHoleCounter counter(w, h);\n    \n    vector<pair<char, int>> folds = {{'H', 3}, {'V', 4}};\n    vector<pair<int, int>> punches = {{1,2}, {3,4}, {1,2}};\n    \n    int result = counter.countHoles(folds, punches);\n    cout << \"Number of holes: \" << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Paper:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n        self.grid = [[0] * width for _ in range(height)]\n\n    def fold_vertical(self, line):\n        new_grid = [row[:line] for row in self.grid]\n        for r in range(self.height):\n            for c in range(line+1, self.width):\n                new_c = line - 1 - (c - line)\n                if new_c >= 0:\n                    new_grid[r][new_c] += self.grid[r][c]\n        self.grid = new_grid\n        self.width = line\n\n    def fold_horizontal(self, line):\n        new_grid = [self.grid[r][:] for r in range(line)]\n        for r in range(line+1, self.height):\n            new_r = line - 1 - (r - line)\n            if new_r >= 0:\n                for c in range(self.width):\n                    new_grid[new_r][c] += self.grid[r][c]\n        self.grid = new_grid\n        self.height = line\n\n    def punch(self, x, y):\n        if 0 <= y < self.height and 0 <= x < self.width:\n            self.grid[y][x] += 1\n\n    def count_holes(self):\n        return sum(cell > 0 for row in self.grid for cell in row)\n\ndef count_holes(width, height, instructions):\n    paper = Paper(width, height)\n    for instruction in instructions:\n        if instruction[0] == 'fold':\n            direction, line = instruction[1], instruction[2]\n            if direction == 'vertical':\n                paper.fold_vertical(line)\n            elif direction == 'horizontal':\n                paper.fold_horizontal(line)\n        elif instruction[0] == 'punch':\n            x, y = instruction[1], instruction[2]\n            paper.punch(x, y)\n    return paper.count_holes()\n\n# Example usage:\ninstructions = [\n    ('fold', 'vertical', 3),\n    ('fold', 'horizontal', 2),\n    ('punch', 1, 1),\n    ('punch', 3, 2),\n]\nholes = count_holes(6, 4, instructions)\nprint(holes)",
    "timestamp": "2025-08-13 04:45:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PaperFolding {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int length = scanner.nextInt();\n        int width = scanner.nextInt();\n        int folds = scanner.nextInt();\n        int punches = scanner.nextInt();\n\n        List<String> foldInstructions = new ArrayList<>();\n        for (int i = 0; i < folds; i++) {\n            foldInstructions.add(scanner.next());\n        }\n\n        List<int[]> punchLocations = new ArrayList<>();\n        for (int i = 0; i < punches; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            punchLocations.add(new int[]{x, y});\n        }\n\n        int finalHoles = countHoles(length, width, foldInstructions, punchLocations);\n        System.out.println(finalHoles);\n    }\n\n    public static int countHoles(int length, int width, List<String> folds, List<int[]> punches) {\n        int height = 1;\n        for (String fold : folds) {\n            if (fold.equals(\"H\")) {\n                height *= 2;\n            } else if (fold.equals(\"V\")) {\n                width *= 2;\n            }\n        }\n\n        boolean[][] paper = new boolean[height][width];\n        for (int[] punch : punches) {\n            int x = punch[0];\n            int y = punch[1];\n\n            for (int fold = 1; fold < height; fold <<= 1) {\n                if (x >= fold) x = 2 * fold - 1 - x;\n            }\n\n            for (int fold = 1; fold < width; fold <<= 1) {\n                if (y >= fold) y = 2 * fold - 1 - y;\n            }\n\n            paper[x][y] = true;\n        }\n\n        int holesCount = 0;\n        for (boolean[] row : paper) {\n            for (boolean hole : row) {\n                if (hole) holesCount++;\n            }\n        }\n\n        return holesCount;\n    }\n}",
    "timestamp": "2025-08-13 04:46:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint countHoles(int width, int height, int numFolds, int xPunch, int yPunch) {\n    // Adjust coordinates for zero-based indexing\n    xPunch--;\n    yPunch--;\n\n    // Fold horizontally first\n    for (int i = 0; i < numFolds; i++) {\n        if (height > width) {\n            // Fold along height if height is greater\n            height = (height + 1) / 2;\n            if (yPunch >= height) yPunch = 2 * height - yPunch - 1;\n        } else {\n            // Fold along width, otherwise\n            width = (width + 1) / 2;\n            if (xPunch >= width) xPunch = 2 * width - xPunch - 1;\n        }\n    }\n\n    // Calculate number of holes for the folded rectangle\n    int finalHoles = (height * width) > 0 ? (1 << numFolds) : 0;\n    return finalHoles;\n}\n\nint main() {\n    int width, height, numFolds, xPunch, yPunch;\n    printf(\"Enter the width and height of the paper: \");\n    scanf(\"%d %d\", &width, &height);\n    printf(\"Enter the number of folds: \");\n    scanf(\"%d\", &numFolds);\n    printf(\"Enter the punch coordinates (x y): \");\n    scanf(\"%d %d\", &xPunch, &yPunch);\n\n    int result = countHoles(width, height, numFolds, xPunch, yPunch);\n    printf(\"Number of holes: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:46:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_holes(width, height, folds, punches):\n    # Initial paper size\n    current_width = width\n    current_height = height\n    \n    # Track hole locations\n    hole_locations = []\n    \n    # Process folds\n    for fold in folds:\n        direction, position = fold\n        if direction == 'H':  # Horizontal fold\n            current_height /= 2\n            hole_locations = [\n                (x, min(y, current_height) if y > current_height else y) \n                for x, y in hole_locations\n            ]\n        else:  # Vertical fold\n            current_width /= 2\n            hole_locations = [\n                (min(x, current_width) if x > current_width else x, y) \n                for x, y in hole_locations\n            ]\n    \n    # Process punches\n    for punch in punches:\n        x, y = punch\n        hole_locations.append((x, y))\n    \n    # Remove duplicate hole locations\n    unique_holes = set(hole_locations)\n    \n    return len(unique_holes)\n\n# Example usage\nwidth = 8\nheight = 6\nfolds = [('H', 3), ('V', 4)]\npunches = [(2, 2), (5, 3), (2, 2)]\n\nprint(count_holes(width, height, folds, punches))",
    "timestamp": "2025-08-13 04:46:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_holes():\n    # Read the number of folds and punches\n    N, M = map(int, input().split())\n    \n    # Initialize the paper layers\n    layers = [1]\n    \n    # Process each fold instruction\n    for _ in range(N):\n        fold = input().strip()\n        new_layers = []\n        if fold == 'L':\n            new_layers = layers[::-1]\n            for i in range(len(layers)):\n                new_layers[i] += layers[i]\n        elif fold == 'R':\n            new_layers = layers.copy()\n            for i in range(len(layers)):\n                new_layers[i] += layers[::-1][i]\n        elif fold == 'U':\n            new_layers = layers[::-1] + layers\n        elif fold == 'D':\n            new_layers = layers + layers[::-1]\n        layers = new_layers\n    \n    # Initialize the grid\n    rows = len(layers)\n    cols = layers[0] if rows > 0 else 0\n    grid = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Process each punch instruction\n    for _ in range(M):\n        x, y = map(int, input().split())\n        x -= 1  # converting to 0-based index\n        y -= 1\n        if 0 <= x < rows and 0 <= y < cols:\n            grid[x][y] += 1\n    \n    # Count the holes\n    total_holes = 0\n    for i in range(rows):\n        for j in range(cols[i] if isinstance(cols, list) else cols):\n            if grid[i][j] > 0:\n                total_holes += 1\n    \n    print(total_holes)\n\ncount_holes()",
    "timestamp": "2025-08-13 04:46:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to simulate folding a piece of paper\nvector<vector<bool>> foldPaper(vector<vector<bool>>& paper, char direction) {\n    int rows = paper.size();\n    int cols = paper[0].size();\n    vector<vector<bool>> newPaper;\n\n    if (direction == 'V') { // Vertical fold\n        for (int i = 0; i < rows / 2; ++i) {\n            newPaper.push_back(vector<bool>(cols));\n            for (int j = 0; j < cols; ++j) {\n                newPaper[i][j] = paper[i][j] || paper[rows - 1 - i][j];\n            }\n        }\n    } else if (direction == 'H') { // Horizontal fold\n        for (int i = 0; i < rows; ++i) {\n            newPaper.push_back(vector<bool>(cols / 2));\n            for (int j = 0; j < cols / 2; ++j) {\n                newPaper[i][j] = paper[i][j] || paper[i][cols - 1 - j];\n            }\n        }\n    }\n    return newPaper;\n}\n\n// Function to apply punch instructions on the folded piece of paper\nvoid punchPaper(vector<vector<bool>>& paper, vector<pair<int, int>>& punches) {\n    for (auto& p : punches) {\n        paper[p.first][p.second] = true;\n    }\n}\n\n// Function to count the number of holes in the folded piece of paper\nint countHoles(const vector<vector<bool>>& paper) {\n    int count = 0;\n    for (auto& row : paper) {\n        for (auto cell : row) {\n            if (cell) ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int rows, cols, numFolds, numPunches;\n    cin >> rows >> cols >> numFolds >> numPunches;\n\n    // Initialize paper with no holes\n    vector<vector<bool>> paper(rows, vector<bool>(cols, false));\n\n    // Read folding instructions\n    for (int i = 0; i < numFolds; ++i) {\n        char direction;\n        cin >> direction;\n        paper = foldPaper(paper, direction);\n    }\n\n    // Read punch instructions\n    vector<pair<int, int>> punches(numPunches);\n    for (int i = 0; i < numPunches; ++i) {\n        cin >> punches[i].first >> punches[i].second;\n    }\n    punchPaper(paper, punches);\n\n    // Output the number of holes\n    cout << countHoles(paper) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:21:36"
  }
]