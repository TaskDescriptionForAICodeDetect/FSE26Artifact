[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x1, y1, x2, y2;\n} Rectangle;\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c) {\n    Point ab = {b.x - a.x, b.y - a.y};\n    Point ac = {c.x - a.x, c.y - a.y};\n    double cr = cross(ab, ac);\n    if (cr > 0) return 1;\n    if (cr < 0) return -1;\n    return 0;\n}\n\nint intersect_segments(Point a1, Point a2, Point b1, Point b2) {\n    int ccw1 = ccw(a1, a2, b1);\n    int ccw2 = ccw(a1, a2, b2);\n    int ccw3 = ccw(b1, b2, a1);\n    int ccw4 = ccw(b1, b2, a2);\n    \n    if (ccw1 * ccw2 < 0 && ccw3 * ccw4 < 0) return 1;\n    return 0;\n}\n\ndouble distance_to_line(Point p, Point a, Point b) {\n    Point ab = {b.x - a.x, b.y - a.y};\n    Point ap = {p.x - a.x, p.y - a.y};\n    double len_ab = sqrt(ab.x * ab.x + ab.y * ab.y);\n    double cross_product = cross(ab, ap);\n    return fabs(cross_product) / len_ab;\n}\n\ndouble min(double a, double b) {\n    return a < b ? a : b;\n}\n\ndouble max(double a, double b) {\n    return a > b ? a : b;\n}\n\ndouble compute_last_moment(double R, Rectangle rects[], int n) {\n    double last_moment = 0.0;\n    Point origin = {0.0, 0.0};\n    \n    for (int i = 0; i < n; i++) {\n        Rectangle r = rects[i];\n        Point corners[4] = {\n            {r.x1, r.y1}, {r.x2, r.y1}, {r.x2, r.y2}, {r.x1, r.y2}\n        };\n        \n        for (int j = 0; j < 4; j++) {\n            Point a = corners[j];\n            Point b = corners[(j + 1) % 4];\n            \n            if (a.y <= 0 && b.y <= 0) continue;\n            \n            double t = -a.y / (b.y - a.y);\n            if (t >= 0 && t <= 1) {\n                Point intersection = {\n                    a.x + t * (b.x - a.x),\n                    0.0\n                };\n                double dist = sqrt(intersection.x * intersection.x);\n                if (dist <= R) {\n                    last_moment = max(last_moment, dist);\n                }\n            }\n        }\n        \n        for (int j = 0; j < 4; j++) {\n            Point corner = corners[j];\n            if (corner.y > 0) {\n                double dist = sqrt(corner.x * corner.x + corner.y * corner.y);\n                if (dist <= R) {\n                    last_moment = max(last_moment, dist);\n                }\n            }\n        }\n        \n        for (int j = 0; j < 4; j++) {\n            Point a = corners[j];\n            Point b = corners[(j + 1) % 4];\n            \n            if (a.y <= 0 && b.y <= 0) continue;\n            \n            Point line_start = {0.0, 0.0};\n            Point line_end = {R * 2, 0.0};\n            \n            if (intersect_segments(line_start, line_end, a, b)) {\n                last_moment = max(last_moment, R);\n            }\n        }\n    }\n    \n    return last_moment;\n}\n\nint main() {\n    while (1) {\n        int R, N;\n        scanf(\"%d %d\", &R, &N);\n        if (R == 0 && N == 0) break;\n        \n        Rectangle rects[100];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%lf %lf %lf %lf\", &rects[i].x1, &rects[i].y1, &rects[i].x2, &rects[i].y2);\n        }\n        \n        double last_moment = compute_last_moment(R, rects, N);\n        printf(\"%.6f\\n\", last_moment);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class VampireSunlight {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            double sunRadius = scanner.nextDouble();\n            int buildingCount = scanner.nextInt();\n            \n            if (buildingCount == 0) break;\n            \n            List<Building> buildings = new ArrayList<>();\n            for (int i = 0; i < buildingCount; i++) {\n                double left = scanner.nextDouble();\n                double height = scanner.nextDouble();\n                double right = scanner.nextDouble();\n                buildings.add(new Building(left, height, right));\n            }\n            \n            double lastBlockTime = calculateLastBlockTime(sunRadius, buildings);\n            System.out.printf(\"%.2f\\n\", lastBlockTime);\n        }\n        \n        scanner.close();\n    }\n    \n    static double calculateLastBlockTime(double sunRadius, List<Building> buildings) {\n        double lastBlock = 0;\n        \n        for (Building building : buildings) {\n            double leftAngle = Math.atan2(building.height, building.left);\n            double rightAngle = Math.atan2(building.height, building.right);\n            \n            if (leftAngle > rightAngle) {\n                double temp = leftAngle;\n                leftAngle = rightAngle;\n                rightAngle = temp;\n            }\n            \n            double leftBlockTime = calculateBlockTime(sunRadius, leftAngle);\n            double rightBlockTime = calculateBlockTime(sunRadius, rightAngle);\n            \n            lastBlock = Math.max(lastBlock, Math.min(leftBlockTime, rightBlockTime));\n        }\n        \n        return lastBlock;\n    }\n    \n    static double calculateBlockTime(double sunRadius, double angle) {\n        return sunRadius * Math.cos(angle);\n    }\n    \n    static class Building {\n        double left, height, right;\n        \n        Building(double left, double height, double right) {\n            this.left = left;\n            this.height = height;\n            this.right = right;\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:14:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    double cross(const Point& p) const { return x * p.y - y * p.x; }\n    double norm() const { return sqrt(x * x + y * y); }\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(Point a, Point b, Point c) {\n    double res = (b - a).cross(c - a);\n    if (fabs(res) < 1e-8) return 0;\n    return res > 0 ? 1 : -1;\n}\n\nPolygon convexHull(Polygon ps) {\n    int n = ps.size(), k = 0;\n    if (n <= 2) return ps;\n    sort(ps.begin(), ps.end(), [](const Point& p, const Point& q) {\n        return p.x < q.x || (p.x == q.x && p.y < q.y);\n    });\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\ndouble distanceToSegment(Point p, Point a, Point b) {\n    Point ab = b - a, ap = p - a;\n    double t = (ab.x * ap.x + ab.y * ap.y) / (ab.x * ab.x + ab.y * ab.y);\n    t = max(0.0, min(1.0, t));\n    Point closest = a + Point(ab.x * t, ab.y * t);\n    return (p - closest).norm();\n}\n\ndouble minDistanceFromPointToPolygon(Point p, const Polygon& poly) {\n    double minDist = 1e18;\n    int n = poly.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = poly[i], b = poly[(i+1)%n];\n        double dist = distanceToSegment(p, a, b);\n        if (dist < minDist) minDist = dist;\n    }\n    return minDist;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    int N;\n    while (cin >> N, N) {\n        double R;\n        cin >> R;\n        Polygon buildings;\n        for (int i = 0; i < N; ++i) {\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            buildings.push_back(Point(x1, y1));\n            buildings.push_back(Point(x1, y2));\n            buildings.push_back(Point(x2, y1));\n            buildings.push_back(Point(x2, y2));\n        }\n        Polygon hull = convexHull(buildings);\n        double maxDist = 0;\n        for (const Point& p : hull) {\n            double dist = p.norm();\n            if (dist > maxDist) maxDist = dist;\n        }\n        double minDist = minDistanceFromPointToPolygon(Point(0, 0), hull);\n        double ans = max(maxDist, R);\n        if (minDist >= R) ans = 0;\n        else ans = sqrt(ans * ans - R * R);\n        cout << ans << '\\n';\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:14:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_BUILDINGS 1000\n\ntypedef struct {\n    double x1, y1, x2, y2;\n} Building;\n\ndouble calculateLastBlockingMoment(double sunRadius, Building* buildings, int numBuildings) {\n    double lastBlockTime = 0.0;\n\n    for (int i = 0; i < numBuildings; i++) {\n        double x1 = buildings[i].x1;\n        double x2 = buildings[i].x2;\n        double height = buildings[i].y2;\n\n        // Calculate angle of horizon blocking\n        double angleStart = atan2(height, x1);\n        double angleEnd = atan2(height, x2);\n\n        // Adjust for sun radius\n        double blockTime = 1.0 - height / (sunRadius * tan(angleStart));\n        lastBlockTime = fmax(lastBlockTime, blockTime);\n    }\n\n    return lastBlockTime;\n}\n\nint main() {\n    int numDatasets;\n    scanf(\"%d\", &numDatasets);\n\n    for (int dataset = 0; dataset < numDatasets; dataset++) {\n        double sunRadius;\n        int numBuildings;\n\n        scanf(\"%lf %d\", &sunRadius, &numBuildings);\n\n        Building* buildings = malloc(numBuildings * sizeof(Building));\n        for (int i = 0; i < numBuildings; i++) {\n            scanf(\"%lf %lf %lf %lf\", \n                &buildings[i].x1, &buildings[i].y1, \n                &buildings[i].x2, &buildings[i].y2);\n        }\n\n        double result = calculateLastBlockingMoment(sunRadius, buildings, numBuildings);\n        printf(\"%.4f\\n\", result);\n\n        free(buildings);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:14:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nstruct Rectangle {\n    double x1, y1, x2, y2;\n};\n\ndouble findLastShadowMoment(double sunRadius, vector<Rectangle>& buildings) {\n    double lastBlockTime = 0;\n    \n    for (auto& building : buildings) {\n        double buildingHeight = abs(building.y2 - building.y1);\n        double buildingWidth = abs(building.x2 - building.x1);\n        \n        // Calculate time when shadow completely blocks sun\n        double shadowLength = buildingHeight * (sunRadius / building.y2);\n        double shadowTime = building.x2 + shadowLength;\n        \n        lastBlockTime = max(lastBlockTime, shadowTime);\n    }\n    \n    return lastBlockTime;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    cout << fixed << setprecision(2);\n    \n    while (datasets--) {\n        double sunRadius;\n        int buildingCount;\n        \n        cin >> sunRadius >> buildingCount;\n        \n        vector<Rectangle> buildings(buildingCount);\n        \n        for (int i = 0; i < buildingCount; i++) {\n            cin >> buildings[i].x1 >> buildings[i].y1 \n                >> buildings[i].x2 >> buildings[i].y2;\n        }\n        \n        double result = findLastShadowMoment(sunRadius, buildings);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:14:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Building {\n        double x1, y1, x2, y2;\n        Building(double x1, double y1, double x2, double y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n    }\n\n    static double EPS = 1e-9;\n\n    static double cross(Point a, Point b) {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    static Point subtract(Point a, Point b) {\n        return new Point(a.x - b.x, a.y - b.y);\n    }\n\n    static boolean ccw(Point a, Point b, Point c) {\n        Point ab = subtract(b, a);\n        Point ac = subtract(c, a);\n        return cross(ab, ac) >= -EPS;\n    }\n\n    static List<Point> convexHull(List<Point> points) {\n        if (points.size() <= 1) return points;\n        Collections.sort(points, (a, b) -> Double.compare(a.x, b.x) != 0 ? Double.compare(a.x, b.x) : Double.compare(a.y, b.y));\n        List<Point> lower = new ArrayList<>();\n        for (Point p : points) {\n            while (lower.size() >= 2 && !ccw(lower.get(lower.size() - 2), lower.get(lower.size() - 1), p)) {\n                lower.remove(lower.size() - 1);\n            }\n            lower.add(p);\n        }\n        List<Point> upper = new ArrayList<>();\n        for (int i = points.size() - 1; i >= 0; i--) {\n            Point p = points.get(i);\n            while (upper.size() >= 2 && !ccw(upper.get(upper.size() - 2), upper.get(upper.size() - 1), p)) {\n                upper.remove(upper.size() - 1);\n            }\n            upper.add(p);\n        }\n        lower.remove(lower.size() - 1);\n        lower.addAll(upper);\n        return lower;\n    }\n\n    static double distance(Point a, Point b) {\n        double dx = a.x - b.x;\n        double dy = a.y - b.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    static double solve(double R, List<Building> buildings) {\n        List<Point> points = new ArrayList<>();\n        for (Building b : buildings) {\n            points.add(new Point(b.x1, b.y1));\n            points.add(new Point(b.x1, b.y2));\n            points.add(new Point(b.x2, b.y1));\n            points.add(new Point(b.x2, b.y2));\n        }\n        List<Point> hull = convexHull(points);\n        if (hull.isEmpty()) return 0.0;\n        double maxDist = 0.0;\n        for (Point p : hull) {\n            double dist = distance(new Point(0, 0), p);\n            if (dist > maxDist) {\n                maxDist = dist;\n            }\n        }\n        return Math.max(0.0, maxDist - R);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null) {\n            StringTokenizer st = new StringTokenizer(line);\n            double R = Double.parseDouble(st.nextToken());\n            int N = Integer.parseInt(st.nextToken());\n            if (R == 0 && N == 0) break;\n            List<Building> buildings = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                st = new StringTokenizer(br.readLine());\n                double x1 = Double.parseDouble(st.nextToken());\n                double y1 = Double.parseDouble(st.nextToken());\n                double x2 = Double.parseDouble(st.nextToken());\n                double y2 = Double.parseDouble(st.nextToken());\n                buildings.add(new Building(x1, y1, x2, y2));\n            }\n            double result = solve(R, buildings);\n            System.out.printf(\"%.3f\\n\", result);\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:15:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef last_moment_blocked(sun_radius, buildings):\n    def is_blocked(sun_position):\n        for x1, y1, x2, y2 in buildings:\n            if x1 <= sun_position <= x2 and 0 <= sun_radius <= y2:\n                return True\n        return False\n\n    # The x-coordinate where the sun will finally reach the ground\n    horizon_x = max(x2 for _, _, x2, _ in buildings)\n\n    # Binary search to find the last moment\n    low, high = 0, horizon_x\n    while low < high:\n        mid = (low + high + 1) // 2\n        if is_blocked(mid):\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip().split('\\n')\n    \n    i = 0\n    while i < len(input_data):\n        sun_radius = float(input_data[i].strip())\n        num_buildings = int(input_data[i+1].strip())\n        buildings = []\n        \n        for j in range(num_buildings):\n            x1, y1, x2, y2 = map(float, input_data[i+2+j].strip().split())\n            buildings.append((x1, y1, x2, y2))\n        \n        print(last_moment_blocked(sun_radius, buildings))\n        \n        i += 2 + num_buildings",
    "timestamp": "2025-08-13 03:02:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class VampireSunblock {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            int sunRadius = scanner.nextInt();\n            int numBuildings = scanner.nextInt();\n            Building[] buildings = new Building[numBuildings];\n            \n            for (int i = 0; i < numBuildings; i++) {\n                int x1 = scanner.nextInt();\n                int y1 = scanner.nextInt();\n                int x2 = scanner.nextInt();\n                int y2 = scanner.nextInt();\n                buildings[i] = new Building(x1, y1, x2, y2);\n            }\n            \n            double lastMoment = calculateLastMoment(sunRadius, buildings);\n            System.out.println(lastMoment);\n        }\n    }\n\n    static class Building {\n        int x1, y1, x2, y2;\n\n        Building(int x1, int y1, int x2, int y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n    }\n\n    private static double calculateLastMoment(int sunRadius, Building[] buildings) {\n        double horizon = 0;\n        \n        for (Building building : buildings) {\n            double height = building.y2 - building.y1;\n            if (height > horizon) {\n                horizon = height;\n            }\n        }\n        \n        return horizon >= sunRadius ? 0 : Math.sqrt(sunRadius * sunRadius - horizon * horizon);\n    }\n}",
    "timestamp": "2025-08-13 03:02:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x1, y1, x2, y2;\n} Rectangle;\n\nint compare(const void *a, const void *b) {\n    Rectangle *rectA = (Rectangle *)a;\n    Rectangle *rectB = (Rectangle *)b;\n    return (rectA->y2 < rectB->y2) - (rectA->y2 > rectB->y2);\n}\n\ndouble computeLastBlockedMoment(int n, double sunRadius, Rectangle *buildings) {\n    qsort(buildings, n, sizeof(Rectangle), compare);\n    for (int i = 0; i < n; i++) {\n        if (buildings[i].y2 >= sunRadius) {\n            return buildings[i].y2;\n        }\n    }\n    return 0.0;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        double sunRadius;\n        int n;\n        scanf(\"%lf %d\", &sunRadius, &n);\n        Rectangle *buildings = (Rectangle *)malloc(n * sizeof(Rectangle));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf %lf\", &buildings[i].x1, &buildings[i].y1, &buildings[i].x2, &buildings[i].y2);\n        }\n        double result = computeLastBlockedMoment(n, sunRadius, buildings);\n        printf(\"%.6lf\\n\", result);\n        free(buildings);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 03:02:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_last_sunlight_blocked_moment(sun_radius, buildings):\n    last_blocking_moment = float('-inf')\n    \n    for building in buildings:\n        x_left, x_right, height = building\n        \n        # Calculate the time when the top of the building blocks the sun\n        blocking_moment = (height / sun_radius)\n        \n        # Update last blocking moment if it's later\n        last_blocking_moment = max(last_blocking_moment, blocking_moment)\n    \n    return last_blocking_moment if last_blocking_moment != float('-inf') else 0\n\ndef main():\n    while True:\n        try:\n            # Read sun radius\n            sun_radius = float(input())\n            \n            # Read number of buildings\n            n = int(input())\n            \n            # Read building details\n            buildings = []\n            for _ in range(n):\n                x_left, x_right, height = map(float, input().split())\n                buildings.append((x_left, x_right, height))\n            \n            # Compute and print result\n            result = find_last_sunlight_blocked_moment(sun_radius, buildings)\n            print(f\"{result:.2f}\")\n        \n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:02:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        R = float(input[ptr])\n        ptr += 1\n        N = int(input[ptr])\n        ptr += 1\n        buildings = []\n        for _ in range(N):\n            x1 = float(input[ptr])\n            y1 = float(input[ptr+1])\n            x2 = float(input[ptr+2])\n            y2 = float(input[ptr+3])\n            ptr +=4\n            buildings.append((x1, y1, x2, y2))\n        \n        # The sun is setting along the negative x-axis (left horizon)\n        # The last moment is when the rightmost edge of the shadow touches the sun's left edge\n        max_t = 0.0\n        for (x1, y1, x2, y2) in buildings:\n            # The building's rightmost x is max(x1, x2)\n            right_x = max(x1, x2)\n            # The building's top y is max(y1, y2)\n            top_y = max(y1, y2)\n            # The shadow's right edge is at right_x + top_y (since slope is 1)\n            shadow_right = right_x + top_y\n            # The sun's left edge is at -R\n            # The time is when shadow_right = -R => t = -R - shadow_right\n            # But since the sun is moving left, the last moment is when shadow_right is minimal\n            # So the minimal shadow_right is the limiting factor\n            # So the last moment is -R - min_shadow_right\n            # But we need to find the minimal shadow_right among all buildings\n            pass\n        \n        min_shadow_right = float('inf')\n        for (x1, y1, x2, y2) in buildings:\n            right_x = max(x1, x2)\n            top_y = max(y1, y2)\n            shadow_right = right_x + top_y\n            if shadow_right < min_shadow_right:\n                min_shadow_right = shadow_right\n        \n        if min_shadow_right >= -R:\n            # The shadow is always to the right of the sun's left edge, so sunlight is never blocked\n            print(\"0.00\")\n        else:\n            last_moment = -R - min_shadow_right\n            print(\"{0:.2f}\".format(last_moment))\n\nsolve()",
    "timestamp": "2025-08-13 03:02:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct Building {\n    double left, right, top;\n};\n\nbool isBlocked(double sunRadius, const std::vector<Building>& buildings) {\n    for (const Building& building : buildings) {\n        if (building.top > sunRadius && building.left <= sunRadius && building.right >= sunRadius) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble findLastBlockedMoment(double sunRadius, const std::vector<Building>& buildings) {\n    double low = sunRadius, high = sunRadius + 100000; // Large number assuming blockage occurs\n    double lastMoment = sunRadius;\n\n    while (high - low > 1e-6) { // Precision of 10^-6\n        double mid = (low + high) / 2.0;\n        \n        if (isBlocked(mid, buildings)) {\n            lastMoment = mid;\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n\n    return lastMoment;\n}\n\nint main() {\n    int datasets;\n    std::cin >> datasets;\n    \n    while (datasets--) {\n        double sunRadius;\n        int numBuildings;\n        std::cin >> sunRadius >> numBuildings;\n        \n        std::vector<Building> buildings(numBuildings);\n        for (int i = 0; i < numBuildings; ++i) {\n            std::cin >> buildings[i].left >> buildings[i].right >> buildings[i].top;\n        }\n        \n        std::cout << std::fixed << std::setprecision(6) << findLastBlockedMoment(sunRadius, buildings) << std::endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:09:21"
  }
]