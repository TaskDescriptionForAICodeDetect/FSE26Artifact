[
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nobject C {\n  def main(args: Array[String]): Unit = {\n    val scanner = new Scanner(System.in)\n    while (true) {\n      val R = scanner.nextInt()\n      val N = scanner.nextInt()\n      if (R == 0 && N == 0) {\n        return\n      }\n      val in = List.fill(N)(scanner.nextInt, scanner.nextInt, scanner.nextInt)\n      var map = scala.collection.mutable.ArrayBuffer.fill(R * 2)(0)\n      in.foreach {\n        case (xl, xr, h) =>\n          (xl until xr)\n            .map(_ + R)\n            .filter(_ >= 0)\n            .filter(_ < map.length)\n            .foreach(i => map(i) = Math.max(map(i), h))\n      }\n      val result = map.zipWithIndex.map {\n        case (h, index) => calc(index, h, R)\n      }.min\n      println(result)\n    }\n  }\n\n  def calc(index: Int, h: Int, R: Int): Double = {\n    h + R - Math.sqrt(Math.pow(R, 2) - Math.pow(getRFromIndex(index, R), 2))\n  }\n\n  def getRFromIndex(index: Int, R: Int): Double = {\n    R - index match {\n      case r if r <= 0 => -r\n      case r => r - 1\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nobject Main {\n  def main(args: Array[String]): Unit = {\n    val scanner = new Scanner(System.in)\n    while (true) {\n      val R = scanner.nextInt()\n      val N = scanner.nextInt()\n      if (R == 0 && N == 0) {\n        return\n      }\n      val in = List.fill(N)(scanner.nextInt, scanner.nextInt, scanner.nextInt)\n      var map = scala.collection.mutable.ArrayBuffer.fill(R * 2)(0)\n      in.foreach {\n        case (xl, xr, h) =>\n          (xl until xr)\n            .map(_ + R)\n            .filter(_ >= 0)\n            .filter(_ < map.length)\n            .foreach(i => map(i) = Math.max(map(i), h))\n      }\n      val result = map.zipWithIndex.map {\n        case (h, index) => calc(index, h, R)\n      }.min\n      println(result)\n    }\n  }\n\n  def calc(index: Int, h: Int, R: Int): Double = {\n    h + R - Math.sqrt(Math.pow(R, 2) - Math.pow(getRFromIndex(index, R), 2))\n  }\n\n  def getRFromIndex(index: Int, R: Int): Double = {\n    R - index match {\n      case r if r <= 0 => -r\n      case r => r - 1\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint r,n;\n\t\tcin >>r >>n;\n\n\t\tif(r==0) break;\n\n\t\tmap<int,int> f;\n\t\tfor(int i=-20; i<=20; ++i) f[i]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint xl,xr,h;\n\t\t\tcin >>xl >>xr >>h;\n\n\t\t\t//?????§?????´??°\n\t\t\tfor(int j=xl; j<xr; ++j) f[j]=max(f[j],h);\n\t\t}\n\n\t\t//????????????\n\t\tfor(int i=0; i<=r; ++i) f[i]=min(f[i],f[-i-1]);\n\n\t\tdouble y=100;\n\t\trep(i,r) y=min(y,f[i]-sqrt(r*r-i*i));\n\n\t\tprintf(\"%.10lf\\n\",y+r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int r; //半径\n        int max=0;  //高さの最大値\n        int n;\n        cin >> r >> n;\n        int r_min = 0 - r; //半径のマイナス\n        double t=20.0;\n        int x_i[n],x_j[n],h[n];\n        for(int i=0;i<n;i++){\n            cin >> x_i[i] >> x_j[i] >> h[i];\n            if(max<h[i])    max=h[i];\n        }\n        int a[max][r+r];\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<max;j++){\n                for(int l=-r;l<r;l++){\n                    if(x_i[i]<=l && x_j[i]>l){\n                        if(h[i]>=j){\n                            a[j-1][l+r]++;\n                        }\n                    }\n                }\n            }\n        }\n        int count=0;\n        double u=0.0;\n        int min=10;\n        int h_a,x_a;\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                if(a[i][j]==0){\n                    if(j<r){\n                        if(min>i+(r-1)-j){\n                            min=i+(r-1)-j;\n                            h_a=i;\n                            x_a=(r-1)-j;\n                        }\n                    }else{\n                        if(min>i+j-r){\n                            min=i+j-r;\n                            h_a=i;\n                            x_a=j-r;\n                        }\n                    }\n                }\n            }\n        }\n        t=(double)r-sqrt(r*r-x_a*x_a)+(double)h_a;\n        printf(\"%.4f\",t);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n//#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tint r, n;\n\twhile (cin >> r >> n&&r) {\n\t\tV height(r * 2);\n\t\trep(i, n) {\n\t\t\tint lx, rx, h;\n\t\t\tcin >> lx >> rx >> h;\n\t\t\tlx += r;\n\t\t\trx += r;\n\t\t\tREP(i, max(0, lx), min(r * 2, rx)) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\t\tif (any_of(all(height), [](int x) { return x == 0; })) {\n\t\t\tprintf(\"%.5f\\n\", 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble ans = r * 2;\n\t\trep(x, r * 2) {\n\t\t\tint h = height[x];\n\t\t\t//?????????????????????????????????????????????????????????\n\t\t\tdouble sun = h + r - sqrt(r*r - pow(abs(r - x) - (r - x > 0), 2));\n\t\t\tans = min(ans, sun);\n\t\t}\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n//#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tint r, n;\n\twhile (cin >> r >> n && r) {\n\t\tV height(r * 2);\n\t\trep(i, n) {\n\t\t\tint lx, rx, h; cin >> lx >> rx >> h;\n\t\t\tlx += r;\n\t\t\trx += r;\n\t\t\tREP(i, max(0, lx), min(r * 2, rx)) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = r * 2;\n\t\trep(x, r * 2) {\n\t\t\tint h = height[x];\n\t\t\tdouble a = sqrt(r * r - pow(abs(r - x) - (r - x > 0), 2));\n\t\t\tdouble sun = (double)(h + r) - a;\n\t\t\tans = min(ans, sun);\n\t\t}\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nint n;\ndouble r;\nint t[100];\nvector<int> x,y;\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(r==0&&n==0)break;\n    for(int i=0;i<100;i++)t[i]=0;\n    for(int i=0;i<n;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a+=50,b+=50;\n      for(int j=a;j<b;j++)t[j]=max(t[j],c);\n    }\n    x.clear(),y.clear();\n    for(int i=0;i<50;i++){\n      x.push_back(50-i-1);\n      y.push_back(t[i]);\n    }\n    for(int i=50;i<100;i++){\n      x.push_back(i-50);\n      y.push_back(t[i]);\n    }\n    double ans=(1<<28);\n    for(int i=0;i<(int)x.size();i++){\n      if(r-0.00000001<x[i])continue;\n      double d=y[i]-sqrt(r*r-x[i]*x[i]);\n      ans=min(d,ans);\n    }\n    printf(\"%.8f\\n\",ans+r);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int INF  = 1000000007;\n\nint r,n;\nmap<int,int> bill;\nbool input(){\n\tcin>>r>>n;\n\tif(r==0 && n==0)return false;\n\t\n\tbill.clear();\n\treps(i,-20,20+1){\n\t\tbill[i] = 0;\n\t}\n\trep(i,n){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t\n\t\treps(i,a,b)bill[i]=max(bill[i],c);\n\t}\n\t\n\treturn true;\n}\n\n\ndouble check(int x, int h){\n\tif(abs(x)>=r)return INF;\n\t\n\tdouble t = h + r - sqrt(r*r-x*x);\n\treturn t;\n}\n\nvoid solve(){\n\t\n\tdouble ans = INF;\n\tfor(map<int,int>::iterator it = bill.begin(); it!=bill.end(); it++){\n\t\tint x = it->first;\n\t\tint h = it->second;\n\t\t\n\t\tans = min(ans, check(x,h));\n\t\tans = min(ans, check(x+1,h));\n\t}\n\t\n\tprintf(\"%.9lf\\n\",ans);\n}\n\nint main(){\n\t\n\twhile(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-6\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R-eps)return false;\n\tif(y<c-R+eps)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\ndouble limit(int x, int y, int r) {\n\tif (x*x>r*r) {\n\t\treturn 100.0;\n\t}\n\treturn (double)y - (-(double)r+sqrt(r*r-x*x));\n}\n\nint main() {\n\tint r, n;\n\twhile (cin >> r >> n) {\n\t\tif (r == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tQ q;\n\t\tpriority_queue<Q, vector<Q>, greater<Q> > pq;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> (q.first).first >> (q.first).second >> q.second;\n\t\t\tpq.push(q);\n\t\t}\n\t\tvector<Q> data;\n\t\twhile (!pq.empty()) {\n\t\t\tQ pp = pq.top();\n\t\t\tpq.pop();\n\t\t\tif ((pp.first).second <= -r || (pp.first).first >= r) {\n\t\t\t} else {\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tQ qq = pq.top();\n\t\t\t\t\tif ((qq.first).first < (pp.first).second) {\n\t\t\t\t\t\tQ ppp = pp;\n\t\t\t\t\t\t(ppp.first).second = (qq.first).first;\n\t\t\t\t\t\tif ((ppp.first).first != (ppp.first).second && (ppp.first).second >= -r) {\n\t\t\t\t\t\t\tdata.push_back(ppp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpq.pop();\n\t\t\t\t\t\t(pp.first).first = (qq.first).first;\n\t\t\t\t\t\tif (pp.second > qq.second) {\n\t\t\t\t\t\t\tif ((pp.first).second >= (qq.first).second) {\n\t\t\t\t\t\t\t\tpq.push(pp);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t(qq.first).first = (pp.first).second;\n\t\t\t\t\t\t\t\tpq.push(pp);\n\t\t\t\t\t\t\t\tif ((qq.first).first < r) {\n\t\t\t\t\t\t\t\t\tpq.push(qq);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ((qq.first).second >= (pp.first).second) {\n\t\t\t\t\t\t\t\tpq.push(qq);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t(pp.first).first = (qq.first).second;\n\t\t\t\t\t\t\t\tif ((pp.first).first < r) {\n\t\t\t\t\t\t\t\t\tpq.push(pp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpq.push(qq);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata.push_back(pp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pq.empty()) {\n\t\t\t\t\tdata.push_back(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble count = 100.0;\n\t\tint left = -100;\n\t\tint sz = data.size();\n\t\tif (sz == 0) {\n\t\t\tcount = 0.0;\n\t\t} else if (sz == 1) {\n\t\t\tif ((data[0].first).first < -r) {\n\t\t\t\tif ((data[0].first).second > r) {\n\t\t\t\t\tcount = limit(0, data[0].second, r);\n\t\t\t\t} else {\n\t\t\t\t\tif ((data[0].first).second <= 0) {\n\t\t\t\t\t\tcount = 0.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcount = limit((data[0].first).second, 0, r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((data[0].first).first >= 0) {\n\t\t\t\t\tcount = 0.0;\n\t\t\t\t} else if ((data[0].first).second > r) {\n\t\t\t\t\tcount = limit((data[0].first).first, 0, r);\n\t\t\t\t} else if ((data[0].first).second < 0){\n\t\t\t\t\tcount = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\tcount = min(limit((data[0].first).first, 0, r), limit((data[0].first).second, 0, r));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tif (i == 0) {\n\t\t\t\tif ((data[0].first).first > 0) {\n\t\t\t\t\tcount = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ((data[0].first).first > -r) {\n\t\t\t\t\tcount = limit((data[0].first).first, 0, r);\n\t\t\t\t} else {\n\t\t\t\t\tcount = limit((data[0].first).second, data[0].second, r);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((data[i-1].first).second != (data[i].first).first) {\n\t\t\t\t\tif ((data[i-1].first).second <= 0 && (data[i].first).first >= 0) {\n\t\t\t\t\t\tcount = 0.0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcount = min(count, min(limit((data[i-1].first).second, 0, r), limit((data[i].first).first, 0, r)));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcount = min(count, min(limit((data[i].first).first, data[i].second, r), limit((data[i].first).second, data[i].second, r)));\n\t\t\t\t}\n\t\t\t\tif (i == sz) {\n\t\t\t\t\tif ((data[i].first).second <= 0) {\n\t\t\t\t\t\tcount = 0.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcount = min(count, limit((data[i].first).second, 0, r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nbool is[40][21];\ndouble eps=1e-9;\nint main(){\n\twhile(true){\n\t\tint r,n;\n\t\tcin>>r>>n;\n\t\tif(n==0) break;\n\t\trep(i,40) rep(j,21) is[i][j]=0;\n\t\trep(i,n){\n\t\t\tint a,b,h;\n\t\t\tcin>>a>>b>>h;\n\t\t\ta+=20,b+=20;\n\t\t\tfor(int x=a;x<b;x++) rep(y,h) is[x][y]=true;\n\t\t}\n\t\tvector<double> vc;\n\t\trep(x,r) rep(y,22){\n\t\t\tif(x*x>=r*r) continue;\n\t\t\tdouble t=y-sqrt(r*r-x*x);\n\t\t\tvc.pb(t);\n\t\t}\n\t\tsort(all(vc));\n\t\trep(i,vc.size()){\n\t\t\tdouble h=vc[i];\n\t\t\tbool can=true;\n\t\t\tfor(int x=-r;x<r;x++) rep(y,21){\n\t\t\t\tif(is[x+20][y]) continue;\n\t\t\t\tif(x*x+(y-h)*(y-h)<r*r+eps) can=false;\n\t\t\t\tif((x+1)*(x+1)+(y-h)*(y-h)<r*r+eps) can=false;\n\t\t\t}\n\t\t\tif(!can){\n\t\t\t\tprintf(\"%.4f\\n\",h+r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconst int INF = (int)1e9;\nint main() {\n  while(true) {\n    int R, N; cin >> R >> N;\n    if(R == 0 && N == 0) break;\n    int H[201];\n    for(int i = 0; i < 201; ++i) H[i] = 0;\n    for(int i = 0; i < N; ++i) {\n      int l, r, h; cin >> l >> r >> h;\n      for(int j = l; j < r; ++j) {\n        H[j+100] = max(H[j+100], h);\n      }\n    }\n    double ans = 1e9;\n    H[-R+100-1] = INF;\n    H[R+100] = INF;\n    for(int i = -R; i <= R; ++i) {\n      int h = min(H[i+100-1], H[i+100]);\n      ans = min(ans, h-sqrt(max<double>(0.0, R*R-abs(i)*abs(i))));\n    }\n    cout.setf(ios::fixed);\n    cout.precision(4);\n    cout << ans +R << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<cctype>\n#include<queue>\n#include<deque>\n#include<regex>\n#include<stack>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<iomanip>\n\n#define rep(i, n) for(int i=0;i<n;i++)\n\ntypedef int long long ll;\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst ll MOD = 1e9 + 7;\nstatic const int MAX = 100;\nstatic const int INF = (1 << 23);\n\ndouble tans(int a,int b,int r){\n    double x=double(a);\n    double y=double(b);\n    double a1=1;\n    double b1=-1*y*2;\n    double c1=x*x+y*y-r*r;\n    double ans1=(-b1-sqrt(b1*b1-4*a1*c1))/2*a1;\n    double ans2=(-b1+sqrt(b1*b1-4*a1*c1))/2*a1;\n    double ans;\n    if(ans1>=0){\n        ans=min(ans1,ans2);\n    }else{\n        ans=ans2;\n    }\n    return ans;\n\n\n}\n\nint main() {\n\n    int r,n;\n    while(true){\n        cin>>r>>n;\n        if(r+n==0)break;\n        int x[41],x1[41],x2[41];\n        rep(i,41){x[i]=0;x1[i]=0;x2[i]=0;}\n        rep(i,n){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a+=20;b+=20;\n            for(int j=a;j<=b-1;j++){\n                x[j]=max(x[j],c);\n            }\n        }\n        for(int i=0;i<41;i++){\n           if(i==0){\n               x2[i]=x[0];\n               x1[i]=x[0];\n           }else if(i==40){\n               x1[i]=x[39];\n               x2[i]=x[39];\n           }else{\n               x1[i]=x[i-1];\n               x2[i]=x[i];\n           }\n        }\n\n        rep(i,41){\n            x1[i]+=r;\n            x2[i]+=r;\n        }\n\n        double t=INF;\n        for(int j=1+20-r;j<20+r;j++){\n            //cout<<abs(20-j)<<\" \"<<x1[j]<<\" \"<<x2[j]<<endl;\n            double t1=tans(abs(20-j),x1[j],r);\n            double t2=tans(abs(20-j),x2[j],r);\n           // cout<<t1<<t2<<endl;\n            t=min({t1,t2,t});\n        }\n\n        printf(\"%.4f\\n\",t);\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst int INF = 10000;\n\nint r, n;\nbool shade[30][50];\n\nint main() {\n  while (cin >> r >> n and r) {\n    REP(y,30) REP(x,50) shade[y][x] = false;\n    REP(y,30) shade[y][24-r] = shade[y][26+r] = true;\n    REP(i,n) {\n      int xl,xr,h;\n      cin >> xl >> xr >> h;\n      xl += 25, xr += 25;\n      for (int x = xl; x < xr; ++x) REP(y,h) shade[y][x] = true;\n    }\n    vector<pair<int,int>> minh;\n    for (int x = 25 - r; x < 25 + r; ++x) {\n      int y = 0;\n      while (shade[y][x] and shade[y][x-1]) y++;\n      minh.push_back(make_pair(x,y));\n    }\n    double ans = INF;\n    for (auto p : minh) {\n      double x = p.first, y = p.second;\n      ans = min(ans, y + (double)r - sqrt(r*r-(25-x)*(25-x)));\n    }\n    cout << fixed << setprecision(10) << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nint test(vector<G> &g,double t,double r){\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(PI/2.);\n\t\n\tfor(int i = 0 ; i < 720 ; i++)\n\t\tchkPoint.push_back(2.*i*PI/720);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t}\n\t\t\t//chkPoint.push_back(g[i][j]);\n\t\t}\n\t}\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tif( contains(g[j],pp) && contains(g[j],c.p+r*P(cos(th+1e-7),sin(th+1e-7))) != OUT && contains(g[j],c.p+r*P(cos(th+1e-7),sin(th-1e-7))) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\tg.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl-1e-7,0},{xr+1e-7,0},{xr+1e-7,h},{xl-1e-7,h}});\n\t\t}\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ndouble calctime(double x, double y, double r) {\n\tx = abs(x);\n\tif (x >= r) return 1e9;\n\treturn y - sqrt(r * r - x * x) + r;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint r, n; cin >> r >> n;\n\t\tif (!r && !n) break;\n\t\tmap<int, map<int, int>> filled;\n\n\t\trep(i, 0, n) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\trep(j, xl, xr) rep(k, 0, h) filled[j][k] = 1;\n\t\t}\n\n\t\tdouble t = 1e9;\n\t\trep(i, -20, 20) rep(j, 0, 21) if (!filled[i][j]) {\n\t\t\tif (i < 0) t = min(t, calctime(i + 1, j, r));\n\t\t\telse t = min(t, calctime(i, j, r));\n\t\t}\n\n\t\tcout << fixed << setprecision(9) << t << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int R, N;\n  while(cin >> R >> N, R){\n\tvector< vector<bool> > cv(50, vector<bool>(30, false));\n\tREP(i,N){\n\t  int l, r, h; cin >> l >> r >> h;\n\t  for(int y=0;y<h;++y)\n\t\tfor(int x=l;x<r;++x)\n\t\tcv[y][x+20] = true;\n\t}\n\t\n\tdouble lb = 0., ub = 20;\n\tREP(i,100){\n\t  double mid = (lb + ub) / 2.;\n\t  bool ok = true;\n\t  vector< vector<bool> > in(50, vector<bool>(30, false));\n\t  for(int y=1;y<=min(19,(int)mid-R);++y){\n\t\tfor(int x=-19;x<=0;++x){\n\t\t  if(x*x+(y-mid+R)*(y-mid+R) < R*R)\n\t\t\tin[y-1][x+20-1] = true;\n\t\t}\n\t\tfor(int x=0;x<20;++x){\n\t\t  if(x*x+(y-mid+R)*(y-mid+R) < R*R)\n\t\t\tin[y-1][x+20] = true;\n\t\t}\n\t  }\n\t  for(int y=max(0,1+(int)mid-R);y<20;++y){\n\t\tfor(int x=-19;x<=0;++x){\n\t\t  if(x*x+(y-mid+R)*(y-mid+R) < R*R)\n\t\t\tin[y][x+20-1] = true;\n\t\t}\n\t\tfor(int x=0;x<20;++x){\n\t\t  if(x*x+(y-mid+R)*(y-mid+R) < R*R)\n\t\t\tin[y][x+20] = true;\n\t\t}\n\t  }\n\t  \n\t  for(int y=0;y<20;++y)\n\t\tfor(int x=0;x<40;++x)\n\t\t  if(in[y][x] && !cv[y][x]) ok = false;\n\t  \n\t  if(ok) lb = mid;\n\t  else ub = mid;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint r,n;\nvoid solve() {\n    map<int,int> h;\n    double ans=INF;\n    rep(i,n) {\n        int x1,x2,t;\n        cin>>x1>>x2>>t;\n        for(int x=x1;x<x2;x++) h[x]=max(h[x],t);\n    }\n    for(int x=-r;x<r;x++) {\n        int x1=x;\n        double y=sqrt(r*r-x1*x1);\n        //printf(\"%d : %d %.10f\\n\",x,h[x],r-y);\n        ans=min(ans,h[x]+r-y);\n        x1++;\n        if(h.count(x1)) {\n            double y=sqrt(r*r-x1*x1);\n            //printf(\"%d : %d %.10f\\n\",x,h[x],r-y);\n            ans=min(ans,h[x]+r-y);\n        }\n    }\n\n    printf(\"%.10f\\n\",ans);\n}\nint main() {\n    while(cin>>r>>n) {\n        if(!r) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = 1'000'000'007; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194&lang=jp\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tconst int MAX = 60;\n\tconst int HALF = MAX/2;\n\t\n\twhile(true){\n\t\tlong double res = 1e10;\n\t\tint _height[MAX+10] = {};\n\t\tint *height = _height + HALF + 5;\n\t\tint r, n;\n\t\t\n\t\tcin>>r>>n;\n\t\t\n\t\tif(!r && !n) break;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\t\n\t\t\tcin>>xl>>xr>>h;\n\t\t\t\n\t\t\tfor(int j = xl; j < xr; j++){\n\t\t\t\theight[j] = max(height[j], h);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j = -r; j < r; j++){\n\t\t\tlong double dis1 = 0, dis2 = 0;\n\t\t\t\n\t\t\tdis1 = r - sqrt(r * r - j * j);\n\t\t\tdis2 = r - sqrt(r * r - (j + 1) * (j + 1));\n\t\t\t\n\t\t\tres = min(res, min(dis1, dis2) + height[j]);\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nllint r, n;\nllint L[25], R[25], h[25];\nllint len[25];\nbool used[105][25];\nllint zero = 52;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> r >> n;\n\t\tif(r == 0 && n == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 25; i++){\n\t\t\tfor(int j = 0; j < 105; j++){\n\t\t\t\tused[j][i] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> L[i] >> R[i] >> h[i];\n\t\t\tfor(int j = L[i]; j <= R[i]-1; j++){\n\t\t\t\tfor(int k = 1; k <= h[i]; k++){\n\t\t\t\t\tused[zero+j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(int i = 1; i < 10; i++){\n\t\t\tfor(int j = -10; j <= 10; j++){\n\t\t\t\tcout << used[zero+j][i] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\t\n\t\tfor(int i = 1; i < 25; i++){\n\t\t\tlen[i] = inf;\n\t\t\tfor(llint j = 0; j < 25; j++){\n\t\t\t\tif(!used[zero+j][i]){\n\t\t\t\t\tlen[i] = min(len[i], j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(llint j = 1; j < 25; j++){\n\t\t\t\tif(!used[zero-j][i]){\n\t\t\t\t\tlen[i] = min(len[i], j-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlen[0] = inf;\n\t\t//for(int i = 1; i < 25; i++) cout << len[i] << endl;\n\t\t\n\t\tdouble ans = inf;\n\t\tfor(int i = 1; i < 25; i++){\n\t\t\tif(len[i-1] <= len[i]) continue;\n\t\t\tif(len[i] >= r-1e-9) continue;\n\t\t\tdouble s = sqrt((double)r*r-len[i]*len[i]);\n\t\t\tans = min(ans, (i-1)-s+r);\n\t\t\t//cout<< i << \" \" << ans << endl;\n\t\t}\n\t\tprintf(\"%.11f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#undef max\n#undef min\n\nbool field[41][22] = {false};\nbool field2[20][22] = { false };\nconstexpr int SUN_OFFSET_X = 20;\nint main() {\n\tint r, n;\n\twhile (std::cin >> r >> n && (r || n)) {\n\t\tstd::memset(field, false, sizeof(bool) * 41 * 22);\n\t\tstd::memset(field2, false, sizeof(bool) * 20 * 22);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x[2], h;\n\t\t\tstd::cin >> x[0] >> x[1] >> h;\n\t\t\tx[0] += SUN_OFFSET_X; x[1] += SUN_OFFSET_X;\n\t\t\t//?????§???????????¶???\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tfor (int k = x[0]; k < x[1]; k++) {\n\t\t\t\t\tfield[k][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstd::vector<double> circleHeights;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t//?°??????????????????????x?????????????????£????????????????????????????????¨??????????????????\n\t\t\tfor (int j = 0; j < 21; j++) {\n\t\t\t\tfield2[19 - i][j] = field[i][j] && field[39 - i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\t//?????????????????????x??§???y=0?????????????¢????\n\t\t\t//h^2 + i^2 = r^2 \n\t\t\t//h^2 = r^2 - i^2\n\t\t\tcircleHeights.push_back(-r + std::sqrt(r  * r - i * i));\n\t\t}\n\n\t\tstd::vector<int> heights;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tint h = 0;\n\t\t\tfor (h = 0; h < 21; h++) {\n\t\t\t\tif (!field2[i][h]) break;\n\t\t\t}\n\t\t\theights.push_back(h);\n\t\t}\n\n\t\t//??¢???\n\t\tdouble y = -0.001;\n\t\tbool isOk = false;\n\t\tdouble cy = 0;\n\t\tfor (int i = 0; i < 21 && !isOk; i++) {\n\t\t\tdouble dy = 0;\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\tdouble tmp = heights[j] - circleHeights[i] - y;\n\t\t\t\tif (tmp > 0) dy = std::min(dy == 0 ? 99999 : dy, tmp);\n\t\t\t}\n\t\t\tif (!dy) dy = 1;\n\n\t\t\ty += dy;\n\t\t\t//?????£???????????°????????¢???\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\t//??????x??§??¢?????????????????????\n\t\t\t\tif (std::abs(heights[j] - (circleHeights[j] + y)) < 0.001) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << std::fixed << std::setprecision(4) << y << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\ndouble r;\n\nconst int OFFSET = 100;\nvector<pair<int, int> > events[200];\nint phs[200];\nint nhs[200];\nint main() {\n  while (scanf(\"%lf %d\", &r, &n) > 0 && r > 0) {\n    MEMSET(phs, 0);\n    MEMSET(nhs, 0);\n    REP(i, 200) { events[i].clear(); }\n    REP(i, n) {\n      int x1, x2, y;\n      scanf(\"%d %d %d\", &x1, &x2, &y);\n      events[x1 + OFFSET].push_back(make_pair(y, 1));\n      events[x2 + OFFSET].push_back(make_pair(y, -1));\n    }\n    multiset<int> ys;\n    for (int i = -50; i <= 50; i++) {\n      int py = 0;\n      if (ys.size() != 0) { py = *ys.rbegin(); }\n      FORIT(it, events[i + OFFSET]) {\n        int y = it->first;\n        int inout = it->second;\n        if (inout == 1) {\n          ys.insert(y);\n        } else {\n          ys.erase(ys.find(y));\n        }\n      }\n      int ny = 0;\n      if (ys.size() != 0) { ny = *ys.rbegin(); }\n      phs[i + OFFSET] = py;\n      nhs[i + OFFSET] = ny;\n    }\n    double ans = 1e+10;\n    for (int i = -r; i <= r; i++) {\n      double h = min(phs[i + OFFSET], nhs[i + OFFSET]);\n      if (i == -r) { h = nhs[i + OFFSET]; }\n      if (i ==  r) { h = phs[i + OFFSET]; }\n      double t = h + r - sqrt(r * r - i * i);\n      ans = min(ans, t);\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    while (true) {\n        int r,n; cin >> r >> n;\n        if (r == 0 && n == 0) break;\n\n        const int off = 30;\n        vector<int> _ht(2*off);\n        auto ht = _ht.begin() + off;\n        rep (i,n) {\n            int l,r,h; cin >> l >> r >> h;\n            loop (x,l,<r) chmax(ht[x],h);\n        }\n\n        double mi = INF;\n        loop (x,-r,<=r) {\n            if (abs(x) == r) continue;\n            double A = r-sqrt(double(r*r-x*x));\n            double B = min(ht[x-1],ht[x]);\n            chmin(mi, A+B);\n        }\n        cout << mi << \"\\n\";\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-5\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(inct (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R-eps)return false;\n\tif(y<c-R+eps)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.4f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define EPS 1e-9\n\nclass biru{\npublic:\n  double xl;\n  double xr;\n  double h;\n  biru(double a, double b, double c) {\n    xl = a;\n    xr = b;\n    h = c;\n  }\n};\n\ndouble r;\nbool crossCheck(double xc, double yc, double x1, double y1, double x2, double y2) {\n  return (hypot(xc-x1, yc-y1)-r < EPS ||\n\t  hypot(xc-x2, yc-y2)-r < EPS ||\n\t  (fabs((y2-y1)*xc+(x1-x2)*yc+(x2*y1-x1*y2))/hypot(x1-x2, y2-y1)-r < EPS &&\n\t   ((fabs(x1-x2) > EPS && (x1 <= xc && xc <= x2 || x2 <= xc && xc <= x1)) ||\n\t    (fabs(y1-y2) > EPS && (y1 <= yc && yc <= y2 || y2 <= yc && yc <= y1)) )));\n}\n\nbool compare(const biru a, const biru b) {\n  return a.xl < b.xl;\n}\n\nbool collision(double p, vector<biru> mbiru) {\n  bool ok = true;\n  if (-r < mbiru[0].xl) {\n    ok = !crossCheck(0, p, -r, 0, mbiru[0].xl, 0);\n  }\n\n  if (crossCheck(0, p, mbiru[0].xl, 0, mbiru[0].xl, mbiru[0].h)) ok = false;\n\n  if (crossCheck(0, p, mbiru[0].xl, mbiru[0].h, mbiru[0].xr, mbiru[0].h)) ok = false;\n  if (mbiru.size() >= 2) {\n    if (fabs(mbiru[0].xr-mbiru[1].xl) < EPS) {\n      if (crossCheck(0, p, mbiru[0].xr, mbiru[0].h, mbiru[0].xr, mbiru[1].h)) {\n\tok = false;\n      }\n    }else {\n      if (crossCheck(0, p, mbiru[0].xr, mbiru[0].h, mbiru[0].xr, 0)) {\n\tok = false;\n      }\n    }\n  }\n  for (int j = 1; j < mbiru.size(); j++) {\n    if (fabs(mbiru[j].xl-mbiru[j-1].xr) < EPS) {\n      if (crossCheck(0, p, mbiru[j].xl, mbiru[j].h, mbiru[j].xl, mbiru[j-1].h)) {\n\tok = false;\n      }\n\n    }else {\n      if (crossCheck(0, p, mbiru[j-1].xr, 0, mbiru[j].xl, 0) ||\n\t  crossCheck(0, p, mbiru[j].xl, 0, mbiru[j].xl, mbiru[j].h)) {\n\tok = false;\n      }\n    }\n    if (crossCheck(0, p, mbiru[j].xl, mbiru[j].h, mbiru[j].xr, mbiru[j].h)) {\n      ok = false;\n    }\n    if (j+1 < mbiru.size()) {\n      if (fabs(mbiru[j].xr-mbiru[j+1].xl) > EPS) {\n\tif (crossCheck(0, p, mbiru[j].xr, mbiru[j].h, mbiru[j].xr, 0)) {\n\t  ok = false;\n\t}\n      }\n    }else {\n      if (crossCheck(0, p, mbiru[j].xr, mbiru[j].h, mbiru[j].xr, 0)) {\n\tok = false;\n      }\n    }\n    if (!ok) break;\n  }\n  if (crossCheck(0, p, mbiru[mbiru.size()-1].xr, 0, 1000, 0)) {\n    ok = false;\n  }\n  return !ok;\n}\n\nint main() {\n  int tr, n;\n  while (cin >> tr >> n) {\n    if (tr == 0 && n == 0) break;\n    if (n == 0) {\n      std::cout << 0 << std::endl;\n      continue;\n    }\n    r = (double)tr-0.00001;\n    bool field[41][21];\n    memset(field, false, sizeof(field));\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n      for (int j = 0; j < h; j++) {\n\tfor (int k = xl; k < xr; k++) {\n\t  field[k+20][j] = true;\n\t}\n      }\n    }\n    // for (int i = 0; i < 20; i++) {\n    //   for (int j = 0; j < 40; j++) {\n    // \tstd::cout << field[j][i];\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n    vector <biru> mbiru;\n    for (int i = 0; i < 41; i++) {\n      if (field[i][0]) {\n\tint h;\n\tfor (int j = 0; field[i][j]; j++) {\n\t  h = j+1;\n\t}\n\tmbiru.push_back(biru(i-20, i-20+1, h));\n      }\n    }\n    // for (int i = 0; i < mbiru.size(); i++) {\n    //   std::cout << mbiru[i].xl << \" \" << mbiru[i].xr << \" \" << mbiru[i].h << std::endl;\n    // }\n\n    double lp = -200, rp = 0;\n    for (int i = -20; i < 100; i++) {\n      rp = double(i);\n      if (collision(rp, mbiru)) {\n\tbreak;\n      }\n    }\n\n    double p;\n    for (int i = 0; i < 100; i++) {\n      p = (lp+rp)/2;\n      if (collision(p, mbiru)) {\n\trp = p;\n      }else {\n\tlp = p;\n      }\n    }\n    printf(\"%lf\\n\", lp+r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=(-x-0.9999),R=(x+0.9999),hb[101]={};\n\n  for(int i=L+50;i<R+50;i++){\n    int x1=i-49-i/50;\n    double y1=y[i]-cy;\n    if(sqrt(x1*x1+y1*y1)>=r)hb[i]++;\n  }\n  for(int i=L+50;i<R+50;i++)if(!hb[i])return 0;\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<100;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.0009;\n    cout << ans-0.0009<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<i_i, int> p_i;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n    int len = v.size();\n    for (int i = 0; i < len; ++i) {\n        s << v[i]; if (i < len - 1) s << \"\\t\";\n    }\n    return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n    int len = vv.size();\n    for (int i = 0; i < len; ++i) {\n        s << vv[i] << endl;\n    }\n    return s;\n}\n\nint main() {\n    while (true) {\n        int r, n;\n        cin >> r >> n;\n        if ( r == 0 ) { break; }\n        map<int, int> maxh;\n        rep (i, n) {\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            FOR (x, xl, xr) {\n                maxh[x] = max(maxh[x], h);\n            }\n        }\n        double mintime = 10000.0;\n        FOR (x, -r+1, r) {\n            double starth = sqrt(r*r - x*x) - r;\n            int endh;\n            if ( x < 0 ) {\n                endh = maxh[x-1];\n            } else if ( x == 0 ) {\n                endh = min(maxh[-1], maxh[0]);\n            } else {\n                endh = maxh[x];\n            }\n            mintime = min(mintime, endh-starth);\n        }\n        printf(\"%f\\n\", mintime);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nstruct Circle{\n  double r;\n  P c;\n  Circle(){}\n  Circle(double r,P c): r(r),c(c) {}\n};\n\nconst double INF = 1e+8;\nconst double EPS = 1e-8;\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint contains(vector<P> v, P p){ \n  bool in = false; \n  for(int i=0;i<v.size();i++){ \n    P a = v[i] - p; \n    P b = v[(i+1)%v.size()] - p; \n    if(imag(a) > imag(b)) swap(a,b); \n    if(imag(a) <= EPS && EPS < imag(b)) \n      if(cross(a,b) < -EPS) in = !in; \n    if(equal(cross(a,b), 0.0) && dot(a,b) < EPS) return 1; \n  } \n  return in ? 2 : 0; \n} \n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nbool isIntersectCS(Circle c, L s){\n  P h = proj(c.c, s);\n  double d = abs(c.c - h);\n  \n  if(d > c.r + EPS) return false;\n  else if(d > c.r - EPS){\n    //return isIntersectSP(s,h);\n    return false;\n  }\n  else {\n    P v = s.second - s.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    if(isIntersectSP(s, h+v)) return true;\n    if(isIntersectSP(s, h-v)) return true;\n    return false;\n  }  \n}\n\n\nint n,r;\nvector<int> v[50];\nvector<P> line;\n\nbool check(Circle c){ \n  if(contains(line, c.c) == 0) return false;\n  for(int i=0;i<line.size();i++){\n    if(abs(line[i] - c.c) < c.r - EPS || isIntersectCS(c, L(line[i],line[(i+1)%line.size()]))) return false;\n  }\n  return true;\n}\n\nvoid solve(){\n  for(int i=0;i<50;i++){\n    v[i].push_back(0);\n    sort(v[i].begin(), v[i].end(), greater<int>());      \n  }\n  \n  line.clear();\n  for(int i=49;i>=0;i--){\n    if(i != 49 && v[i][0] != v[i+1][0]) line.push_back(P(i-24, v[i][0]));\n    line.push_back(P(i-25, v[i][0]));\n  }\n  line.push_back(P(-INF, 0));\n  line.push_back(P(-INF, -INF));\n  line.push_back(P(INF, -INF));\n  line.push_back(P(INF, 0));\n\n  double st = 0.0, ed = INF, mid;\n  while(!equal(ed,st)){\n    mid = (st + ed) / 2.0;\n    Circle c = Circle(r, P(0, mid - (double)r));\n    if(check(c)) st = mid;\n    else ed = mid;\n  }\n  \n  printf(\"%.7f\\n\", mid);\n}\n\nint main(){\n  while( cin >> r >> n && (r|n) ){\n    for(int i=0;i<50;i++) v[i].clear();\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin >> x1 >> x2 >> h;\n      for(int j=x1;j<x2;j++) v[j+25].push_back(h);\n    }\n    \n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(ll i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(ll i=(a),i##_cond=(b);i<i##_cond;++i)\n#define ROF(i,a,b) for(ll i=(a)-1,i##_cond=(b);i>=i##_cond;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define UNIQUE(v) v.erase(unique(all(v)),v.end())\n#define SUM(a) accumulate(all(a),0)\n#define sz(x) ((ll)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<ll,ll> pii;\n\nconst ll inf = 1ll<<62;\nconst ll mod = 1e9+7;\n\nint main(){\n#define int ll\n  while(1){\n    int r,n; cin >> r >> n;\n    if(r == 0 and n == 0) break;\n    map<int,int> maxh;\n    FOR(i,-r-1,r+2) maxh[i];\n    rep(i,n){\n      int nl,nr,h;\n      cin >> nl >> nr >> h;\n      FOR(j,nl,nr) maxh[j] = max(maxh[j], h);\n    }\n    if(maxh[r] == 0) maxh[r] = maxh[r-1];\n    ROF(i,r,-r+1) maxh[i] = min(maxh[i], maxh[i-1]);\n    dump(maxh);\n    double ans = inf;\n    FOR(i,-r,r+1){\n      ans = min(ans, maxh[i] - sqrt(pow(r, 2) - pow(i, 2)));\n    }\n    printf(\"%.10f\\n\",ans + r);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tdouble r;\n\t\tdouble center;\n\t\tdouble high;\n\t\tdouble answer = 20.0;\n\t\tint n;\n\t\tdouble xl[21] = {}, xr[21] = {}, h[21] = {};\n\n\t\tcin >> r >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t}\n\n\n\t\tfor (double i = 0; i <= 20.0; i += 0.0001) {\n\t\t\tcenter = -r + i;\n\n\t\t\tfor (double j = -r; j <= r; j += 0.0001) {\n\t\t\t\thigh = sqrt(r*r - j * j) + center;\n\n\t\t\t\t//cout << center << \" \" << high << endl;\n\n\t\t\t\tFOR(k, 1, n) {\n\t\t\t\t\tif (xl[k] <= j && xr[k] >= j && high <= h[k]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (high <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (k == n) {\n\t\t\t\t\t\tanswer = i - 0.0001;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (answer != 20.0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (answer != 20.0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\", answer);\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r, h;\n  double xl, xr, ans;\n  vector<int> V(41,0);  \n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  double r;\n  int n;\n  double ans;\n  double left,right,h;\n\n  while(1){\n    cin >> r >> n;\n    if(r==0) break;\n    ans=21;\n    vector<double> takasahidari(41,0),takasamigi(41,0);\n    for(int i=0;i<n;i++){\n      cin >> left >> right >> h;\n      for(int j=left;j<right;j++){\n        takasahidari[j+20]=max(takasahidari[j+20],h);\n      }\n      for(int j=left+1;j<=right;j++){\n        takasamigi[j+20]=max(takasamigi[j+20],h);\n      }\n    }\n    /*\n    for(int i=0;i<41;i++){\n      cout << takasahidari[i] << \" \";\n    }\n    cout << endl;\n    for(int i=0;i<41;i++){\n      cout << takasamigi[i] << \" \";\n    }\n    cout << endl;\n    */\n    for(int i=20-r;i<=20+r;i++){\n      /*\n      if(ans>min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20))){\n        cout << \"(\" << i-20 << \",\" << min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)) << \")\" << endl;\n      }\n      */\n      if(takasahidari[i]>0&&takasamigi[i]>0){\n        ans=min(ans,min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)));\n      }else{\n        ans=min(ans,r-sqrt(r*r-(i-20)*(i-20)));\n      }\n\n\n\n    }\n    if(ans==21){\n      ans=0;\n    }\n    cout << fixed<<setprecision(6)<<ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\n\nint main(){\n\tint R, n;\n\n\tcin >> R >> n;\n\twhile(!(R==0 && n==0) ){\n\t\tint pos[41][2]={ {0, 0} };\n\t\tint l, r, h;\n\t\tF(i, n){\n\t\t\tcin >> l >> r >> h;\n\t\t\tfor(int j=l+20; j<=r+20; j++){\n\t\t\t\tint tmph=h;\n\t\t\t\tif(j!=l+20 && j!=r+20){\n\t\t\t\t\tif(tmph > pos[j][0]){\n\t\t\t\t\t\tpos[j][0]=tmph;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmph > pos[j][1]){\n\t\t\t\t\t\tpos[j][1]=tmph;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(tmph > pos[j][0])swap(tmph, pos[j][0]);\n\t\t\t\t\tif(tmph > pos[j][1])swap(tmph, pos[j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble min=100;\n\t\tfor(int i=20-R+1; i<=20+R-1; i++){\n\t\t\tdouble tmp=pos[i][1]-sqrt(static_cast<double>(R*R-(i-20>0 ? i-20:20-i)*(i-20>0 ? i-20:20-i) ) );\n\t\t\tif(min > tmp)min = tmp;\n\t\t}\n\t\tif(min <= -R){\n\t\t\tmin = 0;\n\t\t}else{\n\t\t\tmin = min+R;\n\t\t}\n\t\tcout << min << endl;\n\n\t\tcin >> R >> n;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int r, n;\n    while (cin >> r >> n, r || n)\n    {\n        map<int, int> ma;\n        for (int i = 0; i < n; i++)\n        {\n            int lx, rx, h;\n            cin >> lx >> rx >> h;\n            for (int j = lx; j < rx; j++)\n            {\n                ma[j] = max(ma[j], h);\n            }\n        }\n        map<int, ld> mi;\n        mi[-r] = ma[-r];\n        mi[r] = ma[r - 1];\n        for (int i = -r + 1; i <= r - 1; i++)\n        {\n            mi[i] = min(ma[i - 1], ma[i]);\n        }\n        ld last = 0;\n        while (true)\n        {\n            bool check = true;\n            last += 0.001;\n            for (int i = -r; i <= r; i++)\n            {\n                ld pos = -r + last + sqrt(r * r - i * i);\n                if (pos > mi[i] + EPS)\n                    check = false;\n            }\n            if (check)\n                continue;\n            last -= 0.001;\n            break;\n        }\n        cout << last << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\t\t\n\t\tmap<int, int> d;\n\t\tfor (int x = -21; x < 21; x++)d[x] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor (int x = xl+1; x <= xr; x++)d[x] = max(d[x], h);\n\t\t}\n\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-4/2){\n\n\t\t\t/*\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\t*/\n\t\t\tint tx = (x >= 0 ? int(x + (1.0 - 1e-7)) : int(x));\n\t\t\tif (x == -r)tx++;\n\t\t\tdouble ty = double(r) - sin(acos(abs(x / double(r)))) * double(r);\n\n\t\t\tans = min(ans, double(d[tx]) + ty);\n\t\t}\n\n\t\tcout << setprecision(6) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\t\t\n\t\tmap<int, int> d;\n\t\tfor (int x = -21; x < 21; x++)d[x] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor (int x = xl+1; x <= xr; x++)d[x] = max(d[x], h);\n\t\t}\n\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-4/3){\n\n\t\t\t/*\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\t*/\n\t\t\tint tx = (x >= 0 ? int(x + (1.0 - 1e-7)) : int(x));\n\t\t\tif (x == -r)tx++;\n\t\t\tdouble ty = double(r) - sin(acos(abs(x / double(r)))) * double(r);\n\n\t\t\tans = min(ans, double(d[tx]) + ty);\n\t\t}\n\n\t\tcout << setprecision(6) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS) return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nvoid vis2(P p){\n\tprintf(\"plot(%.5lf,%.5lf,0)\\n\",p.real(),p.imag());\n}\nint test(vector<G> &g,double t,double r){\n\tr -= 1e-4;\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(0);\n\tchkPoint.push_back(PI/2.);\n\tchkPoint.push_back(3*PI/2.);\n\tchkPoint.push_back(2*PI/2.);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tx = x - c.p;\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"cir(\" << c.p.real() << \",\" << c.p.imag() << \",\" << r << \")\" << endl;\n\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tP p1 = c.p+r*P(cos(th+1e-4),sin(th+1e-4));\n\t\t\tP p2 = c.p+r*P(cos(th-1e-4),sin(th-1e-4));\n\t\t\t//vis2(p1);\n\t\t\t//vis2(p2);\n\t\t\t//vis2(pp);\n\t\t\tif( contains(g[j],pp) && contains(g[j],p1) != OUT && contains(g[j],p2) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if(flag) vis2(pp);\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nvoid vis(G g){\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tcout << \"line(\" << curr(g,i).real() << \",\" << curr(g,i).imag() << \",\" << next(g,i).real() << \",\" << next(g,i).imag() << \")\" << endl;\n\t}\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\t//g.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl-1e-3,0},{xr+1e-3,0},{xr+1e-3,h},{xl-1e-3,h}});\n\t\t\t//vis(g[i]);\n\t\t}\n\t\t\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\t\t\n\t\tmap<int, int> d;\n\t\tfor (int x = -21; x < 21; x++)d[x] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor (int x = xl; x < xr; x++)d[x] = max(d[x], h);\n\t\t}\n\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-5/3.0){\n\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\tint tx = (x >= 0 ? int(x) : int(x - (1.0 - 1e-7)));\n\t\t\tans = min(ans, double(d[tx]) - y);\n\n\t\t}\n\n\t\tcout << setprecision(6) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint _h[40], h[20];\n\ndouble calc()\n{\n\tdouble res = 1e8;\n\tfor (int i = 0; i < 20; i++){\n\t\tdouble height = i < r ? sqrt(r * r - i * i) - r : -1e8;\n\t\tres = min(res, h[i] - height);\n\t}\n\treturn max(0.0, res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &r, &n), r){\n\t\tmemset(_h, 0, sizeof(_h));\n\t\tmemset(h, 0, sizeof(h));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tfor (int j = a + 20; j < b + 20; j++){\n\t\t\t\t_h[j] = max(_h[j], c);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 20; i++){\n\t\t\th[i] = min(_h[i + 20], _h[19 - i]);\n\t\t}\n\t\t\n\t\tprintf(\"%.20f\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define DELTA\t((double)1e-10)\n#define DIV\t(40003)\n#define PIDIV\t(M_PI / DIV)\n\n#define MAX_N\t(20)\n#define MAX_T\t(20.0)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nstruct rect_t {\n  double x0, x1, h;\n};\n\n/* global variables */\n\nint r, n;\nrect_t rects[MAX_N];\ndouble cosd[DIV + 1], sind[DIV + 1];\n\n/* subroutines */\n\nbool visible(double t) {\n  double y0 = t - r;\n  for (int d = 0; d <= DIV; d++) {\n    double y = r * sind[d] + y0;\n    if (y <= 0.0) continue;\n\n    double x = r * cosd[d];\n\n    bool covered = false;\n    for (int i = 0; i < n; i++) {\n      if (x >= rects[i].x0 && x <= rects[i].x1 && y <= rects[i].h) {\n\tcovered = true;\n\tbreak;\n      }\n    }\n\n    if (! covered) return true;\n  }\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  for (int d = 0; d <= DIV; d++) {\n    double th = PIDIV * d;\n    cosd[d] = cos(th);\n    sind[d] = sin(th);\n  }\n\n  for (;;) {\n    cin >> r >> n;\n    if ((r | n) == 0) break;\n\n    for (int i = 0; i < n; i++)\n      cin >> rects[i].x0 >> rects[i].x1 >> rects[i].h;\n\n    double t0 = 0;\n    double t1 = MAX_T;\n\n    while (t1 - t0 > DELTA) {\n      double t = (t0 + t1) / 2;\n      if (visible(t))\n\tt1 = t;\n      else\n\tt0 = t;\n    }\n\n    printf(\"%.4lf\\n\", t0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ndouble w[2][44];\ndouble s[44];\nint r;\nint n;\nint x1,x2,h;\ndouble nkr;\ndouble a[3];\n\nmain(){\n  while(cin >> r >> n,r||n){\n    nkr=-1;\n    for(int i=0;i<2;i++)for(int j=0;j<44;j++) w[i][j]=0;\n\n    for(int i=0;i<n;i++){\n      cin >> x1 >> x2 >> h;\n\n      if(w[0][x2+20]<h || w[0][x2+20]==0) w[0][x2+20]=h;\n      if(w[1][x1+20]<h || w[1][x1+20]==0) w[1][x1+20]=h;\n      for(int j=x1+21;j<x2+20;j++){\n\tif(w[0][j]<h || w[0][j]==0) w[0][j]=h;\n\tif(w[1][j]<h || w[1][j]==0) w[1][j]=h;\n      }\n\n    }\n    \n    nkr=w[1][20-r]+r;\n    for(int i=r*(-1)+1;i<r;i++){\n      s[i+20]=sqrt(r*r-i*i)-r;\n      if(w[0][i+20]-s[i+20]<nkr) nkr=w[0][i+20]-s[i+20];\n      if(w[1][i+20]-s[i+20]<nkr) nkr=w[1][i+20]-s[i+20];\n    }\n    if(w[0][20+r]+r<nkr) nkr=w[0][20+r]+r;\n\n    \n\n    printf(\"%.4f\\n\",nkr);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\n/*\n\nTodo:\nLine??¨Segment?????????????????????\n\n*/\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\n#define idx(i) (i+25)\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nsigned main() {\n\tcout << fixed << setprecision(6);\n\tfor (int r, n; cin >> r >> n&&r;) {\n\t\tint Hl[50] = {};\n\t\tint Hr[50] = {};\n\t\trep(i, 0, n) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\trep(j, xl, xr) {\n\t\t\t\tchmax(Hl[idx(j)], h);\n\t\t\t}\n\t\t\trep(j, xl + 1, xr + 1) {\n\t\t\t\tchmax(Hr[idx(j)], h);\n\t\t\t}\n\t\t}\n\t\tdouble miny = INF;\n\t\tLine L(Point(0, 0), Point(0, 1));\n\t\trep(x, -20, 20 + 1) {\n\t\t\tCircle C(Point(x, min(Hl[idx(x)], Hr[idx(x)])), r);\n\t\t\tif (!intersect(C, L))continue;\n\t\t\tauto cp = get_cross_points(C, L);\n\t\t\tif (cp.first == cp.second)continue;\n\t\t\tchmin(miny, cp.first.y);\n\t\t\tchmin(miny, cp.second.y);\n\t\t}\n\t\tcout << max(-(double)r, miny) + r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this); \n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto dist = distance_lp(l, c);\n  if(dist > c.r + EPS) { return {{-inf,-inf},{-inf,-inf}}; }\n  auto basehalf = sqrt(c.r * c.r - dist * dist);\n  P v = (l[1]-l[0]) * P(0, 1);\n  Line h(c, c+v); P ph = crosspoint(l, h);\n  P u1 = (ph + v) * P(0, 1); u1 /= abs(u1); u1 *= basehalf;\n  P u2 = (ph + v) * P(0, -1); u2 /= abs(u2); u2 *= basehalf;\n  return {u1, u2};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  for(int R, N; cin >> R >> N && (R | N);) {\n    vector<int> hs(44); int const OF = 22;\n    rep(i, N) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      REP(x, xl, xr) {\n        maximize(hs[x+OF], h);\n      }\n    }\n    vector<P> events;\n    int currh = 0;\n    events.emplace_back(-22, 0);\n    REP(x, -21, 22) {\n      if(currh != hs[x+OF]) {\n        events.emplace_back(x, currh);\n        currh = hs[x+OF];\n        events.emplace_back(x, currh);\n      }\n      else {\n        events.emplace_back(x, currh);\n      }\n    }\n\n//    for(auto && e: events) { cout << e << endl; } cout << endl;\n\n    Circle c(P(0, -R), R);\n\n    for(double t=0; t<=20; t+=0.00005) {\n      bool ok = 0;\n      rep(i, events.size()) {\n        if(abs(c - events[i]) < c.r) {\n          printf(\"%.10f\\n\", t);\n          ok = 1;\n          break;\n        }\n      }\n      if(ok) { break; }\n      c.cent[1] += 0.00005;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint nextInt() { int d; cin >> d; return d; }\n\nconst double EPS = 10e-6;\n\nstruct Rect {\npublic:\n  int height;\n  int xl, xr;\n  \n  Rect() { }\n  Rect(int xl, int xr, int height):\n    xl(xl), xr(xr), height(height) { }\n};\n\nstruct Point {\npublic:\n  double y, x;\n  Point() { }\n  Point(double y, double x): y(y), x(x) { }\n};\n\nbool judge(const vector<Point>& point, const int r, const double y) {\n  for (int i = 0; i < point.size(); i++) {\n    double dsq = (point[i].x * point[i].x) + ((point[i].y - y) * (point[i].y - y));\n    if (r * r - dsq > 0) {\n      return false;\n    }\n  }\n  \n  return true;  \n}\n\nint main() {\n  while (true) {\n    int r = nextInt();\n    int n = nextInt();\n    if (r + n == 0) {\n      break;\n    }\n    vector<Rect> rect(n);\n    int ymax = -1;\n    for (int i = 0; i < n; i++) {\n      int xl = nextInt();\n      int xr = nextInt();\n      int h  = nextInt();\n      ymax = max(ymax, h);\n      rect[i] = Rect(xl, xr, h);\n    }    \n  \n    sort(rect.begin(), rect.end(), [](Rect a, Rect b) {\n      if (a.xl == b.xl) {\n        return a.xr < b.xr;\n      }\n      return a.xl < b.xl;\n    });\n    \n    for (int i = 0; i < n; i++) {\n      Rect& a = rect[i];\n      for (int j = i + 1; j < n; j++) {\n        Rect& b = rect[j];\n        if (a.xr > b.xr && a.xl < b.xl) {\n          // 3????????????\n          rect.push_back(Rect(b.xr, a.xr, a.height));\n          a.xr = b.xl;\n        } else if (a.xr > b.xl) {\n          if (a.xl == b.xl) {\n             b.xl = a.xr;\n          } else if (a.xr == b.xr) {\n            a.xr = b.xl;            \n          }        \n        }\n      }\n    }\n    \n    vector<Point> point;\n    \n    point.push_back(Point(0, rect[0].xl));\n    point.push_back(Point(rect[0].height, rect[0].xl));\n    \n    for (int i = 1; i < rect.size(); i++) {\n      if (rect[i - 1].xr != rect[i].xl) {\n        point.push_back(Point(0, rect[i].xl));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xl));\n    }\n    \n    point.push_back(Point(0, rect[rect.size() - 1].xr));\n    point.push_back(Point(rect[rect.size() - 1].height, rect[rect.size() - 1].xr));\n    \n    for (int i = 0; i < rect.size() - 1; i++) {\n      if (rect[i + 1].xl != rect[i].xr) {\n        point.push_back(Point(0, rect[i].xr));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xr));\n    }\n    \n    double lt = 0, ht = ymax;\n    \n    for (int i = 0; i < 100; i++) {\n      double mt = (lt + ht) / 2;\n      double y = -r + mt;\n      if (judge(point, r, y)) {\n        lt = mt;\n      } else {\n        ht = mt;\n      }\n    }    \n    printf(\"%.15f\\n\", ht);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\n    while(true){\n\n        double r;\n        int n;\n\n        cin >> r >> n;\n\n        if(r == 0.0 && n == 0){\n            break;\n        }\n\n        int x[41] = {0};\n\n        for(int i=0; i<n; i++){\n            int lx,ly,h;\n\n            cin >> lx >> ly >> h;\n\n            for(int i=20+lx; i<20+ly; i++){\n                x[i] = max(x[i],h);\n            }\n        }\n        double ans = 0.000;\n\n        while(true){\n\n            double survey = ans + 0.001;\n\n            bool flag = true;\n\n            for(int i=-20; i<=20; i++){\n                double d_x = static_cast<double>(i);\n                if(r*r > d_x*d_x){\n                    double h = sqrt(r*r - d_x*d_x) + survey - r;\n                    if(h > x[i+20] || h > x[i+20 -1]){\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n\n            if(!flag){\n                break;\n            }\n\n            ans += 0.001;\n\n        }\n\n        cout << fixed << setprecision(4) << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int R, N;\n  while(cin >> R >> N, R){\n\tVVI hs(50, VI(50, 0));\n\tREP(i,N){\n\t  int l, r, h; cin >> l >> r >> h;\n\t  for(int x=l;x<r;++x)\n\t\ths[x+20][x+20+1] = max(hs[x+20][x+20+1], h);\n\t}\n\t\n\tdouble ans = 0.;\n\tfor(;1;){\n\t  bool ok = true;\n\t  double y = ans - R;\n\t  for(int x=-20;x<=20;++x){\n\t\tint h = hs[x+20][x+20+1];\n\t\tif(x*x + (h-y)*(h-y) < R*R || (x+1)*(x+1)+(h-y)*(h-y)<R*R)\n\t\t  ok = false;\n\t  }\n\t  if(!ok) break;\n\t  ans += 0.0001;\n\t}ans -= 0.0001;\n\tcout << fixed << setprecision(9) << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint r,n,L,R,h,i,x;\n\nint main(){\n\t\n\twhile(cin>>r>>n,r){\n\n\t\t\n\t\tint A[41]={},B[41]={};\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>L>>R>>h;\n\t\t\tfor(x=L;x<=R;x++){\n\t\t\t\tif(x!=R)A[x+20]=max(A[x+20],h);\n\t\t\t\tif(x!=L)B[x+20]=max(B[x+20],h);\n\t\t\t}\t\n\t\t}\n\t\tdouble res=99;\n\t\tfor(i=-r;i<=r-1;i++){\n\t\t\tres=min(res,min(r-sqrt(r*r-i*i)+A[i+20],r-sqrt(r*r-(i+1)*(i+1))+B[i+1+20]));\n\t\t}\n\t\tcout<<res<<\"\\n\";\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\ndouble R;\nint n;\nint base = 50;\nbool building[55][100];\ndouble solve(){\n    fill(*building,*building+100*55,0);\n    double res = 0;\n    vector<int> xl(n),xr(n),h(n);\n    for(int i = 0; i < n;i++) cin >> xl[i] >> xr[i] >> h[i];\n    for(int i = 0; i < n;i++){\n        xl[i] += base; xr[i] += base;\n        for(int j = xl[i]; j < xr[i];j++){\n            for(int k = 0; k < h[i];k++){\n                building[k][j] = true;\n            }\n        }\n    }\n//    for(int i = 10; i >= 0; i--){\n//        for(int j = 40; j <= 60; j++){\n//            cout << building[i][j];\n//        }\n//        cout << endl;\n//    }\n    \n    double l = 0,r = 50;\n    for(int i = 0; i < 50;i++){\n        double m = (l+r)/2;\n        bool ok = true;\n        for(int x = -R; x < 0; x++){\n            double from = R - sqrt(R*R-(abs(x)-1)*(abs(x)-1));\n            double H = m - from;\n            if(H < 0) continue;\n            if(building[(int)H][x+base] == 0) ok = false;\n        }\n        for(int x = 0; x < R; x++){\n            double from = R - sqrt(R*R-x*x);\n            double H = m - from;\n            if(H < 0) continue;\n            if(building[(int)H][x+base] == 0) ok = false;\n        }\n        if(ok){\n            l = m;\n        }else{\n            r = m;\n        }\n    }\n    res = l;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> R >> n){\n        if(n == 0 && R < 1e-9) break;\n        cout << fixed << setprecision(4) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long  ll;\n\nconst int offset = 20;\ndouble r; // ??????????????????1 <= r <= 20???\nint n; // ?????????????????¨??????????????°???0 <= n <= 20???\n\nbool C(double t, const vector<double> &h)\n{\n    const int lx = offset - r, rx = offset + r;\n    double x0 = offset, y0 = -r + t; // ????????????\n\n    // ??????[x, x+1]??????????????????????????????????????????????????????\n    for (int x = lx; x < rx; ++x) {\n        double tmp_x1 = (x - x0) * (x - x0);\n        double c_y1 = sqrt(r * r - tmp_x1) + y0;\n        double tmp_x2 = (x + 1.0 - x0) * (x + 1.0 - x0);\n        double c_y2 = sqrt(r * r - tmp_x2) + y0;\n\n        if (h[x] < c_y1 || h[x] < c_y2)\n            return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(8) << setiosflags(ios::fixed); // printf(\"%.4f\", x);\n\n    while (cin >> r >> n) {\n        if (r == 0 && n == 0)\n            break;\n\n        vector<double> h(41, 0);\n        int xl, xr;\n        double tmp_h;\n        for (int i = 0; i < n; ++i) {\n            cin >> xl >> xr >> tmp_h;\n            xl += offset;\n            xr += offset;\n            for (int x = xl; x < xr; ++x)\n                h[x] = max(h[x], tmp_h);\n        }\n\n        double lb = 0.0, ub = 100.0;\n        for (int i = 0; i < 100; ++i) {\n            double mid = (lb + ub) * 0.5;\n            if (C(mid, h))\n                lb = mid;\n            else\n                ub = mid;\n        }\n\n        cout << ub << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint r, n, xl, xr, h;\n\nint main(void) {\n  while(cin >> r >> n, r && n) {\n    map<pii, bool> m;\n    int mh = 0;\n    REP(i, 0, n) {\n      cin >> xl >> xr >> h;\n      REP(j, 0, h) REP(k, xl, xr) m[pii(j, k)] = true;\n      mh = max(mh, h);\n    }\n\n    // REP(i, 0, mh) {\n    //   REP(j, -r, r) {\n    //     cout << (m[pii(i, j)] ? 1 : 0);\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n\n    int y, x;\n    REP(i, 0, mh) {\n      REP(j, -r, r) {\n        if(!m[pii(i, j)]) {\n          y = i;\n          x = j;\n          goto BREAK;\n        }\n      }\n    }\nBREAK:\n\n    if(x < 0) x = -x - 1;\n    // cout << y << \" \" << x << endl;\n\n    double t = y - sqrt(r * r - x * x) + r;\n    printf(\"%.4f\\n\", max(0.0, t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint xl[20], xr[20], h[20];\nint main() {\n\tint R, n;\n\twhile (cin >> R >> n,R) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t}\n\t\tdouble l = 0, r = 60;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tdouble m = (l + r) / 2;\n\t\t\tbool OK = 1;\n\t\t\tfor (int j = 0; j <= 10000; j++) {\n\t\t\t\tdouble x = -R + (2 * R) / 10000.0 * j;\n\t\t\t\tint Max = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (xl[k] <= x&&x <= xr[k]) {\n\t\t\t\t\t\tMax = max(Max, h[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble H = sqrt(R*R - x*x) + m - R;\n\t\t\t\tif (Max < H) {\n\t\t\t\t\tOK = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (OK) l = m; else r = m;\n\t\t}\n\t\tcout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid run(int r, int n) {\n\tvector< int > s(n), t(n), h(n);\n\tfor (int i=0; i<n; ++i) cin >> s[i] >> t[i] >> h[i];\n\t\n\tdouble ans = 1e9;\n\tfor (int x=-r; x<=r; ++x) {\n\t\tint hx = 0;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tif (abs(x) == r && (s[i] == r || t[i] == r)) hx = max(hx, h[i]);\n\t\t\telse if (s[i] < x && x < t[i]) hx = max(hx, h[i]);\n\t\t}\n\t\tfor (int i=0; i<n; ++i) for (int j=0; j<n; ++j) if (i != j && t[i] == s[j] && t[i] == x) hx = max(hx, min(h[i], h[j]));\n\t\tans = min(ans, r - (double)r * sin(acos((double)x / r)) + hx);\n\t}\n\t\n\tprintf(\"%.5lf\\n\", ans);\n}\n\nint main() {\n\tint r, n;\n\twhile (cin >> r >> n, r) run(r, n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 2*r+1; ++i) V[i] = 0;\n    double ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j < -r) continue;\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i-1] + r - sqrt(r*r - (i-r)*(i-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ndouble r;\nint n;\n\nconst int CENTER = 25;\ndouble h[50] = { 0 };\n\nbool check(double k) {\n    for (int i = 0; i <= 20; i++) {\n        double x = i;\n        if (r <= x) continue;\n        double y = sqrt(r * r - x * x);\n        y += -r + k;\n        if (y > h[CENTER + i]) {\n            return false;\n        }\n    }\n    for (int i = -20; i <= -1; i++) {\n        double x = i + 1;\n        if (r <= abs(x)) continue;\n        double y = sqrt(r * r - x * x);\n        y += -r + k;\n        if (y > h[CENTER + i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid solve() {\n    fill(h, h + 50, 0);\n    for (int i = 0; i < n; i++) {\n        int x1, x2;\n        double hh;\n        cin >> x1 >> x2 >> hh;\n        for (int i = x1; i < x2; i++) {\n            h[i+CENTER] = max(h[i+CENTER], hh);\n        }\n    }\n\n    double ok = 0, ng = 10000000;\n    for (int loop = 0; loop < 100; loop++) {\n        double m = (ng + ok) / 2;\n        if (check(m)) ok = m;\n        else ng = m;\n    }\n\n    cout << fixed <<setprecision(15) << ok << endl;\n}\n\nint main() {\n    while (cin >> r >> n, r) {\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define x first\n#define y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint main(void){\n    double res;\n    for(int r, n; cin >> r >> n, r; cout << res << endl){\n        res = 0.;\n        map<int, map<int, int> > shadows;\n        rep(i, n){\n            int left, right, h; cin >> left >> right >> h;\n            range(x, left, right){\n                shadows[x][x + 1] = max(shadows[x][x + 1], h);\n            }\n        }\n\n        bool ok = false;\n        for(; !ok; res += 0.00001){\n            pair<double, double> o = mp(0., -r + res);\n\n            range(x, -r, r){\n                rep(i, 2){\n                    double d = sqr(x + i - o.x) + sqr(shadows[x][x + 1] - o.y);\n\n                    if(d < (double)sqr(r)){\n                        ok = true;\n                        break;\n                    }\n                }\n            }\n        }\n        res -= 0.0001;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint R;\n\ndouble calc(double height){\n\treturn sqrt(fabs((double)R*(double)R - ((double)R-height)*((double)R-height)));\n}\n\n\nint main(){\n\n\tint N,left,right,height;\n\tbool map[21][41];\n\tbool FLG;\n\tdouble sun_right,sun_height,ans;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&R,&N);\n\t\tif(R == 0 && N == 0)break;\n\n\t\tfor(int i = 0; i <= 40; i++){\n\t\t\tfor(int k = 0; k <= 20; k++)map[k][i] = false;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d %d\",&left,&right,&height);\n\n\t\t\tfor(int a = 20+left; a <= 20+right-1; a++){\n\t\t\t\tfor(int b = 0; b < height; b++){\n\t\t\t\t\tmap[b][a] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(double time = 0.0001; time <= 20.0001; time += 0.0001){\n\t\t\tsun_height = time;\n\n\t\t\theight = (int)ceil(sun_height);\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int h = 0; h < height; h++){\n\t\t\t\tsun_right = calc(sun_height-(double)(h));\n\t\t\t\tright = (int)ceil(sun_right);\n\t\t\t\tleft = -right;\n\n\t\t\t\tfor(int w = 20+left; w <= 20+right-1; w++){\n\t\t\t\t\tif(map[h][w] == false){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\n\t\t\tif(!FLG){\n\t\t\t\tans = time - 0.0001;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n, r;\n\twhile (cin >> r >> n, r | n) {\n\t\tvector<int> h(40);\n\t\tfor (int i = 0, xl, xr, hi; i < n; i++) {\n\t\t\tcin >> xl >> xr >> hi;\n\t\t\tfor (int j = xl + 20; j < xr + 20; j++) {\n\t\t\t\th[j] = max(h[j], hi);\n\t\t\t}\n\t\t}\n\t\tint cnt = 100;\n\t\tld lb = 0, ub = 30;\n\t\twhile (cnt--) {\n\t\t\tld c = (lb + ub) / 2.0;\n\t\t\tbool flag = true;\n\t\t\tfor (int i = 0; i < 40; i++) {\n\t\t\t\tint t1 = r * r - (i - 20) * (i - 20), t2 = r * r - (i - 19) * (i - 19);\n\t\t\t\tif (t1 < 0 || t2 < 0) continue;\n\t\t\t\tif (max(sqrtl(t1), sqrtl(t2)) - r + c > h[i]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tlb = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tub = c;\n\t\t\t}\n\t\t}\n\t\tcout << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint hs[100][100];\nint main(){\n  int n;\n  double r;\n  while(cin>>r>>n,r+n){\n    memset(hs,0,sizeof(hs));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      x1+=20;\n      x2+=20;\n      for(int i=x1;i<x2;i++){\n\tfor(int j=0;j<=h;j++)\n\t  hs[i][j]=1;\n      }\n    }\n    auto check = [&](double t){\n      for(int i=0;i<r;i++){\n\tdouble x=i;\n\tint y=sqrt(r*r-x*x)+t+1-r;\n\t//cout<<i<<\" \"<<t<<\" \"<<y<<endl;\n\tif(y<0)continue;\n\tif(!hs[i+20][y])return false;\n\tif(!hs[-i+20-1][y])return false;\n\t\n      }\n      return true;\n    };\n    double ub=100,lb=0,mid;\n    for(int i=0;i<200;i++){\n      mid=(ub+lb)/2;\n      if(check(mid))lb=mid;\n      else ub=mid;\n    }\n    cout<<fixed<<setprecision(12)<<lb<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tint r;\n\t\tint n;\n\t\tint xl, xr, h;\n\t\tint dp[41] = {};\n\t\tdouble dph[41] = {};\n\t\tdouble mini = 20.0;\n\t\tdouble minihigh = 20.0;\n\n\t\tcin >> r >> n;\n\t\tif (n == 0&&r==0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl >> xr >> h;\n\n\t\t\tFOR(j, xl, xr-1) {\n\t\t\t\tif (dp[j + 20] < h) {\n\t\t\t\t\tdp[j + 20] = h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = -r; i <= r-1; i++) {\n\t\t\tcout << i << \" \" << dp[i+20] << endl;\n\t\t}*/\n\t\t\n\n\t\tfor (int i = -r; i <= r; i++) {\n\t\t\tdouble rr, xx, yy;\n\t\t\tif (i < 0) {\n\t\t\t\trr = (double)r;\n\t\t\t\txx = (double)(i+1);\n\t\t\t\tyy = sqrt(rr*rr - xx * xx);\n\t\t\t\tdph[i + 20] = dp[i + 20] +r-yy;\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\trr = (double)r;\n\t\t\t\txx = (double)(i);\n\t\t\t\tyy = sqrt(rr*rr - xx * xx);\n\t\t\t\tdph[i + 20] = dp[i + 20] + r - yy;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\trr = (double)r;\n\t\t\t\txx = (double)(i);\n\t\t\t\tyy = sqrt(rr*rr - xx * xx);\n\t\t\t\tdph[i + 20] = dp[i + 20] + r - yy;\n\t\t\t}\n\n\t\t}\n\n\t\t//cout << endl;\n\t\tfor (int i = -r; i <= r-1; i++) {\n\t\t\t//cout << i << \" \" << dph[i + 20] << endl;\n\t\t\tif (dph[i + 20] < mini) {\n\t\t\t\tmini = dph[i + 20];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.5lf\\n\", max(mini, 0.0));\n\t\tcout << endl;\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool operator == (const P& a, const P& b) {\n    return abs(a-b) < EPS;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??????\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\nstruct C {//???\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {//??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;      // counter clockwise\n  if (cross(b, c) < 0)   return -1;      // clockwise\n  if (dot(b, c) < 0)     return +2;      // c--a--b on line\n  if (norm(b) < norm(c)) return -2;      // a--b--c on line\n  return 0;\n}\n\n// p??????l?????????????????????????????????\nP projection(const L& l,const P& p){\n  double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// l???????§°?????¨????????????p??¨???????§°?????????????????????\nP reflection(const L& l,const P& p){\n  return p + 2. * (projection(l,p) - p);\n}\n\nbool intersectLL(const L& l,const L& m){\n  //non-parallel || sameline\n  return abs(cross(l[1]-l[0],m[1]-m[0])) > EPS || abs(cross(l[1]-l[0],m[0]-l[0])) < EPS;\n}\nbool intersectLS(const L& l,const L& s){\n  // s[0] is left of l,s[1] is right of l\n  return cross(l[1]-l[0],s[0]-l[0]) * cross(l[1]-l[0],s[1]-l[0]) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectLP(const L& l,const P& p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p) - abs(s[1]-s[0]) < EPS;// triangle inequality\n}\n\ndouble distancePP(const P &a, const P &b){\n  return abs(a - b);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceLP(const L& l,const P& p){\n  return abs(p - projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m){\n  return intersectLL(l,m) ? 0 : distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s){\n  if(intersectLS(l,s)) return 0;\n  return min(distanceLP(l, s[0]),distanceLP(l, s[1]));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n    min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// ??´???????????????\nbool orthogonalLL(const L &l1, const L &l2){\n  return (dot(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && dot(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n// ??????????????????\nbool parallelLL(const L &l1, const L &l2){\n  return (cross(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && cross(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n\n\n// ??????\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nvector<P> crosspointCL(const C &c, const L &l){\n  vector<P> res;\n  double d = distanceLP(l, c.p);\n  if(d < c.r + EPS){\n    double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    P nor = (l[0] - l[1]) / abs(l[0] - l[1]);\n    res.push_back(projection(l, c.p) + len * nor);\n    res.push_back(projection(l, c.p) - len * nor);\n  }\n  return res;\n}\nvector<P> crosspointCS(const C &c, const L &l){\n  vector<P> v = crosspointCL(c, l), res;\n  for(int k=0;k<v.size();k++) if(ccw(l[0], v[k], l[1]) == -2) res.push_back(v[k]);\n  return res;\n}\nvector<P> crosspointCC(const C &c1, const C &c2){\n  vector<P> res;\n  double d = abs(c1.p - c2.p);\n  double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  double dfr = c1.r * c1.r - rc * rc;\n  if(EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return res;\n  double rs = sqrt(dfr);\n\n  P diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * P(rc, rs));\n  res.push_back(c1.p + diff * P(rc, -rs));\n  return res;\n}\n\n//-1 : ???????????????\n// 0 : ??\\??????\n// 1 : ???????????§????????????\n// 2 : ???????????§????????????\nint intersectSC(const L &s, const C &c) {\n  int ins = 0;\n  for(int i = 0; i < 2; i++ ) {\n    if (abs(s[i]-c.p)<c.r) ins++;\n    else if (EQ(abs(s[i]-c.p), c.r)) return 0;\n  }\n  if (ins == 2) return -1;\n  if (ins == 1) return 1;\n  double d = distanceLP(s, c.p);\n  if (d-c.r > EPS) return -1;\n  P nor=(s[0]-s[1]) * P(0, 1);\n  if (ccw(c.p, c.p+nor, s[0]) * ccw(c.p, c.p+nor, s[1]) < 0) return 2;\n  return -1;\n}\n\n\nint main(void) {\nwhile(true){\n  int r,n;\n  cin >> r >> n;\n  if(r == 0 && n == 0)return 0;\n  vector<int> xl(n),xr(n),h(n);\n\n  vector<int> height(100);\n  const int z = 20;\n  for(int i=0;i<n;i++){\n    cin >> xl[i] >> xr[i] >> h[i];\n    for(int j=xl[i];j<xr[i];j++){\n      height[j+z] = max(height[j+z],h[i]);\n    }\n  }\n\n  vector<L> lines;\n  for(int i=-20;i<=20;i++){\n    P p1(i,height[i+z]);\n    P p2(i+1,height[i+z]);\n    lines.emplace_back(p1,p2);\n    // cerr << i << \"~\" << i+1 << \":\" << height[i+z] << endl;\n  }\n\n  bool ok = false;\n  for(double t=0;t<=41;t+=0.001){\n    C taiyou(P(0,-r+t),r);\n    for(int i=0;i<lines.size();i++){\n      if(intersectSC(lines[i],taiyou) >= 1){\n        // for(double dt=0;dt<=0.001;dt+=0.0001){\n          // C taiyou2(P(0,-r+t-dt),r);\n          // if(intersectSC(lines[i],taiyou2) < 1){\n            cout << fixed << setprecision(10) << t-EPS << endl;\n            // break;\n          // }\n        // }\n        ok = true;\n        break;\n      }\n    }\n    if(ok)break;\n  }\n}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint hs[100][100];\nint main(){\n  int n;\n  double r;\n  while(cin>>r>>n,r+n){\n    memset(hs,0,sizeof(hs));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      x1+=20;\n      x2+=20;\n      for(int i=x1;i<x2;i++){\n\tfor(int j=0;j<=h;j++)\n\t  hs[i][j]=1;\n      }\n    }\n    auto check = [&](double t){\n      for(int i=0;i<r;i++){\n\tdouble x=i;\n\tint y=sqrt(r*r-x*x)+t+1-r;\n\t//cout<<i<<\" \"<<t<<\" \"<<y<<endl;\n\tif(y<=0)continue;\n\tif(!hs[i+20][y])return false;\n\tif(!hs[-i+20-1][y])return false;\n     \n      }\n      return true;\n    };\n    double ub=100,lb=0,mid;\n    for(int i=0;i<200;i++){\n      mid=(ub+lb)/2;\n      if(check(mid))lb=mid;\n      else ub=mid;\n    }\n    cout<<fixed<<setprecision(12)<<lb<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n;\n    ld r;\n    while(cin>>r>>n,n!=0 || r!=0){\n        vector<ld> xl(n);\n        vector<ld> xr(n);\n        vector<ld> h(n);\n        for(int i=0;i<n;i++) cin>>xl[i]>>xr[i]>>h[i];\n\n        vector<vector<int>> field(50,vector<int>(30,false));\n        for(int i=0;i<n;i++){\n            for(int j=xl[i];j<xr[i];j++){\n                for(int k=0;k<h[i];k++){\n                    field[j+20][k]=true;\n                }\n            }\n        }\n        ld res=1e9;\n        \n        function<ld(ld,ld)> height=[&](ld x,ld hei){\n            if(abs(x)>=r) return ld(1e9);\n            return hei-sqrt(double(r*r-x*x));\n        };\n        for(int i=0;i<50;i++){\n            int j=0;\n            for(;j<30;j++){\n                if(!field[i][j]) break;\n            }\n            ld hei=j;\n            ld l=i;\n            ld r=i+1;\n            res=min(res,ld(height(l-20,hei)));\n            res=min(res,ld(height(r-20,hei)));\n        }\n        cout<<fixed<<setprecision(7);\n        cout<<(res==1e9 ? 0 : res+r)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tconstexpr int MAX_H = 20;\n\n\tfor(int r, n; cin >> r >> n && r;) {\n\t\tunordered_map<int, int> max_height;\n\n\t\trep(i, n) {\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tREP(x, xl, xr) {\n\t\t\t\tchmax(max_height[x], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = MAX_H;\n\t\tREP(i, -r, r) {\n\t\t\tconst int h = max_height[i] + r;\n\t\t\tconst int x = (i < 0 ? i + 1 : i);\n\t\t\tconst double y = sqrt(r * r - x * x);\n\t\t\tchmin(ans, h - y);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\nconst int CENTER = 30;\nint n, r;\nint h[60];\n\nbool check(double m) {\n\tfor(int i = 0; i <= r - 1; i++) {\n\t\tdouble sh = -r + m + sqrt(r * r - i * i);\n\t\tif(sh < 0) continue;\n\t\tif(h[CENTER + i] < sh) return false;\n\t}\n\tfor(int i = -r; i <= -1; i++) {\n\t\tdouble sh = -r + m + sqrt(r * r - (i + 1) * (i + 1));\n\t\tif(sh < 0) continue;\n\t\tif(h[CENTER + i] < sh) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> r >> n, n | r) {\n\t\tfor(int i = 0; i < 60; i++) {\n\t\t\th[i] = 0.0;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint xl, xr, hh;\n\t\t\tcin >> xl >> xr >> hh;\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\th[CENTER + j] = max(h[CENTER + j], hh);\n\t\t\t}\n\t\t}\n\t\tdouble ok = 0, ng = 100;\n\t\tfor(int loop = 0; loop < 100; loop++) {\n\t\t\tdouble m = (ok + ng) / 2.0;\n\t\t\tif(check(m)) ok = m;\n\t\t\telse ng = m;\n\t\t}\n\n\t\tcout << fixed << setprecision(4) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nint main(){\n  int r,n;\n  int xl, xr, h;\n  int H[50], base = 25;\n  while(cin >> r >> n, r){\n    memset(H,0,sizeof(H));\n    rep(i,n){\n      cin >> xl >> xr >> h;\n      for(int j=xl;j<xr;j++){\n\tH[base+j] = max(H[base+j], h);\n      }\n    }\n\n    int L=0, R=0;\n    double ans = 10000;\n\n    rep(i,25){\n      if(i>=r)break;;\n      double len = i;\n      double height = sqrt(r*r-len*len);\n      ans = min(ans, H[base-i-1]-height + r);\n    }\n    rep(i,25){\n      if(i>=r)break;\n      double len = i;\n      double height = sqrt(r*r-len*len);\n      ans = min(ans, H[base+i]-height + r);\n    }\n    cout << fixed << setprecision(4) << ans << endl;\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      printf(\"%lf %lf %lf\\n\", my, dx, t);\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nconst int BIAS = 20;\n\nsigned main(){\n    while(true){\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if(r == 0 && n == 0){\n            break;\n        }\n\n        vector<double> bill(20*2);\n        rep(i, n){\n            double xl, xr, h;\n            cin >> xl >> xr >> h;\n            for(int j = xl; j < xr; j++){\n                bill[j+BIAS] = max(bill[j+BIAS], h);\n            }\n        }\n\n        double min = 100.0;\n        for(int i = -r; i < 0; i++){\n            double d = i+1;\n            double len = bill[i+BIAS] - sqrt(r*r - d*d) + r;\n\n            if(min > len){\n                min = len;\n            }\n        }\n\n        for(int i = 0; i < r; i++){\n            double d = i;\n            double len = bill[i+BIAS] - sqrt(r*r - d*d) + r;\n\n            if(min > len){\n                min = len;\n            }\n        }\n        cout << fixed << setprecision(4) << min << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=30;\nint xl[60];\nint xr[60];\n\nint main(void){\n\tint r,n;\n\twhile(cin >> r >> n){\n\t\tif(r==0)\n\t\t\tbreak;\n\t\trep(i,60) xl[i]=xr[i]=0;\n\t\trep(i,n){\n\t\t\tint l,r,h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tl+=offset,r+=offset;\n\t\t\tfor(int j=l;j<=r;++j){\n\t\t\t\tif(j!=l)\n\t\t\t\t\txl[j]=max(xl[j],h);\n\t\t\t\tif(j!=r)\n\t\t\t\t\txr[j]=max(xr[j],h);\n\t\t\t}\n\t\t}\n\t\tdouble cmin=inf;\n\t\tfor(int x=-r;x<=r;++x){\n\t\t\tint h=inf;\n\t\t\tif(x!=-r)h=min(h,xl[x+offset]);\n\t\t\tif(x!=r)h=min(h,xr[x+offset]);\n\n\t\t\tint diff=r*r-x*x;\n\t\t\tif(diff<0){\n\n\t\t\t}\n\t\t\tdouble y=sqrt(diff);\n\t\t\tdouble t=h-y+r;\n\t\t\tcmin=min(cmin,t);\n\t\t}\n\t\tcout.precision(9);\n\t\tcout << fixed << max(cmin,0.0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n  \nint s[21][41];\nint main(void){\n    int r, n, xl, xr, h;\n    while(cin >> r >> n && r) {\n        rep(i, 21) rep(j, 41) s[i][j] = 0;\n        rep(i, n) {\n            cin >> xl >> xr >> h;\n            for(int y=0; y<h; ++y) {\n                for(int x=xl+20; x<xr+20; ++x) {\n                    s[y][x] = 1;\n                }\n            }\n        }\n        double mint = numeric_limits<double>::max();\n        rep(y, 21) {\n            for(int x=-r+20; x<r+20; ++x) {\n                if(s[y][x] == 0) {\n                    double t;\n                    if(x<20) t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n                    else t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n                    mint = min(mint, t);\n                }\n            }\n        }\n        printf(\"%.4lf\\n\", mint);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#include <iomanip>\nint main() {\n//    cout << fixed << setprecision(6);\n    int r, n;\n    while (cin >> r >> n, r) {\n        map<int, int> ma;\n        ma[r] = ma[-r - 1] = 100;\n        while (n--) {\n            int xl, xr, h; cin >> xl >> xr >> h;\n            for (int x = xl; x < xr; x++) {\n                ma[x] = max(ma[x], h);\n            }\n        }\n        double mi = 100;\n        for (int x = 0; x <= r; x++) {\n            double d = min({ma[x - 1], ma[x], ma[-x], ma[-x - 1]});\n            d += r - sqrt(r * r - x * x);\n            mi = min(mi, d);\n        }\n        cout << mi << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n#define fi first\n#define se second\ntemplate <typename A, typename B> inline bool chmax(A &a, B b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate <typename A, typename B> inline bool chmin(A &a, B b) {if (a > b) {a = b; return 1;} return 0;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst ll INFL = 1e18+100;\nconst double EPS = 1e-9;\nconst bool debug = 0;\n/****************************/\n\nint N, R;\nint maps[100][100];\n\nbool check(double cy) {\n\tREP(i, 100) REP(j, 100) {\n\t\tif (!maps[i][j]) {\n\t\t\tint x[4] = {j, j, j + 1, j + 1};\n\t\t\tint y[4] = {i, i + 1, i + 1, i};\n\t\t\tREP(k, 4) {\n\t\t\t\tdouble dx = x[k] - 50;\n\t\t\t\tdouble dy = y[k] - cy;\n\t\t\t\tif (dx*dx + dy*dy < R*R - EPS) return false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nint main() {\n\twhile (cin >> R >> N, R || N) {\n\t\tmemset(maps, 0, sizeof(maps));\n\t\t\n\t\tREP(t, N) {\n\t\t\tint l, r, h;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &h);\n\t\t\tl += 50; r += 50;\n\t\t\t\n\t\t\tFOR(j, l, r) REP(i, h) maps[i][j] = 1;\n\t\t\t\n\t\t}\n\t\t\n\t\tdouble l = -R, r = 50;\n\t\tREP(t, 50) {\n\t\t\tdouble m = (l + r) / 2;\n\t\t\t(check(m) ? l : r) = m;\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tprintf(\"%.15f\\n\", l + R);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nint solve_testcase() {\n    int R, N; scanf(\"%d%d\", &R, &N);\n    if(R == 0 and N == 0) return 1;\n    \n    vector<int> HL(50), HR(50);\n    for(int i=0; i<N; i++) {\n        int xl, xr, h; scanf(\"%d%d%d\", &xl, &xr, &h);\n        xl += 20, xr += 20;\n        for(int x=xl; x<xr; x++) {\n            chmax(HL[x], h);\n        }\n        for(int x=xl+1; x<=xr; x++) {\n            chmax(HR[x], h);\n        }\n    }\n\n    double ans = INF;\n    for(int i=0; i<45; i++) {\n        int dist = abs(i - 20);\n        if(dist >= R) continue;\n        if(dist == 0) {\n            double y = min(HL[i], HR[i]);\n            chmin(ans, y);\n            continue;\n        }\n        {\n            double x = i - 20;\n            double y = sqrt(R*R - x*x);\n            y = min(HL[i], HR[i]) - y;\n            double t = y + R;\n            chmin(ans, t);\n        }\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,n){\n\t\tdouble l=-R,r;\n\t\tint ma=0;\n\t\tvi in(50);\n\t\twhile(n--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tma=max(ma,c);\n\t\t\tloop(i,a,b)in[i+25]=max(in[i+25],c);\n\t\t}\n\t\tr=ma-R;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tbool q=true;\n\t\t\tloop(i,1,50){\n\t\t\t\tdouble dis=hypot(min(in[i],in[i-1])-h,i-25);\n//\t\t\t\tcout<<i-25<<\" \"<<dis<<endl;\n\t\t\t\tif(dis<(double)R)q=false;\n\t\t\t}\n\t\t\tif(q)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.8f\\n\",l+R);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #define NDEBUG\n#include <cassert>\n#include <cctype>\n#include <climits>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nnamespace geo\n{\n\tusing namespace std;\n\n\ttypedef double Double;\n\n\tconst Double PI = M_PI; // 3.14159265358979323846\n\tDouble EPS = 1e-08;\n\tDouble INF = 1e+12;\n\n\tenum {\n\t\tCCW = 1, CW = -1, CAB = 2, ABC = -2, ACB = 0,\n\t};\n\n\ttypedef complex<Double> P;\n\tstruct L : public vector<P> {\n\t\tL ( const P &a, const P &b ) {\n\t\t\tpush_back(a); push_back(b);\n\t\t}\n\t};\n\ttypedef vector<P> G;\n\tstruct C {\n\t\tP p; Double r;\n\t\tC ( const P &ip, Double ir ) : p(ip), r(ir) {}\n\t};\n\n\tnamespace comp {\n\t\tbool operator < ( const P &a, const P &b ) {\n\t\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t}\n\t\tbool comp_x ( const P &a, const P &b ) {\n\t\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t}\n\t}\n\n\tDouble cross ( const P &a, const P &b ) {\n\t\treturn imag(conj(a) * b);\n\t}\n\n\tDouble dot ( const P &a, const P &b ) {\n\t\treturn real(conj(a) * b);\n\t}\n\n\tbool intersectSP ( const L &s, const P &p ) {\n\t\t// triangle inequality\n\t\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n\t\t// parallel && signed dot\n\t\t// return cross(s[0] - p, s[1] - p) == 0 && dot(s[0] - p, s[1] - p) <= 0;\n\t}\n\n\tP projection ( const L &l, const P &p ) {\n\t\tDouble t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\t\treturn l[0] + t * (l[1] - l[0]);\n\t}\n\n\tDouble distanceSP ( const L &s, const P &p ) {\n\t\tconst P r = projection(s, p);\n\t\tif (intersectSP(s, r)) { return abs(r - p); }\n\t\treturn min(abs(s[0] - p), abs(s[1] - p));\n\t}\n}\n\nconst int BASE_X = 25;\nconst int RANGE_H = 25;\n\nbool C ( geo::Double r, geo::Double t, const geo::G& g )\n{\n\tfor ( int i = 0; i < g.size() - 1; ++i ) {\n\t\tif ( r > distanceSP( geo::L( g[i], g[i + 1] ), geo::P( 0, t - r ) ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor ( int i = 0; i < g.size() - 1; i += 2 ) {\n\t\tgeo::P pa = g[i], pb = g[i + 1];\n\t\tif ( pa.real() <= 0 && 0 < pb.real() && pa.imag() <= t - r ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main ( void )\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 9 );\n\tcout << setiosflags( ios::fixed );\n\n\tint r, n, minx = 1 << 29, maxx = -minx;\n\n\twhile ( cin >> r >> n, r | n ) {\n\t\tVVI m( RANGE_H, VI( BASE_X * 2, 0 ) );\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\n\t\t\tminx = min( minx, xl );\n\t\t\tmaxx = max( maxx, xr );\n\n\t\t\tfor ( int y = 0; y <= h; ++y ) {\n\t\t\t\tfor ( int x = xl; x < xr; ++x ) {\n\t\t\t\t\tm[y][BASE_X + x] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm[0] = VI( BASE_X * 2, 1 );\n\n\t\tgeo::G g;\n\n\t\tg.push_back( geo::P( -( 1 << 29 ), 0 ) );\n\n\t\tint tx = 0, ty = 0, state = 1;\n\n\t\tdo {\n\t\t\tswitch ( state ) {\n\t\t\tcase 1:\n\t\t\t\tfor ( ; tx < BASE_X * 2 && !m[ty + 1][tx]; ++tx );\n\t\t\t\tif ( tx >= BASE_X * 2 ) { state = 0; }\n\t\t\t\telse {\n\t\t\t\t\tstate = 2;\n\t\t\t\t\tg.push_back( geo::P( tx - BASE_X, ty ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor ( ; m[ty + 1][tx]; ++ty );\n\t\t\t\tstate = 3;\n\t\t\t\tg.push_back( geo::P( tx - BASE_X, ty ) );\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfor ( ; tx + 1 < BASE_X * 2 && m[ty][tx + 1] && !m[ty + 1][tx]; ++tx );\n\t\t\t\tif ( tx + 1 >= BASE_X * 2 ) { state = 0; }\n\t\t\t\telse if ( !m[ty][tx + 1] ) {\n\t\t\t\t\tstate = 4;\n\t\t\t\t\tg.push_back( geo::P( tx + 1 - BASE_X, ty ) );\n\t\t\t\t}\n\t\t\t\telse if ( m[ty + 1][tx] ) {\n\t\t\t\t\tstate = 2;\n\t\t\t\t\tg.push_back( geo::P( tx - BASE_X, ty ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tfor ( ; !m[ty][tx + 1]; --ty );\n\t\t\t\tstate = 3;\n\t\t\t\tg.push_back( geo::P( tx + 1 - BASE_X, ty ) );\n\t\t\t\t++tx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} while ( state );\n\n\t\tg.push_back( geo::P( +( 1 << 29 ), 0 ) );\n\n\t\tgeo::Double low = 0, high = 21;\n\t\tfor ( int i = 0; i < 100; ++i ) {\n\t\t\tgeo::Double mid = ( low + high ) / 2.0;\n\t\t\tif ( C( r, mid, g ) ) {\n\t\t\t\tlow = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\tcout << low << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\nint main(){\n  int n,m;\n  double r;\n  while(cin>>r>>n,n){\n    int h[50]={};\n    seg s[50];\n    r(i,50)s[i].p1.x=i,s[i].p1.y=0,s[i].p2.y=0,s[i].p2.x=i+1;\n    r(i,n){\n      int a,b,c;\n      cin>>a>>b>>c;\n      for(int i=a+25;i<b+25;i++)\n        s[i].p1.y=s[i].p2.y=max(s[i].p1.y,(double)c);\n    }\n  int p=0,t=0;\n    Point time;\n    time.x=25;\n    time.y=-r;\n    double d=0;\n    //r(i,50)cout<<s[i].p1.x<<s[i].p1.y<<s[i].p2.x<<s[i].p2.y<<endl;\n    while(1){\n      r(i,50){//cout<<getDistanceSP(s[i],time)<<endl;\n        if((getDistanceSP(s[i],time)<(double)r)){\n        printf(\"%.4f\\n\",d-0.0001);\n        goto L;\n      }}\n      d+=0.0001;\n      time.y+=0.0001;\n    }\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, R;\n\nVI XLS, XRS;\nVI HS;\n\nVVI find_max_hs() {\n    VVI max_hs(41, VI(2));\n    \n    rep(i, N) {\n        REP(x, XLS[i], XRS[i] + 1) {\n            rep(lr, 2) {\n                if (!lr && x == XLS[i]) continue;\n                if (lr && x == XRS[i]) continue;\n\n                max_hs[20 + x][lr] = max(max_hs[20 + x][lr], HS[i]);\n            }\n        }\n    }\n\n    return max_hs;\n}\n\ndouble calc(double h, double x) {\n    double r = R;\n    double A = h + r;\n\n    double a = 1;\n    double b = -2. * A;\n    double c = A * A + x * x - r * r;\n\n    double p = b * b - 4. * a * c;\n    if (p < 0) return DINF;\n\n    double ans = (-1. * b - sqrt(p)) / 2.;\n\n    return ans;\n}\n\ndouble solve() {\n    VVI max_hs = find_max_hs();\n\n    double anst = DINF;\n\n    for (int x = -1 * R; x <= R; x++) {\n        double tt = DINF;\n        for (int lr = 0; lr < 2; lr++) {\n            int h = max_hs[20 + x][lr];\n            double t = calc(h, abs(x));\n            tt = min(tt, t);\n        }\n        if (tt != DINF) {\n            anst = min(anst, tt);\n        }\n    }\n\n    return anst;\n}\n\nint main(void) {\n    while (cin >> R >> N, R) {\n        XLS.clear();\n        XRS.clear();\n        HS.clear();\n\n        XLS.resize(N);\n        XRS.resize(N);\n        HS.resize(N);\n\n        for (int i = 0; i < N; i++) {\n            cin >> XLS[i] >> XRS[i] >> HS[i];\n        }\n\n        printf(\"%.4f\\n\", solve());\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 1e9 + 7;\nusing pii = pair<int, int>;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\nconst int mod = 1e9 + 7;\nll power(ll a,ll b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\n\nint main() {\n    int r, n;\n    while (cin >> r >> n) {\n        if (r == 0 && n == 0) break;\n        vector<pair<pair<double, double>, double> > v;\n        rep(i, n) {\n            int xl, xr, h; cin >> xl >> xr >> h;\n            v.push_back({{xl, xr}, h});\n        }\n        double left = -r, right = r + 20; //center\n        int c = 0;\n        int roll = 100;\n        while (c++ < roll) {\n            double mid = (left + right) / 2;\n            //cout << \"mid \" << mid << endl;\n            int flg = 0;\n            rep(i, 5000) {\n                flg = 0;\n                double x = r * cos(2 * M_PI * i / 360);\n                double y = mid + r * sin(2 * M_PI * i / 360);\n                if (y < 0) {flg = 1; continue;}\n                rep(j, v.size()) { //どっかの中に入ってろ\n                    if (v[j].first.first <= x && x <= v[j].first.second && y <= v[j].second) {\n                        //if (mid == 1) cout << v[j].first.first << \" \" << v[j].first.second << \"   \" << x << \" \" << y << endl;\n                        flg = 1;\n                        break;\n                    }\n                }\n                if (flg == 0) {\n                    right = mid;\n                    break;\n                }\n            }\n            if (flg == 1) {\n                left = mid;\n            }\n            //cout << left << \" \" << right << endl;\n            if (c == roll) cout << mid + r << endl;\n        }\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint r, n;\n\t\tcin>>r>>n;\n\t\tif(r == 0 && n == 0) break;\n\t\tvector<int> _h(40, 0);\n\t\tREP(i, n) {\n\t\t\tint xl, xr, h;\n\t\t\tcin>>xl>>xr>>h;\n\t\t\tFOR(j, xl, xr) {\n\t\t\t\t_h[j + 20] = max(h, _h[j + 20]);\n\t\t\t}\n\t\t}\n\t\tlong double lb = 0, ub = 21;\n\t\tint cnt = 0;\n\t\twhile(cnt < 100) {\n\t\t\tlong double mid = (lb + ub) / 2;\n\t\t\tbool def = true;\n\t\t\tREP(i, r) {\n\t\t\t\tif(_h[19 - i] - ((mid - r) + sqrt(r * r - i * i)) < - EPS) def = false;\n\t\t\t\tif(_h[20 + i] - ((mid - r) + sqrt(r * r - i * i)) < - EPS) def = false;\n\t\t\t}\n\t\t\tif(def) lb = mid;\n\t\t\telse ub = mid;\n\t\t\t++cnt;\n\t\t}\n\t\tcout<<fixed<<showpoint<<setprecision(39)<<lb<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\nbool box[21][41];\nvoid solve(int r,int n){\n  rep(y,21) rep(x,41) box[y][x]=false;\n  rep(i,n) {\n    int li,ri,hi;\n    cin >> li >> ri >> hi;\n\n    for(int y=0;y<hi;++y) {\n      for(int x=li+20;x<ri+20;++x){\n        box[y][x]=true;\n      }\n    }\n  }\n  auto ans=numeric_limits<double>::max();\n  rep(y,21){\n    for(int x=-r+20;x<r+20;++x) {\n      if(!box[y][x]){\n        double time;\n        if(x<20) time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n        else time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n        ans=min(ans,time);\n      }\n    }\n  }\n  printf(\"%.4lf\\n\",ans);\n}\n\nint main()\n{\n  int r,n;\n  while(cin>>r>>n, n&&r){\n    solve(r,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\t\t\n\t\tmap<int, int> d;\n\t\tfor (int x = -21; x < 21; x++)d[x] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor (int x = xl+1; x <= xr; x++)d[x] = max(d[x], h);\n\t\t}\n\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-5){\n\n\t\t\t/*\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\t*/\n\t\t\tint tx = (x >= 0 ? int(x + (1.0 - 1e-7)) : int(x));\n\t\t\tif (x == -r)tx++;\n\t\t\tdouble ty = double(r) - sin(acos(abs(x / double(r)))) * double(r);\n\n\t\t\tans = min(ans, double(d[tx]) + ty);\n\t\t}\n\n\t\tcout << setprecision(6) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst double EPS = 1e-10;\n\nint r, n, xl[20], xr[20], h[20];\nint right[20], left[20]; // right:(i, i+1)  left:(-i-1, -i)\n\nbool ok(double height) {\n  for (int i = 0; i < r; i++) {\n    double temp = sqrt(r * r - i * i) + height;\n    if (temp - (double) right[i] > EPS) return false;\n    if (temp - (double) left[i] > EPS) return false;\n  }\n  return true;\n}\n\ndouble search() {\n  double lb = (double)-r, ub = (double)r;\n  while (ub > lb + EPS) {\n    double md = (lb + ub) / 2;\n    if (ok(md)) lb = md;\n    else ub = md;\n  }\n  return lb;\n}\n\nvoid inputright(int l, int r, int height) {\n  for (int i = l; i < r; i++) right[i] = max(right[i], height);\n}\n\nvoid inputleft(int l, int r, int height) {\n  for (int i = r; i > l; i--) left[-i] = max(left[-i], height);\n}\n\n\nint main() {\n  while (2)  {\n    scanf(\"%d%d\", &r, &n);\n    if (r == 0) break;\n    for (int i = 0; i < 21; i++) right[i] = left[i] = 0;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%d\", &xl[i], &xr[i], &h[i]);\n      if (xl[i] >= 0) inputright(xl[i], xr[i], h[i]);\n      else if (xr[i] <= 0) inputleft(xl[i], xr[i], h[i]);\n      else inputright(0, xr[i], h[i]), inputleft(xl[i], 0, h[i]);\n    }\n    printf(\"%f\\n\", (double) r + search());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#undef max\n#undef min\n\nbool field[41][22] = {false};\nbool field2[20][22] = { false };\nconstexpr int SUN_OFFSET_X = 20;\nint main() {\n\tint r, n;\n\twhile (std::cin >> r >> n && (r || n)) {\n\t\tstd::memset(field, false, sizeof(bool) * 41 * 22);\n\t\tstd::memset(field2, false, sizeof(bool) * 20 * 22);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x[2], h;\n\t\t\tstd::cin >> x[0] >> x[1] >> h;\n\t\t\tx[0] += SUN_OFFSET_X; x[1] += SUN_OFFSET_X;\n\t\t\t//?????§???????????¶???\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tfor (int k = x[0]; k < x[1]; k++) {\n\t\t\t\t\tfield[k][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstd::vector<double> circleHeights;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t//?°??????????????????????x?????????????????£????????????????????????????????¨??????????????????\n\t\t\tfor (int j = 0; j < 21; j++) {\n\t\t\t\tfield2[19 - i][j] = field[i][j] && field[39 - i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\t//?????????????????????x??§???y=0?????????????¢????\n\t\t\t//h^2 + i^2 = r^2 \n\t\t\t//h^2 = r^2 - i^2\n\t\t\tcircleHeights.push_back(-r + std::sqrt(r  * r - i * i));\n\t\t}\n\n\t\tstd::vector<int> heights;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tint h = 0;\n\t\t\tfor (h = 0; h < 21; h++) {\n\t\t\t\tif (!field2[i][h]) break;\n\t\t\t}\n\t\t\theights.push_back(h);\n\t\t}\n\n\t\t//??¢???\n\t\tdouble y = -0.001;\n\t\tbool isOk = false;\n\t\tdouble cy = 0;\n\t\tfor (int i = 0; i < 21 && !isOk; i++) {\n\t\t\tdouble dy = 0;\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\tdouble tmp = heights[j] - circleHeights[i] - y;\n\t\t\t\tif (tmp > 0) dy = std::min(dy == 0 ? INT_MAX : dy, tmp);\n\t\t\t}\n\t\t\tif (!dy) dy = 1;\n\n\t\t\ty += dy;\n\t\t\t//?????£???????????°????????¢???\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\t//??????x??§??¢?????????????????????\n\t\t\t\tif (std::abs(heights[j] - (circleHeights[j] + y)) < 0.001) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << y << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint R, N; \nint x1,x2,h;\nint B[50];\ndouble ans = 10000.0;\n\ndouble b(double x) {\n\treturn (double) B[(int) (x + 25.0)];\n\t\n}\n\ndouble sun(double x) {\n\tdouble r = R;\n\treturn sqrt(r * r - x * x) - r;\n}\n\ndouble f(double x) {\n\treturn b(x) - sun(x);\n}\n\nint main() {\n\tcin >> R >> N;\n\twhile(R + N) {\n\t\tans = 10000000.0;\n\t\tfor (int i = 0; i < 50; i ++) {\n\t\t\tB [i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x1 >> x2 >> h;\n\t\t\tx1 += 25;\n\t\t\tx2 += 25;\n\t\t\tfor (int x = x1; x < x2; x++ ) {\n\t\t\t\tB[x] = max(B[x], h);\n\t\t\t}\n\t\t}\n\t\tdouble r = R;\n\t\tfor (double x = -r; x < r; x += 0.001) {\n\t\t\tans = min(ans, f(x));\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\tcin >> R >> N;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n#define all all(v) v.begin(),v.end()\n#define INF i<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\n\ntypedef long long ll;\n\n#define EPS (1e-10)\n\nclass Point {\n\tpublic:\n\tdouble x,y;\n\n\tPoint(double x = 0, double y = 0): x(x),y(y){}\n\n\tPoint operator + (Point P) { return Point(x+P.x, y+P.y);}\n\tPoint operator - (Point P) { return Point(x-P.x, y-P.y);}\n\tPoint operator * (double a) { return Point(a*x, a*y);}\n\tPoint operator / (double a) { return Point(x/a, y/a);}\n\n\tdouble abs_() { return sqrt(norm());}\n\tdouble norm() { return x*x+y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ndouble dot(Point a, Point b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a, Point b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif(cross(a,b) > EPS) return 1;\n\tif(cross(a,b) < -EPS) return -1;\n\tif(dot(a,b) < -EPS) return 2;\n\tif(a.norm() < b.norm() ) return -2;\n\n\treturn 0;\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon andrewScan( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3) return s;\n\tsort(s.begin(),s.end());\n\n\tu.pb(s[0]);\n\tu.pb(s[1]);\n\n\tfor(int i=2; i< s.size(); i++){\n\t\tfor(int n = u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i]) != -1; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\n\treturn u;\n}\n\nint main(){\n\twhile(1){\n\t\tint r;\n\t\tint n;\n\t\tPolygon pv;\n\t\tcin >> r >> n;\n\t\tif(r==0) break;\n\n\t\tmap<int,pii> mv;\n\n\t\trep(i,n){\n\t\t\tint xr,xl,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tmv[xl].se = max(h,mv[xl].se);\n\t\t\tfor(int nx = xl+1;nx<xr;nx++){\n\t\t\t\tmv[nx].fi = max(h,mv[nx].fi);\n\t\t\t\tmv[nx].se = max(h,mv[nx].se);\t\t\n\t\t\t}\n\t\t\tmv[xr].fi = max(h,mv[xr].fi);\n\t\t\t/*\n\t\t\tpv.pb(Point(xl,0));\n\t\t\tpv.pb(Point(xr,0));\n\t\t\tpv.pb(Point(xl,h));\n\t\t\tpv.pb(Point(xr,h));\n\t\t\tif(xl < 0 && 0 < xr){\n\t\t\t\tpv.pb(Point(0,h));\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tmv[-r].fi = mv[-r].se;\n\t\tmv[r].se = mv[r].fi;\n\n\t\t// cout<<\"=======\"<<endl;\n\t\tfor(int i=-20;i<=20;i++){\n\t\t\t\n\t\t\t// cout << min(mv[i].fi,mv[i].se) << endl;\n\t\t\tpv.pb(Point(i,min(mv[i].fi,mv[i].se)));\n\t\t}\n\t\t// cout<<\"=======\"<<endl;\n\n/*\n\t\tfor(int i=-20;i<21;i++){\n\t\t\tpv.pb(Point(i,min(mv[i],mv[i+1])));\n\t\t}\n\n\t\tcout<<\"-----------\"<<endl;\n\t\trep(i,pv.size()){\n\t\t\tif(pv[i].y!=23)cout<<pv[i].x<<\" \"<<pv[i].y<<endl;\n\t\t}\n\t\tcout<<\"--------\"<<endl;\n*/\n\n\t\tfor(double t = 0; t<=20.1;t+=0.00005){\n\t\t\tPoint c = Point(0,-r+t);\n\t\t\trep(i,pv.size()){\n\t\t\t\tif((c-pv[i]).abs_()<=r){\n\t\t\t\t\t// cout<<(c-pv[i]).abs_()<<endl;\n\t\t\t\t\tprintf(\"%.4lf\\n\",t);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\t/*\n\t\t// Polygon pt;\n\t\t// pt = andrewScan(pv);\n\t\t// rep(i,pv.size()){\n\t\t// \tcout << \"pv :\" << pv[i].x << \" \"<< pv[i].y << endl;\n\t\t// }\n\n\t\trep(i,pt.size()){\n\t\t\tcout << \"pt :\" << pt[i].x << \" \"<< pt[i].y << endl;\n\t\t}\n*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=30;\nint xl[60];\nint xr[60];\n\nint main(void){\n\tint r,n;\n\twhile(cin >> r >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\trep(i,60) xl[i]=xr[i]=0;\n\t\trep(i,n){\n\t\t\tint l,r,h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tl+=offset,r+=offset;\n\t\t\tfor(int j=l;j<=r;++j){\n\t\t\t\tif(j!=l)\n\t\t\t\t\txl[j]=max(xl[j],h);\n\t\t\t\tif(j!=r)\n\t\t\t\t\txr[j]=max(xr[j],h);\n\t\t\t}\n\t\t}\n\t\tdouble cmin=inf;\n\t\tfor(int x=-r;x<=r;++x){\n\t\t\tint h=inf;\n\t\t\tif(x!=-r)h=min(h,xl[x+offset]);\n\t\t\tif(x!=r)h=min(h,xr[x+offset]);\n\n\t\t\tint diff=r*r-x*x;\n\t\t\tif(diff<0){\n\n\t\t\t}\n\t\t\tdouble y=sqrt(diff);\n\t\t\tdouble t=h-y+r;\n\t\t\tcmin=min(cmin,t);\n\t\t}\n\t\tcout.precision(9);\n\t\tcout << fixed << max(cmin,0.0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint hs[100][100];\nint main(){\n  int n;\n  double r;\n  while(cin>>r>>n,r&&n){\n    memset(hs,0,sizeof(hs));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      x1+=20;\n      x2+=20;\n      for(int i=x1;i<x2;i++){\n\tfor(int j=0;j<=h;j++)\n\t  hs[i][j]=1;\n      }\n    }\n    auto check = [&](double t){\n      for(int i=0;i<r;i++){\n\tdouble x=i;\n\tint y=sqrt(r*r-x*x)+t+1-r;\n\t//cout<<i<<\" \"<<t<<\" \"<<y<<endl;\n\tif(y<0)continue;\n\tif(!hs[i+20][y])return false;\n\tif(!hs[-i+20][y])return false;\n\t\n      }\n      return true;\n    };\n    double ub=100,lb=0,mid;\n    for(int i=0;i<200;i++){\n      mid=(ub+lb)/2;\n      if(check(mid))lb=mid;\n      else ub=mid;\n    }\n    cout<<fixed<<setprecision(12)<<lb<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\ndouble limit(int x, int y, int r) {\n\tif (x*x>r*r) {\n\t\treturn 100.0;\n\t} else if (x*x==r*r && y == 0) {\n\t\treturn 100.0;\n\t}\n\treturn (double)y - (-(double)r+sqrt(r*r-x*x));\n}\n\nint main() {\n\tint r, n;\n\twhile (cin >> r >> n) {\n\t\tif (r == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tpriority_queue< Q, vector<Q>, greater<Q> > pq;\n\t\tQ q;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> (q.first).first >> (q.first).second >> q.second;\n\t\t\tpq.push(q);\n\t\t}\n\t\tvector<Q> data;\n\t\twhile (!pq.empty()) {\n\t\t\tQ q1 = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (!pq.empty()) {\n\t\t\t\tQ q2 = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif ((q2.first).first < (q1.first).second) {\n\t\t\t\t\tif (((q2.first).second <= (q1.first).second) && (q2.second <= q1.second)) {\n\t\t\t\t\t\tpq.push(q1);\n\t\t\t\t\t} else if ((q1.first).first != (q2.first).first){\n\t\t\t\t\t\tQ q3;\n\t\t\t\t\t\tq3.second = q1.second;\n\t\t\t\t\t\t(q3.first).first = (q1.first).first;\n\t\t\t\t\t\t(q3.first).second = (q2.first).first;\n\t\t\t\t\t\tdata.push_back(q3);\n\t\t\t\t\t\t(q1.first).first = (q2.first).first;\n\t\t\t\t\t\tpq.push(q1);\n\t\t\t\t\t\tpq.push(q2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (q1.second <= q2.second) {\n\t\t\t\t\t\t\tpq.push(q2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpq.push(q1);\n\t\t\t\t\t\t\t(q2.first).first = (q1.first).second;\n\t\t\t\t\t\t\tpq.push(q2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata.push_back(q1);\n\t\t\t\t\tpq.push(q2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata.push_back(q1);\n\t\t\t}\n\t\t}\n\t\tdouble MIN = 100.0;\n\t\tbool hantei = true;\n\t\tfor (int i = 0; i< data.size(); i++) {\n\t\t\tint xl = (data[i].first).first;\n\t\t\tint xr = (data[i].first).second;\n\t\t\tint h = data[i].second;\n\t\t\tif (xl <= 0 && xr >= 0) {\n\t\t\t\thantei = false;\n\t\t\t\tMIN = min(MIN, limit(0, h, r));\n\t\t\t}\n\t\t\tif (i == 0){\n\t\t\t\tMIN = min(MIN, min(limit(xl, 0, r), min(limit(xl, h, r), limit(xr, h, r))));\n\t\t\t\tif (xr != (data[i+1].first).first) {\n\t\t\t\t\tMIN = min(MIN, limit(xr, 0, r));\n\t\t\t\t}\n\t\t\t} else if (i+1 == data.size()) {\n\t\t\t\tMIN = min(MIN, min(limit(xr, 0, r), min(limit(xl, h, r), limit(xr, h, r))));\n\t\t\t\tif (xl != (data[i-1].first).second) {\n\t\t\t\t\tMIN = min(MIN, limit(xl, 0, r));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tMIN = min(MIN, min(limit(xl, h, r), limit(xr, h, r)));\n\t\t\t\tif (xr != (data[i+1].first).first) {\n\t\t\t\t\tMIN = min(MIN, limit(xr, 0, r));\n\t\t\t\t}\n\t\t\t\tif (xl != (data[i-1].first).second) {\n\t\t\t\t\tMIN = min(MIN, limit(xl, 0, r));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tMIN = min(MIN, limit(0, 0, r));\n\t\t}\n\t\tprintf(\"%.4f\\n\", MIN);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<int,int> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\n//int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint r,n;\nint x[22][44]={};\ndouble y[22];\n\nint main(){\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tfor(int i=0;i<22;i++){\n\t\t\ty[i]=0.0;\n\t\t}\n\t\tfor(int i=0;i<22;i++){\n\t\t\tfor(int j=0;j<44;j++){\n\t\t\t\tx[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tif(r==0&&n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint xl,xr,h;\n\t\t\tcin>>xl>>xr>>h;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=xl+21;j<xr+21;j++){\n\t\t\t\t\tx[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<22;i++){\n\t\t\tint t1=0;\n\t\t\tfor(t1=21;t1<42&&x[i][t1]==1;t1++){\n\t\t\t}\n\t\t\tt1-=21;\n\t\t\tint t2;\n\t\t\tfor(t2=20;t2>=0&&x[i][t2]==1;t2--){\n\t\t\t}\n\t\t\tt2=20-t2;\n\t\t\ty[i]=min(t1,t2);\n\t\t}\n\t\tdouble ans=100.0;\n\t\tfor(int i=1;i<22;i++){\n\t\t\tif(r>y[i]){\n\t\t\t\tdouble t=(double)r-(sqrt(double(r*r)-double(y[i]*y[i]))+1.0-(double)i);\n\t\t\t\tans=min(ans,t);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%f\\n\",ans);\n\t}\n\treturn 0;\n}\n\t\t\t\n\t\t\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <array>\n\nusing namespace std;\n\n\nint main(){\n\tint r,n;\n\n\tcout.precision(4);\n\tcout.setf(ios::fixed);\n\n\twhile(cin >> r >> n ,r){\n\t\tarray<pair<int,int>,41> height;\n\t\tfor(int i=0;i<41;i++) height[i] = make_pair(0,0);\n\t\tint xl,xr,h;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor(int i=xl;i<xr;i++){\n\t\t\t\theight[i+20].second = max(height[i+20].second,h);\n\t\t\t\theight[i+21].first = max(height[i+21].first,h);\n\t\t\t}\n\t\t}\n\t\tdouble ret = 20.0;\n\t\tfor(int i=-r+1;i<=r-1;i++){\n\t\t\tret = min(ret,(double)min(height[20+i].first,height[20+i].second) - sqrt(pow(r,2) - pow(i,2)) + r);\n\t\t\t//cout << i << \":\" << (double)min(height[20+i].first,height[20+i].second) - sqrt(pow(r,2) - pow(i,2)) + r << endl;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint main() {\n    int r, n;\n    while (cin >> r >> n, r | n) {\n        map<int, int> mp;\n        for (int i = 0; i < n; i++) {\n            int l, r, h;\n            cin >> l >> r >> h;\n            for (int i = l; i < r; i++) mp[i] = max(mp[i], h);\n        }\n        double ans = 100.0;\n        for (int i = - r; i < r; i++) {\n            double p = (i < 0 ? i + 1 : i);\n            ans = min(ans, mp[i] + r - sqrt(r * r - p * p));\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool operator == (const P& a, const P& b) {\n    return abs(a-b) < EPS;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??????\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\nstruct C {//???\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {//??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;      // counter clockwise\n  if (cross(b, c) < 0)   return -1;      // clockwise\n  if (dot(b, c) < 0)     return +2;      // c--a--b on line\n  if (norm(b) < norm(c)) return -2;      // a--b--c on line\n  return 0;\n}\n\n// p??????l?????????????????????????????????\nP projection(const L& l,const P& p){\n  double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// l???????§°?????¨????????????p??¨???????§°?????????????????????\nP reflection(const L& l,const P& p){\n  return p + 2. * (projection(l,p) - p);\n}\n\nbool intersectLL(const L& l,const L& m){\n  //non-parallel || sameline\n  return abs(cross(l[1]-l[0],m[1]-m[0])) > EPS || abs(cross(l[1]-l[0],m[0]-l[0])) < EPS;\n}\nbool intersectLS(const L& l,const L& s){\n  // s[0] is left of l,s[1] is right of l\n  return cross(l[1]-l[0],s[0]-l[0]) * cross(l[1]-l[0],s[1]-l[0]) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectLP(const L& l,const P& p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p) - abs(s[1]-s[0]) < EPS;// triangle inequality\n}\n\ndouble distancePP(const P &a, const P &b){\n  return abs(a - b);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceLP(const L& l,const P& p){\n  return abs(p - projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m){\n  return intersectLL(l,m) ? 0 : distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s){\n  if(intersectLS(l,s)) return 0;\n  return min(distanceLP(l, s[0]),distanceLP(l, s[1]));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n    min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// ??´???????????????\nbool orthogonalLL(const L &l1, const L &l2){\n  return (dot(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && dot(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n// ??????????????????\nbool parallelLL(const L &l1, const L &l2){\n  return (cross(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && cross(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n\n\n// ??????\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nvector<P> crosspointCL(const C &c, const L &l){\n  vector<P> res;\n  double d = distanceLP(l, c.p);\n  if(d < c.r + EPS){\n    double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    P nor = (l[0] - l[1]) / abs(l[0] - l[1]);\n    res.push_back(projection(l, c.p) + len * nor);\n    res.push_back(projection(l, c.p) - len * nor);\n  }\n  return res;\n}\nvector<P> crosspointCS(const C &c, const L &l){\n  vector<P> v = crosspointCL(c, l), res;\n  for(int k=0;k<v.size();k++) if(ccw(l[0], v[k], l[1]) == -2) res.push_back(v[k]);\n  return res;\n}\nvector<P> crosspointCC(const C &c1, const C &c2){\n  vector<P> res;\n  double d = abs(c1.p - c2.p);\n  double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  double dfr = c1.r * c1.r - rc * rc;\n  if(EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return res;\n  double rs = sqrt(dfr);\n\n  P diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * P(rc, rs));\n  res.push_back(c1.p + diff * P(rc, -rs));\n  return res;\n}\n\n//-1 : ???????????????\n// 0 : ??\\??????\n// 1 : ???????????§????????????\n// 2 : ???????????§????????????\nint intersectSC(const L &s, const C &c) {\n  int ins = 0;\n  for(int i = 0; i < 2; i++ ) {\n    if (abs(s[i]-c.p)<c.r) ins++;\n    else if (EQ(abs(s[i]-c.p), c.r)) return 0;\n  }\n  if (ins == 2) return -1;\n  if (ins == 1) return 1;\n  double d = distanceLP(s, c.p);\n  if (d-c.r > EPS) return -1;\n  P nor=(s[0]-s[1]) * P(0, 1);\n  if (ccw(c.p, c.p+nor, s[0]) * ccw(c.p, c.p+nor, s[1]) < 0) return 2;\n  return -1;\n}\n\n\nint main(void) {\nwhile(true){\n  int r,n;\n  cin >> r >> n;\n  if(r == 0 && n == 0)return 0;\n  vector<int> xl(n),xr(n),h(n);\n\n  vector<int> height(100);\n  const int z = 20;\n  for(int i=0;i<n;i++){\n    cin >> xl[i] >> xr[i] >> h[i];\n    for(int j=xl[i];j<xr[i];j++){\n      height[j+z] = max(height[j+z],h[i]);\n    }\n  }\n\n  vector<L> lines;\n  for(int i=-20;i<=20;i++){\n    P p1(i,height[i+z]);\n    P p2(i+1,height[i+z]);\n    lines.emplace_back(p1,p2);\n    // cerr << i << \"~\" << i+1 << \":\" << height[i+z] << endl;\n  }\n\n  bool ok = false;\n  for(double t=0;t<=41;t+=0.0001){\n    C taiyou(P(0,-r+t),r);\n    for(int i=0;i<lines.size();i++){\n      if(intersectSC(lines[i],taiyou) >= 1){\n        for(double dt=0;dt<=0.0001;dt+=0.00001){\n          C taiyou2(P(0,-r+t-dt),r);\n          if(intersectSC(lines[i],taiyou2) < 1){\n            cout << fixed << setprecision(10) << t-dt+0.00001 << endl;\n            break;\n          }\n        }\n        ok = true;\n        break;\n      }\n    }\n    if(ok)break;\n  }\n}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=30;\nint xl[60];\nint xr[60];\n\nint main(void){\n\tint r,n;\n\twhile(cin >> r >> n){\n\t\tif(r==0)\n\t\t\tbreak;\n\t\trep(i,60) xl[i]=xr[i]=0;\n\t\trep(i,n){\n\t\t\tint l,r,h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tl+=offset,r+=offset;\n\t\t\tfor(int j=l;j<=r;++j){\n\t\t\t\tif(j!=l)\n\t\t\t\t\txl[j]=max(xl[j],h);\n\t\t\t\tif(j!=r)\n\t\t\t\t\txr[j]=max(xr[j],h);\n\t\t\t}\n\t\t}\n\t\tdouble cmin=inf;\n\t\tfor(int x=-r;x<=r;++x){\n\t\t\tint h=inf;\n\t\t\tif(x!=-r)h=min(h,xl[x+offset]);\n\t\t\tif(x!=r)h=min(h,xr[x+offset]);\n\n\t\t\tint diff=r*r-x*x;\n\t\t\tdouble y=sqrt(diff);\n\t\t\tdouble t=h-y+r;\n\t\t\tcmin=min(cmin,t);\n\t\t}\n\t\tcout.precision(9);\n\t\tcout << fixed << max(cmin,0.0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct Circle {\n  Point p; double r;\n  Circle(const Point &p, double r) : p(p), r(r) { }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nvector<Point> crosspointsCC(const Circle& s,const Circle& t){\n  //ax + by + c = 0\n  double a = real(t.p) - real(s.p); //x1-x2;\n  double b = imag(t.p) - imag(s.p); //y1-y2;\n  double d = sqrt(a * a + b * b);\n  double theta = 0.0;\n\n  if(d > 0) {\n    theta = acos((d * d + s.r * s.r - t.r * t.r) / (2 * d * s.r));\n  }\n\n  double angle = atan2(b,a);\n  \n  vector<Point> res;\n  if(d < s.r + t.r){\n    res.push_back(Point(s.p.real() + s.r * cos(angle + theta), s.p.imag() + s.r * sin(angle + theta)));\n    res.push_back(Point(s.p.real() + s.r * cos(angle - theta), s.p.imag() + s.r * sin(angle - theta)));\n  }\n\n  else if(s.r + t.r - EPS <= d && d <= s.r + t.r + EPS){\n    res.push_back(Point(s.p.real() + s.r * cos(angle), s.p.imag() + s.r * sin(angle)));\n  }\n  \n  return res;\n}\n\nbool intersectCS(const Circle& s,const Line& t){\n  Point v = t[1] - t[0];\n  Point c = s.p - t[0];\n  Point b = s.p - t[1];\n  if(dot(v,c) < 0){\n    if(abs(c) < s.r) return true;\n    return false;\n  }\n  else{\n    if(dot(v,c) > dot(v,v)){\n      if(s.r * s.r > dot(b,b)) return true;\n      return false;\n    }\n    else{\n      if(dot(c,c) - dot(dot(v,c),dot(v,c)) / dot(v,v) < dot(s.r,s.r)) return true;\n      return false;\n    }\n  }\n}\n\nPoint crosspointLL(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const Point &l,const Point &m){\n  return abs(cross(l,m)) / 2.0;\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool include(const Circle& s,Point t){\n  t -= s.p;\n  return dot(t,t) <= s.r * s.r + EPS;\n}\n\nint main(){\n  int r,n;\n  while(~scanf(\"%d %d\",&r,&n)){\n    if(r == 0 && n == 0) break;\n    \n    vector<Line> lines;\n    double rhs = 0.0;\n    double lhs = -(double)r;\n\n    bool has_point[50][50] = {};\n    for(int i = 0; i < n; i++){\n      int lx,rx;\n      int h;\n      scanf(\"%d %d %d\",&lx,&rx,&h);\n      for(int x = lx; x < rx; x++){\n        has_point[x + 20][h] = true;\n      }\n      rhs = max(rhs,(double)h);\n    }\n\n    lines.push_back(Line(Point(-10000,0),Point(-20,0)));\n    lines.push_back(Line(Point(20,0),Point(10000,0)));\n    for(int x = -20; x + 1 <= 20; x++){\n      bool isok = false;\n      for(int y = 40; y >= 0; y--){\n        if(has_point[x + 20][y]){\n          lines.push_back(Line(Point(x,y),Point(x+1,y)));\n          isok = true;\n          break;\n        }\n      }\n      if(!isok){\n        lines.push_back(Line(Point(x,0),Point(x+1,0)));\n      }\n    }\n\n    for(int round = 0; round < 50; round++){\n      double mid = lhs + (rhs - lhs) / 2.0;\n      Circle c(Point(0,mid),r);\n\n      bool has_crosspoint = false;\n      for(int i = 0; i < lines.size(); i++){\n        if(intersectCS(c,lines[i])){\n          has_crosspoint = true;\n          break;\n        }\n      }\n\n      if(has_crosspoint){\n        rhs = mid;\n      }\n      else{\n        lhs = mid;\n      }\n    }\n\n    printf(\"%lf\\n\",rhs + (double)r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint hs[100][100];\nint main(){\n  int n;\n  double r;\n  while(cin>>r>>n,r+n){\n    memset(hs,0,sizeof(hs));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      x1+=20;\n      x2+=20;\n      for(int i=x1;i<x2;i++){\n\tfor(int j=0;j<=h;j++)\n\t  hs[i][j]=1;\n      }\n    }\n    auto check = [&](double t){\n      for(int i=0;i<r;i++){\n\tdouble x=i;\n\tint y=sqrt(r*r-x*x)+t+1-r;\n\t//cout<<i<<\" \"<<t<<\" \"<<y<<endl;\n\tif(y<=0)continue;\n\tif(!hs[i+20][y])return false;\n\tif(!hs[-i+20-1][y])return false;\n      }\n      return true;\n    };\n    double ub=100,lb=0,mid;\n    for(int i=0;i<200;i++){\n      mid=(ub+lb)/2;\n      if(check(mid))lb=mid;\n      else ub=mid;\n    }\n    cout<<fixed<<setprecision(12)<<lb<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint r, n;\n\t\tcin>>r>>n;\n\t\tif(r == 0 && n == 0) break;\n\t\tvector<int> _h(40, 0);\n\t\tREP(i, n) {\n\t\t\tint xl, xr, h;\n\t\t\tcin>>xl>>xr>>h;\n\t\t\tFOR(j, xl, xr) {\n\t\t\t\t_h[j + 20] = max(h, _h[j + 20]);\n\t\t\t}\n\t\t}\n\t\tlong double lb = 0, ub = 21;\n\t\tint cnt = 0;\n\t\twhile(cnt < 10000) {\n\t\t\tlong double mid = (lb + ub) / 2;\n\t\t\tbool def = true;\n\t\t\tREP(i, r) {\n\t\t\t\tif(_h[19 - i] - ((mid - r) + sqrt(r * r - i * i)) < - EPS) def = false;\n\t\t\t\tif(_h[20 + i] - ((mid - r) + sqrt(r * r - i * i)) < - EPS) def = false;\n\t\t\t}\n\t\t\tif(def) lb = mid;\n\t\t\telse ub = mid;\n\t\t\t++cnt;\n\t\t}\n\t\tcout<<fixed<<showpoint<<setprecision(39)<<lb<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\nint r, n, H[50];\n\nint main() {\n\twhile (cin >> r >> n, r) {\n\t\tmemset(H, 0, sizeof(H));\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\tfor_(j,xl+20,xr+20) H[j] = max(H[j], h);\n\t\t}\n\t\t\n\t\tdouble ans = 1e5;\n\t\tfor_(x,-r,r) {\n\t\t\tdouble p = (x < 0 ? x + 1 : x);\n\t\t\tans = min(ans, H[x+20] + r - sqrt(r * r - p * p));\n\t\t}\n\t\t\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Vampire\n#include<bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint h1[40];//x[0]:-20?-19, x[39]:19?20\nint h2[41];//判定用\nconst double EPS=1E-5;\n\nbool a(double t){\n  complex<double> c;\n  c.real()=0.0, c.imag()=t-r;\n  for(int i=0; i<41; i++){\n    complex<double> d;\n    d.real()=i-20; d.imag()=h2[i];\n    //printf(\"(%f, %f)->%f\\n\", d.real(), d.imag(), abs(c-d));\n    if(abs(c-d)<r-EPS)return true;//含む\n  }\n  return false;//含まない\n}\n\ndouble solve(){\n  double ret=0;\n  while(true){\n    //cout<<\"ret=\"<<ret<<endl;\n    if(a(ret))break;\n    ret+=0.0001;\n  }\n  return ret-0.0001;\n}\n\nint main(){\n  while(true){\n    cin>>r>>n;\n    if(r==0 && n==0)break;\n    memset(h1, 0, sizeof(h1));\n    memset(h2, 0, sizeof(h2));\n    for(int i=0; i<n; i++){\n      int xl, xr, h;\n      cin>>xl>>xr>>h;\n      xl+=20; xr+=20;\n      for(int j=xl; j<xr; j++)\n        if(h1[j]<h)h1[j]=h;\n    }\n    for(int i=1; i<40; i++)\n      h2[i]=min(h1[i-1], h1[i]);\n    /*\n    for(int i=0; i<41; i++)\n      cout<<h2[i]<<' ';\n      cout<<endl;*/\n    printf(\"%.8f\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define DELTA\t((double)1e-10)\n#define DIV\t(29998)\n#define PIDIV\t(M_PI / DIV)\n\n#define MAX_N\t(20)\n#define MAX_T\t(20.0)\n#define MAX_D\t(30000)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nstruct rect_t {\n  double x0, x1, h;\n};\n\n/* global variables */\n\nint r, n;\nrect_t rects[MAX_N];\ndouble cosd[MAX_D + 1], sind[MAX_D + 1];\n\n/* subroutines */\n\nbool visible(double t) {\n  double y0 = t - r;\n  for (int d = 0; d <= DIV; d++) {\n    double y = r * sind[d] + y0;\n    if (y <= 0.0) continue;\n\n    double x = r * cosd[d];\n\n    bool covered = false;\n    for (int i = 0; i < n; i++) {\n      if (x >= rects[i].x0 && x <= rects[i].x1 && y <= rects[i].h) {\n\tcovered = true;\n\tbreak;\n      }\n    }\n\n    if (! covered) return true;\n  }\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  for (int d = 0; d <= MAX_D; d++) {\n    double th = PIDIV * d;\n    cosd[d] = cos(th);\n    sind[d] = sin(th);\n  }\n\n  for (;;) {\n    cin >> r >> n;\n    if ((r | n) == 0) break;\n\n    for (int i = 0; i < n; i++)\n      cin >> rects[i].x0 >> rects[i].x1 >> rects[i].h;\n\n    double t0 = 0;\n    double t1 = MAX_T;\n\n    while (t1 - t0 > DELTA) {\n      double t = (t0 + t1) / 2;\n      if (visible(t))\n\tt1 = t;\n      else\n\tt0 = t;\n    }\n\n    printf(\"%.4lf\\n\", t0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<iomanip>\n#include<iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\n\nint main(){\n\tint R, n;\n\n\tcin >> R >> n;\n\twhile(!(R==0 && n==0) ){\n\t\tint pos[41][2]={ {0, 0} };\n\t\tint l, r, h;\n\t\tF(i, n){\n\t\t\tcin >> l >> r >> h;\n\t\t\tfor(int j=l+20; j<=r+20; j++){\n\t\t\t\tint tmph=h;\n\t\t\t\tif(j!=l+20 && j!=r+20){\n\t\t\t\t\tif(tmph > pos[j][0]){\n\t\t\t\t\t\tpos[j][0]=tmph;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmph > pos[j][1]){\n\t\t\t\t\t\tpos[j][1]=tmph;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(tmph > pos[j][0])swap(tmph, pos[j][0]);\n\t\t\t\t\tif(tmph > pos[j][1])swap(tmph, pos[j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble min=100;\n\t\tfor(int i=20-R+1; i<=20+R-1; i++){\n\t\t\tdouble tmp=pos[i][1]-sqrt(static_cast<double>(R*R-(i-20>0 ? i-20:20-i)*(i-20>0 ? i-20:20-i) ) );\n\t\t\tif(min > tmp)min = tmp;\n\t\t}\n\t\tif(min <= -R){\n\t\t\tmin = 0;\n\t\t}else{\n\t\t\tmin = min+R;\n\t\t}\n\t\tcout << fixed << setprecision(4) << min << endl;\n\n\t\tcin >> R >> n;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <iomanip>\nusing namespace std;\nint n,r;\n//vector<double> keep_x;\n//vector<double> keep_y;\nmap<int, double> keep_y;  \nbool check2(double x,double y, double xl, double xr, double hei){\n  return xl <= x && x <= xr && y <= hei;\n}\nvoid addPoint(vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  keep_y = map<int, double>();\n  for(int i = 0;i < n;i++){\n\tfor(int j = xl[i];j < xr[i];j++){\n\t  keep_y[j] = max(keep_y[j], hei[i]);\n\t}\n  }\n}\ndouble dist(double x1,double y1,double x2,double y2){\n  return ((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}\nbool check(double h){//円内に, 候補点があり=> アウト日が出る\n  for(int i = -r;i <= r;i++){\n\tif(dist(i, keep_y[i], 0, h) < r*r || dist(i, keep_y[i-1], 0, h) < r*r){\n\t  return true;\n\t}\n  }\n  return false;\n}\n\ndouble bs(double h,vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  double f = -r;\n  double e = h;  \n  while(e - f >= 0.0001){\n\tdouble mid = (f + e) / 2.0;\n\tif(check(mid)){\n\t  e = mid;\n\t}else{\n\t  f = mid;\n\t}\n  }\n  return f;\n}\nint main(){\n  \n  while(cin >> r >> n && n != 0){\n\tvector<double> xl(n);\n\tvector<double> xr(n);\n\tvector<double> hei(n);\n\tfor(int i = 0;i < n;i++){\n\t  cin >> xl[i] >> xr[i] >> hei[i];\n\t}\n\taddPoint(xl,xr,hei);\n\tcout << fixed << setprecision(5) << bs(keep_y[0]-r,xl,xr,hei) + r<< endl;\n\t \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tlong double radius;\n\tvector<long double>ans;\n\tcout<<setprecision(20);\n\twhile(cin>>radius>>N,r>0.5){\n\t\tvector<int>l(100);\n\t\tvector<int>r(100);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>L>>R>>K;\n\t\t\tr[L+50]=max(r[L+50],K);\n\t\t\tl[R+50]=max(l[R+50],K);\n\t\t\tfor(int j=L+51;j<R+50;j++){\n\t\t\t\tr[j]=max(r[j],K);\n\t\t\t\tl[j]=max(l[j],K);\n\t\t\t}\n\t\t}\n\t\tlong double ret=100;\n\t\tfor(int i=-radius+1;i<radius;i++){\n\t\t\tlong double h=min(r[i+50],l[i+50]);\n\t\t\tlong double amari=radius*radius;\n\t\t\tamari-=i*i;\n\t\t\tamari=sqrt(amari);\n\t\t\tamari-=radius;\n\t\t\tret=min(ret,h-amari);\n\t\t}\n\t\tans.push_back(ret);\n\t}\n\tfor(auto i:ans)cout<<i<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <array>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\twhile (true) {\n\t\tint r, n;\n\t\tstd::cin >> r >> n;\n\t\tif (r == 0 && n == 0) break;\n\n\t\tstd::vector<int> pos(20, 0), neg(20, 0);\n\t\tREP(i, n) {\n\t\t\tint tl, tr, th;\n\t\t\tstd::cin >> tl >> tr >> th;\n\n\t\t\t// pos\n\t\t\tFOR(j, std::max(0LL, tl), tr) pos[j] = std::max(pos[j], th);\n\n\t\t\ttl *= -1;\n\t\t\ttr *= -1;\n\t\t\tstd::swap(tl, tr);\n\n\t\t\t// neg\n\t\t\tFOR(j, std::max(0LL, tl), tr) neg[j] = std::max(neg[j], th);\n\t\t}\n\n\t\tauto calc = [&](std::vector<int> h)  -> double {\n\t\t\tdouble res = 1e300;\n\n\t\t\tREP(i, r) {\n\t\t\t\tres = std::min(res, (r - std::sqrt(r * r - i * i)) + h[i]);\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\n\t\tstd::cout << std::fixed << std::setprecision(4) << std::min(calc(pos), calc(neg)) << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nbool solve(){\n  int r, n;\n  int maxh[50] = {};\n  \n  scanf(\"%d%d\", &r, &n);\n\n  if(r == 0) return false;\n  \n  for(int i=0;i<n;i++){\n    int l, r, h;\n    scanf(\"%d%d%d\", &l, &r, &h);\n\n    for(int j=l+20;j<r+20;j++) maxh[j] = max(maxh[j], h);\n  }\n\n  double ans = INF;\n  \n  for(int i=20-r;i<20+r;i++){\n    int x = (i<20) + i - 20;\n\n    ans = min(ans, maxh[i] + r - sqrt(r*r-x*x));\n  }\n\n  printf(\"%.5lf\\n\", ans);\n\n  return 1;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#define MAX_N 20\nusing namespace std;\n\nint main(){\n\tint r,n; //r:??????????????????n:?????????????????¨??????????????°\n\twhile(1){\n\t\tint xl[MAX_N],xr[MAX_N],h[MAX_N];\n\t\tcin>>r>>n;\n\t\tif(r==0 && n==0) break;\n\t\t\n\t\tfor(int ni=0;ni<n;ni++){\n\t\t\tcin>>xl[ni]>>xr[ni]>>h[ni];\n\t\t}\n\t\t\n\t\tdouble sunCY;\n\t\tdouble time=0.0000;\n\t\tbool check; //???????????????????????°true\n\t\twhile(1){\n\t\t\ttime+=0.0001;\n\t\t\tsunCY=time-(double)r;\n\t\t\tfor(int j=-r;j<r;j++){\n\t\t\t\tdouble sunX;\n\t\t\t\tcheck=true;\n\t\t\t\tif(j<0) sunX=(double)j+0.99999;\n\t\t\t\telse    sunX=(double)j+0.00001;\n\t\t\t\tdouble sunY=sunCY + sqrt((double)(r*r) - sunX*sunX);\n\t\t\t\tif(sunY<=0) check=false;\n\t\t\t\tfor(int ni=0;ni<n;ni++){\n\t\t\t\t\tif(sunX>=xl[ni] && sunX<=xr[ni] && sunY<=h[ni]) check=false;\n\t\t\t\t}\n\t\t\t\tif(check) break;\n\t\t\t}\n\t\t\tif(check) break;\n\t\t}\n\t\ttime-=0.0001;\n\t\tcout<<fixed<<setprecision(4)<<time<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-12;\nstruct edge\n{\n  int to, cost;\n  bool operator < (const edge& e) const { return cost < e.cost; }\n  bool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nint main()\n{\n  int r, n;\n  while (cin >> r >> n, r)\n  {\n    vector<vector<int>> build(50,vi(50));\n    int L = 25 - r, R = 25 + r;\n\n    REP(i, n)\n    {\n      int l, r, h;\n      cin >> l >> r >> h;\n      l += 25; r += 25;\n\n      FOR(i, l, r)\n      {\n        REP(j, h) build[i][j] = 1;\n      }\n    }\n\n    double ans = INF;\n    FOR(i, L + 1, R)\n    {\n      int j;\n      for (j = 0;; j++)\n      {\n        if (build[i][j] != 1 || build[i-1][j] != 1) break;\n      }\n      double k = abs(i - 25);\n      double tmp = sqrt(r*r - k*k);\n      tmp = r - tmp;\n      //cout << j - tmp << endl;\n      ans = chmin(ans, max(j+tmp, 0.0));\n    }\n    cout << D10 << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#define EPS (1e-10)\nusing namespace std;\nint main(){\n  double r,n;\n  cin >> r >> n;\n  while(r!=0||n!=0){\n    int i,j,k;\n    double xr,xl,h;\n    double hs[41]={};\n    for(i=0;i<n;i++){\n      cin >> xr >> xl >> h;\n      for(j=xr;j<xl;j++){\n\ths[j+20]=max(hs[j+20],h);\n      }\n    }\n    /*\n    for(i=0;i<=40;i++) cout << hs[i] ;\n    cout << endl;\n    */\n    double o=0;\n    int f=0;\n    while(f==0){\n      o+=0.0001;\n      int w;\n      if(o<r){\n\tw = (int) sqrt((r*r)-(r-o)*(r-o));\n\tif(sqrt((r*r)-(r-o)*(r-o))-w>=EPS) w+=1;\n      }\n      else{\n\tw=r;\n      }\n      //cout << w << endl;\n      for(j=-w;j<0;j++){\n\tif(hs[j+20]<o-r+sqrt((r*r)-((j+1)*(j+1)))){\n\t  //cout << w << \":\" << o << \":\" << hs[j+20]  << \":\" <<  j << endl;\n\t  f=1;\n\t}\n      }\n      if(o-hs[20-1]>EPS){\n\t//cout << w << \":\" << o << \":\" << hs[20-1]  << endl;\n\tf=1;\n      }\n      if(o-hs[20]>EPS){\n\t//cout << w << \":\" << o << \":\" << hs[20] << endl;\n\tf=1;\n      }\n      for(j=1;j<w;j++){\n\tif(hs[j+20]<o-r+sqrt((r*r)-(j*j))){\n\t  //cout << w << \":\" << o << \":\" << hs[j+20]  << \":\" <<  j << endl;\n\t  f=1;\n\t}\n      }\n    }\n    \n    printf(\"%.4f\\n\",o-0.0001);\n    cin >> r >> n;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nint main(){\n    while(1){\n        int r, n;\n        cin >> r >> n;\n        if(r == 0) break;\n\n        vector<int> maxHeight(2*r);\n        for(int i=0;i<n;i++){\n            int tl, tr, th;\n            cin >> tl >> tr >> th;\n            for(int x=tl;x<tr;x++){\n                if(-r <= x && x < r){\n                    maxHeight[x+r] = max(th, maxHeight[x+r]);\n                }\n            }\n        }\n        double ans = 10000;\n        for(int x=-r;x<r;x++){\n            int c;\n            if(x < 0){\n                c = -x-1;\n            }else{\n                c = x;\n            }\n            ans = min(ans, r+maxHeight[x+r]-sqrt(r*r - c*c));\n        }\n        printf(\"%.6f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst double BIGNUM=400.0;\n\nint heights[40];\n\nint main(){\n\n    int r,n;\n    while(scanf(\"%d%d\",&r,&n)&&r!=0){\n        for(int i=0;i<40;i++) heights[i]=0;\n        for(int i=0;i<n;i++){\n            int l,r,h;\n            scanf(\"%d%d%d\",&l,&r,&h);\n            for(int k=l+20;k<r+20;k++) heights[k]=max(heights[k],h);\n        }\n\n        double ans=BIGNUM;\n        for(int i=20-r;i<20;i++){\n            int dist=20-i-1;\n            double depth=sqrt((double)(r*r-dist*dist));\n            // printf(\"depth=%lf,dist=%d\\n\",depth,dist);\n            ans=min(ans,(heights[i]+r-depth));\n            // printf(\"ans=%lf\\n\",ans);\n        }\n\n        for(int i=20;i<20+r;i++){\n            int dist=i-20;\n            double depth=sqrt((double)(r*r-dist*dist));\n            // printf(\"depth=%lf,dist=%d\\n\",depth,dist);\n            ans=min(ans,(heights[i]+r-depth));\n            // printf(\"ans=%lf\\n\",ans);\n        }\n\n        printf(\"%lf\\n\",ans);\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint r,n,L,R,h,i,x;\n\nint main(){\n\t\n\twhile(cin>>r>>n,r){\n\n\t\t\n\t\tint A[41]={},B[41]={};\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>L>>R>>h;\n\t\t\tfor(x=L;x<=R;x++){\n\t\t\t\tif(x!=R)A[x+20]=max(A[x+20],h);\n\t\t\t\tif(x!=L)B[x+20]=max(B[x+20],h);\n\t\t\t}\t\n\t\t}\n\t\tdouble res=99;\n\t\tfor(i=-r;i<=r-1;){\n\t\t\tres=min(res,min(r-sqrt(r*r-i*i)+A[i+20],r-sqrt(r*r-(i+1)*(i+1))+B[i+++1+20]));\n\t\t}\n\t\tcout<<res<<\"\\n\";\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <cmath>\n#include <cfloat>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n#define dbg(...) fprintf(stderr,__VA_ARGS__);\nstruct range{\n\tint e,b=0,s=1;range(int b,int e,int s):e(e),b(b),s(s){} range(int b,int e): e(e), b(b){} range(int e):e(e){}\n\tstruct it{int v,s; it(int v,int s):v(v),s(s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\n_T struct pos {\n\tvector<T> p;\n\tpos(int n) : p(n) {};\n\tT& operator [] (int n) {\n\t\treturn p[p.size() / 2 + n];\n\t}\n};\n\nint main() {\n\tfor (int r, n; r = in, n = in, r || n;) {\n\t\tpos<int> b(50);\n\t\ttimes(i, n) {\n\t\t\tint xl {in}, xr {in}, h {in};\n\t\t\tfor (int j: range(xl, xr))\n\t\t\t\tb[j] = max(b[j], h);\n\t\t}\n\t\tdouble a {DBL_MAX};\n\t\tfor (int i: range(-r + 1, r))\n\t\t\ta = min(a, r - sqrt(r * r - i * i) + min(b[i - 1], b[i]));\n\t\tprintf(\"%f\\n\", a);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\n/*\n\nTodo:\nLine??¨Segment?????????????????????\n\n*/\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\n#define idx(i) (i+25)\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nsigned main() {\n\tcout << fixed << setprecision(6);\n\tfor (int r, n; cin >> r >> n&&r;) {\n\t\tint Hl[50] = {};\n\t\tint Hr[50] = {};\n\t\trep(i, 0, n) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\trep(j, xl, xr) {\n\t\t\t\tchmax(Hl[idx(j)], h);\n\t\t\t}\n\t\t\trep(j, xl + 1, xr + 1) {\n\t\t\t\tchmax(Hr[idx(j)], h);\n\t\t\t}\n\t\t}\n\t\tdouble miny = INF;\n\t\tLine L(Point(0, 0), Point(0, 1));\n\t\trep(x, -20, 20 + 1) {\n\t\t\tCircle C(Point(x, min(Hl[idx(x)], Hr[idx(x)])), r);\n\t\t\tif (!intersect(C, L))continue;\n\t\t\tauto cp = get_cross_points(C, L);\n\t\t\tif (cp.first == cp.second)continue;\n\t\t\tchmin(miny, cp.first.y);\n\t\t\tchmin(miny, cp.second.y);\n\t\t}\n\t\tcout << max(-2.0, miny) + 2.0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n    while (1){\n        int r, n;\n        cin >> r >> n;\n        if (r == 0 && n == 0) break;\n        vector<double> rnd(2*r + 1, -r);\n        for (int i = 0; i <= r; i++){\n            rnd[r - i] += sqrt(r * r - i * i);\n            if (i != 0) rnd[r + i] += sqrt(r * r - i * i);\n        }\n        vector<int> border(2*r, 0);\n        for (int i = 0; i < n; i++){\n            int left, right, height;\n            cin >> left >> right >> height;\n            for (int j = left; j < right; j++){\n                if (j + r < 0 || j + r >= 2*r) continue;\n                border[j+r] = max(border[j+r], height);\n            }\n        }\n        double t = 0.0000;\n        bool flag = false;\n        while (1){\n            for (int i = 0; i <= 2*r; i++) rnd[i] += 0.00005;\n            for (int i = 0; i < 2*r; i++){\n                if (border[i] < rnd[i] || border[i] < rnd[i+1]){\n                    cout << t << endl;\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) break;\n            t += 0.00005;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  double r;\n  int n;\n  double ans;\n  double left,right,h;\n\n  while(1){\n    cin >> r >> n;\n    if(r==0) break;\n    ans=21;\n    vector<double> takasahidari(41,0),takasamigi(41,0);\n    for(int i=0;i<n;i++){\n      cin >> left >> right >> h;\n      for(int j=left;j<right;j++){\n        takasahidari[j+20]=max(takasahidari[j+20],h);\n      }\n      for(int j=left+1;j<=right;j++){\n        takasamigi[j+20]=max(takasamigi[j+20],h);\n      }\n    }\n    /*\n    for(int i=0;i<41;i++){\n      cout << takasahidari[i] << \" \";\n    }\n    cout << endl;\n    for(int i=0;i<41;i++){\n      cout << takasamigi[i] << \" \";\n    }\n    cout << endl;\n    */\n    for(int i=21-r;i<=19+r;i++){\n      /*\n      if(ans>min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20))){\n        cout << \"(\" << i-20 << \",\" << min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)) << \")\" << endl;\n      }\n      */\n      if(takasahidari[i]>0&&takasamigi[i]>0){\n        ans=min(ans,min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)));\n      }\n\n\n\n    }\n    if(ans==21){\n      ans=0;\n    }\n    cout << fixed<<setprecision(6)<<ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, R;\nbool fie[55][55];\nint dx[]={0,1,0};\nint dy[]={-1,0,1};\nbool used[55][55];\ntypedef complex<double> P;\nconst double EPS = 1e-8;\nbool check(int x,int y,int d){\n  if( 0 <= x && x <= 44 && 0 <= y && y <= 44 ){\n    if(!used[x][y]){\n      if( d == 0 ) return !fie[x-1][y] || !fie[x][y];\n      else if( d == 1 ) return !fie[x-1][y];\n      else return true;\n    }\n  }\n  return false;\n}\n\ndouble solve( P p,const vector<P>& ep ){\n  double x = abs(p.real()-22);\n  if( (int)x > R ) return -R;\n  P v = P(22, p.imag() - sqrt(R*R - x*x) );\n  for(int i=0;i<(int)ep.size();i++){\n    if( (double)R - EPS > abs( ep[i] - v ) ) return -R;\n  }\n  return v.imag();\n}\n\nint main(){\n  while( cin >> R >> N && (N|R) ){\n    double ra = R;\n    memset(fie,0,sizeof(fie));\n    for(int i=0;i<N;i++){\n      int xr,xl,h;\n      cin >> xr >> xl >> h;\n      xr+=22; xl+=22;\n      for(int j=xr;j<xl;j++)\n\tfor(int l=0;l<h;l++)\n\t  fie[j][l] = true;      \n    }\n    \n    memset(used,0,sizeof(used));\n    vector<P> ep;\n    int x=1,y=0;\n    while( !(x == 44 && y == 0) ){\n      used[x][y] = true;\n      ep.push_back( P( x, y ) );\n      for(int i=0;i<3;i++){\n\tint nx = x+dx[i], ny = y+dy[i];\n\tif( check(nx,ny,i) ){\t  \n\t  x = nx; y = ny;\n\t  break;\n\t}       \n      }\n    }\n\n    double res = -ra;\n    for(int i=0;i<(int)ep.size();i++){\n      res = max( res, solve(ep[i],ep) );      \n    }\n    cout << res + R << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<typename T>\nbool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\ndouble height[50];\n\nint main() {\n    while(true) {\n        int n;\n        int _r;\n        double r;\n        cin >> _r >> n;\n        if(_r == 0) break;\n        r = _r;\n        for(int i = 0; i < 50; i++) height[i] = 0.0;\n        while(n--) {\n            int l, r;\n            double h;\n            cin >> l >> r >> h;\n            l += 20;\n            r += 20;\n            for(int i = l; i < r; i++) chmax(height[i], h);\n        }\n        double ng = 1e2;\n        double ok = 0;\n        for(int _ = 0; _ <= 300; _++) {\n            double mid = (ok + ng) / 2.0;\n            bool clear = true;\n            for(int i = 1; i < 50; i++) {\n                //double sun = pow(max((r * r - (20 - i) * (20 - i)), 0.0), 0.5);\n                if(abs(20-i) > r - EPS) continue;\n                double sun = max(0.0, mid - r + pow(r * r - (20-i)*(20-i), 0.5));\n                //cerr << mid << \" \" << i << \" \" << sun << \" \" << height[i-1] << \" \" << height[i] << endl;\n                if(sun - EPS > min(height[i], height[i-1])) clear = false;\n            }\n            if(clear) ok = mid;\n            else ng = mid;\n        }\n        printf(\"%lf\\n\", ok);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1194\n//\n//  Created by 13B15237 on 2015/06/22.\n//  Copyright (c) 2015??´ 13B15237. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Rect {\n    int l, r;\n    int h;\n};\n\nstruct Point {\n    int x, y;\n};\n\nstruct Area {\n    bool table[21][41];\n    \n    void clear() {\n        for (int y = 0; y < 21; ++y) {\n            for (int x = -20; x < 21; ++x) {\n                table[y][x+20] = false;\n            }\n        }\n    }\n    \n    void draw(Rect rect) {\n        for (int y = 0; y < rect.h; ++y) {\n            for (int x = rect.l; x < rect.r; ++x) {\n                table[y][x + 20] = true;\n            }\n        }\n    }\n    \n    void show() {\n        for (int y = 20; y >= 0; --y) {\n            for (int x = -20; x < 21; ++x) {\n                cout << (table[y][x+20] == true ? '#' : '_');\n            }\n            cout << endl;\n        }\n    }\n    \n    bool test(int r, int t) {\n        const int ybegin = max(0, t - 2 * r);\n        const int yend = t;\n        \n        for (int y = ybegin; y < yend; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == false) return false;\n            }\n        }\n        return true;\n    }\n    \n    Point calcMinDistPoint(int r, int maxt) {\n        double mindist = 30.0;\n        Point p = {0, 0};\n        \n        for (int y = max(0, maxt - 2 * r); y < maxt; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == true) continue;\n                \n                const int a = x < 0 ? abs(x + 1) : x;\n                const int b = y;\n                double dist = sqrt(a*a + b*b);\n                //printf(\"(%d, %d) = %f\\n\", x,y,dist);\n                \n                if (dist < mindist) {\n                    mindist = dist;\n                    p.x = x;\n                    p.y = y;\n                }\n            }\n        }\n        return p;\n    }\n};\n\nint R, N;\nvector<Rect> vrect;\nArea area;\n\nint main(int argc, const char * argv[]) {\n    while (1) {\n        cin >> R >> N;\n        if (!R && !N) break;\n        \n        area.clear();\n        vrect.clear();\n        vrect.resize(N);\n        for (auto r : vrect) {\n            cin >> r.l >> r.r >> r.h;\n            area.draw(r);\n        }\n        \n        //area.show();\n        \n        int tmax;\n        for (tmax = 0; tmax < 21; ++tmax) {\n            if (area.test(R, tmax) == false) break;\n        }\n        \n        /*\n        double t = static_cast<double>(tmax - 1);\n        while (1) {\n            double d = area.calcMinDist(R, t, tmax);\n            if (d < static_cast<double>(R)) break;\n            t += 0.001;\n        }\n         */\n        Point p = area.calcMinDistPoint(R, tmax);\n        const int dx = p.x < 0 ? abs(p.x + 1) : abs(p.x);\n        double dy = sqrt(R * R - dx * dx);\n        \n        \n        //cout << \"p = (\" << p.x << \", \" << p.y << \")\" << endl\n        //<< \"dy = \" << dy << \", R  = \" << R << endl;\n        \n        double t;\n        if (dy < (double)R) {\n            t = ((double)(p.y + R) - dy);\n        } else {\n            t = (double)p.y;\n        }\n        \n        printf(\"%.4f\\n\", t);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex< double > Point;\ntypedef vector< Point > Polygon;\nnamespace std{\n    bool operator < ( Point a, Point b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n};\nconst double INF = 1e12;\nconst double EPS = 1e-8;\nPoint NextPoint(){\n    Point P;\n    cin>>P.real() >> P.imag();\n    return P;\n}\nstruct Line : Polygon{\n    Line(){};\n    Line(Point p, Point q){push_back(p);push_back(q);}\n};\n \nstruct Circle{\n    Point p;\n    double r;\n    Circle();\n    Circle(Point a, double s){p = a,r = s;}\n};\ndouble cross(Point p, Point q){\n    return imag(conj(p)*q);\n}\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\nint ccw(Point a,Point b,Point c){\n    b -= a,c -= a;\n    if(cross(b,c) > 0)return 1;\n    if(cross(b,c) < 0)return -1;\n    if(dot(b,c) < 0 )return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\nPoint projection(Line l,Point p){\n    double t = dot(p - l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nbool intersectSP(Line s,Point p){\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble distanceSP(Line s,Point p){\n    const Point r = projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0] - p),abs(s[1] - p));\n}\nint main(){\n    int r,n;\n    while(cin>>r>>n,r){\n        int sc[50] = {};\n        for(int i = 0;i < n;i++){\n            int l,r,h;\n            cin>>l>>r>>h;\n            l+=30,r+=30;\n            for(int j = l;j < r;j++){\n                sc[j] = max(sc[j],h);\n            }\n        }\n        Polygon G;\n        G.push_back(Point(-100,0));\n        G.push_back(Point(0,0));\n        for(int i = 0;i < 45;i++){\n             \n            if(i != 0){\n                if(sc[i] != sc[i-1])\n                    G.push_back(Point(i,sc[i]));\n                 \n                G.push_back(Point(i+1,sc[i]));\n            }\n        }\n        G.push_back(Point(100,0));\n \n        for(int i = 0;i < G.size();i++){\n            //cout<<G[i].real()<<\" \"<<G[i].imag()<<endl;\n        }\n \n        double low = -100,high = 100;\n        int D = 100;\n        //cout<<sc[20]<<endl;\n        while(D--){\n            double mid = (low+high)/2;\n            Circle C = Circle(Point(30,mid),r);\n            double mi = INF;\n            for(int i = 0;i < G.size()-1;i++){\n                double dist = distanceSP(Line(G[i],G[i+1]),C.p);\n                mi = min(mi,dist);\n            }\n            //cout<<mid<<\" \"<<mi<<\" \"<<mid+r<<endl;\n            if(mi < r)high = mid;\n            else if(sc[30] < mid+r)high = mid;\n            else low = mid;\n        }\n        printf(\"%.4lf\\n\",low+r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r, h;\n  double xl, xr, ans;\n  int V[41];  \n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define SZ 20\n\nint mat[SZ+1][2*SZ+1];  //no-shade:0, shade:plus, mat[height][width+20]\n\nint main(){\n  int r,n;\n  while(scanf(\"%d %d\",&r,&n), r|n){\n    // initialize\n    rep(i,SZ+1){\n      rep(j,2*SZ+1){\n\tmat[i][j]=0;\n      }\n    }\n\n    // input provess for imosu\n    rep(i,n){\n      int xl, xr, h;\n      scanf(\"%d %d %d\", &xl, &xr, &h);\n      mat[0][xl+20]++;\n      mat[0][xr+20]--;\n      mat[h][xl+20]--;\n      mat[h][xr+20]++;\n    }\n    \n    // imosu\n    rep(i,SZ){\n      repl(j,1,2*SZ){\n\tmat[i][j] += mat[i][j-1];\n      }\n    }\n    rep(i,2*SZ){\n      repl(j,1,SZ){\n\tmat[j][i] += mat[j-1][i];\n      }\n    }\n\n    // debug\n    /*\n    rep(i,SZ){\n      rep(j,2*SZ){\n\tprintf(\"%d\", mat[SZ-i-1][j]);\n      }printf(\"\\n\");\n    }\n    */\n\n    // move sun from bottom\n    int t=0;\n    int w;\n    double res=20;\n    while(t<20){\n      w=0; //width\n      while(w<r){\n\tif(mat[t][20+w]>0 && mat[t][19-w]>0){\n\t  w++;\n\t}else{\n\t  break;\n\t}\n      }\n      if(w==0){\n\tres=min(res, (double)t);\n\tbreak;\n      } else if(w==r){\n\tt++;\n\tcontinue;\n      } else {\n\tres = min(res, (double)(r+t) - sqrt(r*r-w*w));\n\tt++;\n      }\n    }\n\n    printf(\"%.4f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint xl[25], xr[25], h[25];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint r, n;\n\t\tcin >> r >> n;\n\t\tif(!r && !n) break;\n\t\tREP(i, n) cin >> xl[i] >> xr[i] >> h[i];\n\n\t\tdouble hi = 60, low = 0;\n\t\tREP(i, 20) {\n\t\t\tdouble mid = (hi+low)/2;\n\t\t\t//cout << hi << \" \" << mid << \" \" << low << endl;\n\t\t\tbool flag = true;\n\t\t\tREP(j, 300000) {\n\t\t\t\tdouble x = -r + (double)(2+r)*j/300000;\n\t\t\t\tint ma = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif(xl[k] <= x && x <= xr[k]) {\n\t\t\t\t\t\tma = max(ma, h[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble H = sqrt(r*r-x*x) + mid - r;\n\t\t\t\t// cout << ma << \" \" << H << endls\n\t\t\t\tif(ma < H) {flag = false; break;}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << low << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n#define all all(v) v.begin(),v.end()\n#define INF i<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\n\ntypedef long long ll;\n\n#define EPS (1e-10)\n\nclass Point {\n\tpublic:\n\tdouble x,y;\n\n\tPoint(double x = 0, double y = 0): x(x),y(y){}\n\n\tPoint operator + (Point P) { return Point(x+P.x, y+P.y);}\n\tPoint operator - (Point P) { return Point(x-P.x, y-P.y);}\n\tPoint operator * (double a) { return Point(a*x, a*y);}\n\tPoint operator / (double a) { return Point(x/a, y/a);}\n\n\tdouble abs_() { return sqrt(norm());}\n\tdouble norm() { return x*x+y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ndouble dot(Point a, Point b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a, Point b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif(cross(a,b) > EPS) return 1;\n\tif(cross(a,b) < -EPS) return -1;\n\tif(dot(a,b) < -EPS) return 2;\n\tif(a.norm() < b.norm() ) return -2;\n\n\treturn 0;\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon andrewScan( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3) return s;\n\tsort(s.begin(),s.end());\n\n\tu.pb(s[0]);\n\tu.pb(s[1]);\n\n\tfor(int i=2; i< s.size(); i++){\n\t\tfor(int n = u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i]) != -1; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\n\treturn u;\n}\n\nint main(){\n\twhile(1){\n\t\tint r;\n\t\tint n;\n\t\tPolygon pv;\n\t\tcin >> r >> n;\n\t\tif(r==0) break;\n\n\t\tmap<int,pii> mv;\n\n\t\trep(i,n){\n\t\t\tint xr,xl,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tmv[xl].se = max(h,mv[xl].se);\n\t\t\tfor(int nx = xl+1;nx<xr;nx++){\n\t\t\t\tmv[nx].fi = max(h,mv[nx].fi);\n\t\t\t\tmv[nx].se = max(h,mv[nx].se);\t\t\n\t\t\t}\n\t\t\tmv[xr].fi = max(h,mv[xr].fi);\n\t\t\t/*\n\t\t\tpv.pb(Point(xl,0));\n\t\t\tpv.pb(Point(xr,0));\n\t\t\tpv.pb(Point(xl,h));\n\t\t\tpv.pb(Point(xr,h));\n\t\t\tif(xl < 0 && 0 < xr){\n\t\t\t\tpv.pb(Point(0,h));\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tmv[-r-1].fi = mv[-r-1].se;\n\t\tmv[r+1].se = mv[r+1].fi;\n\n\t\t// cout<<\"=======\"<<endl;\n\t\tfor(int i=-20;i<=20;i++){\n\t\t\t\n\t\t\t// cout << min(mv[i].fi,mv[i].se) << endl;\n\t\t\tpv.pb(Point(i,min(mv[i].fi,mv[i].se)));\n\t\t}\n\t\t// cout<<\"=======\"<<endl;\n\n/*\n\t\tfor(int i=-20;i<21;i++){\n\t\t\tpv.pb(Point(i,min(mv[i],mv[i+1])));\n\t\t}\n\n\t\tcout<<\"-----------\"<<endl;\n\t\trep(i,pv.size()){\n\t\t\tif(pv[i].y!=23)cout<<pv[i].x<<\" \"<<pv[i].y<<endl;\n\t\t}\n\t\tcout<<\"--------\"<<endl;\n*/\n\n\t\tfor(double t = 0; t<=20;t+=0.00005){\n\t\t\tPoint c = Point(0,-r+t);\n\t\t\trep(i,pv.size()){\n\t\t\t\tif((c-pv[i]).abs_()<=r){\n\t\t\t\t\t// cout<<(c-pv[i]).abs_()<<endl;\n\t\t\t\t\tprintf(\"%lf\\n\",t);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\t/*\n\t\t// Polygon pt;\n\t\t// pt = andrewScan(pv);\n\t\t// rep(i,pv.size()){\n\t\t// \tcout << \"pv :\" << pv[i].x << \" \"<< pv[i].y << endl;\n\t\t// }\n\n\t\trep(i,pt.size()){\n\t\t\tcout << \"pt :\" << pt[i].x << \" \"<< pt[i].y << endl;\n\t\t}\n*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint x[22][42];\nint r, n;\nint dx[] = {0, -1, -1, 0};\nint dy[] = {0, 0, -1, -1};\n\nbool check(double t) {\n  repl(i, 1, 21)repl(j, 1, 41) {\n    if ((i - 1 - t + r) * (i - 1 - t + r) + (j - 21) * (j - 21) <= r * r) {\n      rep(k, 4) {\n        if (x[i + dy[k]][j + dx[k]] == 0) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  rep(i, 22)rep(j, 42) x[i][j] = 1;\n\n  while(cin >> r >> n, r) {\n    repl(i, 1, 21)repl(j, 1, 41) x[i][j] = 0;\n\n    rep(i, n) {\n      int l, r, h;\n      cin >> l >> r >> h;\n\n      repl(k, 1, h + 1)repl(j, l + 21, r + 21) x[k][j] = 1;\n    }\n\n    double ok = 0, ng = 20, md;\n    rep(i, 100) {\n      md = (ok + ng) / 2;\n      if (check(md)) ok = md;\n      else ng = md;\n    }\n\n    printf(\"%.10f\\n\", ok);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ndouble INF = 10e8;\nint plus20[40];\nint maxh[21];\n\nint main(){\n    while(1){\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if(r==0) break;\n\n        REP(i, 40) plus20[i] = 0;\n        REP(i, n){\n            int xr, xl;\n            double h;\n            cin >> xr >> xl >> h;\n            for(int j = xr+20; j < xl+20; j++){\n                plus20[j] = max((double)plus20[j], h);\n            }\n        }\n\n        REP(i, 21) maxh[i] = 0;\n        REP(i, r+1){\n            if(i==r){\n                maxh[i] = 0;\n            } else {\n                double ph = min(plus20[20+i], plus20[20+i-1]);\n                double nh = min(plus20[20-i], plus20[20-i-1]);\n                maxh[i] = min(ph, nh);\n                cout << maxh[i] << \" \"; //\n            }\n        }\n        cout << endl;\n\n        double output = INF;\n        REP(i, r){\n            output = min(output, r - sqrt(pow(r, 2)-pow(i, 2)) + maxh[i]);\n        }\n\n        cout << fixed << setprecision(4) << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nrandom_device rnd;\nmt19937 mt(rnd());\n\nconst lld EPS = 1e-9;\nconst int IINF = 1 << 30;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1e9 + 7;\nlld r, n;\n\nlld calcdist(lld x, lld y)\n{\n    if (fabsl(x) >= r)\n    {\n        return 101010;\n    }\n    lld ok = -r;\n    lld ng = y;\n    while (fabsl(ok - ng) > EPS)\n    {\n        lld mid = (ok + ng) / 2;\n        if ((x * x + (y - mid) * (y - mid)) < r * r)\n        {\n            ng = mid;\n        }\n        else\n        {\n            ok = mid;\n        }\n    }\n    return ok + r;\n}\n\nint main()\n{\n    while (cin >> r >> n, r)\n    {\n        lld ans = 101010;\n        map<int, lld> mp;\n\n        rep(i, n)\n        {\n            int xl, xr;\n            lld h;\n            cin >> xl >> xr >> h;\n            rep(j, xl, xr)\n            {\n                chmax(mp[j], h);\n            }\n        }\n        lld cur = 0;\n        rep(i, -20, 20)\n        {\n            lld x = i;\n            lld y = min(mp[x], mp[x - 1]);\n            chmin(ans, calcdist(x, y));\n        }\n        cout << fixed << setprecision(18) << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,n){\n\t\tdouble l=-R,r;\n\t\tint ma=0;\n\t\tvi in(50,0);\n\t\twhile(n--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tma=max(ma,c);\n\t\t\tloop(i,a,b)in[i+25]=max(in[i+25],c);\n\t\t}\n\t\tr=ma-R;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tbool q=true;\n\t\t\tloop(i,1,50){\n\t\t\t\tdouble dis=hypot(min(in[i],in[i-1])-h,i-25);\n//\t\t\t\tcout<<i-25<<\" \"<<dis<<endl;\n\t\t\t\tif(dis+EPS<(double)R)q=false;\n\t\t\t}\n\t\t\tif(q)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.8f\\n\",l+R);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <math.h>\n\n#define DEBUG 0\n\nusing namespace std;\n\nint max(int a,int b){\n\treturn a>=b ? a : b;\n}\nint min(int a,int b){\n\treturn a>=b ? b : a;\n}\n\nint main(){\n\n\tint r,n;\n\tint xi,xr,h;\n\n\twhile(cin>>r>>n){\n\t\tif(r==0 && n==0){\n\t\t\tbreak;\n\t\t}\n\n\t\tmap< int , int > data;\n\t\tmap< int , int > data2;\n\n\t\tfor(int i=-42;i<=42;i++){\n\t\t\tdata[i]=0;\n\t\t\tdata2[i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>xi>>xr>>h;\n\t\t\tfor(int j=0;j+xi*2<=xr*2;j++){\n\t\t\t\tdata[j+xi*2] = max(data[j+xi*2],h);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(DEBUG){\n\t\tfor(int i=-40;i<=40;i++){\n\t\t\tcout<<i<<\" \"<<data[i]<<endl;\n\t\t}\n\t\t}\n\n\t\tfor(int i=-40;i<=40;i+=2){\n\t\t\tdata[i]=min(data[i-1],data[i+1]);\n\t\t}\n\n\t\tif(DEBUG){\n\t\tfor(int i=-40;i<=40;i++){\n\t\t\tcout<<i<<\" \"<<data[i]<<endl;\n\t\t}\n\t\t}\n\n\t\tfor(int i=-20;i<=20;i++){\n\t\t\tdata2[i] = data[i*2];\n\t\t}\n\t\tdouble ans = 100000000;\n\t\tfor(int i=-r+1;i<r;i++){\n\t\t\tdouble offset = r - sqrt(r*r - i*i);\n\t\t\tif(DEBUG){\n\t\t\t\tcout<<\"ans=\"<<ans<<\" data2[i]= \"<<data2[i]<<\" offset= \"<<offset<<endl;\n\t\t\t}\n\t\t\tif(ans >= data2[i]+offset){\n\t\t\t\tans = data2[i]+offset;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n\nusing namespace std; using namespace placeholders;\n\ntypedef vector< int > VI;\n\ntemplate < typename T > inline T fromString( const string &s ){ T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) (c).begin(), (c).end()\n#define AALL( a, t ) (t*)a, (t*)a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nbool ok( const int r, const VI &highest, const double t )\n{\n\tdouble cx = 32, cy = -r + t;\n\n\tREP( x, 0, 63 )\n\t{\n\t\tconst double dx1 = x - cx;\n\t\tconst double dx2 = ( x + 1 ) - cx;\n\n\t\tconst double dy1 = dx1 < r ? sqrt( r * r - dx1 * dx1 ) : -1000;\n\t\tconst double dy2 = dx2 < r ? sqrt( r * r - dx2 * dx2 ) : -1000;\n\n\t\tif ( highest[x] < cy + max( dy1, dy2 ) )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 8 ) << fixed;\n\n\tfor ( int r, n; cin >> r >> n, ( r | n ); )\n\t{\n\t\tVI highest( 64 );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint a, b, h;\n\t\t\tcin >> a >> b >> h;\n\t\t\ta += 32;\n\t\t\tb += 32;\n\n\t\t\tREP( j, a, b )\n\t\t\t{\n\t\t\t\thighest[j] = max( highest[i], h );\n\t\t\t}\n\t\t}\n\n\t\tdouble lb = 0, ub = 100;\n\t\tREP( iteration, 0, 100 )\n\t\t{\n\t\t\tconst double mid = ( lb + ub ) / 2;\n\t\t\t( ok( r, highest, mid ) ? lb : ub ) = mid;\n\t\t}\n\n\t\tcout << lb << endl;\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\t\t\n\t\tmap<int, int> d,d2;\n\t\tfor (int x = -21; x < 21; x++)d[x] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor (int x = xl + 1; x <= xr; x++)d[x] = max(d[x], h);\n\t\t\tfor (int x = xl; x < xr; x++)d2[x] = max(d2[x], h);\n\t\t}\n\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x++){\n\n\n\t\t\tdouble ty = double(r) - sin(acos(abs(x / double(r)))) * double(r);\n\n\t\t\tif (x != -r)ans = min(ans, double(d[x] + ty));\n\t\t\tif (x != r)ans = min(ans, double(d2[x] + ty));\n\t\t}\n\n\t\tcout << setprecision(6) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(ll i=(n);i<(N);i++)\n#define RREP(i,n,N) for(ll i=(N-1);i>=(n);i--)\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(), (v).end()\n#define MCP(a,b) memcpy(b,a, sizeof(b))\n#define p(s) cout<<(s)<<endl\n#define p2(a,b) cout<<(a)<<\" \"<<(b)<<endl\ntypedef long long ll;\nusing namespace std;\nconst ll mod = 1e9+7;\nconst ll inf =1e18;\n\nll r, n;\nll height[50];\nint main(){\n    while(cin>>r>>n && r!=0 || n!=0){\n        REP(i,0,50) height[i] = 0;\n        REP(i, 0, n){\n            ll xl, xr, y;\n            cin>>xl>>xr>>y;\n            REP(j, xl, xr){\n                height[j+20]=max(height[j+20], y);\n            }\n        }\n\n        bool ok=false;\n        for(double t=0; t<=21; t+=0.001){\n            REP(i, -r+1, r){\n                double h=sqrt(r*r-i*i);\n                if(h+t+0.000001>=min(height[20+i], height[20+i-1])+r){\n                    printf(\"%.4lf\\n\", t);\n                    ok=true;\n                    break;\n                }\n            }\n            if(ok) break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this); \n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto dist = distance_lp(l, c);\n  if(dist > c.r + EPS) { return {{-inf,-inf},{-inf,-inf}}; }\n  auto basehalf = sqrt(c.r * c.r - dist * dist);\n  P v = (l[1]-l[0]) * P(0, 1);\n  Line h(c, c+v); P ph = crosspoint(l, h);\n  P u1 = (ph + v) * P(0, 1); u1 /= abs(u1); u1 *= basehalf;\n  P u2 = (ph + v) * P(0, -1); u2 /= abs(u2); u2 *= basehalf;\n  return {u1, u2};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  for(int R, N; cin >> R >> N && (R | N);) {\n    vector<int> hs(44); int const OF = 22;\n    rep(i, N) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      REP(x, xl, xr) {\n        maximize(hs[x+OF], h);\n      }\n    }\n    vector<P> events;\n    int currh = 0;\n    events.emplace_back(-22, 0);\n    REP(x, -21, 22) {\n      if(currh != hs[x+OF]) {\n        events.emplace_back(x, currh);\n        currh = hs[x+OF];\n        events.emplace_back(x, currh);\n      }\n      else {\n        if(x == 0) {\n          events.emplace_back(x, currh);\n        }\n      }\n    }\n\n//    for(auto && e: events) { cout << e << endl; } cout << endl;\n\n    Circle c(P(0, -R), R);\n\n    for(double t=0; t<=20; t+=0.00005) {\n      bool ok = 0;\n      rep(i, events.size()) {\n        if(abs(c - events[i]) < c.r) {\n          printf(\"%.10f\\n\", t);\n          ok = 1;\n          break;\n        }\n      }\n      if(ok) { break; }\n      c.cent[1] += 0.00005;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define SZ 20\n\nint mat[SZ+1][2*SZ+1];  //no-shade:0, shade:plus, mat[height][width+20]\n\nint main(){\n  int r,n;\n  while(scanf(\"%d %d\",&r,&n), r|n){\n\n    // initialize\n    rep(i,SZ+1){\n      rep(j,2*SZ+1){\n\tmat[i][j]=0;\n      }\n    }\n\n    // input provess for imosu\n    rep(i,n){\n      int xl, xr, h;\n      scanf(\"%d %d %d\", &xl, &xr, &h);\n      mat[0][xl+20]++;\n      mat[0][xr+20]--;\n      mat[h][xl+20]--;\n      mat[h][xr+20]++;\n    }\n    \n    // imosu\n    rep(i,SZ){\n      repl(j,1,2*SZ){\n\tmat[i][j] += mat[i][j-1];\n      }\n    }\n    rep(i,2*SZ){\n      repl(j,1,SZ){\n\tmat[j][i] += mat[j-1][i];\n      }\n    }\n\n    // move sun from bottom\n    int t=0;\n    int w;\n    while(t<20){\n      w=0;\n      while(w<r){\n\tif(mat[t][20+w]>0 && mat[t][19-w]>0){\n\t  w++;\n\t}else{\n\t  break;\n\t}\n      }\n      if(w==r) t++;\n      else break;\n    }\n\n    if(t==20){\n      cout<<20<<endl;\n      continue;\n    }\n\n    double res = sqrt(r*r-w*w);\n    res = (double)(t+r) - res;\n\n    printf(\"%.4f\\n\", res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\nusing namespace std;\n\nvector<int> h;\nint n, r;\nint get_h(int x) {\n    return h[x + 23];\n}\n\nvoid set_h(int x, int k) {\n    h[x + 23] = k;\n} \n\ndouble get_t(int x, int k) {\n    if (abs(x) >= r) return 100; \n    return k - sqrt(r * r - x * x) + r;\n}\n\nint main(){\n    while(1) {\n        cin >> r >> n;\n        if (r == 0) break;\n        h = vector<int>(50, 0);\n        REP(i, n) {\n            int li, ri, hi;\n            cin >> li >> ri >> hi;\n            for (int j = li; j < ri; ++j) {\n                set_h(j, max(get_h(j), hi));\n            }\n        }\n        double ans = 100;\n        for (int x = -20; x <= 20; ++x) {\n            ans = min(ans, get_t(x, get_h(x)));\n            ans = min(ans, get_t(x + 1, get_h(x)));\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50\n\nint main(){\n  double r;\n  int n;\n  while(cin >> r >> n, r){\n    int H[MAX] = {0},xl,xr,h;\n    for(int i = 0 ; i < n ; i++){\n      cin >> xl >> xr >> h;\n      xl += 20; xr += 20;\n      for(int j = xl ; j < xr ; j++){\n        H[j] = max(H[j],h);\n      }\n    }\n    double res = (1<<29);\n    for(int i = 20-r ; i < 20+r ; i++){\n      double rr = i-20+(i<20);\n      res = min(res,r+H[i]-sqrt(r*r-rr*rr));\n    }\n    printf(\"%.8f\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, n){\n    vector<int> hl(50, 0), hr(50, 0);\n    for (int i = 0; i < n; i++) {\n      int xr, xl, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl + 1; j < xr; j++) {\n        hl[j + diff] = hr[j + diff] = h;\n      }\n      hl[xl + diff] = hr[xr + diff] = h;\n    }\n    double ans = 1e9;\n    for (int i = -r + 1; i < r; i++) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint r, n; cin >> r >> n;\n\t\tif(!r && !n) break;\n\t\tint y[40] = {0};\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\tfor(int j=xl; j < xr; j++){\n\t\t\t\ty[j+20] = max(h, y[j+20]);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 999;\n\t\tfor(int i=-r+1; i<r; i++){\n\t\t\tint h = min(y[i+19], y[i+20]);\n\t\t\tdouble time = h + r - sqrt(r*r - i*i);\n\t\t\tans = min(ans, time);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\ntypedef pair<mp,ll> mmp;\n\n\nint main(){\n while(1){\n  ll r,n;\n  cin>>r>>n;\n  if(r==0 &&n == 0 )break;\n  vector<mmp> x(n),y(n);\n  for(ll i=0;i<n;i++){\n   ll xl,xr,h;\n   cin>>xl>>xr>>h;\n   x[i] = mmp( mp(xl,xr) , h );\n   y[i] = mmp( mp(-xr,-xl) , h);\n  }\n  sort( x.begin() , x.end() );\n  sort( y.begin() , y.end() );\n\n  vector<ll> left(21,0),right(21,0);\n  for(ll i=0;i<n;i++){\n   for(ll j=0;j<x[i].second;j++){\n    if( x[i].first.first <= left[j] ){\n     left[j] = max( left[j] , x[i].first.second );\n    }\n   }\n   for(ll j=0;j<y[i].second;j++){\n    if( y[i].first.first <= right[j] ){\n     right[j] = max( right[j] , y[i].first.second );\n    }\n   }\n  }\n\n  double res = 20;\n  for(ll i=0;i<21;i++){\n   ll lr = min( r, min( right[i] , left[i] ) );\n   double rr = i+  r-sqrt( r*r - lr*lr ) ;\n   if( lr == r ) rr = 20;\n   res = min( res , rr );\n   if( lr == 0 ) break;\n //  cout<<lr<<' '<<rr <<endl;\n  }\n\n  printf(\"%0.10lf\\n\",res);\n\n }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define Sort(a) sort(a.begin(), a.end())\ntypedef long long int ll;\ntypedef vector<double> vi;\n\nint main(){\n    while(1){\n        double r, n;\n        cin >> r >> n;\n        if(r == 0 && n == 0) break;\n        vi hr(41), hl(41);\n        rep(i, 41){\n            hr[i] = 0; hl[i] = 0;\n        }\n        vi xl(n), xr(n), h(n);\n        rep(i, n){\n            cin >> xl[i] >> xr[i] >> h[i];\n            xl[i] += 20;\n            xr[i] += 20;\n            rep(j, abs(xr[i]-xl[i])){\n                hl[xl[i]+j] = max(h[i], hl[xl[i]+j]);\n                hr[xl[i]+j+1] = max(h[i], hr[xl[i]+j+1]);\n            }\n        }\n        hr[20-r] = hl[20-r];\n        hl[20+r] = hr[20+r];\n        double min_t = 100;\n        for(int i = 20-r; i <= r+20; i++){\n            double b = abs(20-i);\n            double a = sqrt(r*r-b*b);\n            min_t = min(min_t, (r-a)+min(hr[i], hl[i]));\n            //cout << min_t << \" \" << i << endl;\n        }\n        printf(\"%.5lf\\n\", min_t);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll=long long;\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define ALL(s) s.begin(),s.end()\n#define P pair<ll,ll>\n#define vl vector<ll>\n#define vi vector<int>\n#define vvl vector<vector<ll>>\n#define vvi vector<vector<int>>\n#define print(n) cout<<n<<endl\nconst int M=100111;\nconst int inf=1000000007;\nconst long long INF=1000000000000000007;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint ddx[8]={1,-1,0,0,1,-1,-1,1},ddy[8]={0,0,1,-1,1,-1,1,-1};\n\nint main(){\n\tint n,r,x1,x2,h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0&&n==0)break;\n\t\tmap<int,int> mp;\n\t\trep(i,0,n){\n\t\t\tcin>>x1>>x2>>h;\n\t\t\trep(x,x1,x2){\n\t\t\t\tmp[x]=max(mp[x],h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans=inf;\n\t\trep(x,-r,r){\n\t\t\tdouble p=(x<0?x+1:x);\n\t\t\tans=min(ans,mp[x]+r-sqrt(r*r-p*p));\n\t\t}\n\t\tprint(setprecision(15)<<ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 2*r+1; ++i) V[i] = 0;\n    double ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = max(xl,-r); j < min(xr,r); ++j){\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i-1] + r - sqrt(r*r - (i-r)*(i-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[50],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=-x-0.9999,R=x+0.9999,hb[101]={};\n\n  for(int i=L+25;i<R+25;i++){\n    int x1=i-24-i/25;\n    double y1=y[i]-cy;\n    if(x1*x1+y1*y1>=r*r)hb[i]++;\n  }\n  for(int i=L+25;i<R+25;i++)if(!hb[i])return 0;\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<50;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+25]=max(y[j+25],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.0009;\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\nstruct Circle{\n  double r;\n  P c;\n  Circle(){}\n  Circle(double r,P c): r(r),c(c) {}\n};\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-8;\n\nint R,N;\nvector<P> line;\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint contains(vector<P> v, P p){ \n  bool in = false; \n  for(int i=0;i<v.size();i++){ \n    P a = v[i] - p; \n    P b = v[(i+1)%v.size()] - p; \n    if(imag(a) > imag(b)) swap(a,b); \n    if((imag(a) <= 0 || equal(imag(a),0.0)) && EPS < imag(b)) \n      if(cross(a,b) < -EPS) in = !in; \n    if(equal(cross(a,b), 0.0) && dot(a,b) < EPS) return 1; \n  } \n  return in ? 2 : 0; \n}\n\nbool check( Circle c ){ \n if( contains(line,c.c) != 2 ) return false;\n  for(int i=0;i<(int)line.size();i++){\n    if(abs(line[i] - c.c) < c.r - EPS) return false;\n  }\n  return true;\n}\n\nint main(){\n  while( cin >> R >> N && (R|N) ){\n    vector<int> vv[50];\n\n    for(int i=0;i<N;i++){\n      int x1,x2,h;\n      cin >> x1 >> x2 >> h;\n      for(int j=x1;j<x2;j++) vv[j+25].push_back(h);\n    }\n\n    for(int i=0;i<50;i++){\n      vv[i].push_back(0);\n      sort(vv[i].begin(), vv[i].end(), greater<int>());      \n    }\n\n\n    line.clear();\n    line.push_back(P(INF, 0));\n    for(int i=49;i>=0;i--){\n      line.push_back(P(i-24,vv[i][0]));\n      line.push_back(P(i-25,vv[i][0]));\n    }\n    line.push_back(P( -INF, 0 ));\n    line.push_back( P(-INF, -INF) );\n    line.push_back( P(INF, -INF) );\n\n    double st = 0.0, ed = INF/10;\n    double res;\n\n    while(!equal(ed,st)){\n      res = (st+ed)/2.0;\n      Circle c = Circle(R,P(0,res-(double)R));\n      if( check( c ) ) st = res;\n      else ed = res;\n    }\n    printf(\"%.5lf\\n\",res);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 1e9 + 7;\nusing pii = pair<int, int>;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\nconst int mod = 1e9 + 7;\nll power(ll a,ll b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\n \nint main() {\n    int r, n;\n    while (cin >> r >> n) {\n        if (r == 0 && n == 0) break;\n        vector<pair<pair<double, double>, double> > v;\n        rep(i, n) {\n            int xl, xr, h; cin >> xl >> xr >> h;\n            v.push_back({{xl, xr}, h});\n        }\n        double left = -r, right = r + 20; //center\n        int c = 0;\n        int roll = 100;\n        while (c++ < roll) {\n            double mid = (left + right) / 2;\n            //cout << \"mid \" << mid << endl;\n            int flg = 0;\n            rep(i, 10000) {\n                flg = 0;\n                double x = r * cos(2 * M_PI * i / 360);\n                double y = mid + r * sin(2 * M_PI * i / 360);\n                if (y < 0) {flg = 1; continue;}\n                rep(j, v.size()) { //どっかの中に入ってろ\n                    if (v[j].first.first <= x && x <= v[j].first.second && y <= v[j].second) {\n                        //if (mid == 1) cout << v[j].first.first << \" \" << v[j].first.second << \"   \" << x << \" \" << y << endl;\n                        flg = 1;\n                        break;\n                    }\n                }\n                if (flg == 0) {\n                    right = mid;\n                    break;\n                }\n            }\n            if (flg == 1) {\n                left = mid;\n            }\n            //cout << left << \" \" << right << endl;\n            if (c == roll) cout << fixed << setprecision(7) << mid + r << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Point { double x,y; };\n\nconst int DIFF = 50;\nint r,n;\nbool bits[100][100];\n\nint main(){\n  while( cin >> r >> n, r|n ){\n    vector<Point> ps;\n    memset(bits,false,sizeof(bits));\n    rep(i,n) {\n      int xL,xR,h;\n      cin >> xL >> xR >> h;\n      xL += DIFF, xR += DIFF;\n      rep(y,h) REP(x,xL,xR) bits[y][x] = true;\n    }\n    rep(y,100){\n      REP(x,-r,r) if( !bits[y][x+DIFF] ) {\n\tps.push_back((Point){x,y});\n\tps.push_back((Point){x+1,y});\n      }\n    }\n    assert( !ps.empty() );\n    double mini = INT_MAX;\n    rep(i,(int)ps.size()) {\n      double X = ps[i].x;\n      double Y = sqrt( r * r - X * X );\n      mini = min(mini,ps[i].y-Y+r);\n    }\n    printf(\"%.10f\\n\",mini);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tint n;\n\tdouble r;\n\twhile(cin>>r>>n,r||n){\n\t\tdouble h[50]={0};\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta+=25;b+=25;\n\t\t\tfor(int i=a;i<b;i++)h[i]=max(h[i],c);\n\t\t}\n\t\t//loop(i,20,30)cout<<\" \"<<h[i];\n\t\t//cout<<endl;\n\t\tdouble t=0;\n\t\twhile(1){\n\t\t\tt+=0.0001;\n\t\t\tbool ans=true;\n\t\t\trep(i,49){\n\t\t\t\tif((double)(i-25)*(i-25)+(r+h[i]-t)*(r+h[i]-t)<r*r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((double)(i-24)*(i-24)+(r+h[i]-t)*(r+h[i]-t)<r*r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ans)break;\n\t\t}\n\t\tcout<<t-0.0001<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define pb push_back\n\n\nint r,n;\nint a,b,c;\nint main(){\n\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0&&n==0)return 0;\n\t\t\n\t\tint h[40]={0};\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a>>b>>c;\n\n\t\t\tfor(int j=a;j<b;j++){\n\t\t\t\th[j+20]=max(h[j+20],c);\n\t\t\t}\n\t\t}\n\n\t\t// for(int i=0;i<40;i++){\n\t\t// \tcout<<i<<\":\"<<h[i]<<endl;\n\t\t// }\n\n\t\tdouble ans=114514.0;\n\t\tdouble tmp;\n\n\t\tfor(int i=-1*r;i<r;i++){\n\t\t\ttmp=max(sqrt(r*r-i*i),sqrt(r*r-(i+1)*(i+1)));\n\t\t\tans=min(ans,h[i+20]-tmp+r);\n\t\t}\n\t\tcout<<ans<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\ntypedef long double ld;\ntypedef vector<ld> vd;\n\nconst ld EPS = 10e-10;\n\nld solve();\nbool search(const ld t, const ld r, vd& s);\n\nint main(void) {\n\t\n\twhile(true){\n\t\tld ans = solve();\n\t\tif( ans < 0.0 ) { break; }\n\t\tcout << fixed << setprecision(5) << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n\nbool search( const ld t, const ld r, vd& s ) {\n\n\tfor( int i = -20; i < 20; i++ ) {\n\n\t\tld d[2]={(ld)i,(ld)i+1.0};\n\n\t\tfor(int j = 0; j < 2; j++)\n\t\t\tif(d[j]>=-r+EPS&&d[j]+EPS<=r)\n\t\t\t\tif(sqrt(r*r-d[j]*d[j])+t>r+s[i+20]+EPS) \n\t\t\t\t\treturn false;\n\t\n\t}\n\n\treturn true;\n}\n\nld solve() {\n\n\tld r, low=0.0, high=21.0, mid;\n\tint n, m;\n\tvd v(40,0.0);\n\t\n\tcin >> m >> n;\n\tr = (ld)m;\n\t\n\tif( m == 0 && n == 0 ) { return -1.0; }\n\n\tfor( int i = 0; i < n; i++ ) {\n\n\t\tint xl, xr;\n\t\tld h;\n\t\tcin >> xl >> xr >> h;\n\n\t\tfor( int j = xl+20; j < xr+20; j++ )\n\t\t\tif( v[j] < h ) \n\t\t\t\tv[j] = h;\n\t}\n\t\n\tfor( int i = 0; i < 1000; i++ ) {\n\t\tmid = (high+low)/2.0;\n\t\tif( search(mid,r,v) )\n\t\t\tlow = mid;\n\t\telse \n\t\t\thigh = mid;\n\t}\n\n\treturn mid;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint main(){\n\twhile(1){\n\t\tint r; int n;\n\t\tint xl[25],xr[25],y[25];\n\t\tscanf(\"%d%d\",&r,&n);\n\t\tif(abs(r-0.0)<1e-9 && n == 0) return 0;\n\t\tmap<int,int>M;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d\",&xl[i],&xr[i],&y[i]);\n\t\t\tfor(int j=xl[i];j<xr[i];j++) M[j] = max(M[j],y[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int X=-r;X<=-1;X++){\n\t\t\t//[X,X+1], X+1 is highest\n\t\t\tif(M.find(X) == M.end()){\n\t\t\t\tans = 0.0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble L = sqrt((double)r*(double)r - (double)(X+1)*(double)(X+1));\n\t\t\t\tL = (double)r-L;\n\t\t\t\tans = min(ans,L+(double)M[X]);\n\t\t\t}\n\t\t}\n\t\tfor(int X=0;X<r;X++){\n\t\t\t//[X,X+1], X is highest\n\t\t\tif(M.find(X) == M.end()){\n\t\t\t\tans = 0.0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble L = sqrt((double)r*(double)r - (double)(X)*(double)(X));\n\t\t\t\tL = (double)r-L;\n\t\t\t\tans = min(ans,L+(double)M[X]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nbool EQ(double a, double b) { return abs(a - b) < EPS; }\n\ndouble getHeight(double r, double x) {\n\treturn sqrt(r * r - x * x);\n}\n\nint main(void) {\n\tint r, n;\n\twhile(scanf(\"%d %d\", &r, &n), r > 0) {\n\t\tint left[20], right[20], height[20];\n\t\tfor(int i = 0; i < n; i++) scanf(\"%d %d %d\", left + i, right + i, height + i);\n\t\tvector<double> xs;\n\t\txs.push_back(-r + 1e-5);\n\t\txs.push_back(r - 1e-5);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble cand = left[i] - 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = left[i] + 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] - 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] + 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t}\n\n\t\tdouble s = 0, e = 100;\n\t\tfor(int lv = 0; lv < 100; lv++) {\n\t\t\tdouble mid = (s + e) / 2;\n\t\t\tbool isAble = true;\n\n\t\t\tfor(double x: xs) {\n\t\t\t\tbool isIncluded = false;\n\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t\tif(left[i] <= x and x <= right[i] and height[i] >= getHeight(r, x) - r + mid) {\n\t\t\t\t\t\tisIncluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tif(!isIncluded) {\n\t\t\t\t\tisAble = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isAble) s = mid;\n\t\t\telse e = mid;\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\", s);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ndouble eq(double x) { return fabs(x) < 0.000001; }\n\ndouble f(double r, double x) {\n  if (fabs(x) > r)\n    return -100000000;\n  if (eq(fabs(x) - r))\n    return -r;\n  return -(r - sqrt(r * r - x * x));\n}\n\nint main() {\n  while (true) {\n    int r, n;\n    cin >> r >> n;\n    if (r == 0 && n == 0)\n      break;\n    double ans = 10000000000;\n    vector<pair<int, int>> x(n);\n    vector<int> h(n);\n    for (int i = 0; i < n; i++)\n      cin >> x[i].first >> x[i].second >> h[i];\n    int H[50][2] = {0};\n    int offset = 25;\n    for (int i = 0; i < n; i++) {\n      for (int j = max(-r, x[i].first); j < min(r + 1, x[i].second); j++) {\n        H[j + offset][0] = max(H[j + offset][0], h[i]);\n      }\n      for (int j = max(-r, x[i].first + 1); j <= min(r, x[i].second); j++) {\n        H[j + offset][1] = max(H[j + offset][1], h[i]);\n      }\n    }\n    for (int i = -r; i <= r; i++) {\n      if (i < r)\n        ans = min(ans, H[i + offset][0] - f(r, i));\n      if (i > -r)\n        ans = min(ans, H[i + offset][1] - f(r, i));\n    }\n    printf(\"%.9lf\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=30;\nint xl[60];\nint xr[60];\n\nint main(void){\n\tint r,n;\n\twhile(cin >> r >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\trep(i,60) xl[i]=xr[i]=0;\n\t\trep(i,n){\n\t\t\tint l,r,h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tl+=offset,r+=offset;\n\t\t\tfor(int j=l;j<=r;++j){\n\t\t\t\tif(j!=l)\n\t\t\t\t\txl[j]=max(xl[j],h);\n\t\t\t\tif(j!=r)\n\t\t\t\t\txr[j]=max(xr[j],h);\n\t\t\t}\n\t\t}\n\t\tdouble cmin=inf;\n\t\tfor(int x=-r;x<=r;++x){\n\t\t\tint h=inf;\n\t\t\tif(x!=-r)h=min(h,xl[x+offset]);\n\t\t\tif(x!=r)h=min(h,xr[x+offset]);\n\n\t\t\tint diff=r*r-x*x;\n\t\t\tif(diff<0){\n\n\t\t\t}\n\t\t\tdouble y=sqrt(diff);\n\t\t\tdouble t=h-y+r;\n\t\t\tcmin=min(cmin,t);\n\t\t}\n\t\tcout.precision(9);\n\t\tcout << fixed << max(cmin,0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\ndouble solve(int r,int n){\n  bool box[21][41] {{false}};\n  rep(i,n) {\n    int li,ri,hi;\n    cin >> li >> ri >> hi;\n\n    rep(y,hi) {\n      for(int x=li+20;x<ri+20;++x){\n        box[y][x]=true;\n      }\n    }\n\n  }\n  double ans=(double)1e9;\n  rep(y,21){\n    for(int x=20-r;x<r+20;x++) if(!box[y][x]){\n      double time;\n      if(x<20) time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n      else time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n      ans=min(ans,time);\n    }\n  }\n  return ans;\n}\n\nint main(int argc, char *argv[])\n{\n  int r,n;\n  while(cin>>r>>n,r&&n){\n    printf(\"%0.4lf\\n\",solve(r,n));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint main(){\n  double r,n;\n  cin >> r >> n;\n  while(r!=0||n!=0){\n    int i,j,k;\n    double xr,xl,h;\n    double hs[41]={};\n    for(i=0;i<n;i++){\n      cin >> xr >> xl >> h;\n      for(j=xr;j<xl;j++){\n\ths[j+20]=max(hs[j+20],h);\n      }\n    }\n    /*\n    for(i=0;i<=40;i++) cout << hs[i] ;\n    cout << endl;\n    */\n    double o=0;\n    int f=0;\n    while(f==0){\n      o+=0.0001;\n      int w;\n      if(o<r){\n\tw = (int) sqrt((r*r)-(r-o)*(r-o));\n\tif(w==sqrt((r*r)-(r-o)*(r-o))) w-=1;\n      }\n      else{\n\tw=r-1;\n      }\n      //cout << w << endl;\n      for(j=-w-1;j<-1;j++){\n\tif(hs[j+20]<o-r+sqrt((r*r)-(r+j+1)*(r+j+1))){\n\t  //cout << w << \":\" << o << \":\" << hs[j+20]  << \":\" <<  j << endl;\n\t  f=1;\n\t}\n      }\n      if(hs[20-1]<o){\n\tf=1;\n      }\n      if(hs[20]<o){\n\tf=1;\n      }\n      for(j=1;j<=w;j++){\n\tif(hs[j+20]<o-r+sqrt((r*r)-(r-j)*(r-j))){\n\t  //cout << w << \":\" << o << \":\" << hs[j+20]  << \":\" <<  j << endl;\n\t  f=1;\n\t}\n      }\n    }\n    \n    printf(\"%.4f\\n\",o-0.0001);\n    cin >> r >> n;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n\nclass Solver {\n  public:\n    int R, N;\n    vector<int> XL, XR, H;\n    int get_height(double x) {\n        int res = 0;\n        rep(i, N) if(XL[i] <= x and x <= XR[i]) set_max(res, H[i]);\n        return res;\n    }\n    bool check(double t) {\n        rep(i, 80 + 1) {\n            for(int j = -1; j <= 1; j++) {\n                double x = (i - 40) / 2.0 + 1e-5 * j;\n                double h = sqrt(R * R - x * x) - R + t;\n                if(get_height(x) <= h) return false;\n            }\n        }\n        return true;\n    }\n    bool solve() {\n        cin >> R >> N;\n        if(R == 0) return false;\n        XL.resize(N); XR.resize(N); H.resize(N);        \n        rep(i, N) cin >> XL[i] >> XR[i] >> H[i];\n\n        double l = 0, r = 21;\n        while(r - l > 1e-8) {\n            double m = (l + r) / 2.0;\n            (check(m) ? l : r) = m;\n        }\n        printf(\"%.10lf\\n\", l);\n        return true;\n    }\n};\n\nint main() {\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//与えられる座標は小さな整数だし、和集合求めるの面倒くさい。整数座標で圧縮して適当にやる。\n#include<iostream>\n#include<stdio.h>\n#include<cmath>\nusing namespace std;\n\nconst int TX = 20;\n\nint r, n;\nint xl, xr, y;\nint data[50];\t//data[x] = [x, x+1)の高さ\t更新は[l,r)なので注意\n\nint main() {\n\twhile( cin >> r >> n ) {\n\t\tif (!r) break;\n\t\tint i, j;\n\t\tfor( i = 0; i <41; i++ )\n\t\t\tdata[i] = 0;\n\t\t\t\t\n\t\tfor( i = 0; i < n; i++ ) {\n\t\t\tcin >> xl >> xr >> y;\n\t\t\txl += TX;\n\t\t\txr += TX;\n\t\t\tfor( j = xl; j < xr; j++ ) {\n\t\t\t\tdata[j] = max( data[j], y );\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble ans = 114514;\n\t\tfor( i = TX - r; i < TX + r; i++ ) {\n\t\t\tdouble h1, h2, h, hit_h;\n\t\t\t//円が(x,y)と当たる時の座標を直接求めるのは難しそう…(扇形？いや違うなあ)\n\t\t\t//円が(x,0)と当たる時は？、三角関数やるだけ！\n\t\t\th1 = -(double)r + sqrt( (double)r*r - (i-TX)*(i-TX) );\n\t\t\th2 = -(double)r + sqrt( (double)r*r - (i+1-TX)*(i+1-TX) );\n\t\t\t//h1 = -(double)r + (double)r * cos( (double)(i - TX)/(double)r );\n\t\t\t//h2 = -(double)r + (double)r * cos( (double)(i + 1 - TX)/(double)r );\n\t\t\th = max(h1, h2);\n\t\t\t//cout << \"i = \" << i-TX << \" h1 = \"<< h1 << \" h2 = \" << h2 << \" h = \" << h << \" data = \" << data[i] << endl;\n\t\t\thit_h = (double)data[i] - h;\n\t\t\t\n\t\t\tans = min(ans, hit_h);\n\t\t}\n\t\tprintf(\"%.14f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int diff = 20;\n\nbool solve() {\n    int R, N;\n    cin >> R >> N;\n    if (R == 0) return false;\n\n    vector<int> H(41, 0);\n    for (int i = 0; i < N; ++i) {\n        int l, r, h;\n        cin >> l >> r >> h;\n        l += diff, r += diff;\n        for (int x = l; x < r; ++x) {\n            H[x] = max(H[x], h);\n        }\n    }\n\n    double ans = 20;\n    for (int x = -R + 1; x < R; ++x) {\n        int xi = x + diff;\n        int h = min(H[xi - 1], H[xi]);\n        ans = min(ans, h - sqrt(R * R - x * x) + R);\n    }\n    cout << fixed << setprecision(10) << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint n;\ndouble r;\nint t[100];\nvector<int> x,y;\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(r==0&&n==0)break;\n    for(int i=0;i<100;i++)t[i]=0;\n    for(int i=0;i<n;i++){\n      int lx,rx,h;\n      cin>>lx>>rx>>h;\n      lx+=30,rx+=30;\n      for(int j=lx;j<rx;j++)t[j]=max(t[j],h);\n    }\n    x.clear(),y.clear();\n    for(int i=0;i<30;i++){\n      x.push_back(30-i-1);\n      y.push_back(t[i]);\n    }\n    for(int i=30;i<60;i++){\n      x.push_back(i-30);\n      y.push_back(t[i]);\n    }\n    double ans=10000000;\n    for(int i=0;i<(int)x.size();i++){\nif(r-0.00000001<x[i])continue;\n      double d=y[i]+r-sqrt(r*r-x[i]*x[i]);\n      ans=min(d,ans);\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int r,n;\n  while(1){\n    cin>>r>>n;\n    if(r==0)break;\n    int height[50]={};\n    int p=25;\n    rep(i,n){\n      int x,y,h;\n      cin>>x>>y>>h;\n      for(j=x+p;j<y+p;j++)height[j]=max(height[j],h);\n    }\n\n    double ok=0.0;\n    double ng=21.0;\n    rep(i,100){\n      double t=(ok+ng)/2;//太陽の中心は(p,t-r)\n      bool c=true;\n      for(j=0;j<50;j++){//x座標がjのとき\n\tint h=min(height[j-1],height[j]);\n\tif(fabs(p-j)>=r)continue;\n\tdouble a=t-r+sqrt(r*r-(p-j)*(p-j));\n\t//\tcout<<j<<\" \"<<a<<endl;\n\tif(a >= h)c=false;\n      }\n      if(c)ok=t;\n      else ng=t;\n      // cout<<shosu(6)<<ok<<\" \"<<ng<<endl;\n    }\n    cout<<shosu(6)<<ok<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(double r,int n){\n  double hl[100]={};\n  double hr[100]={};\n  double h[100]={};\n  double b = 20;\n  double ans = 30.0;\n  rep(i,n){\n    int x,y;\n    double z;\n    cin>>x>>y>>z;\n    x+=b; y+=b;\n    FOR(j,x+1,y){\n      hl[j]=z;\n      hr[j]=z;\n    }\n    hr[x]=z;\n    hl[y]=z;\n  }\n  FOR(i,b-r,b+r+1){\n    h[i] = min(hl[i],hr[i]);\n    if(i==b-r&&hr[i]>hl[i]) h[i] = hr[i];\n    if(i==b+r&&hr[i]<hl[i]) h[i] = hl[i];\n  }\n\n  double i =b-r;\n\n  while(i<b+r+1){\n    double x = r+h[(int)i]-sqrt(r*r-(i-b)*(i-b));\n    ans = min(ans,x);\n\n    i +=1.0;\n  }\n\n  printf(\"%lf\\n\",ans);\n}\n\n\n\nint main(){\n  double r,n;\n  while(1){\n    cin>>r>>n;\n    if(r==0) break;\n    f(r,n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, r;\n\twhile (cin >>r>>n, r) {\n\t\tmap<int, int> v;\n\t\tint cmin = INF, cmax = -INF;\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcmin = min(cmin, a);\n\t\t\tcmax = max(cmax, b);\n\t\t\tFOR(j, a, b)v[j] = max(v[j], c);\n\t\t}\n\t\tif (cmin == INF) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tdouble u = 20, l = 0;\n\t\t\twhile (u - l > EPS) {\n\t\t\t\tint flag = 1;\n\t\t\t\tdouble mid = (u + l) / 2;\n\t\t\t\tFOR(i, cmin, cmax) {\n\t\t\t\t\tint d = i;\n\t\t\t\t\tif (i < 0)d++;\n\t\t\t\t\tdouble c = sqrt(r*r - d*d);\n\t\t\t\t\tif (c + EPS + mid -r> v[i])flag = 0;\n\t\t\t\t}\n\t\t\t\tif (flag)l = mid;\n\t\t\t\telse u = mid;\n\t\t\t}\n\t\t\tcout << fixed << setprecision(12) << l << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint main(){\n\n  int r,n,x1,x2,h,i,j;\n  \n  while(cin>>r>>n,r){\n  int build[41][2]={0};\n  for(i=0;i<n;i++){\n    cin>>x1>>x2>>h;\n    x1+=20; x2+=20;\n    for(j=x1+1;j<=x2-1;j++) for(int k=0;k<2;k++) build[j][k]=max(build[j][k],h);\n    build[x1][0]=max(build[x1][0],h);\n    build[x2][1]=max(build[x2][1],h);\n  }\n  int bu[41]={0};\n  for(i=0;i<41;i++) bu[i]=min(build[i][0],build[i][1]);\n  double c[41],result=100;\n  for(i=-r+1;i<=r-1;i++) c[i+20]=sqrt(r*r-i*i)-r;\n  for(i=20-r+1;i<=20+r-1;i++){\n    //cout<<bu[i]-c[i]<<\" \";\n    //cout<<endl;\n    result=min(result,bu[i]-c[i]);\n  }\n  cout<<result<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\ndouble calc(int r, int x, int y) {\n\tif (r <= abs(x)) return DBL_MAX;\n\treturn y - sqrt((double)r * r - x * x);\n}\n\nint main() {\n\tfor (;;) {\n\t\tint r, n; cin >> r >> n;\n\t\tif (r == 0) break;\n\t\tvector<int> y(40);\n\t\twhile (n--) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\tfor (int x = xl; x < xr; x++)\n\t\t\t\ty[20 + x] = max(y[20 + x], h);\n\t\t}\n\t\tdouble mini = DBL_MAX;\n\t\tfor (int x = -20; x < 20; x++) {\n\t\t\tmini = min(mini, calc(r, x, y[20 + x]));\n\t\t\tmini = min(mini, calc(r, x + 1, y[20 + x]));\n\t\t}\n\t\tprintf(\"%.10f\\n\", mini + r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nint main() {\n    std::cout<< std::setprecision(11) << std::fixed;\n    int r, n;\n    while(cin >> r >> n, r != 0 && n != 0) {\n        vi xl(n), xr(n), h(n);\n        REP(i, n) cin >> xl[i] >> xr[i] >> h[i];\n\n        vector<int> px;\n        px.push_back(-100);\n        px.push_back(-r);\n        px.push_back(0);\n        px.push_back(+r);\n        px.push_back(+100);\n        n = -1;\n        REP(i, xl.size()) {\n            px.push_back(xl[i]);\n            px.push_back(xr[i]);\n        }\n        sort(ALL(px));\n        px.erase(unique(ALL(px)), px.end());\n        vector<int> ph(px.size(), 0);\n        REP(k, px.size()) {\n            REP(i, xl.size()) {\n                int x = px[k];\n                if (xl[i] <= x && x < xr[i]) ph[k] = max(ph[k], h[i]);\n            }\n        }\n\n        // REP(i, ph.size()){  cout<< \"#\" << px[i] << \" - \" << ph[i] << endl; }\n\n        double al = 0;\n        double ar = 100;\n        while(ar - al > 0.00000001) {\n            double m = (al + ar) / 2;\n            bool ok = true;\n            REP(i, px.size() - 1) {\n                double nl = px[i], nr = px[i + 1];\n                double nh =  ph[i] - m + r;\n                nh = max(0.0, nh);\n                // cout<< \"T=\" << m << \" Check:\" << nl << \",\" << nr << \" H:\" << nh << endl;\n                double rl = r * r - nl * nl;\n                double rr = r * r - nr * nr;\n                // cout<< \"=\" << rl << \",\" << rr << endl;\n \n                if (rl > nh * nh || rr > nh * nh) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) { al = m; /* cout<< \"OK\" << endl; */}\n            else { ar = m; /* cout<< \"NG\" << endl; */}\n        }\n        cout<< al << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-5\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tR -= eps;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<map>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define REPS(i, n) for(int i=1;i<=(int)n;i++)\n#define RREP(i, n) for(int i=n-1;i>=0;i--)\n#define RREPS(i, n) for(int i=n;i>0;i--)\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint r, n, m;\n\nint main(){\n\twhile(cin >> r >> n, r){\n\t\tvi hi(100, 0);\n\t\tREP(i, n){\n\t\t\tint l, r, h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tfor(int j=(l+20)*2+1;j<=(r+20)*2;j++) hi[j] = max(hi[j], h);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tREP(i, 100){\n\t\t\tint x = abs((i/2)-20);\n\t\t\tif(x < r) ans = min(ans, r - (sqrt(r*r-x*x) - hi[i]));\n\t\t}\n\t\tprintf(\"%.11f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <complex>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(4);\n    int r, n;\n    while(cin >> r >> n, r or n)\n    {\n        int hight[50] = {};\n        for(int k = 0; k < n; k++)\n        {\n            int x1, x2, h; cin >> x1 >> x2 >> h;\n            x1 += 20, x2 += 20;\n            for(int i = x1; i < x2; i++) hight[i] = max(hight[i], h);\n        }\n        double ans = 1e5;\n        for(int i = -r + 1; i < r; i++)\n        {\n            int y = min(hight[i + 19], hight[i + 20]);\n            double t = y + r - sqrt(r * r - i * i);\n            ans = min(ans, t);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tll r,n;\n\tll line =0;\n\t//std::ofstream writing_file;\n  \t//writing_file.open(\"vamp_cin.txt\", std::ios::out);\n\twhile(cin>>r>>n){\n\t//\tline++;\n\t\tif(r==0)break;\n\t\tint xl[41],xr[41],h[41];\n\t\tint hh[41][41];\n\t\tmemset(hh,0,sizeof(hh));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>xl[i+20]>>xr[i+20]>>h[i+20];\n\t\t\tfor(int j=xl[i+20];j<xr[i+20];j++){\n\t\t\t\thh[j+20][j+21]=max(h[i+20],hh[j+20][j+21]);\n\t\t\t}\n\t\t}\n\t\tint minh = 1e5;\n\t\tint minx = 0;\n\t\tdouble ans=1e5;\n\t\tdouble res=1e5;\n\t\tfor(int i=20-r;i<20+r;i++){\n\t\t\t//minh = min(h[i+20]);\n/*\t\t\tif(minh >= hh[i][i+1]){\n\t\t\t\tif(minh == hh[i][i+1]){\n\t\t\t\t\tif(abs(20-i)<abs(minx-20)){\n\t\t\t\t\t\tminx = i;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tminx = i;\n\t\t\t\t}\n\t\t\t\tminh = hh[i][i+1];\n\t\t\t}*/\n\t\t//\tcout<<\"i i+1:\"<<i<<\" \"<<i+1<<\"hh:\"<<hh[i][i+1]<<endl;\n\t\t\tif(i<20)res = min(res,hh[i][i+1] + r - sqrt(r*r - abs(i-19)*abs(i-19)));\n\t\t\telse res = min(res,hh[i][i+1] + r - sqrt(r*r - abs(i-20)*abs(i-20)));\n\t\t//\tcout<<\"res:\"<<res<<endl;\n\t\t\tans = min(ans,res);\n\t\t}\n\t\tfor(int i=20-r;i<20+r;i++){\n\t\t//\tcout<<\"i i+1:\"<<i<<\" \"<<i+1<<\"hh:\"<<hh[i][i+1]<<endl;\n\t\t}\n//\t\tminh = min(hh[minx-1],min(hh[minx+1],minh));\n\t\t/*if(minh>hh[minx-1][minx]&&minh<hh[minx+1][minx+2]){\n\t\t\t//minh = hh[minx-1][minx];\n\t\t\tminx-=1;\n\t\t}else if(minh > hh[minx+1][minx+2]&&minh<hh[minx-1][minx]){\n\t\t\t//minh=hh[minx+1][minx+2];\n\t\t\tminx+=1;\n\t\t}*/\n\n\t\tif(minx<20)minx+=1;\n\t\t//if(minx>20)minx-=1;\n\t\t//cout<<\"minx\"<<minx<<\" minh:\"<<minh<<endl;\n\t\tcout<<fixed;\n\t\tcout<<setprecision(4)<<ans<<endl;\n\t\t/*writing_file<<\"line:\"<<line<<endl;\n\t\twriting_file<<n<<\" \"<<r<<endl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\twriting_file<<xl[i+20]<<\" \"<<xr[i+20]<<\" \"<<h[i+20]<<endl;\n\t\t}+*/\n\t//\twriting_file<<fixed;\n\t//\twriting_file<<setprecision(4)<<res<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex< double > Point;\ntypedef vector< Point > Polygon;\nnamespace std{\n\tbool operator < ( Point a, Point b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n};\nconst double INF = 1e12;\nconst double EPS = 1e-8;\nPoint NextPoint(){\n\tPoint P;\n\tcin>>P.real()>>P.imag();\n\treturn P;\n}\nstruct Line : Polygon{\n\tLine(){};\n\tLine(Point p, Point q){push_back(p);push_back(q);}\n};\n\nstruct Circle{\n\tPoint p;\n\tdouble r;\n\tCircle();\n\tCircle(Point a, double s){p = a,r = s;}\n};\ndouble cross(Point p, Point q){\n\treturn imag(conj(p)*q);\n}\ndouble dot(Point p,Point q){\n\treturn real(conj(p)*q);\n}\nint ccw(Point a,Point b,Point c){\n\tb -= a,c -= a;\n\tif(cross(b,c) > 0)return 1;\n\tif(cross(b,c) < 0)return -1;\n\tif(dot(b,c) < 0 )return 2;\n\tif(norm(b) < norm(c))return -2;\n\treturn 0;\n}\nPoint projection(Line l,Point p){\n\tdouble t = dot(p - l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\nbool intersectSP(Line s,Point p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble distanceSP(Line s,Point p){\n\tconst Point r = projection(s,p);\n\tif(intersectSP(s,r))return abs(r-p);\n\treturn min(abs(s[0] - p),abs(s[1] - p));\n}\nint main(){\n\tint r,n;\n\twhile(cin>>r>>n,r){\n\t\tint sc[50] = {};\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint l,r,h;\n\t\t\tcin>>l>>r>>h;\n\t\t\tl+=20,r+=20;\n\t\t\tfor(int j = l;j < r;j++){\n\t\t\t\tsc[j] = max(sc[j],h);\n\t\t\t}\n\t\t}\n\t\tPolygon G;\n\t\tG.push_back(Point(-100,0));\n\t\tG.push_back(Point(0,0));\n\t\tfor(int i = 0;i < 45;i++){\n\t\t\t\n\t\t\tif(i != 0){\n\t\t\t\tif(sc[i] != sc[i-1])\n\t\t\t\t\tG.push_back(Point(i,sc[i]));\n\t\t\t\t\n\t\t\t\tG.push_back(Point(i+1,sc[i]));\n\t\t\t}\n\t\t}\n\t\tG.push_back(Point(100,0));\n\n\t\tfor(int i = 0;i < G.size();i++){\n\t\t\t//cout<<G[i].real()<<\" \"<<G[i].imag()<<endl;\n\t\t}\n\n\t\tdouble low = -100,high = 100;\n\t\tint D = 100;\n\t\t//cout<<sc[20]<<endl;\n\t\twhile(D--){\n\t\t\tdouble mid = (low+high)/2;\n\t\t\tCircle C = Circle(Point(20,mid),r);\n\t\t\tdouble mi = INF;\n\t\t\tfor(int i = 0;i < G.size()-1;i++){\n\t\t\t\tdouble dist = distanceSP(Line(G[i],G[i+1]),C.p);\n\t\t\t\tmi = min(mi,dist);\n\t\t\t}\n\t\t\t//cout<<mid<<\" \"<<mi<<\" \"<<mid+r<<endl;\n\t\t\tif(mi < r)high = mid;\n\t\t\telse if(sc[20] < mid+r)high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\tprintf(\"%.5lf\\n\",low+r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#undef max\n#undef min\n\nbool field[41][22] = {false};\nbool field2[20][22] = { false };\nconstexpr int SUN_OFFSET_X = 20;\nint main() {\n\tint r, n;\n\twhile (std::cin >> r >> n && (r || n)) {\n\t\tstd::memset(field, false, sizeof(bool) * 41 * 22);\n\t\tstd::memset(field2, false, sizeof(bool) * 20 * 22);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x[2], h;\n\t\t\tstd::cin >> x[0] >> x[1] >> h;\n\t\t\tx[0] += SUN_OFFSET_X; x[1] += SUN_OFFSET_X;\n\t\t\t//?????§???????????¶???\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tfor (int k = x[0]; k < x[1]; k++) {\n\t\t\t\t\tfield[k][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstd::vector<double> circleHeights;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t//?°??????????????????????x?????????????????£????????????????????????????????¨??????????????????\n\t\t\tfor (int j = 0; j < 21; j++) {\n\t\t\t\tfield2[19 - i][j] = field[i][j] && field[39 - i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\t//?????????????????????x??§???y=0?????????????¢????\n\t\t\t//h^2 + i^2 = r^2 \n\t\t\t//h^2 = r^2 - i^2\n\t\t\tcircleHeights.push_back(-r + std::sqrt(r  * r - i * i));\n\t\t}\n\n\t\tstd::vector<int> heights;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tint h = 0;\n\t\t\tfor (h = 0; h < 21; h++) {\n\t\t\t\tif (!field2[i][h]) break;\n\t\t\t}\n\t\t\theights.push_back(h);\n\t\t}\n\n\t\t//??¢???\n\t\tdouble y = -0.001;\n\t\tbool isOk = false;\n\t\tdouble cy = 0;\n\t\tfor (int i = 0; i < 21 && !isOk; i++) {\n\t\t\tdouble dy = 0;\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\tdouble tmp = heights[j] - circleHeights[i] - y;\n\t\t\t\tif (tmp > 0) dy = std::min(dy == 0 ? 99999 : dy, tmp);\n\t\t\t}\n\t\t\tif (!dy) dy = 1;\n\n\t\t\ty += dy;\n\t\t\t//?????£???????????°????????¢???\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\t//??????x??§??¢?????????????????????\n\t\t\t\tif (std::abs(heights[j] - (circleHeights[j] + y)) < 0.001) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << std::fixed << std::setprecision(5) << y << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint n;\ndouble r;\nint t[100];\nvector<int> x,y;\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(r==0&&n==0)break;\n    for(int i=0;i<100;i++)t[i]=0;\n    for(int i=0;i<n;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a+=50,b+=50;\n      for(int j=a;j<b;j++)t[j]=max(t[j],c);\n    }\n    x.clear(),y.clear();\n    for(int i=0;i<50;i++){\n      x.push_back(50-i-1);\n      y.push_back(t[i]);\n    }\n    for(int i=50;i<100;i++){\n      x.push_back(i-50);\n      y.push_back(t[i]);\n    }\n    double ans=(1<<28);\n    for(int i=0;i<(int)x.size();i++){\n      if(r-0.00000001<x[i])continue;\n      double d=y[i]-sqrt(r*r-x[i]*x[i]);\n      ans=min(d,ans);\n    }\n    printf(\"%.8f\\n\",ans+r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(double r,int n){\n  double hl[100]={};\n  double hr[100]={};\n  double h[100]={};\n  double b = 20;\n  double ans = 30.0;\n  rep(i,n){\n    int x,y;\n    double z;\n    cin>>x>>y>>z;\n    x+=b; y+=b;\n    FOR(j,x+1,y){\n      hl[j]=max(hl[j],z);\n      hr[j]=max(hr[j],z);\n    }\n    hr[x]=max(hr[x],z);\n    hl[y]=max(hl[y],z);\n  }\n  rep(i,100){\n    h[i] = min(hl[i],hr[i]);\n    if(i==b-r&&hr[i]>hl[i]) h[i] = hr[i];\n    if(i==b+r&&hr[i]<hl[i]) h[i] = hl[i];\n  }\n\n  double i =b-r;\n\n  while(i<b+r+1){\n    double x = r+h[(int)i]-sqrt(r*r-(i-b)*(i-b));\n    ans = min(ans,x);\n    i +=1.0;\n  }\n\n  printf(\"%lf\\n\",ans);\n}\n\n\n\nint main(){\n  double r,n;\n  while(1){\n    cin>>r>>n;\n    if(r==0) break;\n    f(r,n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int r, n;\n        cin >> r >> n;\n        if(r == 0)\n            return 0;\n\n        vector<int> height(50, 0);\n        for(int i=0; i<n; ++i){\n            int x1, x2, h;\n            cin >> x1 >> x2 >> h;\n            for(int j=x1; j<x2; ++j)\n                height[j+25] = max(height[j+25], h);\n        }\n\n        double ret = DBL_MAX;\n        for(int x=-r+1; x<r; ++x){\n            int y = min(height[x+24], height[x+25]);\n            ret = min(ret, y - sqrt((double)r * r - x * x) + r);\n        }\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint main() {\n\tdouble r; int n;\n\twhile (cin >> r >> n, r) {\n\t\tdouble high[40] = {};\n\t\tint x, y; double h;\n\t\trep(i, n) {\n\t\t\tcin >> x >> y >> h;\n\t\t\tRep1(j, x + 20, y + 19) {\n\t\t\t\thigh[j] = max(high[j], h);\n\t\t\t}\n\t\t}\n\t\tdouble out=100;\n\t\trep(i, 40) {\n\t\t\tif (i < 20) {\n\t\t\t\tdouble d = 19 - i;\n\t\t\t\tif (r*r - d * d > 0) {\n\t\t\t\t\tout = min(out, high[i] - sqrt(r*r - d * d));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble d = i - 20;\n\t\t\t\tif (r*r - d * d > 0) {\n\t\t\t\t\tout = min(out, high[i] - sqrt(r*r - d * d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(4) << r+out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=20003,INF=1<<30;\nconst double eps=1e-12;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int R,N;cin>>R>>N;\n        if(R==0&&N==0) break;\n        \n        vector<int> maxi(60,0.0);\n        \n        for(int i=0;i<N;i++){\n            int l,r,h;cin>>l>>r>>h;\n            for(int i=l;i+1<=min(r,0);i++){\n                maxi[30+i+1]=max(h,maxi[30+i+1]);\n            }\n            for(int i=max(0,l);i<r;i++){\n                maxi[31+i]=max(h,maxi[31+i]);\n            }\n        }\n        \n        double left=0.0,right=100.0;\n        \n        for(int q=0;q<100;q++){\n            double mid=(left+right)/2.0;\n            \n            bool ok=true;\n            \n            for(int i=-R;i+1<=0;i++){\n                double h=mid-double(R);\n                h+=sqrt(double(R*R-(i+1)*(i+1)));\n                if(h>maxi[30+i+1]+eps) ok=false;\n            }\n            \n            for(int i=0;i<R;i++){\n                double h=mid-double(R);\n                h+=sqrt(double(R*R-i*i));\n                if(h>maxi[31+i]+eps) ok=false;\n            }\n            \n            if(ok) left=mid;\n            else right=mid;\n        }\n        \n        cout<<fixed<<setprecision(25)<<left<<endl;\n        \n        /*for(int i=25;i<=35;i++) cout<<maxi[i]<<\" \";\n        cout<<endl;*/\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\ntypedef long double ld;\ntypedef vector<ld> vd;\n\nconst ld EPS = 10e-10;\n\nld solve();\nbool search(const ld t, const ld r, vd& s);\n\nint main(void) {\n\t\n\twhile(true){\n\t\tld ans = solve();\n\t\tif( ans < 0.0 ) { break; }\n\t\tcout << fixed << setprecision(5) << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n\nbool search( const ld t, const ld r, vd& s ) {\n\n\tfor( int i = -20; i < 20; i++ ) {\n\n\t\tld d[2]={(ld)i,(ld)i+1.0};\n\n\t\tfor(int j = 0; j < 2; j++)\n\t\t\tif(d[j]>=-r+EPS&&d[j]+EPS<=r)\n\t\t\t\tif(sqrt(r*r-d[j]*d[j])+t>r+s[i+20]+EPS) \n\t\t\t\t\treturn false;\n\t\n\t}\n\n\treturn true;\n}\n\nld solve() {\n\n\t//????????¢?´¢\n\tld r, low=0.0, high=21.0, mid;\n\tint n, m;\n\tvd v(40,0.0);\n\t\n\tcin >> m >> n;\n\tr = (ld)m;\n\t\n\tif( m == 0 && n == 0 ) { return -1.0; }\n\n\tfor( int i = 0; i < n; i++ ) {\n\n\t\tint xl, xr;\n\t\tld h;\n\t\tcin >> xl >> xr >> h;\n\n\t\tfor( int j = xl+20; j < xr+20; j++ )\n\t\t\tif( v[j] < h ) \n\t\t\t\tv[j] = h;\n\t}\n\t\n\n\t//low???????????????????????????\n\tfor( int i = 0; i < 1000; i++ ) {\n\t\tmid = (high+low)/2.0;\n\t\tif( search(mid,r,v) )\n\t\t\tlow = mid;\n\t\telse \n\t\t\thigh = mid;\n\t}\n\n\treturn mid;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\n\nconst int OFFSET=50;\nconst ld INF=1e4;\n\nld solve(int r,int n,vector<int> &rh){\n  ld t=INF;\n  for(int i=1;i<OFFSET*2;++i){\n    int x=i-OFFSET;\n    if(x<=-r || r<=x) continue;\n    int h=min(rh[i-1],rh[i]);\n    ld y=sqrt(r*r-x*x);\n\n\n    t=min(h-y,t);\n  }\n  return t+r;\n}\n\t \nint main(){\n  int r,n;\n  cout<<setprecision(10)<<fixed;\n  while(cin>>r>>n,r){\n    vector<int> xl(n);\n    vector<int> xr(n);\n    vector<int> h(n);\n    for(int i=0;i<n;i++){\n      cin>>xl[i]>>xr[i]>>h[i];\n    }\n    vector<vector<int>> f(30,vector<int>(OFFSET*2,0));\n    for(int i=0;i<n;i++){\n      for(int j=xl[i];j<xr[i];j++){\n\tfor(int k=0;k<h[i];k++){\n\t  f[k][j+OFFSET]=true;\n\t}\n      }\n    }\n\n    vector<int> rh(OFFSET*2,0);\n    for(int i=0;i<OFFSET*2;i++){\n      for(int j=29;j>=0;j--){\n\tif(f[j][i]){\n\t  rh[i]=j+1;\n\t  break;\n\t}\n      }\n    }\n    cout<<solve(r,n,rh)<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define EPS 1e-10\n \nusing namespace std;\ntypedef long long int ll;\n \ndouble add(double a, double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\n \nstruct P{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y): x(x), y(y){\n\t}\n\tP operator+ (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator- (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator* (double d){\n\t\treturn P(x*d, y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n \nbool on_seg(P p1, P p2, P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n \nP intersection(P p1, P p2, P q1, P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1) / (q2-q1).det(p2-p1));\n}\n\ndouble dist(P p1, P p2, P q){\n\tdouble d1=sqrt((p1-q).dot(p1-q)), d2=sqrt((p2-q).dot(p2-q));\n\tif(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS){\n\t\treturn d1;\n\t}\n\tP r=P((p2-p1).y, (p1-p2).x);\n\tP s=intersection(p1, p2, q, q+r);\n\tif(on_seg(p1, p2, s)){\n\t\treturn sqrt((q-s).dot(q-s));\n\t}else{\n\t\treturn min(d1, d2);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n\t\tint n, r0;\n\t\tscanf(\"%d %d\", &r0, &n);\n\t\tif(r0==0 && n==0) return 0;\n\t\tdouble r=(double)r0;\n\t\tif(n==0){\n\t\t\tprintf(\"%d\\n\", 0);\n\t\t\tcontinue;\n\t\t}\n\t\tdouble h[41]={};\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint xl, xr;\n\t\t\tdouble h0;\n\t\t\tscanf(\"%d %d %lf\", &xl, &xr, &h0);\n\t\t\txl+=20, xr+=20;\n\t\t\tfor(int j=xl; j<xr; j++){\n\t\t\t\th[j]=max(h[j], h0);\n\t\t\t}\n\t\t}\n\t\tdouble d1=0, d2=h[20];\n\t\tfor(int t=0; t<100; t++){\n\t\t\tdouble d=(d1+d2)/2;\n\t\t\tP p=P(20.0, d-r);\n\t\t\tdouble D=100.0;\n\t\t\tfor(int i=0; i<40; i++){\n\t\t\t\tP q1=P((double)i, h[i]), q2=P((double)(i+1), h[i]);\n\t\t\t\tD=min(D, dist(q1, q2, p));\n\t\t\t}\n\t\t\tfor(int i=0; i<=40; i++){\n\t\t\t\tP q1, q2;\n\t\t\t\tif(i==0){\n\t\t\t\t\tq1=P((double)i, 0), q2=P((double)i, h[0]);\n\t\t\t\t}else if(i==40){\n\t\t\t\t\tq1=P((double)i, h[39]), q2=P((double)i, 0);\n\t\t\t\t}else{\n\t\t\t\t\tq1=P((double)i, h[i-1]), q2=P((double)i, h[i]);\n\t\t\t\t}\n\t\t\t\tD=min(D, dist(q1, q2, p));\n\t\t\t}\n\t\t\tif(D>r-EPS){\n\t\t\t\td1=d;\n\t\t\t}else{\n\t\t\t\td2=d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6lf\\n\", d1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9 + 7;\n\nbool solve(){\n    int r, n;\n    cin >> r >> n;\n    if(!r)\n        return false;\n\n    // center: 50\n    vector<int> v(100, 0);\n    for(int i = 0; i < n; ++i){\n        int l, r, y;\n        cin >> l >> r >> y;\n        l += 50, r += 50;\n        for(int j = l; j < r; ++j)\n            v[j] = max(v[j], y);\n    }\n\n    auto f = [&](double h){\n        for(int i = 0; i < 100; ++i){\n            double x = min(abs(i - 50 + 1e-8), abs(i - 50 + 1 - 1e-8));\n            // r^2 = x^2 + y^2\n            // sqrt(r^2 - x^2)\n            if(r - x < 0)\n                continue;\n            if(sqrt(r * r - x * x) + h - r > v[i])\n                return false;\n        }\n        return true;\n    };\n\n    double ok = 0, ng = 10000;\n    for(int i = 0; i < 64; ++i){\n        double mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    printf(\"%.20lf\\n\", ok);\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tdouble r;\n\tint n;\n\twhile(cin>>r>>n, r!=0){\n\t\tvector<double> x(50,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint L,R;\n\t\t\tdouble h;\tcin>>L>>R>>h;\n\t\t\tL+=20;\tR+=20;\n\t\t\tfor(int j=L; j<R;j++)x[j]=max(x[j],h);\n\t\t}\n\n\t\t/*\n\t\t   (memo)\n\t\t   x^2 + (y-r+t)^2<=r^2\n\t\t */\n\n\n\t\tdouble t=0;\n\t\twhile(1){\n\t\t\tfor(int L=0;L<40;L++){\n\t\t\t\tdouble X=(double)L-20.0, Y=(double)x[L];\n\t\t\t\tif(X<0){\n\t\t\t\t\t// 右の高さを採用\n\t\t\t\t\tX+=1.0;\n\t\t\t\t}\n\t\t\t\t//cout<<X<<endl;\n\t\t\t\tdouble d=(X*X) + ((Y-(t-r))*(Y-(t-r)));\n\t\t\t\t//cout<<d<<endl;\n\t\t\t\tif(d<(r*r)){\n\t\t\t\t\tprintf(\"%.4lf\\n\",t);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tt+=0.0001;\n\t\t}\n\t\tEND:\n\t\t\tcontinue;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n */\nusing namespace std;\n//type\ntypedef long long ll;\n#define pii pair<int, int>\n#define vi vector<int>\n#define vl vector<ll>\n//x * y * 1.0 can cause overflow\n//constant\n#define inf (int)(1e9+7)\n#define mod (ll)(1e9+7)\n#define eps 1e-10\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\nint dx[] = {1, -1, 0, 0, -1, 1, 1, -1};\n//omission\n#define eb emplace_back\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define all(v) v.begin(), v.end()\n//manip\ntemplate<class T> bool chmax(T &a, T b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<class T> bool chmin(T &a, T b) {if (a > b) {a = b; return 1;} return 0;}\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end(), v.end())\n#define fill(x, y) memset(x, y, sizeof(x))\n#define ceil(a, b) a / b + !!(a % b)\ntemplate<class T> T power(T a, T b)\n{return b ? power(a * a % inf, b / 2) * (b % 2 ? a : 1) % inf : 1;}\n#define LB(v, x) (int)(lower_bound(v.begin(), v.end(), x) - v.begin())\n#define UB(v, x) (int)(upper_bound(v.begin(), v.end(), x) - v.begin())\n//output\n#define out(a) cout << a << endl\n#define outa(a, n) rep(i, n) cout << a[i] << \" \"; cout << endl\n#define outv(v) rep(i, SZ(v)) cout << v[i] << \" \"; cout << endl;\n#define outp(v) rep(i, SZ(v)) cout << v[i].F << \" \" << v[i].S << endl\n#define outc(s, t) cout << fixed << setprecision(10) << (double)(t - s) / CLOCKS_PER_SEC << endl\n//loop\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define rep3(i, st, n) for (int i = st; i < n; ++i)\n#define rrep(i, n) for (int i = n - 1; i >= 0; --i)\n//algorithm (have library)\n//double pointer, l start, how many adds, can be 0 -> init r = l, sum = 0, while r < n\n\n\n\n\nbool comp(pair<int, pii> a, pair<int, pii> b) {\n    if (a.S.F != b.S.F) return a.S.F > b.S.F;\n    return a.S.S > b.S.S;\n}\n\nint main() {\n    //cast caution\n    //look constraints always\n    cin.tie(0); ios::sync_with_stdio(false);\n    \n    \n    \n    \n    \n    \n    int r, n;\n    while (cin >> r >> n && r) {\n        int xl[n], xr[n], h[n];\n       \n        rep(i, n) {\n            cin >> xl[i] >> xr[i] >> h[i];\n            \n        }\n        \n        double ans = inf;\n        rep3(left, -20, 20) {\n            if (left + 1 <= -r || left >= r) continue;\n            int flg = 0;\n            double ans_tmp = 0;\n            rep(i, n) {\n                \n                if (xl[i] <= left && left + 1 <= xr[i]) {\n                    flg = 1;\n                    double tmp = h[i];\n                    \n                    int x = min(abs(left), abs(left + 1));\n                    //cout << tmp << \" \" << (-r + sqrt(r * r - x * x)) << endl;\n                    tmp = tmp - (-r + sqrt(r * r - x * x));\n                    //cout << i << \" \" << x << \" \" << left << \" \" << tmp << endl;\n                    chmax(ans_tmp, tmp);\n                }\n            }\n            if (flg) {\n                chmin(ans, ans_tmp);\n            } else {\n                double tmp = 0;\n                int x = min(abs(left), abs(left + 1));\n                tmp = tmp - (-r + sqrt(r * r - x * x));\n                chmin(ans, tmp);\n            }\n            \n        }\n        cout << ans << endl;\n        \n        \n    }\n    \n   \n    \n    \n    \n}\n//cast caution\n\n/*\n \n 一番手前のとこ見つけたらいいんじゃね？\n \n いや、難しい\n 配列作ったらsample1\n -1のとこ3やし0のとこも3\n \n \n \n \n \n ビルごとに見るか\n \n 円の位置二分探索する\n 各ビルに対し、左端、右端のちょい左、右を見て円が範囲内か\n \n いや、他のビルも含めて範囲内か見るのむずい\n \n その座標を保存して全探索するか\n いや、角度むず\n \n \n \n \n \n すべてのx範囲1の区間見るか\n \n ダメだったら配列でindex2倍にしたら\n -1 -> -2, 0 -> 0, 1 -> 2\n になる\n \n sample1\n -3  -2  -1   0   1   2   3\n  0 0 3 3 3 0 3 3 3 0 3 3 3 0\n \n あれ、わからんわ\n \n \n */\n \n \n \n \n \n \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nint r,n,L,R,h,i,x;\n\nint main(){\n\t\n\twhile(cin>>r>>n,r){\n\n\t\t\n\t\tmap<int,int> A,B;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>L>>R>>h;\n\t\t\tfor(x=L;x<=R;x++){\n\t\t\t\tif(x!=R)A[x]=max(A[x],h);\n\t\t\t\tif(x!=L)B[x]=max(B[x],h);\n\t\t\t}\t\n\t\t}\n\t\tdouble res=99;\n\t\tfor(i=-r;i<=r-1;i++){\n\t\t\tres=min(res,min(r-sqrt(r*r-i*i)+A[i],r-sqrt(r*r-(i+1)*(i+1))+B[i+1]));\n\t\t}\n\t\tcout<<res<<\"\\n\";\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <iomanip>\nusing namespace std;\nint n,r;\n\nmap<int, double> keep_y;  \nbool check2(double x,double y, double xl, double xr, double hei){\n  return xl <= x && x <= xr && y <= hei;\n}\nvoid addPoint(vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  keep_y = map<int, double>();\n  for(int i = 0;i < n;i++){\n\tfor(int j = xl[i];j < xr[i];j++){\n\t  keep_y[j] = max(keep_y[j], hei[i]);\n\t}\n  }\n}\ndouble dist(double x1,double y1,double x2,double y2){\n  return ((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}\nbool check(double h){//円内に, 候補点があり=> アウト日が出る\n  for(int i = -r;i <= r;i++){\n\tif(dist(i, keep_y[i], 0, h) < r*r || dist(i, keep_y[i-1], 0, h) < r*r){\n\t  return true;\n\t}\n  }\n  return false;\n}\n\ndouble bs(double h,vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  double f = -r;\n  double e = h;  \n  while(e - f >= 0.0001){\n\tdouble mid = (f + e) / 2.0;\n\tif(check(mid)){\n\t  e = mid;\n\t}else{\n\t  f = mid;\n\t}\n  }\n  return f;\n}\nint main(){\n  \n  while(cin >> r >> n){\n\tif(n == 0 && r == 0)break;\n\tvector<double> xl(n);\n\tvector<double> xr(n);\n\tvector<double> hei(n);\n\tfor(int i = 0;i < n;i++){\n\t  cin >> xl[i] >> xr[i] >> hei[i];\n\t}\n\taddPoint(xl,xr,hei);\n\tcout << fixed << setprecision(5) << bs(min(keep_y[0]-r, keep_y[-1]-r),xl,xr,hei) + r<< endl;\n\t \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint r, n, a, b, c, h[44];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> r >> n;\n\t\tif (r==0) break;\n\t\tzero(h);\n\t\trep(i,n) {\n\t\t\tcin >> a >> b >> c;\n\t\t\treps(j,a,b) chmax(h[j+20],c);\n\t\t}\n\t\tdouble res = 1e100;\n\t\treps(i,-r,r) {\n\t\t\tint x = min(abs(i),abs(i+1)), y = h[i+20];\n\t\t\tchmin(res, y+r-sqrt(r*r-x*x));\n\t\t}\n\t\tprintf(\"%.8lf\\n\",res);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//Vampire\n#include<bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint h1[40];//x[0]:-20?-19, x[39]:19?20\nint h2[41];//判定用\nconst double EPS=1E-5;\n\nbool a(double t){\n  complex<double> c;\n  c.real()=0.0, c.imag()=t-2.0;\n  for(int i=0; i<41; i++){\n    complex<double> d;\n    d.real()=i-20; d.imag()=h2[i];\n    //printf(\"(%f, %f)->%f\\n\", d.real(), d.imag(), abs(c-d));\n    if(abs(c-d)<r-EPS)return true;//含む\n  }\n  return false;//含まない\n}\n\ndouble solve(){\n  double ret=0;\n  while(true){\n    //cout<<\"ret=\"<<ret<<endl;\n    if(a(ret))break;\n    ret+=0.00001;\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    cin>>r>>n;\n    if(r==0 && n==0)break;\n    memset(h1, 0, sizeof(h1));\n    memset(h2, 0, sizeof(h2));\n    for(int i=0; i<n; i++){\n      int xl, xr, h;\n      cin>>xl>>xr>>h;\n      xl+=20; xr+=20;\n      for(int j=xl; j<xr; j++)\n        if(h1[j]<h)h1[j]=h;\n    }\n    for(int i=1; i<40; i++)\n      h2[i]=min(h1[i-1], h1[i]);\n    printf(\"%.8f\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n;\n    ld r;\n    while(cin>>r>>n,n){\n        vector<ld> xl(n);\n        vector<ld> xr(n);\n        vector<ld> h(n);\n        for(int i=0;i<n;i++) cin>>xl[i]>>xr[i]>>h[i];\n\n        vector<vector<int>> field(50,vector<int>(30,false));\n        for(int i=0;i<n;i++){\n            for(int j=xl[i];j<xr[i];j++){\n                for(int k=0;k<h[i];k++){\n                    field[j+20][k]=true;\n                }\n            }\n        }\n        ld res=1e9;\n        \n        function<ld(ld,ld)> height=[&](ld x,ld hei){\n            if(abs(x)>=r) return ld(1e9);\n            return hei-sqrt(double(r*r-x*x));\n        };\n        for(int i=0;i<50;i++){\n            int j=0;\n            for(;j<30;j++){\n                if(!field[i][j]) break;\n            }\n            ld hei=j;\n            ld l=i;\n            ld r=i+1;\n            res=min(res,ld(height(l-20,hei)));\n            res=min(res,ld(height(r-20,hei)));\n        }\n        cout<<fixed<<setprecision(10);\n        cout<<res+r<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nbool is[40][21];\ndouble eps=1e-9;\nint main(){\n\twhile(true){\n\t\tint r,n;\n\t\tcin>>r>>n;\n\t\tif(r==0) break;\n\t\trep(i,40) rep(j,21) is[i][j]=0;\n\t\trep(i,n){\n\t\t\tint a,b,h;\n\t\t\tcin>>a>>b>>h;\n\t\t\ta+=20,b+=20;\n\t\t\tfor(int x=a;x<b;x++) rep(y,h) is[x][y]=true;\n\t\t}\n\t\tvector<double> vc;\n\t\trep(x,r) rep(y,22){\n\t\t\tif(x*x>=r*r) continue;\n\t\t\tdouble t=y-sqrt(r*r-x*x);\n\t\t\tvc.pb(t);\n\t\t}\n\t\tsort(all(vc));\n\t\trep(i,vc.size()){\n\t\t\tdouble h=vc[i];\n\t\t\tbool can=true;\n\t\t\tfor(int x=-r;x<r;x++) rep(y,21){\n\t\t\t\tif(is[x+20][y]) continue;\n\t\t\t\tif(x*x+(y-h)*(y-h)<r*r+eps) can=false;\n\t\t\t\tif((x+1)*(x+1)+(y-h)*(y-h)<r*r+eps) can=false;\n\t\t\t}\n\t\t\tif(!can){\n\t\t\t\tprintf(\"%.4f\\n\",h+r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nint main(void)\n{\n    while(true) {\n        int r,n,y[40],b[41];\n        double res=500.0;\n        \n        memset(y, 0, sizeof(y));\n        memset(b, 0, sizeof(b));\n\n        scanf(\"%d%d\", &r, &n);\n        if(!r && !n) break;\n\n        for(int i=0; i < n; i++) {\n            int xs,xe,t;\n            scanf(\"%d%d%d\", &xs, &xe, &t);\n            for(int p=xs+20; p < xe + 20; p++)\n                y[p] = std::max(y[p], t);\n        }\n\n        b[0]  = 0;\n        b[40] = 0;\n\n        for(int i=1; i < 40; i++)\n            b[i] = std::min(y[i-1], y[i]);\n\n        for(int i=-r+1+20; i < r+20; i++) {\n            res = std::min( res, (double)(b[i]+r) - sqrt((double)r*r - abs(-20.0+i)*abs(-20.0+i)) );\n//            printf(\".%d:%lf:%lf.\",i,(double)(b[i]+r), sqrt((double)r*r - abs(-20.0+i)*abs(-20.0+i)));\n        }\n\n        printf(\"%lf\\n\", res);\n    }\n        \n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<int, int> pii;\ndouble GetPos(point x, double r){\n  if(abs(x.real()) > r)return 1e9;\n  double maxi = x.imag(), mini = -1000, med = (maxi + mini)/2;\n            \n  while(maxi - mini > 1e-9){\n    point p = point(0, med);\n    if(abs(x - p) < r){\n      maxi = med;\n    }else{\n      mini = med;      \n    }\n    med = (maxi + mini)/2;\n  }\n  return maxi;\n}\nint main(int argc, char *argv[]){\n  int r, n;\n  while(std::cin >> r >> n, n){\n    vector<point> corner;\n    double ans = 1e9;\n    vector<pii> begin, end;\n    for (int i = 0; i < n; i++) {\n      int b, e, h;\n      std::cin >> b >> e >> h;\n      corner.push_back(point(b, h));\n      corner.push_back(point(e, h));\n      begin.push_back(pii(b, -h));\n      end.push_back(pii(e, -h));\n    }\n    sort(begin.begin(), begin.end());\n    sort(end.begin(), end.end());\n    int bpos = 0, epos = 0;\n    if(begin[0].first > -r || end[n - 1].first < r)ans = 0;\n    int sum = 0;\n    for (int i = 0; i < 2*begin.size() - 2; i++) {\n      if(begin[bpos].first > end[epos].first)ans = -r;\n      int hight = min(-begin[bpos].second, -end[epos].second);\n      if(i%2){\n        if(end[epos].first == end[epos + 1].first)continue;\n        //std::cout << point(end[epos].first, hight) << std::endl;\n        corner.push_back(point(end[epos].first, hight));\n        epos++; \n      }else{\n        bpos++;\n        if(begin[bpos].first == begin[bpos - 1].first)continue;\n        //std::cout << point(begin[bpos].first, hight) << std::endl;\n        corner.push_back(point(begin[bpos].first, hight));\n      }\n    }\n    for (point i: corner){\n      //std::cout << corner[i] << std::endl;\n      ans = min(ans, GetPos(i, r));\n      //std::cout << ans << std::endl;\n    }\n    std::cout << setprecision(12) << ans + r << std::endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint r, n;\n\twhile (cin >> r >> n, r | n) {\n\t\tmap<int, int> left, right;\n\t\tFOR (x, -20, 20 + 1) {\n\t\t\tleft[x] = right[x] = 0;\n\t\t}\n\n\t\tREP (i, n) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\tFOR (x, xl, xr+1) {\n\t\t\t\tif (x != xl) {\n\t\t\t\t\tleft[x] = max(left[x], h);\n\t\t\t\t}\n\t\t\t\tif (x != xr) {\n\t\t\t\t\tright[x] = max(right[x], h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble low = -r, high = 40;\n\t\twhile (high - low > 0.0001) {\n\t\t\tdouble mid = (low + high) / 2.0;\n\t\t\tdump(mid);\n\t\t\tbool ok = true;\n\t\t\tFOR (x, -r, r + 1) {\n\t\t\t\t// x^2 + y^2 = r^2\n\t\t\t\tdouble y = mid + sqrt(static_cast<double>(pow(r, 2) - pow(x, 2)));\n\t\t\t\tdump(x);\n\t\t\t\tdump(y);\n\t\t\t\tdump(left[x]);\n\t\t\t\tdump(right[x]);\n\t\t\t\tif ((x == -r && y > right[x]) || (x != -r && x <= 0 && y > left[x])) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((x == r && y > left[x]) || (x != r && x >= 0 && y > right[x])) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.4f\\n\", low + r);\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint r, n, xl, xr, h;\n\nint main(void) {\n  while(cin >> r >> n, r) {\n    map<pii, bool> m;\n    int mh = 0;\n    REP(i, 0, n) {\n      cin >> xl >> xr >> h;\n      REP(j, 0, h) REP(k, xl, xr) m[pii(j, k)] = true;\n      mh = max(mh, h);\n    }\n\n    // REP(i, 0, mh) {\n    //   REP(j, -r, r) {\n    //     cout << (m[pii(i, j)] ? 1 : 0);\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n\n    double t = 1000;\n    REP(i, 0, mh + 1) {\n      REP(j, -r, r) {\n        if(!m[pii(i, j)]) {\n          int y = i;\n          int x = j < 0 ? -(j + 1) : j;\n          t = min(t, y - sqrt(r * r - x * x) + r);\n        }\n      }\n    }\n    printf(\"%.4f\\n\", max(0.0, t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS) return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nvoid vis2(P p){\n\tprintf(\"plot(%.5lf,%.5lf,0)\\n\",p.real(),p.imag());\n}\nint test(vector<G> &g,double t,double r){\n\tr -= 1e-4;\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(0);\n\tchkPoint.push_back(PI/2.);\n\tchkPoint.push_back(3*PI/2.);\n\tchkPoint.push_back(2*PI/2.);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tx = x - c.p;\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t\tchkPoint.push_back(th+1e-4);\n\t\t\t\tchkPoint.push_back(th-1e-4);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"cir(\" << c.p.real() << \",\" << c.p.imag() << \",\" << r << \")\" << endl;\n\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tif( contains(g[j],pp) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if(flag) vis2(pp);\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nvoid vis(G g){\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tcout << \"line(\" << curr(g,i).real() << \",\" << curr(g,i).imag() << \",\" << next(g,i).real() << \",\" << next(g,i).imag() << \")\" << endl;\n\t}\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\t//g.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl,0},{xr,0},{xr,h},{xl,h}});\n\t\t\t//vis(g[i]);\n\t\t}\n\t\t\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nint s[21][41];\nint main(void){\n    int r, n, xl, xr, h;\n    while(cin >> r >> n && r) {\n        rep(i, 41) rep(j, 41) s[i][j] = 0;\n        rep(i, n) {\n            cin >> xl >> xr >> h;\n            for(int y=0; y<h; ++y) {\n                for(int x=xl+20; x<xr+20; ++x) {\n                    s[y][x] = 1;\n                }\n            }\n        }\n        /*for(int y=20; y>=0; --y) {\n            rep(x, 41) cout << s[y][x];\n            cout << endl;\n        }*/\n        double mint = numeric_limits<double>::max();\n        rep(y, 21) {\n            for(int x=-r+20; x<r+20; ++x) {\n                if(s[y][x] == 0) {\n                    double t;\n                    if(x<20) t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n                    else t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n                    mint = min(mint, t);\n                }\n            }\n        }\n        cout << fixed << setprecision(4) << mint << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\ndouble mk_dis(int x1,int h,double cy){\n  return sqrt(x1*x1+(h-cy)*(h-cy));\n}\n\n\nbool check(double cy){\n  cy=(int)(cy*100000)/100000.0;\n  double x=fabs(sqrt(r*r-cy*cy));\n  if(cy>=0)x=r;\n  int L=(-x-0.999999),R=(x+0.999999),hb[101]={};\n  for(int i=L+50;i<R+50;i++)\n    if(i>=50){\n      if(mk_dis(i-50,y[i],cy)>=r)hb[i]++;\n    }\n    else {\n      if(mk_dis(i-49,y[i],cy)>=r)hb[i]++;\n    }\n  \n  for(int i=L+50;i<R+50;i++)if(!hb[i])return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    memset(y,0,sizeof(y));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans;\n    for(ans=0;ans<41&&check(ans-r);ans+=0.0001);\n    printf(\"%lf\\n\",ans-0.0001);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\ntypedef complex <double> P;\n\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\n\ndouble dot( P a, P b ) {\n    return real( conj( a ) * b );\n}\n\ndouble cross( P a, P b ) {\n    return imag( conj( a ) * b );\n}\n\nstruct C {\n\tP c;\n    double r;\n\tC ( const P & c, double r ) : c( c ), r( r ) {}\n};\n\nstruct L : public vector<P> {\n    L ( const P & a, const P & b ) {\n        push_back( a );\n        push_back( b );\n    }\n};\n\nP projection( L a, P p ) {\n\tdouble t = dot( p - a[0], a[0] - a[1] ) / norm( a[0] - a[1] );\n\treturn a[0] + t * ( a[0] - a[1] );\n}\n\nP reflection( L a, P p ) {\n\treturn p + 2.0 * ( projection( a, p ) - p );\n}\n\nL crosspointCL( C c, L l ) {\n\tP pr = projection( l, c.c );\n\tP e  = ( l[1] - l[0] ) / abs( l[1] - l[0] );\n\tdouble t = sqrt( c.r * c.r - norm( pr - c.c ) );\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif ( b < a ) swap( a, b );\n\treturn L( a, b );\n}\n\nstruct hoge {\n    int hidarimuki;\n    int migimuki;\n};\n\nint main() {\n    int r, n;\n    while ( cin >> r >> n, r ) {\n        vector <int> left(n), right(n), hight(n);\n        map <int, hoge> xToMaxHight;\n        rep ( i, n ) {\n            cin >> left[i] >> right[i] >> hight[i];\n            range ( j, left[i], right[i] + 1 ) {\n                if ( j == left[i] ) {\n                    hoge tmp = xToMaxHight[j];\n                    xToMaxHight[j] = { tmp.hidarimuki, max( tmp.migimuki, hight[i] ) };\n                }\n                else if ( j == right[i] ) {\n                    hoge tmp = xToMaxHight[j];\n                    xToMaxHight[j] = { max( hight[i], tmp.hidarimuki) , tmp.migimuki };\n                }\n                else {\n                    hoge tmp = xToMaxHight[j];\n                    xToMaxHight[j] = { max( hight[i], tmp.hidarimuki ) ,\n                                       max( hight[i], tmp.migimuki ) };\n                }\n            }\n        }\n\n        C circle( P( 0, -r ), r );\n        double ans = 1e9;\n        range ( i, -r, r + 1 ) {\n            P va;\n            if ( i == -r ) {\n                va = P( i, xToMaxHight[i].migimuki );\n            }\n            else if ( i == r ) {\n                va = P( i, xToMaxHight[i].hidarimuki );\n            }\n            else {\n                va = P( i, min( xToMaxHight[i].hidarimuki, xToMaxHight[i].migimuki ) );\n            }\n            L line( va , P( i, -1 ) );\n            L tmp = crosspointCL( circle, line );\n\n            ans = min( { ans, abs( va - tmp[0] ), abs( va - tmp[1] ) } );\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tint n;\n\tdouble r;\n\twhile(cin>>r>>n,r||n){\n\t\tdouble h[50]={0};\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta+=25;b+=25;\n\t\t\tfor(int i=a;i<b;i++)h[i]=max(h[i],c);\n\t\t}\n\t\t//loop(i,20,30)cout<<\" \"<<h[i];\n\t\t//cout<<endl;\n\t\tdouble t=0;\n\t\twhile(1){\n\t\t\tt+=0.0005;\n\t\t\tbool ans=true;\n\t\t\trep(i,49){\n\t\t\t\tif((double)(i-25)*(i-25)+(r+h[i]-t)*(r+h[i]-t)<r*r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((double)(i-25)*(i-25)+(r+h[i]-t)*(r+h[i]-t)<r*r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ans)break;\n\t\t}\n\t\tcout<<t-0.0005<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<complex>\n\n#define fin cin\n\nusing namespace std;\n\nint r, n;\nint building[41];\n\nvoid init() {\n\tfor (int i = 20 - r; i < 20 + r; i++) {\n\t\tbuilding[i] = 0;\n\t}\n}\n\ndouble toSec(int x, int y) {\n\treturn (double)(r + y) - sqrt(pow(r, 2) - pow(x, 2));\n}\n\nint main() {\n\t//ifstream fin(\"in.txt\");\n\n\twhile (true) {\n\t\tr = n = 0;\n\n\t\tfin >> r >> n;\n\t\tif (r == 0 && n == 0)break;\n\n\t\tinit();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint left, right, h;\n\t\t\tfin >> left >> right >> h;\n\n\t\t\tfor (int j = left + 20; j < right + 20; j++) {\n\n\t\t\t\tif (building[j] < h)building[j] = h;\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\n\t\tfor (int i = 20 - r; i < 20 + r; i++) {\n\t\t//\tcout << building[i] << \" \";\n\t\t}\n\n\t\tdouble min = 30.0;\n\t\tint x, y;\n\t\tfor (int i = 20 - r; i < 20 + r; i++) {\n\t\t\tdouble tmp = (i < 20 ? toSec(i - 19, building[i]) : toSec(i - 20, building[i]));\n\t\t\tif (tmp < min) {\n\t\t\t\tmin = tmp;\n\t\t\t\tx = i;\n\t\t\t\ty = building[i];\n\t\t\t}\n\t\t}\n\n\t\tcout << min << endl;// << \" :: \" << x << \":\" << y << endl;\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint main(){\n\twhile(1){\n\t\tint r; int n;\n\t\tint xl[25],xr[25],y[25];\n\t\tscanf(\"%d%d\",&r,&n);\n\t\tif(n == 0) return 0;\n\t\tmap<int,int>M;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d\",&xl[i],&xr[i],&y[i]);\n\t\t\tfor(int j=xl[i];j<xr[i];j++) M[j] = max(M[j],y[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int X=-r;X<=-1;X++){\n\t\t\t//[X,X+1], X+1 is highest\n\t\t\tif(M.find(X) == M.end()){\n\t\t\t\tans = 0.0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble L = sqrt((double)r*(double)r - (double)(X+1)*(double)(X+1));\n\t\t\t\tL = (double)r-L;\n\t\t\t\tans = min(ans,L+(double)M[X]);\n\t\t\t}\n\t\t}\n\t\tfor(int X=0;X<r;X++){\n\t\t\t//[X,X+1], X is highest\n\t\t\tif(M.find(X) == M.end()){\n\t\t\t\tans = 0.0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble L = sqrt((double)r*(double)r - (double)(X)*(double)(X));\n\t\t\t\tL = (double)r-L;\n\t\t\t\tans = min(ans,L+(double)M[X]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this); \n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto dist = distance_lp(l, c);\n  if(dist > c.r + EPS) { return {{-inf,-inf},{-inf,-inf}}; }\n  auto basehalf = sqrt(c.r * c.r - dist * dist);\n  P v = (l[1]-l[0]) * P(0, 1);\n  Line h(c, c+v); P ph = crosspoint(l, h);\n  P u1 = (ph + v) * P(0, 1); u1 /= abs(u1); u1 *= basehalf;\n  P u2 = (ph + v) * P(0, -1); u2 /= abs(u2); u2 *= basehalf;\n  return {u1, u2};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  for(int R, N; cin >> R >> N && (R | N);) {\n    vector<int> hs(44); int const OF = 22;\n    rep(i, N) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      REP(x, xl, xr) {\n        maximize(hs[x+OF], h);\n      }\n    }\n    vector<P> events;\n    int currh = 0;\n    events.emplace_back(-22, 0);\n    REP(x, -21, 22) {\n      if(currh != hs[x+OF]) {\n        events.emplace_back(x, currh);\n        currh = hs[x+OF];\n        events.emplace_back(x, currh);\n      }\n      else {\n        if(x == 0) {\n          events.emplace_back(x, currh);\n        }\n      }\n    }\n\n//    for(auto && e: events) { cout << e << endl; } cout << endl;\n\n    Circle c(P(0, -R), R);\n\n    for(double t=0; t<=20; t+=0.000001) {\n      bool ok = 0;\n      rep(i, events.size()) {\n        if(abs(c - events[i]) < c.r) {\n          printf(\"%.10f\\n\", t);\n          ok = 1;\n          break;\n        }\n      }\n      if(ok) { break; }\n      c.cent[1] += 0.000001;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> point;\n\nint main(int argc, char *argv[]){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, n){\n    vector<int> hl(50, 1e9), hr(50, 1e9);\n    for (int i = 0; i < n; i++) {\n      int xr, xl, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl + 1; j < xr; j++) {\n        hl[j + diff] = hr[j + diff] = h;\n      }\n      hl[xl + diff] = hr[xr + diff] = h;\n    }\n    double ans = 1e9;\n    for (int i = -r; i <= r; i++) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tlong double radius;\n\tvector<long double>ans;\n\twhile(cin>>radius>>N,N){\n\t\tvector<int>l(100);\n\t\tvector<int>r(100);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>L>>R>>K;\n\t\t\tr[L+50]=max(r[L+50],K);\n\t\t\tl[R+50]=max(l[R+50],K);\n\t\t\tfor(int j=L+51;j<R+50;j++){\n\t\t\t\tr[j]=max(r[j],K);\n\t\t\t\tl[j]=max(l[j],K);\n\t\t\t}\n\t\t}\n\t\tlong double ret=100;\n\t\tfor(int i=-radius+1;i<radius;i++){\n\t\t\tlong double h=min(r[i+50],l[i+50]);\n\t\t\tlong double amari=radius*radius;\n\t\t\tamari-=i*i;\n\t\t\tamari=sqrt(amari);\n\t\t\tamari-=radius;\n\t\t\t//cout<<endl<<radius<<\" \"<<amari<<endl;\n\t\t\tret=min(ret,h-amari);\n\t\t\t//cout<<ret<<endl;\n\t\t}\n\t\tans.push_back(ret);\n\t}\n\tfor(auto i:ans)cout<<setprecision(20)<<i<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\nint main(){\n\tint d,n;\n\twhile(cin>>d>>n,d){\n\t\tvi v(42,0);\n\t\trep(lp,n){\n    \t\tint l,r,h;  cin>>l>>r>>h;\n    \t\tfor(int i=l+20;i<r+20;i++){\n    \t\t    v[i]=max(v[i],h);\n    \t\t}\n\t\t}\n\t\tvi nv(42,0);\n\t\trange(i,1,41){\n\t\t    nv[i]=min(v[i-1],v[i]);\n\t\t}\n\t\tv=nv;\n\t\tdouble ans=INF;\n\t\tfor(int x=-d+21;x<=d+19;x++){\n\t\t    double t=v[x]-sqrt(d*d-(x-20)*(x-20));\n\t\t    ans=min(ans,t);\n\t\t    //cout<<x-20<<\": \"<<v[x]<<\"  \";\n\t\t}\n\t\tcout<<fixed<<setprecision(4)<<ans+d<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, r;\n\twhile (cin >>r>>n, r) {\n\t\tmap<int, int> v;\n\t\tint cmin = INF, cmax = -INF;\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcmin = min(cmin, a);\n\t\t\tcmax = max(cmax, b);\n\t\t\tFOR(j, a, b)v[j] = max(v[j], c);\n\t\t}\n\t\tif (cmin == INF) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tdouble u = 20, l = 0;\n\t\t\twhile (u - l > EPS) {\n\t\t\t\tint flag = 1;\n\t\t\t\tdouble mid = (u + l) / 2;\n\t\t\t\tFOR(i, cmin, cmax) {\n\t\t\t\t\tint d = i;\n\t\t\t\t\tif (i < 0)d++;\n\t\t\t\t\tdouble c = sqrt(r*r - d*d);\n\t\t\t\t\tif (c + mid -r> v[i])flag = 0;\n\t\t\t\t}\n\t\t\t\tif (flag)l = mid;\n\t\t\t\telse u = mid;\n\t\t\t}\n\t\t\tcout << fixed << setprecision(3) << l << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(n); ++i)\nusing namespace std;\n#define N 20\n//#define vec vector<int>\n\nclass rec {\npublic:\n  int l;\n  int r;\n  int h;\n  rec(int l_ = 0, int r_ = 0, int h_ = 0) : l(l_), r(r_), h(h_) {}\n};\n\nint main(){\n  while(true){\n    int r,n;\n    cin>>r>>n;\n    if(r==0){\n      break;\n    }\n    n++;\n    vector<rec> v(n);\n    REP(i,n-1){\n      int tl,tr,th;\n      cin>>tl>>tr>>th;\n      v[i] = rec(tl,tr,th);\n    }\n    v[n-1] = rec(-20, 20, 0);\n    //hについて降順ソート\n    sort(v.begin(), v.end(), [](rec lhs, rec rhs){ return lhs.h > rhs.h;});\n\n    //左右で覆われている範囲\n    vector<int> pl(n,0);\n    vector<int> pr(n,0);\n    vector<int> p(n,0);\n\n    //pを計算\n    REP(i,n){\n      REP(j,n){\n        if(v[j].h <= v[i].h) break;\n        if(v[j].l <= pr[i]){\n          pr[i] = max(pr[i], v[j].r);\n        }\n        if(v[j].r >= pl[i]){\n          pl[i] = min(pl[i], v[j].l);\n        }\n      }\n    }\n    REP(i,n){\n      p[i] = min(-pl[i], pr[i]);\n    }\n\n    //tを計算\n    double t = 500.0;\n    REP(i,n){\n      if(r<=p[i]) continue;\n      double tmp = v[i].h + r - sqrt(r*r - p[i]*p[i]);\n      t = min(tmp,t);\n    }\n    cout<<fixed << setprecision(4) <<t<<endl;\n\n\n    //debug\n    /*\n    REP(i,n){\n      cout<<\"v[\"<<i<<\"] = \"<<v[i].l<<\" \"<<v[i].r<<\" \"<<v[i].h<<endl;\n    }\n    REP(i,n){\n      cout<<\"p[\"<<i<<\"] = \"<<pl[i]<<\" \"<<pr[i]<<\" \"<<p[i]<<endl;\n    }\n    */\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\twhile (true) {\n\t\tint r, n;\n\t\tcin >> r >> n;\n\n\t\tif (r == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbool grid[22][41];\n\t\tfor (int i = 0; i < 22; i++) {\n\t\t\tfor (int j = 0; j < 41; j++) {\n\t\t\t\tgrid[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint lx, rx, y;\n\t\t\tcin >> lx >> rx >> y;\n\n\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\tfor (int k = lx + 20; k < rx + 20; k++) {\n\t\t\t\t\tgrid[j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 100;\n\n\t\tfor (int y = 0; y < 22; y++) {\n\t\t\tfor (int x = -r + 20; x < r + 20; x++) {\n\t\t\t\tif (grid[y][x] == false) {\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (x < 20) {\n\t\t\t\t\t\ttemp = (double)r - sqrt((double)r * 2 - abs(x - 19)*abs(x - 19)) + y;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttemp = (double)r - sqrt((double)r * 2 - abs(x - 20)*abs(x - 20)) + y;\n\t\t\t\t\t}\n\t\t\t\t\tans = min(ans, temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.4f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<pi, int> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint p[50];\nint is[50];\nint r, n;\n\nint C(double t){\n  if(p[20] < t) return 0;\n  for(int i=0;i<41;i++){\n    int x = i-20;\n    if(SQ((t-r)-p[i])+SQ(x)  < SQ(r)) return 0;\n  }\n  return 1;\n}\nint main()\n{\n  while(1){\n    cin >> r >> n;\n    if(r == 0 && n == 0) return 0;\n    memset(p, 0, sizeof(p));\n    memset(is, -1, sizeof(is));\n    int maxh = 0;\n    int xl[32], xr[32], h[32];\n    pii x[32];\n    rep(i, n){\n      cin >> xl[i] >> xr[i] >> h[i];\n      //      cin >> x[i].first.first >> x[i].first.second >> x[i].second;\n      for(int j=xl[i]+1;j<xr[i];j++){\n\t//      for(int j=x[i].first.first+1;j<x[i].first.second;j++){\n\t//\t  cout << i << \" \" << j << \" \" << p[39] << endl;\n\tif(p[j+20] < h[i]){\n\t  //\tif(p[j+20] < x[i].second){\n\t  //\t  cout << p[j+20] << \" \" << x[i].second << endl;\n\t  //\t  p[j+20] = x[i].second;\n\t  p[j+20] = h[i];\n\t}\n\t//\tp[j+20] = max(p[j+20], x[i].second);\n\n      }\n      //      for(int j=x[i].first.first;j<=x[i].first.second;j++) is[j] = 0;\n      maxh = max(maxh, h[i]);\n    }\n    sort(x, x+n);\n    rep(i, n) rep(j, n){\n      if(i == j) continue;\n      //      if(x[i].first.second == x[j].first.first)\n      //\tp[x[i].first.second+20] = max(p[x[i].first.second+20], min(x[i].second, x[j].second));\n      if(xr[i] == xl[j])\n\tp[xr[i]+20] = max(p[xr[i]+20], min(h[i], h[j]));\n    }\n    //    rep(i, 41) cout << p[i] << \" \"; cout << endl;\n    double lb = 0.0, ub = maxh;\n    rep(i, 100){\n      double mid = (lb+ub)/2;\n      //      cout << mid << endl;\n      if(C(mid)) lb = mid;\n      else ub = mid;\n    }\n    printf(\"%.12f\\n\", lb);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\nstruct Point {\n\n\n    double x, y;\n\n    Point() {\n        x = 0;\n        y = 0;\n    }\n\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n\n    inline Point operator+=(double s) {\n        this->y += s;\n    }\n\n//    constexpr Point operator+(Point rhs) const {\n//        return {x + rhs.x, y + rhs.y};\n//    }\n//\n//    constexpr Point operator-(Point rhs) const {\n//        return {x - rhs.x, y - rhs.y};\n//    }\n\n};\n\ninline Point operator+(double s, Point p) {\n    return {p.x, s + p.y};\n}\n\n\nstruct Rect {\n\n    Point left;\n    Point right;\n\n    Rect() {\n\n    }\n\n    Rect(int left_x, int right_x, int y) {\n        left = Point(left_x, y);\n        right = Point(right_x, y);\n    }\n\n};\n\nbool isSection(Point point, Rect rect) {\n    if (rect.left.x <= point.x && point.x <= rect.right.x && point.y <= rect.left.y) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n\n    while (true) {\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0) {\n            break;\n        }\n\n        vector<Point> circlePoints(100000);\n        REP(i, circlePoints.size()) {\n            double x = -r + ((2.0 * r) * ((double) i / (double) circlePoints.size()));\n            double y = sqrt(r * r - x * x);\n            circlePoints[i] = Point(x, y);\n        }\n\n        vector<Rect> rects(n + 1);\n        REP(i, n + 1) {\n            if (i == n) {\n                rects[n] = Rect(-1000, 1000, 0);\n            } else {\n                int left, right, h;\n                cin >> left >> right >> h;\n                rects[i] = Rect(left, right, h);\n            }\n        }\n\n        double diff = 10;\n\n        bool plus = true;\n        while (diff > 0.00000001) {\n            if (plus) {\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += diff;\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n                if (good) {\n                    continue;\n                } else {\n                    diff /= 2.0000;\n                    plus = false;\n                    // cout << diff;\n                }\n\n            } else {\n\n\n                //cout << \"here\";\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += (-diff);\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n\n                if (good) {\n                    diff /= 2.0000;\n                    plus = true;\n                    //cout << diff << endl;\n                } else {\n                    continue;\n                }\n            }\n        }\n\n        double largeY = -1;\n        REP(i, circlePoints.size()) {\n            largeY = max(largeY, circlePoints[i].y);\n        }\n\n\n//        double ans = floor_n(largeY, 4);\n        cout << fixed << setprecision(6) << largeY << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Vampire\n#include<bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint h1[40];//x[0]:-20?-19, x[39]:19?20\nint h2[41];//判定用\nconst double EPS=1E-5;\n\nbool a(double t){\n  complex<double> c;\n  c.real()=0.0, c.imag()=t-2.0;\n  for(int i=0; i<41; i++){\n    complex<double> d;\n    d.real()=i-20; d.imag()=h2[i];\n    //printf(\"(%f, %f)->%f\\n\", d.real(), d.imag(), abs(c-d));\n    if(abs(c-d)<r-EPS)return true;//含む\n  }\n  return false;//含まない\n}\n\ndouble solve(){\n  double ret=0;\n  while(true){\n    //cout<<\"ret=\"<<ret<<endl;\n    if(a(ret))break;\n    ret+=0.0001;\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    cin>>r>>n;\n    if(r==0 && n==0)break;\n    memset(h1, 0, sizeof(h1));\n    memset(h2, 0, sizeof(h2));\n    for(int i=0; i<n; i++){\n      int xl, xr, h;\n      cin>>xl>>xr>>h;\n      xl+=20; xr+=20;\n      for(int j=xl; j<xr; j++)\n        if(h1[j]<h)h1[j]=h;\n    }\n    for(int i=1; i<40; i++)\n      h2[i]=min(h1[i-1], h1[i]);\n    printf(\"%.8f\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\n\nint main() {\n    int n,r;\n    while (cin >> r >> n && r) {\n        int mh_[50]={};\n        auto mh = mh_+25;\n        rep(i,n){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            loop(j,xl,xr) mh[j] = max(mh[j], h);\n        }\n        double ans = 1e200;\n        loop(x,-r,r){\n            double dx = x;\n            if(x<0) dx++;\n            double dy = r-sqrt(r*r-dx*dx);\n            ans = min(ans, mh[x]+dy);\n        }\n        printf(\"%.4lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double inf = 1e10;\n\nint main() {\n  for(int r, n; cin >> r >> n && (r|n); ) {\n    vector<int> hs(2 * r);\n    for(int i = 0; i < n; ++i) {\n      int a, b, h;\n      cin >> a >> b >> h;\n      a += r; b += r;\n      for(int j = a; j < b; ++j) {\n        if(0 <= j && j < hs.size()) {\n          hs[j] = max(hs[j], h);\n        }\n      }\n    }\n    double t = inf;\n    for(int j = 1; j < hs.size(); ++j) {\n      double x = j - r;\n      t = min(t, (double)min(hs[j-1], hs[j]) + r - sqrt(r*r - x*x));\n    }\n    printf(\"%.10f\\n\", t);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint nextInt() { int d; cin >> d; return d; }\n\nconst double EPS = 10e-6;\n\nstruct Rect {\npublic:\n  int height;\n  int xl, xr;\n  \n  Rect() { }\n  Rect(int xl, int xr, int height):\n    xl(xl), xr(xr), height(height) { }\n};\n\nstruct Point {\npublic:\n  double y, x;\n  Point() { }\n  Point(double y, double x): y(y), x(x) { }\n};\n\nbool judge(const vector<Point>& point, const int r, const double y) {\n  for (int i = 0; i < point.size(); i++) {\n    double dsq = (point[i].x * point[i].x) + ((point[i].y - y) * (point[i].y - y));\n    if (r * r - dsq > 0) {\n      return false;\n    }\n  }\n  \n  return true;  \n}\n\nint main() {\n  while (true) {\n    int r = nextInt();\n    int n = nextInt();\n    if (r + n == 0) {\n      break;\n    }\n    vector<Rect> rect(n);\n    int ymax = -1;\n    for (int i = 0; i < n; i++) {\n      int xl = nextInt();\n      int xr = nextInt();\n      int h  = nextInt();\n      ymax = max(ymax, h);\n      rect[i] = Rect(xl, xr, h);\n    }    \n  \n    sort(rect.begin(), rect.end(), [](Rect a, Rect b) {\n      if (a.xl == b.xl) {\n        return a.xr < b.xr;\n      }\n      return a.xl < b.xl;\n    });\n  \n    \n    for (int i = 0; i < n; i++) {\n      Rect& a = rect[i];\n      for (int j = 0; j < n; j++) {\n        Rect& b = rect[j];\n        if (a.xr > b.xr) {\n          // 3テ」ツ?、テ」ツ?ォテ」ツ?凖」ツつ?\n          rect.push_back(Rect(b.xr, a.xr, a.height));\n          a.xr = b.xl;\n        } else if (a.xr > b.xl) {\n          a.xr = b.xl;\n        }\n      }\n    }\n    \n        \n    vector<Point> point;\n    \n    point.push_back(Point(0, rect[0].xl));\n    point.push_back(Point(rect[0].height, rect[0].xl));\n    \n    for (int i = 1; i < rect.size(); i++) {\n      if (rect[i - 1].xr != rect[i].xl) {\n        point.push_back(Point(0, rect[i].xl));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xl));\n    }\n    \n    point.push_back(Point(0, rect[rect.size() - 1].xr));\n    point.push_back(Point(rect[rect.size() - 1].height, rect[rect.size() - 1].xr));\n    \n    for (int i = 0; i < rect.size() - 1; i++) {\n      if (rect[i + 1].xl != rect[i].xr) {\n        point.push_back(Point(0, rect[i].xr));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xr));\n    }\n    \n    double lt = 0, ht = ymax;\n    \n    for (int i = 0; i < 100; i++) {\n      double mt = (lt + ht) / 2;\n      double y = -r + mt;\n      if (judge(point, r, y)) {\n        lt = mt;\n      } else {\n        ht = mt;\n      }\n    }    \n    printf(\"%.15f\\n\", ht);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<map>\n#include<cstdio>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define pb push_back\n#define P pair<int,int>\n#define ll __int64\nint n;\ndouble r;\ndouble x[100],x2[100],h[100];\ndouble EPS=0.0001;\nbool che(double t){\n\n\nfor(int i=-r;i<r;i++){\n\tint a=i,b=i+1;//aとb両方でのyを求める[a,b]内で最大の高さの長方形を求める\n\t int in=-1;\n\t\tdouble ma=-1,y1,y2;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(x[j]<=a&&b<=x2[j]&&ma<h[j]){\n\t\t\t\tma=h[j];\t\n\t\t\t\tin=j;\n\t\t\t}\n\t\t}\n\t\ty1=sqrt(r*r-a*a)+t-r;\n\t\ty2=sqrt(r*r-b*b)+t-r;\n\t\t//cout<<a<<\" \"<<b<<\" \"<<y1<<\" \"<<y2<<endl;\n\t\tif(!(h[in]>=y1&&h[in]>=y2))return 0;\n}\n\n\treturn 1;\n}\n\n/*\nfor(int i=0;i<n;i++){\n\tdouble lx=x[i],rx=x2[i];\n\tif(lx<-r|| rx>r)continue;\n\tdouble ny=t-r;\n\tdouble y1,y2;\n\ty1=sqrt(r*r-lx*lx)+ny;\n\ty2=sqrt(r*r-rx*rx)+ny;\n\n\t//cout<<y1<<\" \"<<y2<<\" \"<<h[i]<<endl;\n\tif(!(h[i]>=y1&&h[i]>=y2))return 0;\n\t}\n*/\n\nint main(){\nwhile(cin>>r>>n,r||n){\nrep(i,n)cin>>x[i]>>x2[i]>>h[i];\n\n\n\ndouble mid=0,l=0,r=100;\nmid=(r+l)/2;\nfor(int i=0;i<20;i++){\n\tif(che(mid)){\n\t\tl=mid;\n\t}\n\telse{\n\t\tr=mid;\n\t}\n\tmid=(r+l)/2;\n}\n\nprintf(\"%.20lf\\n\",mid);\nrep(i,n)x[i]=x2[i]=h[i]=0;\n\n}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,N,n) for(int i=N;i>=n;i++)\n#define CH(n,a,b) (a)<=(n)&&(n)<(b)\n#define p(s) cout<<s<<endl;\ntypedef long long ll;\nusing namespace std;\n\nbool grid[25][45];\n\nint main() {\n\tint n, r, lx, rx, h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0 && n == 0) break;\n\t\tREP(i,0,25)REP(j,0,45) grid[i][j] = 0;\n\t\tREP(ii,0,n){\n\t\t\tcin>>lx>>rx>>h;\n\t\t\tREP(k,lx+20,rx+20)REP(l,0,h)grid[l][k] = 1;\n\t\t}\n\t\tbool flag = false;\n\t\tREP(i,0,21){\n\t\t\tREP(w,0,r){\n\t\t\t\tif( (grid[i][-w+20-1] == 0) || (grid[i][w+20] == 0)){\n\t\t\t\t\tif(-w+20<0) w--;\n\t\t\t\t\tdouble ans = r - sqrt(r*r - w*w);\n\t\t\t\t\t//cout<<\"i: \"<<i<<\" w: \"<<w<<endl;\n\t\t\t\t\tprintf(\"%.6f\\n\", ans+i);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n \nint s[21][41];\nint main(void){\n    int r, n, xl, xr, h;\n    while(cin >> r >> n && r) {\n        rep(i, 41) rep(j, 41) s[i][j] = 0;\n        rep(i, n) {\n            cin >> xl >> xr >> h;\n            for(int y=0; y<h; ++y) {\n                for(int x=xl+20; x<xr+20; ++x) {\n                    s[y][x] = 1;\n                }\n            }\n        }\n        /*for(int y=20; y>=0; --y) {\n            rep(x, 41) cout << s[y][x];\n            cout << endl;\n        }*/\n        double mint = numeric_limits<double>::max();\n        rep(y, 21) {\n            for(int x=-r+20; x<r+20; ++x) {\n                if(s[y][x] == 0) {\n                    double t;\n                    if(x<20) t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n                    else t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n                    mint = min(mint, t);\n                }\n            }\n        }\n        printf(\"%.4lf\\n\", mint);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Vampire\n#include<bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint h1[40];//x[0]:-20?-19, x[39]:19?20\nint h2[41];//判定用\nconst double EPS=1E-5;\n\nbool a(double t){\n  complex<double> c;\n  c.real()=0.0, c.imag()=t-2.0;\n  for(int i=0; i<41; i++){\n    complex<double> d;\n    d.real()=i-20; d.imag()=h2[i];\n    //printf(\"(%f, %f)->%f\\n\", d.real(), d.imag(), abs(c-d));\n    if(abs(c-d)<r-EPS)return true;//含む\n  }\n  return false;//含まない\n}\n\ndouble solve(){\n  double ret=0;\n  while(true){\n    //cout<<\"ret=\"<<ret<<endl;\n    if(a(ret))break;\n    ret+=0.0001;\n  }\n  return ret-0.0001;\n}\n\nint main(){\n  while(true){\n    cin>>r>>n;\n    if(r==0 && n==0)break;\n    memset(h1, 0, sizeof(h1));\n    memset(h2, 0, sizeof(h2));\n    for(int i=0; i<n; i++){\n      int xl, xr, h;\n      cin>>xl>>xr>>h;\n      xl+=20; xr+=20;\n      for(int j=xl; j<xr; j++)\n        if(h1[j]<h)h1[j]=h;\n    }\n    for(int i=1; i<40; i++)\n      h2[i]=min(h1[i-1], h1[i]);\n    /*\n    for(int i=0; i<41; i++)\n      cout<<h2[i]<<' ';\n      cout<<endl;*/\n    printf(\"%.8f\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  //cout << fixed << setprecision(12);\n  cout << fixed << setprecision(4);\n\n  while(1){\n    Int r, N;\n    cin>>r>>N;\n    if(r == 0 && N == 0) break;\n\n    vector<Int> mp(50);\n    for(Int i=0;i<N;i++){\n      Int l, r, h;\n      cin>>l>>r>>h;\n      l += 25;\n      r += 25;\n      for(Int x=l;x<r;x++) Max(mp[x], h);\n    }\n\n    auto dis = [&](Double x, Double y, Double a, Double b){\n      return sqrt( (x - a) * (x - a) + (y - b) * (y - b));\n    };\n\n    auto check = [&](Double cy){\n      Double cx = 25;\n      Double H = cy + r;\n      Double W = r;\n      if(cy < 0) W = sqrt(r * r - cy * cy);\n\n      for(Int x=1;x<49;x++){\n        if(dis(cx, cy, x, mp[x]) < r) return (Int)0;\n        if(dis(cx, cy, x, mp[x-1]) < r) return (Int)0;\n\n        Int h = cy >= 0? cy:0;\n        //if(x <= cx - W && cx - W <= x + 1 && mp[x-1] < h) return (Int)0;\n        //if(x <= cx + W && cx + W <= x + 1 && mp[x] < h) return (Int)0;\n\n        if(cx - W < x && x < cx + W){\n          if(mp[x] < h) return (Int)0;\n          if(cx - W != x && mp[x-1] < h) return (Int)0;\n\n        }\n      }\n      return (Int)1;\n    };\n\n    Double L = 0, R = 100;\n    for(Int t=0;t<100;t++){\n      Double M = (L + R) / 2;\n      if(check(M - r)) L = M;\n      else R = M;\n    }\n\n    cout<<L<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry{\n\t\t\twhile(true) {\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(r+n == 0) continue;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\n\n\tstatic double solve(int r, int n) throws Exception {\n\t\tint[] dp = new int[39];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.001) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <math.h>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint r,n;\nint main(){while(cin>>r>>n,r){int L,R,h;int A[41]={},B[41]={};for(int i=0;i<n;i++){cin>>L>>R>>h;for(int x=L;x<=R;x++){if(x!=R)A[x+20]=max(A[x+20],h);if(x!=L)B[x+20]=max(B[x+20],h);}}double res=100;for(int i=-r;i<=r-1;i++){res=min(res,min(r-sqrt(r*r-i*i)+A[i+20],r-sqrt(r*r-(i+1)*(i+1))+B[i+1+20]));}cout<<res<<\"\\n\";}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=20;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint r,n;\n\t\tcin>>r>>n;\n\t\tif(r==0) break;\n\t\tvi a(2*M);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint l,r,h;\n\t\t\tcin>>l>>r>>h;\n\t\t\tl+=M,r+=M;\n\t\t\tfor(int j=l;j<r;j++) a[j]=max(a[j],h);\n\t\t}\n\t\tdouble res=inf;\n\t\tfor(int i=0;i<2*M;i++){\n\t\t\tint d=(i<M?M-i-1:i-M);\n\t\t\tif(r>d){\n\t\t\t\tres=min(res,r+a[i]-sqrt(r*r-d*d));\n\t\t\t}\n\t\t}\n\t\tcout<<syosu(9)<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tlong double radius;\n\tcout<<setprecision(20);\n\twhile(cin>>radius>>N,N){\n\t\tvector<int>l(100);\n\t\tvector<int>r(100);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>L>>R>>K;\n\t\t\tr[L+50]=max(r[L+50],K);\n\t\t\tl[R+50]=max(l[R+50],K);\n\t\t\tfor(int j=L+51;j<R+50;j++){\n\t\t\t\tr[j]=max(r[j],K);\n\t\t\t\tl[j]=max(l[j],K);\n\t\t\t}\n\t\t}\n\t\tlong double ret=100;\n\t\tfor(int i=-radius+1;i<radius;i++){\n\t\t\tlong double h=min(r[i+50],l[i+50]);\n\t\t\tlong double amari=radius*radius;\n\t\t\tamari-=i*i;\n\t\t\tamari=sqrt(amari);\n\t\t\tamari-=radius;\n\t\t\tret=min(ret,h-amari);\n\t\t}\n\t\tprintf(\"%.4f\\n\",ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, n){\n    vector<int> hl(50, 0), hr(50, 0);\n    for (int i = 0; i < n; i++) {\n      int xr, xl, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl + 1; j < xr; j++) {\n        hl[j + diff] = max(hl[j + diff], h);\n        hr[j + diff] = max(hr[j + diff], h);\n      }\n      hl[xr + diff] = max(hl[xr + diff], h);\n      hr[xl + diff] = max(hr[xl + diff], h);\n    }\n    double ans = 1e9;\n    for (int i = -r + 1; i < r; i++) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\n\nfloat solve(int r, vector<array<int, 3>>& vs)\n{\n    std::array<int, 41> imos;\n    for(auto& e: imos) e = 0;\n\n    for(auto& e: vs){\n        imos[e[0] + 20] += 1;\n        imos[e[1] + 20] += -1;\n    }\n\n    int s = 0;\n    for(auto& e: imos){\n        s += e;\n        e = s;\n    }\n\n    int maxL = 0, maxR = 0;\n    for(int i = 0; i <= 20; ++i){\n        if(imos[i+20] == 0)\n            break;\n        maxL = i + 1;\n    }\n    for(int i = 0; i >= -20; --i){\n        if(imos[i+20] == 0)\n            break;\n        maxR = -i;\n    }\n\n    // for(auto&e : imos)\n    //     cout << e << \", \";\n    // cout << endl << \"maxL: \" << maxL << \", maxR: \" << maxR << endl;\n\n    int width = (maxL < maxR ? maxL : maxR) * 2;\n    // if(width != 0) width -= 1;\n    if(width == 0) return 0;\n    if(width > r)\n        width = r*2;\n\n    // cout << width << endl;\n\n    int wh = width / 2;\n    float whf = wh;\n\n    float hd = r - sqrt(r*r - whf*whf);\n    // if(!(hd > 0)) hd = 0;\n\n    std::array<int, 41> maxH;\n    for(auto& e: maxH) e = 0;\n    for(auto& e: vs){\n        for(int i = -20; i <= 20; ++i)\n            if(e[0] <= i && i < e[1]){\n                if(maxH[i+20] < e[2])\n                    maxH[i+20] = e[2];\n            }\n    }\n\n\n\n    float max = 0;\n    for(int i = -wh; i <= wh; ++i){\n        auto hh = sqrt(r*r - i*i) - (r - hd);\n        if(maxH[i+20] < hh && max < (hh - maxH[i+20])){\n            max = hh - maxH[i+20];\n        }\n    }\n\n    // cout << \"max: \" << max << endl;\n    // cout << \"hd: \" << hd << endl;\n\n    // for(auto&e : maxH)\n    //     cout << e << \", \";\n    // cout << endl;\n\n    if(max == 0){\n        float mm = 1024, ret = 0;\n        for(int i = -wh; i <= wh; ++i){\n            float rm1 = maxH[i+20] - sqrt(r*r - (i+1)*(i+1));\n            float rm2 = maxH[i+20] - sqrt(r*r - i*i);\n            float rm = rm1 < rm2 ? rm1 : rm2;\n            // cout << \"i: \" << i << \", rm1: \" << rm1 << \", rm2: \" << rm2 << endl;\n            if(maxH[i+20] != 0 && mm > rm){\n                mm = rm;\n                ret = rm + whf;\n            }\n        }\n\n        // cout << \"mm: \" << mm << endl;\n        return ret;\n    }\n\n    return hd - max;\n}\n\n\nint main(void)\n{\n    int r, n;\n    while(cin >> r >> n){\n        if(r == 0 && n == 0)\n            break;\n\n        vector<array<int, 3>> vs;\n        for(int i = 0; i < n; ++i){\n            array<int, 3> arr;\n            cin >> arr[0] >> arr[1] >> arr[2];\n            vs.push_back(arr);\n        }\n\n        cout << fixed << setprecision(4) << solve(r, vs) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int r, n;\n    while(1){\n        cin >> r >> n;\n        if(r == 0 && n == 0) break;\n        int building[42] = {};\n        for(int i = 0; i < n; i++){\n            int x1, x2, h;\n            cin >> x1 >> x2 >> h;\n            // cout << (double)r * r - pow(min(abs(x1), abs(x2)), 2) << endl;\n            \n            x1 += 20;\n            x2 += 20;\n            for(int i = x1; i < x2; i++){\n                building[i] = max(building[i], h);\n            }\n        }\n        double ans = 25.0;\n        for(int i = 20 - r; i < 20 + r; i++){\n// [cout << i - 20 << \" : \" << building[i] << (double)building[i] - sqrt(r * r - pow(abs(i - 20) - 1, 2)) + r << endl;\n            if(i - 20 < 0) ans = min(ans, (double)building[i] - sqrt(r * r - pow(-i + 20 - 1, 2)) + r);\n            else ans = min(ans, (double)building[i] - sqrt(r * r - pow(i - 20, 2)) + r);\n        }\n        printf(\"%.10f\\n\", max(ans, 0.0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nint test(vector<G> &g,double t,double r){\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(PI/2.);\n\t\n\tfor(int i = 0 ; i < 1440 ; i++)\n\t\tchkPoint.push_back(2.*i*PI/1440);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t}\n\t\t\t//chkPoint.push_back(g[i][j]);\n\t\t}\n\t}\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tif( contains(g[j],pp) && contains(g[j],c.p+r*P(cos(th+1e-7),sin(th+1e-7))) != OUT && contains(g[j],c.p+r*P(cos(th+1e-7),sin(th-1e-7))) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\tg.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl-1e-7,0},{xr+1e-7,0},{xr+1e-7,h},{xl-1e-7,h}});\n\t\t}\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint x[22][42];\nint r, n;\nint dx[] = {0, -1, -1, 0};\nint dy[] = {0, 0, -1, -1};\n\nbool check(double t) {\n  repl(i, 1, 21)repl(j, 1, 41) {\n    if ((i - t + r) * (i - t + r) + (j - 21) * (j - 21) < r * r) {\n      rep(k, 4) {\n        if (x[i + dy[k]][j + dx[k]] == 0) {\n          return false;\n        }\n      }\n    }/* else if ((i - t + r) * (i - t + r) + (j - 21) * (j - 21) == r * r) {\n\n    }*/\n  }\n  return true;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  rep(i, 22)rep(j, 42) x[i][j] = 1;\n\n  while(cin >> r >> n, r) {\n    repl(i, 1, 21)repl(j, 1, 41) x[i][j] = 0;\n\n    rep(i, n) {\n      int l, r, h;\n      cin >> l >> r >> h;\n\n      repl(k, 1, h)repl(j, l + 21, r + 21) x[k][j] = 1;\n    }\n\n    double ok = 0, ng = 20, md;\n    rep(i, 100) {\n      md = (ok + ng) / 2;\n      if (check(md)) ok = md;\n      else ng = md;\n    }\n\n    printf(\"%.10f\\n\", ok);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n#define px 20\n\nint main() {\n\n  while( true ) {\n\n    long long int r, n;\n    cin >> r >> n;\n    if ( r == 0 ) break;\n\n    long long int dy[50][2] = {};\n\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int minx, maxx, h;\n      cin >> minx >> maxx >> h;\n      minx += px;\n      maxx += px;\n      for ( long long int j = minx; j < maxx; j++ ) {\n\tdy[j][1] = h;\n\tdy[j+1][0] = h;\n      }\n    }\n    \n    double ans = 50.0;\n\n    for ( long long int i = px - r + 1; i < px + r; i++ ) {\n      double x = i - px;\n      double y = sqrt( r * r - x * x );\n      ans = min( ans, dy[i][0] - y + r );\n      ans = min( ans, dy[i][1] - y + r );\n    }\n    ans = min( ans, 0.0 + dy[px-r][1] + r );\n    ans = min( ans, 0.0 + dy[px+r][0] + r );\n    cout << fixed << setprecision(10) << ans << endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-10;\n\n#define INF (1<<29)\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int r;\n  int n;\n  while (cin >> r >> n) {\n    if (r == 0 && n == 0) break;\n    if (n == 0) {\n      cout << 0 << endl;\n      continue;\n    }\n    map<int, map<int, double>> height;\n    int lx, rx, h;\n    int l_end = INF;\n    int r_end = -INF;\n    rep(i, n) {\n      cin >> lx >> rx >> h;\n      l_end = min(l_end, lx);\n      r_end = max(r_end, rx);\n      REP(j, lx, rx) {\n        height[j][j+1] = max<double>(h, height[j][j+1]);\n      }\n    }\n    l_end = min(-r, l_end);\n    r_end = max(r, r_end);\n\n    // simulation\n    double center = -r;\n    double step = 0.0001;\n    double ans = -step;\n    while (true) {\n      bool judge = true;\n      REP(i, l_end, r_end) {\n        int lx = i;\n        int rx = i + 1;\n        double h = height[lx][rx];\n        double dl = sqrt(fabs(h - center) * fabs(h - center) + abs(lx) * abs(lx));\n        double dr = sqrt(fabs(h - center) * fabs(h - center) + abs(rx) * abs(rx));\n        if (dl < r || dr < r) {\n          judge = false;\n          break;\n        }\n      }\n      if (!judge) break;\n      center += step;\n      ans += step;\n    }\n    cout << fixed << setprecision(4) << ans << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long \nint h[40];\nint n;\ndouble r;\ninline bool check(double t);\nint main(){\n    while(cin>>r>>n,r){\n        for(int i=0;i<40;i++)h[i]=0;\n        for(int i=0;i<n;i++){\n            int a,b,c;cin>>a>>b>>c;\n            for(int j=a+20;j<b+20;j++){\n                h[j]=max(h[j],c);\n            }\n        }\n        double ok=0,ng=21;\n        for(int i=0;i<50;i++){\n            double mid=(ok+ng)/2;\n            if(check(mid))ok=mid;\n            else ng=mid;\n        }\n        printf(\"%.9f\\n\",ok);\n    }\n    return 0;\n}\n\ninline bool check(double t){\n    for(int i=20-r+1;i<20+r;i++){\n        double x=sqrt(r*r-(i-20)*(i-20))-r+t;\n        if((double)h[i]>=x && (double)h[i-1]>=x){\n            continue;\n        }else{\n            //cout<<\"false\"<<endl;\n            //printf(\"%.9f\\n\",t);\n            return false;\n        }\n    }\n    //cout<<\"true\"<<endl;\n    //printf(\"%.9f\\n\",t);\n    return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define let const auto\nstring get_line() { string line; cin >> line; return line; }\nint get_int(){ int tmp; cin >> tmp;return tmp; }\n\nstruct Building{ int l,r,h; };\nint main() {\n  while(true){\n    let r = get_int();\n    let n = get_int();\n    if(r == 0 and n == 0) return 0;\n    vector<Building> bs(n);\n    bool fills[20][20];\n    double lens[20][20];\n    { // setup fills and bs and lens\n      REP(i,n) bs[i] = {get_int(),get_int(),get_int()};\n      bool silhouettes[40][20];\n      REP(x,40) REP(y,20) silhouettes[x][y] = false;\n      for(auto b :bs) REP(y,b.h) FOR(x,b.l,b.r){\n        silhouettes[x + 20][y] = true;\n      }\n      REP(x,20) REP(y,20) {\n        fills[x][y] = silhouettes[20+x][y] && silhouettes[20-x-1][y];\n        lens[x][y] = y - sqrt(r * r - (x+1) * (x+1)) + r;\n      }\n    }\n    double maxlens[20];\n    { // setup maxlens\n      REP(x,r) {\n        double maxlen = 0.0;\n        REP(y,20){\n          if(not fills[x][y]) continue;\n          int add = (fills[x+1][y]) ? 1 : 0;  //WARN:\n          maxlen = max(lens[x][y],maxlen + add);\n        }\n        maxlens[x] = maxlen;\n      }\n    }\n    double result = 0.0;\n    REP(x,r) REP(y,20){\n      if(not fills[x][y]) continue;\n      double len = lens[x][y];\n      bool isOk = true;\n      REP(x1,r) {\n        if(maxlens[x1] < len) isOk = false;\n      }\n      if(not isOk) continue;\n      result = max(result,len);\n    }\n    cout << result << endl;\n    // [&](){ REP(y,5) { REP(x,r) cout << (fills[x][y] ? '#' : '.'); cout<< endl;}};\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\nstruct Point {\n\n\n    double x, y;\n\n    Point() {\n        x = 0;\n        y = 0;\n    }\n\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n\n    inline Point operator+=(double s) {\n        this->y += s;\n    }\n\n//    constexpr Point operator+(Point rhs) const {\n//        return {x + rhs.x, y + rhs.y};\n//    }\n//\n//    constexpr Point operator-(Point rhs) const {\n//        return {x - rhs.x, y - rhs.y};\n//    }\n\n};\n\ninline Point operator+(double s, Point p) {\n    return {p.x, s + p.y};\n}\n\n\nstruct Rect {\n\n    Point left;\n    Point right;\n\n    Rect() {\n\n    }\n\n    Rect(int left_x, int right_x, int y) {\n        left = Point(left_x, y);\n        right = Point(right_x, y);\n    }\n\n};\n\nbool isSection(Point point, Rect rect) {\n    if (rect.left.x <= point.x && point.x <= rect.right.x && point.y <= rect.left.y) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n\n    while (true) {\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0) {\n            break;\n        }\n\n        vector<Point> circlePoints(100000);\n        REP(i, circlePoints.size()) {\n            double x = -r + ((2.0 * r) * ((double) i / (double) circlePoints.size()));\n            double y = sqrt(r * r - x * x);\n            circlePoints[i] = Point(x, y);\n        }\n\n        vector<Rect> rects(n + 1);\n        REP(i, n + 1) {\n            if (i == n) {\n                rects[n] = Rect(-1000, 1000, 0);\n            } else {\n                int left, right, h;\n                cin >> left >> right >> h;\n                rects[i] = Rect(left, right, h);\n            }\n        }\n\n        double diff = 20;\n\n        bool plus = true;\n        while (diff > 0.000001) {\n            if (plus) {\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += diff;\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n                if (good) {\n                    continue;\n                } else {\n                    diff /= 2.0000;\n                    plus = false;\n                    // cout << diff;\n                }\n\n            } else {\n\n\n                //cout << \"here\";\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += (-diff);\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n//                double largeY = -1;\n//                REP(i, circlePoints.size()) {\n//                    largeY = max(largeY, circlePoints[i].y);\n//                }\n\n                if (good) {\n                    diff /= 2.0000;\n                    plus = true;\n                    //cout << diff << endl;\n                } else {\n                    continue;\n                }\n            }\n        }\n\n        double largeY = -1;\n        REP(i, circlePoints.size()) {\n            largeY = max(largeY, circlePoints[i].y);\n        }\n\n\n        double ans = floor_n(largeY, 4);\n        cout << fixed << setprecision(4) << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=(-x-0.999999),R=(x+0.999999),hb[101]={};\n\n  for(int i=L+50;i<R+50;i++){\n    int x1=i-49-i/50;\n    double y1=y[i]-cy;\n    if(sqrt(x1*x1+y1*y1)>=r)hb[i]++;\n  }\n  for(int i=L+50;i<R+50;i++)if(!hb[i])return 0;\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<100;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.0001;\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r, h;\n  double xl, xr, ans;\n  vector<int> V(41,0);  \n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define x first\n#define y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint main(void){\n    double res;\n    for(int r, n; cin >> r >> n, r; cout << res << endl){\n        res = 0.;\n        map<int, map<int, int> > shadows;\n        rep(i, n){\n            int left, right, h; cin >> left >> right >> h;\n            range(x, left, right){\n                shadows[x][x + 1] = max(shadows[x][x + 1], h);\n            }\n        }\n\n        bool ok = false;\n        for(; !ok; res += 0.0001){\n            pair<double, double> o = mp(0., -r + res);\n\n            range(x, -r, r){\n                rep(i, 2){\n                    double d = sqr(x + i - o.x) + sqr(shadows[x][x + 1] - o.y);\n\n                    if(d <= (double)sqr(r)){\n                        ok = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n\nint main() {\n    while(true) {\n        vector<double> height(40, 0.0);\n        int sun_r, n; cin >> sun_r >> n;\n        if(sun_r == 0 && n == 0) break;\n        for(int i = 0; i < n; ++i) {\n            int l, r; double h;\n            cin >> l >> r >> h;\n            l += 20, r += 20;\n            for(int x = l; x < r; ++x) {\n                height[x] = max(height[x], h);\n            }\n        }\n        double ans = 20.0;\n        for(int i = 0; i < sun_r; ++i) {\n            double limit = min(height[20+i], height[19-i]);\n            double max_h = limit - sqrt(1.0*(sun_r*sun_r - i*i)) + sun_r;\n            if(ans > max_h) ans = max_h;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n// [Problem] Vampire\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194&lang=jp\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *   @FileName\ta.cpp\n *   @Author\tkanpurin\n *   @Created\t2020.07.13 01:31:57\n**/\n\n#include \"bits/stdc++.h\" \nusing namespace std; \ntypedef long long ll;\n\nint main() {\n    while (true) {\n        int r, n;\n        cin >> r >> n;\n        if (r == 0) break;\n        vector< int > height(81);\n        for (int i = 0; i < n; i++) {\n            int x, y, h;\n            cin >> x >> y >> h;\n            x *= 2;\n            y *= 2;\n            x += 40;\n            y += 40;\n            for (int j = x + 1; j <= y - 1; j++) {\n                height[j] = max(height[j], h);\n            }\n        }\n        double ans = 1000000;\n        for (int i = -r * 2 + 40; i <= r * 2 + 40; i += 2) {\n            if (i == -r * 2 + 40) {\n                ans = min(ans, height[i + 1] + r - sqrt(r * r - (i - 40) * (i - 40) / 4));\n            } else if (i == r * 2 + 40) {\n                ans = min(ans, height[i - 1] + r - sqrt(r * r - (i - 40) * (i - 40) / 4));\n            } else {\n                ans = min(ans, min((i >= 1 ? height[i - 1] : 0), (i < 80 ? height[i + 1] : 0)) + r - sqrt(r * r - (i - 40) * (i - 40) / 4));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nvoid solve(int rad, int n, vi l, vi r, vi h) {\n  double ok = 0, ng = 20 + rad;\n  rep (_, 10000) {\n    bool flag = true;\n    double t = (ok + ng) / 2.0;\n    for (int x = -rad; x <= rad; x++) {\n      int left_ma = 0, right_ma = 0;\n      rep (i, n) {\n        if (l[i] < x && x < r[i]) {\n          chmax(left_ma, h[i]);\n          chmax(right_ma, h[i]);\n        }\n        else if (l[i] == x) {\n          chmax(right_ma, h[i]);\n        }\n        else if (r[i] == x) {\n          chmax(left_ma, h[i]);\n        }\n      }\n      int ma;\n      if (x == -rad) ma = right_ma;\n      else if (x == rad) ma = left_ma;\n      else ma = min(left_ma, right_ma);\n      double y = sqrt(rad*rad - x*x) - rad + t;\n      if (y > ma) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) ok = t;\n    else ng = t;\n  \n  }\n  Sp(ok);\n}\n\nint main() {\n  while (true) {\n    int rad, n;\n    cin >> rad >> n;\n    if (rad == 0) return 0;\n    vi l(n), r(n), h(n);\n    rep (i, n) {\n      cin >> l[i] >> r[i] >> h[i];\n    }\n    solve(rad, n, l, r, h);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, a, n) for(int i=a;i < n;i++)\n#define all(e) e.begin(), e.end()\n#define INF (1 << 30)\n#define INFL (1LL << 55)\n#define EPS 1e-9\n\nusing namespace std;\n\nstruct Solve {\n    vector<int> bh;\n    int r;\n    int zero = 20;\n\n    bool gt(double a, double b) {\n        double tmp = a - b;\n        return tmp > EPS;\n    }\n\n\n    bool check(double y) {\n        for (int i = -19; i < 20; ++i) {\n//            if (2 * abs(i) > r) continue;\n//            if (r * r < i * i) continue;\n            vector<double> kouho;\n            for (int di = -1; di <= 0; ++di) {\n//                if (abs(i + di) <= r) {\n//                    kouho.push_back(bh[zero + i + di]);\n//                }\n                if (i == 0) {\n                    kouho.push_back(bh[zero + i + di]);\n                } else if (i < 0) {\n                    if (abs(i + di) <= r)\n                        kouho.push_back(bh[zero + i + di]);\n                } else if (i > 0) {\n                    if (abs(i + di) < r)\n                        kouho.push_back(bh[zero + i + di]);\n                }\n            }\n            if (kouho.size() == 0) continue;\n            double h = *min_element(all(kouho));\n//            double h = bh[zero + i];\n//            if (i > 0) h = bh[zero + i - 1];\n//            if (i == 0) h = min(bh[zero + i - 1], bh[zero + i]);\n\n            double sh = sqrt(1.0 * r * r - i * i) + (1.0 * y - r);\n            if (gt(sh, h))\n                return false;\n        }\n        return true;\n    }\n\n    bool solve() {\n        bh.resize(40, 0);\n        int n;\n        cin >> r >> n;\n        if (r == 0 && n == 0) return false;\n        for (int i = 0; i < n; ++i) {\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            for (int x = xl + zero; x < xr + zero; ++x) {\n                bh[x] = max(bh[x], h);\n            }\n        }\n\n//        double lb = 0, ub = 100.0;\n        double ok = 0.0, ng = 100.0;\n        check(3.0);\n\n        for (int _ = 0; _ < 100; ++_) {\n            double mid = (ok + ng) / 2;\n            if (check(mid)) {\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n//        cout << lb << endl;\n        printf(\"%.5f\\n\", ok);\n        return true;\n    }\n};\n\nint main() {\n    while (Solve().solve()) {\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i-1-r)*(i-1-r)));\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nsigned main(){\n\twhile(true){\n\t\tint r=read(),n=read();\n\t\tif(r==0&&n==0) break;\n\t\t\n\t\tint xl[n],xr[n],h[n];\n\t\t\n\t\tREP(i,n){\n\t\t\txl[i]=read();\n\t\t\txr[i]=read();\n\t\t\th[i]=read();\n\t\t}\n\t\t\n\t\tint maxheight[2*r]={0};\n\t\t\n\t\tREP(i,n){\n\t\t\tfor(int j=-r;j<=r;j++){\n\t\t\t\tif(j<=xr[i]&&j>=xl[i]&&j+1<=xr[i]&&j+1>=xl[i]){\n\t\t\t\t\tmaxheight[j+r] = max(maxheight[j+r],h[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//REP(i,2*r) cout << maxheight[i];\n\t\t//cout << endl;\n\t\t\n\t\tfloat ans=0.000;\n\t\twhile(true){\n\t\t\tbool flag=true;\n\t\t\tREP(i,2*r){\n\t\t\t\tint x1=abs(i-r);\n\t\t\t\tint x2=abs(i+1-r);\n\t\t\t\tif(r*r-x1*x1 >= (maxheight[i]+r-ans)*(maxheight[i]+r-ans) || r*r-x2*x2 >= (maxheight[i]+r-ans)*(maxheight[i]+r-ans)){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false){\n\t\t\t\tcout << fixed << setprecision(5) << ans << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse ans+=0.00001;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r, h;\n  double xl, xr, ans;\n  vector<int> V(41,0);\n  while(cin >> r >> n, r||n){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nint r,n,L,R,h,i,x;\n\nint main(){\n\t\n\twhile(cin>>r>>n,r){\n\n\t\t\n\t\tmap<int,int> A,B;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>L>>R>>h;\n\t\t\tfor(x=L;x<=R;x++){\n\t\t\t\tif(x!=R)A[x]=max(A[x],h);\n\t\t\t\tif(x!=L)B[x]=max(B[x],h);\n\t\t\t}\t\n\t\t}\n\t\tdouble res=99;\n\t\tfor(i=-r;i<=r-1;i++){\n\t\t\tres=min(res,min(r-sqrt(r*r-i*i)+A[i],r-sqrt(r*r-(i+1)*(i+1))+B[i+1]));\n\t\t}\n\t\tcout<<res<<\"\\n\";\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int r; //半径\n        int max=0;  //高さの最大値\n        int n;\n        cin >> r >> n;\n        int r_min = 0 - r; //半径のマイナス\n        double t=20.0;\n        int x_i[n],x_j[n],h[n];\n        for(int i=0;i<n;i++){\n            cin >> x_i[i] >> x_j[i] >> h[i];\n            if(max<h[i])    max=h[i];\n        }\n        int a[max][r+r];\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<max;j++){\n                for(int l=-r;l<r;l++){\n                    if(x_i[i]<=l && x_j[i]>l){\n                        if(h[i]>=j){\n                            a[j-1][l+r]++;\n                        }\n                    }\n                }\n            }\n        }\n        int count=0;\n        double u=0.0;\n        int min=10;\n        int h_a,x_a;\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                if(a[i][j]==0){\n                    if(j<r){\n                        if(min>i+(r-1)-j){\n                            min=i+(r-1)-j;\n                            h_a=i;\n                            x_a=(r-1)-j;\n                        }\n                    }else{\n                        if(min>i+j-r){\n                            min=i+j-r;\n                            h_a=i;\n                            x_a=j-r;\n                        }\n                    }\n                }\n            }\n        }\n        t=(double)r-sqrt(r*r-x_a*x_a)+(double)h_a;\n        printf(\"%.4f\",t);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<pi, int> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint p[50];\nint r, n;\n\nint C(double t){\n  for(int i=0;i<41;i++){\n    //    cout << x-r << \" \" << a.second << endl;\n    int x = i-20;\n    if(SQ((t-r)-p[i])+SQ(x)  < SQ(r)) return 0;\n  }\n  return 1;\n}\n\nint main()\n{\n  while(1){\n    cin >> r >> n;\n    if(r == 0 && n == 0) return 0;\n    memset(p, 0, sizeof(p));\n    int maxh = 0;\n    pii x[32];\n    rep(i, n){\n      cin >> x[i].first.first >> x[i].first.second >> x[i].second;\n      for(int j=x[i].first.first+1;j<x[i].first.second;j++) p[j+20] = max(p[j+20], x[i].second);\n      maxh = max(maxh, x[i].second);\n    }\n    sort(x, x+n);\n    rep(i, n-1){\n      if(x[i].first.second == x[i+1].first.first){\n\tp[x[i].first.second+20] = min(x[i].second, x[i+1].second);\n      }else{\n\t//\tp[x[i].first.second+20] = 0;\n\t//\tp[x[i+1].first.first+20] = 0;\n      }\n    }\n\n    //    rep(i, 10) cout << p[i+15] << \" \"; cout << endl;\n    double lb = 0.0, ub = maxh;\n    rep(i, 100){\n      double mid = (lb+ub)/2;\n      //      cout << mid << endl;\n      if(C(mid)) lb = mid;\n      else ub = mid;\n    }\n    printf(\"%.12f\\n\", lb);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int R, N;\n  while (cin >> R >> N && R + N ){\n    vector<int> LS(N);\n    vector<int> RS(N);\n    vector<int> HS(N);\n    \n    map<int, int> C[30];\n    \n    REP(i, N){\n      cin >> LS[i] >> RS[i] >> HS[i];\n      \n      REP2(j, LS[i], RS[i]){\n        REP(k, HS[i]){\n          C[k][j] = true;\n        }\n      }\n    }\n\n    // cout << C[3][0] << endl;\n    \n    vector<pair<int, int> > PS;\n    \n    REP2(x, -30, 30) REP(y, 25){\n      if (abs(x) >= R) continue;\n\n      bool ok = true;\n      REP(j, N) if (LS[j] < x && x < RS[j] && HS[j] > y){\n        ok = false;\n      }\n      \n      if (ok && (!C[y][x - 1] ||!C[y][x] || !C[y][x + 1])){\n        // cout << x << \" \" << y << endl;\n         PS.push_back(make_pair(x, y));  \n      }\n      \n    }\n    \n    double res = 1e9;\n    for (auto p : PS){\n      res = min(res, R + p.second - sqrt(R * R - p.first * p.first));\n      // cout << p.first << \" \" << p.second << \" \" << res << endl;\n    }\n    cout << fixed << setprecision(20) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\nint main(){\n\tint n,r;\n\twhile(scanf(\"%d%d\",&r,&n),n||r){\n\t\tdouble rr=r;\n\t\tvector<int> v1(2*r+1,0),v2(2*r+1,0);\n\t\trep(i,n){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\ta=max(a,-r);\n\t\t\tb=min(b,r);\n\t\t\treep(j,a,b+1){\n\t\t\t\tif(j-a){\n\t\t\t\t\tif(v1[j+r]==0){\n\t\t\t\t\t\tv1[j+r]=c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tv1[j+r]=max(v1[j+r],c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j-b){\n\t\t\t\t\tif(v2[j+r]==0){\n\t\t\t\t\t\tv2[j+r]=c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tv2[j+r]=max(v2[j+r],c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans=1e20;\n\t\treep(i,-r,r+1){\n\t\t\tint mx=1e8;\n\t\t\tif(r+i) mx=min(mx,v1[i+r]);\n\t\t\tif(r-i) mx=min(mx,v2[i+r]);\n\t\t\tans=min(ans,mx+rr-sqrt(rr*rr-pow(abs(i),2)));\n\t\t}\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n#define all all(v) v.begin(),v.end()\n#define INF i<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\n\ntypedef long long ll;\n\n#define EPS (1e-10)\n\nclass Point {\n\tpublic:\n\tdouble x,y;\n\n\tPoint(double x = 0, double y = 0): x(x),y(y){}\n\n\tPoint operator + (Point P) { return Point(x+P.x, y+P.y);}\n\tPoint operator - (Point P) { return Point(x-P.x, y-P.y);}\n\tPoint operator * (double a) { return Point(a*x, a*y);}\n\tPoint operator / (double a) { return Point(x/a, y/a);}\n\n\tdouble abs_() { return sqrt(norm());}\n\tdouble norm() { return x*x+y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ndouble dot(Point a, Point b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a, Point b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif(cross(a,b) > EPS) return 1;\n\tif(cross(a,b) < -EPS) return -1;\n\tif(dot(a,b) < -EPS) return 2;\n\tif(a.norm() < b.norm() ) return -2;\n\n\treturn 0;\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon andrewScan( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3) return s;\n\tsort(s.begin(),s.end());\n\n\tu.pb(s[0]);\n\tu.pb(s[1]);\n\n\tfor(int i=2; i< s.size(); i++){\n\t\tfor(int n = u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i]) != -1; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\n\treturn u;\n}\n\nint main(){\n\twhile(1){\n\t\tint r;\n\t\tint n;\n\t\tPolygon pv;\n\t\tcin >> r >> n;\n\t\tif(r==0) break;\n\n\t\tmap<int,pii> mv;\n\n\t\trep(i,n){\n\t\t\tint xr,xl,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tmv[xl].se = max(h,mv[xl].se);\n\t\t\tfor(int nx = xl+1;nx<xr;nx++){\n\t\t\t\tmv[nx].fi = max(h,mv[nx].fi);\n\t\t\t\tmv[nx].se = max(h,mv[nx].se);\t\t\n\t\t\t}\n\t\t\tmv[xr].fi = max(h,mv[xr].fi);\n\t\t\t/*\n\t\t\tpv.pb(Point(xl,0));\n\t\t\tpv.pb(Point(xr,0));\n\t\t\tpv.pb(Point(xl,h));\n\t\t\tpv.pb(Point(xr,h));\n\t\t\tif(xl < 0 && 0 < xr){\n\t\t\t\tpv.pb(Point(0,h));\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tmv[-r-1].fi = mv[-r-1].se;\n\t\tmv[r+1].se = mv[r+1].fi;\n\n\t\t// cout<<\"=======\"<<endl;\n\t\tfor(int i=-20;i<=20;i++){\n\t\t\t\n\t\t\t// cout << min(mv[i].fi,mv[i].se) << endl;\n\t\t\tpv.pb(Point(i,min(mv[i].fi,mv[i].se)));\n\t\t}\n\t\t// cout<<\"=======\"<<endl;\n\n/*\n\t\tfor(int i=-20;i<21;i++){\n\t\t\tpv.pb(Point(i,min(mv[i],mv[i+1])));\n\t\t}\n\n\t\tcout<<\"-----------\"<<endl;\n\t\trep(i,pv.size()){\n\t\t\tif(pv[i].y!=23)cout<<pv[i].x<<\" \"<<pv[i].y<<endl;\n\t\t}\n\t\tcout<<\"--------\"<<endl;\n*/\n\n\t\tfor(double t = 0; t<=20;t+=0.00001){\n\t\t\tPoint c = Point(0,-r+t);\n\t\t\trep(i,pv.size()){\n\t\t\t\tif((c-pv[i]).abs_()<=r){\n\t\t\t\t\t// cout<<(c-pv[i]).abs_()<<endl;\n\t\t\t\t\tprintf(\"%lf\\n\",t);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\t/*\n\t\t// Polygon pt;\n\t\t// pt = andrewScan(pv);\n\t\t// rep(i,pv.size()){\n\t\t// \tcout << \"pv :\" << pv[i].x << \" \"<< pv[i].y << endl;\n\t\t// }\n\n\t\trep(i,pt.size()){\n\t\t\tcout << \"pt :\" << pt[i].x << \" \"<< pt[i].y << endl;\n\t\t}\n*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nsigned main() {\n    int R, N;\n    while(cin >> R >> N, R) {\n        int x[50] = {};\n        int *a = x + 25;\n\n        rep(i,0,N) {\n            int xl, xr, h; cin >> xl >> xr >> h;\n            repq(k,xl+1,xr) chmax(a[k], h);\n        }\n\n        double ans = INF;\n        repq(k,-R+1, R) {\n            int x = min(abs(k-1), abs(k));\n            double val = a[k] + R - sqrt(R*R - x*x);\n            chmin(ans, val);\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nbool EQ(double a, double b) { return abs(a - b) < EPS; }\n\ndouble getHeight(double r, double x) {\n\treturn sqrt(r * r - x * x);\n}\n\nint main(void) {\n\tint r, n;\n\twhile(scanf(\"%d %d\", &r, &n), r > 0) {\n\t\tint left[20], right[20], height[20];\n\t\tfor(int i = 0; i < n; i++) scanf(\"%d %d %d\", left + i, right + i, height + i);\n\t\tvector<double> xs;\n\t\tconst double GAPEPS = 1e-7;\n\t\txs.push_back(-r + GAPEPS);\n\t\txs.push_back(r - GAPEPS);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble cand = left[i] - GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = left[i] + GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] - GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] + GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t}\n\n\t\tdouble s = 0, e = 100;\n\t\tfor(int lv = 0; lv < 100; lv++) {\n\t\t\tdouble mid = (s + e) / 2;\n\t\t\tbool isAble = true;\n\n\t\t\tfor(double x: xs) {\n\t\t\t\tbool isIncluded = false;\n\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t\tif(left[i] <= x and x <= right[i] and height[i] >= getHeight(r, x) - r + mid) {\n\t\t\t\t\t\tisIncluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tif(!isIncluded) {\n\t\t\t\t\tisAble = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isAble) s = mid;\n\t\t\telse e = mid;\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\", s);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=(-x-0.9999),R=(x+0.9999),hb[101]={};\n\n  for(int i=L+50;i<R+50;i++){\n    int x1=i-49-i/50;\n    double y1=y[i]-cy;\n    if(sqrt(x1*x1+y1*y1)>=r)hb[i]++;\n  }\n  for(int i=L+50;i<R+50;i++)if(!hb[i])return 0;\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<100;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.0009;\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\tint r, n;\n\twhile(cin >> r >> n) {\n\n\t\tif(r == 0 && n == 0) break;\n\n\t\tvector<pair<P, int> > v(n);\n\t\trep(i, n) cin >> v[i].first.first >> v[i].first.second >> v[i].second;\n\n\t\tsort(v.begin(), v.end());\n\t\tmap<int, int> m;\n\t\tvector<P> p;\n\t\tdouble ans = 0;\n\n\t\trep(i, n) {\n\t\t\tint x1 = v[i].first.first, x2 = v[i].first.second, h = v[i].second;\n\n\t\t\tif(x1 <= -r && r <= x2) {\n\t\t\t\tans = max(ans, (double)h);\n\t\t\t}\n\n\t\t\tif(abs(x1) <= r) p.push_back(P(x1, h));\n\t\t\tif(abs(x2) <= r) p.push_back(P(x2, h));\n\n\t\t\tREP(j, i+1, n) {\n\t\t\t\tint x3 = v[j].first.first, x4 = v[j].first.second, h2 = v[j].second;\n\t\t\t\tif(x1 <= x3 && x3 <= x2 && abs(x3) <= r) {\n\t\t\t\t\tm[x3] = max(m[x3], h);\n\t\t\t\t}\n\n\t\t\t\tif(x3 <= x2 && x2 <= x4 && abs(x2) <= r) {\n\t\t\t\t\tm[x2] = max(m[x2], h2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble res = 0;\n\n\t\tif(m.size() > 0) {\n\t\t\tres = INF;\n\n\t\t\tmap<int, int>::iterator ite;\n\t\t\tfor(ite = m.begin(); ite != m.end(); ite++) {\n\t\t\t\tint x = ite->first, y = ite->second;\n\t\t\t\tdouble d = r + y;\n\t\t\t\tres = min(res, d - sqrt(r*r - x*x));\n\t\t\t}\n\n\t\t\trep(i, p.size()) {\n\t\t\t\tint x = p[i].first, y = p[i].second;\n\t\t\t\tdouble d = r + y;\n\t\t\t\tres = min(res, d - sqrt(r*r - x*x));\n\t\t\t}\n\t\t}\n\n\t\tcout << fixed;\n\t\tcout.precision(4);\n\t\tcout << max(ans, res) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,n){\n\t\tdouble l=-R,r;\n\t\tint ma=0;\n\t\tvi in(50,0);\n\t\twhile(n--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tma=max(ma,c);\n\t\t\tloop(i,a,b)in[i+25]=max(in[i+25],c);\n\t\t}\n\t\tr=ma-R;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tbool q=true;\n\t\t\tloop(i,1,50){\n\t\t\t\tdouble dis=hypot(min(in[i],in[i-1])-h,i-25);\n//\t\t\t\tcout<<i-25<<\" \"<<dis<<endl;\n\t\t\t\tif(min(in[i],in[i-1])<h-R||dis+EPS<(double)R)q=false;\n\t\t\t}\n\t\t\tif(q)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.8f\\n\",l+R);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\nconst int CENTER = 30;\nint n, r;\nint h[60];\n\nbool check(double m) {\n\tfor(int i = 0; i <= r - 1; i++) {\n\t\tdouble sh = -r + m + sqrt(r * r - i * i);\n\t\tif(sh < 0) continue;\n\t\tif(h[CENTER + i] < sh) return false;\n\t}\n\tfor(int i = -r; i <= -1; i++) {\n\t\tdouble sh = -r + m + sqrt(r * r - (i + 1) * (i + 1));\n\t\tif(sh < 0) continue;\n\t\tif(h[CENTER + i] < sh) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> r >> n, n | r) {\n\t\tfor(int i = 0; i < 60; i++) {\n\t\t\th[i] = 0.0;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint xl, xr, hh;\n\t\t\tcin >> xl >> xr >> hh;\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\th[CENTER + j] = max(h[CENTER + j], hh);\n\t\t\t}\n\t\t}\n\t\tcheck(4.0);\n\t\tdouble ok = 0, ng = 100;\n\t\tfor(int loop = 0; loop < 100; loop++) {\n\t\t\tdouble m = (ok + ng) / 2.0;\n\t\t\tif(check(m)) ok = m;\n\t\t\telse ng = m;\n\t\t}\n\n\t\tcout << fixed << setprecision(4) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> a(82);\nlong long r, n;\nint fl(int x) { return x + 40; }\nint fr(int x) { return x + 41; }\nbool g(double t) {\n  for (int i = -r; i < r; i++) {\n    if (a[fr(i)] < sqrt(r * r - i * i) + t - r) {\n      return false;\n    }\n  }\n  for (int i = -r + 1; i <= r; i++) {\n    if (a[fl(i)] < sqrt(r * r - i * i) + t - r) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  while (true) {\n    cin >> r >> n;\n    if (r == 0)\n      break;\n    for (int i = 0; i < 82; i++)\n      a[i] = 0;\n    for (int i = 0; i < n; i++) {\n      int b, c, h;\n      cin >> b >> c >> h;\n      for (int j = fr(b); j <= fl(c); j++) {\n        a[j] = max(a[j], (double)h);\n      }\n    }\n    double tmin = 0, tmax = 1000;\n    for (int l = 0; l < 3000; l++) {\n      double t = (tmin + tmax) / 2;\n      if (g(t)) {\n        tmin = t;\n      } else {\n        tmax = t;\n      }\n    }\n    printf(\"%.9lf\\n\", tmin);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\n    for(int R, N; cin >> R >> N, R;){\n        map<int, int>H;\n        for(int i = 0; i < N; i++){\n            int l, r, h;\n            cin >> l >> r >> h;\n            for(int x = l; x < r; x++){\n                H[x] = max(H[x], h);\n            }\n        }\n        double ans = 1234567;\n        for(int X = -R; X < R; X++){\n            int x = X;\n            if(X < 0)x = X + 1;\n            double h = sqrt(R * R - x * x);\n            ans = min(ans, H[X] + (R - h));\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r;\n  while(cin >> r >> n, n){\n    vector<double> V(2*r+1,0);\n    double xl, xr, h;\n    double ans = 1e9;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(abs(i+1-r) <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// H[i] := xの区間が[i, i + 1]での建物シルエットの最大の高さ\n// [i, i+1]に建物が何もないなら、H[i] = 0\n// t秒後に、円の中心は(0, -r + t)\n// \n// xの区間が[i, i + 1]で、太陽が露出される時間は、\n//  min( H[i] - sqrt(r*r - i*i), H[i] - sqrt(r*r - (i+1)*(i+1)) ) + r \n// これを、xの区間が[-r, -r + 1], .... , [r-1, r]で露出される時間を調べて、\n// その最小値を調べるとそれが答え？\n\n// [0, 1]と[1, 2]で、高さが違う場合(H[0] != H[1])\n\n// H[i] は 0で初期化\n// for(int i = xl; i < xr; ++i) H[i] = max(H[i], h)\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int r,n;\n    while(cin >> r >> n, r|n){\n        int h[45] = {};\n\n        for(int i = 0; i < n; i++){\n            int xl,xr,hi; cin >> xl >> xr >> hi;\n            for(int j = xl+20; j < xr+20; j++){\n                h[j] = max(h[j],hi);\n            }\n        }\n        /*\n        for(int j = -5+20; j < 5+20; j++){\n            cout << h[j] << \" \";\n        }\n        */\n\n        double ans = 100.00;\n        for(int i = -r+20; i < r+20; i++){\n            double X = i - 20;\n            ans =  min(ans, min(h[i]-sqrt(r*r-X*X)+r, h[i]-sqrt(r*r-(X+1)*(X+1))+r));\n        }   \n\n        cout << fixed << setprecision(10) <<  ans << \"\\n\";\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble h[55];\nint main(){\n    double r;\n    int n;\n    while(cin>>r>>n,(int)r|n){\n        int xl,xr;\n        double hi;\n        memset(h,0,sizeof(h));\n        rep(i,n){\n            cin>>xl>>xr>>hi;\n            xl+=25,xr+=25;\n            FOR(j,xl,xr) h[j]=max(hi,h[j]);\n        }\n        double mn=1000100010;\n        FOR(i,25-r,25+r){\n            double dx=min(abs(i-25),abs(i-24));\n            mn=min(mn,h[i]-sqrt(r*r-dx*dx)+r);\n        }\n        cout<<fixed<<setprecision(12)<<mn<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this); \n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto dist = distance_lp(l, c);\n  if(dist > c.r + EPS) { return {{-inf,-inf},{-inf,-inf}}; }\n  auto basehalf = sqrt(c.r * c.r - dist * dist);\n  P v = (l[1]-l[0]) * P(0, 1);\n  Line h(c, c+v); P ph = crosspoint(l, h);\n  P u1 = (ph + v) * P(0, 1); u1 /= abs(u1); u1 *= basehalf;\n  P u2 = (ph + v) * P(0, -1); u2 /= abs(u2); u2 *= basehalf;\n  return {u1, u2};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  for(int R, N; cin >> R >> N && (R | N);) {\n    vector<int> hs(44); int const OF = 22;\n    rep(i, N) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      REP(x, xl, xr) {\n        maximize(hs[x+OF], h);\n      }\n    }\n    vector<P> events;\n    int currh = 0;\n    events.emplace_back(-22, 0);\n    REP(x, -21, 22) {\n      if(currh != hs[x+OF]) {\n        events.emplace_back(x, currh);\n        currh = hs[x+OF];\n        events.emplace_back(x, currh);\n      }\n      else {\n        events.emplace_back(x, currh);\n      }\n    }\n\n//    for(auto && e: events) { cout << e << endl; } cout << endl;\n\n    Circle c(P(0, -R), R);\n\n    Real ok = 0.0;\n    Real ng = 100000.0;\n\n    auto compare = [&](Real t) {  // ???????¢????????¶??????????NG(?????????OK)\n      bool ret = 1;\n      c.cent[1] += t;\n      rep(i, events.size()) {\n        if(abs(c - events[i]) < c.r || (-R+EPS < events[i].real() && events[i].real() < R-EPS && events[i].imag() < c.cent[1])) { ret = 0; }\n      }\n      c.cent[1] -= t;\n      return ret;\n    };\n    \n    rep(i, 100) {\n      Real mid = (ok + ng) / 2.0;\n      (compare(mid) ? ok : ng) = mid;\n    }\n\n    printf(\"%.10f\\n\", ok);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<int, int> pii;\ndouble GetPos(point x, double r){\n  if(abs(x.real()) > r)return 1e9;\n  double maxi = x.imag(), mini = -1000, med = (maxi + mini)/2;\n            \n  while(maxi - mini > 1e-9){\n    point p = point(0, med);\n    if(abs(x - p) < r){\n      maxi = med;\n    }else{\n      mini = med;      \n    }\n    med = (maxi + mini)/2;\n  }\n  return maxi;\n}\nint main(int argc, char *argv[]){\n  int r, n;\n  while(std::cin >> r >> n, n){\n    vector<point> corner;\n    double ans = 1e9;\n    vector<pii> begin, end;\n    for (int i = 0; i < n; i++) {\n      int b, e, h;\n      std::cin >> b >> e >> h;\n      corner.push_back(point(b, h));\n      corner.push_back(point(e, h));\n      begin.push_back(pii(b, -h));\n      end.push_back(pii(e, -h));\n    }\n    sort(begin.begin(), begin.end());\n    sort(end.begin(), end.end());\n    int bpos = 0, epos = 0;\n    if(begin[0].first > -r || end[n - 1].first < r)ans = 0;\n    int sum = 0;\n    for (int i = 0; i < 2*begin.size() - 2; i++) {\n      if(begin[bpos].first > end[epos].first)ans = -r;\n      int hight = min(-begin[bpos].second, -end[epos].second);\n      if(i%2){\n        if(end[epos].first == end[epos + 1].first)continue;\n        //std::cout << point(end[epos].first, hight) << std::endl;\n        corner.push_back(point(end[epos].first, hight));\n        epos++; \n      }else{\n        bpos++;\n        if(begin[bpos].first == begin[bpos - 1].first)continue;\n        //std::cout << point(begin[bpos].first, hight) << std::endl;\n        corner.push_back(point(begin[bpos].first, hight));\n      }\n    }\n    for (point i: corner){\n      //std::cout << corner[i] << std::endl;\n      ans = min(ans, GetPos(i, r));\n      //std::cout << ans << std::endl;\n    }\n    std::cout << setprecision(12) << ans + r << std::endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\ndouble solve(int r,int n){\n  bool box[21][41] {{false}};\n  rep(i,n) {\n    int li,ri,hi;\n    cin >> li >> ri >> hi;\n\n    rep(y,hi) {\n      for(int x=li+20;x<ri+20;++x){\n        box[y][x]=true;\n      }\n    }\n\n  }\n  double ans=(double)1e9;\n  rep(y,21){\n    for(int x=20-r;x<r+20;x++) if(!box[y][x]){\n      double time;\n      if(x<20) time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n      else time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n      ans=min(ans,time);\n    }\n  }\n  return ans;\n}\n\nint main(int argc, char *argv[])\n{\n  int r,n;\n  while(cin>>r>>n,r&&n){\n    printf(\"%.4lf\\n\",solve(r,n));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n\nusing namespace std;\n\nclass Solver {\n};\n\n\tint main() {\n\t\twhile (true) {\n\t\t\tint r, n;\n\t\t\tcin >> r >> n;\n\t\t\tif (r == 0)break;\n\n\t\t\tvector<vector<int>> ranges(n, vector<int>(3, 0));\n\t\t\tvector<int> heights(50, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l, r, h;\n\t\t\t\tcin >> l >> r >> h;\n\t\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\t\theights[25 + j] = max(heights[25 + j], h);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<double> times(50, 0);\n\t\t\tdouble res = 500;\n\t\t\tfor (int i = -r; i < r; i++) {\n\t\t\t\tint near = min(abs(i), abs(i + 1));\n\t\t\t\tdouble height = heights[25 + i] + r - sqrt(r * r - near * near);\n\t\t\t\tres = min(res,height);\n\t\t\t}\n\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> point;\n\nint main(int argc, char *argv[]){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, n){\n    vector<int> hl(50, 0), hr(50, 0);\n    hl[r + diff] = hr[-r + diff] = 1e9;\n    for (int i = 0; i < n; i++) {\n      int xr, xl, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl + 1; j < xr; j++) {\n        hl[j + diff] = hr[j + diff] = h;\n      }\n      hl[xl + diff] = hr[xr + diff] = h;\n    }\n    double ans = 1e9;\n    for (int i = -r; i <= r; i++) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-6\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tR -= eps;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-12;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nint main()\n{\n\tint r, n;\n\twhile (cin >> r >> n, r)\n\t{\n\t\tvector<vector<int>> build(50,vi(50));\n\t\tint L = 25 - r, R = 25 + r;\n\n\t\tREP(i, n)\n\t\t{\n\t\t\tint l, r, h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tl += 25; r += 25;\n\n\t\t\tFOR(i, l, r)\n\t\t\t{\n\t\t\t\tREP(j, h) build[i][j] = 1;\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tFOR(i, L + 1, R)\n\t\t{\n\t\t\tint j;\n\t\t\tfor (j = 0;; j++)\n\t\t\t{\n\t\t\t\tif (build[i][j] != 1 || build[i-1][j] != 1) break;\n\t\t\t}\n\t\t\tdouble k = abs(i - 25);\n\t\t\tdouble tmp = sqrt(r*r - k*k);\n\t\t\ttmp = r - tmp;\n\t\t\t//cout << j - tmp << endl;\n\t\t\tans = chmin(ans, max(j+tmp, 0.0));\n\t\t}\n\t\tcout << D10 << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<limits>\n#include<iomanip>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n\n\nint main(){\n    while(1){\n    cout<<fixed<<setprecision(12);\n    int r,n;\n    vector<int> v(200);\n    cin>>r>>n;\n        if(r==0 && n==0){break;}\n    for(int i=0;i<n;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        for(int t=100+a;t<100+b;t++){\n            v[t]=max(v[t],c);\n        }\n    }\n    double mi=1e9;\n    for(int i=100-r+1;i<100+r;i++){\n        int h=min(v[i],v[i-1]);\n        mi=min(mi,(double)h+r-sqrt(r*r-(100-i)*(100-i)));\n    }\n    mi=min(mi,(double)v[100-r]+r);\n    mi=min(mi,(double)v[100+r-1]+r);\n    cout<<mi<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int r; //半径\n        int max=0;  //高さの最大値\n        int n;\n        cin >> r >> n;\n        int r_min = 0 - r; //半径のマイナス\n        double t=20.0;\n        int x_i[n],x_j[n],h[n];\n        for(int i=0;i<n;i++){\n            cin >> x_i[i] >> x_j[i] >> h[i];\n            if(max<h[i])    max=h[i];\n        }\n        int a[max][r+r];\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<max;j++){\n                for(int l=-r;l<r;l++){\n                    if(x_i[i]<=l && x_j[i]>l){\n                        if(h[i]>=j){\n                            a[j-1][l+r]++;\n                        }\n                    }\n                }\n            }\n        }\n        int count=0;\n        double u=0.0;\n        int min=10;\n        int h_a,x_a;\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                if(a[i][j]==0){\n                    if(j<r){\n                        if(min>i+(r-1)-j){\n                            min=i+(r-1)-j;\n                            h_a=i;\n                            x_a=(r-1)-j;\n                        }\n                    }else{\n                        if(min>i+j-r){\n                            min=i+j-r;\n                            h_a=i;\n                            x_a=j-r;\n                        }\n                    }\n                }\n            }\n        }\n        t=(double)r-sqrt(r*r-x_a*x_a)+(double)h_a;\n        printf(\"%.4f\",t);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n#define px 20\n\nint main() {\n\n  while( true ) {\n\n    long long int r, n;\n    cin >> r >> n;\n    if ( r == 0 ) break;\n\n    long long int dy[50][2] = {};\n\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int minx, maxx, h;\n      cin >> minx >> maxx >> h;\n      minx += px;\n      maxx += px;\n      for ( long long int j = minx; j < maxx; j++ ) {\n\tdy[j][1] = h;\n\tdy[j+1][0] = h;\n      }\n    }\n    \n    double ans = 50.0;\n\n    for ( long long int i = px - r + 1; i < px + r; i++ ) {\n      double x = i - px;\n      double y = sqrt( r * r - x * x );\n      ans = min( ans, dy[i][0] - y + r );\n      ans = min( ans, dy[i][1] - y + r );\n    }\n    ans = min( ans, 0.0 + dy[px-r][1] + r );\n    ans = min( ans, 0.0 + dy[px+r][0] + r );\n    cout << fixed << setprecision(10) << ans << endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint idx(int n){\n    if(n<0) return 20-n;\n    else return n;\n}\n\nbool isArive(vector<int>& w, int r, int time){\n    for(int i=-r+1; i<r; i++){\n        if(sqrt(r*r-i*i)-r+time/1e5 > w[idx(i)]){\n            return false;\n        }\n    }\n    return true;\n}\n\nint bin_search(vector<int>& w, int r, int imin, int imax){\n    if(imax <= imin){\n        return imax;\n    }else{\n        int imid = (imax+imin)/2;\n        if(isArive(w, r, imid)){\n            return bin_search(w, r, imid+1, imax);\n        }else{\n            return bin_search(w, r, imin, imid-1);\n        }\n    }\n}\n\n\nint main(){\n    while(1){\n        int r,n;\n        cin >> r >> n;\n        if(r==0) break;\n\n        vector<int> wall(41, 0); //(int coordinates)\n        for(int i=0; i<n; i++){\n            int xl,xr,h;\n            cin >> xl >> xr >> h;\n            for(int j=xl; j<xr; j++){\n                wall[idx(j)] = max(wall[idx(j)], h);\n            }\n        }\n        for(int i=19; i>=-19; i--){\n            wall[idx(i)] = min(wall[idx(i-1)], wall[idx(i)]);\n        }\n\n        int dmsec = bin_search(wall, r, 0, 40*1e5);\n        cout << fixed;\n        cout << setprecision(5);\n        cout << dmsec/1e5 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint R, N; \nint x1,x2,h;\nint B[50];\ndouble ans = 10000.0;\n\ndouble b(double x) {\n\treturn (double) B[(int) (x + 25.0)];\n\t\n}\n\ndouble sun(double x) {\n\tdouble r = R;\n\treturn sqrt(r * r - x * x) - r;\n}\n\ndouble f(double x) {\n\treturn b(x) - sun(x);\n}\n\nint main() {\n\tcin >> R >> N;\n\twhile(R + N) {\n\t\tans = 10000000.0;\n\t\tfor (int i = 0; i < 50; i ++) {\n\t\t\tB [i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x1 >> x2 >> h;\n\t\t\tx1 += 25;\n\t\t\tx2 += 25;\n\t\t\tfor (int x = x1; x < x2; x++ ) {\n\t\t\t\tB[x] = max(B[x], h);\n\t\t\t}\n\t\t}\n\t\tdouble r = R;\n\t\tfor (double x = -r; x < r; x += 0.00001) {\n\t\t\tans = min(ans, f(x));\n\t\t}\n\t\tprintf(\"%f\\n\",ans);\n\t\t\n\t\tcin >> R >> N;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ndouble min(double a,double b){return a<b?a:b;}\nint main(){\n  int r,n;\n  while(cin>>r>>n,r+n){\n    vi in(50);//25=center\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      loop(i,a,b)in[25+i]=max(in[25+i],c);\n    }\n    double out=1e9;\n    for(int i=25-r+1;i<25+r;i++){\n      int t=min(in[i],in[i-1]);\n      double tim=t-sqrt(r*r-(25-i)*(25-i));\n      out=min(tim,out);\n    }\n    printf(\"%.9f\\n\",out+r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nbool kage[41][21];\n\nint main(){\n\tint n,r;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r+n==0)break;\n\t\tmemset(kage,false,sizeof(kage));\n\t\tREP(i,n){\n\t\t\tint x1,x2,h;\n\t\t\tcin>>x1>>x2>>h;\n\t\t\tfor(int x=x1+20;x<x2+20;x++){\n\t\t\t\tfor(int y=0;y<h;y++){\n\t\t\t\t\tkage[x][y]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool w=false;\n\t\tdouble ans=0.0;\n\t\tREP(i,21){\n\t\t\tint c=0;\n\t\t\twhile(kage[20+c][i]&&kage[19-c][i])c++;\n\t\t\tif(c==0)break;\n\t\t\tif(c>=r){\n\t\t\t\tans=(double)(i+1);\n\t\t\t}else{\n\t\t\t\tdouble res=(double)(r)-sqrt((double)(r*r)-(double)(c*c));\n\t\t\t\tif(w){\n\t\t\t\t\tans=min((double)i+res,ans);\n\t\t\t\t}else{\n\t\t\t\t\tans+=res;\n\t\t\t\t\tw=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6f\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n    int r,n;\n    int i,j,k;\n    int xl,xr,h;\n    int b[40][21];\n    double min,d;\n    while(1){\n        cin >> r >> n;\n        if(r == 0) break;\n        for(i = 0;i < 40;i++){\n            for(j = 0;j < 21;j++){\n                b[i][j] = 0;\n            }\n        }\n        for(i = 0;i < n;i++){\n            cin >> xl >> xr >> h;\n            xl += 20;\n            xr += 20;\n            for(j = xl;j < xr;j++){\n                for(k = 0;k < h;k++){\n                    b[j][k] = 1;\n                }\n            }\n        }\n        min = 10000;\n        for(i = -r+1;i < r;i++){\n            for(j = 0;j < 21;j++){\n                if(b[i+19][j] == 0 || b[i+20][j] == 0){\n                    d = j+r-sqrt(r*r-i*i);\n                    if(min > d) min = d;\n                }\n            }\n        }\n        cout << min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n#define EPS 1e-9\nint H[50];\ndouble SH[50];\nint r;\nbool ok(double t){\n  for(int d=20-r;d+1<=20+r;++d){\n    double sh1 = SH[d]-r+t;\n    double sh2 = SH[d+1]-r+t;\n    double sh = max(sh1,sh2);\n    if(sh > H[d]) return false;\n  }\n  return true;\n}\nint main(){\n  int n;\n  while(cin>>r>>n , r||n){\n    for(int d=-r;d<=r;++d){\n      SH[d+20]=sqrt(r*r-d*d);\n    }\n    for(int i=0;i<50;++i) H[i]=0;\n    while(n--){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;      \n      x1+=20;x2+=20;\n      for(int j=x1;j+1<=x2;++j) H[j]=max(H[j],h);\n    }\n    double a=0,b=50;\n    for(int i=0;i<50;++i){\n      double t = (a+b)/2.0;\n      if(ok(t)) a=t;\n      else b=t;\n    }\n    printf(\"%lf\",(a+b)/2);\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n//#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tint r, n;\n\twhile (cin >> r >> n && r) {\n\t\tV height(r * 2);\n\t\trep(i, n) {\n\t\t\tint lx, rx, h; cin >> lx >> rx >> h;\n\t\t\tlx += r;\n\t\t\trx += r;\n\t\t\tREP(i, max(0, lx), min(r * 2, rx)) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = r * 2;\n\t\trep(x, r * 2) {\n\t\t\tint h = height[x];\n\t\t\tdouble a = sqrt(r * r - pow(abs(r - x) - (r - x > 0), 2));\n\t\t\tdouble sun = (double)(h + r) - a;\n\t\t\tans = min(ans, sun);\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\n\nfloat solve(int r, vector<array<int, 3>>& vs)\n{\n    std::array<int, 41> imos;\n    for(auto& e: imos) e = 0;\n\n    for(auto& e: vs){\n        imos[e[0] + 20] += 1;\n        imos[e[1] + 20] += -1;\n    }\n\n    int s = 0;\n    for(auto& e: imos){\n        s += e;\n        e = s;\n    }\n\n    int maxL = 0, maxR = 0;\n    for(int i = 0; i <= 20; ++i){\n        if(imos[i+20] == 0)\n            break;\n        maxL = i + 1;\n    }\n    for(int i = 0; i >= -20; --i){\n        if(imos[i+20] == 0)\n            break;\n        maxR = -i;\n    }\n\n    // for(auto&e : imos)\n    //     cout << e << \", \";\n    // cout << endl << \"maxL: \" << maxL << \", maxR: \" << maxR << endl;\n\n    int width = (maxL < maxR ? maxL : maxR) * 2;\n    // if(width != 0) width -= 1;\n    if(width == 0) return 0;\n    if(width > r)\n        width = r*2;\n\n    // cout << width << endl;\n\n    int wh = width / 2;\n    float whf = wh;\n\n    float hd = r - sqrt(r*r - whf*whf);\n    if(!(hd > 0)) hd = 0;\n\n    std::array<int, 41> maxH;\n    for(auto& e: maxH) e = 0;\n    for(auto& e: vs){\n        for(int i = -20; i <= 20; ++i)\n            if(e[0] <= i && i < e[1]){\n                if(maxH[i+20] < e[2])\n                    maxH[i+20] = e[2];\n            }\n    }\n\n\n\n    float max = 0;\n    for(int i = -wh; i <= wh; ++i){\n        auto hh = sqrt(r*r - i*i);\n        if(maxH[i+20] < hh && max < (hh - maxH[i+20])){\n            max = hh - maxH[i+20];\n        }\n    }\n\n    // cout << \"max: \" << max << endl;\n    // cout << \"hd: \" << hd << endl;\n\n    // for(auto&e : maxH)\n    //     cout << e << \", \";\n    // cout << endl;\n\n    if(max == 0){\n        float mm = 1024, ret = 0;\n        for(int i = -wh; i <= wh; ++i){\n            float rm1 = maxH[i+20] - sqrt(r*r - (i+1)*(i+1));\n            float rm2 = maxH[i+20] - sqrt(r*r - i*i);\n            float rm = rm1 < rm2 ? rm1 : rm2;\n            // cout << \"i: \" << i << \", rm1: \" << rm1 << \", rm2: \" << rm2 << endl;\n            if(maxH[i+20] != 0 && mm > rm){\n                mm = rm;\n                ret = rm + whf;\n            }\n        }\n\n        // cout << \"mm: \" << mm << endl;\n        return ret;\n    }\n\n    return hd - max;\n}\n\n\nint main(void)\n{\n    int r, n;\n    while(cin >> r >> n){\n        if(r == 0 && n == 0)\n            break;\n\n        vector<array<int, 3>> vs;\n        for(int i = 0; i < n; ++i){\n            array<int, 3> arr;\n            cin >> arr[0] >> arr[1] >> arr[2];\n            vs.push_back(arr);\n        }\n\n        cout << fixed << setprecision(4) << solve(r, vs) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tdouble r;\n\t\tdouble center;\n\t\tdouble high;\n\t\tdouble answer = 20.0;\n\t\tint n;\n\t\tdouble xl[21] = {}, xr[21] = {}, h[21] = {};\n\n\t\tcin >> r >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t}\n\n\n\t\tfor (double i = 0; i <= 20.0; i += 0.0001) {\n\t\t\tcenter = -r + i;\n\n\t\t\tfor (double j = -r; j <= r; j += 0.001) {\n\t\t\t\thigh = sqrt(r*r - j * j) + center;\n\n\t\t\t\t//cout << center << \" \" << high << endl;\n\n\t\t\t\tFOR(k, 1, n) {\n\t\t\t\t\tif (xl[k] <= j && xr[k] >= j && high <= h[k]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (high <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (k == n) {\n\t\t\t\t\t\tanswer = i - 0.0001;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (answer != 20.0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (answer != 20.0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\", answer);\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS) return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nvoid vis2(P p){\n\tprintf(\"plot(%.5lf,%.5lf,0)\\n\",p.real(),p.imag());\n}\nint test(vector<G> &g,double t,double r){\n\tr -= 1e-4;\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(0);\n\tchkPoint.push_back(PI/2.);\n\tchkPoint.push_back(3*PI/2.);\n\tchkPoint.push_back(2*PI/2.);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tx = x - c.p;\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"cir(\" << c.p.real() << \",\" << c.p.imag() << \",\" << r << \")\" << endl;\n\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tP p1 = c.p+r*P(cos(th+1e-4),sin(th+1e-4));\n\t\t\tP p2 = c.p+r*P(cos(th-1e-4),sin(th-1e-4));\n\t\t\t//vis2(p1);\n\t\t\t//vis2(p2);\n\t\t\t//vis2(pp);\n\t\t\tif( contains(g[j],pp) && contains(g[j],p1) != OUT && contains(g[j],p2) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if(flag) vis2(pp);\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nvoid vis(G g){\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tcout << \"line(\" << curr(g,i).real() << \",\" << curr(g,i).imag() << \",\" << next(g,i).real() << \",\" << next(g,i).imag() << \")\" << endl;\n\t}\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\t//g.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl-1e-4,0},{xr+1e-4,0},{xr+1e-4,h},{xl-1e-4,h}});\n\t\t\t//vis(g[i]);\n\t\t}\n\t\t\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, R;\nbool fie[55][55];\nint dx[]={0,1,0};\nint dy[]={-1,0,1};\nbool used[55][55];\ntypedef complex<double> P;\nconst double EPS = 1e-8;\nbool check(int x,int y,int d){\n  if( 0 <= x && x <= 44 && 0 <= y && y <= 44 ){\n    if(!used[x][y]){\n      if( d == 0 ) return !fie[x-1][y] || !fie[x][y];\n      else if( d == 1 ) return !fie[x-1][y];\n      else return true;\n    }\n  }\n  return false;\n}\n\ndouble solve( P p,const vector<P>& ep ){\n  double x = abs(p.real()-22);\n  if( (int)x > R ) return -R;\n  P v = P(22, p.imag() - sqrt(R*R - x*x) );  \n  for(int i=0;i<(int)ep.size();i++){\n    if( (double)R - EPS > abs( ep[i] - v ) ) return -R;\n    if( ep[i].real() == 22 && ep[i].imag() < v.imag() ) return -R;\n  }\n  return v.imag();\n}\n\nint main(){\n  int cnt = 0;\n  while( cin >> R >> N && (N|R) ){\n    cnt++;\n    double ra = R;\n    memset(fie,0,sizeof(fie));\n    for(int i=0;i<N;i++){\n      int xr,xl,h;\n      cin >> xr >> xl >> h;\n      xr+=22; xl+=22;\n      for(int j=xr;j<xl;j++)\n\tfor(int l=0;l<h;l++)\n\t  fie[j][l] = true;      \n    }\n    \n    memset(used,0,sizeof(used));\n    vector<P> ep;\n    int x=1,y=0;\n    while( !(x == 44 && y == 0) ){\n      used[x][y] = true;\n      ep.push_back( P( x, y ) );\n      for(int i=0;i<3;i++){\n\tint nx = x+dx[i], ny = y+dy[i];\n\tif( check(nx,ny,i) ){\t  \n\t  x = nx; y = ny;\n\t  break;\n\t}       \n      }\n    }\n\n    double res = -ra;\n    for(int i=0;i<(int)ep.size();i++){\n      res = max( res, solve(ep[i],ep) );      \n    }\n    printf(\"%.4lf\\n\", res + R );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T = int> using V = vector<T>;\n\nint main() {\n    int r, n;\n    while (cin >> r >> n, r) {\n        V<> a(40);\n        while (n--) {\n            int l, r, h; cin >> l >> r >> h;\n            l += 20, r += 20;\n            for (int i = l; i < r; ++i) a[i] = max(a[i], h);\n        }\n        auto chk = [&](double t) -> bool {\n            for (int x = 20 - r + 1; x < 20 + r; ++x) {\n                double y = min(a[x - 1], a[x]) + r - t;\n                if (sqrt(r * r - (x - 20) * (x - 20)) > y) return false;\n            }\n            return true;\n        };\n        double ok = 0, ng = 100;\n        for (int _ = 0; _ < 100; ++_) {\n            double mid = (ok + ng) / 2;\n            (chk(mid) ? ok : ng) = mid;\n        }\n        cout << fixed << setprecision(15) << ok << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 50\n \nint main(){\n    double r;\n    int n;\n    while(cin >> r >> n, r){\n\tint H[MAX] = {0},xl,xr,h;\n\tfor(int i = 0 ; i < n ; i++){\n\t    cin >> xl >> xr >> h;\n\t    xl += 20; xr += 20;\n\t    for(int j = xl ; j < xr ; j++){\n\t\tH[j] = max(H[j],h);\n\t    }\n\t}\n\tdouble res = (1<<29);\n\tfor(int i = 20-r ; i < 20+r ; i++){\n\t    double rr = i-20+(i<20);\n\t    res = min(res,r+H[i]-sqrt(r*r-rr*rr));\n\t}\n\tprintf(\"%.8f\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cmath>\n#include<stdio.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\ndouble solve(int r,int n){\n  bool box[21][41] {{false}};\n  rep(i,n) {\n    int li,ri,hi;\n    cin >> li >> ri >> hi;\n\n    rep(y,hi) {\n      for(int x=li+20;x<ri+20;++x){\n        box[y][x]=true;\n      }\n    }\n\n  }\n  double ans=(double)1e9;\n  rep(y,21){\n    for(int x=20-r;x<r+20;x++) if(!box[y][x]){\n      double time;\n      if(x<20) time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n      else time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n      ans=min(ans,time);\n    }\n  }\n  return ans;\n}\n\nint main(int argc, char *argv[])\n{\n  int r,n;\n  while(cin>>r>>n, n&&r){\n    printf(\"%.4lf\\n\",solve(r,n));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}\n #include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint r, n, sl, sr, h; int height[40]; double sunrise[40];\n\n\twhile (true)\n\t{\n\t\tcin >> r >> n;\n\n\t\tif (r == 0 && n == 0) { break; }\n\n\t\tfor (int i = 0; i < 40; i++) { height[i] = 0; sunrise[i] = -5000.0; }\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> sl >> sr >> h;\n\n\t\t\tfor (int j = sl; j < sr; j++)\n\t\t\t{\n\t\t\t\theight[j + 20] = max(h, height[j + 20]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 20 - r; i < 20 + r; i++)\n\t\t{\n\t\t\tif (i < 20)\n\t\t\t{\n\t\t\t\tsunrise[i] = sqrt(r * r - (19 - i) * (19 - i)) - r;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsunrise[i] = sqrt(r * r - (i - 20) * (i - 20)) - r;\n\t\t\t}\n\t\t}\n\n\t\tdouble Answer = 10000.0;\n\n\t\tfor (int i = 0; i < 40; i++)\n\t\t{\n\t\t\tAnswer = min(height[i] - sunrise[i], Answer);\n\t\t}\n\t\t\n\t\tprintf(\"%.4f\\n\", Answer);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\n// typedef pair<int, int> P;\ntypedef complex<double> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\n\nconst int offset = 21;\nconst int width = 2 * offset + 1;\n\nstruct L {\n    P s, t;\n};\n\ndouble dot(P a, P b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble distanceLP(L l, P p) {\n    return abs(cross(p - l.s, l.t - l.s)) / abs(l.t - l.s);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.t - l.s, p - l.s) < 0) return abs(p - l.s);\n    if (dot(l.s - l.t, p - l.t) < 0) return abs(p - l.t);\n    return distanceLP(l, p);\n}\n\nbool inside(double t, int r, vector<L> lines) {\n    P center = P(0, - r + t);\n    for (auto line : lines) {\n        if (distanceSP(line, center) < r) return false;\n    }\n    return true;\n}\n\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int R, n;\n    while (cin >> R >> n && R) {\n        // ??? x ??§?¨????????????????????????????????????? (??????????¨????????????????????????????)\n        vector<int> highest(width + 2, 0); // highest[0] = highest[41] = 0\n        rep(i, n) {\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            // [xl, xr)\n            for (int j = xl + offset; j < xr + offset; j++) {\n                highest[j] = max(highest[j], h);\n            }\n        }\n\n        // ?????????????§??????????????????????\n        vector<L> lines;\n        P p1, p2;\n        p1 = P(-offset, 0);\n        rep2(i, 1, width) {\n            if (highest[i] != highest[i - 1]) {\n                // horizontal line\n                p2 = P(i - offset, highest[i - 1]);\n                lines.emplace_back((L){p1, p2});\n\n                // vertical line\n                p1 = P(i - offset, highest[i]);\n                lines.emplace_back((L){p2, p1});\n            }\n        }\n        lines.emplace_back((L){p1, P(offset, 0)});\n\n        // cout << \"hey!\" << endl;\n        // for (auto line : lines) {\n        //     cout << line.s << \" \" << line.t << endl;\n        // }\n\n        // ?????????1?????????????????????????????????????????????????????°????????????\n        double t = 0;\n        while (inside(t, R, lines)) t++;\n\n        // cout << t << endl;\n\n        double l = t - 1;\n        double r = t;\n        rep(i, 100) {\n            double m = (l + r) / 2;\n            if (inside(m, R, lines)) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n\n        printf(\"%.10f\\n\", (l + r) / 2);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nbool EQ(double a, double b) { return abs(a - b) < EPS; }\n\ndouble getHeight(double r, double x) {\n\treturn sqrt(r * r - x * x);\n}\n\nint main(void) {\n\tint r, n;\n\twhile(scanf(\"%d %d\", &r, &n), r > 0) {\n\t\tint left[20], right[20], height[20];\n\t\tfor(int i = 0; i < n; i++) scanf(\"%d %d %d\", left + i, right + i, height + i);\n\t\tvector<double> xs;\n\t\txs.push_back(-r + 1e-5);\n\t\txs.push_back(r - 1e-5);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble cand = left[i] - 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = left[i] + 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] - 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] + 1e-5;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t}\n\n\t\tdouble s = 0, e = 100;\n\t\tfor(int lv = 0; lv < 100; lv++) {\n\t\t\tdouble mid = (s + e) / 2;\n\t\t\tbool isAble = true;\n\n\t\t\tfor(double x: xs) {\n\t\t\t\tbool isIncluded = false;\n\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t\tif(left[i] <= x and x <= right[i] and height[i] >= getHeight(r, x) - r + mid) {\n\t\t\t\t\t\tisIncluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tif(!isIncluded) {\n\t\t\t\t\tisAble = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isAble) s = mid;\n\t\t\telse e = mid;\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\", ((int)(s * 10000)) * 0.0001);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ndouble INF = 10e8;\nint plus20[40];\nint maxh[21];\n\nint main(){\n    while(1){\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if(r==0) break;\n\n        REP(i, 40) plus20[i] = 0;\n        REP(i, n){\n            int xr, xl;\n            double h;\n            cin >> xr >> xl >> h;\n            for(int j = xr+20; j < xl+20; j++){\n                plus20[j] = max((double)plus20[j], h);\n            }\n        }\n\n        REP(i, 21) maxh[i] = 0;\n        REP(i, r+1){\n            if(i==r){\n                maxh[i] = 0;\n            } else {\n                double ph = min(plus20[20+i], plus20[20+i-1]);\n                double nh = min(plus20[20-i], plus20[20-i-1]);\n                maxh[i] = min(ph, nh);\n            }\n        }\n\n        double output = INF;\n        REP(i, r){\n            output = min(output, r - sqrt(pow(r, 2)-pow(i, 2)) + maxh[i]);\n        }\n\n        cout << fixed << setprecision(4) << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=(-x-0.999999),R=(x+0.999999),hb[101]={};\n\n  for(int i=L+50;i<R+50;i++){\n    int x1=i-49-i/50;\n    double y1=y[i]-cy;\n    if(sqrt(x1*x1+y1*y1)>=r)hb[i]++;\n  }\n  for(int i=L+50;i<R+50;i++)if(!hb[i])return 0;\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<100;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.001;\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<map>\n#include<cstdio>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define pb push_back\n#define P pair<int,int>\n#define ll __int64\nint n;\ndouble r;\ndouble x[100],x2[100],h[100];\ndouble EPS=0.0001;\nbool che(double t){\ndouble fai;\nint B=36000;\ndouble fy;\n\nfor(int i=0;i<=B;i++){\n\tfai=M_PI*(double)i/(double)B;\n\tdouble nx=r*cos(fai);//円上のx\n\tdouble ny=r*sin(fai)+t-r;//円上のy\n\t\n\tfy=-10000;\n\tdouble fx=0;\n\tfor(int j=0;j<n;j++){\n\t\tif(x[j]<=nx&&nx<=x2[j])fy=max(fy,h[j]);\n\t}\n\t//cout<<nx<<\" \"<<ny<<\" \"<<fy<<endl;\n\t\n\tif(fy<=-9999||ny>fy)return 0;\n}\nreturn 1;\n\n}\nint main(){\nwhile(cin>>r>>n,r||n){\nrep(i,n)cin>>x[i]>>x2[i]>>h[i];\n\n\n\ndouble mid=0,l=0,r=100;\nmid=(r+l)/2;\nfor(int i=0;i<30;i++){\n\tif(che(mid)){\n\t\tl=mid;\n\t}\n\telse{\n\t\tr=mid;\n\t}\n\tmid=(r+l)/2;\n}\n\nprintf(\"%.20lf\\n\",mid);\nrep(i,n)x[i]=x2[i]=h[i]=0;\n}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1e9;\n\nint main() {\n\tint r, n;\n\twhile(cin >> r >> n, r) {\n\t\tvector<int> h1(2 * r + 1), h2(2 * r + 1);\n\t\tvector<int> flag(2 * r + 1);\n\t\tconst int center = r;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint xl, xr, hi;\n\t\t\tcin >> xl >> xr >> hi;\n\t\t\txl = max(-r, xl);\n\t\t\txr = min(r, xr);\n\t\t\txl += r;\n\t\t\txr += r;\n\t\t\tfor(int j = xl; j <= xr; ++j) {\n\t\t\t\tif(j == xl) flag[j] |= 1;\n\t\t\t\telse if(j == xr) flag[j] |= 2;\n\t\t\t\telse flag[j] |= 3;\n\t\t\t\tif(j == xl) h1[j] = max(h1[j], hi);\n\t\t\t\telse if(j == xr) h2[j] = max(h2[j], hi);\n\t\t\t\telse {\n\t\t\t\t\th1[j] = max(h1[j], hi);\n\t\t\t\t\th2[j] = max(h2[j], hi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> h(2 * r + 1);\n\t\tfor(int i = 0; i <= 2 * r; ++i) {\n\t\t\th[i] = min(h1[i], h2[i]);\n\t\t}\n\t\tfor(int i = 0; i <= 2*r; ++i) {\n\t\t\tif(flag[i] != 3) {\n\t\t\t\th[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble ans = inf;\n\t\tfor(int i = 1; i < 2 * r; ++i) {\n\t\t\tdouble hh = sqrt(r * r - abs(r - i) * abs(r - i));\n\t\t\tdouble cp = max(h[i] - hh, -(double)r);\n\t\t\tans = min(ans, cp + r);\n\t\t}\n\t\t\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint build[20][40];\n\nvoid printbuild() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      if (build[i][j]) cout << \"#\";\n      else cout << \".\";\n    }\n    cout << endl;\n  }\n}\n\nvoid makeOut() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 1 - build[i][j];\n    }\n  }\n}\n\nbool touchingSun(long h, long i, double c, long r) {\n  return hypot(19 - h - c, i - 20) < r || hypot(19 - h - c, i - 19) < r;\n}\n\nbool touchingSunAll(double c, long r) {\n  for (int h = 0; h < 20; h++) {\n    for (int i = 0; i < 40; i++) {\n      if (build[h][i] && touchingSun(h, i, c, r)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid reset() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 0;\n    }\n  }\n}\n\nvoid fillbuild(long l, long r, long h) {\n  for (int i = 19; i >= 20 - h; i--) {\n    for (int j = l + 20; j < r + 20; j++) {\n      build[i][j] = 1;\n    }\n  }\n}\n\nvoid solve(long n, long r) {\n  reset();\n  long l, rr, h;\n  for (int i = 0; i < n; i++) {\n    cin >> l >> rr >> h;\n    fillbuild(l, rr, h);\n  }\n  makeOut();\n  // printbuild();\n  double c = -r;\n  double step = 0.5;\n  while (step > 0.00001) {\n    if (!touchingSunAll(c, r)) {\n      c += step;\n    } else {\n      c -= step;\n      step /= 2;\n    }\n  }\n  printf(\"%.4f\\n\", c + r);\n}\n\nint main() {\n  long n, r;\n  while (1) {\n    cin >> r >> n;\n    if (n + r) {\n      solve(n, r);\n    } else {\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<pi, int> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint p[50];\nint is[50];\nint r, n;\n\nint C(double t){\n  if(p[20] < t) return 0;\n  for(int i=0;i<41;i++){\n    //    cout << x-r << \" \" << a.second << endl;\n    int x = i-20;\n    if(SQ((t-r)-p[i])+SQ(x)  < SQ(r)) return 0;\n  }\n  return 1;\n}\n\nint main()\n{\n  while(1){\n    cin >> r >> n;\n    if(r == 0 && n == 0) return 0;\n    memset(p, 0, sizeof(p));\n    memset(is, -1, sizeof(is));\n    int maxh = 0;\n    pii x[32];\n    rep(i, n){\n      cin >> x[i].first.first >> x[i].first.second >> x[i].second;\n      for(int j=x[i].first.first+1;j<x[i].first.second;j++) p[j+20] = max(p[j+20], x[i].second);\n      for(int j=x[i].first.first;j<=x[i].first.second;j++) is[j] = 0;\n      maxh = max(maxh, x[i].second);\n    }\n    sort(x, x+n);\n    rep(i, n-1){\n      if(x[i].first.second == x[i+1].first.first){\n\tp[x[i].first.second+20] = min(x[i].second, x[i+1].second);\n      }else{\n\t//\tp[x[i].first.second+20] = 0;\n\t//\tp[x[i+1].first.first+20] = 0;\n      }\n    }\n\n    //    rep(i, 10) cout << p[i+15] << \" \"; cout << endl;\n    double lb = 0.0, ub = maxh;\n    rep(i, 100){\n      double mid = (lb+ub)/2;\n      //      cout << mid << endl;\n      if(C(mid)) lb = mid;\n      else ub = mid;\n    }\n    printf(\"%.12f\\n\", lb);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nint main(){\n    ll r,n;\n    ll line =0;\n    //std::ofstream writing_file;\n    //writing_file.open(\"vamp_cin.txt\", std::ios::out);\n    while(cin>>r>>n){\n    //  line++;\n        if(r==0)break;\n        int xl[41],xr[41],h[41];\n        int hh[41][41];\n        memset(hh,0,sizeof(hh));\n        for(int i=0;i<n;i++){\n            cin>>xl[i+20]>>xr[i+20]>>h[i+20];\n            for(int j=xl[i+20];j<xr[i+20];j++){\n                hh[j+20][j+21]=max(h[i+20],hh[j+20][j+21]);\n            }\n        }\n        int minh = 1e5;\n        int minx = 0;\n        double ans=1e5;\n        double res=1e5;\n        for(int i=20-r;i<20+r;i++){\n            //minh = min(h[i+20]);\n/*          if(minh >= hh[i][i+1]){\n                if(minh == hh[i][i+1]){\n                    if(abs(20-i)<abs(minx-20)){\n                        minx = i;\n                    }\n                }else{\n                    minx = i;\n                }\n                minh = hh[i][i+1];\n            }*/\n        //  cout<<\"i i+1:\"<<i<<\" \"<<i+1<<\"hh:\"<<hh[i][i+1]<<endl;\n            if(i<20)res = min(res,hh[i][i+1] + r - sqrt(r*r - abs(i-19)*abs(i-19)));\n            else res = min(res,hh[i][i+1] + r - sqrt(r*r - abs(i-20)*abs(i-20)));\n        //  cout<<\"res:\"<<res<<endl;\n            ans = min(ans,res);\n        }\n        for(int i=20-r;i<20+r;i++){\n        //  cout<<\"i i+1:\"<<i<<\" \"<<i+1<<\"hh:\"<<hh[i][i+1]<<endl;\n        }\n//      minh = min(hh[minx-1],min(hh[minx+1],minh));\n        /*if(minh>hh[minx-1][minx]&&minh<hh[minx+1][minx+2]){\n            //minh = hh[minx-1][minx];\n            minx-=1;\n        }else if(minh > hh[minx+1][minx+2]&&minh<hh[minx-1][minx]){\n            //minh=hh[minx+1][minx+2];\n            minx+=1;\n        }*/\n \n        if(minx<20)minx+=1;\n        //if(minx>20)minx-=1;\n        //cout<<\"minx\"<<minx<<\" minh:\"<<minh<<endl;\n        cout<<fixed;\n        cout<<setprecision(4)<<ans<<endl;\n        /*writing_file<<\"line:\"<<line<<endl;\n        writing_file<<n<<\" \"<<r<<endl;\n        for(int i=0;i<n;i++){\n            writing_file<<xl[i+20]<<\" \"<<xr[i+20]<<\" \"<<h[i+20]<<endl;\n        }+*/\n    //  writing_file<<fixed;\n    //  writing_file<<setprecision(4)<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>=R)return false;\n\tif(x<=-R)return false;\n\tif(y1<=c&&c<=y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>=c+R)return false;\n\tif(y<=c-R)return false;\n\tif(x1<=0.0&&0.0<=x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i,(double)(i+1))){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)h[i+geta],(double)h[i+1+geta])){\n\t\t\t\t//cout << i+1 << ' ' << h[i+geta] << ' ' << h[geta+1+i] << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\thighest = max(hi,highest);\n\t\tfor(int j=l;j<r;j++){\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = (double)highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n\nstruct Point {\n\n\n    double x, y;\n\n    Point() {\n        x = 0;\n        y = 0;\n    }\n\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n\n    inline Point operator+=(double s) {\n        this->y += s;\n    }\n\n//    constexpr Point operator+(Point rhs) const {\n//        return {x + rhs.x, y + rhs.y};\n//    }\n//\n//    constexpr Point operator-(Point rhs) const {\n//        return {x - rhs.x, y - rhs.y};\n//    }\n\n};\n\ninline Point operator+(double s, Point p) {\n    return {p.x, s + p.y};\n}\n\n\nstruct Rect {\n\n    Point left;\n    Point right;\n\n    Rect() {\n\n    }\n\n    Rect(int left_x, int right_x, int y) {\n        left = Point(left_x, y);\n        right = Point(right_x, y);\n    }\n\n};\n\nbool isSection(Point point, Rect rect) {\n    if (rect.left.x <= point.x && point.x <= rect.right.x && point.y <= rect.left.y) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n\n    while (true) {\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0) {\n            break;\n        }\n\n        vector<Point> circlePoints(100000);\n        REP(i, circlePoints.size()) {\n            double x = -r + ((2.0 * r) * ((double) i / (double) circlePoints.size()));\n            double y = sqrt(r * r - x * x);\n            circlePoints[i] = Point(x, y);\n        }\n\n        vector<Rect> rects(n + 1);\n        REP(i, n + 1) {\n            if (i == n) {\n                rects[n] = Rect(-1000, 1000, 0);\n            }else{\n                int left, right, h;\n                cin >> left >> right >> h;\n                rects[i] = Rect(left, right, h);\n            }\n        }\n\n        double diff = 20;\n\n        bool plus = true;\n        while (diff > 0.00001) {\n            if (plus) {\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += diff;\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n                if (good) {\n                    continue;\n                } else {\n                    diff /= 2.0000;\n                    plus = false;\n                   // cout << diff;\n                }\n\n            } else {\n\n\n                //cout << \"here\";\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += (-diff);\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n//                double largeY = -1;\n//                REP(i, circlePoints.size()) {\n//                    largeY = max(largeY, circlePoints[i].y);\n//                }\n\n                if (good) {\n                    diff /= 2.0000;\n                    plus = true;\n                    //cout << diff << endl;\n                } else {\n                    continue;\n                }\n            }\n        }\n\n        double largeY = -1;\n        REP(i, circlePoints.size()) {\n            largeY = max(largeY, circlePoints[i].y);\n        }\n\n        cout << setprecision(10) << largeY << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,n){\n\t\tdouble l=-R,r;\n\t\tint ma=0;\n\t\tvi in(50,0);\n\t\twhile(n--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tloop(i,a,b)in[i+25]=max(in[i+25],c);\n\t\t}\n\t\tloop(i,-R,R)ma=max(ma,in[i+25]);\n\t\tr=ma-R;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tbool q=true;\n\t\t\tloop(i,25-R,25+R){\n\t\t\t\tdouble dis=hypot(min(in[i],in[i-1])-h,i-25);\n//\t\t\t\tcout<<i-25<<\" \"<<dis<<endl;\n\t\t\t\tif(min(in[i],in[i-1])<h-R||dis+EPS<(double)R)q=false;\n\t\t\t}\n\t\t\tif(q)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.8f\\n\",l+R);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint R,N;\n\twhile(cin >> R >> N){\n\t\tif(R==0)break;\n\t\tvector<int> h(41,0);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tint l,r,hh; cin >> l >> r >> hh;\n\t\t\tfor(int x=l+20;x<r+20;x++){\n\t\t\t\th[x]=max(h[x],hh);\n\t\t\t}\n\t\t}\n\t\tdouble res=25;\n\t\tfor(int x=-R+1;x<R;x++){\n\t\t\tint hh=min(h[x+20],h[x+19]);\n\t\t\tres=min(res,hh-sqrt(R*R-x*x)+R);\n\t\t}\n\t\tprintf(\"%.8lf\\n\",res);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    double r;\n    int n;\n    while (cin >> r >> n && n){\n        map<int, double> hl, hr;\n        while (n--){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            hr[xl] = fmax(hr[xl], h);\n            hl[xr] = fmax(hl[xr], h);\n            FOR(i,xl+1,xr-1){\n                hl[i] = fmax(hl[i], h);\n                hr[i] = fmax(hr[i], h);\n            }\n        }\n\n        double ans = fmin(hr[-r], hl[r]) + r;\n        FOR(i,-r+1,r-1){\n            double h = fmin(hl[i], hr[i]);\n            double y = r - sqrt(r*r-i*i);\n            ans = fmin(ans, y+h);\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\n\nP e[100010];\nint D = 50000;\ndouble PI = acos(-1);\nint test(vector<G> &g,double t,double r){\n\tC c = C(P(0,-r+t),r);\n\tvector<P> chkPoint;\n\t\n\tfor(int i = 0 ; i < D ; i++){\n\t\tchkPoint.push_back(c.p+r*e[i]);\n\t}\n\tfor( auto p : chkPoint ){\n\t\tif( p.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tif( contains(g[j],p) != OUT  ){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nint main(){\n\tfor(int i = 0 ; i < D ; i++){\n\t\te[i] = P(cos(i*2.*PI/D),sin(i*2.*PI/D));\n\t}\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\tg.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl-1e-7,-1e-7},{xr+1e-7,-1e-7},{xr+1e-7,h+1e-7},{xl-1e-7,h+1e-7}});\n\t\t}\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this); \n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto dist = distance_lp(l, c);\n  if(dist > c.r + EPS) { return {{-inf,-inf},{-inf,-inf}}; }\n  auto basehalf = sqrt(c.r * c.r - dist * dist);\n  P v = (l[1]-l[0]) * P(0, 1);\n  Line h(c, c+v); P ph = crosspoint(l, h);\n  P u1 = (ph + v) * P(0, 1); u1 /= abs(u1); u1 *= basehalf;\n  P u2 = (ph + v) * P(0, -1); u2 /= abs(u2); u2 *= basehalf;\n  return {u1, u2};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  for(int R, N; cin >> R >> N && (R | N);) {\n    vector<int> hs(44); int const OF = 22;\n    rep(i, N) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      REP(x, xl, xr) {\n        maximize(hs[x+OF], h);\n      }\n    }\n    vector<P> events;\n    int currh = 0;\n    events.emplace_back(-22, 0);\n    REP(x, -21, 22) {\n      if(currh != hs[x+OF]) {\n        events.emplace_back(x, currh);\n        currh = hs[x+OF];\n        events.emplace_back(x, currh);\n      }\n      else {\n        events.emplace_back(x, currh);\n      }\n    }\n\n//    for(auto && e: events) { cout << e << endl; } cout << endl;\n\n    Circle c(P(0, -R), R);\n\n    for(double t=0; t<=80; t+=0.00001) {\n      bool ok = 0;\n      rep(i, events.size()) {\n        if(abs(c - events[i]) < c.r - EPS) {\n          printf(\"%.10f\\n\", t);\n          ok = 1;\n          break;\n        }\n      }\n      if(ok) { break; }\n      c.cent[1] += 0.00001;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble h[55];\nint main(){\n    double r;\n    int n;\n    while(cin>>r>>n,n){\n        int xl,xr;\n        double hi;\n        memset(h,0,sizeof(h));\n        rep(i,n){\n            cin>>xl>>xr>>hi;\n            xl+=25,xr+=25;\n            FOR(j,xl,xr) h[j]=max(hi,h[j]);\n        }\n        double mn=1000100010;\n        FOR(i,25-r,25+r){\n            double dx=min(abs(i-25),abs(i-24));\n            mn=min(mn,h[i]-sqrt(r*r-dx*dx)+r);\n        }\n        cout<<fixed<<setprecision(12)<<mn<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int r; //半径\n        int max=0;  //高さの最大値\n        int n;\n        cin >> r >> n;\n        int r_min = 0 - r; //半径のマイナス\n        double t=20.0;\n        int x_i[n],x_j[n],h[n];\n        for(int i=0;i<n;i++){\n            cin >> x_i[i] >> x_j[i] >> h[i];\n            if(max<h[i])    max=h[i];\n        }\n        int a[max][r+r];\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<max;j++){\n                for(int l=-r;l<r;l++){\n                    if(x_i[i]<=l && x_j[i]>l){\n                        if(h[i]>=j){\n                            a[j-1][l+r]++;\n                        }\n                    }\n                }\n            }\n        }\n        int count=0;\n        double u=0.0;\n        int min=10;\n        int h_a,x_a;\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                if(a[i][j]==0){\n                    if(j<r){\n                        if(min>i+(r-1)-j){\n                            min=i+(r-1)-j;\n                            h_a=i;\n                            x_a=(r-1)-j;\n                        }\n                    }else{\n                        if(min>i+j-r){\n                            min=i+j-r;\n                            h_a=i;\n                            x_a=j-r;\n                        }\n                    }\n                }\n            }\n        }\n        t=(double)r-sqrt(r*r-x_a*x_a)+(double)h_a;\n        printf(\"%.4f\",t);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\n    while(true){\n\n        double r;\n        int n;\n\n        cin >> r >> n;\n\n        if(r == 0.0 && n == 0){\n            break;\n        }\n\n        int x[41] = {0};\n\n        for(int i=0; i<n; i++){\n            int lx,ly,h;\n\n            cin >> lx >> ly >> h;\n\n            for(int i=20+lx; i<20+ly; i++){\n                x[i] = max(x[i],h);\n            }\n        }\n\n        for(int i=0; i<41; i++){\n            cout << i-20 << \" to \" << i-20 + 1 << \" \" << x[i] << endl;\n        }\n\n        double ans = 0.000;\n\n        while(true){\n\n            double survey = ans + 0.001;\n\n            bool flag = true;\n\n            for(int i=-20; i<=20; i++){\n                double d_x = static_cast<double>(i);\n                if(r*r > d_x*d_x){\n                    double h = sqrt(r*r - d_x*d_x) + 1.0*survey - r;\n                    if(h > x[i+20] || h > x[i+20 -1]){\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n\n            if(!flag){\n                break;\n            }\n\n            ans += 0.001;\n\n        }\n\n        cout << fixed << setprecision(4) << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[50],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=-x-25.9999,R=x+25.9999;\n\n  for(int i=L;i<R;i++){\n    int x1=i-24-i/25;\n    double y1=y[i]-cy;\n    if(x1*x1+y1*y1<r*r)return 0;\n  }\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<50;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+25]=max(y[j+25],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.000999;\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, r;\n\twhile (cin >>r>>n, r) {\n\t\tmap<int, int> v;\n\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t\n\t\t\tFOR(j, a, b)v[j] = max(v[j], c);\n\t\t}\n\t\tif (n==0) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tdouble u = 21, l = -1;\n\t\t\twhile (u - l > EPS) {\n\t\t\t\tint flag = 1;\n\t\t\t\tdouble mid = (u + l) / 2;\n\t\t\t\tFOR(i, -20, 20) {\n\t\t\t\t\tint d = i;\n\t\t\t\t\tif (i < 0)d++;\n\t\t\t\t\tif (d > r)continue;\n\t\t\t\t\tdouble c = sqrt(r*r - d*d);\n\t\t\t\t\tif (c + mid -r> v[i])flag = 0;\n\t\t\t\t}\n\t\t\t\tif (flag)l = mid;\n\t\t\t\telse u = mid;\n\t\t\t}\n\t\t\tcout << fixed << setprecision(4) << l << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <math.h>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i-1-r)*(i-1-r)));\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\n#define MAX_N 20\n\nusing namespace std;\n\nint N, R;\nint lx[MAX_N], rx[MAX_N], h[MAX_N];\nint inf = 100000000;\n\nbool judge(double t){\n\tfor (int x = -R+1; x < R; x++)\n\t{\n\t\tint l = inf, r = inf, m = 0;\n\t\tint y;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif(lx[i] == x){\n\t\t\t\tr = min(h[i], r);\n\t\t\t}else if(rx[i] == x){\n\t\t\t\tl = min(h[i], l);\n\t\t\t}else if(lx[i] < x && x < rx[i]){\n\t\t\t\tm = max(h[i], m);\n\t\t\t}\n\t\t}\n\t\tif(l == inf || r == inf) y = 0;\n\t\telse y = min(l, r);\n\t\tif(m > y) y = m;\n\t\tif(y < (double)sqrt(R*R-x*x)-R+t) return true;\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tdouble maxT = 21;\n\tdouble minT = 0;\n\twhile(maxT - minT > 0.0001){\n\t\tdouble t = (maxT+minT)/2;\n\t\tif(judge(t)){// ???????????????\n\t\t\tmaxT = t;\n\t\t}else{// ????????????\n\t\t\tminT = t;\n\t\t}\n\t}\n\tprintf(\"%.4lf\\n\", (maxT+minT)/2);\n\treturn;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> R >> N;\n\t\tif(R == 0 && N == 0) break;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> lx[i] >> rx[i] >> h[i];\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,N,n) for(int i=N;i>=n;i++)\n#define CH(n,a,b) (a)<=(n)&&(n)<(b)\n#define p(s) cout<<s<<endl;\ntypedef long long ll;\nusing namespace std;\nconst double inf=1e8;\nbool grid[25][45];\n\nint main() {\n\tint n, r, lx, rx, h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0 && n == 0) break;\n\t\tREP(i,0,25)REP(j,0,45) grid[i][j] = 0;\n\t\tREP(ii,0,n){\n\t\t\tcin>>lx>>rx>>h;\n\t\t\tREP(k,lx+20,rx+20)REP(l,0,h)grid[l][k] = 1;\n\t\t}\n\t\tdouble ans=inf;\n\t\tREP(i,0,21){\n\t\t\tREP(w,-r+20,r+20){\n\t\t\t\tif( grid[i][w] == 0){\n\t\t\t\t\tdouble tmp;\n\t\t\t\t\tif(w<20) tmp= (double) r - sqrt((double)r*r - (19-w)*(19-w))+i;\n\t\t\t\t\telse tmp =(double) r - sqrt((double)r*r - (20-w)*(20-w))+i;\n\t\t\t\t\tans=min(tmp,ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans!=inf) {\n\t\t\t\tprintf(\"%.6f\\n\", ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <iomanip>\nusing namespace std;\nint n,r;\n\nmap<int, double> keep_y;  \nbool check2(double x,double y, double xl, double xr, double hei){\n  return xl <= x && x <= xr && y <= hei;\n}\nvoid addPoint(vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  keep_y = map<int, double>();\n  for(int i = 0;i < n;i++){\n\tfor(int j = xl[i];j < xr[i];j++){\n\t  keep_y[j] = max(keep_y[j], hei[i]);\n\t}\n  }\n}\ndouble dist(double x1,double y1,double x2,double y2){\n  return ((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}\nbool check(double h){//円内に, 候補点があり=> アウト日が出る\n  for(int i = -r;i <= r;i++){\n\tif(dist(i, keep_y[i], 0, h) < r*r || dist(i, keep_y[i-1], 0, h) < r*r){\n\t  return true;\n\t}\n  }\n  return false;\n}\n\ndouble bs(double h,vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  double f = -r;\n  double e = h;  \n  while(e - f >= 0.0001){\n\tdouble mid = (f + e) / 2.0;\n\tif(check(mid)){\n\t  e = mid;\n\t}else{\n\t  f = mid;\n\t}\n  }\n  return f;\n}\nint main(){\n  \n  while(cin >> r >> n){\n\tif(n == 0 && r == 0)break;\n\tvector<double> xl(n);\n\tvector<double> xr(n);\n\tvector<double> hei(n);\n\tfor(int i = 0;i < n;i++){\n\t  cin >> xl[i] >> xr[i] >> hei[i];\n\t}\n\taddPoint(xl,xr,hei);\n\tcout << fixed << setprecision(5) << bs(keep_y[0]-r,xl,xr,hei) + r<< endl;\n\t \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, R;\n\nVI XLS, XRS;\nVI HS;\n\nVVI find_max_hs() {\n    VVI max_hs(41, VI(2));\n    \n    rep(i, N) {\n        REP(x, XLS[i], XRS[i] + 1) {\n            rep(lr, 2) {\n                if (!lr && x == XLS[i]) continue;\n                if (lr && x == XRS[i]) continue;\n\n                max_hs[20 + x][lr] = max(max_hs[20 + x][lr], HS[i]);\n            }\n        }\n    }\n\n    return max_hs;\n}\n\ndouble calc(double h, double x) {\n    double r = R;\n    double A = h + r;\n\n    double a = 1;\n    double b = -2. * A;\n    double c = A * A + x * x - r * r;\n\n    double p = b * b - 4. * a * c;\n    if (p < 0) return DINF;\n\n    double ans = (-1. * b - sqrt(p)) / 2.;\n\n    return ans;\n}\n\ndouble solve() {\n    VVI max_hs = find_max_hs();\n\n    double anst = DINF;\n\n    for (int x = -1 * R; x <= R; x++) {\n        double tt = DINF;\n        for (int lr = 0; lr < 2; lr++) {\n            int h = max_hs[20 + x][lr];\n            double t = calc(h, abs(x));\n            tt = min(tt, t);\n        }\n        if (tt != DINF) {\n            anst = min(anst, tt);\n        }\n    }\n\n    return anst;\n}\n\nint main(void) {\n    while (cin >> R >> N, R) {\n        XLS.clear();\n        XRS.clear();\n        HS.clear();\n\n        XLS.resize(N);\n        XRS.resize(N);\n        HS.resize(N);\n\n        for (int i = 0; i < N; i++) {\n            cin >> XLS[i] >> XRS[i] >> HS[i];\n        }\n\n        printf(\"%.4f\\n\", solve());\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1194\n//\n//  Created by 13B15237 on 2015/06/22.\n//  Copyright (c) 2015??´ 13B15237. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Rect {\n    int l, r;\n    int h;\n};\n\nstruct Point {\n    int x, y;\n};\n\nstruct Area {\n    bool table[21][41];\n    \n    void clear() {\n        for (int y = 0; y < 21; ++y) {\n            for (int x = -20; x < 21; ++x) {\n                table[y][x+20] = false;\n            }\n        }\n    }\n    \n    void draw(Rect rect) {\n        for (int y = 0; y < rect.h; ++y) {\n            for (int x = rect.l; x < rect.r; ++x) {\n                table[y][x + 20] = true;\n            }\n        }\n    }\n    \n    void show() {\n        for (int y = 20; y >= 0; --y) {\n            for (int x = -20; x < 21; ++x) {\n                cout << (table[y][x+20] == true ? '#' : '_');\n            }\n            cout << endl;\n        }\n    }\n    \n    bool test(int r, int t) {\n        const int ybegin = max(0, t - 2 * r);\n        const int yend = t;\n        \n        for (int y = ybegin; y < yend; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == false) return false;\n            }\n        }\n        return true;\n    }\n    \n    Point calcMinDistPoint(int r, int maxt) {\n        double mindist = 30.0;\n        Point p = {0, 0};\n        \n        for (int y = max(0, maxt - 2 * r); y < maxt; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == true) continue;\n                \n                const int a = x < 0 ? abs(x + 1) : x;\n                const int b = y;\n                double dist = sqrt(a*a + b*b);\n                //printf(\"(%d, %d) = %f\\n\", x,y,dist);\n                \n                if (dist < mindist) {\n                    mindist = dist;\n                    p.x = x;\n                    p.y = y;\n                }\n            }\n        }\n        return p;\n    }\n};\n\nint R, N;\nvector<Rect> vrect;\nArea area;\n\nint main(int argc, const char * argv[]) {\n    while (1) {\n        cin >> R >> N;\n        if (!R && !N) break;\n        \n        area.clear();\n        vrect.clear();\n        vrect.resize(N);\n        for (auto r : vrect) {\n            cin >> r.l >> r.r >> r.h;\n            area.draw(r);\n        }\n        \n        //area.show();\n        \n        int tmax;\n        for (tmax = 0; tmax < 21; ++tmax) {\n            if (area.test(R, tmax) == false) break;\n        }\n        \n        /*\n        double t = static_cast<double>(tmax - 1);\n        while (1) {\n            double d = area.calcMinDist(R, t, tmax);\n            if (d < static_cast<double>(R)) break;\n            t += 0.001;\n        }\n         */\n        Point p = area.calcMinDistPoint(R, tmax);\n        const int dx = p.x < 0 ? abs(p.x + 1) : abs(p.x);\n        double dy = sqrt(R * R - dx * dx);\n        \n        \n        //cout << \"p = (\" << p.x << \", \" << p.y << \")\" << endl\n        //<< \"dy = \" << dy << \", R  = \" << R << endl;\n        double t;\n        if (p.x == 0) {\n            t = (double)p.y;\n        }\n        else {\n            if (dy < (double)R) {\n                t = (double)(tmax - 1) + ((double)R - dy);\n            } else {\n                t = (double)p.y;\n            }\n        }\n        \n        printf(\"%.4f\\n\", t);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <math.h>\n#include <utility>\n#include <queue>\n#include <stdio.h>\n#include <string>\n#define INF 1000000007\nusing namespace std;\n\ndouble hi_0(int x,int r){\n    if (x>-1*r&&x<r) {\n        double h = sqrt(r*r-x*x);\n        return h-(double)r;\n    }else{\n        return -1*r;\n    }\n}\n\n\nint main(){\n    for (;;) {\n        int  r,n;\n        cin >> r>>n;\n        if (r==0&&n==0) break;\n        double hist[41];\n        for (int i=0; i<41; i++) {\n            hist[i] = 0;\n        }\n        for (int i=0; i<n; i++) {\n            int l,rr,h;\n            cin >> l >> rr >>h;\n            for (int j=l; j<rr; j++) {\n                hist[j+20]=max(hist[j+20],(double)h);\n            }\n        }\n        double ans=114514;\n        for (int i=-1*r+1; i<r ; i++) {\n            double limit = min(hist[i+19]-hi_0(i, r),hist[i+20]-hi_0(i, r));\n            ans= min(ans,limit);\n        }\n        printf(\"%.4f\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define SZ 20\n\nint mat[SZ+1][2*SZ+1];  //no-shade:0, shade:plus, mat[height][width+20]\n\nint main(){\n  int r,n;\n  while(scanf(\"%d %d\",&r,&n), r|n){\n    // initialize\n    rep(i,SZ+1){\n      rep(j,2*SZ+1){\n\tmat[i][j]=0;\n      }\n    }\n\n    // input provess for imosu\n    rep(i,n){\n      int xl, xr, h;\n      scanf(\"%d %d %d\", &xl, &xr, &h);\n      mat[0][xl+20]++;\n      mat[0][xr+20]--;\n      mat[h][xl+20]--;\n      mat[h][xr+20]++;\n    }\n    \n    // imosu\n    rep(i,SZ){\n      repl(j,1,2*SZ){\n\tmat[i][j] += mat[i][j-1];\n      }\n    }\n    rep(i,2*SZ){\n      repl(j,1,SZ){\n\tmat[j][i] += mat[j-1][i];\n      }\n    }\n\n    // debug\n    /*\n    rep(i,SZ){\n      rep(j,2*SZ){\n\tprintf(\"%d\", mat[SZ-i-1][j]);\n      }printf(\"\\n\");\n    }\n    */\n\n    // move sun from bottom\n    int t=0;\n    int w;\n    double res=INF;\n    while(t<20){\n      w=0; //width\n      while(w<r){\n\tif(mat[t][20+w]>0 && mat[t][19-w]>0){\n\t  w++;\n\t}else{\n\t  break;\n\t}\n      }\n      if(w==0){\n\tres=min(res, (double)t);\n\tbreak;\n      } else if(w==r){\n\tt++;\n\tcontinue;\n      } else {\n\tres = min(res, (double)(r+t) - sqrt(r*r-w*w));\n\tt++;\n      }\n    }\n\n    if(t==20 && (res==INF|| res>=20)){\n      printf(\"20.0000\\n\");\n      continue;\n    }\n\n    printf(\"%.4f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid uniq(vector<double> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\ndouble sq(double x) {\n\treturn x * x;\n}\n\nbool intersect(double x1, double y1, double x2, double y2, double cx, double cy, double r) {\n\tif (x1 <= cx && cx <= x2 && y1 - r < cy && cy < y2 + r) return true;\n\tif (y1 <= cy && cy <= y2 && x1 - r < cx && cx < x2 + r) return true;\n\tif (sq(x1 - cx) + sq(y1 - cy) < sq(r)) return true;\n\tif (sq(x1 - cx) + sq(y2 - cy) < sq(r)) return true;\n\tif (sq(x2 - cx) + sq(y1 - cy) < sq(r)) return true;\n\tif (sq(x2 - cx) + sq(y2 - cy) < sq(r)) return true;\n\treturn false;\n}\n\nint main() {\n\tdouble r, n;\n\twhile (cin >> r >> n) {\n\t\tif (r == 0) break;\n\n\t\tvector<double> xl(n), xr(n), h(n);\n\t\tvector<double> xs({-99, 99}), ys({0, 99});\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\txs.push_back(xl[i]);\n\t\t\txs.push_back(xr[i]);\n\t\t\tys.push_back(h[i]);\n\t\t}\n\t\tuniq(xs);\n\t\tuniq(ys);\n\n\t\tint seg_h = ys.size() - 1;\n\t\tint seg_w = xs.size() - 1;\n\t\tvector<vector<bool>> seg(seg_h, vector<bool>(seg_w, false)); // 遮られている区画はtrue\n\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\t//          (x2, y2) \n\t\t\t// (x1, y1)\n\t\t\tint y1 = lower_bound(ys.begin(), ys.end(), 0) - ys.begin();\n\t\t\tint y2 = lower_bound(ys.begin(), ys.end(), h[i]) - ys.begin();\n\t\t\tint x1 = lower_bound(xs.begin(), xs.end(), xl[i]) - xs.begin();\n\t\t\tint x2 = lower_bound(xs.begin(), xs.end(), xr[i]) - xs.begin();\n\t\t\tfor (int j=y1; j<y2; ++j) {\n\t\t\t\tfor (int k=x1; k<x2; ++k) {\n\t\t\t\t\tseg[j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto is_blocked = [&](double y) {\n\t\t\tfor (int i=0; i<seg_h; ++i) {\n\t\t\t\tfor (int j=0; j<seg_w; ++j) {\n\t\t\t\t\tif ( ! seg[i][j] && intersect(xs[j], ys[i], xs[j+1], ys[i+1], 0, y, r)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t\n\t\tdouble lo = -r;\n\t\tdouble hi = 21;\n\t\twhile (hi - lo > 1e-6) {\n\t\t\tdouble mid = (lo + hi) / 2.0;\n\t\t\tif (is_blocked(mid)) {\n\t\t\t\tlo = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\", hi + r);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex< double > Point;\ntypedef vector< Point > Polygon;\nnamespace std{\n    bool operator < ( Point a, Point b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n};\nconst double INF = 1e12;\nconst double EPS = 1e-8;\nPoint NextPoint(){\n    Point P;\n    cin>>P.real() >> P.imag();\n    return P;\n}\nstruct Line : Polygon{\n    Line(){};\n    Line(Point p, Point q){push_back(p);push_back(q);}\n};\n \nstruct Circle{\n    Point p;\n    double r;\n    Circle();\n    Circle(Point a, double s){p = a,r = s;}\n};\ndouble cross(Point p, Point q){\n    return imag(conj(p)*q);\n}\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\nint ccw(Point a,Point b,Point c){\n    b -= a,c -= a;\n    if(cross(b,c) > 0)return 1;\n    if(cross(b,c) < 0)return -1;\n    if(dot(b,c) < 0 )return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\nPoint projection(Line l,Point p){\n    double t = dot(p - l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nbool intersectSP(Line s,Point p){\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble distanceSP(Line s,Point p){\n    const Point r = projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0] - p),abs(s[1] - p));\n}\nint main(){\n    int r,n;\n    while(cin>>r>>n,r){\n        int sc[60] = {};\n        for(int i = 0;i < n;i++){\n            int l,r,h;\n            cin>>l>>r>>h;\n            l+=30,r+=30;\n            for(int j = l;j < r;j++){\n                sc[j] = max(sc[j],h);\n            }\n        }\n        Polygon G;\n        G.push_back(Point(-100,0));\n        G.push_back(Point(0,0));\n        for(int i = 0;i < 55;i++){\n             \n            if(i != 0){\n                if(sc[i] != sc[i-1])\n                    G.push_back(Point(i,sc[i]));\n                 \n                G.push_back(Point(i+1,sc[i]));\n            }\n        }\n        G.push_back(Point(100,0));\n \n        for(int i = 0;i < G.size();i++){\n            //cout<<G[i].real()<<\" \"<<G[i].imag()<<endl;\n        }\n \n        double low = -100,high = 100;\n        int D = 100;\n        //cout<<sc[20]<<endl;\n        while(D--){\n            double mid = (low+high)/2;\n            Circle C = Circle(Point(30,mid),r);\n            double mi = INF;\n            for(int i = 0;i < G.size()-1;i++){\n                double dist = distanceSP(Line(G[i],G[i+1]),C.p);\n                mi = min(mi,dist);\n            }\n            //cout<<mid<<\" \"<<mi<<\" \"<<mid+r<<endl;\n            if(mi < r)high = mid;\n            else if(sc[30] < mid+r)high = mid;\n            else low = mid;\n        }\n        printf(\"%.4lf\\n\",low+r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  int tr, n;\n  while (true) {\n    cin >> tr >> n;\n    if (tr == 0 && n == 0) break;\n    double r = tr;\n\n    int bias = 20;\n    int x[41];\n    memset(x, 0, sizeof(x));\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n      xl += bias;\n      xr += bias;\n      for (int j = xl; j < xr; j++) {\n\tx[j] = max(x[j], h);\n      }\n    }\n\n    double ans = 1000;\n    for (int i = -r+1; i < 0; i++) {\n      ans = min(ans, x[i+bias-1]-sqrt(r*r-i*i)+r);\n    }\n    ans = min(ans, x[bias-1]-sqrt(r*r)+r);\n    for (int i = 0; i <= r-1; i++) {\n      ans = min(ans, x[i+bias]-sqrt(r*r-i*i)+r);\n    }\n\n    printf(\"%.5f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint R,N;\n\nvoid solve(){\n    vector<int> lx(N),rx(N),y(N);\n    for(int i=0;i<N;i++) cin>>lx[i]>>rx[i]>>y[i];\n\n    vector<int> high(2*R,0);\n    for(int i=0;i<N;i++){\n        for(int j=lx[i];j<rx[i];j++){\n            if(j<-R||j>=R) continue;\n            high[j+R]=max(high[j+R],y[i]);\n        }\n    }\n\n    vector<int> mi(2*R+1,100);\n    for(int i=0;i<=2*R;i++){\n        if(i-1>=0) mi[i]=min(mi[i],high[i-1]);\n        if(i<2*R) mi[i]=min(mi[i],high[i]);\n    }\n\n    double ans=10000.0;\n    for(int h=0;h<=2*R;h++){\n        double x=R-h;\n        double y2=R*R-x*x;\n        double z=sqrt(y2);\n        ans=min(ans,mi[h]-z+R);\n    }\n    cout<<fixed<<setprecision(10)<<ans<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>R>>N;\n      if(R==0&&N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=30;\nint xl[60];\nint xr[60];\n\nint main(void){\n\tint r,n;\n\twhile(cin >> r >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\trep(i,60) xl[i]=xr[i]=0;\n\t\trep(i,n){\n\t\t\tint l,r,h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tl+=offset,r+=offset;\n\t\t\tfor(int j=l;j<=r;++j){\n\t\t\t\tif(j!=l)\n\t\t\t\t\txl[j]=max(xl[j],h);\n\t\t\t\tif(j!=r)\n\t\t\t\t\txr[j]=max(xr[j],h);\n\t\t\t}\n\t\t}\n\t\tdouble cmin=inf;\n\t\tfor(int x=-r;x<=r;++x){\n\t\t\tint h=inf;\n\t\t\tif(x!=-r)h=min(h,xl[x+offset]);\n\t\t\tif(x!=r)h=min(h,xr[x+offset]);\n\n\t\t\tint diff=r*r-x*x;\n\t\t\tif(diff<0)\n\t\t\t\tcontinue;\n\t\t\tdouble y=sqrt(diff);\n\t\t\tdouble t=h-y+r;\n\t\t\tcmin=min(cmin,t);\n\t\t}\n\t\tcout.precision(9);\n\t\tcout << fixed << cmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nsigned main(){\n    int r,n;\n    while(cin>>r>>n,r||n){\n        int h[40]={0};\n        while(n--){\n            int xl,xr,hh;\n            cin>>xl>>xr>>hh;\n            xl+=20;xr+=20;\n            for(int i=xl;i<xr;i++)chmax(h[i],hh);\n        }\n\n        double ans=1001001001;\n        for(int i=0;i<40;i++){\n            int x=abs(i-20)+(i-20>=0?0:-1);\n            if(x>=r)continue;\n            double tmp=r-sqrt(1.0*(r*r-x*x));\n            chmin(ans,h[i]+tmp);\n        }\n        printf(\"%.20f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n#define EPS 1e-7\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ndouble high[66];\nint n,r;\n\nbool check(double mid){\n\tfor(int i = 30-r;i < 30+r;i++){\n\t\tDBG(cerr << \"hidh \" << i << ' ' << high[i] << ' ' << high[i+1] << endl;)\n\t\tif(i != 30-r && i != 30+r && high[i] < mid)return false;\n\t\tdouble A = sqrt((i-30)*(i-30) + (high[i]-mid)*(high[i]-mid));\n\t\tdouble B = sqrt((i-29)*(i-29) + (high[i]-mid)*(high[i]-mid));\n\t\tDBG(cerr << \"AB \" <<  A << ' ' << B << endl;)\n\t\tif(min(A,B) < r + EPS)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> r >> n,r|n){\n\t\t//初期\n\t\tREP(i,66)high[i] = 0;\n\t\t\n\t\t\n\t\tREP(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tfor(int j = a;j < b;j++){\n\t\t\t\thigh[j+30] = max(high[j+30],c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble tb = 100;\n\t\tdouble ub = -10;\n\t\tDBG(SHOW1d(high,66));\n\t\tREP(i,30){\n\t\t\tdouble mid = (tb + ub) / 2;\n\t\t\tDBG(cerr << endl << \"mid \" << mid << endl << endl;)\n\t\t\tif(check(mid))ub = mid;\n\t\t\telse tb = mid;\n\t\t}\n\t\t\n\t\tcout << Decimal << (double)(ub+r) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst double EPS = 1e-10;\n\nint r, n, xl[20], xr[20], h[20];\nint right[20], left[20]; // right:(i, i+1)  left:(-i-1, -i)\n\nbool ok(double height) {\n  for (int i = 0; i < r; i++) {\n    double temp = sqrt(r * r - i * i) + height;\n    if (temp - (double) right[i] > EPS) return false;\n    if (temp - (double) left[i] > EPS) return false;\n  }\n  return true;\n}\n\ndouble search() {\n  double lb = (double)-r, ub = 20.0;\n  while (ub > lb + EPS) {\n    double md = (lb + ub) / 2;\n    if (ok(md)) lb = md;\n    else ub = md;\n  }\n  return lb;\n}\n\nvoid inputright(int l, int r, int height) {\n  for (int i = l; i < r; i++) right[i] = max(right[i], height);\n}\n\nvoid inputleft(int l, int r, int height) {\n  for (int i = r; i > l; i--) left[-i] = max(left[-i], height);\n}\n\n\nint main() {\n  while (2)  {\n    scanf(\"%d%d\", &r, &n);\n    if (r == 0) break;\n    for (int i = 0; i < 21; i++) right[i] = left[i] = 0;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%d\", &xl[i], &xr[i], &h[i]);\n      if (xl[i] >= 0) inputright(xl[i], xr[i], h[i]);\n      else if (xr[i] <= 0) inputleft(xl[i], xr[i], h[i]);\n      else inputright(0, xr[i], h[i]), inputleft(xl[i], 0, h[i]);\n    }\n    printf(\"%f\\n\", (double) r + search());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1194\n//\n//  Created by 13B15237 on 2015/06/22.\n//  Copyright (c) 2015??´ 13B15237. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Rect {\n    int l, r;\n    int h;\n};\n\nstruct Point {\n    int x, y;\n};\n\nstruct Area {\n    bool table[21][41];\n    \n    void clear() {\n        for (int y = 0; y < 21; ++y) {\n            for (int x = -20; x < 21; ++x) {\n                table[y][x+20] = false;\n            }\n        }\n    }\n    \n    void draw(Rect rect) {\n        for (int y = 0; y < rect.h; ++y) {\n            for (int x = rect.l; x < rect.r; ++x) {\n                table[y][x + 20] = true;\n            }\n        }\n    }\n    \n    void show() {\n        for (int y = 20; y >= 0; --y) {\n            for (int x = -20; x < 21; ++x) {\n                cout << (table[y][x+20] == true ? '#' : '_');\n            }\n            cout << endl;\n        }\n    }\n    \n    bool test(int r, int t) {\n        const int ybegin = max(0, t - 2 * r);\n        const int yend = t;\n        \n        for (int y = ybegin; y < yend; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == false) return false;\n            }\n        }\n        return true;\n    }\n    \n    Point calcMinDistPoint(int r, int maxt) {\n        double mindist = 30.0;\n        Point p = {0, 0};\n        \n        for (int y = max(0, maxt - 2 * r); y < maxt; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == true) continue;\n                \n                const int a = x < 0 ? abs(x + 1) : x;\n                const int b = y;\n                double dist = sqrt(a*a + b*b);\n                //printf(\"(%d, %d) = %f\\n\", x,y,dist);\n                \n                if (dist < mindist) {\n                    mindist = dist;\n                    p.x = x;\n                    p.y = y;\n                }\n            }\n        }\n        return p;\n    }\n};\n\nint R, N;\nvector<Rect> vrect;\nArea area;\n\nint main(int argc, const char * argv[]) {\n    while (1) {\n        cin >> R >> N;\n        if (!R && !N) break;\n        \n        area.clear();\n        vrect.clear();\n        vrect.resize(N);\n        for (auto r : vrect) {\n            cin >> r.l >> r.r >> r.h;\n            area.draw(r);\n        }\n        \n        //area.show();\n        \n        int tmax;\n        for (tmax = 0; tmax < 21; ++tmax) {\n            if (area.test(R, tmax) == false) break;\n        }\n        \n        /*\n        double t = static_cast<double>(tmax - 1);\n        while (1) {\n            double d = area.calcMinDist(R, t, tmax);\n            if (d < static_cast<double>(R)) break;\n            t += 0.001;\n        }\n         */\n        Point p = area.calcMinDistPoint(R, tmax);\n        const int dx = p.x < 0 ? abs(p.x + 1) : abs(p.x);\n        double dy = sqrt(R * R - dx * dx);\n        \n        \n        //cout << \"p = (\" << p.x << \", \" << p.y << \")\" << endl\n        //<< \"dy = \" << dy << \", R  = \" << R << endl;\n        \n        double t;\n        if (dy < (double)R) {\n            t = ((double)(tmax + R - 1) - dy);\n        } else {\n            t = (double)p.y;\n        }\n        \n        printf(\"%.4f\\n\", t);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint H[40];\nint r, n;\n\ndouble sq(double d) {\n    return d * d;\n}\n\nbool ok(double t) {\n    for (int i = -r; i < r; i++) {\n        double h = max(sqrt(sq(r) - sq(i)), sqrt(sq(r) - sq(i + 1)));\n        if (h + t - r > H[i + 20]) { return false; }\n    }\n    return true;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &r, &n);\n\n        if (!r && !n) { break; }\n\n        for (int i = 0; i < 40; i++) { H[i] = 0; }\n\n        for (int i = 0; i < n; i++) {\n            int xl, xr, h;\n            scanf(\"%d%d%d\", &xl, &xr, &h);\n            for (int i = xl; i < xr; i++) { H[i + 20] = max(H[i + 20], h); }\n        }\n\n        double ub = 20;\n        double lb = 0;\n\n        for (int i = 0; i < 30; i++) {\n            double m = lb + (ub - lb) / 2;\n            if (ok(m)) { lb = m; }\n            else { ub = m; }\n        }\n\n        printf(\"%f\\n\", lb);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define MAX 30\n\nint R, n;\nint term=100000;\ndouble answer;\nstruct data{\n\tint l, r, h;\n};\ndata b[MAX];\n\nbool go(int m){\n\tint i, j;\n\tdouble x, y, t;\n\tbool flag;\n\tt=(double)m/term;\n\t\n\tfor (i=-R*term;i<=R*term;i++){ // x??  i/10000\n\t\tx=(double)i/term;\n\t\ty=-((double)R-t)+sqrt((double)(R*R)-(x*x));\n\t\tif (y<=0) continue;\n\t\tflag=false;\n\t\tfor (j=1;j<=n;j++){\n\t\t\tif (b[j].l*term<=i && b[j].r*term>=i){\n\t\t\t\tif (y<=b[j].h){\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag==false) return 0;\n\t}\n\treturn 1;\n}\n\nint main(void){\n\tint i;\n\tint f, l, mid;\n\tfor (;;){\n\t\tscanf(\"%d %d\", &R, &n);\n\t\tif (R+n==0) break;\n\t\tfor (i=1;i<=n;i++) scanf(\"%d %d %d\", &b[i].l, &b[i].r, &b[i].h);\n\t\tf=0, l=50*term;\n\t\tfor (;;){\n\t\t\tmid=(f+l)/2;\n\t\t\tif (go(mid)){\n\t\t\t\tanswer=(double)mid/term;\n\t\t\t\tf=mid+1;\n\t\t\t}else{\n\t\t\t\tl=mid-1;\n\t\t\t}\n\t\t\tif (f>l) break;\n\t\t}\n\t\tprintf(\"%.4lf\\n\", answer);\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <array>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <tuple>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <regex>\n#include <cstdint>\n#include <numeric>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\nusing ll = int64_t;\nusing ull = uint64_t;\n\nconstexpr ll INF = 1000000000;/* 1e+9a */\nnamespace utils{\n\n    class Repeater{\n        int st;\n        int ed;\n        int d;\n    public:\n        class rep_iterator{\n            int i; int d;\n        public:\n            rep_iterator(int x, int pd) :i(x), d(pd) {}\n\n            int& operator*(){ return i; }\n            bool operator==(const rep_iterator& k) const { return i == k.i; }\n            bool operator!=(const rep_iterator& k) const { return i != k.i; }\n            rep_iterator& operator++(){ i+=d; return *this; }\n        };\n\n        explicit Repeater(int N) :st(0), ed(N), d(1) {}\n        Repeater(int b, int e) :st(b), ed(e), d(1) {if(st > ed){ st--; ed--; d = -1; } }\n\n        rep_iterator begin() const{ return rep_iterator(st, d); }\n        rep_iterator end() const{ return rep_iterator(ed, d); }\n\n    };\n\n    template<class T, class Compare> using p_queue = priority_queue<T, vector<T>, Compare>;\n    template<class T> using min_queue = p_queue<T, greater<T>>;\n    template<class T> using max_queue = p_queue<T, less<T>>;\n\n    template<class T> bool min_update(T& X, const T& A){ if(X > A) {X = A; return true;} return false; }\n    template<class T> bool max_update(T& X, const T& A){ if(X < A) {X = A; return true;} return false; }\n#define ALL(x) begin(x), end(x)\n#define rALL(x) rbegin(x), rend(x)\n}\nusing namespace utils;\n\nunordered_map<int, double> init(vector<int> xl, vector<int> xr, vector<int> h, int R){\n    unordered_map<int, double> ans;\n    for (int i = -R; i < R; ++i) {\n        int mx = 0;\n        for (int j = 0; j < xl.size(); ++j) {\n            if(xl[j] <= i and xr[j] > i){\n                mx = max(h[j], mx);\n            }\n        } // end j\n        ans[i] = mx;\n    } // end i\n\n    return ans;\n\n}\n\nbool check(double t, int R, const unordered_map<int, double>& walls){\n    for (int x = -R; x < R; ++x) {\n        double y = sqrt(R*R-x*x) + t - R;\n        double y1 = sqrt(R*R - (x+1)*(x+1)) + t  - R;\n\n        if(walls.at(x) < y) return false;\n        if(walls.at(x) < y1) return false;\n    } // end x\n    return true;\n}\n\n\nvoid sub_main(istream &is) {\n    ll R, N;\n    is >> R >> N;\n    if(!is or R == 0) return;\n    vector<int> xl(N), xr(N), h(N);\n\n    for (int i = 0; i < N; ++i) {\n        is >> xl[i] >> xr[i] >> h[i];\n    } // end i\n\n    auto walls = init(xl, xr, h, R);\n\n    double ok = 0;\n    double NG = 20;\n    while(NG - ok > 0.000001 ){\n        double mid = (ok + NG) / 2.;\n        if(check(mid, R, walls)){\n            ok = mid;\n        }\n        else NG = mid;\n    }\n\n    cout << ok << endl;\n\n}\n\nint main(int argc, char *argv[]) {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << setprecision(7);\n#ifdef DEBUG\n    string test_cases = \"test_A.txt\";\n    cerr << \"DEBUG MODE\" <<  endl;\n    cerr << test_cases << \" -->\" << endl;\n    auto fs = fstream(test_cases, fstream::in);\n    int lp = 0;\n    while(fs) {\n        lp++;\n        cout << lp <<  \"#------\\n\";\n        sub_main(fs);\n    }\n    cout << \"------#\" << endl;\n    if(lp <= 1) sub_main(cin);\n#else\n    while(cin) sub_main(cin);\n#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<iomanip>\n#include<iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\n\nint main(){\n\tint R, n;\n\n\tcin >> R >> n;\n\twhile(!(R==0 && n==0) ){\n\t\tint pos[41][2]={ {0, 0} };\n\t\tint l, r, h;\n\t\tF(i, n){\n\t\t\tcin >> l >> r >> h;\n\t\t\tfor(int j=l+20; j<=r+20; j++){\n\t\t\t\tint tmph=h;\n\t\t\t\tif(j!=l+20 && j!=r+20){\n\t\t\t\t\tif(tmph > pos[j][0]){\n\t\t\t\t\t\tpos[j][0]=tmph;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmph > pos[j][1]){\n\t\t\t\t\t\tpos[j][1]=tmph;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(tmph > pos[j][0])swap(tmph, pos[j][0]);\n\t\t\t\t\tif(tmph > pos[j][1]){\n\t\t\t\t\t\tif(j!=0 && j==l+20){\n\t\t\t\t\t\t\tif(pos[j-1][1] > h){\n\t\t\t\t\t\t\t\tswap(tmph, pos[j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(j!=40 && j==r+20){\n\t\t\t\t\t\t\tif(pos[j+1][1] > h){\n\t\t\t\t\t\t\t\tswap(tmph, pos[j][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tswap(tmph, pos[j][1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble min=100;\n\t\tfor(int i=20-R+1; i<=20+R-1; i++){\n\t\t\tdouble tmp=pos[i][1]-sqrt(static_cast<double>(R*R-(i-20>0 ? i-20:20-i)*(i-20>0 ? i-20:20-i) ) );\n\t\t\tif(min > tmp)min = tmp;\n\t\t}\n\t\tif(min <= -R){\n\t\t\tmin = 0;\n\t\t}else{\n\t\t\tmin = min+R;\n\t\t}\n\t\tcout << fixed << setprecision(4) << min << endl;\n\n\t\tcin >> R >> n;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint R;\n\ndouble calc(double height){\n\treturn sqrt(fabs((double)R*(double)R - ((double)R-height)*((double)R-height)));\n}\n\n\nint main(){\n\n\tint N,left,right,height;\n\tbool map[21][41];\n\tbool FLG;\n\tdouble sun_right,sun_height,ans;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&R,&N);\n\t\tif(R == 0 && N == 0)break;\n\n\t\tfor(int i = 0; i <= 40; i++){\n\t\t\tfor(int k = 0; k <= 20; k++)map[k][i] = false;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d %d\",&left,&right,&height);\n\n\t\t\tfor(int a = 20+left; a <= 20+right-1; a++){\n\t\t\t\tfor(int b = 0; b < height; b++){\n\t\t\t\t\tmap[b][a] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(double time = 0.0001; time <= 20.0001; time += 0.0001){\n\t\t\tif(time <= (double)R*2.0){\n\t\t\t\tsun_height = time;\n\n\t\t\t\theight = (int)ceil(sun_height);\n\n\t\t\t\tFLG = true;\n\n\t\t\t\tfor(int h = 0; h < height; h++){\n\t\t\t\t\tsun_right = calc(sun_height-(double)(h));\n\t\t\t\t\tright = (int)ceil(sun_right);\n\t\t\t\t\tleft = -right;\n\n\t\t\t\t\tfor(int w = 20+left; w <= 20+right-1; w++){\n\t\t\t\t\t\tif(map[h][w] == false){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG)break;\n\t\t\t\t}\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tans = time - 0.0001;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\tsun_height = time;\n\n\t\t\t\theight = (int)ceil(sun_height);\n\n\t\t\t\tFLG = true;\n\n\t\t\t\tfor(int h = height-2*R; h < height; h++){\n\t\t\t\t\tsun_right = calc(sun_height-(double)(h));\n\t\t\t\t\tright = (int)ceil(sun_right);\n\t\t\t\t\tleft = -right;\n\n\t\t\t\t\tfor(int w = 20+left; w <= 20+right-1; w++){\n\t\t\t\t\t\tif(map[h][w] == false){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG)break;\n\t\t\t\t}\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tans = time - 0.0001;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\n\t\tint xl[20], xr[20], h[20];\n\t\tint sx = 21;\n\t\tint th = 0;\n\t\tint gx = -21;\n\t\tint t;\n\n\t\tfor (int i = 0; i < n;i++){\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (sx > xl[i] || (sx == xl[i] && th < h[i])){\n\t\t\t\tsx = xl[i];\n\t\t\t\tth = h[i];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t\tif (gx < xr[i]){\n\t\t\t\tgx = xr[i];\n\t\t\t}\n\t\t}\n\n\t\tmap<int, int> ma;\n\t\t\n\t\tfor (int x = -20; x <= 20; x++)ma[x] = 0;\n\t\tfor (int x = sx; x <= gx; x++){\n\n\t\t\tbool ef = false; int eh = -1;\n\t\t\tif (xr[t] == x){\n\t\t\t\tef = true; eh = 0;\n\t\t\t}\n\t\t\tint mh = th; int tt = t;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (xl[i] == x && mh < h[i]){\n\t\t\t\t\tmh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t\tif (x >= xl[i] && x < xr[i] && ef){\n\t\t\t\t\teh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mh != th){\n\t\t\t\tt = tt; th = mh;\n\t\t\t}else\n\t\t\tif (ef){\n\t\t\t\tth = eh; t = tt;\n\t\t\t}\n\t\t\tma[x] = th;\n\t\t}\n\t\t\n\t\tconst double PI = 3.14159265359;\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-6){\n\t\t\t\n\t\t\tdouble y = -double(r) + sqrt(r*r - x*x);\n\t\t\tint tx = (x >= 0 ? int(x) : int(x - (1.0 - 1e-7)));\n\t\t\tans = min(ans,double(ma[ tx  ]) - y);\n\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\nstring s[50],t[50];\nsigned main(){\n\tint n,m,r;\n\t/*\n\tdouble d;\n\tcin>>d;\n\t\n\tdouble ans=0;\n\tfor(int i=0;i<=10;i++){\n\t\tif(i>d) break;\n\t\tdouble ii=i+0.0;\n\t\tans=max(ans,sqrt(d*d-ii*ii));\n\t}\n\tprintf(\"%.10lf\\n\",ans);\n\t*/\n\t\n\twhile(1){\n\tcin>>r>>n;\n\t\t//int sumi[200]={0};\n\t\tif(n==0&&r==0) return 0;\n\t\tint a[100]={0};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x2,x1,h;\n\t\t\tcin>>x1>>x2>>h;\n\t\t\tfor(int i=x1+50+1;i<=x2+50;i++) a[i]=max(a[i],h);\n\t\t}\n\t\tint aa[100]={0};\n\t\tfor(int i=50-r-2;i<=r+50+2;i++) aa[i]=min(a[i],a[i+1]);\n\t\tdouble ans=1000000000;\n\t\tfor(int i=50-r;i<=50+r;i++){\n\t\t\tint d=i-50;\n\t\t\tdouble w=(r+0.0)-sqrt((r+0.0)*(r+0.0)-(d+0.0)*(d+0.0));\n\t\t\tans=min(ans,aa[i]+w)\t;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",ans);\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tdouble r;\n\t\tdouble center;\n\t\tdouble high;\n\t\tdouble answer = 20.0;\n\t\tdouble maxhigh = 0.0;\n\t\tdouble smallhigh = 0.0;\n\t\tint flag;\n\t\tint n;\n\t\tdouble xl[21] = {}, xr[21] = {}, h[21] = {};\n\n\t\tcin >> r >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (h[i] > maxhigh) {\n\t\t\t\tmaxhigh = h[i];\n\t\t\t}\n\t\t\tif (xl[i] <= -r && xr[i] >= r && smallhigh < h[i]) {\n\t\t\t\tsmallhigh = h[i];\n\t\t\t}\n\t\t}\n\n\t\tanswer = maxhigh;\n\n\n\t\tfor (double i = smallhigh; i <= maxhigh; i += 0.0001) {\n\t\t\tcenter = -r + i;\n\n\n\t\t\tfor (double j = 0; j <= r; j += 0.0001) {\n\t\t\t\thigh = sqrt(r*r - j * j) + center;\n\n\t\t\t\t\n\n\t\t\t\t//cout << center << \" \" << high << endl;\n\t\t\t\tflag = 0;\n\t\t\t\tFOR(k, 1, n) {\n\t\t\t\t\tif (xl[k] <= j && xr[k] >= j && high <= h[k]) {\n\t\t\t\t\t\tswitch (flag) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tflag = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (xl[k] <= -j && xr[k] >= -j && high <= h[k]) {\n\t\t\t\t\t\tswitch (flag) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tflag = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tflag = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (high <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (flag == 3) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (k == n) {\n\t\t\t\t\t\tanswer = i - 0.0001;\n\t\t\t\t\t\t//cout << j << \" \" << high << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (answer != maxhigh) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t\tif (answer != maxhigh) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\", answer);\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint build[20][40];\n\nvoid printbuild() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      if (build[i][j]) cout << \"#\";\n      else cout << \".\";\n    }\n    cout << endl;\n  }\n}\n\nvoid makeOut() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 1 - build[i][j];\n    }\n  }\n}\n\nbool touchingSun(long h, long i, double c, long r) {\n  return hypot(19 - h - c, i - 20) < r || hypot(19 - h - c, i - 19) < r;\n}\n\nbool touchingSunAll(double c, long r) {\n  for (int h = 0; h < 20; h++) {\n    for (int i = 0; i < 40; i++) {\n      if (build[h][i] && touchingSun(h, i, c, r)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid reset() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 0;\n    }\n  }\n}\n\nvoid fillbuild(long l, long r, long h) {\n  for (int i = 19; i >= 20 - h; i--) {\n    for (int j = l + 20; j < r + 20; j++) {\n      build[i][j] = 1;\n    }\n  }\n}\n\nvoid solve(long n, long r) {\n  reset();\n  long l, rr, h;\n  for (int i = 0; i < n; i++) {\n    cin >> l >> rr >> h;\n    fillbuild(l, rr, h);\n  }\n  makeOut();\n  // printbuild();\n  double c = -r;\n  double step = 0.01;\n  while (step > 0.00001) {\n    if (!touchingSunAll(c, r)) {\n      c += step;\n    } else {\n      c -= step;\n      step /= 2;\n    }\n  }\n  printf(\"%.4f\\n\", c + r);\n}\n\nint main() {\n  long n, r;\n  while (1) {\n    cin >> r >> n;\n    if (n + r) {\n      solve(n, r);\n    } else {\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n;\n    ld r;\n    while(cin>>r>>n,n){\n        vector<ld> xl(n);\n        vector<ld> xr(n);\n        vector<ld> h(n);\n        for(int i=0;i<n;i++) cin>>xl[i]>>xr[i]>>h[i];\n\n        vector<vector<int>> field(50,vector<int>(30,false));\n        for(int i=0;i<n;i++){\n            for(int j=xl[i];j<xr[i];j++){\n                for(int k=0;k<h[i];k++){\n                    field[j+20][k]=true;\n                }\n            }\n        }\n        ld res=1e9;\n        \n        function<ld(ld,ld)> height=[&](ld x,ld hei){\n            if(abs(x)>=r) return ld(1e9);\n            return hei-sqrt(double(r*r-x*x));\n        };\n        for(int i=0;i<50;i++){\n            int j=0;\n            for(;j<30;j++){\n                if(!field[i][j]) break;\n            }\n            ld hei=j;\n            ld l=i;\n            ld r=i+1;\n            res=min(res,ld(height(l-20,hei)));\n            res=min(res,ld(height(r-20,hei)));\n        }\n        cout<<fixed<<setprecision(7);\n        cout<<res+r<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r;\n  while(cin >> r >> n, n){\n    vector<double> V(2*r+1,0);\n    double xl, xr, h;\n    double ans = 1e9;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(abs(i+1-r) <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tdouble r;\n\t\tdouble center;\n\t\tdouble high;\n\t\tdouble answer = 20.0;\n\t\tdouble maxhigh = 0.0;\n\t\tdouble smallhigh = 0.0;\n\t\tint n;\n\t\tdouble xl[21] = {}, xr[21] = {}, h[21] = {};\n\n\t\tcin >> r >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (h[i] > maxhigh) {\n\t\t\t\tmaxhigh = h[i];\n\t\t\t}\n\t\t\tif (xl[i] <= -r && xr[i] >= r && smallhigh < h[i]) {\n\t\t\t\tsmallhigh = h[i];\n\t\t\t}\n\t\t}\n\n\t\tanswer = maxhigh;\n\n\n\t\tfor (double i = smallhigh; i <= maxhigh; i += 0.001) {\n\t\t\tcenter = -r + i;\n\n\n\t\t\tfor (double j = -r; j <= r; j += 0.001) {\n\t\t\t\thigh = sqrt(r*r - j * j) + center;\n\n\t\t\t\t\n\n\t\t\t\t//cout << center << \" \" << high << endl;\n\t\t\t\tFOR(k, 1, n) {\n\t\t\t\t\tif (xl[k] <= j && xr[k] >= j && high <= h[k]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (high <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (k == n) {\n\t\t\t\t\t\tanswer = i - 0.001;\n\t\t\t\t\t\t//cout << j << \" \" << high << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (answer != maxhigh) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t\tif (answer != maxhigh) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\", answer);\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint nextInt() { int d; cin >> d; return d; }\n\nconst double EPS = 10e-6;\n\nstruct Rect {\npublic:\n  int height;\n  int xl, xr;\n  \n  Rect() { }\n  Rect(int xl, int xr, int height):\n    xl(xl), xr(xr), height(height) { }\n};\n\nstruct Point {\npublic:\n  double y, x;\n  Point() { }\n  Point(double y, double x): y(y), x(x) { }\n};\n\nbool judge(const vector<Point>& point, const int r, const double y) {\n  for (int i = 0; i < point.size(); i++) {\n    double dsq = (point[i].x * point[i].x) + ((point[i].y - y) * (point[i].y - y));\n    if (r * r - dsq > 0) {\n      return false;\n    }\n  }\n  \n  return true;  \n}\n\nint main() {\n  while (true) {\n    int r = nextInt();\n    int n = nextInt();\n    if (r + n == 0) {\n      break;\n    }\n    vector<Rect> rect(n);\n    int ymax = -1;\n    for (int i = 0; i < n; i++) {\n      int xl = nextInt();\n      int xr = nextInt();\n      int h  = nextInt();\n      ymax = max(ymax, h);\n      rect[i] = Rect(xl, xr, h);\n    }    \n  \n    sort(rect.begin(), rect.end(), [](Rect a, Rect b) {\n      if (a.xl == b.xl) {\n        return a.xr < b.xr;\n      }\n      return a.xl < b.xl;\n    });\n    \n    for (int i = 0; i < n; i++) {\n      Rect& a = rect[i];\n      for (int j = i + 1; j < n; j++) {\n        Rect& b = rect[j];\n        if (a.xr > b.xr && a.xl < b.xl) {\n          // 3テ」ツ?、テ」ツ?ォテ」ツ?凖」ツつ?\n          rect.push_back(Rect(b.xr, a.xr, a.height));\n          a.xr = b.xl;\n        } else if (a.xr > b.xl) {\n          if (a.xl == b.xl) {\n             b.xl = a.xr;\n          } else if (a.xr == b.xr) {\n            a.xr = b.xl;            \n          }        \n        }\n      }\n    }\n    \n    vector<Point> point;\n    \n    point.push_back(Point(0, rect[0].xl));\n    point.push_back(Point(rect[0].height, rect[0].xl));\n    \n    for (int i = 1; i < rect.size(); i++) {\n      if (rect[i - 1].xr != rect[i].xl) {\n        point.push_back(Point(0, rect[i].xl));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xl));\n    }\n    \n    point.push_back(Point(0, rect[rect.size() - 1].xr));\n    point.push_back(Point(rect[rect.size() - 1].height, rect[rect.size() - 1].xr));\n    \n    for (int i = 0; i < rect.size() - 1; i++) {\n      if (rect[i + 1].xl != rect[i].xr) {\n        point.push_back(Point(0, rect[i].xr));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xr));\n    }\n    \n    double lt = 0, ht = ymax;\n    \n    for (int i = 0; i < 100; i++) {\n      double mt = (lt + ht) / 2;\n      double y = -r + mt;\n      if (judge(point, r, y)) {\n        lt = mt;\n      } else {\n        ht = mt;\n      }\n    }    \n    printf(\"%.15f\\n\", ht);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <math.h>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,n){\n\t\tdouble l=-R,r;\n\t\tint ma=0;\n\t\tvi in(50,0);\n\t\twhile(n--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tloop(i,a,b)in[i+25]=max(in[i+25],c);\n\t\t}\n\t\tloop(i,-R,R)ma=max(ma,in[i+25]);\n\t\tr=ma-R;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tbool q=true;\n\t\t\tloop(i,26-R,25+R){\n\t\t\t\tdouble dis=hypot(min(in[i],in[i-1])-h,i-25);\n//\t\t\t\tcout<<i-25<<\" \"<<dis<<endl;\n\t\t\t\tif(min(in[i],in[i-1])<h-R||dis+EPS<(double)R)q=false;\n\t\t\t}\n\t\t\tif(q)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.8f\\n\",l+R);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint R, N; \nint x1,x2,h;\nint B[50];\ndouble ans = 10000.0;\n\ndouble b(double x) {\n\treturn (double) B[(int) (x + 25.0)];\n\t\n}\n\ndouble sun(double x) {\n\tdouble r = R;\n\treturn sqrt(r * r - x * x) - r;\n}\n\ndouble f(double x) {\n\treturn b(x) - sun(x);\n}\n\nint main() {\n\tcin >> R >> N;\n\twhile(R + N) {\n\t\tans = 10000000.0;\n\t\tfor (int i = 0; i < 50; i ++) {\n\t\t\tB [i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x1 >> x2 >> h;\n\t\t\tx1 += 25;\n\t\t\tx2 += 25;\n\t\t\tfor (int x = x1; x < x2; x++ ) {\n\t\t\t\tB[x] = max(B[x], h);\n\t\t\t}\n\t\t}\n\t\tdouble r = R;\n\t\tfor (double x = -r; x < r; x += 0.00001) {\n\t\t\tans = min(ans, f(x));\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\tcin >> R >> N;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint _h[40], h[20];\n\ndouble calc()\n{\n\tconst auto PI = acos(-1.0);\n\tdouble res = 1e8;\n\tfor (int i = 0; i < 20; i++){\n\t\tdouble height = i < r ? sqrt(r * r - i * i) : -1e8;\n\t\tres = min(res, h[i] - height);\n\t}\n\treturn max(0.0, res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &r, &n), n){\n\t\tmemset(_h, 0, sizeof(_h));\n\t\tmemset(h, 0, sizeof(h));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tfor (int j = a + 20; j < b + 20; j++){\n\t\t\t\t_h[j] = max(_h[j], c);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 20; i++){\n\t\t\th[i] = min(_h[i + 20], _h[19 - i]);\n\t\t}\n\t\t\n\t\tprintf(\"%.20f\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-4\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n  \nint s[21][41];\nint main(void){\n    int r, n, xl, xr, h;\n    while(cin >> r >> n && r) {\n        rep(i, 11) rep(j, 41) s[i][j] = 0;\n        rep(i, n) {\n            cin >> xl >> xr >> h;\n            for(int y=0; y<h; ++y) {\n                for(int x=xl+20; x<xr+20; ++x) {\n                    s[y][x] = 1;\n                }\n            }\n        }\n        double mint = numeric_limits<double>::max();\n        rep(y, 21) {\n            for(int x=-r+20; x<r+20; ++x) {\n                if(s[y][x] == 0) {\n                    double t;\n                    if(x<20) t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n                    else t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n                    mint = min(mint, t);\n                }\n            }\n        }\n        printf(\"%.4lf\\n\", mint);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\ndouble calc(double h, double x, double r) {\n    return h + sqrt(r * r - x * x);\n}\n\n\nint main() {\n    int rad, n;\n    while (cin >> rad >> n, rad + n) {\n\tvector<int> X1(n), X2(n), Y(n);\n\tfor (int i = 0; i < n; i++) {\n\t    cin >> X1[i] >> X2[i] >> Y[i];\n\t}\n\tdouble l = 0, r = 1000, ans = 0.0;\n\twhile (abs(l - r) >= 1e-6) {\n\t    double mid = (l + r) / 2;\n\t    vector<bool> H(rad * 2, false);\n\t    for (int x = -rad; x < rad; x++) {\n\t\tif (max(calc(mid - rad, x, rad), calc(mid - rad, x + 1, rad)) <= 0) {\n\t\t    H[x + rad] = true;\n\t\t}\n\t    }\n\t    \n\t    \n\t    for (int i = 0; i < n; i++) {\n\t\tfor (int x = -rad; x < rad; x++) {\n\t\t    if (X1[i] <= x && x < X2[i]) {\n\t\t\tdouble mn = min(Y[i] - calc(mid - rad, x, rad), Y[i] - calc(mid - rad,  x + 1, rad));\n\t\t\tif (mn >= 0) {\n\t\t\t    H[rad + x] = true;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    bool ok = true;\n\t    for (int i = 0; i < rad * 2; i++) {\n\t\tok &= H[i];\n\t    }\n\t    if (ok) {\n\t\tans = mid;\n\t\tl = mid;\n\t    }\n\t    else {\n\t\tr = mid;\n\t    }\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nsigned main(){\n\twhile(true){\n\t\tint r=read(),n=read();\n\t\tif(r==0&&n==0) break;\n\t\t\n\t\tint xl[n],xr[n],h[n];\n\t\t\n\t\tREP(i,n){\n\t\t\txl[i]=read();\n\t\t\txr[i]=read();\n\t\t\th[i]=read();\n\t\t}\n\t\t\n\t\tint maxheight[2*r]={0};\n\t\t\n\t\tREP(i,n){\n\t\t\tfor(int j=-r;j<=r;j++){\n\t\t\t\tif(j<=xr[i]&&j>=xl[i]&&j+1<=xr[i]&&j+1>=xl[i]){\n\t\t\t\t\tmaxheight[j+r] = max(maxheight[j+r],h[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//REP(i,2*r) cout << maxheight[i];\n\t\t//cout << endl;\n\t\t\n\t\tfloat ans=0.000;\n\t\twhile(true){\n\t\t\tbool flag=true;\n\t\t\tREP(i,2*r){\n\t\t\t\tint x1=abs(i-r);\n\t\t\t\tint x2=abs(i+1-r);\n\t\t\t\tif(r*r-x1*x1 >= (maxheight[i]+r-ans)*(maxheight[i]+r-ans) || r*r-x2*x2 >= (maxheight[i]+r-ans)*(maxheight[i]+r-ans)){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false){\n\t\t\t\tcout << fixed << setprecision(5) << ans << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse ans+=0.000001;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint xl[25], xr[25], h[25];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint r, n;\n\t\tcin >> r >> n;\n\t\tif(!r && !n) break;\n\t\tREP(i, n) cin >> xl[i] >> xr[i] >> h[i];\n\n\t\tdouble hi = 60, low = 0;\n\t\tREP(i, 20) {\n\t\t\tdouble mid = (hi+low)/2;\n\t\t\t//cout << hi << \" \" << mid << \" \" << low << endl;\n\t\t\tbool flag = true;\n\t\t\tREP(j, 200000) {\n\t\t\t\tdouble x = -r + (double)(2+r)*j/200000;\n\t\t\t\tint ma = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif(xl[k] <= x && x <= xr[k]) {\n\t\t\t\t\t\tma = max(ma, h[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble H = sqrt(r*r-x*x) + mid - r;\n\t\t\t\t// cout << ma << \" \" << H << endls\n\t\t\t\tif(ma < H) {flag = false; break;}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << low << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int r, n;\n  while (cin >> r >> n, r) {\n    vector<int> mh(41, 0);\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n      xl += 20;\n      xr += 20;\n      for (int x = xl; x < xr; x++) {\n        mh[x] = max(mh[x], h);\n      }\n    }\n    double ans = 1e2;\n    for (int x = 20 - r + 1; x < 20 + r; x++) {\n      int l = abs(20 - x);\n      int h = min(mh[x - 1], mh[x]);\n      double d = r - sqrt(r * r - l * l);\n      ans = min(ans, d + h);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n;\n    ld r;\n    while(cin>>r>>n,n){\n        vector<ld> xl(n);\n        vector<ld> xr(n);\n        vector<ld> h(n);\n        for(int i=0;i<n;i++) cin>>xl[i]>>xr[i]>>h[i];\n\n        vector<vector<int>> field(50,vector<int>(30,false));\n        for(int i=0;i<n;i++){\n            for(int j=xl[i];j<xr[i];j++){\n                for(int k=0;k<h[i];k++){\n                    field[j+20][k]=true;\n                }\n            }\n        }\n        ld res=1e9;\n        \n        function<ld(ld,ld)> height=[&](ld x,ld hei){\n            if(abs(x)>=r) return ld(1e9);\n            return hei-sqrt(double(r*r-x*x));\n        };\n        for(int i=0;i<50;i++){\n            int j=0;\n            for(;j<30;j++){\n                if(!field[i][j]) break;\n            }\n            ld hei=j;\n            ld l=i;\n            ld r=i+1;\n            res=min(res,ld(height(l-20,hei)));\n            res=min(res,ld(height(r-20,hei)));\n        }\n        cout<<fixed<<setprecision(7);\n        cout<<(res==1e9 ? 0 : res+r)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\t\t\n\t\tmap<int, int> d;\n\t\tfor (int x = -21; x < 21; x++)d[x] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor (int x = xl; x < xr; x++)d[x] = max(d[x], h);\n\t\t}\n\n\t\tconst double PI = 3.14159265359;\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-5){\n\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\tint tx = (x >= 0 ? int(x) : int(x - (1.0 - 1e-7)));\n\t\t\tans = min(ans, double(d[tx]) - y);\n\n\t\t}\n\n\t\tcout << setprecision(6) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n, r, x1, x2, h;\n\twhile(scanf(\"%d%d\", &r, &n), r){\n\t\tmap<int,int> mp;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d\", &x1, &x2, &h);\n\t\t\tfor(int x = x1; x < x2; ++x){\n\t\t\t\tint &t = mp[x];\n\t\t\t\tt = max(t, h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1e99;\n\t\tfor(int x = -r; x < r; ++x){\n\t\t\tdouble p = (x < 0 ? x + 1 : x);\n\t\t\tans = min(ans, mp[x] + r - sqrt(r * r - p * p));\n\t\t}\n\n\t\tprintf(\"%f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <map>\nusing namespace std;\nint r,n,L,R,h,i,x;int main(){while(cin>>r>>n,r){map<int,int> A,B;for(i=0;i<n;i++){cin>>L>>R>>h;for(x=L;x<=R;x++){if(x!=R)A[x]=max(A[x],h);if(x!=L)B[x]=max(B[x],h);}}double res=99;for(i=-r;i<=r-1;i++){res=min(res,min(r-sqrt(r*r-i*i)+A[i],r-sqrt(r*r-(i+1)*(i+1))+B[i+1]));}cout<<res<<\"\\n\";}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\n\nint n,r;\ntypedef pair<int,int> P;\nmap<int,map<int,double> > height;\n\nbool judge(double base)\n{\n  for(int x=-r;x<r;x++)\n    {\n      double y=height[x][x+1]-base;\n      if(x*x+y*y<r*r)\n\t{\n\t  return true;\n\t}\n      if((x+1)*(x+1)+y*y < r*r)\n\t{\n\t  return true;\n\t}\n    }\n  return false;\n}\nint main(int argc,char const* argv[])\n{\n  while(cin >> r >> n && r)\n    {\n      height.clear();\n      double lx,rx,h;\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> lx >> rx >> h;\n\t  for(int x=lx;x<rx;x++)\n\t    {\n\t      height[x][x+1]=max(h,height[x][x+1]);\n\t    }\n\t}\n      bool end=false;\n      double base=-r;\n      double t=0.0,step=0.0001;\n      while(1)\n\t{\n\t  base+=step;\n\t  end=judge(base);\n\t  if(end) break;\n\t  t+=step;\n\t}\n      cout <<fixed << setprecision(9) << t << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#undef max\n#undef min\n\nbool field[41][22] = {false};\nbool field2[20][22] = { false };\nconstexpr int SUN_OFFSET_X = 20;\nint main() {\n\tint r, n;\n\twhile (std::cin >> r >> n && (r || n)) {\n\t\tstd::memset(field, false, sizeof(bool) * 41 * 22);\n\t\tstd::memset(field2, false, sizeof(bool) * 20 * 22);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x[2], h;\n\t\t\tstd::cin >> x[0] >> x[1] >> h;\n\t\t\tx[0] += SUN_OFFSET_X; x[1] += SUN_OFFSET_X;\n\t\t\t//?????§???????????¶???\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tfor (int k = x[0]; k < x[1]; k++) {\n\t\t\t\t\tfield[k][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstd::vector<double> circleHeights;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t//?°??????????????????????x?????????????????£????????????????????????????????¨??????????????????\n\t\t\tfor (int j = 0; j < 21; j++) {\n\t\t\t\tfield2[19 - i][j] = field[i][j] && field[39 - i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\t//?????????????????????x??§???y=0?????????????¢????\n\t\t\t//h^2 + i^2 = r^2 \n\t\t\t//h^2 = r^2 - i^2\n\t\t\tcircleHeights.push_back(-r + std::sqrt(r  * r - i * i));\n\t\t}\n\n\t\tstd::vector<int> heights;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tint h = 0;\n\t\t\tfor (h = 0; h < 21; h++) {\n\t\t\t\tif (!field2[i][h]) break;\n\t\t\t}\n\t\t\theights.push_back(h);\n\t\t}\n\n\t\t//??¢???\n\t\tdouble y = -0.001;\n\t\tbool isOk = false;\n\t\tdouble cy = 0;\n\t\tfor (int i = 0; i < 21 && !isOk; i++) {\n\t\t\tdouble dy = 0;\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\tdouble tmp = heights[j] - circleHeights[i] - y;\n\t\t\t\tif (tmp > 0) dy = std::min(dy == 0 ? 99999 : dy, tmp);\n\t\t\t}\n\t\t\tif (!dy) dy = 1;\n\n\t\t\ty += dy;\n\t\t\t//?????£???????????°????????¢???\n\t\t\tfor (int j = 0; j < circleHeights.size(); j++) {\n\t\t\t\t//??????x??§??¢?????????????????????\n\t\t\t\tif (std::abs(heights[j] - (circleHeights[j] + y)) < 0.001) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << y << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Point { double x,y; };\n\nconst int DIFF = 50;\nint r,n;\nbool bits[100][100];\n\nint main(){\n  while( cin >> r >> n, r|n ){\n    vector<Point> ps;\n    memset(bits,false,sizeof(bits));\n    rep(i,n) {\n      int xL,xR,h;\n      cin >> xL >> xR >> h;\n      xL += DIFF, xR += DIFF;\n      rep(y,h) REP(x,xL,xR) bits[y][x] = true;\n    }\n    rep(y,100){\n      REP(x,-r,r) if( !bits[y][x+DIFF] ) {\n\tps.push_back((Point){x,y});\n\tps.push_back((Point){x+1,y});\n      }\n      if( !ps.empty() ) break;\n    }\n    assert( !ps.empty() );\n    double mini = INT_MAX;\n    rep(i,(int)ps.size()) {\n      double X = ps[i].x;\n      double Y = sqrt( r * r - X * X );\n      mini = min(mini,ps[i].y-Y);\n    }\n    printf(\"%.10f\\n\",mini+r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//reference to\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1724480#1\n\n#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll r;\n  ll n;\n  while(cin >> r >> n ,r || n){\n    vector<ll> a(45,0);\n    ll l,u,h;\n    rep(i,n){\n      cin >> l >> u >> h; \n      l += 20;\n      u += 20;\n      REP(j,l,u){\n        a[j] = max(a[j],h);\n      }\n    } \n    double ans = 11000;\n    rep(i,40){\n      int x=abs(i-20)+(i-20>=0?0:-1);\n      if(x>=r)continue;\n      double tmp=r-sqrt(1.0*(r*r-x*x));\n      ans = min(ans,a[i]+tmp);\n    }\n    std::fcout(10) << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef long double ld;\n\nint main() {\n    std::cout<< std::setprecision(11) << std::fixed;\n    int r, n;\n    while(cin >> r >> n, r != 0 || n != 0) {\n        vi xl(n), xr(n), h(n);\n        REP(i, n) cin >> xl[i] >> xr[i] >> h[i];\n\n        vector<int> px;\n        px.push_back(-100);\n        px.push_back(-r);\n        px.push_back(0);\n        px.push_back(+r);\n        px.push_back(+100);\n        n = -1;\n        REP(i, xl.size()) {\n            px.push_back(xl[i]);\n            px.push_back(xr[i]);\n        }\n        sort(ALL(px));\n        px.erase(unique(ALL(px)), px.end());\n        vector<int> ph(px.size(), 0);\n        REP(k, px.size()) {\n            REP(i, xl.size()) {\n                int x = px[k];\n                if (xl[i] <= x && x < xr[i]) ph[k] = max(ph[k], h[i]);\n            }\n        }\n\n        // REP(i, ph.size()){  cout<< \"#\" << px[i] << \" - \" << ph[i] << endl; }\n\n        ld al = 0;\n        ld ar = 100;\n        ld eps = 0.00000001;\n        while(ar - al > eps) {\n            ld m = (al + ar) / 2;\n            bool ok = true;\n            REP(i, px.size() - 1) {\n                ld nl = px[i], nr = px[i + 1];\n                ld nh =  ph[i] - m + r;\n                nh = max(0.0L, nh);\n                // cout<< \"T=\" << m << \" Check:\" << nl << \",\" << nr << \" H:\" << nh << endl;\n                ld rl = r * r - nl * nl;\n                ld rr = r * r - nr * nr;\n                // cout<< \"=\" << rl << \",\" << rr << endl;\n \n                if (rl > nh * nh || rr > nh * nh) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) { al = m; /* cout<< \"OK\" << endl; */}\n            else { ar = m; /* cout<< \"NG\" << endl; */}\n        }\n        cout<< al << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nvoid solve(double r,int n){\n    vector<int> xl(n),xr(n),h(n);\n    map<int,int> H;\n    rep(i,n){\n        cin >> xl[i] >> xr[i] >> h[i];\n        for(int j=xl[i];j<xr[i];j++){\n            H[j] = h[i];\n        }\n    }\n\n    //for(auto p : H) cerr << p << endl;\n\n    double ans = 100;\n    for(int x=-r;x<=r;x++){\n        double y = min(H[x-1],H[x]);\n        if(x == -r) y = H[x];\n        if(x == r) y = H[x-1];\n        double t = y + r - sqrt(r*r-x*x);\n        ans = min(ans,t);\n        //cerr << x << \" \" << y << \" \" << t << endl;\n    }\n    cout << Double(ans) << endl;\n}\n\n\nint main(){\n    int r,n;\n    while(1){\n        cin >> r >> n;\n        if(!r and !n) break;\n        solve(r,n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int r,n;scanf(\"%d%d\",&r,&n),r;){\n\t\tint h[40]={};\n\t\trep(i,n){\n\t\t\tint x1,x2,a; scanf(\"%d%d%d\",&x1,&x2,&a);\n\t\t\tx1+=20;\n\t\t\tx2+=20;\n\t\t\tfor(int x=x1;x<x2;x++) h[x]=max(h[x],a);\n\t\t}\n\n\t\tdouble ans=100;\n\t\tfor(int x1=20-r;x1<20+r;x1++){\n\t\t\tint x2=x1+1;\n\t\t\tans=min(ans,h[x1]+r-max(sqrt(r*r-(x1-20)*(x1-20)),sqrt(r*r-(x2-20)*(x2-20))));\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\ntypedef long long ll;\n#define int ll\n#define rep(i,n) for(int i = 0;i < (n) ; i++) \n#define MP(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define INF LLONG_MAX/2\nusing namespace std;\nint MOD = 1000000007;\n\nsigned main(){\n    int r,n;\n    while(1){\n        cin >> r >> n;\n        if(r == 0 && n == 0)break;\n        int x1[20],x2[20],h[20];\n        int up[50]={0};\n        int rup[50]={0};\n        int lup[50]={0};\n        rep(i,n){\n            cin >> x1[i] >> x2[i] >> h[i];\n            lup[25+x1[i]] = max(lup[25+x1[i]],h[i]);\n            rup[25+x2[i]] = max(rup[25+x2[i]],h[i]);\n            for(int j = x1[i]+1;j < x2[i];j++){\n                up[25+j] = max(up[25+j],h[i]);\n            }\n        }\n        double ans = 10000.0;\n        for(int i = -r+1;i < r;i++){\n            //cerr << i << \" \" << r-sqrt(r*r-i*i)+max(up[25+i],min(lup[25+i],rup[25+i])) << endl;\n            ans = min(ans,r-sqrt(r*r-i*i)+max(up[25+i],min(lup[25+i],rup[25+i])));\n        }\n        cout << ans << endl;\n    }\n\n\n    \n    return 0;\n}\n\n// g++ -std=c++14 icpc2014_a.cpp\n// rm -r -f test;oj dl https://cf17-final-open.contest.atcoder.jp/tasks/cf17_final_a\n// rm -r -f test;oj dl http://agc034.contest.atcoder.jp/tasks/agc034_b\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\nint r,n,x,y,h,B[41]; \nCircle C;\n\ndouble sq(double a){ return a*a;}\n\nbool Check(double ans){\n  for(int i=1-C.r;i<C.r;i++){\n    int index=i+20;\n    int mh=min(B[index-1],B[index]);\n    double d=sq(0.0-(double)i)+sq(ans-(double)mh);\n    if(d<=(double)(C.r*C.r))return false;\n  }\n  return true;\n}\n \nint main()\n{\n  while(1){\n    cin>>r>>n;\n    if(r+n==0)break;\n    C.c.x=0;C.c.y=0,C.r=r;\n    for(int i=0;i<41;i++)B[i]=0;\n    for(int i=0;i<n;i++){\n      cin>>x>>y>>h;\n      for(int j=x;j<y;j++)B[j+20]=max(B[j+20],h);\n    }\n\n    double ans=-r;\n    for(double t=-r;t<=20.0;t+=0.0001){\n      if(!Check(t)){\n\tbreak;\n      }\n      ans=t;\n    }\n    printf(\"%.10f\\n\",ans+r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nconstexpr double eps = 1e-8;\n\nint main() {\n    int r, n;\n    cout << fixed << setprecision(5);\n    while(cin >> r >> n, r) {\n        vector<double> v(2*r+1);\n        vector<double> lh(2*r+1), rh(2*r+1), gh(2*r+1);\n        for(int i=0; i<n; ++i) {\n            int x1, x2;\n            double h;\n            cin >> x1 >> x2 >> h;\n            for(int j=x1+r; j<=x2+r; ++j) {\n                if(0 <= j && j < v.size()) {\n                    if(j == x1+r) {\n                        lh[j] = max(lh[j], h);\n                    } else if(j == x2+r) {\n                        rh[j] = max(rh[j], h);\n                    } else {\n                        gh[j] = max(gh[j], h);\n                    }\n                }\n            }\n        }\n        for(int i=0; i<v.size(); ++i) {\n            v[i] = max(gh[i], min(rh[i], lh[i]));\n        }\n        v[0] = v[2*r] = 100;\n        //cout << endl;\n        //for(int i=0; i<v.size(); ++i) {\n        //    cout << \"x = \" << i-r << \"   h = \" << v[i] << endl;;\n        //}\n        //cout << \"\\n\" << endl;\n        double L = -r, R = 1000;\n        for(int i=0; i<100; ++i) {\n            double c = (L+R)/2;\n            //cout << \"(L, R) = \" << L << \" \" << R << endl;\n            bool ok = true;\n            for(int i=0; i<v.size(); ++i) {\n                if(r > sqrt((i-r)*(i-r) + (c-v[i])*(c-v[i])) + eps) {\n                    ok = false;\n                    break;\n                } else if(c > v[i] + eps) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) {\n                L = c;\n            } else {\n                R = c;\n            }\n        }\n        if(L + r < eps) {\n            cout << 0 << endl;\n        } else {\n            cout << L + r << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, n){\n    vector<int> hl(50, 0), hr(50, 0);\n    for (int i = 0; i < n; i++) {\n      int xr, xl, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl + 1; j < xr; j++) {\n        hl[j + diff] = max(hl[j + diff], h);\n        hr[j + diff] = max(hr[j + diff], h);\n      }\n      hl[xl + diff] = max(hl[xl + diff], h);\n      hr[xr + diff] = max(hr[xr + diff], h);\n    }\n    double ans = 1e9;\n    for (int i = -r + 1; i < r; i++) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\n\nP e[100010];\nint D = 50000;\ndouble PI = acos(-1);\nint test(vector<G> &g,double t,double r){\n\tC c = C(P(0,-r+t),r);\n\tvector<P> chkPoint;\n\t\n\tfor(int i = 0 ; i < D ; i++){\n\t\tchkPoint.push_back(c.p+r*e[i]);\n\t}\n\tfor( auto p : chkPoint ){\n\t\tif( p.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tif( contains(g[j],p) != OUT  ){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nint main(){\n\tfor(int i = 0 ; i < D ; i++){\n\t\te[i] = P(cos(i*2.*PI/D),sin(i*2.*PI/D));\n\t}\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\tg.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl-1e-7,-1e-7},{xr+1e-7,-1e-7},{xr+1e-7,h+1e-7},{xl-1e-7,h+1e-7}});\n\t\t}\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint idx(int n){\n    if(n<0) return 20-n;\n    else return n;\n}\n\nbool isArive(vector<int>& w, int r, int time){\n    for(int i=-r+1; i<r; i++){\n        if(sqrt(r*r-i*i)-r+time/1e5 > w[idx(i)]){\n            return false;\n        }\n    }\n    return true;\n}\n\nint bin_search(vector<int>& w, int r, int imin, int imax){\n    if(imax <= imin){\n        return imax;\n    }else{\n        int imid = (imax+imin)/2;\n        if(isArive(w, r, imid)){\n            return bin_search(w, r, imid+1, imax);\n        }else{\n            return bin_search(w, r, imin, imid-1);\n        }\n    }\n}\n\n\nint main(){\n    while(1){\n        int r,n;\n        cin >> r >> n;\n        if(r==0) break;\n\n        vector<int> wall(41, 0); //(int coordinates)\n        for(int i=0; i<n; i++){\n            int xl,xr,h;\n            cin >> xl >> xr >> h;\n            for(int j=xl; j<xr; j++){\n                wall[idx(j)] = max(wall[idx(j)], h);\n            }\n        }\n        for(int i=19; i>=-19; i--){\n            wall[idx(i)] = min(wall[idx(i-1)], wall[idx(i)]);\n        }\n\n        int dmsec = bin_search(wall, r, 0, 40*1e5);\n        cout << fixed;\n        cout << setprecision(5);\n        cout << dmsec/1e5 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\n\t\tint xl[20], xr[20], h[20];\n\t\tint sx = 21;\n\t\tint th = 0;\n\t\tint gx = -21;\n\t\tint t;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (sx > xl[i] || (sx == xl[i] && th < h[i])){\n\t\t\t\tsx = xl[i];\n\t\t\t\tth = h[i];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t\tif (gx < xr[i]){\n\t\t\t\tgx = xr[i];\n\t\t\t}\n\t\t}\n\n\t\tmap<int, int> ma;\n\n\t\tfor (int x = -20; x <= 20; x++)ma[x] = 0;\n\t\tfor (int x = sx; x <= gx; x++){\n\n\t\t\tbool ef = false; int eh = -1;\n\t\t\tif (xr[t] == x){\n\t\t\t\tef = true; eh = 0;\n\t\t\t}\n\t\t\tint mh = th; int tt = t;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (xl[i] == x && mh < h[i]){\n\t\t\t\t\tmh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t\tif (x >= xl[i] && x < xr[i] && ef){\n\t\t\t\t\teh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mh != th){\n\t\t\t\tt = tt; th = mh;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (ef){\n\t\t\t\t\tth = eh; t = tt;\n\t\t\t\t}\n\t\t\tma[x] = th;\n\t\t}\n\n\t\tconst double PI = 3.14159265359;\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-5/2.0){\n\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\tint tx = (x >= 0 ? int(x) : int(x - (1.0 - 1e-6)));\n\t\t\tans = min(ans, double(ma[tx]) - y);\n\n\t\t}\n\n\t\tcout << setprecision(30) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N, R;\n\nVI XLS, XRS;\nVI HS;\n\nVVI find_max_hs() {\n    VVI max_hs(41, VI(2));\n    \n    rep(i, N) {\n        REP(x, XLS[i], XRS[i] + 1) {\n            rep(lr, 2) {\n                if (!lr && x == XLS[i]) continue;\n                if (lr && x == XRS[i]) continue;\n\n                max_hs[20 + x][lr] = max(max_hs[20 + x][lr], HS[i]);\n            }\n        }\n    }\n\n    return max_hs;\n}\n\ndouble calc(double h, double x) {\n    double r = R;\n    double A = h + r;\n\n    double a = 1;\n    double b = -2. * A;\n    double c = A * A + x * x - r * r;\n\n    double p = b * b - 4. * a * c;\n    if (p < 0) return DINF;\n\n    double ans = (-1. * b - sqrt(p)) / 2.;\n\n    return ans;\n}\n\ndouble solve() {\n    VVI max_hs = find_max_hs();\n\n    double anst = DINF;\n\n    for (int x = -1 * R; x <= R; x++) {\n        for (int lr = 0; lr < 2; lr++) {\n            if (!lr && x == -1 * R) continue;\n            if (lr && x == R) continue;\n\n            int h = max_hs[20 + x][lr];\n            double t = calc(h, abs(x));\n            anst = min(anst, t);\n        }\n    }\n\n    return anst;\n}\n\nint main(void) {\n    while (cin >> R >> N, R) {\n        XLS.clear();\n        XRS.clear();\n        HS.clear();\n\n        XLS.resize(N);\n        XRS.resize(N);\n        HS.resize(N);\n\n        for (int i = 0; i < N; i++) {\n            cin >> XLS[i] >> XRS[i] >> HS[i];\n        }\n\n        printf(\"%.4f\\n\", solve());\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r, h;\n  double xl, xr, ans;\n  vector<int> V(41,0);\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint r;\n\tint n;\n\twhile (cin >> r >> n, r){\n\t\tdouble hight[40] = {0};\n\t\tdouble suny[41];\n\t\tREP(i, 41)\n\t\t\tsuny[i] = -1e9;\n\t\tREP(i, 41){\n\t\t\tif (-r<=i - 20&&i-20<=r )\n\t\t\t\tsuny[i] = -(double)r + sqrt((double)r*(double)r - (double)(i - 20)*(double)(i - 20));\n\t\t}\n\t\tREP(i, n){\n\t\t\tint x, x2, h;\n\t\t\tcin >> x >> x2 >> h;\n\t\t\tREP(i,x2-x){\n\t\t\t\thight[x + 20+i] = max(hight[x + 20+i], (double)h);\n\t\t\t}\n\t\t}\n\t\tdouble mi = 1e9;\n\t\tREP(i, 41){\n\t\t\tif (abs(i - 20) <= r){\n\t\t\t\tif (i - 20==-r)\n\t\t\t\t\tmi = min(mi, hight[i] -suny[i]);\n\t\t\t\tif (i - 20==r)\n\t\t\t\t\tmi = min(mi, hight[i-1] - suny[i]);\n\t\t\t\telse\n\t\t\t\t\tmi = min(mi, min(hight[i],hight[i-1]) - suny[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", mi);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef long double ld;\n\nint main() {\n    std::cout<< std::setprecision(11) << std::fixed;\n    int r, n;\n    while(cin >> r >> n, r != 0 && n != 0) {\n        vi xl(n), xr(n), h(n);\n        REP(i, n) cin >> xl[i] >> xr[i] >> h[i];\n\n        vector<int> px;\n        px.push_back(-100);\n        px.push_back(-r);\n        px.push_back(0);\n        px.push_back(+r);\n        px.push_back(+100);\n        n = -1;\n        REP(i, xl.size()) {\n            px.push_back(xl[i]);\n            px.push_back(xr[i]);\n        }\n        sort(ALL(px));\n        px.erase(unique(ALL(px)), px.end());\n        vector<int> ph(px.size(), 0);\n        REP(k, px.size()) {\n            REP(i, xl.size()) {\n                int x = px[k];\n                if (xl[i] <= x && x < xr[i]) ph[k] = max(ph[k], h[i]);\n            }\n        }\n\n        // REP(i, ph.size()){  cout<< \"#\" << px[i] << \" - \" << ph[i] << endl; }\n\n        ld al = 0;\n        ld ar = 100;\n        ld eps = 0.00000001;\n        while(ar - al > eps) {\n            ld m = (al + ar) / 2;\n            bool ok = true;\n            REP(i, px.size() - 1) {\n                ld nl = px[i], nr = px[i + 1];\n                ld nh =  ph[i] - m + r;\n                nh = max(0.0L, nh);\n                // cout<< \"T=\" << m << \" Check:\" << nl << \",\" << nr << \" H:\" << nh << endl;\n                ld rl = r * r - nl * nl;\n                ld rr = r * r - nr * nr;\n                // cout<< \"=\" << rl << \",\" << rr << endl;\n \n                if (rl > nh * nh || rr > nh * nh) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) { al = m; /* cout<< \"OK\" << endl; */}\n            else { ar = m; /* cout<< \"NG\" << endl; */}\n        }\n        cout<< al << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 114514\n\n#define IN 1\n#define OUT 2\n\nusing Data = pair<int, double>;\nusing Pair = pair<int, Data>;\nusing Seg = pair<int, int>;\n\nint n;\ndouble r;\nvector<Pair> es;\nmap<Seg, double> mp;\n\nbool check(double t) {\n  for (auto &itr : mp) {\n    Seg s = itr.first;\n    int a = s.first;\n    int b = s.second;\n    if (b <= -r || r <= a) continue;\n\n    int mid = 0;\n    if (b <= 0) mid = b;\n    else if (a >= 0) mid = a;\n\n    if (sqrt(r*r - double(mid)*mid)-r+t > itr.second) return false;\n  }\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%lf%d\", &r, &n);\n    if (r == 0 && n == 0) return 0;\n    es.clear();\n    for (int i=0; i<n; i++) {\n      int l, r;\n      double h;\n      scanf(\"%d%d%lf\", &l, &r, &h);\n      es.emplace_back(Pair(l, Data(IN, h)));\n      es.emplace_back(Pair(r, Data(OUT, h)));\n    }\n    sort(es.begin(), es.end());\n\n    multiset<double> hs;\n    hs.insert(0.0);\n    int prevx = -INF;\n    mp.clear();\n    for (auto &pa : es) {\n      int x = pa.first;\n      int type = pa.second.first;\n      double h = pa.second.second;\n\n      if (prevx != x) {\n        mp[Seg(prevx, x)] = *hs.rbegin();\n      }\n\n      if (type == IN) {\n        hs.insert(h);\n      } else {\n        hs.erase(hs.find(h));\n      }\n      prevx = x;\n    }\n\n    if (prevx < r) {\n      mp[Seg(prevx, r)] = 0;\n    }\n\n    double low = 0.0;\n    double high = INF;\n    for (int i=0; i<40; i++) {\n      double mid = (low+high)/2;\n      if (check(mid)) low = mid;\n      else high = mid;\n    }\n    printf(\"%.10f\\n\", low);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\nint r,n;\nint xl,xr,h;\ndouble ans;\nbool b[22][42];\n\ndouble check1(int i){\n\tif(i == 20-r){\n\t\tif(!b[0][i])return 0;\n\t\tfor(int j = 1;j < 22;j++){\n\t\t\tif(!b[j][i]) return j-1;\n\t\t}\n\t}\n\telse if(i == 20+r){\n\t\tif(!b[0][i-1])return 0;\n\t\tfor(int j = 1;j < 22;j++){\n\t\t\tif(!b[j][i-1]) return j-1;\n\t\t}\n\t}\n\telse{\n\t\tif(!(b[0][i] && b[0][i-1]))return 0;\n\t\tfor(int j = 1;j < 22;j++){\n\t\t\tif(!(b[j][i] && b[j][i-1]))return j-1;\n\t\t}\n\t}\n}\n\ndouble check2(int i){\n\tdouble x;\n\tif(i == 20-r || i == 20+r)return r;\n\telse if(i == 20)return 0;\n\tif(i < 20){\n\t\tx = r - (20 - i);\n\t}\n\telse{\n\t\tx = r - (i - 20);\n\t}\n\treturn r - sqrt((r*r) - (x*x));\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> r >> n;\n\t\tif(r == 0)break;\n\t\tans = 100;\n\t\tfor(int i = 0;i < 22;i++){\n\t\t\tfor(int j = 0;j < 42;j++){\n\t\t\t\tb[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xl >> xr >> h;\n\t\t\txl += 20;\n\t\t\txr += 20;\n\t\t\tfor(int i = 0;i <= h;i++){\n\t\t\t\tfor(int j = xl;j < xr;j++){\n\t\t\t\t\tb[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 20-r;i <= 20+r;i++){\n\t\t\tans = min(check1(i) + check2(i),ans);\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rect {\n    int l, r, h;\n\n    Rect(){}\n    ~Rect(){}\n\n    Rect (int a, int b, int c):\n        l(a), r(b), h(c) {}\n\n    bool operator < (const Rect& o) const {\n        return r == o.r ? l < o.l : r < o.r;\n    }\n};\n\nint main() {\n    while (true) {\n        int r, n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0){\n            break;\n        }\n\n        vector<Rect> rects(n);\n\n        for (int j = 0; j < n; ++j) {\n            cin >> rects[j].l >> rects[j].r >> rects[j].h;\n        }\n\n        sort(begin(rects), end(rects));\n\n        int dum[100];\n        int* heights = dum + 50;\n        fill(dum, dum + 100, 0);\n\n        for (int j = 0; j < n; ++j) {\n            for (int x = 2 * rects[j].l; x <= 2 * rects[j].r; ++x) {\n                heights[x] = max(heights[x], rects[j].h);\n            }\n        }\n\n        heights[-2*r-1] = numeric_limits<int>::max();\n        heights[2*r+1] = numeric_limits<int>::max();\n\n\n        double ret = numeric_limits<double>::max();\n\n        for (int j = 0; j < n; ++j) {\n            for (int x = -2 * r; x <= 2 * r; x += 2) {\n                double h = min(heights[x], min(heights[x-1], heights[x+1]));\n                ret = min(ret, h + r - sqrt(r * r - x * x / 4));\n            }\n        }\n\n        printf(\"%.12f\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nint hm[43];\nint r,n;\n\nint main() {\n  while(cin>>r>>n,r){\n    REP(i,43) hm[i]=0;\n    REP(i,n){\n      int xl,xr,h;\n      cin>>xl>>xr>>h;\n      for(int i=xl+21;i<xr+21;++i) hm[i]=max(hm[i],h);\n    }\n    double mx=21;\n    for(int i=21-r;i<=21+r;++i) mx=min(mx,min(hm[i-1],hm[i])+r-sqrt(r*r-(i-21)*(i-21)));\n    cout<<setprecision(10)<<fixed<<mx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\nint main(){\n  int n,m;\n  double r;\n  while(cin>>r>>n,n+r){\n    int h[50]={};\n    seg s[50];\n    r(i,50)s[i].p1.x=i,s[i].p1.y=0,s[i].p2.y=0,s[i].p2.x=i+1;\n    r(i,n){\n      int a,b,c;\n      cin>>a>>b>>c;\n      for(int i=a+25;i<b+25;i++)\n        s[i].p1.y=s[i].p2.y=max(s[i].p1.y,(double)c);\n    }\n  int p=0,t=0;\n    Point time;\n    time.x=25;\n    time.y=-r;\n    double d=0;\n    while(1){\n      r(i,50)if((getDistanceSP(s[i],time)<(double)r-EPS)){\n        printf(\"%.4f\\n\",d-0.0001);\n        goto L;\n      }\n      d+=0.0001;\n      time.y+=0.0001;\n    }\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-5\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(inct (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R-eps)return false;\n\tif(y<c-R+eps)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint build[20][40];\n\nvoid printbuild() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      if (build[i][j]) cout << \"#\";\n      else cout << \".\";\n    }\n    cout << endl;\n  }\n}\n\nvoid makeOut() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 1 - build[i][j];\n    }\n  }\n}\n\nbool touchingSun(long h, long i, double c, long r) {\n  return hypot(19 - h - c, i - 20) < r || hypot(19 - h - c, i - 19) < r;\n}\n\nbool touchingSunAll(double c, long r) {\n  for (int h = 0; h < 20; h++) {\n    for (int i = 0; i < 40; i++) {\n      if (build[h][i] && touchingSun(h, i, c, r)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid reset() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 0;\n    }\n  }\n}\n\nvoid fillbuild(long l, long r, long h) {\n  for (int i = 19; i >= 20 - h; i--) {\n    for (int j = l + 20; j < r + 20; j++) {\n      build[i][j] = 1;\n    }\n  }\n}\n\nvoid solve(long n, long r) {\n  reset();\n  long l, rr, h;\n  for (int i = 0; i < n; i++) {\n    cin >> l >> rr >> h;\n    fillbuild(l, rr, h);\n  }\n  makeOut();\n  // printbuild();\n  double c = -r;\n  double step = 0.0005;\n  while (!touchingSunAll(c, r)) c += step;\n  printf(\"%.4f\\n\", c + r);\n}\n\nint main() {\n  long n, r;\n  while (1) {\n    cin >> r >> n;\n    if (n + r) {\n      solve(n, r);\n    } else {\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int r;\n    int n;\n    while (cin >> r >> n, r | n)\n    {\n        vector<pair<pair<int, int>, int>> bd(n);\n        for (int i = 0; i < n; i++)\n        {\n            int a, b, h;\n            cin >> a >> b >> h;\n            bd[i] = make_pair(make_pair(a, b), h);\n        }\n\n        sort(bd.begin(), bd.end());\n        set<pair<int, int>> check;\n        vector<int> height(41);\n        for (int i = 0; i < n; i++)\n        {\n            int start = bd[i].first.first + 20;\n            int end = bd[i].first.second + 20;\n            int h = bd[i].second;\n            for (int j = start; j < end; j++)\n            {\n                height[j] = max(height[j], h);\n            }\n        }\n\n        for (int i = 0; i < 40; i++)\n        {\n            if (height[i] != height[i + 1])\n            {\n                check.insert(make_pair(i + 1 - 20, max(height[i], height[i + 1])));\n                check.insert(make_pair(i + 1 - 20, min(height[i], height[i + 1])));\n            }\n        }\n        check.insert(make_pair(0, max(height[20], height[19])));\n        // cout << \"=======\" << endl;\n\n        // for (int i = 0; i < 40; i++)\n        // {\n        //     cout << height[i] << '\\t';\n        // }\n        // cout << endl;\n        // for (int i = 0; i < 40; i++)\n        // {\n        //     cout << height[i] << '\\t';\n        // }\n        // cout << endl;\n        // for (auto x : check)\n        // {\n        //     cout << x.first << \" \" << x.second << endl;\n        // }\n        // cout << \"=======\" << endl;\n\n        double t = 0;\n        const double dt = 0.0005;\n        while (1)\n        {\n            int found = 0;\n            t += dt;\n            double xc = 0.0;\n            double yc = t - (double)r;\n            for (auto x : check)\n            {\n                double xd = (double)x.first;\n                double yd = (double)x.second;\n                if ((xd - xc) * (xd - xc) + (yd - yc) * (yd - yc) < (double)(r * r))\n                {\n                    found = 1;\n                    break;\n                }\n            }\n            if (found)\n                break;\n        }\n        cout << fixed << setprecision(10) << t - dt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<pii> vp;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e18:1e9+10;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,R){\n\t\tvi in(60);\n\t\trep(i,n){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta+=30;b+=30;\n\t\t\tloop(j,a,b)in[j]=max(in[j],c);\n\t\t}\n\t\tdouble l=0,r=21;\n\t//\trep(i,60)cout<<\" \"<<in[i];cout<<endl;\n\t\twhile(r-l>0.0001){\n\t\t\tdouble h=(l+r)/2;\n\t\t\tbool H=true;\n\t\t\trep(q,50){\n\t\t\t\tint t=q-25;\n\t\t\t\tif(abs(t)>R)continue;\n\t\t\t\tint hi=min(in[t+29],in[t+30]);\n\t\t\t\tif(t==R)hi=in[t+29];\n\t\t\t\telse if(-t==R)hi=in[t+30];\n\t\t\t\tif(h-R>hi)H=false;\n\t\t\t\tif(R*R>t*t+(hi-(h-R))*(hi-(h-R)))H=false;\n\t\t\t}\n//\t\t\tcout<<shosu(4)<<h<<\" \"<<H<<endl;\n\t\t\tif(H)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tcout<<shosu(9)<<l<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100;\nint HH[MAXN];\nint* H = HH+(MAXN/2);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int r, n;\n    while (cin >> r >> n) {\n        if (r == 0 && n == 0) break;\n        memset(HH, 0, sizeof(HH));\n        for (int i = 0; i < n; i++) {\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            for (int x = 2*xl; x < 2*xr; x++) {\n                H[x] = max(H[x], h);\n            }\n            if (xr == r) H[2*xr] = max(H[2*xr], h);\n            if (xl == -r) H[2*xl] = max(H[2*xl], h);\n        }\n        double ans = 1e9;\n        for (int x = -2*r; x <= 2*r; x++) {\n            if (x%2 == 0) {\n                int X = x/2;\n                double p = r-sqrt(r*r-X*X);\n                ans = min(ans, H[x]+p);\n            } else {\n                int X = (x+1)/2;\n                {\n                    double p = r-sqrt(r*r-X*X);\n                    ans = min(ans, p+H[x]);\n                }\n                X--;\n                {\n                    double p = r-sqrt(r*r-X*X);\n                    ans = min(ans, p+H[x]);\n                }\n            }\n            cout << x << \"  \" << ans << endl;\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nconst double infty = 100000;\nbool c[50][50];\ndouble k[50][50];\nint n;\nint r;\n\n// const int d[4][2] = { {0,1}, {0,-1}, {1,0}, {-1,0} }; \n\nbool isedge(int x, int y) {\n  return c[x][y] != c[x-1][y] || c[x][y] != c[x][y-1]; \n}\n/* 独流でここに辿り着くまで時間がかかった。\n   今後のために解法をまとめておく。\n   ・境界の格子点がいつ円と交わるかを計算する。最小値が答え。(これはすぐ思いついた)\n   ・塗ってあるパネルは、左下の頂点で管理する。ここで重要なのは半開区間で塗りつぶすことだ。閉区間だと隙間があるとき判定できない。(冷静になるまで時間がかかった)\n   ・すると境界の判定は上記のようにできる。\n */\n\nint main() {\n  while (scanf(\"%d%d\", &r, &n) != EOF && r && n) {\n    fill(&c[0][0], &c[0][0]+50*50, false);\n    for (int x=0; x<50; x++) {\n      c[x][0] = true;\n    }\n    fill(&k[0][0], &k[0][0]+50*50, infty);\n    for (int k=0; k<n; k++) {\n      int x_l, x_r, h;\n      scanf(\"%d%d%d\", &x_l, &x_r, &h);\n      x_l += 25;\n      x_r += 25;\n      h += 1;\n      for (int x=x_l; x<x_r; x++) {\n\tfor (int y=1; y<h; y++) {\n\t  c[x][y] = true;\n\t}\n      }\n    }\n    double ans = infty;\n    for (int x=26-r; x<25+r; x++) {\n      for (int y=1; y<30; y++) {\n\tif (isedge(x, y)) {\n\t  k[x][y] = r + y - 1 - sqrt(r*r - (25-x)*(25-x));\n\t  /*if (k[x][y] < 3) {\n\t    cerr << \"x = \" << x-25 << \", y = \" << y-1 << \", k[x][y] = \" << k[x][y] << endl;\n\t    }*/\n\t  if (ans > k[x][y]) {\n\t    ans = k[x][y];\n\t  }\n\t}\n      }\n    }\n    printf(\"%.4f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<vector<int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PIII;\n\nint main(void) {\n    while(true) {\n        int r, n;\n        cin >> r >> n;\n        if (r == 0) {\n            break;\n        }\n        vector<PII> table(41, make_pair(0, 0));         \n        for (int i = 0; i < n; i++) {\n            int l;\n            int r;\n            int h;\n            cin >> l >> r >> h;\n            l += 20;\n            r += 20;\n            table[l].second = max(table[l].second, h);\n            table[r].first = max(table[r].first, h);\n            for (int j = l + 1; j <= r - 1; j++) {\n                table[j].first = max(table[j].first, h);\n                table[j].second = max(table[j].second, h);\n            }\n        }\n        /*\n        for (int i = 0; i <= 40; i++) {\n            cout << table[i].first << \" \" << table[i].second << endl;\n        }\n        */\n        double min_dist = (double)(1e09);\n        int min_h;\n        double sun_y;\n\n\n        for (int i = 20 - r; i <= 20 + r; i++) {\n            if (i == 20 - r) {\n                min_h = table[i].second;\n            } else if (i == 20 + r) {\n                min_h = table[i].first;\n            } else {\n                min_h = min(table[i].first, table[i].second);\n            }\n            sun_y = (double)(sqrt(r * r - (i - 20) * (i - 20))) - (double)r;\n            //cout << i << \" \" << min_h << \" \" << sun_y << endl;\n            if (min_dist > min_h - sun_y) {\n                min_dist = min_h - sun_y;\n            }\n        }\n        printf(\"%.4f\\n\", min_dist);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 1000000007;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  while(true){\n    double r;\n    LL n;\n    cin >> r >> n;\n    if (r == 0)\n    {\n      break;\n  }\n  vector<double> plusH(21,0);\n  vector<double> minusH(21,0);\n  \n  REP(i,n){\n    LL xl, xr;\n    double H;\n    cin >> xl >> xr >> H;\n    if(xl<=0&&xr<=0){\n      for (LL i = -xr; i < -xl;++i){\n        minusH[i] = max(minusH[i], H);\n      }\n    }else\n    if(xl<=0&&xr>=0){\n      for (LL i = 0; i < xr;++i){\n        plusH[i] = max(plusH[i], H);\n      }\n      for (LL i = 0; i < -xl;++i){\n        minusH[i] = max(minusH[i], H);\n      }\n    }else\n    if(xl>=0&&xr>=0){\n      for (LL i = xl; i < xr;++i){\n        plusH[i] = max(plusH[i], H);\n      }\n    }\n  }\n\n  double mint = 1e10;\n  \n  REP(i,r){\n    double starty = -(r-sqrt(r * r - i * i));\n\n    double tt = min({plusH[i] - starty, minusH[i] - starty});\n    mint = min({mint, tt});\n  }\n\n  cout << max(0.,mint) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tR -= eps;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    while(1){\n        int r, n; cin>>r>>n;\n        if(r == 0) return 0;\n\n        vector<int> height(130, 0);\n\n        for(int i=0; i<n; i++){\n            int xl, xr, h; cin>>xl>>xr>>h;\n            xl += 100;\n            xr += 100;\n\n            for(int j=xl; j<xr; j++){\n                height[j] = max(height[j], h);\n            }\n        }\n\n        vector<int> fheight(130, 0);\n        for(int i=75; i<=125; i++){\n            fheight[i] = min(height[i], height[i-1]);\n        }\n\n        double ans = 1e9;\n        for(int i=100-r+1; i<100+r; i++){\n            double sum = fheight[i] + 1. * (r - sqrt(r * r - abs(100 - i) * abs(100 - i)));\n            ans = min(ans, sum);\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst double EPS = 1e-10;\n\nint r, n, xl[20], xr[20], h[20];\nint right[20], left[20]; // right:(i, i+1)  left:(-i-1, -i)\n\nbool ok(double height) {\n  for (int i = 0; i < r; i++) {\n    double temp = sqrt(r * r - i * i) + height;\n    if (temp - (double) right[i] > EPS) return false;\n    if (temp - (double) left[i] > EPS) return false;\n  }\n  return true;\n}\n\ndouble search() {\n  double lb = (double)-r, ub = (double)r;\n  while (ub > lb + 0.000001) {\n    double md = (lb + ub) / 2;\n    if (ok(md)) lb = md;\n    else ub = md;\n  }\n  return lb;\n}\n\nvoid inputright(int l, int r, int height) {\n  for (int i = l; i < r; i++) right[i] = max(right[i], height);\n}\n\nvoid inputleft(int l, int r, int height) {\n  for (int i = r; i > l; i--) left[-i] = max(left[-i], height);\n}\n\n\nint main() {\n  while (2)  {\n    scanf(\"%d%d\", &r, &n);\n    if (r == 0) break;\n    for (int i = 0; i < 21; i++) right[i] = left[i] = 0;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%d\", &xl[i], &xr[i], &h[i]);\n      if (xl[i] >= 0) inputright(xl[i], xr[i], h[i]);\n      else if (xr[i] <= 0) inputleft(xl[i], xr[i], h[i]);\n      else inputright(0, xr[i], h[i]), inputleft(xl[i], 0, h[i]);\n    }\n    printf(\"%f\\n\", (double) r + search());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ndouble r;\n\ndouble calc(int x, int h){\n     return h-sqrt(pow(r,2)-pow(x,2))+r;\n}\n\nint main(){\n    int n;\n    int map[50];\n    while(cin>>r>>n,r!=0){\n        fill(map, map+50,0);\n        int xl,xr,h;\n        for(int i=0;i<n;i++){\n            cin>>xl>>xr>>h;\n            for(int x=xl;x<xr;x++){\n                if(map[x+25]<h)map[x+25]=h;\n            }\n        }\n        double ans=calc(0,map[25]);\n        for(int x=floor(-r)+1;x<=ceil(r)-1;x++){\n            ans=min({ans,calc(x,map[25+x-1]),calc(x,map[25+x])});\n        }\n        cout.precision(8);\n        cout<<fixed;\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint nextInt() { int d; cin >> d; return d; }\n\nconst double EPS = 10e-6;\n\nstruct Rect {\npublic:\n  int height;\n  int xl, xr;\n  \n  Rect() { }\n  Rect(int xl, int xr, int height):\n    xl(xl), xr(xr), height(height) { }\n};\n\nstruct Point {\npublic:\n  double y, x;\n  Point() { }\n  Point(double y, double x): y(y), x(x) { }\n};\n\nbool judge(const vector<Point>& point, const int r, const double y) {\n  for (int i = 0; i < point.size(); i++) {\n    double dsq = (point[i].x * point[i].x) + ((point[i].y - y) * (point[i].y - y));\n    if (r * r - dsq > 0) {\n      return false;\n    }\n  }\n  \n  return true;  \n}\n\nint main() {\n  while (true) {\n    int r = nextInt();\n    int n = nextInt();\n    if (r + n == 0) {\n      break;\n    }\n    if (n == 0) {\n      cout << \"0.0000\" << endl;\n      continue;\n    }\n    vector<Rect> rect(n);\n    int ymax = -1;\n    for (int i = 0; i < n; i++) {\n      int xl = nextInt();\n      int xr = nextInt();\n      int h  = nextInt();\n      ymax = max(ymax, h);\n      rect[i] = Rect(xl, xr, h);\n    }    \n  \n    sort(rect.begin(), rect.end(), [](Rect a, Rect b) {\n      if (a.xl == b.xl) {\n        return a.xr < b.xr;\n      }\n      return a.xl < b.xl;\n    });\n    \n    for (int i = 0; i < n; i++) {\n      Rect& a = rect[i];\n      for (int j = i + 1; j < n; j++) {\n        Rect& b = rect[j];\n        if (a.xr > b.xr && a.xl < b.xl) {\n          // 3????????????\n          rect.push_back(Rect(b.xr, a.xr, a.height));\n          a.xr = b.xl;\n        } else if (a.xr > b.xl) {\n          if (a.xl == b.xl) {\n             b.xl = a.xr;\n          } else if (a.xr == b.xr) {\n            a.xr = b.xl;            \n          }        \n        }\n      }\n    }\n    \n    vector<Point> point;\n    \n    point.push_back(Point(0, rect[0].xl));\n    point.push_back(Point(rect[0].height, rect[0].xl));\n    \n    for (int i = 1; i < rect.size(); i++) {\n      if (rect[i - 1].xr != rect[i].xl) {\n        point.push_back(Point(0, rect[i].xl));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xl));\n    }\n    \n    point.push_back(Point(0, rect[rect.size() - 1].xr));\n    point.push_back(Point(rect[rect.size() - 1].height, rect[rect.size() - 1].xr));\n    \n    for (int i = 0; i < rect.size() - 1; i++) {\n      if (rect[i + 1].xl != rect[i].xr) {\n        point.push_back(Point(0, rect[i].xr));  \n      }\n      point.push_back(Point(rect[i].height, rect[i].xr));\n    }\n    \n    double lt = 0, ht = ymax;\n    \n    for (int i = 0; i < 100; i++) {\n      double mt = (lt + ht) / 2;\n      double y = -r + mt;\n      if (judge(point, r, y)) {\n        lt = mt;\n      } else {\n        ht = mt;\n      }\n    }    \n    printf(\"%.15f\\n\", ht);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[10010];string s;ll l;double d;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tdouble nextDouble(){scanf(\"%lf\", &d);return d;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nint main(){\n\twhile(1){\n\t\tint r = in.nextInt(), n = in.nextInt();\n\t\tif(r == 0 && n == 0) break;\n\t\tmap<int, int> mpl, mpr;\n\t\tmpr[-r] = INF;\n\t\tmpl[r] = INF;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x1 = in.nextInt(), x2 = in.nextInt(), h = in.nextInt();\n\t\t\tfor(int x = x1; x < x2; x++){\n\t\t\t\tmpl[x] = max(mpl[x], h);\n\t\t\t}\n\t\t\tfor(int x = x1+1; x <= x2; x++){\n\t\t\t\tmpr[x] = max(mpr[x], h);\n\t\t\t}\n\t\t}\n\t\tdouble ans = 1e18;\n\t\tfor(int x = -r; x <= r; x++){\n\t\t\tdouble y = -r + sqrt(r*r-x*x);\n\t\t\tdouble dl = -y + mpl[x];\n\t\t\tdouble dr = -y + mpr[x];\n\t\t\tans = min({ans, dl, dr});\n\t\t}\n\t\tprintf(\"%.15lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <math.h>\n\n\nusing namespace std;\n\nint max(int a,int b){\n\treturn a>=b ? a : b;\n}\nint min(int a,int b){\n\treturn a>=b ? b : a;\n}\n\nint main(){\n\n\tint r,n;\n\tint xi,xr,h;\n\n\twhile(cin>>r>>n){\n\t\tif(r==0 && n==0){\n\t\t\tbreak;\n\t\t}\n\n\t\tmap< int , int > data;\n\t\tmap< int , int > data2;\n\n\t\tfor(int i=-42;i<=42;i++){\n\t\t\tdata[i]=0;\n\t\t\tdata2[i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>xi>>xr>>h;\n\t\t\tfor(int j=0;j+xi*2<=xr*2;j++){\n\t\t\t\tdata[j+xi*2] = max(data[j+xi*2],h);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int i=-40;i<=40;i++){\n\t\t\tcout<<i<<\" \"<<data[i]<<endl;\n\t\t}\n\t\t*/\n\n\t\tfor(int i=-40;i<=40;i+=2){\n\t\t\tdata[i]=min(data[i-1],data[i+1]);\n\t\t}\n\n\t\t/*\n\t\tfor(int i=-40;i<=40;i++){\n\t\t\tcout<<i<<\" \"<<data[i]<<endl;\n\t\t}\n\t\t*/\n\t\tfor(int i=-20;i<=20;i++){\n\t\t\tdata2[i] = data[i*2];\n\t\t}\n\t\tdouble ans = 100000000;\n\t\tfor(int i=-r;i<=r;i++){\n\t\t\tdouble offset = r - sqrt(r*r - i*i);\n\t\t\tif(ans >= data2[i]+offset){\n\t\t\t\tans = data2[i]+offset;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nbool EQ(double a, double b) { return abs(a - b) < EPS; }\n\ndouble getHeight(double r, double x) {\n\treturn sqrt(r * r - x * x);\n}\n\nint main(void) {\n\tint r, n;\n\tint T = 0;\n\twhile(scanf(\"%d %d\", &r, &n), r > 0) {\n\t\tT++;\n\t\tint left[20], right[20], height[20];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", left + i, right + i, height + i);\n\t\t}\n\n\t\tvector<double> xs;\n\t\tconst double GAPEPS = 1e-7;\n\t\txs.push_back(-r + GAPEPS);\n\t\txs.push_back(r - GAPEPS);\n\t\txs.push_back(r);\n\t\txs.push_back(-r);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble cand = left[i] - GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = left[i] + GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] - GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i] + GAPEPS;\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = left[i];\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t\tcand = right[i];\n\t\t\tif(-r <= cand and cand <= r) xs.push_back(cand);\n\t\t}\n\t\tfor(int i = 1; i < 10001; i++) xs.push_back(-r + 2 * r / 10001.0 * i);\n\n\t\tsort(xs.begin(), xs.end());\n\n\t\tdouble s = 0, e = 100;\n\t\tfor(int lv = 0; lv < 100; lv++) {\n\t\t\tdouble mid = (s + e) / 2;\n\t\t\tbool isAble = true;\n\n\t\t\tfor(double x: xs) {\n\t\t\t\tbool isIncluded = false;\n\n\t\t\t\tdouble curHeight = getHeight(r, x) - r + mid;\n\t\t\t\tif(curHeight <= 0 or EQ(curHeight, 0)) continue;\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t\tif(left[i] <= x and x <= right[i] and height[i] > curHeight and !EQ(height[i], curHeight)) {\n\t\t\t\t\t\tisIncluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tif(!isIncluded) {\n\t\t\t\t\tisAble = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isAble) s = mid;\n\t\t\telse e = mid;\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\", s);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\ndouble mk_dis(int x1,int h,double cy){\n  return sqrt(x1*x1+(h-cy)*(h-cy));\n}\n\n\nbool check(double cy){\n  cy=(int)(cy*100000)/100000.0;\n  double x=fabs(sqrt(r*r-cy*cy));\n  if(cy>=0)x=r;\n  int L=(-x-0.999999),R=(x+0.999999),hb[101]={};\n  for(int i=L+50;i<R+50;i++)\n    if(i>=50){\n      if(mk_dis(i-50,y[i],cy)>=r)hb[i]++;\n    }\n    else {\n      if(mk_dis(i-49,y[i],cy)>=r)hb[i]++;\n    }\n  \n  for(int i=L+50;i<R+50;i++)if(!hb[i])return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    memset(y,0,sizeof(y));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans;\n    for(ans=0;ans<41&&check(ans-r);ans+=0.00001);\n    printf(\"%lf\\n\",ans-0.00001);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct Circle {\n  Point p; double r;\n  Circle(const Point &p, double r) : p(p), r(r) { }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nvector<Point> crosspointsCC(const Circle& s,const Circle& t){\n  //ax + by + c = 0\n  double a = real(t.p) - real(s.p); //x1-x2;\n  double b = imag(t.p) - imag(s.p); //y1-y2;\n  double d = sqrt(a * a + b * b);\n  double theta = 0.0;\n\n  if(d > 0) {\n    theta = acos((d * d + s.r * s.r - t.r * t.r) / (2 * d * s.r));\n  }\n\n  double angle = atan2(b,a);\n  \n  vector<Point> res;\n  if(d < s.r + t.r){\n    res.push_back(Point(s.p.real() + s.r * cos(angle + theta), s.p.imag() + s.r * sin(angle + theta)));\n    res.push_back(Point(s.p.real() + s.r * cos(angle - theta), s.p.imag() + s.r * sin(angle - theta)));\n  }\n\n  else if(s.r + t.r - EPS <= d && d <= s.r + t.r + EPS){\n    res.push_back(Point(s.p.real() + s.r * cos(angle), s.p.imag() + s.r * sin(angle)));\n  }\n  \n  return res;\n}\n\nbool intersectCS(const Circle& s,const Line& t){\n  Point v = t[1] - t[0];\n  Point c = s.p - t[0];\n  Point b = s.p - t[1];\n  if(dot(v,c) < 0){\n    if(abs(c) < s.r) return true;\n    return false;\n  }\n  else{\n    if(dot(v,c) > dot(v,v)){\n      if(s.r * s.r > dot(b,b)) return true;\n      return false;\n    }\n    else{\n      if(dot(c,c) - dot(dot(v,c),dot(v,c)) / dot(v,v) < dot(s.r,s.r)) return true;\n      return false;\n    }\n  }\n}\n\nPoint crosspointLL(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const Point &l,const Point &m){\n  return abs(cross(l,m)) / 2.0;\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool include(const Circle& s,Point t){\n  t -= s.p;\n  return dot(t,t) <= s.r * s.r + EPS;\n}\n\nint main(){\n  int r,n;\n  while(~scanf(\"%d %d\",&r,&n)){\n    if(r == 0 && n == 0) break;\n    \n    vector<Line> lines;\n    double rhs = 0.0;\n    double lhs = -(double)r;\n\n    bool has_point[50][50] = {};\n    for(int i = 0; i < n; i++){\n      int lx,rx;\n      int h;\n      scanf(\"%d %d %d\",&lx,&rx,&h);\n      for(int x = lx; x < rx; x++){\n        has_point[x + 20][h] = true;\n      }\n      rhs = max(rhs,(double)h);\n    }\n\n    lines.push_back(Line(Point(-10000,0),Point(-20,0)));\n    lines.push_back(Line(Point(20,0),Point(10000,0)));\n    for(int x = -20; x + 1 <= 20; x++){\n      bool isok = false;\n      for(int y = 40; y >= 0; y--){\n        if(has_point[x + 20][y]){\n          lines.push_back(Line(Point(x,y),Point(x+1,y)));\n          isok = true;\n          break;\n        }\n      }\n      if(!isok){\n        lines.push_back(Line(Point(x,0),Point(x+1,0)));\n      }\n    }\n\n    for(int round = 0; round < 50; round++){\n      double mid = lhs + (rhs - lhs) / 2.0;\n      Circle c(Point(0,mid),r);\n\n      bool has_crosspoint = false;\n      for(int i = 0; i < lines.size(); i++){\n        if(intersectCS(c,lines[i])){\n          has_crosspoint = true;\n          break;\n        }\n      }\n\n      if(has_crosspoint){\n        rhs = mid;\n      }\n      else{\n        lhs = mid;\n      }\n    }\n\n    printf(\"%.5lf\\n\",rhs + (double)r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nint main()\n{\n\tcout << fixed << setprecision(5);\n\tint n, r;\n\twhile (cin >> r >> n, r | n) {\n\t\tvector<int> h(40);\n\t\tfor (int i = 0, xl, xr, hi; i < n; i++) {\n\t\t\tcin >> xl >> xr >> hi;\n\t\t\tfor (int j = xl + 20; j < xr + 20; j++) {\n\t\t\t\th[j] = hi;\n\t\t\t}\n\t\t}\n\t\tint cnt = 100;\n\t\tld lb = 0, ub = 30;\n\t\twhile (cnt--) {\n\t\t\tld c = (lb + ub) / 2.0;\n\t\t\tbool flag = true;\n\t\t\tfor (int i = 20 - r; i < 20 + r; i++) {\n\t\t\t\tif (max(sqrtl(r * r - (i - 20) * (i - 20)), sqrtl(r * r - (i - 19) * (i - 19))) - r + c > h[i]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tlb = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tub = c;\n\t\t\t}\n\t\t}\n\t\tcout << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r;\n  double xl, xr, h, ans;\n  vector<double> V(41,0);\n  while(cin >> r >> n, r||n){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\n    while(true){\n\n        double r;\n        int n;\n\n        cin >> r >> n;\n\n        if(r == 0.0 && n == 0){\n            break;\n        }\n\n        int x[41] = {0};\n\n        for(int i=0; i<n; i++){\n            int lx,ly,h;\n\n            cin >> lx >> ly >> h;\n\n            for(int i=20+lx; i<20+ly; i++){\n                x[i] = max(x[i],h);\n            }\n        }\n\n        for(int i=0; i<41; i++){\n            cout << i-20 << \" to \" << i-20 + 1 << \" \" << x[i] << endl;\n        }\n\n        double ans = 0.000;\n\n        while(true){\n\n            double survey = ans + 0.0001;\n\n            bool flag = true;\n\n            for(int i=-20; i<=20; i++){\n                double d_x = static_cast<double>(i);\n                if(r*r > d_x*d_x){\n                    double h = sqrt(r*r - d_x*d_x) + 1.0*survey - r;\n                    if(h > x[i+20] || h > x[i+20 -1]){\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n\n            if(!flag){\n                break;\n            }\n\n            ans += 0.0001;\n\n        }\n\n        cout << fixed << setprecision(5) << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nint main() {\n  int r, n;\n  while(true) {\n    cin >> r >> n;\n    if (r == 0 && n == 0) break;\n    int x[42];\n    memset(x, 0, sizeof(x));\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n      for (int j = xl; j < xr; j++) {\n        x[j+20] = max(x[j+20], h);\n      }\n    }\n\n\n    double ans = 1000;\n    for (int i = -r; i < r; i++) {\n      int p;\n      if (i < 0) {\n        p = i+1;\n      }else {\n        p = i;\n      }\n      ans = min(ans, x[i+20]+r-sqrt(r*r-p*p));\n\n    }\n    printf(\"%.9lf\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint main(){\n\n  while(true){\n    int r, n; cin>> r>> n;\n    if(n==0 && r==0) break;\n\n    vector<int> xl(n), xr(n), h(n);\n    rep(i, n) cin>> xl[i]>> xr[i]>> h[i];\n    map<int, int> mh;\n    rep(i, n){\n      for(int x=xl[i]; x<xr[i]; x++){\n        mh[x]=max(mh[x], h[i]);\n      }\n    }\n\n    double t=1e9;\n    for(int x=-r+1; x<r; x++){\n      t=min(t, r-sqrt(r*r-x*x)+min(mh[x-1], mh[x]));\n    }\n\n    printf(\"%.18f\\n\", t);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194&lang=jp */\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#include<cassert>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\nint main() {\n\tint R,N;\n\tint xl,xr,h;\n\tint offset = 20;\n\tcout << fixed << setprecision(4); //固定でかつ浮動小数点誤差範囲\n\n\twhile(cin >> R >> N)\n\t{\n\t\tif (R == 0 && N == 0) { break; }\n\t\tvector<int> max_hs(50,0); //-20<=i<=20\n\n\t\trep(i,N) {\n\t\t\tcin >> xl >> xr >> h;\n\t\t\txl = xl + offset;\n\t\t\txr = xr + offset;\n\t\t\tfor(int x = xl; x < xr; x++) { //-2<=x<=-1(点) -> -2<=x<-1(線分)\n\t\t\t\tmax_hs[x] = max(max_hs[x],h);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * ここでのx0,y0とは円の中心座標\n\t\t * y0_left, y0_rightはビルの頂点の左右の点のこと\n\t\t */\n\t\tdouble mini = INT_MAX;\n\t\tdouble y0=0;\n\t\tint y=0;\n\t\tfor(int x = -R; x < R; x++) {\n\t\t\tint xx = x+offset; //配列用のx座標\n\t\t\ty = max_hs[xx];\n\n\t\t\tint tmp_x = 0;\n\t\t\tif (x < 0) { tmp_x = x+1; } //-2点| -2線 | -1点 | -1線 | 0点 | 0線 | ...\n\t\t\telse { tmp_x = x; }\n\n\t\t\t//R分のオフセットあり\n\t\t\ty0 = y - sqrt(R*R - tmp_x*tmp_x); //建物の左側または右側の特徴点(x0=0)\n\t\t\ty0 = y0 + R; //中心から距離R上の円上の座標\n\t\t\tchmin(mini,y0);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nbool is[40][21];\ndouble eps=1e-9;\nint main(){\n\twhile(true){\n\t\tint r,n;\n\t\tcin>>r>>n;\n\t\tif(n==0) break;\n\t\trep(i,40) rep(j,21) is[i][j]=0;\n\t\trep(i,n){\n\t\t\tint a,b,h;\n\t\t\tcin>>a>>b>>h;\n\t\t\ta+=20,b+=20;\n\t\t\tfor(int x=a;x<b;x++) rep(y,h) is[x][y]=true;\n\t\t}\n\t\tvector<double> vc;\n\t\tfor(int x=-20;x<=20;x++) for(int y=0;y<=21;y++){\n\t\t\tif(x*x>=r*r) continue;\n\t\t\tdouble t=y-sqrt(r*r-x*x);\n\t\t\tvc.pb(t);\n\t\t}\n\t\tsort(all(vc));\n\t\trep(i,vc.size()){\n\t\t\tdouble h=vc[i];\n\t\t\tbool can=true;\n\t\t\tfor(int x=-r;x<r;x++) for(int y=0;y<21;y++){\n\t\t\t\tif(is[x+20][y]) continue;\n\t\t\t\tif(x*x+(y-h)*(y-h)-eps<r*r) can=false;\n\t\t\t\tif((x+1)*(x+1)+(y-h)*(y-h)-eps<r*r) can=false;\n\t\t\t}\n\t\t\tif(!can){\n\t\t\t\tprintf(\"%.12f\\n\",h+r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v ) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n\nstruct edge { int to, cost; };\nostream& operator<<(ostream& os, const edge& e) {\n    os << \"(\" << e.to << \", \" << e.cost << \")\";\n    return os;\n}\n\nconst LL LINF = 1LL<<60;\nconst int IINF = 1<<30;\nconst LL MOD = 1e9+7;\n\nint main()\n{\n    vector<int> rs, ns;\n    vector<vector<int>> xls, xrs, ys;\n    while (true) {\n        int r, n; cin >> r >> n;\n        if (r == 0 && n == 0) {\n            break;\n        }\n        vector<int> xl(n), xr(n), y(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> xl[i] >> xr[i] >> y[i];\n        }\n        rs.push_back(r);\n        ns.push_back(n);\n        xls.push_back(xl);\n        xrs.push_back(xr);\n        ys.push_back(y);\n    }\n\n    for (int t = 0; t < ns.size(); ++t) {\n        int r = rs[t], n = ns[t];\n        auto xl = xls[t], xr = xrs[t], y = ys[t];\n\n        auto s = make_v<int>(20+20, 20+1);\n        for (int i = 0; i < n; ++i) {\n            for (int X = xl[i]; X < xr[i]; ++X) {\n                for (int Y = 0; Y < y[i]; ++Y) {\n                    s[X+20][Y] = 1;\n                }\n            }\n        }\n\n        double ans = 1e9;\n        for (int i = 0; i < 40; ++i) {\n            for (int j = 0; j <= 20; ++j) {\n                if (s[i][j] == 0) {\n                    int X = i-20, Y = j;\n                    if (X < 0) {\n                        X += 1;\n                    }\n                    if (r*r - X*X <= 0) {\n                        continue;\n                    }\n                    double h = sqrt(r*r - X*X);\n                    chmin(ans, Y-h);\n                }\n            }\n        }\n        printf(\"%.4lf\\n\", max(ans+r, 0.));\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=(-x-0.9999),R=(x+0.9999),hb[101]={};\n\n  for(int i=L+50;i<R+50;i++){\n    int x1=i-49-i/50;\n    double y1=y[i]-cy;\n    if(sqrt(x1*x1+y1*y1)>=r)hb[i]++;\n  }\n  for(int i=L+50;i<R+50;i++)if(!hb[i])return 0;\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<100;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.0005;\n    cout << ans-0.0005<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(int r,int n){\n  double tmp[60] = {};\n  double *height = tmp + 30;\n  for(int i = 0;i < n;++i){\n    int xl,xr;\n    double h;\n    cin >> xl >> xr >> h;\n    for(int i = xl;i <xr;++i){\n      height[i] = h;\n    }\n  }\n  double res = 100.0;\n  for(int i = 0;i < r;++i){\n    res = min(res, height[i] - sqrt(r*r - i*i) + r);\n  }\n  for(int i = 0;i > -r;--i){\n    res = min(res, height[i-1] - sqrt(r*r - i*i) + r);\n  }\n  cout << setprecision(15) << res << endl;\n}\n\nint main(void){\n  int r,n;\n  while(cin >> r >> n,\n\t!(r == 0 && n == 0)){\n    solve(r,n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\twhile (true) {\n\t\tint r, n;\n\t\tcin >> r >> n;\n\n\t\tif (r == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbool grid[21][41];\n\t\tfor (int i = 0; i < 21; i++) {\n\t\t\tfor (int j = 0; j < 41; j++) {\n\t\t\t\tgrid[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint lx, rx, y;\n\t\t\tcin >> lx >> rx >> y;\n\n\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\tfor (int k = lx + 20; k < rx + 20; k++) {\n\t\t\t\t\tgrid[j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 10000000;\n\n\t\tfor (int y = 0; y < 21; y++) {\n\t\t\tfor (int x = -r + 20; x < r + 20; x++) {\n\t\t\t\tif (grid[y][x] == false) {\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (x < 20) {\n\t\t\t\t\t\ttemp = (double)r - sqrt((double)r * r - abs(x - 19)*abs(x - 19)) + y;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttemp = (double)r - sqrt((double)r * r - abs(x - 20)*abs(x - 20)) + y;\n\t\t\t\t\t}\n\t\t\t\t\tans = min(ans, temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.4f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ndouble w[2][44];\ndouble s[44];\nint r;\nint n;\nint x1, x2, h;\ndouble nkr;\ndouble a[3];\n\nmain(){\n\twhile (cin >> r >> n, r || n){\n\t\tnkr = -1;\n\t\tfor (int i = 0; i<2; i++)for (int j = 0; j<44; j++) w[i][j] = 0;\n\n\t\tfor (int i = 0; i<n; i++){\n\t\t\tcin >> x1 >> x2 >> h;\n\n\t\t\tif (w[0][x2 + 20]<h || w[0][x2 + 20] == 0) w[0][x2 + 20] = h;\n\t\t\tif (w[1][x1 + 20]<h || w[1][x1 + 20] == 0) w[1][x1 + 20] = h;\n\t\t\tfor (int j = x1 + 21; j<x2 + 20; j++){\n\t\t\t\tif (w[0][j]<h || w[0][j] == 0) w[0][j] = h;\n\t\t\t\tif (w[1][j]<h || w[1][j] == 0) w[1][j] = h;\n\t\t\t}\n\n\t\t}\n\n\t\tnkr = w[1][20 - r] + r;\n\t\tfor (int i = r*(-1) + 1; i<r; i++){\n\t\t\ts[i + 20] = sqrt(r*r - i*i) - r;\n\t\t\tif (w[0][i + 20] - s[i + 20]<nkr) nkr = w[0][i + 20] - s[i + 20];\n\t\t\tif (w[1][i + 20] - s[i + 20]<nkr) nkr = w[1][i + 20] - s[i + 20];\n\t\t}\n\t\tif (w[0][20 + r] + r<nkr) nkr = w[0][20 + r] + r;\n\n\n\n\t\tprintf(\"%.4f\\n\", nkr);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 10000000;\n\ntypedef complex<double> P;\n\nint main(){\n    int n;\n    double r;\n    while(cin >> r >> n, r||n){\n        double p[41] = {0};\n        rep(i,n){\n            double left, right, h;\n            cin >> left >> right >> h;\n            left+=20; right+=20 - 1;\n            for(int j = left; j <= right; j++){\n                p[j] = max(p[j],h);\n            }\n        }\n        rep(i,40) if(p[i] == INF) p[i] = 0;\n\n        P c = {20.0, -r};\n        double mini = INF;\n        auto pow = [](double a){return a * a; };\n        rep(i,40){\n            //if(i < 17 || 22 < i) continue;\n\n            if(not (i > 20 - r && i < 20 + r)) continue;\n            mini = min(mini, min(p[i], p[i - 1]) + r - sqrt(pow(r) - pow(i - 20)));\n            //show(min(p[i],p[i - 1]))\n            //show(sqrt(pow(r) - pow(i - 20)))\n            //show(r)\n            //show(mini)\n            //if(i == 0){\n            //    P tmp = {static_cast<double>(i), 0};\n            //    mini = min(mini, abs((abs(c - p[i]) - r) * sin(arg(c / p[i]))));\n            //}else if(i == n - 1){\n            //    P tmp = {static_cast<double>(i), 0};\n            //    mini = min(mini, abs((abs(c - p[i]) - r) * sin(arg(c / p[i]))));\n            //}else{\n            //    P tmp = {static_cast<double>(i),min(p[i - 1], p[i])};\n            //    show(p[i])\n            //    show(tmp)\n            //    double dist = abs(c - tmp) -r;\n            //    show(dist)\n            //    mini = min(mini, abs((abs(c - tmp) - r) * sin(arg(c / tmp))));\n            //}\n        }\n        cout << fixed << setprecision(4) << mini << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<utility>\n#include<iomanip>\n#include<iostream>\n#define F(A, B) for(int A=0; A<B; A++)\nusing namespace std;\n\nint main(){\n\tint R, n;\n\n\tcin >> R >> n;\n\twhile(!(R==0 && n==0) ){\n\t\tint pos[41][2]={ {0, 0} };\n\t\tint l, r, h;\n\t\tF(i, n){\n\t\t\tcin >> l >> r >> h;\n\t\t\tfor(int j=l+20; j<r+20; j++){\n\t\t\t\tif(pos[j][0] < h)pos[j][0] = h;\n\t\t\t}\n\t\t}\n\t\tfor(int i=40; i>0; i--){\n\t\t\tpos[i][1] = min(pos[i][0], pos[i-1][0]);\n\t\t\tpos[i][0] = max(pos[i][0], pos[i-1][0]);\n\t\t}\n\n\t\tdouble min=100;\n\t\tfor(int i=20-R+1; i<=20+R-1; i++){\n\t\t\tdouble tmp=pos[i][1]-sqrt(static_cast<double>(R*R-(i-20>0 ? i-20:20-i)*(i-20>0 ? i-20:20-i) ) );\n\t\t\tif(min > tmp)min = tmp;\n\t\t}\n\t\tif(min <= -R){\n\t\t\tmin = 0;\n\t\t}else{\n\t\t\tmin = min+R;\n\t\t}\n\t\tcout << fixed << setprecision(4) << min << endl;\n\n\t\tcin >> R >> n;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ndouble eq(double x) { return fabs(x) < 0.000001; }\n\ndouble f(double r, double x) {\n  if (fabs(x) > r)\n    return -100000000;\n  if (eq(fabs(x) - r))\n    return -r;\n  return -(r - sqrt(r * r - x * x));\n}\n\nint main() {\n  while (true) {\n    int r, n;\n    cin >> r >> n;\n    if (r == 0 && n == 0)\n      break;\n    double ans = 10000000000;\n    vector<pair<int, int>> x(n);\n    vector<int> h(n);\n    for (int i = 0; i < n; i++)\n      cin >> x[i].first >> x[i].second >> h[i];\n    if (n == 0) {\n      cout << 0 << endl;\n      continue;\n    }\n    int H[50][2] = {0};\n    int offset = 25;\n    for (int i = 0; i < n; i++) {\n      for (int j = max(-r, x[i].first); j < min(r + 1, x[i].second); j++) {\n        H[j + offset][0] = max(H[j + offset][0], h[i]);\n      }\n      for (int j = max(-r, x[i].first + 1); j <= min(r, x[i].second); j++) {\n        H[j + offset][1] = max(H[j + offset][1], h[i]);\n      }\n    }\n    for (int i = -r; i <= r; i++) {\n      cout << H[i + offset][0] << \" \" << H[i + offset][1] << \" \" << f(r, i)\n           << endl;\n      if (i < r)\n        ans = min(ans, H[i + offset][0] - f(r, i));\n      if (i > -r)\n        ans = min(ans, H[i + offset][1] - f(r, i));\n    }\n    printf(\"%.9lf\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n#define all all(v) v.begin(),v.end()\n#define INF i<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\n\ntypedef long long ll;\n\n#define EPS (1e-10)\n\nclass Point {\n\tpublic:\n\tdouble x,y;\n\n\tPoint(double x = 0, double y = 0): x(x),y(y){}\n\n\tPoint operator + (Point P) { return Point(x+P.x, y+P.y);}\n\tPoint operator - (Point P) { return Point(x-P.x, y-P.y);}\n\tPoint operator * (double a) { return Point(a*x, a*y);}\n\tPoint operator / (double a) { return Point(x/a, y/a);}\n\n\tdouble abs_() { return sqrt(norm());}\n\tdouble norm() { return x*x+y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ndouble dot(Point a, Point b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a, Point b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif(cross(a,b) > EPS) return 1;\n\tif(cross(a,b) < -EPS) return -1;\n\tif(dot(a,b) < -EPS) return 2;\n\tif(a.norm() < b.norm() ) return -2;\n\n\treturn 0;\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon andrewScan( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3) return s;\n\tsort(s.begin(),s.end());\n\n\tu.pb(s[0]);\n\tu.pb(s[1]);\n\n\tfor(int i=2; i< s.size(); i++){\n\t\tfor(int n = u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i]) != -1; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\n\treturn u;\n}\n\nint main(){\n\twhile(1){\n\t\tint r;\n\t\tint n;\n\t\tPolygon pv;\n\t\tcin >> r >> n;\n\t\tif(r==0) break;\n\n\t\tmap<int,pii> mv;\n\n\t\trep(i,n){\n\t\t\tint xr,xl,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tmv[xl].se = max(h,mv[xl].se);\n\t\t\tfor(int nx = xl+1;nx<xr;nx++){\n\t\t\t\tmv[nx].fi = max(h,mv[nx].fi);\n\t\t\t\tmv[nx].se = max(h,mv[nx].se);\t\t\n\t\t\t}\n\t\t\tmv[xr].fi = max(h,mv[xr].fi);\n\t\t\t/*\n\t\t\tpv.pb(Point(xl,0));\n\t\t\tpv.pb(Point(xr,0));\n\t\t\tpv.pb(Point(xl,h));\n\t\t\tpv.pb(Point(xr,h));\n\t\t\tif(xl < 0 && 0 < xr){\n\t\t\t\tpv.pb(Point(0,h));\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tmv[-r-1].fi = mv[-r-1].se;\n\t\tmv[r+1].se = mv[r+1].fi;\n\n\t\t// cout<<\"=======\"<<endl;\n\t\tfor(int i=-20;i<=20;i++){\n\t\t\t\n\t\t\t// cout << min(mv[i].fi,mv[i].se) << endl;\n\t\t\tpv.pb(Point(i,min(mv[i].fi,mv[i].se)));\n\t\t}\n\t\t// cout<<\"=======\"<<endl;\n\n/*\n\t\tfor(int i=-20;i<21;i++){\n\t\t\tpv.pb(Point(i,min(mv[i],mv[i+1])));\n\t\t}\n\n\t\tcout<<\"-----------\"<<endl;\n\t\trep(i,pv.size()){\n\t\t\tif(pv[i].y!=23)cout<<pv[i].x<<\" \"<<pv[i].y<<endl;\n\t\t}\n\t\tcout<<\"--------\"<<endl;\n*/\n\n\t\tfor(double t = 0; t<=20;t+=0.00001){\n\t\t\tPoint c = Point(0,-r+t);\n\t\t\trep(i,pv.size()){\n\t\t\t\tif((c-pv[i]).abs_()<=r){\n\t\t\t\t\t// cout<<(c-pv[i]).abs_()<<endl;\n\t\t\t\t\tprintf(\"%lf\\n\",t);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\t/*\n\t\t// Polygon pt;\n\t\t// pt = andrewScan(pv);\n\t\t// rep(i,pv.size()){\n\t\t// \tcout << \"pv :\" << pv[i].x << \" \"<< pv[i].y << endl;\n\t\t// }\n\n\t\trep(i,pt.size()){\n\t\t\tcout << \"pt :\" << pt[i].x << \" \"<< pt[i].y << endl;\n\t\t}\n*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-10;\n\n#define INF (1<<29)\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nmap<int, map<int, double>> height;\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  double r;\n  int n;\n  while (cin >> r >> n, r && n) {\n    height.clear();\n    int lx, rx, h;\n    int l_end = INF;\n    int r_end = -INF;\n    rep(i, n) {\n      cin >> lx >> rx >> h;\n      l_end = min(l_end, lx);\n      r_end = max(r_end, rx);\n      REP(j, lx, rx) {\n        height[j][j+1] = max<double>(h, height[j][j+1]);\n      }\n    }\n\n    // simulation\n    double center = -r;\n    double step = 0.0001;\n    double ans = -step;\n    while (true) {\n      bool judge = true;\n      REP(i, l_end, r_end) {\n        int lx = i;\n        int rx = i + 1;\n        double h = height[lx][rx];\n        double dl = sqrt(fabs(h - center) * fabs(h - center) + abs(lx) * abs(lx));\n        double dr = sqrt(fabs(h - center) * fabs(h - center) + abs(rx) * abs(rx));\n        if (dl < r || dr < r) {\n          judge = false;\n          break;\n        }\n      }\n      if (!judge) break;\n      center += step;\n      ans += step;\n    }\n    cout << fixed << setprecision(4) << ans << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG(C) cerr << #C << \" = \" << C << endl\n\nusing namespace std;\n\nconst int MAX = 30;\nint xl[MAX], xr[MAX], h[MAX];\nint maxHeight[MAX * 2 + 10];\n\nbool solve() {\n  int r, n;\n  scanf(\"%d%d\", &r, &n);\n  if (r == n && r == 0) {\n    return false;\n  }\n  memset(maxHeight, 0, sizeof(maxHeight));\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d%d\", xl + i, xr + i, h + i);\n    for (int j = xl[i] + MAX; j < xr[i] + MAX; j++) {\n      maxHeight[j] = max(maxHeight[j], h[i]);\n    }\n  }\n  double high = MAX, low = 0;\n  for (int cnt = 0; cnt < 100; cnt++) {\n    const double mid = (high + low) / 2;\n    bool out = false;\n    \n    for (int i = MAX - r + 1; i < MAX + r; i++) {\n      double nowHeight = 1. * mid + sqrt(r * r - (i - MAX) * (i - MAX)) - r;\n      if (maxHeight[i - 1] < nowHeight || maxHeight[i] < nowHeight) {\n        out = true;\n        break;\n      }\n    }\n    \n    if (out) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n  }\n  printf(\"%.10lf\\n\", low);\n  return true;\n}\n\nint main() {\n  while (solve()) {}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\n#define MAX_N 20\n\nusing namespace std;\n\nint N, R;\nint lx[MAX_N], rx[MAX_N], h[MAX_N];\nint inf = 100000000;\n\nbool judge(double t){\n\tfor (int x = -R+1; x < R; x++)\n\t{\n\t\tint l = inf, r = inf, m = 0;\n\t\tint y;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif(lx[i] == x){\n\t\t\t\tr = min(h[i], r);\n\t\t\t}else if(rx[i] == x){\n\t\t\t\tl = min(h[i], l);\n\t\t\t}else if(lx[i] < x && x < rx[i]){\n\t\t\t\tm = max(h[i], m);\n\t\t\t}\n\t\t}\n\t\tif(l == inf || r == inf) y = 0;\n\t\telse y = min(l, r);\n\t\tif(m > y) y = m;\n\t\tif(y < (double)sqrt(R*R-x*x)-R+t) return true;\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tdouble maxT = 21;\n\tdouble minT = 0;\n\twhile(maxT - minT > 0.0001){\n\t\tdouble t = (maxT+minT)/2;\n\t\tif(judge(t)){// ???????????????\n\t\t\tmaxT = t;\n\t\t}else{// ????????????\n\t\t\tminT = t;\n\t\t}\n\t}\n\tprintf(\"%.4lf\\n\", (maxT+minT)/2);\n\treturn;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> R >> N;\n\t\tif(R == 0 && N == 0) break;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> lx[i] >> rx[i] >> h[i];\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pi 3.14159265358979\n \n \nint main()\n{\n    int r,n,xl,xr,h;\n    while(1==1)\n    {\n        scanf(\"%d %d\\n\",&r,&n);\n        if(r==0)break;\n        int hei[50]={};\n        REP(i,n)\n        {\n            scanf(\"%d %d %d\\n\",&xl,&xr,&h);\n            for(int j=xl+25;j<xr+25;j++)if(hei[j]<h)hei[j]=h;\n        }\n        double min=810;\n        double dlen;\n        REP(i,r)\n        {\n            dlen=hei[25+i];\n            dlen+=r-sqrt(r*r-i*i);\n            if(min>dlen)min=dlen;\n        }\n        REP(i,r)\n        {\n            dlen=hei[25-i-1];\n            dlen+=r-sqrt(r*r-i*i);\n            if(min>dlen)min=dlen;\n        }\n        printf(\"%f\\n\",min);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nconst double infty = 100000;\nbool c[50][50];\ndouble k[50][50];\nint n;\nint r;\n\n// const int d[4][2] = { {0,1}, {0,-1}, {1,0}, {-1,0} }; \n\nbool isedge(int x, int y) {\n  return c[x][y] != c[x-1][y] || c[x][y] != c[x][y-1]; \n}\n/* 独流でここに辿り着くまで時間がかかった。\n   今後のために解法をまとめておく。\n   ・境界の格子点がいつ円と交わるかを計算する。最小値が答え。(これはすぐ思いついた)\n   ・塗ってあるパネルは、左下の頂点で管理する。ここで重要なのは半開区間で塗りつぶすことだ。閉区間だと隙間があるとき判定できない。(冷静になるまで時間がかかった)\n   ・すると境界の判定は上記のようにできる。\n */\n\nint main() {\n  while (scanf(\"%d%d\", &r, &n) != EOF && r && n) {\n    fill(&c[0][0], &c[0][0]+50*50, false);\n    for (int x=0; x<50; x++) {\n      c[x][0] = true;\n    }\n    fill(&k[0][0], &k[0][0]+50*50, infty);\n    for (int kkk=0; kkk<n; kkk++) {\n      int x_l, x_r, h;\n      scanf(\"%d%d%d\", &x_l, &x_r, &h);\n      x_l += 25;\n      x_r += 25;\n      h += 1;\n      for (int x=x_l; x<x_r; x++) {\n\tfor (int y=1; y<h; y++) {\n\t  c[x][y] = true;\n\t}\n      }\n    }\n    double ans = infty;\n    for (int x=26-r; x<25+r; x++) {\n      for (int y=1; y<30; y++) {\n\tif (isedge(x, y)) {\n\t  k[x][y] = r + y - 1 - sqrt(r*r - (25-x)*(25-x));\n\t  /*if (k[x][y] < 3) {\n\t    cerr << \"x = \" << x-25 << \", y = \" << y-1 << \", k[x][y] = \" << k[x][y] << endl;\n\t    }*/\n\t  if (ans > k[x][y]) {\n\t    ans = k[x][y];\n\t  }\n\t}\n      }\n    }\n    printf(\"%.4f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint dx[3] = { 0,1,0 };\nint dy[3] = { -1,0,1 };\n// dir: ??????0, ??????1, ??????2\nvoid kado_mituketu(int x,int y,vector<pair<int, int>>& kado, bool grid[80][80],int dir) {\n\tif (x >= 61) {\n\t\tkado.push_back({ x,y + 1 });\n\t\treturn;\n\t}\n\tfor (int i = 2; i >= 0;i--) {\n\t\tif (i == 2 && dir == 0)continue;\n\t\tif (grid[x + dx[i]][y + dy[i]] == true) {\n\t\t\tif (dir != i) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (dir != 0) { kado.push_back({ x,y + 1 }); }\n\t\t\t\t\telse { kado.push_back({ x + 1,y + 1 }); }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (dir == 2) { kado.push_back({ x,y + 1 }); }\n\t\t\t\t\tkado.push_back({ x + 1,y + 1 });\n\t\t\t\t}\n\t\t\t\tdir = i;\n\t\t\t}\n\t\t\tkado_mituketu(x + dx[i], y + dy[i], kado, grid, dir);\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint r, n;\n\twhile (cin >> r >> n, r | n) {\n\t\tbool grid[80][80] = { false };\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\tfor (int x = xl; x < xr;x++) {\n\t\t\t\tfor (int hh = 0;hh < h;hh++) {\n\t\t\t\t\tgrid[40 + x][40+hh] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 42;i++) grid[19 + i][39] = true;\n\t\tvector<pair<int, int>> kado;\n\t\tkado.push_back({ 20,40 });\n\t\tkado_mituketu(20,39,kado, grid, 1);\n\t\t\n\t\tfor (int i = 0; i < kado.size();i++) {\n\t\t\tkado[i].first -= 40;kado[i].second -= 40;\n\t\t}\n\n\t\tdouble ny = -r;\n\t\tfor (;ny < 21.0;ny = ny + 0.00005) {\n\t\t\tbool f = false;\n\t\t\tfor (int i = 0; i < kado.size();i++) {\n\t\t\t\tdouble vx = kado[i].first, vy = kado[i].second;\n\t\t\t\tdouble dist = vx*vx + (vy - ny)*(vy - ny);\n\t\t\t\tif (r*r > dist) {\n\t\t\t\t\tcout << r << \" \" << ny << endl;\n\t\t\t\t\tcout << fixed << setprecision(10) << r + ny << endl;\n\t\t\t\t\tf = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tconstexpr int MAX_H = 20;\n\n\tfor(int r, n; cin >> r >> n && r;) {\n\t\tunordered_map<int, int> max_height;\n\n\t\trep(i, n) {\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tREP(x, xl, xr) {\n\t\t\t\tchmax(max_height[x], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = MAX_H;\n\t\tREP(i, -r, r) {\n\t\t\tconst int h = max_height[i] + r;\n\t\t\tconst int x = (i < 0 ? i + 1 : i);\n\t\t\tconst double y = sqrt(r * r - x * x);\n\t\t\tchmin(ans, h - y);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,N,n) for(int i=N;i>=n;i++)\n#define CH(n,a,b) (a)<=(n)&&(n)<(b)\n#define p(s) cout<<s<<endl;\ntypedef long long ll;\nusing namespace std;\n\nbool grid[25][45];\n\nint main() {\n\tint n, r, lx, rx, h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0 && n == 0) break;\n\t\tREP(i,0,25)REP(j,0,45) grid[i][j] = 0;\n\t\tREP(ii,0,n){\n\t\t\tcin>>lx>>rx>>h;\n\t\t\tREP(k,lx+20,rx+20)REP(l,0,h)grid[l][k] = 1;\n\t\t}\n\t\t/*\n\t\tREP(i,0,21)\n\t\t{\n\t\t\tREP(j,0,44){\n\t\t\t\tcout<<grid[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\t */\n\t\tbool flag = false;\n\t\tREP(i,0,21){\n\t\t\tREP(w,0,r){\n\t\t\t\tif( (grid[i][-w+20-1] == 0) || (grid[i][w+20] == 0)){\n\t\t\t\t\tdouble ans = (double)r - (double)sqrt((double)r*(double)r - (double)w*(double)w);\n\t\t\t\t\t//cout<<\"i: \"<<i<<\" w: \"<<w<<endl;\n\t\t\t\t\tif(w == 0) printf(\"%.6f\\n\", (double)i);\n\t\t\t\t\telse printf(\"%.6f\\n\", ans);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(ll i=(n);i<(N);i++)\n#define RREP(i,n,N) for(ll i=(N-1);i>=(n);i--)\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(), (v).end()\n#define MCP(a,b) memcpy(b,a, sizeof(b))\n#define p(s) cout<<(s)<<endl\n#define p2(a,b) cout<<(a)<<\" \"<<(b)<<endl\ntypedef long long ll;\nusing namespace std;\nconst ll mod = 1e9+7;\nconst ll inf =1e18;\n\nll r, n;\nll height[50];\nint main(){\n    while(cin>>r>>n, n){\n        REP(i,0,50) height[i] = 0;\n        REP(i, 0, n){\n            ll xl, xr, y;\n            cin>>xl>>xr>>y;\n            REP(j, xl, xr){\n                height[j+20]=max(height[j+20], y);\n            }\n        }\n\n        bool ok=false;\n        for(double t=0; t<=21; t+=0.001){\n            REP(i, -r+1, r){\n                double h=sqrt(r*r-i*i);\n                if(h+t+0.000001>=min(height[20+i], height[20+i-1])+r){\n                    printf(\"%.4lf\\n\", t);\n                    ok=true;\n                    break;\n                }\n            }\n            if(ok) break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-6\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n\nfloat solve(int r, vector<array<int, 3>>& vs)\n{\n    std::array<int, 41> imos;\n    for(auto& e: imos) e = 0;\n\n    for(auto& e: vs){\n        imos[e[0] + 20] += 1;\n        imos[e[1] + 20] += -1;\n    }\n\n    int s = 0;\n    for(auto& e: imos){\n        s += e;\n        e = s;\n    }\n\n    int maxL = 0, maxR = 0;\n    for(int i = 0; i <= 20; ++i){\n        if(imos[i+20] == 0)\n            break;\n        maxL = i + 1;\n    }\n    for(int i = 0; i >= -20; --i){\n        if(imos[i+20] == 0)\n            break;\n        maxR = -i;\n    }\n\n    // for(auto&e : imos)\n    //     cout << e << \", \";\n    // cout << endl << \"maxL: \" << maxL << \", maxR: \" << maxR << endl;\n\n    int width = (maxL < maxR ? maxL : maxR) * 2;\n    // if(width != 0) width -= 1;\n    if(width == 0) return 0;\n    if(width > r)\n        width = r*2;\n\n    // cout << width << endl;\n\n    int wh = width / 2;\n    float whf = wh;\n\n    float hd = r - sqrt(r*r - whf*whf);\n    if(!(hd > 0)) hd = 0;\n\n    std::array<int, 41> maxH;\n    for(auto& e: maxH) e = 0;\n    for(auto& e: vs){\n        for(int i = -20; i <= 20; ++i)\n            if(e[0] <= i && i < e[1]){\n                if(maxH[i+20] < e[2])\n                    maxH[i+20] = e[2];\n            }\n    }\n\n\n\n    float max = 0;\n    for(int i = -wh; i <= wh; ++i){\n        auto hh = sqrt(r*r - i*i);\n        if(maxH[i+20] < hh && max < (hh - maxH[i+20])){\n            max = hh - maxH[i+20];\n        }\n    }\n\n    // cout << \"max: \" << max << endl;\n    // cout << \"hd: \" << hd << endl;\n\n    // for(auto&e : maxH)\n    //     cout << e << \", \";\n    // cout << endl;\n\n    if(max == 0){\n        float mm = 1024, ret = 0;\n        for(int i = -wh; i <= wh; ++i){\n            float rm1 = maxH[i+20] - sqrt(r*r - (i+1)*(i+1));\n            float rm2 = maxH[i+20] - sqrt(r*r - i*i);\n            float rm = rm1 < rm2 ? rm1 : rm2;\n            // cout << \"i: \" << i << \", rm1: \" << rm1 << \", rm2: \" << rm2 << endl;\n            if(maxH[i+20] != 0 && mm > rm){\n                mm = rm;\n                ret = rm + whf;\n            }\n        }\n\n        // cout << \"mm: \" << mm << endl;\n        return ret;\n    }\n\n    return hd - max;\n}\n\n\nint main(void)\n{\n    int r, n;\n    while(cin >> r >> n){\n        if(r == 0 && n == 0)\n            break;\n\n        vector<array<int, 3>> vs;\n        for(int i = 0; i < n; ++i){\n            array<int, 3> arr;\n            cin >> arr[0] >> arr[1] >> arr[2];\n            vs.push_back(arr);\n        }\n\n        cout << solve(r, vs) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nvoid solve(double r,int n){\n    vector<int> xl(n),xr(n),h(n);\n    map<int,int> H;\n    rep(i,n){\n        cin >> xl[i] >> xr[i] >> h[i];\n        for(int j=xl[i];j<xr[i];j++){\n            H[j] = max(h[i],H[j]);\n        }\n    }\n\n    double ans = 100;\n    for(int x=-r;x<=r;x++){\n        double y = min(H[x-1],H[x]);\n        if(x == -r) y = H[x];\n        if(x == r) y = H[x-1];\n        double t = y + r - sqrt(r*r-x*x);\n        ans = min(ans,t);\n    }\n    cout << Double(ans) << endl;\n}\n\n\nint main(){\n    int r,n;\n    int cnt = 0;\n    while(1){\n        cin >> r >> n;\n        if(!r and !n) break;\n        solve(r,n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n    double r;\n    int n;\n    while (cin >> r >> n, r || n) {\n        vector<double> height(21 * 2 + 1, 0);\n        for (int i = 0; i < n; i++) {\n            int x1, x2;\n            double h;\n            cin >> x1 >> x2 >> h;\n            for (int j = x1; j < x2; j++) {\n                height[j + 21] = max(height[j + 21], h);\n            }\n        }\n\n        double res = 20. + r;\n        for (int i = 0; i < 21 * 2 + 1; i++) {\n            if (abs(i - 21) >= r) continue;\n            double low = min(height[i-1], height[i]);\n            double C = low * low + abs(i - 21) * abs(i - 21) - r * r;\n            double ret = low - sqrt(pow(low,2) - C) + r;\n            res = min(res, ret);\n        }\n\n        printf(\"%.4f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex< double > Point;\ntypedef vector< Point > Polygon;\nnamespace std{\n\tbool operator < ( Point a, Point b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n};\nconst double INF = 1e12;\nconst double EPS = 1e-8;\nPoint NextPoint(){\n\tPoint P;\n\tcin>>P.real()>>P.imag();\n\treturn P;\n}\nstruct Line : Polygon{\n\tLine(){};\n\tLine(Point p, Point q){push_back(p);push_back(q);}\n};\n\nstruct Circle{\n\tPoint p;\n\tdouble r;\n\tCircle();\n\tCircle(Point a, double s){p = a,r = s;}\n};\ndouble cross(Point p, Point q){\n\treturn imag(conj(p)*q);\n}\ndouble dot(Point p,Point q){\n\treturn real(conj(p)*q);\n}\nint ccw(Point a,Point b,Point c){\n\tb -= a,c -= a;\n\tif(cross(b,c) > 0)return 1;\n\tif(cross(b,c) < 0)return -1;\n\tif(dot(b,c) < 0 )return 2;\n\tif(norm(b) < norm(c))return -2;\n\treturn 0;\n}\nPoint projection(Line l,Point p){\n\tdouble t = dot(p - l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\nbool intersectSP(Line s,Point p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble distanceSP(Line s,Point p){\n\tconst Point r = projection(s,p);\n\tif(intersectSP(s,r))return abs(r-p);\n\treturn min(abs(s[0] - p),abs(s[1] - p));\n}\nint main(){\n\tint r,n;\n\twhile(cin>>r>>n,r){\n\t\tint sc[50] = {};\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint l,r,h;\n\t\t\tcin>>l>>r>>h;\n\t\t\tl+=20,r+=20;\n\t\t\tfor(int j = l;j < r;j++){\n\t\t\t\tsc[j] = max(sc[j],h);\n\t\t\t}\n\t\t}\n\t\tPolygon G;\n\t\tG.push_back(Point(-100,0));\n\t\tG.push_back(Point(0,0));\n\t\tfor(int i = 0;i < 45;i++){\n\t\t\t\n\t\t\tif(i != 0){\n\t\t\t\tif(sc[i] != sc[i-1])\n\t\t\t\t\tG.push_back(Point(i,sc[i]));\n\t\t\t\t\n\t\t\t\tG.push_back(Point(i+1,sc[i]));\n\t\t\t}\n\t\t}\n\t\tG.push_back(Point(100,0));\n\n\t\tfor(int i = 0;i < G.size();i++){\n\t\t\t//cout<<G[i].real()<<\" \"<<G[i].imag()<<endl;\n\t\t}\n\n\t\tdouble low = -r,high = 25;\n\t\tint D = 50;\n\t\t//cout<<sc[20]<<endl;\n\t\twhile(D--){\n\t\t\tdouble mid = (low+high)/2;\n\t\t\tCircle C = Circle(Point(20,mid),r-EPS);\n\t\t\tdouble mi = INF;\n\t\t\tfor(int i = 0;i < G.size()-1;i++){\n\t\t\t\tdouble dist = distanceSP(Line(G[i],G[i+1]),C.p);\n\t\t\t\tmi = min(mi,dist);\n\t\t\t}\n\t\t\t//cout<<mid<<\" \"<<mi<<\" \"<<mid+r<<endl;\n\t\t\tif(mi < r - EPS)high = mid;\n\t\t\telse if(sc[20] < mid+r)high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\tprintf(\"%.4lf\\n\",low+r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\ndouble R;\nint n;\nint base = 50;\nbool building[55][100];\ndouble solve(){\n    fill(*building,*building+100*55,0);\n    double res = 0;\n    vector<int> xl(n),xr(n),h(n);\n    for(int i = 0; i < n;i++) cin >> xl[i] >> xr[i] >> h[i];\n    for(int i = 0; i < n;i++){\n        xl[i] += base; xr[i] += base;\n        for(int j = xl[i]; j < xr[i];j++){\n            for(int k = 0; k < h[i];k++){\n                building[k][j] = true;\n            }\n        }\n    }\n//    for(int i = 10; i >= 0; i--){\n//        for(int j = 40; j <= 60; j++){\n//            cout << building[i][j];\n//        }\n//        cout << endl;\n//    }\n    \n    double l = 0,r = 50;\n    for(int i = 0; i < 50;i++){\n        double m = (l+r)/2;\n        bool ok = true;\n        for(int x = -R; x < 0; x++){\n            double from = R - sqrt(R*R-(abs(x)-1)*(abs(x)-1));\n            double H = m - from;\n            if(H < 0) continue;\n            if(building[(int)H][x+base] == 0) ok = false;\n        }\n        for(int x = 0; x < R; x++){\n            double from = R - sqrt(R*R-x*x);\n            double H = m - from;\n            if(H < 0) continue;\n            if(building[(int)H][x+base] == 0) ok = false;\n        }\n        if(ok){\n            l = m;\n        }else{\n            r = m;\n        }\n    }\n    res = l;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> R >> n,n){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      printf(\"%lf %lf %lf\\n\", my, dx, t);\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(double r,int n){\n  double hl[100]={};\n  double hr[100]={};\n  double h[100]={};\n  double b = 20;\n  double ans = 30.0;\n  rep(i,n){\n    int x,y;\n    double z;\n    cin>>x>>y>>z;\n    x+=b; y+=b;\n    FOR(j,x+1,y){\n      hl[j]=max(hl[j],z);\n      hr[j]=max(hr[j],z);\n    }\n    hr[x]=max(hr[x],z);\n    hl[y]=max(hl[y],z);\n  }\n  rep(i,100){\n    h[i] = min(hl[i],hr[i]);\n    if(i==b-r&&hr[i]>hl[i]) h[i] = hr[i];\n    if(i==b+r&&hr[i]<hl[i]) h[i] = hl[i];\n  }\n\n  double i =b-r;\n\n  while(i<b+r+1){\n    double x = r+h[(int)i]-sqrt(r*r-(i-b)*(i-b));\n    \n    i +=1.0;\n  }\n\n  printf(\"%lf\\n\",ans);\n}\n\n\n\nint main(){\n  double r,n;\n  while(1){\n    cin>>r>>n;\n    if(r==0) break;\n    f(r,n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint r, n, xl, xr, h;\n\nint main(void) {\n  while(cin >> r >> n, r) {\n    map<pii, bool> m;\n    int mh = 0;\n    REP(i, 0, n) {\n      cin >> xl >> xr >> h;\n      REP(j, 0, h) REP(k, xl, xr) m[pii(j, k)] = true;\n      mh = max(mh, h);\n    }\n\n    // REP(i, 0, mh) {\n    //   REP(j, -r, r) {\n    //     cout << (m[pii(i, j)] ? 1 : 0);\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n\n    int y = 0, x = 10000;\n    REP(i, 0, mh + 1) {\n      REP(j, -r, r) {\n        if(!m[pii(i, j)]) {\n          int tmp;\n          y = i;\n          if(j < 0) tmp = -(j + 1);\n          else tmp = j;\n          x = min(x, tmp);\n        }\n      }\n      if(x != 10000) break;\n      y++;\n    }\n\n    // cout << y << \" \" << x << endl;\n\n    double t = y - sqrt(r * r - x * x) + r;\n    printf(\"%.4f\\n\", max(0.0, t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int R, N;\n  while (cin >> R >> N && R + N ){\n    vector<int> LS(N);\n    vector<int> RS(N);\n    vector<int> HS(N);\n    \n    map<int, int> C[30];\n    \n    REP(i, N){\n      cin >> LS[i] >> RS[i] >> HS[i];\n\n      REP2(j, LS[i], RS[i]){\n        REP(k, HS[i]){\n          C[k][j] = true;\n        }\n      }\n    }\n\n    \n    vector<pair<int, int> > PS;\n    \n    REP2(x, -30, 30) REP(y, 25){\n      if (abs(x) >= R) continue;\n\n      bool ok = true;\n      REP(j, N) if (LS[j] < x && x < RS[j] && HS[j] > y){\n        ok = false;\n      }\n\n      if (ok && (!C[y][x - 1] ||!C[y][x] || !C[y][x + 1])){\n         PS.push_back(make_pair(x, y));  \n      }\n      \n    }\n    \n    double res = 1e9;\n    for (auto p : PS){\n      res = min(res, R + p.second - sqrt(R * R - p.first * p.first));\n      // cout << p.first << \" \" << p.second << \" \" << res << endl;\n    }\n    cout << fixed << setprecision(20) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-6\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+2.0*eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)==out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)==out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tR -= eps;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint r;\n\tint n;\n\twhile (cin >> r >> n, r){\n\t\tdouble hight[40] = {0};\n\t\tdouble suny[41];\n\t\tREP(i, 41)\n\t\t\tsuny[i] = -1e9;\n\t\tREP(i, 41){\n\t\t\tif (-r<=i - 20&&i-20<=r )\n\t\t\t\tsuny[i] = -(double)r + sqrt((double)r*(double)r - (double)(i - 20)*(double)(i - 20));\n\t\t}\n\t\tREP(i, n){\n\t\t\tint x, x2, h;\n\t\t\tcin >> x >> x2 >> h;\n\t\t\tREP(i,x2-x){\n\t\t\t\thight[x + 20+i] = max(hight[x + 20+i], (double)h);\n\t\t\t}\n\t\t}\n\t\tdouble mi = 1e9;\n\t\tREP(i, 41){\n\t\t\tif (abs(i - 20) <= r){\n\t\t\t\tif (i - 20==-r)\n\t\t\t\t\tmi = min(mi, hight[i] -suny[i]);\n\t\t\t\tif (i - 20==r)\n\t\t\t\t\tmi = min(mi, hight[i-1] - suny[i]);\n\t\t\t\telse\n\t\t\t\t\tmi = min(mi, min(hight[i],hight[i-1]) - suny[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", mi);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-5\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(inct (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R+eps)return false;\n\tif(y<c-R-eps)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nint h[60];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tdouble L=0;\n\t\tdouble R=20;\n\t\tfor(int i=0;i<60;i++)h[i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r;\n\t\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\t\tp+=30;q+=30;\n\t\t\tfor(int j=p;j<q;j++)h[j]=max(h[j],r);\n\t\t}\n\t//\tfor(int i=0;i<60;i++)printf(\"%d \",h[i]);\n\t\t\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(L+R)/2;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=30-a+1;j<30+a;j++){\n\t\t\t\tdouble s=M+sqrt(a*a-(j-30)*(j-30))-a;\n\t\t\t\tif((double)h[j-1]<s||(double)h[j]<s)ok=false;\n\t\t\t}\n\t\t\tif(ok)L=M;\n\t\t\telse R=M;\n\t\t}\n\t\tprintf(\"%.12f\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(ll i=(n);i<(N);i++)\n#define RREP(i,n,N) for(ll i=(N-1);i>=(n);i--)\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(), (v).end()\n#define MCP(a,b) memcpy(b,a, sizeof(b))\n#define p(s) cout<<(s)<<endl\n#define p2(a,b) cout<<(a)<<\" \"<<(b)<<endl\ntypedef long long ll;\nusing namespace std;\nconst ll mod = 1e9+7;\nconst ll inf =1e18;\n\nll r, n;\nll height[50];\nint main(){\n    while(cin>>r>>n && r!=0 || n!=0){\n        REP(i,0,50) height[i] = 0;\n        REP(i, 0, n){\n            ll xl, xr, y;\n            cin>>xl>>xr>>y;\n            REP(j, xl, xr){\n                height[j+20]=max(height[j+20], y);\n            }\n        }\n\n        bool ok=false;\n        for(double t=0; t<=21; t+=0.0001){\n            REP(i, -r+1, r){\n                double h=sqrt(r*r-i*i);\n                if(h+t>=min(height[20+i], height[20+i-1])+r){\n                    printf(\"%.4lf\\n\", t);\n                    ok=true;\n                    break;\n                }\n            }\n            if(ok) break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<functional>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P,ll> B;\nconst int MOD = 1000000007;\nconst ll INF=2e18;\nconst double EPS=1e-10;\n\nll N,R;\nint main(){\n    while(cin>>R>>N,R!=0){\n        ll minL=INF,maxR=-INF;\n        map<ll,ll> lHeight;\n        map<ll,ll> rHeight;\n        for(ll i=0;i<N;i++){\n            ll l,r,h;\n            cin>>l>>r>>h;\n            minL=min(minL,l);\n            maxR=max(maxR,r);\n            for(ll j=l;j<r;j++){\n                if(lHeight.count(j)!=0){\n                    lHeight[j]=max(lHeight[j],h);\n                }else{\n                    lHeight[j]=h;\n                }\n            }\n            for(ll j=l+1;j<=r;j++){\n                if(rHeight.count(j)!=0){\n                    rHeight[j]=max(rHeight[j],h);\n                }else{\n                    rHeight[j]=h;\n                }\n            }\n        }\n        double ans=INF;\n        //R-t+h==R*R-w*w;\n        //2R-t\n        for(ll w=-R+1;w<R;w++){\n            ll h=min(lHeight[w],rHeight[w]);\n            if(R>abs(w))\n                ans=min(ans,R+h-sqrt(R*R-w*w));\n        }\n        cout<<setprecision(10)<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nconst double infty = 100000;\nbool c[50][50];\ndouble k[50][50];\nint n;\nint r;\n\n// const int d[4][2] = { {0,1}, {0,-1}, {1,0}, {-1,0} }; \n\nbool isedge(int x, int y) {\n  return c[x][y] != c[x-1][y] || c[x][y] != c[x][y-1]; \n}\n/* 独流でここに辿り着くまで時間がかかった。\n   今後のために解法をまとめておく。\n   ・境界の格子点がいつ円と交わるかを計算する。最小値が答え。(これはすぐ思いついた)\n   ・塗ってあるパネルは、左下の頂点で管理する。ここで重要なのは半開区間で塗りつぶすことだ。閉区間だと隙間があるとき判定できない。(冷静になるまで時間がかかった)\n   ・すると境界の判定は上記のようにできる。\n */\n\nint main() {\n  while (scanf(\"%d%d\", &r, &n) != EOF && r) {\n    fill(&c[0][0], &c[0][0]+50*50, false);\n    for (int x=0; x<50; x++) {\n      c[x][0] = true;\n    }\n    fill(&k[0][0], &k[0][0]+50*50, infty);\n    for (int kkk=0; kkk<n; kkk++) {\n      int x_l, x_r, h;\n      scanf(\"%d%d%d\", &x_l, &x_r, &h);\n      x_l += 25;\n      x_r += 25;\n      h += 1;\n      for (int x=x_l; x<x_r; x++) {\n\tfor (int y=1; y<h; y++) {\n\t  c[x][y] = true;\n\t}\n      }\n    }\n    double ans = infty;\n    for (int x=26-r; x<25+r; x++) {\n      for (int y=1; y<30; y++) {\n\tif (isedge(x, y)) {\n\t  k[x][y] = r + y - 1 - sqrt(r*r - (25-x)*(25-x));\n\t  /*if (k[x][y] < 3) {\n\t    cerr << \"x = \" << x-25 << \", y = \" << y-1 << \", k[x][y] = \" << k[x][y] << endl;\n\t    }*/\n\t  if (ans > k[x][y]) {\n\t    ans = k[x][y];\n\t  }\n\t}\n      }\n    }\n    printf(\"%.4f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T, class U>\ninline bool chmin(T& t, const U& f) { return t > f ? t = f, true : false; }\n\ntemplate <class T, class U>\ninline bool chmax(T& t, const U& f) { return t < f ? t = f, true : false; }\n\ntemplate <class T> inline T sqr(const T&& x) { return x * x; }\n\nint main() {\n    for (int r, n; cin >> r >> n, r | n;) {\n        vector<int> height(45);\n        while (n--) {\n            int xl, xr, h; cin >> xl >> xr >> h;\n            for (int x = xl; x < xr; ++x) chmax(height[x + 20], h);\n        }\n        double t = 20;\n        for (int x = -r; x < r; ++x) {\n            chmin(t, r - sqrt(r * r - sqr(x < 0 ? x + 1 : x)) + height[x + 20]);\n        }\n        cout << fixed << setprecision(4) << t << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\n\t\tint xl[20], xr[20], h[20];\n\t\tint sx = 21;\n\t\tint th = 0;\n\t\tint gx = -21;\n\t\tint t;\n\n\t\tfor (int i = 0; i < n;i++){\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (sx > xl[i] || (sx == xl[i] && th < h[i])){\n\t\t\t\tsx = xl[i];\n\t\t\t\tth = h[i];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t\tif (gx < xr[i]){\n\t\t\t\tgx = xr[i];\n\t\t\t}\n\t\t}\n\n\t\tmap<int, int> ma;\n\t\t\n\t\tfor (int x = -20; x <= 20; x++)ma[x] = 0;\n\t\tfor (int x = sx; x <= gx; x++){\n\n\t\t\tbool ef = false; int eh = -1;\n\t\t\tif (xr[t] == x){\n\t\t\t\tef = true; eh = 0;\n\t\t\t}\n\t\t\tint mh = th; int tt = t;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (xl[i] == x && mh < h[i]){\n\t\t\t\t\tmh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t\tif (x >= xl[i] && x < xr[i] && ef){\n\t\t\t\t\teh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mh != th){\n\t\t\t\tt = tt; th = mh;\n\t\t\t}else\n\t\t\tif (ef){\n\t\t\t\tth = eh; t = tt;\n\t\t\t}\n\t\t\tma[x] = th;\n\t\t}\n\t\t\n\t\tconst double PI = 3.14159265359;\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-5){\n\t\t\t\n\t\t\tdouble y = -double(r) + sqrt(r*r - x*x);\n\t\t\tint tx = (x >= 0 ? int(x) : int(x - (1.0 - 1e-6)));\n\t\t\tans = min(ans,double(ma[ tx  ]) - y);\n\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble r;\n\ndouble calc(int x, int h){\n     return h-sqrt(pow(r,2)-pow(x,2))+r;\n}\n\nint main(){\n    int n;\n    int map[50];\n    while(cin>>r>>n,r!=0){\n        fill(map, map+50,0);\n        int xl,xr,h;\n        for(int i=0;i<n;i++){\n            cin>>xl>>xr>>h;\n            for(int x=xl;x<xr;x++){\n                if(map[x+25]<h)map[x+25]=h;\n            }\n        }\n        double ans=calc(0,map[25]);\n        for(int x=floor(-r)+1;x<=ceil(r)-1;x++){\n            ans=min({ans,calc(x,map[25+x-1]),calc(x,map[25+x])});\n        }\n        cout.precision(8);\n        cout<<fixed;\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h[41]; //-20, 20\nint R;\n\nbool ok(double t)\n{\n\tfor (int i = -R; i < R; i++){\n\t\tdouble ly = 0, ry = 0;\n\t\t\n\t\tif (R * R - i * i >= 0) ly = max(ly, -R + t + sqrt(R * R - i * i));\n\t\tif (R * R - (i + 1) * (i + 1) >= 0) ry = max(ry, -R + t + sqrt(R * R - (i + 1) * (i + 1)));\n\t\t\n\t\tif (ly > h[i + 20] + 1e-15 || ry > h[i + 20] + 1e-15){\n\t\t\t//printf(\"ng [ly = %.10lf ry = %.10lf t = %.10lf h[%d] = %d\\n\", ly, ry, t, i, h[i + 20]);\n\t\t\treturn (false);\n\t\t}\n\t}\n\t\n\treturn (true);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d %d\", &R, &n) && n){\n\t\tmemset(h, 0, sizeof(h));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint l, r, y;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &y);\n\t\t\t\n\t\t\tfor (int i = l; i < r; i++) h[i + 20] = max(h[i + 20], y);\n\t\t}\n\t\t\n\t\tdouble l = 0, r = 20;\n\t\t\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tif (ok((l + r) / 2)) l = (l + r) / 2;\n\t\t\telse r = (l + r) / 2;\n\t\t}\n\t\t\n\t\tprintf(\"%.10lf\\n\", (l + r) / 2);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\nstruct Point {\n\n\n    double x, y;\n\n    Point() {\n        x = 0;\n        y = 0;\n    }\n\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n\n    inline Point operator+=(double s) {\n        this->y += s;\n    }\n\n//    constexpr Point operator+(Point rhs) const {\n//        return {x + rhs.x, y + rhs.y};\n//    }\n//\n//    constexpr Point operator-(Point rhs) const {\n//        return {x - rhs.x, y - rhs.y};\n//    }\n\n};\n\ninline Point operator+(double s, Point p) {\n    return {p.x, s + p.y};\n}\n\n\nstruct Rect {\n\n    Point left;\n    Point right;\n\n    Rect() {\n\n    }\n\n    Rect(int left_x, int right_x, int y) {\n        left = Point(left_x, y);\n        right = Point(right_x, y);\n    }\n\n};\n\nbool isSection(Point point, Rect rect) {\n    if (rect.left.x <= point.x && point.x <= rect.right.x && point.y <= rect.left.y) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n\n    while (true) {\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0) {\n            break;\n        }\n\n        vector<Point> circlePoints(100000);\n        REP(i, circlePoints.size()) {\n            double x = -r + ((2.0 * r) * ((double) i / (double) circlePoints.size()));\n            double y = sqrt(r * r - x * x);\n            circlePoints[i] = Point(x, y);\n        }\n\n        vector<Rect> rects(n + 1);\n        REP(i, n + 1) {\n            if (i == n) {\n                rects[n] = Rect(-1000, 1000, 0);\n            } else {\n                int left, right, h;\n                cin >> left >> right >> h;\n                rects[i] = Rect(left, right, h);\n            }\n        }\n\n        double diff = 10;\n\n        bool plus = true;\n        while (diff > 0.00001) {\n            if (plus) {\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += diff;\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n                if (good) {\n                    continue;\n                } else {\n                    diff /= 2.0000;\n                    plus = false;\n                    // cout << diff;\n                }\n\n            } else {\n\n\n                //cout << \"here\";\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += (-diff);\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n\n                if (good) {\n                    diff /= 2.0000;\n                    plus = true;\n                    //cout << diff << endl;\n                } else {\n                    continue;\n                }\n            }\n        }\n\n        double largeY = -1;\n        REP(i, circlePoints.size()) {\n            largeY = max(largeY, circlePoints[i].y);\n        }\n\n\n//        double ans = floor_n(largeY, 4);\n        cout << fixed << setprecision(6) << largeY << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\ndouble R;\nint n;\nint base = 50;\nbool building[55][100];\ndouble solve(){\n    fill(*building,*building+100*55,0);\n    double res = 0;\n    vector<int> xl(n),xr(n),h(n);\n    for(int i = 0; i < n;i++) cin >> xl[i] >> xr[i] >> h[i];\n    for(int i = 0; i < n;i++){\n        xl[i] += base; xr[i] += base;\n        for(int j = xl[i]; j < xr[i];j++){\n            for(int k = 0; k < h[i];k++){\n                building[k][j] = true;\n            }\n        }\n    }\n//    for(int i = 10; i >= 0; i--){\n//        for(int j = 40; j <= 60; j++){\n//            cout << building[i][j];\n//        }\n//        cout << endl;\n//    }\n    \n    double l = 0,r = 50;\n    for(int i = 0; i < 50;i++){\n        double m = (l+r)/2;\n        bool ok = true;\n        for(int x = -R; x < 0; x++){\n            double from = R - sqrt(R*R-(abs(x)-1)*(abs(x)-1));\n            double H = m - from;\n            if(H < 0) continue;\n            if(building[(int)H][x+base] == 0) ok = false;\n        }\n        for(int x = 0; x < R; x++){\n            double from = R - sqrt(R*R-x*x);\n            double H = m - from;\n            if(H < 0) continue;\n            if(building[(int)H][x+base] == 0) ok = false;\n        }\n        if(ok){\n            l = m;\n        }else{\n            r = m;\n        }\n    }\n    res = l;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> R >> n,n){\n        cout << fixed << setprecision(4) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\n\nfloat solve(int r, vector<array<int, 3>>& vs)\n{\n    std::array<int, 41> imos;\n    for(auto& e: imos) e = 0;\n\n    for(auto& e: vs){\n        imos[e[0] + 20] += 1;\n        imos[e[1] + 20] += -1;\n    }\n\n    int s = 0;\n    for(auto& e: imos){\n        s += e;\n        e = s;\n    }\n\n    int maxL = 0, maxR = 0;\n    for(int i = 0; i <= 20; ++i){\n        if(imos[i+20] == 0)\n            break;\n        maxL = i + 1;\n    }\n    for(int i = 0; i >= -20; --i){\n        if(imos[i+20] == 0)\n            break;\n        maxR = -i;\n    }\n\n    // for(auto&e : imos)\n    //     cout << e << \", \";\n    // cout << endl << \"maxL: \" << maxL << \", maxR: \" << maxR << endl;\n\n    int width = (maxL < maxR ? maxL : maxR) * 2;\n    // if(width != 0) width -= 1;\n    if(width == 0) return 0;\n    if(width > r)\n        width = r*2;\n\n    // cout << width << endl;\n\n    int wh = width / 2;\n    float whf = wh;\n\n    float hd = r - sqrt(r*r - whf*whf);\n    if(!(hd > 0)) hd = 0;\n\n    std::array<int, 41> maxH;\n    for(auto& e: maxH) e = 0;\n    for(auto& e: vs){\n        for(int i = -20; i <= 20; ++i)\n            if(e[0] <= i && i < e[1]){\n                if(maxH[i+20] < e[2])\n                    maxH[i+20] = e[2];\n            }\n    }\n\n\n\n    float max = 0;\n    for(int i = -wh; i <= wh; ++i){\n        auto hh = sqrt(r*r - i*i) - (r - hd);\n        if(maxH[i+20] < hh && max < (hh - maxH[i+20])){\n            max = hh - maxH[i+20];\n        }\n    }\n\n    // cout << \"max: \" << max << endl;\n    // cout << \"hd: \" << hd << endl;\n\n    // for(auto&e : maxH)\n    //     cout << e << \", \";\n    // cout << endl;\n\n    if(max == 0){\n        float mm = 1024, ret = 0;\n        for(int i = -wh; i <= wh; ++i){\n            float rm1 = maxH[i+20] - sqrt(r*r - (i+1)*(i+1));\n            float rm2 = maxH[i+20] - sqrt(r*r - i*i);\n            float rm = rm1 < rm2 ? rm1 : rm2;\n            // cout << \"i: \" << i << \", rm1: \" << rm1 << \", rm2: \" << rm2 << endl;\n            if(maxH[i+20] != 0 && mm > rm){\n                mm = rm;\n                ret = rm + whf;\n            }\n        }\n\n        // cout << \"mm: \" << mm << endl;\n        return ret;\n    }\n\n    return hd - max;\n}\n\n\nint main(void)\n{\n    int r, n;\n    while(cin >> r >> n){\n        if(r == 0 && n == 0)\n            break;\n\n        vector<array<int, 3>> vs;\n        for(int i = 0; i < n; ++i){\n            array<int, 3> arr;\n            cin >> arr[0] >> arr[1] >> arr[2];\n            vs.push_back(arr);\n        }\n\n        cout << fixed << setprecision(4) << solve(r, vs) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\nint main(){\n\n  while(1){\n    int r,n;\n    cin >> r >> n;\n    if(r==0&&n==0) break;\n    int field[41]={};\n    int *hs = &field[20];\n\n    rep(i,n){\n      int x1,x2,h;\n      cin >> x1 >> x2 >> h;\n      REP(j,x1,x2) hs[j]=max(hs[j],h);\n    }\n    \n    double ans = 1e15;\n    for(int i=-r;i<r;i++){\n      double x;\n      if(i<0) x = x+1;\n      else x = i;\n      ans = min(ans,r-sqrt(r*r-x*x)+hs[i]);\n    }\n    \n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    int r, n;\n    while(cin >> r >> n, r) {\n        vector<int> v(25), u(25);\n        for (int i = 0; i < n; ++i) {\n            int p, q, h;\n            cin >> p >> q >> h;\n            for (int j = p; j < q; ++j) {\n                if(j < 0){\n                    u[-j-1] = max(u[-j-1], h);\n                }else {\n                    v[j] = max(v[j], h);\n                }\n            }\n        }\n        double ans = INF<int>;\n        for (int i = 0; i < r; ++i) {\n            v[i] = min(v[i], u[i]);\n            ans = min(ans, r+v[i]-sqrt(r*r-i*i));\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cmath>\n#include<stdio.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\ndouble solve(int r,int n){\n  bool box[21][41];\n  rep(y,21) rep(x,41) box[y][x]=false;\n  rep(i,n) {\n    int li,ri,hi;\n    cin >> li >> ri >> hi;\n\n    for(int y=0;y<hi;++y) {\n      for(int x=li+20;x<ri+20;++x){\n        box[y][x]=true;\n      }\n    }\n\n  }\n  double ans=(double)1e8;\n  rep(y,21){\n    for(int x=20-r;x<r+20;x++) {\n      if(!box[y][x]){\n      double time;\n      if(x<20) time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n      else time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n      ans=min(ans,time);\n    }\n    }\n  }\n  return ans;\n}\n\nint main(int argc, char *argv[])\n{\n  int r,n;\n  while(cin>>r>>n, n&&r){\n    printf(\"%.4lf\\n\",solve(r,n));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n\nstruct S{\n\tint l,r,h;\n}b[20];\n\n\nint main(){\n\tint r,n;\n\twhile(cin>>r>>n,r|n){\n\t\trep(i,n)cin>>b[i].l>>b[i].r>>b[i].h;\n\t\tdouble ans=20;\n\t\tvector<int> x;\n\t\trep(i,n){x.push_back(b[i].l);x.push_back(b[i].r);}\n\t\tx.push_back(0);\n\t\tx.push_back(-r);\n\t\tx.push_back(r);\n\t\trep(i,x.size()){\n\t\t\tif(x[i]<-r||r<x[i])continue;\n\t\t\tint y=20;\n\t\t\tint f=0;\n\t\t\tif(x[i]==r)f|=1;\n\t\t\tif(x[i]==-r)f|=2;\n\t\t\trep(j,n){\n\t\t\t\tif(x[i]==b[j].l||x[i]==b[j].r)\n\t\t\t\t\ty=min(y,b[j].h);\n\t\t\t\tif(x[i]==b[j].l)f|=1;\n\t\t\t\tif(x[i]==b[j].r)f|=2;\n\t\t\t}\n\t\t\tif(f!=3)y=0;\n\t\t\trep(j,n){\n\t\t\t\tif(b[j].l<x[i]&&x[i]<b[j].r){\n\t\t\t\t\ty=max(y,b[j].h);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble t=y+r-sqrt((double)(r*r-x[i]*x[i]));\n\t\t\tans=min(ans,t);\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 1e9 + 7;\nusing pii = pair<int, int>;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\nconst int mod = 1e9 + 7;\nll power(ll a,ll b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\n\nint main() {\n    int r, n;\n    while (cin >> r >> n) {\n        if (r == 0 && n == 0) break;\n        vector<pair<pair<double, double>, double> > v;\n        rep(i, n) {\n            int xl, xr, h; cin >> xl >> xr >> h;\n            v.push_back({{xl, xr}, h});\n        }\n        double left = -r, right = r + 20; //center\n        int c = 0;\n        int roll = 100;\n        while (c++ < roll) {\n            double mid = (left + right) / 2;\n            //cout << \"mid \" << mid << endl;\n            int flg = 0;\n            rep(i, 1000) {\n                flg = 0;\n                double x = r * cos(2 * M_PI * i / 360);\n                double y = mid + r * sin(2 * M_PI * i / 360);\n                rep(j, v.size()) { //どっかの中に入ってろ\n                    if (v[j].first.first <= x && x <= v[j].first.second && y <= v[j].second) {\n                        //if (mid == 1) cout << v[j].first.first << \" \" << v[j].first.second << \"   \" << x << \" \" << y << endl;\n                        flg = 1;\n                        break;\n                    }\n                }\n                if (flg == 0) {\n                    right = mid;\n                    break;\n                }\n            }\n            if (flg == 1) {\n                left = mid;\n            }\n            //cout << left << \" \" << right << endl;\n            if (c == roll) cout << mid + r << endl;\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-5\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tR -= eps;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\ndouble r;\nll n;\nll ymax[100][2];\n\nint main(){\n\twhile(cin >> r >> n && r){\n\t\trep(i,100)rep(j,2)ymax[i][j] = 0;\n\t\tdouble ans = INF;\n\t\trep(i,n){\n\t\t\tll lb,ub,h;\n\t\t\tcin >> lb >> ub >> h;\n\t\t\tlb += 50;\n\t\t\tub += 50;\n\t\t\tFOR(i,lb,ub+1){\n\t\t\t\tif(i != lb)ymax[i][0] = max(ymax[i][0],h);\n\t\t\t\tif(i != ub)ymax[i][1] = max(ymax[i][1],h);\n\t\t\t}\n\t\t}\n\t\tFOR(i,50-r+1,50+r){\n\t\t\tdouble y = min(ymax[i][0],ymax[i][1]);\n\t\t\tdouble absx = abs(i-50);\n\t\t\tdouble g = sqrt(r*r - absx*absx);\n\t\t\t// cout << i << \" \" << y << endl;\n\t\t\tans = min(ans,r + y - g);\n\t\t}\n\t\tprintf(\"%.10lf\\n\",ans);\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R, V, E;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tlong double r;\n\tvector<long double>ans;\n\tcin >> r >> N;\n\twhile (N) {\n\t\tmap<long double, long double>m;\n\t\tfor (long double j = -20; j <= 20; j+=0.5) {\n\t\t\tm[j] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a, b;\n\t\t\tlong double c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tfor (long double j = a; j <= b; j+=0.5) {\n\t\t\t\tm[j] = max(m[j], c);\n\t\t\t}\n\t\t}\n\t\tfor (long double i = -r + 0.5; i <= r - 0.5; i += 1) {\n\t\t\tm[i - 0.5] = min(m[i], m[i - 0.5]);\n\t\t\tm[i + 0.5] = min(m[i], m[i + 0.5]);\n\t\t}\n\t\tlong double ret = 10000;\n\t\tfor (int i = -20; i <= 20; i++) {\n\t\t\tif (abs(i) > abs(r))continue;\n\t\t\tlong double box = sqrt(r*r - i * i);\n\t\t\tret = min(ret, m[i] - box + r);\n\t\t//\tcout << i << \" \" << m[i] << endl;\n\t\t}\n\t\tans.push_back(ret);\n\t\tcin >> r >> N;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << setprecision(20) << i << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\ndouble mk_dis(int x1,int h,double cy){\n  return sqrt(x1*x1+(h-cy)*(h-cy));\n}\n\nbool check(double cy){\n  //  cy=(int)(cy*100000)/100000.0;\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=(-x-0.999999),R=(x+0.999999),hb[101]={};\n  for(int i=L+50;i<R+50;i++)\n    if(i>=50){\n      if(mk_dis(i-50,y[i],cy)>=r)hb[i]++;\n    }\n    else {\n      if(mk_dis(i-49,y[i],cy)>=r)hb[i]++;\n    }\n  \n  for(int i=L+50;i<R+50;i++)if(!hb[i])return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    memset(y,0,sizeof(y));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans;\n    for(ans=0;check(ans-r);ans+=0.0001);\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(n); ++i)\nusing namespace std;\n#define N 20\n//#define vec vector<int>\n\nclass rec {\npublic:\n  int l;\n  int r;\n  int h;\n  rec(int l_ = 0, int r_ = 0, int h_ = 0) : l(l_), r(r_), h(h_) {}\n};\n\nint main(){\n  while(true){\n    int r,n;\n    cin>>r>>n;\n    if(r==0){\n      break;\n    }\n    n++;\n    vector<rec> v(n);\n    REP(i,n-1){\n      int tl,tr,th;\n      cin>>tl>>tr>>th;\n      v[i] = rec(tl,tr,th);\n    }\n    v[n-1] = rec(-20, 20, 0);\n    //hについて降順ソート\n    sort(v.begin(), v.end(), [](rec lhs, rec rhs){ return lhs.h > rhs.h;});\n\n    //左右で覆われている範囲\n    vector<int> pl(n,0);\n    vector<int> pr(n,0);\n    vector<int> p(n,0);\n\n    //pを計算\n    REP(i,n){\n      REP(j,n){\n        if(v[j].h <= v[i].h) break;\n        if(v[j].l <= pr[i]){\n          pr[i] = max(pr[i], v[j].r);\n        }\n        if(v[j].r >= pl[i]){\n          pl[i] = min(pl[i], v[j].l);\n        }\n      }\n    }\n    REP(i,n){\n      p[i] = min(-pl[i], pr[i]);\n    }\n\n    //tを計算\n    double t = 500.0;\n    REP(i,n){\n      if(r<=p[i]) continue;\n      double tmp = v[i].h + r - sqrt(r*r - p[i]*p[i]);\n      t = min(tmp,t);\n    }\n    cout<<t<<endl;\n\n    //debug\n    /*\n    REP(i,n){\n      cout<<\"v[\"<<i<<\"] = \"<<v[i].l<<\" \"<<v[i].r<<\" \"<<v[i].h<<endl;\n    }\n    REP(i,n){\n      cout<<\"p[\"<<i<<\"] = \"<<pl[i]<<\" \"<<pr[i]<<\" \"<<p[i]<<endl;\n    }\n    */\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  cout << fixed << setprecision(10) << endl;\n  for(;;){\n    int r,n;\n    cin >> r >> n;\n    if(!r) return 0;\n    map<int,int> a,b;\n    REP(i,n){\n      int xl,xr,h;\n      cin >> xl >> xr >> h;\n      FOR(j,xl,xr){\n\ta[j]=max(a[j],h);\n\tb[j+1]=max(b[j+1],h);\n      }\n    }\n    double answer=1000.0;\n    answer=min(answer,r+1.0*a[-r]);\n    FOR(i,-r+1,r) answer=min(answer,r-sqrt(r*r-i*i)+min(a[i],b[i]));\n    answer=min(answer,r+1.0*b[r]);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": " #include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint hs[100][100];\nint main(){\n  int n;\n  double r;\n  while(cin>>r>>n,r&&n){\n    memset(hs,0,sizeof(hs));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      x1+=20;\n      x2+=20;\n      for(int i=x1;i<x2;i++){\n\tfor(int j=0;j<=h;j++)\n\t  hs[i][j]=1;\n      }\n    }\n    auto check = [&](double t){\n      for(int i=0;i<r;i++){\n\tdouble x=i;\n\tint y=sqrt(r*r-x*x)+t+1-r;\n\t//cout<<i<<\" \"<<t<<\" \"<<y<<endl;\n\tif(y<0)continue;\n\tif(!hs[i+20][y])return false;\n\tif(!hs[-i+20-1][y])return false;\n\t\n      }\n      return true;\n    };\n    double ub=100,lb=0,mid;\n    for(int i=0;i<200;i++){\n      mid=(ub+lb)/2;\n      if(check(mid))lb=mid;\n      else ub=mid;\n    }\n    cout<<fixed<<setprecision(12)<<lb<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n    double r;\n    int n;\n    while (cin >> r >> n, r || n) {\n        vector<double> height(21 * 2 + 1, 0);\n        for (int i = 0; i < n; i++) {\n            int x1, x2;\n            double h;\n            cin >> x1 >> x2 >> h;\n            for (int j = x1; j < x2; j++) {\n                height[j + 21] = h;\n            }\n        }\n\n        double res = 20. + r;\n        for (int i = 0; i < 21 * 2 + 1; i++) {\n            if (abs(i - 21) >= r) continue;\n            double low = min(height[i-1], height[i]);\n            double C = low * low + abs(i - 21) * abs(i - 21) - r * r;\n            double ret = low - sqrt(pow(low,2) - C) + r;\n            res = min(res, ret);\n        }\n\n        printf(\"%.4f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nusing ll = long long;\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int r, n; cin >> r >> n;\n        if (r == 0) break;\n        int height[40] = {0};\n        int heightl[40] = {0};\n        int heightr[40] = {0};\n        for (int i=0, xl, xr, h; i<n; i++) {\n            cin >> xl >> xr >> h;\n            heightl[xl+20] = max(heightl[xl+20], h);\n            heightr[xr+20] = max(heightr[xr+20], h);\n            for (int x=xl+1; x<xr; x++) {\n                height[x + 20] = max(height[x + 20], h);\n            }\n        }\n        double ans = 100;\n        for (int x=-r; x<=r; x++) {\n            int h;\n            if (x == -r) h = max(height[x + 20], heightl[x + 20]);\n            else if (x == r)  h = max(height[x + 20], heightr[x + 20]);\n            else h = min(max(height[x + 20], heightl[x + 20]), max(height[x + 20], heightr[x + 20]));\n            ans = min(ans, (double)h - (sqrt(r*r - x*x) - r));\n        }\n        cout << setprecision(15) << fixed << ans << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41];\n  double xl, xr, ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint h[41]; //-20, 20\nint R;\n \nbool ok(double t)\n{\n\tint D = ceil(t);\n\tD = min(D, R);\n\tfor (int i = -D; i < D; i++){\n\t\tdouble ly = 0, ry = 0;\n \n\t\tif (R * R - i * i >= 0) ly = max(ly, -R + t + sqrt(R * R - i * i));\n\t\tif (R * R - (i + 1) * (i + 1) >= 0) ry = max(ry, -R + t + sqrt(R * R - (i + 1) * (i + 1)));\n \n\t\tif (ly > h[i + 20] + 1e-15 || ry > h[i + 20] + 1e-15){\n\t\t\t//printf(\"ng [ly = %.10lf ry = %.10lf t = %.10lf h[%d] = %d\\n\", ly, ry, t, i, h[i + 20]);\n\t\t\treturn (false);\n\t\t}\n\t}\n \n\treturn (true);\n}\n \nint main()\n{\n\tint n;\n \n\twhile (scanf(\"%d %d\", &R, &n) && n){\n\t\tmemset(h, 0, sizeof(h));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint l, r, y;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &y);\n \n\t\t\tfor (int i = l; i < r; i++) h[i + 20] = max(h[i + 20], y);\n\t\t}\n \n\t\tdouble l = 0, r = 20;\n \n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tif (ok((l + r) / 2)) l = (l + r) / 2;\n\t\t\telse r = (l + r) / 2;\n\t\t}\n \n\t\tprintf(\"%.10lf\\n\", (l + r) / 2);\n\t}\n \n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\tint r, n;\n\twhile(cin >> r >> n) {\n\n\t\tif(r == 0 && n == 0) break;\n\n\t\tvector<pair<int, P> > v(n);\n\t\trep(i, n) cin >> v[i].second.first >> v[i].second.second >> v[i].first;\n\n\t\tint H[60], GETA = 30;\n\t\tmemset(H, 0, sizeof(H));\n\n\n\t\trep(i, n) {\n\t\t\tint h = v[i].first, x1 = v[i].second.first, x2 = v[i].second.second;\n\n\t\t\tREP(j, x1, x2) {\n\t\t\t\tH[j + GETA] = max(H[j + GETA], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tREP(i, -r+1, r) {\n\t\t\tdouble res = r + min(H[i + GETA], H[i - 1 + GETA]);\n\t\t\tans = min(ans, res - sqrt(r*r - i*i));\n\t\t}\n\n\t\tcout << fixed;\n\t\tcout.precision(4);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\t\t\n\t\tmap<int, int> d;\n\t\tfor (int x = -21; x < 21; x++)d[x] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint xl, xr, h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor (int x = xl+1; x <= xr; x++)d[x] = max(d[x], h);\n\t\t}\n\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-4/5){\n\n\t\t\t/*\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\t*/\n\t\t\tint tx = (x >= 0 ? int(x + (1.0 - 1e-7)) : int(x));\n\t\t\tif (x == -r)tx++;\n\t\t\tdouble ty = double(r) - sin(acos(abs(x / double(r)))) * double(r);\n\n\t\t\tans = min(ans, double(d[tx]) + ty);\n\t\t}\n\n\t\tcout << setprecision(6) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\twhile (true) {\n\t\tint r, n;\n\t\tcin >> r >> n;\n\n\t\tif (r == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbool grid[21][41];\n\t\tfor (int i = 0; i < 21; i++) {\n\t\t\tfor (int j = 0; j < 41; j++) {\n\t\t\t\tgrid[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint lx, rx, y;\n\t\t\tcin >> lx >> rx >> y;\n\n\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\tfor (int k = lx + 20; k < rx + 20; k++) {\n\t\t\t\t\tgrid[j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 10000000;\n\n\t\tfor (int y = 0; y < 21; y++) {\n\t\t\tfor (int x = -r + 20; x < r + 20; x++) {\n\t\t\t\tif (grid[y][x] == false) {\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (x < 20) {\n\t\t\t\t\t\ttemp = (double)r - sqrt((double)r * 2 - abs(x - 19)*abs(x - 19)) + y;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttemp = (double)r - sqrt((double)r * 2 - abs(x - 20)*abs(x - 20)) + y;\n\t\t\t\t\t}\n\t\t\t\t\tans = min(ans, temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.4f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint R, N; \nint x1,x2,h;\nint B[50];\ndouble ans = 10000.0;\n\ndouble b(double x) {\n\treturn (double) B[(int) (x + 25.0)];\n\t\n}\n\ndouble sun(double x) {\n\tdouble r = R;\n\treturn sqrt(r * r - x * x) - r;\n}\n\ndouble f(double x) {\n\treturn b(x) - sun(x);\n}\n\nint main() {\n\tcin >> R >> N;\n\twhile(R + N) {\n\t\tans = 10000000.0;\n\t\tfor (int i = 0; i < 50; i ++) {\n\t\t\tB [i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x1 >> x2 >> h;\n\t\t\tx1 += 25;\n\t\t\tx2 += 25;\n\t\t\tfor (int x = x1; x < x2; x++ ) {\n\t\t\t\tB[x] = max(B[x], h);\n\t\t\t}\n\t\t}\n\t\tdouble r = R;\n\t\tfor (double x = -r; x < r; x += 0.00005) {\n\t\t\tans = min(ans, f(x));\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\tcin >> R >> N;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\nstring s[50],t[50];\nsigned main(){\n\tint n,m,r;\n\t/*\n\tdouble d;\n\tcin>>d;\n\t\n\tdouble ans=0;\n\tfor(int i=0;i<=10;i++){\n\t\tif(i>d) break;\n\t\tdouble ii=i+0.0;\n\t\tans=max(ans,sqrt(d*d-ii*ii));\n\t}\n\tprintf(\"%.10lf\\n\",ans);\n\t*/\n\t\n\twhile(1){\n\tcin>>r>>n;\n\t\t//int sumi[200]={0};\n\t\tif(n==0&&r==0) return 0;\n\t\tint a[100]={0};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x2,x1,h;\n\t\t\tcin>>x1>>x2>>h;\n\t\t\tfor(int i=x1+50+1;i<=x2+50;i++) a[i]=max(a[i],h);\n\t\t}\n\t\tint aa[100]={0};\n//\t\tfor(int i=50-r;i<=50+r;i++) cout<<aa[i]<<endl;\n\t\tfor(int i=50-r-2;i<=r+50+2;i++) aa[i]=min(a[i],a[i+1]);\n\t//\t\tfor(int i=50-r;i<=50+r;i++) cout<<i-50<<\" \"<<aa[i]<<endl;\n\t\tdouble ans=1000000000;\n\t\tfor(int i=50-r+1;i<=50+r-1;i++){\n\t\t\tint d=i-50;\n\t\t\tdouble w=(r+0.0)-sqrt((r+0.0)*(r+0.0)-(d+0.0)*(d+0.0));\n\t\t\tans=min(ans,aa[i]+w)\t;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",ans);\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint xl[25], xr[25], h[25];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint r, n;\n\t\tcin >> r >> n;\n\t\tif(!r && !n) break;\n\t\tREP(i, n) cin >> xl[i] >> xr[i] >> h[i];\n\n\t\tdouble hi = 60, low = 0;\n\t\tREP(i, 20) {\n\t\t\tdouble mid = (hi+low)/2;\n\t\t\t//cout << hi << \" \" << mid << \" \" << low << endl;\n\t\t\tbool flag = true;\n\t\t\tREP(j, 200000) {\n\t\t\t\tdouble x = -r + (double)(2*r)*j/200000;\n\t\t\t\tint ma = 0;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tif(xl[k] <= x && x <= xr[k]) {\n\t\t\t\t\t\tma = max(ma, h[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble H = sqrt(r*r-x*x) + mid - r;\n\t\t\t\t// cout << ma << \" \" << H << endls\n\t\t\t\tif(ma < H) {flag = false; break;}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << low << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nbool kage[41][21];\n\nint main(){\n\tint n,r;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r+n==0)break;\n\t\tmemset(kage,false,sizeof(kage));\n\t\tREP(i,n){\n\t\t\tint x1,x2,h;\n\t\t\tcin>>x1>>x2>>h;\n\t\t\tfor(int x=x1+20;x<x2+20;x++){\n\t\t\t\tfor(int y=0;y<h;y++){\n\t\t\t\t\tkage[x][y]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool w=false;\n\t\tdouble ans=0.0;\n\t\tREP(i,21){\n\t\t\tint c=0;\n\t\t\twhile(kage[20+c][i]&&kage[19-c][i])c++;\n\t\t\tif(c==0)break;\n\t\t\tif(c>=r){\n\t\t\t\tans=(double)(i+1);\n\t\t\t}else{\n\t\t\t\tdouble res=(double)(r)-sqrt((double)(r*r)-(double)(c*c));\n\t\t\t\tif(w){\n\t\t\t\t\tans=min((double)i+res,ans);\n\t\t\t\t}else{\n\t\t\t\t\tans+=res;\n\t\t\t\t\tw=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\ndouble r,n;\nint xl[21];\nint xr[21];\nint h[21];\nint ma[50];\nint main(){\n   while(cin>>r,cin>>n,r){\n       REP(i,n){\n             cin>>xl[i]>>xr[i]>>h[i];\n               xl[i]+=20;\n               xr[i]+=20;\n        }\n       REP(i,50){\n             int now=0;\n             REP(j,n){\n                    if(xl[j]<i&&i<=xr[j]){\n                          now=max(now,h[j]);\n                       }\n               }\n             ma[i]=now;\n        }\n        /*\n       for(int i=20;i>0;i--){\n            ma[i-1]=min(ma[i],ma[i-1]);\n        }\n       for(int i=20;i<=39;i++){\n            ma[i+1]=min(ma[i],ma[i+1]);\n        }*/\n        /*REP(i,40){\n              if(i<10)continue;\n                cout<<ma[i]<<endl;\n          }*/\n\n       double ans=1e6;\n       REP(i,41){\n             double dx=abs(20-i);\n             if(i>20){\n                  dx--;\n               }\n             if(r*r<=dx*dx){\n                  continue;\n               }\n               //cout<<r<<dx<<ma[i]<<endl;\n             double yy=-sqrt(double(r)*r-dx*dx)+r+ma[i];\n              // cout<<sqrt(double(r)*r-dx*dx)<<endl;\n             ans=min(ans,yy);\n        }\n       cout<<ans<<endl;\n   }\n   return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int r; //半径\n        int max=0;  //高さの最大値\n        int n;\n        cin >> r >> n;\n        int r_min = 0 - r; //半径のマイナス\n        double t=20.0;\n        int x_i[n],x_j[n],h[n];\n        for(int i=0;i<n;i++){\n            cin >> x_i[i] >> x_j[i] >> h[i];\n            if(max<h[i])    max=h[i];\n        }\n        int a[max][r+r];\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<max;j++){\n                for(int l=-r;l<r;l++){\n                    if(x_i[i]<=l && x_j[i]>l){\n                        if(h[i]>=j){\n                            a[j-1][l+r]++;\n                        }\n                    }\n                }\n            }\n        }\n        int count=0;\n        double u=0.0;\n        int min=10;\n        int h_a,x_a;\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                if(a[i][j]==0){\n                    if(j<r){\n                        if(min>i+(r-1)-j){\n                            min=i+(r-1)-j;\n                            h_a=i;\n                            x_a=(r-1)-j;\n                        }\n                    }else{\n                        if(min>i+j-r){\n                            min=i+j-r;\n                            h_a=i;\n                            x_a=j-r;\n                        }\n                    }\n                }\n            }\n        }\n        t=(double)r-sqrt(r*r-x_a*x_a)+(double)h_a;\n        printf(\"%.4f\",t);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid run(int r, int n) {\n\tvector< int > s(n), t(n), h(n);\n\tfor (int i=0; i<n; ++i) cin >> s[i] >> t[i] >> h[i];\n\t\n\tdouble ans = 1e9;\n\tfor (int x=-r; x<=r; ++x) {\n\t\tint hx = 0;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tif (abs(x) == r && s[i] <= r && r <= t[i]) hx = max(hx, h[i]);\n\t\t\telse if (s[i] < x && x < t[i]) hx = max(hx, h[i]);\n\t\t}\n\t\tfor (int i=0; i<n; ++i) for (int j=0; j<n; ++j) if (i != j && t[i] == s[j] && t[i] == x) hx = max(hx, min(h[i], h[j]));\n\t\tans = min(ans, r - (double)r * sin(acos((double)x / r)) + hx);\n\t}\n\t\n\tprintf(\"%.5lf\\n\", ans);\n}\n\nint main() {\n\tint r, n;\n\twhile (cin >> r >> n, r) run(r, n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex< double > Point;\ntypedef vector< Point > Polygon;\nnamespace std{\n\tbool operator < ( Point a, Point b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n};\nconst double INF = 1e12;\nconst double EPS = 1e-8;\nPoint NextPoint(){\n\tPoint P;\n\tcin>>P.real()>>P.imag();\n\treturn P;\n}\nstruct Line : Polygon{\n\tLine(){};\n\tLine(Point p, Point q){push_back(p);push_back(q);}\n};\n\nstruct Circle{\n\tPoint p;\n\tdouble r;\n\tCircle();\n\tCircle(Point a, double s){p = a,r = s;}\n};\ndouble cross(Point p, Point q){\n\treturn imag(conj(p)*q);\n}\ndouble dot(Point p,Point q){\n\treturn real(conj(p)*q);\n}\nint ccw(Point a,Point b,Point c){\n\tb -= a,c -= a;\n\tif(cross(b,c) > 0)return 1;\n\tif(cross(b,c) < 0)return -1;\n\tif(dot(b,c) < 0 )return 2;\n\tif(norm(b) < norm(c))return -2;\n\treturn 0;\n}\nPoint projection(Line l,Point p){\n\tdouble t = dot(p - l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\nbool intersectSP(Line s,Point p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble distanceSP(Line s,Point p){\n\tconst Point r = projection(s,p);\n\tif(intersectSP(s,r))return abs(r-p);\n\treturn min(abs(s[0] - p),abs(s[1] - p));\n}\nint main(){\n\tint r,n;\n\twhile(cin>>r>>n,r){\n\t\tint sc[50] = {};\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint l,r,h;\n\t\t\tcin>>l>>r>>h;\n\t\t\tl+=20,r+=20;\n\t\t\tfor(int j = l;j < r;j++){\n\t\t\t\tsc[j] = max(sc[j],h);\n\t\t\t}\n\t\t}\n\t\tPolygon G;\n\t\tG.push_back(Point(-100,0));\n\t\tG.push_back(Point(0,0));\n\t\tfor(int i = 0;i < 45;i++){\n\t\t\t\n\t\t\tif(i != 0){\n\t\t\t\tif(sc[i] != sc[i-1])\n\t\t\t\t\tG.push_back(Point(i,sc[i]));\n\t\t\t\t\n\t\t\t\tG.push_back(Point(i+1,sc[i]));\n\t\t\t}\n\t\t}\n\t\tG.push_back(Point(100,0));\n\n\t\tfor(int i = 0;i < G.size();i++){\n\t\t\t//cout<<G[i].real()<<\" \"<<G[i].imag()<<endl;\n\t\t}\n\n\t\tdouble low = -r,high = 25;\n\t\tint D = 50;\n\t\t//cout<<sc[20]<<endl;\n\t\twhile(D--){\n\t\t\tdouble mid = (low+high)/2;\n\t\t\tCircle C = Circle(Point(20,mid),r);\n\t\t\tdouble mi = INF;\n\t\t\tfor(int i = 0;i < G.size()-1;i++){\n\t\t\t\tdouble dist = distanceSP(Line(G[i],G[i+1]),C.p);\n\t\t\t\tmi = min(mi,dist);\n\t\t\t}\n\t\t\t//cout<<mid<<\" \"<<mi<<\" \"<<mid+r<<endl;\n\t\t\tif(mi < r)high = mid;\n\t\t\telse if(sc[20] < mid+r)high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\tprintf(\"%.4lf\\n\",low+r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n, r;\n\twhile (cin >> r >> n, r | n) {\n\t\tvector<int> h(40);\n\t\tfor (int i = 0, xl, xr, hi; i < n; i++) {\n\t\t\tcin >> xl >> xr >> hi;\n\t\t\tfor (int j = xl + 20; j < xr + 20; j++) {\n\t\t\t\th[j] = hi;\n\t\t\t}\n\t\t}\n\t\tint cnt = 1000;\n\t\tld lb = 0, ub = 30;\n\t\twhile (cnt--) {\n\t\t\tld c = (lb + ub) / 2.0;\n\t\t\tbool flag = true;\n\t\t\tfor (int i = 20 - r; i < 20 + r; i++) {\n\t\t\t\tif (max(sqrtl(r * r - (i - 20) * (i - 20)), sqrtl(r * r - (i - 19) * (i - 19))) - r + c > h[i]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tlb = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tub = c;\n\t\t\t}\n\t\t}\n\t\tcout << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define USE_CPP11\n// #define USE_PRINTF\n\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <numeric>\n#include <complex>\n#include <memory>\n#include <sstream>\n\n#ifdef USE_CPP11\n#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#endif\n\n#define PRINT(obj) cout << obj << endl\n#define REP(i, n) for(int (i) = 0; (i) < (n); i++)\n#define SPACE \" \"\n\ntypedef long long ll;\n\nconst int INF = 1e9 + 10;\n\nusing namespace std;\n\nnamespace Scanner {\n#ifdef USE_PRINTF\n  int    nextInt()    { int    d; scanf(\"%d\" , &d); return d; }\n  float  nextFloat()  { float  f; scanf(\"%f\" , &f); return f; }\n  double nextDouble() { double f; scanf(\"%lf\", &f); return f; }  \n  string nextString() { string s; scanf(\"%s\" , &s); return s; }\n  ll     nextll()     { ll     l; scanf(\"%ll\", &l); return l; }\n#else\n  int    nextInt()    { int    d; cin >> d; return d; }\n  float  nextFloat()  { float  f; cin >> f; return f; }\n  double nextDouble() { double f; cin >> f; return f; }  \n  string nextString() { string s; cin >> s; return s; }\n  ll     nextll()     { ll     l; cin >> l; return l; }\n#endif\n\n  string getLine() { \n    string input;\n    getline(cin, input);\n    return input;\n  }\n};\n\nnamespace myLibrary {\n  vector<string> split(const string& str, char delim) {\n    vector<string> ret;\n    size_t current = 0, found;\n    while ((found = str.find_first_of(delim, current)) != string::npos) {\n      ret.push_back(string(str, current, found - current));\n      current = found + 1;\n    }\n    ret.push_back(string(str, current, str.size() - current));\n    return ret;\n  }\n  \n#ifdef USE_CPP11\n  ///\n  /// higher-order functional\n  /// This is something like map in haskell, python, etc.\n  /// Sample usage:\n  ///   vector<int> a = {1, 2, 3, 4, 5};\n  ///   vector<int> b = myLibrary::_Map<int, int>(a, [](int n){\n  ///     return n * n;\n  ///   });\n  /// Result:\n  ///   b = 1, 4, 9, 16, 25\n  ///\n  template<typename T_IN, typename T_OUT, class Functor>\n  vector<T_OUT> _Map(vector<T_IN> src, Functor func) {\n    vector<T_OUT> ret;\n    for (int i = 0; i < src.size(); i++) {\n      ret.push_back(func(src[i]));\n    }\n    return ret;\n  }\n#endif\n\n};\n\nstruct Point {\npublic:\n  int y, x;\n  Point(int y, int x): y(y), x(x) { }\n  Point() { }\n};\n\n/// BEGIN //////////////////////////////////////////////////////////\n\nint main() {\n\n  while (true) {\n    int r = Scanner::nextInt();\n    int n = Scanner::nextInt();\n\n    if (r + n == 0) {\n      break;\n    }\n\n    int height[41] = { 0 };\n\n    int ymax = 0;\n    for (int i = 0; i < n; i++) {\n      int xl = Scanner::nextInt() + 20;\n      int xr = Scanner::nextInt() + 20;\n      int h  = Scanner::nextInt();\n\n      ymax = max(ymax, h);\n      for (int x = xl; x < xr; x++) {\n        height[x] = max(height[x], h);\n      }      \n    }  \n\n    double lt = 0, ht = ymax;\n\n    for (int i = 0; i < 100; i++) {\n      double mt = (lt + ht) / 2;\n\n      bool isOK = true;\n\n      for (int i = 20; i < 41; i++) {\n        if (r <= (i - 20)) {\n          continue;\n        }\n        double y = sqrt(r * r - (i - 20) * (i - 20)) + mt - r;\n        if (y > height[i]) {\n          isOK = false;\n          break;\n        }\n      }\n\n      if (isOK) {\n        for (int i = 0; i < 20; i++) {\n          if (r <= (19 - i)) {\n            continue;\n          }\n          double y = sqrt(r * r - (i - 19) * (i - 19)) + mt - r;\n          if (y > height[i]) {\n            isOK = false;\n            break;\n          }\n        }\n      }\n\n      if (isOK) {\n        lt = mt;\n      } else {\n        ht = mt;\n      }\n    }\n\n    printf(\"%.15f\\n\", ht);\n\n  }\n\n  return 0;\n}\n\n/// END   //////////////////////////////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    int r, n;\n    while (cin >> r >> n, r) {\n        vector<int> xl(n), xr(n), h(n), L(41), R(41);\n        REP (i, n) {\n            cin >> xl[i] >> xr[i] >> h[i];\n            FOR (j, xl[i], xr[i] + 1) {\n                if (j != xl[i]) L[j + 20] = max(L[j + 20], h[i]);\n                if (j != xr[i]) R[j + 20] = max(R[j + 20], h[i]);\n            }\n        }\n\n        const double EPS = 1e-10;\n        auto check = [&](double m) -> bool {\n            bool res = true;\n            FOR (i, -r, r + 1) {\n                double hh = sqrt(r * r - i * i) + m - r;\n                int j = i + 20;\n                if (i != -r) res &= (hh <= L[j] + EPS);\n                if (i != r) res &= (hh <= R[j] + EPS);\n            }\n            return res;\n        };\n\n        double ok = 0, ng = 20;\n        REP (i, 100) {\n            double m = (ok + ng) / 2;\n            if (check(m)) ok = m;\n            else ng = m;\n        }\n        cout << ok << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tint n;\n\tdouble r;\n\twhile(cin>>r>>n,r||n){\n\t\tdouble h[50]={0};\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta+=25;b+=25;\n\t\t\tfor(int i=a;i<b;i++)h[i]=max(h[i],c);\n\t\t}\n\t\t//loop(i,20,30)cout<<\" \"<<h[i];\n\t\t//cout<<endl;\n\t\tdouble t=0;\n\t\twhile(1){\n\t\t\tt+=0.0001;\n\t\t\tbool ans=true;\n\t\t\trep(i,49){\n\t\t\t\tif(hypot((double)(i-25),r+h[i]-t)<r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(hypot((double)(i-24),r+h[i]-t)<r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ans)break;\n\t\t}\n\t\tcout<<t-0.0001<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-7;\nvoid solve (int r, int n) {\n  double lx[30] = {0}, rx[30] = {0};\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    double h;\n    cin >> a >> b >> h;\n\n    for (int x = -20; x < 0; ++x) {\n      if (a <= x && x < b) {\n        lx[-x - 1] = max(lx[-x - 1], h);\n      }\n    }\n    for (int x = 0; x <= 20; ++x) {\n      if (a <= x && x < b) {\n        rx[x] = max(rx[x], h);\n      }\n    }\n  }\n/*\n  for (int i = 20; i >= 0; --i) {\n    cout << lx[i] << \" \";\n  }\n  for (int i = 0; i < 20; ++i) {\n    cout << rx[i] << \" \";\n  }\n  puts(\"\");\n*/\n  double lch = -r, rch = 20.0;\n  while (rch - lch > EPS) {\n    double m = (lch + rch) / 2.0;\n    bool f = true;\n\n//    cout << m << endl;\n\n    for (int i = 0; i < r; ++i) {\n      double nowh = sqrt(r * r - i * i) + m - (double)r;\n      if (lx[i] - nowh < EPS) f = false;\n      if (rx[i] - nowh < EPS) f = false;\n//      cout << f << \" \";\n    }\n//    puts(\"\");\n\n    if (f) {\n      lch = m;\n    } else {\n      rch = m;\n    }\n  }\n\n  printf(\"%.4lf\\n\", lch);\n}\n\nint main() {\n  int r, n;\n\n  while (cin >> r >> n, r) {\n    solve(r, n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint r;\n\tint n;\n\twhile (cin >> r >> n, r){\n\t\tdouble hight[40] = {0};\n\t\tdouble suny[41];\n\t\tREP(i, 41)\n\t\t\tsuny[i] = -1e9;\n\t\tREP(i, 41){\n\t\t\tif (abs(i - 20) <= r)\n\t\t\t\tsuny[i] = -(double)r + sqrt((double)r*(double)r - (double)(i - 20)*(double)(i - 20));\n\t\t}\n\t\tREP(i, n){\n\t\t\tint x, x2, h;\n\t\t\tcin >> x >> x2 >> h;\n\t\t\tREP(i,x2-x){\n\t\t\t\thight[x + 20+i] = max(hight[x + 20+i], (double)h);\n\t\t\t}\n\t\t}\n\t\tdouble mi = 1e9;\n\t\tREP(i, 41){\n\t\t\tif (abs(i - 20) <= r){\n\t\t\t\tif (i - 20==-r)\n\t\t\t\t\tmi = min(mi, hight[i] -suny[i]);\n\t\t\t\tif (i - 20==r)\n\t\t\t\t\tmi = min(mi, hight[i-1] - suny[i]);\n\t\t\t\telse\n\t\t\t\t\tmi = min(mi, min(hight[i],hight[i-1]) - suny[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", mi);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, r;\n\twhile (cin >>r>>n, r) {\n\t\tmap<int, int> v;\n\t\tint cmin = INF, cmax = -INF;\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcmin = min(cmin, a);\n\t\t\tcmax = max(cmax, b);\n\t\t\tFOR(j, a, b)v[j] = max(v[j], c);\n\t\t}\n\t\tif (cmin == INF) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tdouble u = 20, l = 0;\n\t\t\twhile (u - l > EPS) {\n\t\t\t\tint flag = 1;\n\t\t\t\tdouble mid = (u + l) / 2;\n\t\t\t\tFOR(i, -20, 20) {\n\t\t\t\t\tint d = i;\n\t\t\t\t\tif (i < 0)d++;\n\t\t\t\t\tif (d > r)continue;\n\t\t\t\t\tdouble c = sqrt(r*r - d*d);\n\t\t\t\t\tif (c + mid -r> v[i])flag = 0;\n\t\t\t\t}\n\t\t\t\tif (flag)l = mid;\n\t\t\t\telse u = mid;\n\t\t\t}\n\t\t\tcout << fixed << setprecision(4) << l << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-6\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(inct (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R-eps)return false;\n\tif(y<c-R+eps)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define pb push_back\n\nint main() {\n  while(true){\n    int r,n;\n    cin >> r >> n;\n    if(r==0 && n==0) break;\n    int bill[40]={0};\n    rep(i,n){\n      int xl,xr,h;\n      cin >> xl >> xr >> h;\n      repi(j,xl,xr){\n\tbill[20+j]=max(bill[20+j],h);\n      }\n    }\n    double min_distance=100000000000000000000.0;\n    repi(i,-1*r,r){\n      double circle_part = max(sqrt(r*r-i*i),sqrt(r*r-(i+1)*(i+1)));\n      min_distance=min(min_distance,bill[20+i]+r-circle_part);\n    }\n    cout << min_distance << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<map>\n#include<cstdio>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define pb push_back\n#define P pair<int,int>\n#define ll __int64\nint n;\ndouble r;\ndouble x[100],x2[100],h[100];\ndouble EPS=0.0001;\nbool che(double t){\ndouble fai;\nint B=500000;\ndouble fy;\n\nfor(int i=0;i<=B;i++){\n\tfai=M_PI*(double)i/(double)B;\n\tdouble nx=r*cos(fai);//円上のx\n\tdouble ny=r*sin(fai)+t-r;//円上のy\n\t\n\tfy=-10000;\n\tdouble fx=0;\n\tfor(int j=0;j<n;j++){\n\t\tif(x[j]<=nx&&nx<=x2[j])fy=max(fy,h[j]);\n\t}\n\t//cout<<nx<<\" \"<<ny<<\" \"<<fy<<endl;\n\t\n\tif(fy<=-9999||ny>fy)return 0;\n}\nreturn 1;\n\n}\nint main(){\nwhile(cin>>r>>n,r||n){\nrep(i,n)cin>>x[i]>>x2[i]>>h[i];\n\n\n\ndouble mid=0,l=0,r=100;\nmid=(r+l)/2;\nfor(int i=0;i<30;i++){\n\tif(che(mid)){\n\t\tl=mid;\n\t}\n\telse{\n\t\tr=mid;\n\t}\n\tmid=(r+l)/2;\n}\n\nprintf(\"%.20lf\\n\",mid);\nrep(i,n)x[i]=x2[i]=h[i]=0;\n}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n  double r;\n  int n;\n  int hight[40];\n  int xl, xr, h;\n\n  while(1) {\n    cin >> r >> n;\n    if(r + n == 0) break;\n\n    for(int i = 0; i < 40; i++) {\n      hight[i] = 0;\n    }\n    \n    for(int i = 0; i < n; i++) {\n      cin >> xl >> xr >> h;\n      for(int j = xl+20; j < xr+20; j++) {\n\tif(hight[j] < h) {\n\t  hight[j] = h;\n\t}\n      }\n    }\n    \n    float ans = 10000;\n    double x, y;\n    for(int i = 20-r; i < 20+r-1; i++) {\n      if(hight[i] < hight[i+1]) {\n\tx = i - 20 + 1;\n\ty = hight[i];\n      }\n      else {\n\tx = i - 20 + 1;\n\ty = hight[i+1];\n      }\n      float t = y + r - sqrt(r * r - x * x);\n      if(ans > t) {\n\tans = t;\n      }\n    }\n    cout << fixed << setprecision(4) << ans << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nint hm[43];\nint r,n;\n\nint main() {\n  while(cin>>r>>n,r){\n    REP(i,43) hm[i]=0;\n    REP(i,n){\n      int xl,xr,h;\n      cin>>xl>>xr>>h;\n      for(int i=xl+21;i<xr+21;++i) hm[i]=max(hm[i],h);\n    }\n    double mx=21;\n    for(int i=21-r+1;i<21+r;++i) mx=min(mx,min(hm[i-1],hm[i])+r-sqrt(r*r-(i-21)*(i-21)));\n    cout<<setprecision(10)<<fixed<<mx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int r, n;\n    while(1){\n        cin >> r >> n;\n        if(r == 0 && n == 0) break;\n        int building[42] = {};\n        for(int i = 0; i < n; i++){\n            int x1, x2, h;\n            cin >> x1 >> x2 >> h;\n            // cout << (double)r * r - pow(min(abs(x1), abs(x2)), 2) << endl;\n            \n            x1 += 20;\n            x2 += 20;\n            for(int i = x1; i < x2; i++){\n                building[i] = max(building[i], h);\n            }\n        }\n        double ans = 25.0;\n        for(int i = 20 - r; i < 20 + r; i++){\n            if(building[i] == 0){\n                ans = 0.0;\n            } else {\n                // cout << i - 20 << \" : \" << building[i] << (double)building[i] - sqrt(r * r - pow(abs(i - 20) - 1, 2)) + r << endl;\n                if(i - 20 < 0) ans = min(ans, (double)building[i] - sqrt(r * r - pow(-i + 20 - 1, 2)) + r);\n                else ans = min(ans, (double)building[i] - sqrt(r * r - pow(i - 20, 2)) + r);\n            }\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint main(){\n\twhile(1){\n\t\tint r; int n;\n\t\tint xl[25],xr[25],y[25];\n\t\tscanf(\"%d%d\",&r,&n);\n\t\tif(r == 0 && n == 0) return 0;\n\t\tmap<int,int>M;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d\",&xl[i],&xr[i],&y[i]);\n\t\t\tfor(int j=xl[i];j<xr[i];j++) M[j] = max(M[j],y[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int X=-r;X<=-1;X++){\n\t\t\t//[X,X+1], X+1 is highest\n\t\t\t{\n\t\t\t\tdouble L = sqrt((double)r*(double)r - (double)(X+1)*(double)(X+1));\n\t\t\t\tL = (double)r-L;\n\t\t\t\tans = min(ans,L+(double)M[X]);\n\t\t\t}\n\t\t}\n\t\tfor(int X=0;X<r;X++){\n\t\t\t//[X,X+1], X is highest\n\t\t\t{\n\t\t\t\tdouble L = sqrt((double)r*(double)r - (double)(X)*(double)(X));\n\t\t\t\tL = (double)r-L;\n\t\t\t\tans = min(ans,L+(double)M[X]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint build[20][40];\n\nvoid printbuild() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      if (build[i][j]) cout << \"#\";\n      else cout << \".\";\n    }\n    cout << endl;\n  }\n}\n\nvoid makeOut() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 1 - build[i][j];\n    }\n  }\n}\n\nbool touchingSun(long h, long i, double c, long r) {\n  return hypot(19 - h - c, i - 20) < r || hypot(19 - h - c, i - 19) < r;\n}\n\nbool touchingSunAll(double c, long r) {\n  for (int h = 0; h < 20; h++) {\n    for (int i = 0; i < 40; i++) {\n      if (build[h][i] && touchingSun(h, i, c, r)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid reset() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 0;\n    }\n  }\n}\n\nvoid fillbuild(long l, long r, long h) {\n  for (int i = 19; i >= 20 - h; i--) {\n    for (int j = l + 20; j < r + 20; j++) {\n      build[i][j] = 1;\n    }\n  }\n}\n\nvoid solve(long n, long r) {\n  reset();\n  long l, rr, h;\n  for (int i = 0; i < n; i++) {\n    cin >> l >> rr >> h;\n    fillbuild(l, rr, h);\n  }\n  makeOut();\n  // printbuild();\n  double c = -r;\n  double step = 0.5;\n  int cnt = 0;\n  while (step > 0.00001) {\n    if (!touchingSunAll(c, r)) {\n      c += step;\n    } else {\n      c -= step;\n      step /= 2;\n    }\n    cnt++;\n    if (cnt > 10000) break;\n   }\n  printf(\"%.4f\\n\", min(c + r, 20.0));\n}\n\nint main() {\n  long n, r;\n  while (1) {\n    cin >> r >> n;\n    if (n + r) {\n      solve(n, r);\n    } else {\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define INF (1e9)\n#define P 25\n#define N 50\nusing namespace std;\ndouble cal(int,int);\nint r,n,xl,xr,h,le,ri;\n\nint main(){\n  double ans;\n  bool d1[N][N],d[N][N];\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) d1[i][j]=d[i][j]=false;\n    while(n--){\n      cin>>xl>>xr>>h;\n      for(int i=0;i<h;i++)\n\tfor(int j=xl+P+1;j<=xr+P;j++) d1[i][j]=true;\n    }\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N-1;j++)\n\tif(d1[i][j]){\n\t  if(!i&&d1[i][j+1]) d[i][j]=true;\n\t  if(i&&d1[i][j+1]&&d1[i-1][j]&&d1[i-1][j+1]) d[i][j]=true;\n\t}\n    le=P-(r-1);\n    ri=P+(r-1);\n    ans=INF;\n    for(int i=le;i<=ri;i++)\n      for(int j=0;j<N;j++)\n\tif(!d[j][i]){\n\t  ans=min(ans,cal(P-i,j));\n\t  break;\n\t}\n    printf(\"%.4f\\n\",ans);\n  }\n  return 0;\n}\n\ndouble cal(int x,int p){\n  return r-sqrt(r*r-x*x)+p;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n\nusing namespace std;\nusing ll = long long;\n\nint f_dir[2][4] = {{-1, 0, 0, 1}, {0, -1, 1, 0}};\nint e_dir[2][8] = {{-1, -1, -1, 0, 0, 1, 1, 1}, {-1, 0, 1, -1, 1, -1, 0, 1}};\nbool is_in_field(int y, int x, int h, int w){\n  return (y >= 0 && y < h && x >= 0 && x < w);\n}\n\nvoid solve(int r, int n){\n  vector<pair<double, double>> heights(41, pair<double, double>{0, 0});\n  for(int i = 0; i < n; i++){\n    int xl, xr;\n    double h;\n    cin >> xl >> xr >> h;\n    for(int j = xl+20; j <= xr+20; j++){\n      if(j > 0 && j > xl+20) heights[j-1].second = max(heights[j-1].second, h);\n      if(j < 40 && j < xr+20) heights[j+1].first = max(heights[j+1].first, h);\n    }\n  }\n  double ans = 20;\n  for(int i = 20 - r; i <= r+20; i++){\n    double h = sqrt(1.0*r*r - (double(i) - 20)*(double(i) - 20));\n    if(i == 20-r){\n      ans = min(ans, r + heights[i].second - h);\n    }\n    else if(i == r+20){\n      ans = min(ans, r + heights[i].first - h);\n    }\n    else{\n      ans = min(ans, r + heights[i].second - h);\n      ans = min(ans, r + heights[i].first - h);\n    }\n  }\n  cout << fixed << setprecision(16) << ans << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int r, n;\n  while(cin >> r >> n && r){\n    solve(r, n);\n  }\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\n#include <map>\n  \nusing namespace std;\n\ndouble r;\nint n;\n\nint main(){\n\t\n\twhile(scanf(\"%lf %d\",&r,&n),r){\n\n\t\tint left,right,h;\n\t\tint HL[41]={};\n\t\tint HR[41]={};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>left>>right>>h;\n\t\t\tfor(int x=left;x<=right;x++){\n\t\t\t\tif(x!=right) HL[x+20]=max(HL[x+20],h);\n\t\t\t\tif(x!=left)  HR[x+20]=max(HR[x+20],h);\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tdouble res=1e10;\n\t\t//[i,i+1]??????????????????\n\t\tfor(int i=-r;i<=r-1;i++){\n\t\t\tdouble t1=r-sqrt(r*r-i*i)+HL[i+20];\n\t\t\tdouble t2=r-sqrt(r*r-(i+1)*(i+1))+HR[i+1+20];\n\t\t\tres=min(res,min(t1,t2));\n\t\t}\n\t\tprintf(\"%.8f\\n\",res);\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,b,a,L;\nld c,r,d[41],ans=100000;\nint main(void){\n    while(1){\n    cin>>r>>n;\n    if(r==0&&n==0)return 0;\n    ans=100000;\n    for(int i=0;i<41;i++)d[i]=0;\n    for(int i=0;i<n;i++){\n        cin>>a>>b>>c;\n        for(int j=a;j<b;j++){\n            //d[j+20]=min(c,d[j+20]);\n            d[j+20]=max(c,d[j+20]);\n        }\n    }\n    //for(int i=0;i<41;i++)if(d[i]==100000)d[i]=0;\n    for(int i=0;i<=40;i++){\n        ld l=i;\n        if(l-20<0)L=19-l;\n        else L=l-20;\n        if(r<=L)continue;\n        //cout<<r<<\" \"<<L<<ans<<\" \"<<\"W\"<<pow(r*r-L*L,0.5)<<\" \"<<d[i]<<endl;\n        ans=min(ans,r-pow(r*r-L*L,0.5)+d[i]);\n    }\n    cout<<setprecision(10)<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Name: Vampire\n//Level: 2\n//Category: 幾何\n//Note:\n\n/**\n * 第一象限に注目すると、太陽のうち区間[x,x+1)にある箇所が影から出るとき、\n * もっとも早く出るのは座標xの点である（太陽の中心、建物の座標がともに整数であり、太陽は上に凸であるため）。\n * したがって、[x,x+1)が影から出るイベントに対しては、xのみを調べればよい（このとき、xが建物の右端でも出ていると判定することに注意）。\n * 第二象限についても同様。\n *\n * オーダーはO(R)。\n */\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool solve() {\n    int R, N;\n    if(!(cin >> R >> N)) return false;\n    if(!R && !N) return false;\n\n    vector<int> hs(R+1), nhs(R+1);\n    for(int i = 0; i < N; ++i) {\n        int xl, xr, h;\n        cin >> xl >> xr >> h;\n        for(int x = max(0, xl); x < xr; ++x) {\n            if(0 <= x && x <= R) hs[x] = max(hs[x], h);\n        }\n        for(int x = min(0, xr); x > xl; --x) {\n            if(0 <= -x && -x <= R) nhs[-x] = max(nhs[-x], h);\n        }\n    }\n    double ans = 1000000;\n    for(int x = 0; x < R; ++x) {\n        const double t = hs[x] + R - sqrt(R*R - x*x);\n        ans = min(ans, t);\n    }\n    for(int x = 0; x > -R; --x) {\n        const double t = nhs[-x] + R - sqrt(R*R - x*x);\n        ans = min(ans, t);\n    }\n    cout.precision(10);\n    cout << fixed << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nconst int BIAS = 20;\n\nsigned main(){\n    while(true){\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if(r == 0 && n == 0){\n            break;\n        }\n\n        vector<double> bill(20*2);\n        rep(i, n){\n            double xl, xr, h;\n            cin >> xl >> xr >> h;\n            for(int j = xl; j < xr; j++){\n                bill[j+BIAS] = h;\n            }\n        }\n\n        double min = 100.0;\n        for(int i = -r; i < 0; i++){\n            double d = i+1;\n            double len = bill[i+BIAS] - sqrt(r*r - d*d) + r;\n\n            if(min > len){\n                min = len;\n            }\n        }\n\n        for(int i = 0; i < r; i++){\n            double d = i;\n            double len = bill[i+BIAS] - sqrt(r*r - d*d) + r;\n\n            if(min > len){\n                min = len;\n            }\n        }\n        cout << fixed << setprecision(5) << min << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\ndouble mk_dis(int x1,int h,double cy){\n  return sqrt(x1*x1+(h-cy)*(h-cy));\n}\n\nbool check(double cy){\n  cy=(int)(cy*100000)/100000.0;\n  double x=fabs(sqrt(r*r-cy*cy));\n  if(cy>=0)x=r;\n  int L=(-x-0.999999),R=(x+0.999999),hb[101]={};\n  for(int i=L+50;i<R+50;i++)\n    if(i>=50){\n      if(mk_dis(i-50,y[i],cy)>=r)hb[i]++;\n    }\n    else {\n      if(mk_dis(i-49,y[i],cy)>=r)hb[i]++;\n    }\n  \n  for(int i=L+50;i<R+50;i++)if(!hb[i])return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    memset(y,0,sizeof(y));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans;\n    for(ans=0;check(ans-r);ans+=0.0001);\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nvoid solve(int r, int n) {\n\tvector<int> interval_height(42, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tint left, right, h;\n\t\tcin >> left >> right >> h;\n\t\tfor (int j = left + 21; j < right + 21; j++) {\n\t\t\tif (interval_height[j] < h) {\n\t\t\t\tinterval_height[j] = h;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> height(r + 1, 0);\n\tfor (int i = 0; i < r; i++) {\n\t\tint left_min = min(interval_height[-i + 21 - 1], interval_height[-i + 21]);\n\t\tint right_min = min(interval_height[i + 21 - 1], interval_height[i + 21]);\n\t\theight[i] = min(left_min, right_min);\n\t}\n\n\tdouble t = 2 << 15;\n\tfor (int i = 0; i < r; i++) {\n\t\tdouble tt = height[i] + r - sqrt(r * r - i * i);\n\t\tif (tt < t) {\n\t\t\tt = tt;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(4) << t << endl;\n}\n\nint main() {\n\tint r, n;\n\twhile (cin >> r >> n) {\n\t\tif (r == 0 && n == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tsolve(r, n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,b) for(int i=a; i<b; i++)\n#define FORR(i,a,b) for(int i=b-1;i>=a;i--)\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n\nint r,n;\nint xl[25], xr[25], h[21];\nint he[45];\n\nint main(){\n    while(true){\n        cin>>r>>n;\n        if(r+n==0)break;\n        REP(i,n)cin>>xl[i]>>xr[i]>>h[i];\n        const int C = 21;\n        fill(he,he+45,0);\n        REP(i,n)FOR(x,C+xl[i],C+xr[i])he[x]=max(he[x],h[i]);\n        double ans = 1e25;\n        REP(i,45){\n            int x = i-C;\n            if(x<0)x++;\n            x = abs(x);\n            if(x>=r)continue;\n            double y = sqrt(r*r-x*x);\n            ans = min(ans, he[i]+r-y);\n        }\n        printf(\"%.9f\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define EPS 1e-9\n\nclass biru{\npublic:\n  double xl;\n  double xr;\n  double h;\n  biru(double a, double b, double c) {\n    xl = a;\n    xr = b;\n    h = c;\n  }\n};\n\ndouble r;\nbool crossCheck(double xc, double yc, double x1, double y1, double x2, double y2) {\n  return (hypot(xc-x1, yc-y1)-r < EPS ||\n\t  hypot(xc-x2, yc-y2)-r < EPS ||\n\t  (fabs((y2-y1)*xc+(x1-x2)*yc+(x2*y1-x1*y2))/hypot(x1-x2, y2-y1)-r < EPS &&\n\t   ((fabs(x1-x2) > EPS && (x1 <= xc && xc <= x2 || x2 <= xc && xc <= x1)) ||\n\t    (fabs(y1-y2) > EPS && (y1 <= yc && yc <= y2 || y2 <= yc && yc <= y1)) )));\n}\n\nbool compare(const biru a, const biru b) {\n  return a.xl < b.xl;\n}\n\nbool collision(double p, vector<biru> mbiru) {\n  bool ok = true;\n  if (-r < mbiru[0].xl) {\n    ok = !crossCheck(0, p, -r, 0, mbiru[0].xl, 0);\n  }\n  if (crossCheck(0, p, mbiru[0].xl, 0, mbiru[0].xl, mbiru[0].h)) ok = false;\n  if (crossCheck(0, p, mbiru[0].xl, mbiru[0].h, mbiru[0].xr, mbiru[0].h)) ok = false;\n  if (mbiru.size() >= 2) {\n    if (fabs(mbiru[0].xr-mbiru[1].xl) < EPS) {\n      ok = !crossCheck(0, p, mbiru[0].xr, mbiru[0].h, mbiru[0].xr, mbiru[1].h);\n    }else {\n      ok = !crossCheck(0, p, mbiru[0].xr, mbiru[0].h, mbiru[0].xr, 0);\n    }\n  }\n  for (int j = 1; j < mbiru.size(); j++) {\n    if (fabs(mbiru[j].xl-mbiru[j-1].xr) < EPS) {\n      if (crossCheck(0, p, mbiru[j].xl, mbiru[j].h, mbiru[j].xl, mbiru[j-1].h)) {\n\tok = false;\n      }\n\n    }else {\n      if (crossCheck(0, p, mbiru[j-1].xr, 0, mbiru[j].xl, 0) ||\n\t  crossCheck(0, p, mbiru[j].xl, 0, mbiru[j].xl, mbiru[j].h)) {\n\tok = false;\n      }\n    }\n    if (crossCheck(0, p, mbiru[j].xl, mbiru[j].h, mbiru[j].xr, mbiru[j].h)) {\n      ok = false;\n    }\n    if (j+1 < mbiru.size()) {\n      if (fabs(mbiru[j].xr-mbiru[j+1].xl) > EPS) {\n\tif (crossCheck(0, p, mbiru[j].xr, mbiru[j].h, mbiru[j].xr, 0)) {\n\t  ok = false;\n\t}\n      }\n    }else {\n      if (crossCheck(0, p, mbiru[j].xr, mbiru[j].h, mbiru[j].xr, 0)) {\n\tok = false;\n      }\n    }\n    if (!ok) break;\n  }\n  if (crossCheck(0, p, mbiru[mbiru.size()-1].xr, 0, 1000, 0)) {\n    ok = false;\n  }\n  return !ok;\n}\n\nint main() {\n  int tr, n;\n  while (cin >> tr >> n) {\n    if (tr == 0 && n == 0) break;\n    if (n == 0) {\n      std::cout << 0 << std::endl;\n      continue;\n    }\n    r = (double)tr-0.00001;\n    bool field[41][21];\n    memset(field, false, sizeof(field));\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n      for (int j = 0; j < h; j++) {\n\tfor (int k = xl; k < xr; k++) {\n\t  field[k+20][j] = true;\n\t}\n      }\n    }\n    // for (int i = 0; i < 10; i++) {\n    //   for (int j = 15; j < 25; j++) {\n    // \tstd::cout << field[j][i];\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n    vector <biru> mbiru;\n    for (int i = 0; i < 41; i++) {\n      if (field[i][0]) {\n\tint h;\n\tfor (int j = 0; field[i][j]; j++) {\n\t  h = j+1;\n\t}\n\tmbiru.push_back(biru(i-20, i-20+1, h));\n      }\n    }\n    // for (int i = 0; i < mbiru.size(); i++) {\n    //   std::cout << mbiru[i].xl << \" \" << mbiru[i].xr << \" \" << mbiru[i].h << std::endl;\n    // }\n\n    double lp = -200, rp = 0;\n    for (int i = -20; i < 100; i++) {\n      rp = double(i);\n      if (collision(rp, mbiru)) {\n\tbreak;\n      }\n    }\n\n    double p;\n    for (int i = 0; i < 100; i++) {\n      p = (lp+rp)/2;\n      if (collision(p, mbiru)) {\n\trp = p;\n      }else {\n\tlp = p;\n      }\n    }\n    printf(\"%lf\\n\", lp+r);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-5\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(inct (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R-eps)return false;\n\tif(y<c-R+eps)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nbool solve(){\n  int r, n;\n  int maxh[50] = {};\n  scanf(\"%d%d\", &r, &n);\n\n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++){\n    int l, r, h;\n    scanf(\"%d%d%d\", &l, &r, &h);\n\n    for(int j=l+20;j<r+20;j++) maxh[j] = max(maxh[j], h);\n  }\n\n  double ans = INF;\n  \n  for(int i=20-r;i<20+r;i++){\n    int x = (i<20) + i - 20;\n\n    ans = min(ans, maxh[i] + r - sqrt(r*r-x*x));\n  }\n\n  printf(\"%.5lf\\n\", ans);\n\n  return 1;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\n#include <map>\n  \nusing namespace std;\n\ndouble r;\nint n;\n\nint main(){\n\t\n\twhile(cin>>r>>n,r){\n\n\t\tdouble left,right,h;\n\t\tmap<int,double> HL,HR;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>left>>right>>h;\n\t\t\tfor(int x=left;x<=right;x++){\n\t\t\t\tif(x!=right) HL[x]=max(HL[x],h);\n\t\t\t\tif(x!=left)  HR[x]=max(HR[x],h);\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tdouble res=1e10;\n\t\t//[i,i+1]??????????????????\n\t\tfor(int i=-r;i<=r-1;i++){\n\t\t\tdouble t1=r-sqrt(r*r-i*i)+HL[i];\n\t\t\tdouble t2=r-sqrt(r*r-(i+1)*(i+1))+HR[i+1];\n\t\t\tres=min(res,min(t1,t2));\n\t\t}\n\t\tprintf(\"%.8f\\n\",res);\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rect {\n    int l, r, h;\n\n    Rect(){}\n    ~Rect(){}\n\n    Rect (int a, int b, int c):\n        l(a), r(b), h(c) {}\n\n    bool operator < (const Rect& o) const {\n        return r == o.r ? l < o.l : r < o.r;\n    }\n};\n\nint main() {\n    while (true) {\n        int r, n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0){\n            break;\n        }\n\n        vector<Rect> rects(n);\n\n        for (int j = 0; j < n; ++j) {\n            cin >> rects[j].l >> rects[j].r >> rects[j].h;\n        }\n\n        int dum[90];\n        int* heights = dum + 45;\n        fill(dum, dum + 90, 0);\n\n        for (int j = 0; j < n; ++j) {\n            for (int x = 2 * rects[j].l; x <= 2 * rects[j].r; ++x) {\n                heights[x] = max(heights[x], rects[j].h);\n            }\n        }\n\n        heights[-2*r-1] = numeric_limits<int>::max();\n        heights[2*r+1] = numeric_limits<int>::max();\n\n        double ret = numeric_limits<double>::max();\n\n        for (int x = -2 * r; x <= 2 * r; x += 2) {\n            int h = min(heights[x], min(heights[x-1], heights[x+1]));\n            ret = min(ret, h + r - sqrt(r * r - x * x / 4));\n        }\n\n        printf(\"%.4f\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint min(int a, int b) {\n    if (a < b) return a;\n    else return b;\n}\n\ndouble calc(int r, int n) {\n    const int hsize = r * 2 + 1;\n    const int psize = hsize - 2;\n    vector<int> heights(hsize, 0);\n    vector<int> points(psize, -1);\n    \n    for (int i = 0; i < n; i++) {\n        int xl, xr, h;\n        cin >> xl >> xr >> h;\n        for (int j = xl; j < xr; j++) {\n            if (j < -r || r < j) continue;\n            if (heights[r + j] < h) heights[r + j] = h;\n        }\n    }\n\n    for (int i = 0; i < psize; i++) {\n        points[i] = min(heights[i], heights[i + 1]);\n    }\n\n    double min = 100.0;\n    double rad = (double)r;\n    for (int i = 0; i < psize; i++) {\n        double x = (double)(i - r + 1);\n        double y = sqrt(rad * rad - x * x);\n        double m = (double)(points[i]) - y + rad;\n        if (min > m) min = m;\n    }\n    return ((double)((int)(min * 10000.0))) / 10000.0;\n}\n\nint main() {\n    int r, n;\n    while (true) {\n        cin >> r >> n;\n        if (r == 0 && n == 0) return 0;\n        cout << fixed << setprecision(4) << calc(r, n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nint main(void){\n    int r,n,left,right,height;\n    double minh;\n    map<int,int> s;\n\n    while(cin>>r>>n,r|n){\n        /* ????????? */\n        rep(i,21)s[i]=s[-i]=0;\n        minh = 21;\n        while(n--){\n            cin>>left>>right>>height;\n            for(int i=left;i<right;++i){\n                if(s[i]<height)s[i]=height;\n            }\n        }\n\n        rep(i,r)minh = min(minh,min(s[i],s[-i-1])-sqrt(r*r-i*i));\n        printf(\"%.4f\\n\",minh+r);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nbool possible(const int r,double t,map<int,int>& mp)\n{\n    rep(i,r){\n        if(mp[i] < sqrt(r*r-i*i)+t-r){\n            return false;\n        }\n    }\n    for(int i=-r;i<0;i++){\n        if(mp[i] < sqrt(r*r-(i+1)*(i+1))+t-r){\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    while(1){\n        int r,n;\n        map<int,int> mp;\n        cin >> r >> n;\n        if(r == 0){\n            break;\n        }\n        rep(i,n){\n            int a,b,c;\n            cin >> a >> b >> c;\n            for(int j=a;j<b;j++){\n                mp[j] = max(mp[j],c);\n            }\n        }\n        double l = 0;\n        double h = 21;\n        while(1){\n            double mid = (l+h) / 2.0;\n            if(mid - l < EPS){\n                printf(\"%.10f\\n\",l);\n                break;\n            }else{\n                if(possible(r,mid,mp)){\n                    l = mid;;\n                }else{\n                    h = mid;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tfor(int r,n;cin>>r>>n && r|n;){\n\t\tvector<int> ls(n),rs(n),hs(n);\n\t\tfor(int i=0;i<n;i++) cin>>ls[i]>>rs[i]>>hs[i];\n\t\tvector<int> ys(41);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int x=ls[i];x<rs[i];x++)\n\t\t\t\tys[20+x]=max(ys[20+x],hs[i]);\n\t\t\n\t\tdouble res=1e9;\n\t\tfor(int x=-r+1;x<=r-1;x++){\n\t\t\tdouble y=-r+sqrt(r*r-x*x);\n\t\t\tres=min({res,ys[20+x]-y,ys[20+x-1]-y});\n\t\t}\n\t\tprintf(\"%f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ndouble eq(double x) { return fabs(x) < 0.000001; }\n\ndouble f(double r, double x) {\n  if (fabs(x) > r)\n    return -100000000;\n  if (eq(fabs(x) - r))\n    return -r;\n  return -(r - sqrt(r * r - x * x));\n}\n\nint main() {\n  while (true) {\n    int r, n;\n    cin >> r >> n;\n    if (r == 0 && n == 0)\n      break;\n    double ans = 10000000000;\n    vector<pair<int, int>> x(n);\n    vector<int> h(n);\n    for (int i = 0; i < n; i++)\n      cin >> x[i].first >> x[i].second >> h[i];\n    int H[50][2] = {0};\n    int offset = 25;\n    for (int i = 0; i < n; i++) {\n      for (int j = max(-r, x[i].first); j < min(r + 1, x[i].second); j++) {\n        H[j + offset][0] = max(H[j + offset][0], h[i]);\n      }\n      for (int j = max(-r, x[i].first + 1); j <= min(r, x[i].second); j++) {\n        H[j + offset][1] = max(H[j + offset][1], h[i]);\n      }\n    }\n    for (int i = -r; i <= r; i++) {\n      cout << H[i + offset][0] << \" \" << H[i + offset][1] << \" \" << f(r, i)\n           << endl;\n      if (i < r)\n        ans = min(ans, H[i + offset][0] - f(r, i));\n      if (i > -r)\n        ans = min(ans, H[i + offset][1] - f(r, i));\n    }\n    printf(\"%.9lf\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS) return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nvoid vis2(P p){\n\tprintf(\"plot(%.5lf,%.5lf,0)\\n\",p.real(),p.imag());\n}\nint test(vector<G> &g,double t,double r){\n\tr -= 1e-4;\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(0);\n\tchkPoint.push_back(PI/2.);\n\tchkPoint.push_back(3*PI/2.);\n\tchkPoint.push_back(2*PI/2.);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tx = x - c.p;\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t\tchkPoint.push_back(th+1e-6);\n\t\t\t\tchkPoint.push_back(th-1e-6);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"cir(\" << c.p.real() << \",\" << c.p.imag() << \",\" << r << \")\" << endl;\n\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tif( contains(g[j],pp) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if(flag) vis2(pp);\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nvoid vis(G g){\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tcout << \"line(\" << curr(g,i).real() << \",\" << curr(g,i).imag() << \",\" << next(g,i).real() << \",\" << next(g,i).imag() << \")\" << endl;\n\t}\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\t//g.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl,0},{xr,0},{xr,h},{xl,h}});\n\t\t\t//vis(g[i]);\n\t\t}\n\t\t\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\tint r, n;\n\twhile(cin >> r >> n) {\n\n\t\tif(r == 0 && n == 0) break;\n\n\t\tvector<pair<P, int> > v(n);\n\t\trep(i, n) cin >> v[i].first.first >> v[i].first.second >> v[i].second;\n\n\t\tsort(v.begin(), v.end());\n\n\t\tbool flag = true;\n\t\tvector<P> p;\n\t\tP sp(0, 0);\n\n\t\trep(i, n) {\n\t\t\tint x1 = v[i].first.first, x2 = v[i].first.second, h = v[i].second;\n\n\t\t\tif(x1 < 0 && x2 > 0) {\n\t\t\t\tif(sp.second < h) {\n\t\t\t\t\tsp.second = h;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(abs(x1) < r) p.push_back(P(x1, h));\n\t\t\tif(abs(x2) < r) p.push_back(P(x2, h));\n\n\t\t\tif(i != n-1) {\n\t\t\t\tint x3 = v[i+1].first.first, x4 = v[i+1].first.second, h2 = v[i+1].second;\n\t\t\t\tbool ch = false;\n\t\t\t\tif(x1 <= x3 && x3 <= x2) {\n\t\t\t\t\tif(abs(x3) < r) p.push_back(P(x3, h));\n\t\t\t\t\tch |= true;\n\t\t\t\t}\n\n\t\t\t\tif(x3 <= x2 && x2 <= x4) {\n\t\t\t\t\tif(abs(x2) < r) p.push_back(P(x2, h2));\n\t\t\t\t\tch |= true;\n\t\t\t\t}\n\n\t\t\t\tif(ch) continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(!flag) {\n\t\t\tcout << \"0.0000\" << endl;\n\t\t} else {\n\t\t\tif(sp.second != 0) p.push_back(sp);\n\n\t\t\tdouble ans = INF;\n\t\t\trep(i, p.size()) {\n\t\t\t\tdouble res = r + p[i].second;\n\t\t\t\t// cout << \"i:\" << i << \" |\" << p[i].first << \" \" << p[i].second << \" \" << res << \" \" << sqrt(r * r - p[i].first * p[i].first) << endl;\n\t\t\t\tans = min(ans, res - sqrt(r * r - p[i].first * p[i].first));\n\t\t\t}\n\n\t\t\trep(i, p.size()) {\n\t\t\t}\n\n\t\t\tcout << fixed;\n\t\t\tcout.precision(4);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define USE_CPP11\n// #define USE_PRINTF\n\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <numeric>\n#include <complex>\n#include <memory>\n#include <sstream>\n\n#ifdef USE_CPP11\n#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#endif\n\n#define PRINT(obj) cout << obj << endl\n#define REP(i, n) for(int (i) = 0; (i) < (n); i++)\n#define SPACE \" \"\n\ntypedef long long ll;\n\nconst int INF = 1e9 + 10;\n\nusing namespace std;\n\nnamespace Scanner {\n#ifdef USE_PRINTF\n  int    nextInt()    { int    d; scanf(\"%d\" , &d); return d; }\n  float  nextFloat()  { float  f; scanf(\"%f\" , &f); return f; }\n  double nextDouble() { double f; scanf(\"%lf\", &f); return f; }  \n  string nextString() { string s; scanf(\"%s\" , &s); return s; }\n  ll     nextll()     { ll     l; scanf(\"%ll\", &l); return l; }\n#else\n  int    nextInt()    { int    d; cin >> d; return d; }\n  float  nextFloat()  { float  f; cin >> f; return f; }\n  double nextDouble() { double f; cin >> f; return f; }  \n  string nextString() { string s; cin >> s; return s; }\n  ll     nextll()     { ll     l; cin >> l; return l; }\n#endif\n\n  string getLine() { \n    string input;\n    getline(cin, input);\n    return input;\n  }\n};\n\nnamespace myLibrary {\n  vector<string> split(const string& str, char delim) {\n    vector<string> ret;\n    size_t current = 0, found;\n    while ((found = str.find_first_of(delim, current)) != string::npos) {\n      ret.push_back(string(str, current, found - current));\n      current = found + 1;\n    }\n    ret.push_back(string(str, current, str.size() - current));\n    return ret;\n  }\n  \n#ifdef USE_CPP11\n  ///\n  /// higher-order functional\n  /// This is something like map in haskell, python, etc.\n  /// Sample usage:\n  ///   vector<int> a = {1, 2, 3, 4, 5};\n  ///   vector<int> b = myLibrary::_Map<int, int>(a, [](int n){\n  ///     return n * n;\n  ///   });\n  /// Result:\n  ///   b = 1, 4, 9, 16, 25\n  ///\n  template<typename T_IN, typename T_OUT, class Functor>\n  vector<T_OUT> _Map(vector<T_IN> src, Functor func) {\n    vector<T_OUT> ret;\n    for (int i = 0; i < src.size(); i++) {\n      ret.push_back(func(src[i]));\n    }\n    return ret;\n  }\n#endif\n\n};\n\nstruct Point {\npublic:\n  int y, x;\n  Point(int y, int x): y(y), x(x) { }\n  Point() { }\n};\n\n/// BEGIN //////////////////////////////////////////////////////////\n\nint main() {\n\n  while (true) {\n    int r = Scanner::nextInt();\n    int n = Scanner::nextInt();\n\n    if (r + n == 0) {\n      break;\n    }\n\n    int height[41] = { 0 };\n\n    int ymax = 0;\n    for (int i = 0; i < n; i++) {\n      int xl = Scanner::nextInt() + 20;\n      int xr = Scanner::nextInt() + 20;\n      int h  = Scanner::nextInt();\n\n      ymax = max(ymax, h);\n      for (int x = xl; x < xr; x++) {\n        height[x] = max(height[x], h);\n      }      \n    }  \n\n    double lt = 0, ht = ymax;\n\n    for (int i = 0; i < 100; i++) {\n      double mt = (lt + ht) / 2;\n      double y = mt - r;\n\n      bool isOK = true;\n\n      for (int i = 0; i < 41; i++) {\n        double dsq = 0;\n        if (i < 20) {\n          dsq = (i - 19) * (i - 19) + (height[i] - y) * (height[i] - y);\n        } else {\n          dsq = (i - 20) * (i - 20) + (height[i] - y) * (height[i] - y);\n        }\n        if (dsq < r * r) {\n          isOK = false;\n          break;\n        }\n      }\n\n      if (isOK) {\n        lt = mt;\n      } else {\n        ht = mt;\n      }\n    }\n\n    printf(\"%.15f\\n\", ht);\n\n  }\n\n  return 0;\n}\n\n/// END   //////////////////////////////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<functional>\n#include<ctime>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define ull unsigned long long\n\nint tower[42];\nint n;\ndouble r;\nint main(void){\n\twhile (true){\n\t\tcin >> r >> n;\n\t\tif (r == 0)return(0);\n\t\tmemset(tower, 0, sizeof(tower));\n\t\trep(i, 0, n){\n\t\t\tint l, r,h;\n\t\t\tcin >> l >> r >> h;\n\t\t\trep(j, l, r)if (tower[(j+42)%42] < h)tower[(j+42)%42] = h;\n\t\t}\n\n\t\tint min_h = 20;\n\t\trep(i, 0, 21){\n\t\t\tif (tower[i]>tower[41 - i])tower[i] = tower[41 - i];\n\t\t\t//cout << i << \" \" << tower[i] << endl;\n\t\t\tif (min_h < tower[i])tower[i] = min_h;\n\t\t\telse min_h = tower[i];\n\t\t}\n\t\tdouble ans = 20,x;\n\t\trep(i, 0, 21){\n\t\t\tx = (double)(20 - i);\n\t\t\tif (x>=r)continue;\n\t\t\tx = sqrt(r*r - x*x);\n\t\t\tans = min(tower[20-i]+(r-x), ans);\n\t\t\t//cout << ans << endl;\n\t\t}\n\t\tprintf(\"%5f\\n\", ans);\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(n); ++i)\nusing namespace std;\n#define N 20\n//#define vec vector<int>\n\nclass rec {\npublic:\n  int l;\n  int r;\n  int h;\n  rec(int l_ = 0, int r_ = 0, int h_ = 0) : l(l_), r(r_), h(h_) {}\n};\n\nint main(){\n  while(true){\n    int r,n;\n    cin>>r>>n;\n    if(r==0){\n      break;\n    }\n    n++;\n    vector<rec> v(n);\n    REP(i,n-1){\n      int tl,tr,th;\n      cin>>tl>>tr>>th;\n      v[i] = rec(tl,tr,th);\n    }\n    v[n-1] = rec(-20, 20, 0);\n    //hについて降順ソート\n    sort(v.begin(), v.end(), [](rec lhs, rec rhs){ return lhs.h > rhs.h;});\n\n    //左右で覆われている範囲\n    vector<int> pl(n,0);\n    vector<int> pr(n,0);\n    vector<int> p(n,0);\n\n    //pを計算\n    REP(i,n){\n      REP(j,n){\n        if(v[j].h <= v[i].h) break;\n        if(v[j].l <= pr[i]){\n          pr[i] = max(pr[i], v[j].r);\n        }\n        if(v[j].r >= pl[i]){\n          pl[i] = min(pl[i], v[j].l);\n        }\n      }\n    }\n    REP(i,n){\n      p[i] = min(-pl[i], pr[i]);\n    }\n\n    //tを計算\n    long double t = 500.0;\n    REP(i,n){\n      if(r<=p[i]) continue;\n      long double tmp = v[i].h + r - sqrt(r*r - p[i]*p[i]);\n      t = min(tmp,t);\n    }\n    cout<<fixed << setprecision(4) <<t<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nint main() {\n\twhile (true) {\n\t\tint r, n;\n\t\tcin >> r >> n;\n\t\tif (r == 0) return 0;\n\t\tvector<tuple<double, double, double>> inputs;\n\t\tREP(i, n) {\n\t\t\tdouble a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tinputs.push_back(make_tuple(a, b, c));\n\t\t}\n\t\tinputs.push_back(make_tuple(-100, 100, 0));\n\t\tdouble bot_time = 0;\n\t\tdouble top_time = 100;\n\t\tREP(t, 100) {\n\t\t\tdouble mid_time = (bot_time + top_time) / 2.0;\n\t\t\tint ng = 0;\n\t\t\tfor (double q = -r; q <= r-1.0; ++q) {\n\t\t\t\tdouble required_length = r * r - q * q;\n\t\t\t\trequired_length = sqrt(required_length);\n\t\t\t\tint ok = 0;\n\t\t\t\tREP(j, inputs.size()) {\n\t\t\t\t\tif (get<0>(inputs[j]) <= q && q < get<1>(inputs[j]) && (get<2>(inputs[j]) + r - mid_time) >= required_length) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok == 0) {\n\t\t\t\t\tng = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (double q = r; q >= -r + 1.0; --q) {\n\t\t\t\tdouble required_length = r * r - q * q;\n\t\t\t\trequired_length = sqrt(required_length);\n\t\t\t\tint ok = 0;\n\t\t\t\tREP(j, inputs.size()) {\n\t\t\t\t\tif (get<0>(inputs[j]) < q && q <= get<1>(inputs[j]) && (get<2>(inputs[j])+r - mid_time) >= required_length) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok == 0) {\n\t\t\t\t\tng = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ng == 0) {\n\t\t\t\tbot_time = mid_time;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttop_time = mid_time;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10);\n\t\tcout << bot_time << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint r,n;\n\twhile(cin >> r >> n,r) {\n\t\tvector<int> hi(2*r);\n\t\twhile(n--) {\n\t\t\tint xl,xr,h; cin >> xl >> xr >> h;\n\t\t\tfor(int i=max(-r,xl);i<min(r,xr);++i) hi[i+r]=max(hi[i+r],h);\n\t\t}\n\t\tdouble ans=1e9;\n\t\tfor(int i=-r;i<=r;++i) {\n\t\t\tdouble tmp=sqrt(r*r-i*i);\n\t\t\tif(i!=-r) ans=min(ans,hi[i+r-1]-tmp+r);\n\t\t\tif(i!=r) ans=min(ans,hi[i+r]-tmp+r);\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\nint main(){\n  int r,n;\n  while(cin>>r>>n,r+n){\n    vi in(50);//25=center\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      loop(i,a,b)in[25+i]=max(in[25+i],c);\n    }\n    double out=1e9;\n    for(int i=25-r+1;i<25+r;i++){\n      int t=min(in[i],in[i-1]);\n      double tim=t-sqrt(r*r-(25-i)*(25-i));\n      out=min(tim,out);\n    }\n    printf(\"%.9f\\n\",out+r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,N,n) for(int i=N;i>=n;i++)\n#define CH(n,a,b) (a)<=(n)&&(n)<(b)\n#define p(s) cout<<s<<endl;\ntypedef long long ll;\nusing namespace std;\n\nbool grid[25][45];\n\nint main() {\n\tint n, r, lx, rx, h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0 && n == 0) break;\n\t\tREP(i,0,25)REP(j,0,45) grid[i][j] = 0;\n\t\tREP(ii,0,n){\n\t\t\tcin>>lx>>rx>>h;\n\t\t\tREP(k,lx+20,rx+20)REP(l,0,h)grid[l][k] = 1;\n\t\t}\n\t\tREP(i,0,21){\n\t\t\tdouble ans=1000000;\n\t\t\tREP(w,-r+20,r+20){\n\t\t\t\tif( (grid[i][w] == 0) ){\n\t\t\t\t\tdouble tmp;\n\t\t\t\t\tif(w<20) tmp=  r - sqrt(r*r - (19-w)*(19-w))+i;\n\t\t\t\t\telse tmp = r - sqrt(r*r - (20-w)*(20-w))+i;\n\t\t\t\t\tans=min(tmp,ans);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans!=1000000) {\n\t\t\t\tprintf(\"%.6f\\n\", ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef long double ld;\n\nint main() {\n    std::cout<< std::setprecision(11) << std::fixed;\n    int r, n;\n    while(cin >> r >> n, r != 0 || n != 0) {\n        vi xl(n), xr(n), h(n);\n        REP(i, n) cin >> xl[i] >> xr[i] >> h[i];\n\n        vector<int> px;\n        px.push_back(-100);\n        px.push_back(-r);\n        px.push_back(0);\n        px.push_back(+r);\n        px.push_back(+100);\n        n = -1;\n        REP(i, xl.size()) {\n            px.push_back(xl[i]);\n            px.push_back(xr[i]);\n        }\n        sort(ALL(px));\n        px.erase(unique(ALL(px)), px.end());\n        vector<int> ph(px.size(), 0);\n        REP(k, px.size()) {\n            REP(i, xl.size()) {\n                int x = px[k];\n                if (xl[i] <= x && x < xr[i]) ph[k] = max(ph[k], h[i]);\n            }\n        }\n\n        // REP(i, ph.size()){  cout<< \"#\" << px[i] << \" - \" << ph[i] << endl; }\n\n        ld al = 0;\n        ld ar = 100;\n        ld eps = 0.00000001;\n        while(ar - al > eps) {\n            ld m = (al + ar) / 2;\n            bool ok = true;\n            REP(i, px.size() - 1) {\n                ld nl = px[i], nr = px[i + 1];\n                ld nh =  ph[i] - m + r;\n                nh = max(0.0L, nh);\n                // cout<< \"T=\" << m << \" Check:\" << nl << \",\" << nr << \" H:\" << nh << endl;\n                ld rl = r * r - nl * nl;\n                ld rr = r * r - nr * nr;\n                // cout<< \"=\" << rl << \",\" << rr << endl;\n \n                if (rl > nh * nh || rr > nh * nh) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) { al = m; /* cout<< \"OK\" << endl; */}\n            else { ar = m; /* cout<< \"NG\" << endl; */}\n        }\n        cout<< al << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 114514\n\n#define IN 1\n#define OUT 2\n\nusing Data = pair<int, double>;\nusing Pair = pair<int, Data>;\nusing Seg = pair<int, int>;\n\nint n;\ndouble r;\nvector<Pair> es;\nmap<Seg, double> mp;\n\nbool check(double t) {\n  for (auto &itr : mp) {\n    Seg s = itr.first;\n    int a = s.first;\n    int b = s.second;\n    if (b <= -r || r <= a) continue;\n\n    int mid = 0;\n    if (b <= 0) mid = b;\n    else if (a >= 0) mid = a;\n\n    if (sqrt(r*r - double(mid)*mid)-r+t > itr.second) return false;\n  }\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%lf%d\", &r, &n);\n    if (r == 0 && n == 0) return 0;\n    es.clear();\n    for (int i=0; i<n; i++) {\n      int l, r;\n      double h;\n      scanf(\"%d%d%lf\", &l, &r, &h);\n      es.emplace_back(Pair(l, Data(IN, h)));\n      es.emplace_back(Pair(r, Data(OUT, h)));\n    }\n    sort(es.begin(), es.end());\n\n    multiset<double> hs;\n    hs.insert(0.0);\n    int prevx = -INF;\n    mp.clear();\n    for (auto &pa : es) {\n      int x = pa.first;\n      int type = pa.second.first;\n      double h = pa.second.second;\n\n      if (prevx != x) {\n        mp[Seg(prevx, x)] = *hs.rbegin();\n      }\n\n      if (type == IN) {\n        hs.insert(h);\n      } else {\n        hs.erase(hs.find(h));\n      }\n      prevx = x;\n    }\n\n    double low = 0.0;\n    double high = INF;\n    for (int i=0; i<40; i++) {\n      double mid = (low+high)/2;\n      if (check(mid)) low = mid;\n      else high = mid;\n    }\n    printf(\"%.10f\\n\", low);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\nint main(){\n  int n,m;\n  double r;\n  while(cin>>r>>n,n){\n    int h[50]={};\n    seg s[50];\n    r(i,50)s[i].p1.x=i,s[i].p1.y=0,s[i].p2.y=0,s[i].p2.x=i+1;\n    r(i,n){\n      int a,b,c;\n      cin>>a>>b>>c;\n      for(int i=a+25;i<b+25;i++)\n        s[i].p1.y=s[i].p2.y=max(s[i].p1.y,(double)c);\n    }\n  int p=0,t=0;\n    Point time;\n    time.x=25;\n    time.y=-r;\n    double d=0;\n    //r(i,50)cout<<s[i].p1.x<<s[i].p1.y<<s[i].p2.x<<s[i].p2.y<<endl;\n    while(1){\n      r(i,50){//cout<<getDistanceSP(s[i],time)<<endl;\n        if((getDistanceSP(s[i],time)<(double)r-EPS)){\n        printf(\"%.4f\\n\",d-0.0001);\n        goto L;\n      }}\n      d+=0.0001;\n      time.y+=0.0001;\n    }\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tint r;\n\t\tint n;\n\t\tint xl, xr, h;\n\t\tint dp[41] = {};\n\t\tdouble dph[41] = {};\n\t\tdouble mini = 20.0;\n\t\tdouble minihigh = 20.0;\n\n\t\tcin >> r >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl >> xr >> h;\n\n\t\t\tFOR(j, xl, xr-1) {\n\t\t\t\tif (dp[j + 20] < h) {\n\t\t\t\t\tdp[j + 20] = h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = -r; i <= r-1; i++) {\n\t\t\tcout << i << \" \" << dp[i+20] << endl;\n\t\t}*/\n\t\t\n\n\t\tfor (int i = -r; i <= r; i++) {\n\t\t\tdouble rr, xx, yy;\n\t\t\tif (i < 0) {\n\t\t\t\trr = (double)r;\n\t\t\t\txx = (double)(i+1);\n\t\t\t\tyy = sqrt(rr*rr - xx * xx);\n\t\t\t\tdph[i + 20] = dp[i + 20] +r-yy;\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\trr = (double)r;\n\t\t\t\txx = (double)(i);\n\t\t\t\tyy = sqrt(rr*rr - xx * xx);\n\t\t\t\tdph[i + 20] = dp[i + 20] + r - yy;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\trr = (double)r;\n\t\t\t\txx = (double)(i);\n\t\t\t\tyy = sqrt(rr*rr - xx * xx);\n\t\t\t\tdph[i + 20] = dp[i + 20] + r - yy;\n\t\t\t}\n\n\t\t}\n\n\t\t//cout << endl;\n\t\tfor (int i = -r; i <= r-1; i++) {\n\t\t\t//cout << i << \" \" << dph[i + 20] << endl;\n\t\t\tif (dph[i + 20] < mini) {\n\t\t\t\tmini = dph[i + 20];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.5lf\\n\", max(mini, 0.0));\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  double r;\n  int n;\n  double ans;\n  double left,right,h;\n\n  while(1){\n    cin >> r >> n;\n    if(r==0) break;\n    ans=21;\n    vector<double> takasahidari(41,0),takasamigi(41,0);\n    for(int i=0;i<n;i++){\n      cin >> left >> right >> h;\n      for(int j=left;j<right;j++){\n        takasahidari[j+20]=max(takasahidari[j+20],h);\n      }\n      for(int j=left+1;j<=right;j++){\n        takasamigi[j+20]=max(takasamigi[j+20],h);\n      }\n    }\n    /*\n    for(int i=0;i<41;i++){\n      cout << takasahidari[i] << \" \";\n    }\n    cout << endl;\n    for(int i=0;i<41;i++){\n      cout << takasamigi[i] << \" \";\n    }\n    cout << endl;\n    */\n    for(int i=20-r;i<=20+r;i++){\n      /*\n      if(ans>min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20))){\n        cout << \"(\" << i-20 << \",\" << min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)) << \")\" << endl;\n      }\n      */\n      if(takasahidari[i]>0&&takasamigi[i]>0){\n        ans=min(ans,min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)));\n      }\n      if(ans==21){\n        ans=0;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  while(true){\n    double r,n,INF=9999;\n    cin>>r>>n;\n    if(r==0&&n==0) break;\n    double xleft[41]={},xright[41]={};\n    for(int i=0;i<n;i++){\n      double xl,xr,h;\n      cin>>xl>>xr>>h;\n      for(int j=xl;j<=xr;j++){\n        int k=20+j;\n        if(j==xl){xright[k]=max(xright[k],h);}\n        else if(j==xr){xleft[k]=max(xleft[k],h);}\n        else{\n          xright[k]=max(xright[k],h);\n          xleft[k]=max(xleft[k],h);\n        }\n      /*if(h>=xleft[k]){\n          xright[k]=xleft[k];\n          xleft[k]=h;\n        }else if(h>=xright[k]){\n          xright[k]=h;\n        }*/\n      }\n    }\n    double ans=INF;\n    for(int i=-20;i<=20;i++){\n      double id=i;\n      int k=20+i;\n      if(abs(i)>r) continue;\n      //cout<<\"xleft\"<<xleft[k]<<\" \"<<k<<endl;\n      //cout<<\"xright\"<<xright[k]<<\" \"<<k<<endl;\n      double yleft,yright;\n      yleft=xleft[k]+r-sqrt(pow(r,2)-pow(id,2));\n      yright=xright[k]+r-sqrt(pow(r,2)-pow(id,2));\n      if(i!=-r)ans=min(ans,yleft);\n      if(i!=r)ans=min(ans,yright);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n#define px 20\n\nint main() {\n\n  while( true ) {\n\n    long long int r, n;\n    cin >> r >> n;\n    if ( r == 0 ) break;\n\n    long long int dy[50][2] = {};\n\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int minx, maxx, h;\n      cin >> minx >> maxx >> h;\n      minx += px;\n      maxx += px;\n      for ( long long int j = minx; j < maxx; j++ ) {\n\tdy[j][1] = max( dy[j][1], h );\n\tdy[j+1][0] = max( dy[j+1][0], h );\n      }\n    }\n    \n    double ans = 50.0;\n\n    for ( long long int i = px - r + 1; i < px + r; i++ ) {\n      double x = i - px;\n      double y = sqrt( r * r - x * x );\n      ans = min( ans, dy[i][0] - y + r );\n      ans = min( ans, dy[i][1] - y + r );\n    }\n    ans = min( ans, 0.0 + dy[px-r][1] + r );\n    ans = min( ans, 0.0 + dy[px+r][0] + r );\n    cout << fixed << setprecision(10) << ans << endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\nstring s[50],t[50];\nsigned main(){\n\tint n,m,r;\n\t/*\n\tdouble d;\n\tcin>>d;\n\t\n\tdouble ans=0;\n\tfor(int i=0;i<=10;i++){\n\t\tif(i>d) break;\n\t\tdouble ii=i+0.0;\n\t\tans=max(ans,sqrt(d*d-ii*ii));\n\t}\n\tprintf(\"%.10lf\\n\",ans);\n\t*/\n\t\n\twhile(1){\n\tcin>>r>>n;\n\t\t//int sumi[200]={0};\n\t\tif(n==0&&r==0) return 0;\n\t\tint a[100]={0};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x2,x1,h;\n\t\t\tcin>>x1>>x2>>h;\n\t\t\tfor(int i=x1+50+1;i<=x2+50;i++) a[i]=max(a[i],h);\n\t\t}\n\t\tint aa[100]={0};\n\t\tfor(int i=50-r;i<=r+50;i++) aa[i]=min(a[i],a[i+1]);\n\t\tdouble ans=1000000000;\n\t\tfor(int i=50-r;i<=50+r;i++){\n\t\t\tint d=i-50;\n\t\t\tdouble w=(r+0.0)-sqrt((r+0.0)*(r+0.0)-(d+0.0)*(d+0.0));\n\t\t\tans=min(ans,aa[i]+w)\t;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",ans);\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\ndouble sun_h(double x, int r) {\n\treturn -1.*r + sqrt(1.*r*r-x*x);\n}\n\nint main() {\n\tint r, n;\n\twhile(cin >> r >> n, r||n) {\n\t\tint height[40] = {};\n\t\trep(i, n) {\n\t\t\tint l, r, h;\n\t\t\tcin >> l >> r >> h;\n\t\t\tfor(int i=l+20; i<r+20; i++) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\t\tdouble mini = 100;\n\t\tfor(int x=-r+20; x<20; x++) {\n\t\t\tmini = min(mini, height[x]-sun_h(x-19,r));\n\t\t}\n\t\tfor(int x=20; x<r+20; x++) {\n\t\t\tmini = min(mini, height[x]-sun_h(x-20,r));\n\t\t}\n\t\tcout << mini << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tR -= eps;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n//素数判定　素数ならそのまま返す　合成数なら０を返す。\nint sosu(int n) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) { return 0; }\n\t}\n\treturn n;\n}\n\nint main() {\n\tcomplex<long double>cmpmp;\n\tconst long long int mod = 1000000007;\n\tmap<long long int, long long int>mp;\n\tcout << fixed << setprecision(10);\n\tlong long int r, n, light[50][30] = {};\n\twhile (1) {\n\t\tlong long int r, n, light[50][30] = {};\n\t\tlong double mi = 20.0;\n\t\tcin >> r >> n;\n\t\tif (r == 0) { return 0; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong long int xli, xri, hi;\n\t\t\tcin >> xli >> xri >> hi;\n\t\t\tfor (int j = xli + 20; j < xri + 20; j++) {\n\t\t\t\tfor (int k = 0; k < hi; k++) {\n\t\t\t\t\tlight[j][k] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 20-r; i < 20+r; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tif (light[i][j] == 0) {\n\t\t\t\t\tif (i != 20 - r) {\n\t\t\t\t\t\tmi = min(mi, (long double)j + (long double)r - sqrt((long double)(r * r) - (long double)((i - 20) * (i - 20))));\n\t\t\t\t\t}\n\t\t\t\t\tif (i != 19 + r) {\n\t\t\t\t\t\tmi = min(mi, (long double)j + (long double)r - sqrt((long double)(r * r) - (long double)((i - 20 + 1) * (i - 20 + 1))));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << mi << endl;\n\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nclass Solver {\n    public:\n        int r, n;\n        int xl[20], xr[20], h[20];\n        double solve() {\n            int hl[41], hr[41];\n            int delta = 20;\n            double time_min = 100;\n            for (int i = -20; i <= 20; ++i) {\n                hl[i + delta] = hr[i + delta] = 0;\n            }\n            for (int i = 0; i < n; ++i) {\n                for (int x = xl[i]; x < xr[i]; ++x) {\n                    hr[x + delta] = max(hr[x + delta], h[i]);\n                }\n                for (int x = xl[i] + 1; x <= xr[i]; ++x) {\n                    hl[x + delta] = max(hl[x + delta], h[i]);\n                }\n            }\n            for (int x = -r + 1; x < r; ++x) {\n                time_min = min(time_min, min(hl[x + delta], hr[x + delta]) + r - sqrt(r * r - x * x));\n            }\n            return time_min;\n        }\n};\n\nint main() {\n    Solver s;\n    while (true) {\n        cin >> s.r >> s.n;\n        if (s.r == 0) {\n            return 0;\n        }\n        for (int i = 0; i < s.n; ++i) {\n            cin >> s.xl[i] >> s.xr[i] >> s.h[i];\n        }\n        cout.precision(128);\n        cout << fixed << s.solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint build[20][40];\n\nvoid printbuild() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      if (build[i][j]) cout << \"#\";\n      else cout << \".\";\n    }\n    cout << endl;\n  }\n}\n\nvoid makeOut() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 1 - build[i][j];\n    }\n  }\n}\n\nbool touchingSun(long h, long i, double c, long r) {\n  return hypot(19 - h - c, i - 20) < r || hypot(19 - h - c, i - 19) < r;\n}\n\nbool touchingSunAll(double c, long r) {\n  for (int h = 0; h < 20; h++) {\n    for (int i = 0; i < 40; i++) {\n      if (build[h][i] && touchingSun(h, i, c, r)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid reset() {\n  for (int i = 0; i < 20; i++) {\n    for (int j = 0; j < 40; j++) {\n      build[i][j] = 0;\n    }\n  }\n}\n\nvoid fillbuild(long l, long r, long h) {\n  for (int i = 19; i >= 20 - h; i--) {\n    for (int j = l + 20; j < r + 20; j++) {\n      build[i][j] = 1;\n    }\n  }\n}\n\nvoid solve(long n, long r) {\n  reset();\n  long l, rr, h;\n  for (int i = 0; i < n; i++) {\n    cin >> l >> rr >> h;\n    fillbuild(l, rr, h);\n  }\n  makeOut();\n  // printbuild();\n  double c = -r;\n  double step = 0.0001;\n  while (!touchingSunAll(c, r)) c += step;\n  printf(\"%.4f\\n\", c + r);\n}\n\nint main() {\n  long n, r;\n  while (1) {\n    cin >> r >> n;\n    if (n + r) {\n      solve(n, r);\n    } else {\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint xl[20], xr[20], h[20];\nconst double EPS = 1e-6;\nint main() {\n\tint R, n;\n\twhile (cin >> R >> n,R) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t}\n\t\tdouble l = 0, r = 60;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tdouble m = (l + r) / 2;\n\t\t\tbool OK = 1;\n\t\t\tfor (int j = 0; j <= 10000; j++) {\n\t\t\t\tdouble x = -R + (2 * R) / 10000.0 * j;\n\t\t\t\tint Max = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (xl[k] <= x+EPS&&x <= xr[k]+EPS) {\n\t\t\t\t\t\tMax = max(Max, h[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble H = sqrt(R*R - x*x) + m - R;\n\t\t\t\tif (Max < H+EPS) {\n\t\t\t\t\tOK = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (OK) l = m; else r = m;\n\t\t}\n\t\tcout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    double r;\n    int n;\n    while (cin >> r >> n && n){\n        map<int, double> hl, hr;\n        while (n--){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            hr[xl] = fmax(hr[xl], h);\n            hl[xr] = fmax(hl[xr], h);\n            FOR(i,xl+1,xr-1){\n                hl[i] = fmax(hl[i], h);\n                hr[i] = fmax(hr[i], h);\n            }\n        }\n\n        double ans = fmin(hr[-r], hl[r]) + r;\n        FOR(i,-r+1,r-1){\n            double h = fmin(hl[i], hr[i]);\n            double y = r - sqrt(r*r-i*i);\n            ans = fmin(ans, y+h);\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int r,n;\n  while(cin>>r>>n,r){\n    int h[50][2]={};\n    for(int i=0,a,b,y;i<n;i++){\n      cin>>a>>b>>y;\n      h[a+20][0]=max(h[a+20][0],y);\n      h[b+20][1]=max(h[b+20][1],y);\n      for(int x=a+1;x<b;x++){\n\th[x+20][0]=max(h[x+20][0],y);\n\th[x+20][1]=max(h[x+20][1],y);\n      }\n    }\n    double ans=1e9;\n    for(int x=-r+1;x<r;x++)\n      ans=min(ans,min(h[x+20][0],h[x+20][1])-sqrt(r*r-x*x)+r);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 1000;\nint main(){\n  cout << fixed << setprecision(5);\n  while (1){\n    int r, n;\n    cin >> r >> n;\n    if (r == 0 && n == 0){\n      break;\n    }\n    vector<int> H(40, 0);\n    for (int i = 0; i < n; i++){\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n      xl += 20;\n      xr += 20;\n      for (int j = xl; j < xr; j++){\n        H[j] = max(H[j], h);\n      }\n    }\n    double ans = INF;\n    for (int i = 20 - r; i < 20 + r; i++){\n      ans = min(ans, H[i] + r - sqrt(pow(r, 2) - pow(min(abs(i - 20), abs(i - 19)), 2)));\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n//#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tint r, n;\n\twhile (cin >> r >> n && r) {\n\t\tV height(r * 2);\n\t\trep(i, n) {\n\t\t\tint lx, rx, h; cin >> lx >> rx >> h;\n\t\t\tlx += r;\n\t\t\trx += r;\n\t\t\tREP(i, max(0, lx), min(r * 2, rx)) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1 << 27;\n\t\trep(x, r * 2) {\n\t\t\tint h = height[x];\n\t\t\tdouble a = sqrt(r * r - pow(abs(r - x) - (r - x > 0), 2));\n\t\t\tdouble sun = (double)(h + r) - a;\n\t\t\tans = min(ans, sun);\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int r, n;\n  int height[44];\n  while(cin >> r >> n, r || n) {\n    memset(height, 0, sizeof(height));\n    while(n--) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      for(int i = xl; i < xr; i++) height[i+22] = max(height[i+22], h);\n    }\n    double ans = 1 << 25;\n    for(int i = -r+1; i < r; i++) {\n      ans = min(ans, height[i+22] + r - sqrt(r*r - i*i));\n    }\n    printf(\"%.4f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int r, n;\n    while(cin >> r >> n && r != 0) {\n        map<int, int> h;\n        REP(_, n) {\n            int L, R, a;\n            cin >> L >> R >> a;\n            for(int i = L; i < R; i++) {\n                h[i] = max(h[i], a);\n            }\n        }\n\n        double ans = 1e16;\n        for(int i = -r; i < r; i++) {\n            double p = (i < 0 ? i + 1: i);\n            ans = min(ans, r - sqrt(r * r - p * p) + h[i]);\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n\ntemplate<typename F> double bsearch(double ok, double ng, ll loop, F f) {\n\tREP(i, loop) {\n\t\tdouble middle = (ok + ng) / 2;\n\t\t(f(middle) ? ok : ng) = middle;\n\t}\n\treturn ok;\n}\nint main() {\n\t#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n\t#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\t\n\twhile (true) {\n\t\tll r, n; cin >> r >> n;\n\t\tif (r == 0)break;\n\t\tvector<ll> hl(30, 0), hr(30, 0);\n\t\tconst int D = 30;\n\t\tREP(i, n) {\n\t\t\tll xl, xr, h; cin >> xl >> xr >> h;\n\t\t\tFOR(x, xl, min(xr, 0ll)) hl[abs(x) - 1] = max(hl[abs(x) - 1], h);\n\t\t\tFOR(x, max(0ll, xl), xr) hr[x] = max(hr[x], h);\n\t\t}\n\t\tcout << bsearch(0, 100000, 1000, [&](double t) {\n\t\t\tFOR(i, -r + 1, r) {\n\t\t\t\tif (i <= 0) if (sqrt(r*r - i*i) + t - r > hl[abs(i)]) return false;\n\t\t\t\tif (i >= 0) if (sqrt(r*r - i*i) + t - r > hr[i]) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<int, int> pii;\ndouble GetPos(point x, double r){\n  if(abs(x.real()) > r)return 1e9;\n  double maxi = x.imag(), mini = -1000, med = (maxi + mini)/2;\n            \n  while(maxi - mini > 1e-9){\n    point p = point(0, med);\n    if(abs(x - p) < r){\n      maxi = med;\n    }else{\n      mini = med;      \n    }\n    med = (maxi + mini)/2;\n  }\n  return maxi;\n}\nint main(int argc, char *argv[]){\n  int r, n;\n  while(std::cin >> r >> n, n){\n    vector<point> corner;\n    double ans = 1e9;\n    vector<pii> begin, end;\n    for (int i = 0; i < n; i++) {\n      int b, e, h;\n      std::cin >> b >> e >> h;\n      corner.push_back(point(b, h));\n      corner.push_back(point(e, h));\n      begin.push_back(pii(b, -h));\n      end.push_back(pii(e, -h));\n    }\n    sort(begin.begin(), begin.end());\n    sort(end.begin(), end.end());\n    int bpos = 0, epos = 0;\n    if(begin[0].first > -r || end[n - 1].first < r)ans = 0;\n    int sum = 0;\n    for (int i = 0; i < 2*begin.size() - 2; i++) {\n      if(begin[bpos].first > end[epos].first)ans = -r;\n      int hight = min(-begin[bpos].second, -end[epos].second);\n      if(i%2){\n        if(end[epos].first == end[epos + 1].first)continue;\n        //std::cout << point(end[epos].first, hight) << std::endl;\n        corner.push_back(point(end[epos].first, hight));\n        epos++; \n      }else{\n        bpos++;\n        if(begin[bpos].first == begin[bpos - 1].first)continue;\n        //std::cout << point(begin[bpos].first, hight) << std::endl;\n        corner.push_back(point(begin[bpos].first, hight));\n      }\n    }\n    for (point i: corner){\n      //std::cout << corner[i] << std::endl;\n      ans = min(ans, GetPos(i, r));\n      //std::cout << ans << std::endl;\n    }\n    printf(\"%.12lf\\n\", ans + r);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\nint main()\n{\n  int rad,n;cin>>rad>>n;\n  while(rad!=0||n!=0)\n  {\n    vector<int> l(n);\n    vector<int> r(n);\n    vector<int> h(n);\n    int i,j;\n    rep(i,n)cin>>l[i]>>r[i]>>h[i];\n    rep(i,n)\n    {\n      l[i]+=20;\n      r[i]+=20;\n    }\n    vector<int> maxh(20*2,0);\n    rep(i,n)\n    {\n      rep(j,20*2)\n      {\n        if(j<l[i]||j>=r[i])continue;\n        maxh[j]=max(maxh[j],h[i]);\n      }\n    }\n    double ans=100.0;\n    for(i=20-rad;i<=20+rad;i++)\n    {\n      int useh;\n      if(i==20-rad)useh=maxh[i];\n      else if(i==20+rad)useh=maxh[i-1];\n      else useh=min(maxh[i-1],maxh[i]);\n      int x=i-20;\n      double kans=useh+rad-sqrt(rad*rad-x*x);\n      ans=min(ans,kans);\n    }\n    cout<<fixed<<setprecision(10)<<ans<<endl;\n    cin>>rad>>n;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ndouble EPS = 1e-10;\n\n// 誤差を考慮してた考慮して足し算を行う\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n  return a+b;\n}\nstruct P {\n  double x,y;\n  P(){}\n  P(double x, double y): x(x), y(y) {}\n\n  P operator + (P p){\n    return P(add(x,p.x), add(y,p.y));\n  }\n\n  P operator - (P p){\n    return P(add(x,-p.x), add(y,-p.y));\n  }\n\n  P operator * (double d){\n    return P(x * d, y * d);\n  }\n\n  double dot(P p){ //内積\n    return add(x * p.x, y * p.y);\n  }\n\n  double det(P p) { //外積\n    return add(x * p.y , -y * p.x);\n  }\n\n  double p_abs(){return sqrt(p_norm());}\n  double p_norm() { return x * x + y * y; }\n\n};\n\n// 線分p1-p2上に点qがあるか判定\nbool on_seg(P p1, P p2, P q){\n  return (p1-q).det(p2 - q) == 0 && (p1 - q).dot(p2 - q) <= 0;\n}\n\n// 直線p1-p2と直線q1-q2 の交点\nP intersection(P p1, P p2, P q1, P q2){\n  return p1 + (p2 - p1) * ((q2 - q1).det(q1- p1) / (q2 - q1).det(p2 - p1));\n}\n\nstruct Segment{\n  P p1, p2;\n};\n\ntypedef Segment Line;\n\ndouble getDistanceLP(Line l, P p){\n  return abs(((l.p2 - l.p1).det(p - l.p1))) / (l.p2 - l.p1).p_abs();\n}\n\n//線分sと点pの距離\ndouble getDistanceSP(Segment s, P p){\n  if((s.p2 - s.p1).dot(p - s.p1) < 0.0) return (p - s.p1).p_abs();\n  if((s.p1 - s.p2).dot(p - s.p2) < 0.0) return (p - s.p2).p_abs();\n  return getDistanceLP(s,p);\n}\n\nvoid solve(double r, ll n , VLL &xmi, VLL &xma ,VLL & h){\n  map<PII,ll> maxH;\n  rep(i,n){\n    for(int x = xmi[i]; x < xma[i]; x++){\n      maxH[PII(x,x+1)] = max(maxH[PII(x,x+1)], h[i]);\n    }\n  }\n\n  vector<Segment> s;\n  P prev = P(-23,0);\n  FOR(x,-22,22){\n    if(prev.y == maxH[PII(x,x+1)]) continue;\n    else{\n      Segment tmp;\n      tmp.p1 = prev, tmp.p2 = P(x,prev.y);\n      s.push_back(tmp);\n      prev = P(x,maxH[PII(x,x+1)]);\n    }\n  }\n  Segment tmp;\n  tmp.p1 = prev, tmp.p2 = P(22,0);\n  s.push_back(tmp);\n\n  //rep(i,s.size()) cout << s[i].p1.x << \",\" << s[i].p1.y << \"    \" << s[i].p2.x << \",\" << s[i].p2.y << endl;;\n  for(double o = -r;; o+=0.0005){\n    P O(0,o);\n    rep(i,s.size()){\n      if(getDistanceSP(s[i],O) + EPS >= r){\n        continue;\n      }\n      else{\n        printf(\"%0.5lf\\n\",o+r);\n        return;\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n\n  ll r;\n  int n;\n  while(true){\n    cin >> r >> n;\n    if(r == 0 && n == 0) break;\n    VLL xmi(n) , xma(n) , h(n);\n    rep(i,n){\n      cin >> xmi[i] >> xma[i] >> h[i];\n    }\n    solve(r,n,xmi,xma,h);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF 1e10\n#define EPS (1e-10)    //誤差\n#define PI 3.1415926535897932384626433832795028841971\n\nsigned main(){\n    \n    while(1){\n        double n, rr; cin >> rr >> n;\n        if(n == 0 && rr == 0) break;\n        vector<double> l(n);\n        vector<double> r(n);\n        vector<double> h(n);\n        for(int i = 0; i < n; i++) cin >> l[i] >> r[i] >> h[i];\n\n        vector<double> a(200, 0);\n        for(int i = 0; i < n; i++){\n            for(int j = l[i]; j < r[i]; j++){\n                int x = j + 100;\n                a[x] = max(a[x], h[i]);\n            }\n        }\n\n        double lb = 0;\n        double ub = 100100.0;\n\n        for(int itr = 0; itr <= 1000; itr++){\n            double t = (lb + ub) / 2.0;\n            double y = t - rr;\n            bool flag = true;\n            for(int i = 0; i < 200; i++){\n                \n                double yy = a[i];\n                double xx1 = i - 100;\n                double xx2 = i - 100 + 1;\n                if(abs(xx1) < rr){\n                    if(sqrt(rr * rr - xx1 * xx1) + y > yy) flag = false;\n                }\n\n                if(abs(xx2) < rr){\n                    if(sqrt(rr * rr - xx2 * xx2) + y > yy) flag = false;\n                }\n\n                if(!flag) break;\n\n            }\n\n            if(flag) lb = t;\n            else ub = t;\n        }\n\n        printf(\"%.10f\\n\", lb);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    double rr;\n    int n;\n    cin >> rr >> n;\n    if(rr==0) return 0;\n    vector<int> t(42,0);\n    int l,r,hh;\n    rep(i,n){\n      cin >> l >> r >> hh;\n      l+=21,r+=21;\n      repp(j,l,r){\n        t[j]=max(t[j],hh);\n      }\n    }\n    double ans=IINF;\n    double x,y;\n    repp(i,20-rr+1,20+rr){\n      x=abs(i-20);\n      y=min(t[i],t[i+1]);\n      // cout << i-20 SP y SP y-sqrt(rr*rr-x*x)+rr << endl;\n      ans=min(ans,y-sqrt(rr*rr-x*x)+rr);\n    }\n    cout << fixed << setprecision(10) << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing ll = long long;\n\nint R, N;\nint xl[40], xr[40], h[40];\n\ndouble solve() {\n    int hs[40];\n    fill(hs, hs+40, 0);\n    for (int j = 0; j < N; ++j) {\n        for (int k = max(-R, xl[j]); k < min(R, xr[j]); ++k) {\n            hs[k+R] = max(hs[k+R], h[j]);\n        }\n    }\n    double ans = 10000;\n    for (int j = 0; j < 2*R; ++j) {\n        double t1 = hs[j] - sqrt(R*R - (j-R)*(j-R)) + R;\n        double t2 = hs[j] - sqrt(R*R - (j-R+1)*(j-R+1)) + R;\n        ans = min(ans, min(t1, t2));\n    }\n    return ans;\n}\n\nint main(){\n    while (true) {\n        cin >> R>> N;\n        if (R == 0 && N == 0) break;\n        for (int j = 0; j < N; ++j) {\n            cin >> xl[j] >> xr[j] >> h[j];\n        }\n        printf(\"%.11f\\n\", solve());\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nbool kage[41][21];\n\nint main(){\n\tint n,r;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r+n==0)break;\n\t\tmemset(kage,false,sizeof(kage));\n\t\tREP(i,n){\n\t\t\tint x1,x2,h;\n\t\t\tcin>>x1>>x2>>h;\n\t\t\tfor(int x=x1+20;x<x2+20;x++){\n\t\t\t\tfor(int y=0;y<h;y++){\n\t\t\t\t\tkage[x][y]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool w=false;\n\t\tdouble ans=0.0;\n\t\tREP(i,21){\n\t\t\tint c=0;\n\t\t\twhile(kage[20+c][i]&&kage[19-c][i])c++;\n\t\t\tif(c==0){\n\t\t\t\tans=min((double)i,ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c>=r){\n\t\t\t\tans=(double)(i+1);\n\t\t\t}else{\n\t\t\t\tdouble res=(double)(r)-sqrt((double)(r*r)-(double)(c*c));\n\t\t\t\tif(w){\n\t\t\t\t\tans=min((double)i+res,ans);\n\t\t\t\t}else{\n\t\t\t\t\tans+=res;\n\t\t\t\t\tw=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",min(ans,20.0));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,n){\n\t\tdouble l=-R,r;\n\t\tint ma=0;\n\t\tvi in(50,0);\n\t\twhile(n--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tma=max(ma,c);\n\t\t\tloop(i,a,b)in[i+25]=max(in[i+25],c);\n\t\t}\n\t\tr=ma-R;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tbool q=true;\n\t\t\tloop(i,1,50){\n\t\t\t\tdouble dis=hypot(min(in[i],in[i-1])-h,i-25);\n//\t\t\t\tcout<<i-25<<\" \"<<dis<<endl;\n\t\t\t\tif(min(in[i],in[i-1])<h||dis+EPS<(double)R)q=false;\n\t\t\t}\n\t\t\tif(q)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.8f\\n\",l+R);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int r; //半径\n        int max=0;  //高さの最大値\n        int n;\n        cin >> r >> n;\n        int r_min = 0 - r; //半径のマイナス\n        double t=20.0;\n        int x_i[n],x_j[n],h[n];\n        for(int i=0;i<n;i++){\n            cin >> x_i[i] >> x_j[i] >> h[i];\n            if(max<h[i])    max=h[i];\n        }\n        int a[max][r+r];\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<max;j++){\n                for(int l=-r;l<r;l++){\n                    if(x_i[i]<=l && x_j[i]>l){\n                        if(h[i]>=j){\n                            a[j-1][l+r]++;\n                        }\n                    }\n                }\n            }\n        }\n        int count=0;\n        double u=0.0;\n        int min=10;\n        int h_a,x_a;\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                if(a[i][j]==0){\n                    if(j<r){\n                        if(min>i+(r-1)-j){\n                            min=i+(r-1)-j;\n                            h_a=i;\n                            x_a=(r-1)-j;\n                        }\n                    }else{\n                        if(min>i+j-r){\n                            min=i+j-r;\n                            h_a=i;\n                            x_a=j-r;\n                        }\n                    }\n                }\n            }\n        }\n        t=(double)r-sqrt(r*r-x_a*x_a)+(double)h_a;\n        printf(\"%.4f\",t);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nmap<int, int> idx;\n\nvoid solve(int &r, int &n)\n{\n  int height[50];\n  fill(height, height + 50, 0);\n  rep(i, 0, n) {\n    int lx, rx, h; cin >> lx >> rx >> h;\n    rep(j, lx, rx) {\n      chmax(height[idx[j]], h);\n    }\n  }\n  double ok = 0., ng = 21.;\n  rep(cnt, 0, 50) {\n    double mid = (ok + ng) / 2;\n    auto check = [&](double mid) {\n      rep(i, -20, 20) {\n        double circle1 = (r * r <= i * i ? 0. : sqrt(r * r - i * i) - (r - mid));\n        double circle2 = (r * r <= (i + 1) * (i + 1) ? 0. : sqrt(r * r - (i + 1) * (i + 1)) - (r - mid));\n        double ch = max(circle1, circle2);\n        if (height[idx[i]] < ch) return false;\n      }\n      return true;\n    };\n    if (check(mid)) ok = mid;\n    else ng = mid;\n  }\n  cout << ok << endl;\n}\n\nint main()\n{\n  int r, n;\n  rep(i, -20, 21) {\n    idx[i] = i + 20;\n  }\n  while (cin >> r >> n)\n  {\n    if (r == 0 && n == 0) break;\n    solve(r, n);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nint n,r;\n\nint besth[50]={};\nint* bh = besth+25;\n\ndouble sh(double nr,double np){\n\tnp = abs(np);\n\treturn sqrt(nr*nr-np*np)-nr;\n}\n\nint main(void){\n\n\tfor(;;){\n\t\tscanf(\"%d%d\",&r,&n);\n\t\tif(r==0)break;\n\t\tmemset(besth,0,sizeof(besth));\n\t\trep(i,n){\n\t\t\tint xl,xr,h;\n\t\t\tscanf(\"%d%d%d\",&xl,&xr,&h);\n\t\t\treg(j,xl,xr-1){\n\t\t\t\tbh[j]=max(bh[j],h);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tdouble ans = 10000;\n\t\t\n\t\treg(i,-r,r-1){\n\t\t\tdouble nsh = sh(r,i>=0?i:abs(i)-1);\n\t\t\t//printf(\" %d .. %lf %d\\n\",i,nsh,bh[i]);\n\t\t\tans = min(ans,bh[i]-nsh);\n\t\t}\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nint main() {\n    while (true) {\n        int r, n; scanf(\"%d%d\", &r, &n);\n        if (r == 0 and n == 0) break;\n        vector<int> hl(2*r);\n        vector<int> hr(2*r);\n        repeat (i, n) {\n            int xl, xr, hi; scanf(\"%d%d%d\", &xl, &xr, &hi);\n            repeat_from (x, max(-r, xl), min(+r, xr)-1+1) setmax(hr[r  +x], hi);\n            repeat_from (x, max(-r, xl)+1, min(+r, xr)+1) setmax(hl[r-1+x], hi);\n        }\n        double t = INFINITY;\n        repeat_from (x, -r, +r+1) {\n            double y = sqrt(r*r - x*x);\n            if (x < +r) setmin(t, r - y + hr[r  +x]);\n            if (-r < x) setmin(t, r - y + hl[r-1+x]);\n        }\n        printf(\"%.8lf\\n\", t);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define SZ 20\n\nint mat[SZ+1][2*SZ+1];  //no-shade:0, shade:plus, mat[height][width+20]\n\nint main(){\n  int r,n;\n  while(scanf(\"%d %d\",&r,&n), r|n){\n    // initialize\n    rep(i,SZ+1){\n      rep(j,2*SZ+1){\n\tmat[i][j]=0;\n      }\n    }\n\n    // input provess for imosu\n    rep(i,n){\n      int xl, xr, h;\n      scanf(\"%d %d %d\", &xl, &xr, &h);\n      mat[0][xl+20]++;\n      mat[0][xr+20]--;\n      mat[h][xl+20]--;\n      mat[h][xr+20]++;\n    }\n    \n    // imosu\n    rep(i,SZ){\n      repl(j,1,2*SZ){\n\tmat[i][j] += mat[i][j-1];\n      }\n    }\n    rep(i,2*SZ){\n      repl(j,1,SZ){\n\tmat[j][i] += mat[j-1][i];\n      }\n    }\n\n    // debug\n    /*\n    rep(i,SZ){\n      rep(j,2*SZ){\n\tprintf(\"%d\", mat[SZ-i-1][j]);\n      }printf(\"\\n\");\n    }\n    */\n\n    // move sun from bottom\n    int t=0;\n    int w;\n    double res=INF;\n    while(t<20){\n      w=0; //width\n      while(w<r){\n\tif(mat[t][20+w]>0 && mat[t][19-w]>0){\n\t  w++;\n\t}else{\n\t  break;\n\t}\n      }\n      if(w==0){\n\tres=min(res, (double)t);\n\tbreak;\n      } else if(w==r){\n\tt++;\n\tcontinue;\n      } else {\n\tres = min(res, (double)(r+t) - sqrt(r*r-w*w));\n\tt++;\n      }\n    }\n\n    if(t==20){\n      printf(\"20.0000\\n\");\n      continue;\n    }\n\n    printf(\"%.4f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(4);\n  int cnt = 0;\n  while(1) {\n    cnt++;\n    int r, n; cin >> r >> n;\n    if(r == 0 && n == 0) break;\n    map<P, int> mp;\n    for(int i=0;i<n;++i) {\n      int x1, x2, h; cin >> x1 >> x2 >> h;\n      mp[{x1, 1}] = max(mp[{x1, 1}], h);\n      mp[{x2, -1}] = max(mp[{x2, -1}], h);\n      for(int j=x1+1;j<=x2-1;++j) {\n        mp[{j, 1}] = max(mp[{j, 1}], h);\n        mp[{j, -1}] = max(mp[{j, -1}], h);\n      }\n    }\n    double mi = INF;\n    for(int i = -r+1;i<r;++i) {\n      double tmp1 = mp[{i, -1}], tmp2 = mp[{i, 1}];\n      mi = min(mi, tmp1 + r - sqrt(r * r - i * i));\n      mi = min(mi, tmp2 + r - sqrt(r * r - i * i));\n    }\n    cout << mi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint main(){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, r){\n    vector<int> hl(50, 0), hr(50, 0);\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl + 1; j < xr; j++) {\n        hr[j + diff] = max(hr[j + diff], h);\n      }\n      for (int j = xl; j <= xr; j++) {\n        hl[j + diff] = max(hl[j + diff], h);\n      }\n    }\n    double ans = 1e9;\n    for (int i = -r + 1; i < r; ++i) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint main(){\n    int rad, n;\n    while(cin >> rad >> n, rad+n){\n        int height[40] = {};\n        for(int i = 0; i < n; i++){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            for(int j = xl; j < xr; j++){\n                height[20+j] = max(height[20+j], h);\n            }\n        }\n        double l = 0.0, r = 21;\n        for(int i = 0; i < 100; i++){\n            double mid = (l+r)/2;\n            bool safe = true;\n            for(int j = -rad; j < rad; j++){\n                safe &= height[20+j] >= mid-rad+sqrt(pow(rad,2.0)-pow(min(fabs(j),fabs(j+1)),2.0));\n            }\n            if(!safe)   r = mid;\n            else        l = mid;\n        }\n        cout << fixed << setprecision(12) << l << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-6\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(inct (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R-eps)return false;\n\tif(y<c-R+eps)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[geta])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint cnt = 0;\nbool solve(){\n\tcnt++;\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tif(cnt==48){\n\t\t//cerr << r << ' ' << n << endl;\n\t\t//cout << \"***************************\" << endl;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\t//if(cnt==48)cerr << l << ' ' << r << ' ' << hi << endl;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int vy[] = {-1, 1, 0, 0}, vx[] = {0, 0, 1, -1};\n\nint main()\n{\n  int R, N;\n  cout << fixed << setprecision(10);\n\n  while(cin >> R >> N, R) {\n    int left[44] = {}, right[44] = {};\n    while(N--) {\n      int l, r, h;\n      cin >> l >> r >> h;\n      l += 22, r += 22;\n      for(int j = l; j < r; j++) left[j] = max(left[j], h);\n      for(int j = r; j > l; j--) right[j] = max(right[j], h);\n    }\n    double ret = 1e9;\n    for(int i = -R + 1; i < R; i++) {\n      ret = min(ret, min(left[i + 22], right[i + 22]) + R - sqrt(R * R - i * i));\n    }\n    cout << ret << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n#define EPS 1e-7\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ndouble high[66];\nint n,r;\n\nbool check(double mid){\n\tfor(int i = 30-r;i < 30+r;i++){\n\t\tDBG(cerr << \"hidh \" << i << ' ' << high[i] << ' ' << high[i+1] << endl;)\n\t\tif(i != 30-r && i != 30+r && high[i] < mid)return false;\n\t\tdouble A = sqrt((i-30)*(i-30) + (high[i]-mid)*(high[i]-mid));\n\t\tdouble B = sqrt((i-29)*(i-29) + (high[i]-mid)*(high[i]-mid));\n\t\tDBG(cerr << \"AB \" <<  A << ' ' << B << endl;)\n\t\tif(min(A,B) < r + EPS)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> r >> n,r|n){\n\t\t//初期\n\t\tREP(i,66)high[i] = 0;\n\t\t\n\t\t\n\t\tREP(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tfor(int j = a;j < b;j++){\n\t\t\t\thigh[j+30] = max(high[j+30],c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble tb = 100;\n\t\tdouble ub = -100;\n\t\tDBG(SHOW1d(high,66));\n\t\tREP(i,1000){\n\t\t\tdouble mid = (tb + ub) / 2;\n\t\t\tDBG(cerr << endl << \"mid \" << mid << endl << endl;)\n\t\t\tif(check(mid))ub = mid;\n\t\t\telse tb = mid;\n\t\t}\n\t\t\n\t\tcout << Decimal << (double)(ub+r) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100;\nint HH[MAXN];\nint* H = HH+(MAXN/2);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int r, n;\n    while (cin >> r >> n) {\n        if (r == 0 && n == 0) break;\n        memset(HH, 0, sizeof(HH));\n        for (int i = 0; i < n; i++) {\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            for (int x = 2*xl; x < 2*xr; x++) {\n                H[x] = max(H[x], h);\n            }\n            if (xr == r) H[2*xr] = max(H[2*xr], h);\n            if (xl == -r) H[2*xl] = max(H[2*xl], h);\n        }\n        double ans = 1e9;\n        for (int x = -2*r; x <= 2*r; x++) {\n            if (x%2 == 0) {\n                int X = x/2;\n                double p = r-sqrt(r*r-X*X);\n                ans = min(ans, H[x]+p);\n            } else {\n                int X = (x+1)/2;\n                {\n                    double p = r-sqrt(r*r-X*X);\n                    ans = min(ans, p+H[x]);\n                }\n                X--;\n                {\n                    double p = r-sqrt(r*r-X*X);\n                    ans = min(ans, p+H[x]);\n                }\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[101],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=(-x-0.9999),R=(x+0.9999),hb[101]={};\n\n  for(int i=L+50;i<R+50;i++){\n    int x1=i-49-i/50;\n    double y1=y[i]-cy;\n    if(sqrt(x1*x1+y1*y1)>=r)hb[i]++;\n  }\n  for(int i=L+50;i<R+50;i++)if(!hb[i])return 0;\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<100;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+50]=max(y[j+50],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.001;\n    cout << ans-0.001<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,N,n) for(int i=N;i>=n;i++)\n#define CH(n,a,b) (a)<=(n)&&(n)<(b)\n#define p(s) cout<<s<<endl;\ntypedef long long ll;\nusing namespace std;\n\nbool grid[25][45];\n\nint main() {\n\tint n, r, lx, rx, h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0 && n == 0) break;\n\t\tREP(i,0,25)REP(j,0,45) grid[i][j] = 0;\n\t\tREP(ii,0,n){\n\t\t\tcin>>lx>>rx>>h;\n\t\t\tREP(k,lx+20,rx+20)REP(l,0,h)grid[l][k] = 1;\n\t\t}\n\t\tbool flag = false;\n\t\tREP(i,0,21){\n\t\t\tREP(w,0,r){\n\t\t\t\tif( (grid[i][-w+20-1] == 0) || (grid[i][w+20] == 0)){\n\t\t\t\t\tdouble ans = r - sqrt(r*r - w*w);\n\t\t\t\t\t//cout<<\"i: \"<<i<<\" w: \"<<w<<endl;\n\t\t\t\t\tif(w == 0) printf(\"%.6f\\n\", (double)i);\n\t\t\t\t\telse printf(\"%.6f\\n\", ans+i);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint r, n, sl, sr, h; int height[40]; double sunrise[40];\n\n\twhile (true)\n\t{\n\t\tcin >> r >> n;\n\n\t\tif (r == 0 && n == 0) { break; }\n\n\t\tfor (int i = 0; i < 40; i++) { height[i] = 0; sunrise[i] = -5000.0; }\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> sl >> sr >> h;\n\n\t\t\tfor (int j = sl; j < sr; j++)\n\t\t\t{\n\t\t\t\theight[j + 20] = max(h, height[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 20 - r; i < 20 + r; i++)\n\t\t{\n\t\t\tif (i < 20)\n\t\t\t{\n\t\t\t\tsunrise[i] = sqrt(r * r - (19 - i) * (19 - i)) - r;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsunrise[i] = sqrt(r * r - (i - 20) * (i - 20)) - r;\n\t\t\t}\n\t\t}\n\n\t\tdouble Answer = 10000.0;\n\n\t\tfor (int i = 0; i < 40; i++)\n\t\t{\n\t\t\tAnswer = min(height[i] - sunrise[i], Answer);\n\t\t}\n\t\t\n\t\tprintf(\"%.4f\\n\", Answer);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint n;\ndouble r;\nint t[100];\nvector<int> x,y;\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(r==0&&n==0)break;\n    for(int i=0;i<100;i++)t[i]=0;\n    for(int i=0;i<n;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a+=50,b+=50;\n      for(int j=a;j<b;j++)t[j]=max(t[j],c);\n    }\n    x.clear(),y.clear();\n    for(int i=0;i<50;i++){\n      x.push_back(50-i-1);\n      y.push_back(t[i]);\n    }\n    for(int i=50;i<100;i++){\n      x.push_back(i-50);\n      y.push_back(t[i]);\n    }\n    double ans=(1<<28);\n    for(int i=0;i<(int)x.size();i++){\n      if(r-0.00000001<x[i])continue;\n      double d=y[i]-sqrt(r*r-x[i]*x[i]);\n      ans=min(d,ans);\n    }\n    printf(\"%.8f\\n\",ans+r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#undef max\n#undef min\n\nbool field[41][22] = {false};\nbool field2[20][22] = { false };\nconstexpr int SUN_OFFSET_X = 20;\nint main() {\n\tint r, n;\n\twhile (std::cin >> r >> n && (r || n)) {\n\t\tstd::memset(field, false, sizeof(bool) * 41 * 22);\n\t\tstd::memset(field2, false, sizeof(bool) * 20 * 22);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x[2], h;\n\t\t\tstd::cin >> x[0] >> x[1] >> h;\n\t\t\tx[0] += SUN_OFFSET_X; x[1] += SUN_OFFSET_X;\n\t\t\t//?????§???????????¶???\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tfor (int k = x[0]; k < x[1]; k++) {\n\t\t\t\t\tfield[k][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstd::vector<double> circleHeights;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t//?°??????????????????????x?????????????????£????????????????????????????????¨??????????????????\n\t\t\tfor (int j = 0; j < 21; j++) {\n\t\t\t\tfield2[19 - i][j] = field[i][j] && field[39 - i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\t//?????????????????????x??§???y=0?????????????¢????\n\t\t\t//h^2 + i^2 = r^2 \n\t\t\t//h^2 = r^2 - i^2\n\t\t\tcircleHeights.push_back(-r + std::sqrt(r  * r - i * i));\n\t\t}\n\n\t\tstd::vector<double> heights;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tint h = 0;\n\t\t\tfor (h = 0; h < 21; h++) {\n\t\t\t\tif (!field2[i][h]) break;\n\t\t\t}\n\t\t\theights.push_back(h);\n\t\t}\n\n\t\t//???????£???£\n\t\tfor (int i = 0; i < heights.size(); i++) {\n\t\t\theights[i] -= circleHeights[i];\n\t\t}\n\n\t\t//????°??????¢???\n\t\tdouble min = 9999;\n\t\tfor (int i = 0; i < heights.size(); i++) {\n\t\t\tmin = std::min(min, heights[i]);\n\t\t}\n\t\tstd::cout << std::fixed << std::setprecision(4) << min << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint r,n;\nint a[50];\nmain()\n{\n\twhile(cin>>r>>n,r)\n\t{\n\t\tfor(int i=0;i<=40;i++)a[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint l,r,h;cin>>l>>r>>h;\n\t\t\tl+=20;r+=20;\n\t\t\tfor(int j=l;j<r;j++)a[j]=max(a[j],h);\n\t\t}\n\t\tdouble l=0,f=1e2;\n\t\tfor(int i=0;i<100;i++)\n\t\t{\n\t\t\tdouble m=(l+f)/2;\n\t\t\tbool flag=1;\n\t\t\tfor(int j=20;j>20-r;j--)\n\t\t\t{\n\t\t\t\tdouble h=sqrt(r*r-(20-j)*(20-j))+m-r;\n\t\t\t\tif(a[j-1]<h)\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=20;j<20+r;j++)\n\t\t\t{\n\t\t\t\tdouble h=sqrt(r*r-(j-20)*(j-20))+m-r;\n\t\t\t\tif(a[j]<h)\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)l=m;\n\t\t\telse f=m;\n\t\t}\n\t\tcout<<fixed<<setprecision(9)<<l<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\ndouble f(double r, double x, double y){\n    if(abs(x) >= r) return INF;\n    return r + y - sqrt(max(0.0, r*r - x*x));\n}\n\nint main(){\n    int r; int n;\n    while(scanf(\"%d%d\", &r, &n) && (r != 0 || n != 0)){\n        map<int, int> hl, hr;\n        rep(i, n){\n            int xl, xr, hi;\n            scanf(\"%d%d%d\", &xl, &xr, &hi);\n            For(x, xl, xr) chmax(hl[x], hi);\n            For(x, xl+1, xr+1) chmax(hr[x], hi);\n        }\n        double ans = INF;\n        For(x, -21, 22){\n            if(x > -r) chmin(ans, f(r, x, hl[x]));\n            if(x < r) chmin(ans, f(r, x, hr[x]));\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\n/* Find the maximum x∈[low, up) such that f(x) is true\n    ---*     (true)\n        ---- (false)\n*/\ntemplate<int precision = 100, typename F> double binarySearchD(double low, const double up, const F &f) {\n  double d = up - low;\n  rep(i, precision) {\n    d /= 2.0;\n    if (f(low + d)) low += d;\n  }\n  return low;\n}\n\nmain {\n  while (true) {\n    int r, n;\n    cin >> r >> n;\n    if (r == 0 && n == 0) break;\n    vector<double> h(100);\n    while (n--) {\n      int a, b, q;\n      cin >> a >> b >> q;\n      a += 30, b += 30;\n      loop(i, a, b) cmax(h[i], q);\n    }\n    cout << prec(32) << binarySearchD(0.0, 20.0, [&](double t) {\n      for (int x = 31 - r; x < 30 + r; x++) {\n        double y = sqrt(r * r - (x - 30) * (x - 30));\n        if (min(h[x - 1], h[x]) < y + t - r) return false;\n      }\n      return true;\n    }) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  double r;\n  int n;\n  double ans;\n  double left,right,h;\n\n  while(1){\n    cin >> r >> n;\n    if(r==0) break;\n    ans=21;\n    vector<double> takasahidari(41,0),takasamigi(41,0);\n    for(int i=0;i<n;i++){\n      cin >> left >> right >> h;\n      for(int j=left;j<right;j++){\n        takasahidari[j+20]=max(takasahidari[j+20],h);\n      }\n      for(int j=left+1;j<=right;j++){\n        takasamigi[j+20]=max(takasamigi[j+20],h);\n      }\n    }\n    /*\n    for(int i=0;i<41;i++){\n      cout << takasahidari[i] << \" \";\n    }\n    cout << endl;\n    for(int i=0;i<41;i++){\n      cout << takasamigi[i] << \" \";\n    }\n    cout << endl;\n    */\n    for(int i=20-r;i<=20+r;i++){\n      /*\n      if(ans>min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20))){\n        cout << \"(\" << i-20 << \",\" << min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)) << \")\" << endl;\n      }\n      */\n      if(takasahidari[i]>0&&takasamigi[i]>0){\n        ans=min(ans,min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)));\n      }\n\n\n\n    }\n    if(ans==21){\n      ans=0;\n    }\n    cout << fixed<<setprecision(6)<<ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define EPS 1e-9\n\nclass biru{\npublic:\n  double xl;\n  double xr;\n  double h;\n  biru(double a, double b, double c) {\n    xl = a;\n    xr = b;\n    h = c;\n  }\n};\n\ndouble r;\nbool crossCheck(double xc, double yc, double x1, double y1, double x2, double y2) {\n  return (hypot(xc-x1, yc-y1)-r < EPS ||\n\t  hypot(xc-x2, yc-y2)-r < EPS ||\n\t  (fabs((y2-y1)*xc+(x1-x2)*yc+(x2*y1-x1*y2))/hypot(x1-x2, y2-y1)-r < EPS &&\n\t   ((fabs(x1-x2) > EPS && (x1 <= xc && xc <= x2 || x2 <= xc && xc <= x1)) ||\n\t    (fabs(y1-y2) > EPS && (y1 <= yc && yc <= y2 || y2 <= yc && yc <= y1)) )));\n}\n\nbool compare(const biru a, const biru b) {\n  return a.xl < b.xl;\n}\n\nint main() {\n  int tr, n;\n  while (cin >> tr >> n) {\n    if (tr == 0 && n == 0) break;\n    r = (double)tr-0.00001;\n    bool field[41][21];\n    memset(field, false, sizeof(field));\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n      for (int j = 0; j < h; j++) {\n\tfor (int k = xl; k < xr; k++) {\n\t  field[k+20][j] = true;\n\t}\n      }\n    }\n    // for (int i = 0; i < 10; i++) {\n    //   for (int j = 15; j < 25; j++) {\n    // \tstd::cout << field[j][i];\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n    vector <biru> mbiru;\n    for (int i = 0; i < 41; i++) {\n      if (field[i][0]) {\n\tint h;\n\tfor (int j = 0; field[i][j]; j++) {\n\t  h = j+1;\n\t}\n\tmbiru.push_back(biru(i-20, i-20+1, h));\n      }\n    }\n    // for (int i = 0; i < mbiru.size(); i++) {\n    //   std::cout << mbiru[i].xl << \" \" << mbiru[i].xr << \" \" << mbiru[i].h << std::endl;\n    // }\n\n    \n    double p;\n    for (int i = 0; i < 400000; i++) {\n      p = -r+double(i)/10000.;\n      bool ok = true;\n      if (-r < mbiru[0].xl) {\n\tok = !crossCheck(0, p, -r, 0, mbiru[0].xl, 0);\n      }\n      if (crossCheck(0, p, mbiru[0].xl, 0, mbiru[0].xl, mbiru[0].h)) ok = false;\n      if (crossCheck(0, p, mbiru[0].xl, mbiru[0].h, mbiru[0].xr, mbiru[0].h)) ok = false;\n      if (mbiru.size() >= 2) {\n\tif (fabs(mbiru[0].xr-mbiru[1].xl) < EPS) {\n\t  ok = !crossCheck(0, p, mbiru[0].xr, mbiru[0].h, mbiru[0].xr, mbiru[1].h);\n\t}else {\n\t  ok = !crossCheck(0, p, mbiru[0].xr, mbiru[0].h, mbiru[0].xr, 0);\n\t}\n      }\n      for (int j = 1; j < mbiru.size(); j++) {\n\tif (fabs(mbiru[j].xl-mbiru[j-1].xr) < EPS) {\n\t  if (crossCheck(0, p, mbiru[j].xl, mbiru[j].h, mbiru[j].xl, mbiru[j-1].h)) {\n\t    ok = false;\n\t  }\n\n\t}else {\n\t  if (crossCheck(0, p, mbiru[j-1].xr, 0, mbiru[j].xl, 0) ||\n\t      crossCheck(0, p, mbiru[j].xl, 0, mbiru[j].xl, mbiru[j].h)) {\n\t    ok = false;\n\t  }\n\t}\n\tif (crossCheck(0, p, mbiru[j].xl, mbiru[j].h, mbiru[j].xr, mbiru[j].h)) {\n\t  ok = false;\n\t}\n\tif (j+1 < mbiru.size()) {\n\t  if (fabs(mbiru[j].xr-mbiru[j+1].xl) > EPS) {\n\t    if (crossCheck(0, p, mbiru[j].xr, mbiru[j].h, mbiru[j].xr, 0)) {\n\t      ok = false;\n\t    }\n\t  }\n\t}else {\n\t  if (crossCheck(0, p, mbiru[j].xr, mbiru[j].h, mbiru[j].xr, 0)) {\n\t    ok = false;\n\t  }\n\t}\n\tif (!ok) break;\n      }\n      if (crossCheck(0, p, mbiru[mbiru.size()-1].xr, 0, 1000, 0)) {\n\tok = false;\n      }\n      if (!ok) {\n\tbreak;\n      }\n    }\n    printf(\"%lf\\n\", p+r);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define DBG 0\nvoid solve(int R, int N) {\n\n\tvector<int>xl(N), xr(N), h(N);\n\trep(i, 0, N) {\n\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t}\n\n\tconst int offset = 25;\n\tvector<vector<int>>field(2 * offset, vector<int>(2 * offset));\n\trep(i, 0, N) {\n\t\trep(x, xl[i], xr[i]) {\n\t\t\trep(y, 0, h[i]) {\n\t\t\t\tfield[y][x + offset] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (DBG) {\n\t\tfor (int y = field.size() - 1; y >= 0; y--) {\n\t\t\trep(x, 0, field[y].size()) {\n\t\t\t\tcout << field[y][x];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tauto f = [&](double t) {\n\t\tauto g = [&](int x, int y) {\n\t\t\tdouble d = (x) * (x) + (t - y) * (t - y);\n\t\t\treturn d < R * R;\n\t\t};\n\t\tint dx[] = { 0,1,1,0 }, dy[] = { 0,0,1,1 };\n\t\tbool ret = true;\n\t\trep(i, 0, field.size()) {\n\t\t\trep(j, 0, field[i].size()) {\n\t\t\t\tif (field[i][j] == 1)continue;\n\t\t\t\tint x = j - offset;\n\t\t\t\tint y = i;\n\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif (g(nx, ny)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tif (DBG) {\n\t\tcout << \"f(-R) = \" << f(-R) << endl;\n\t\tcout << \"f(1000) = \" << f(1000) << endl;\n\t}\n\tdouble l = -R, r = 20;\n\tfor (int loop = 0; loop < 100; loop++) {\n\t\tdouble m = (l + r) / 2;\n\t\tif (f(m)) {\n\t\t\tl = m;\n\t\t}\n\t\telse {\n\t\t\tr = m;\n\t\t}\n\t}\n\tcout << l+R << endl;\n\n}\n\nsigned main(int argc, char* argv[]) {\n\tint R, N;\n\twhile (cin >> R >> N, R or N) {\n\t\tsolve(R, N);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    double r;\n    int n;\n    while (cin >> r >> n && r){\n        map<int, double> hl, hr;\n        while (n--){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            hr[xl] = fmax(hr[xl], h);\n            hl[xr] = fmax(hl[xr], h);\n            FOR(i,xl+1,xr-1){\n                hl[i] = fmax(hl[i], h);\n                hr[i] = fmax(hr[i], h);\n            }\n        }\n\n        double ans = fmin(hr[-r], hl[r]) + r;\n        FOR(i,-r+1,r-1){\n            double h = fmin(hl[i], hr[i]);\n            double y = r - sqrt(r*r-i*i);\n            ans = fmin(ans, y+h);\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    double r;\n    int n;\n    while (cin >> r >> n && n){\n        map<int, double> hl, hr;\n        while (n--){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            hr[xl] = fmax(hr[xl], h);\n            hl[xr] = fmax(hl[xr], h);\n            FOR(i,xl+1,xr-1){\n                hl[i] = fmax(hl[i], h);\n                hr[i] = fmax(hr[i], h);\n            }\n        }\n\n        double ans = 20.0;\n        FOR(i,-r,r){\n            double h = fmin(hl[i], hr[i]);\n            double y = r - sqrt(r*r-i*i);\n            ans = fmin(ans, y+h);\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint main(){\n\tint n, r;\n\tint X[41], L[41], R[41];//X[i] = i - 20\n\tint x_l, x_r, h;\n\tdouble t;\n\t\n\twhile(true){\n\t\tscanf(\"%d%d\", &r, &n);\n\t\tif(r == 0 && n == 0) break;\n\t\tfor(int i = -20; i < 20; i++){\n\t\t\tL[i + 20] = 0; R[i + 20] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d%d\", &x_l, &x_r, &h);\n\t\t\tfor(int i = x_l + 1; i <= x_r; i++){\n\t\t\t\tL[i + 20] = max(L[i + 20], h);\n\t\t\t}\n\t\t\tfor(int i = x_l; i < x_r; i++){\n\t\t\t\tR[i + 20] = max(R[i + 20], h);\n\t\t\t}\n\t\t}\n\t\t\n\t\tX[-r + 20] = R[-r + 20]; X[r + 20] = L[r + 20];\n\t\tfor(int i = -r + 1; i < r; i++){\n\t\t\tX[i + 20] = min(L[i + 20], R[i + 20]);\n\t\t}\n\t\tt = 100;\n\t\tfor(int i = -r; i <= r; i++){\n\t\t\tt = min(t, X[i + 20] + r - sqrt((r + i) * (r - i)));\n\t\t}\n\t\tprintf(\"%lf\\n\", t);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint main(){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, r){\n    vector<int> hl(50, 0), hr(50, 0);\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl + 1; j < xr; j++) {\n        hr[j + diff] = max(hr[j + diff], h);\n      }\n      for (int j = xl; j <= xr; j++) {\n        hl[j + diff] = max(hl[j + diff], h);\n      }\n    }\n    double ans = 1e9;\n    for (int i = -r + 1; i < r; ++i) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n//struct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this); \n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::on_segment;\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nReal instersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto dist = distance_lp(l, c);\n  if(dist > c.r + EPS) { return {{-inf,-inf},{-inf,-inf}}; }\n  auto basehalf = sqrt(c.r * c.r - dist * dist);\n  P v = (l[1]-l[0]) * P(0, 1);\n  Line h(c, c+v); P ph = crosspoint(l, h);\n  P u1 = (ph + v) * P(0, 1); u1 /= abs(u1); u1 *= basehalf;\n  P u2 = (ph + v) * P(0, -1); u2 /= abs(u2); u2 *= basehalf;\n  return {u1, u2};\n}\n\n// ??????clang??§????????°???\"(x, y)\"?????¢?????????????????????????????????\"x y\"????????´??????\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nint main() {\n\n  for(int R, N; cin >> R >> N && (R | N);) {\n    vector<int> hs(44); int const OF = 22;\n    rep(i, N) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      REP(x, xl, xr) {\n        maximize(hs[x+OF], h);\n      }\n    }\n    vector<P> events;\n    int currh = 0;\n    events.emplace_back(-22, 0);\n    REP(x, -21, 22) {\n      if(currh != hs[x+OF]) {\n        events.emplace_back(x, currh);\n        currh = hs[x+OF];\n        events.emplace_back(x, currh);\n      }\n      else {\n        events.emplace_back(x, currh);\n      }\n    }\n\n//    for(auto && e: events) { cout << e << endl; } cout << endl;\n\n    Circle c(P(0, -R), R);\n\n    for(double t=0; t<=20; t+=0.00001) {\n      bool ok = 0;\n      rep(i, events.size()) {\n        if(abs(c - events[i]) < c.r - EPS) {\n          printf(\"%.10f\\n\", t);\n          ok = 1;\n          break;\n        }\n      }\n      if(ok) { break; }\n      c.cent[1] += 0.00001;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n#define EPS 1e-7\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ndouble high[66];\nint n,r;\n\nbool check(double mid){\n\tfor(int i = 30-r;i < 30+r;i++){\n\t\tDBG(cerr << \"hidh \" << i << ' ' << high[i] << ' ' << high[i+1] << endl;)\n\t\tif(i != 30-r && i != 30+r && high[i] < mid)return false;\n\t\tdouble A = sqrt((i-30)*(i-30) + (high[i]-mid)*(high[i]-mid));\n\t\tdouble B = sqrt((i-29)*(i-29) + (high[i]-mid)*(high[i]-mid));\n\t\tDBG(cerr << \"AB \" <<  A << ' ' << B << endl;)\n\t\tif(min(A,B) < r + EPS)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> r >> n,r|n){\n\t\t//初期\n\t\tREP(i,66)high[i] = 0;\n\t\t\n\t\t\n\t\tREP(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tfor(int j = a;j < b;j++){\n\t\t\t\thigh[j+30] = max(high[j+30],c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble tb = 100;\n\t\tdouble ub = -10;\n\t\tDBG(SHOW1d(high,66));\n\t\tREP(i,1000){\n\t\t\tdouble mid = (tb + ub) / 2;\n\t\t\tDBG(cerr << endl << \"mid \" << mid << endl << endl;)\n\t\t\tif(check(mid))ub = mid;\n\t\t\telse tb = mid;\n\t\t}\n\t\t\n\t\tcout << Decimal << (double)(ub+r) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()????????????, Polygon?????????????????°\n#include<algorithm> // min(), sort(), reverse()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)??§3???a, b, p???????????¢????????????\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-?????????p, -1: -a-b-?????????p\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    const Point normalize() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n    void print() const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Line&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n    void print() const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    explicit Polygon(std::vector<Point> p) :point(p) {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool intersect(const Polygon&) const;\n    bool on_edge(const Point&) const;\n    const Polygon convex_hull() const;\n    void print() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nvoid Point::print() const {std::cout << x() << \", \" << y() << std::endl;}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Segment::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Line::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Line& l) const {return center().distance(l) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\nvoid Circle::print() const {std::cout << \"radius: \" << r() << \" - point: \"; center().print();}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::intersect(const Polygon& p) const {\n    for(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\n    return false;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\n    Polygon result;\n    std::vector<Point> res;\n    std::vector<Point> original = vertex();\n    sort(original.begin(), original.end());\n    original.insert(original.end(), original.rbegin() + 1, original.rend());\n    for(const auto& v: original) {\n        while(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\n        res.push_back(v);\n    }\n    res.pop_back();\n    for(const auto& v: res) result.add(v);\n    return result;\n}\nvoid Polygon::print() const {for(const auto& v: vertex()) std::cout << v.x() << \", \" << v.y() << std::endl;}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n\nbool check(const Polygon& polygon, const Circle& Sun) {\n    if(polygon.include(Sun.center())) {\n        for(const auto& e: polygon.edge()) if(Sun.center().distance(e) < Sun.r()) return false;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    int n, r;\n    while(cin >> r >> n, r | n) {\n        vector<double> height(81, 0.0);\n        for(int i = 0; i < n; ++i) {\n            int x1, x2;\n            double y;\n            cin >> x1 >> x2 >> y;\n            x1 += 20; x2 += 20;\n            for(int i = 2 * x1; i < 2 * x2; ++i) height[i] = max(height[i], y);\n        }\n\n        vector<Point> vertex;\n        vertex.push_back(Point(50.0, 0.0));\n        vertex.push_back(Point(50.0, -50.0));\n        vertex.push_back(Point(-50.0, -50.0));\n        vertex.push_back(Point(-50.0, 0.0));\n        double last = 0.0;\n        for(int i = 0; i < 81; ++i) {\n            double x = i / 2.0 - 20.0;\n            if(height[i] == last) continue;\n            vertex.push_back(Point(x, last));\n            vertex.push_back(Point(x, height[i]));\n            last = height[i];\n        }\n        vertex.push_back(Point(20.0, height[80]));\n\n        double low, middle, high;\n        low = -r;\n        high = 50.0;\n        while(fabs(high - low) > EPS) {\n            middle = (low + high) / 2.0;\n            if(check(Polygon(vertex), Circle(0.0, -r + middle, r))) low = middle;\n            else high = middle;\n        }\n\n        cout << setprecision(4) << fixed << high << endl;\n//         cout << setprecision(4) << low + EPS << high << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(double r,int n){\n  double hl[100]={};\n  double hr[100]={};\n  double h[100]={};\n  double b = 20;\n  double ans = 30.0;\n  rep(i,n){\n    int x,y;\n    double z;\n    cin>>x>>y>>z;\n    x+=b; y+=b;\n    FOR(j,x+1,y){\n      hl[j]=z;\n      hr[j]=z;\n    }\n    hr[x]=z;\n    hl[y]=z;\n  }\n  FOR(i,b-r,b+r+1){\n    h[i] = min(hl[i],hr[i]);\n    if(i==b-r&&hr[i]>hl[i]) h[i] = hr[i];\n    if(i==b+r&&hr[i]<hl[i]) h[i] = hl[i];\n  }\n\n  double i =b-r;\n\n  while(i<b+r+1){\n    double x = r+h[(int)i]-sqrt(r*r-(i-b)*(i-b));\n    ans = min(ans,x);\n\n    i +=1.0;\n  }\n\n  printf(\"%lf\\n\",ans);\n}\n\n\n\nint main(){\n  double r,n;\n  while(1){\n    cin>>r>>n;\n    if(r==0) break;\n    f(r,n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int r, n;\n    while(cin >> r >> n, r != 0){\n        vector<int> maxHigh(40, 0);\n\n        REP(i, n){\n            int x, y, z;\n            cin >> x >> y >> z;\n            REP(j, y-x) maxHigh[20+x+j] = max(z, maxHigh[20+x+j]);\n        }\n\n        double ans = 20;\n        for(int i = -r+1; i <= r-1; i++){\n            int high = min(maxHigh[19+i], maxHigh[20+i]);\n            double t = high + r - sqrt(r*r -i*i);\n            ans = min(t, ans);\n        }\n\n        printf(\"%.9f\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\nbool box[21][41];\nvoid solve(int r,int n){\n  rep(y,21) rep(x,41) box[y][x]=false;\n  rep(i,n) {\n    int li,ri,hi;\n    cin >> li >> ri >> hi;\n\n    for(int y=0;y<hi;++y) {\n      for(int x=li+20;x<ri+20;++x){\n        box[y][x]=true;\n      }\n    }\n  }\n  auto ans=numeric_limits<double>::max();\n  rep(y,21){\n    for(int x=20-r;x<r+20;x++) {\n      if(!box[y][x]){\n        double time;\n        if(x<20) time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n        else time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n        ans=min(ans,time);\n      }\n    }\n  }\n  printf(\"%.4lf\\n\",ans);\n}\n\nint main()\n{\n  int r,n;\n  while(cin>>r>>n, n&&r){\n    solve(r,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <map>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\ndouble d = 0.00001;\nint build[25][3];\n\nint main(){\n    int r,n;\n    while(true){\n        cin >> r >> n;\n        if(r + n == 0)break;\n        double ans = 100.0;\n        for(int i = 0;i < n;i++){ // cin\n            for(int j = 0;j < 3;j++){\n                cin >> build[i][j];\n            }\n        }\n        for(int x = -r+1;x <= r;x++){\n            int hmax = 0;\n            for(int i = 0;i < n;i++){\n                if(build[i][0] < x && x <= build[i][1]) hmax = max(hmax,build[i][2]);\n            }\n       //     cout << \"x:\" << x << \", hmax:\" << hmax << endl;\n            double a = -30.0,b = (double)hmax,xx;\n            if(x <= 0){\n                xx = (double) x;\n            }else{\n                xx = (double) (x-1);\n            }\n            while(b - a > d){\n                double half = (a + b) / 2.0;\n                if( (double)r*r > ((double)hmax - half)*((double)hmax - half) + xx*xx){\n                    b = half;\n                }else{\n                    a = half;\n                }\n            }\n            if(ans > a + (double)r) ans = a + (double)r;\n        }\n        cout << round(ans*10000)/10000 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1194\n//\n//  Created by 13B15237 on 2015/06/22.\n//  Copyright (c) 2015??´ 13B15237. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Rect {\n    int l, r;\n    int h;\n};\n\nstruct Point {\n    int x, y;\n};\n\nstruct Area {\n    bool table[21][41];\n    \n    void clear() {\n        for (int y = 0; y < 21; ++y) {\n            for (int x = -20; x < 21; ++x) {\n                table[y][x+20] = false;\n            }\n        }\n    }\n    \n    void draw(Rect rect) {\n        for (int y = 0; y < rect.h; ++y) {\n            for (int x = rect.l; x < rect.r; ++x) {\n                table[y][x + 20] = true;\n            }\n        }\n    }\n    \n    void show() {\n        for (int y = 20; y >= 0; --y) {\n            for (int x = -20; x < 21; ++x) {\n                cout << (table[y][x+20] == true ? '#' : '_');\n            }\n            cout << endl;\n        }\n    }\n    \n    bool test(int r, int t) {\n        const int ybegin = max(0, t - 2 * r);\n        const int yend = t;\n        \n        for (int y = ybegin; y < yend; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == false) return false;\n            }\n        }\n        return true;\n    }\n    \n    Point calcMinDistPoint(int r, int maxt) {\n        double mindist = 30.0;\n        Point p = {0, 0};\n        \n        for (int y = max(0, maxt - 2 * r); y < maxt; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == true) continue;\n                \n                const int a = x < 0 ? abs(x + 1) : x;\n                const int b = y;\n                double dist = sqrt(a*a + b*b);\n                //printf(\"(%d, %d) = %f\\n\", x,y,dist);\n                \n                if (dist < mindist) {\n                    mindist = dist;\n                    p.x = x;\n                    p.y = y;\n                }\n            }\n        }\n        return p;\n    }\n};\n\nint R, N;\nvector<Rect> vrect;\nArea area;\n\nint main(int argc, const char * argv[]) {\n    while (1) {\n        cin >> R >> N;\n        if (!R && !N) break;\n        \n        area.clear();\n        vrect.clear();\n        vrect.resize(N);\n        for (auto r : vrect) {\n            cin >> r.l >> r.r >> r.h;\n            area.draw(r);\n        }\n        \n        int t;\n        for (t = 0; t < 21; ++t) {\n            if (area.test(R, t) == false) break;\n        }\n        \n        Point p = area.calcMinDistPoint(R, t);\n        const int dx = p.x < 0 ? abs(p.x + 1) : abs(p.x);\n        const double dy = sqrt(R * R - dx * dx);\n        \n        double ans = (double)(R) + ((double)p.y - dy);\n        \n        printf(\"%.4f\\n\", ans);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n  \nint s[21][41];\nint main(void){\n    int r, n, xl, xr, h;\n    while(cin >> r >> n && r) {\n        rep(i, 21) rep(j, 41) s[i][j] = 0;\n        rep(i, n) {\n            cin >> xl >> xr >> h;\n            for(int y=0; y<h; ++y) {\n                for(int x=xl+20; x<xr+20; ++x) {\n                    s[y][x] = 1;\n                }\n            }\n        }\n        double mint = numeric_limits<double>::max();\n        rep(y, 21) {\n            for(int x=-r+20; x<r+20; ++x) {\n                if(s[y][x] == 0) {\n                    double t;\n                    if(x<20) t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n                    else t = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n                    mint = min(mint, t);\n                }\n            }\n        }\n        printf(\"%.4lf\\n\", mint);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tint n;\n\tdouble r;\n\twhile(cin>>r>>n,r||n){\n\t\tdouble h[50]={0};\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta+=25;b+=25;\n\t\t\tfor(int i=a;i<b;i++)h[i]=max(h[i],c);\n\t\t}\n\t\t//loop(i,20,30)cout<<\" \"<<h[i];\n\t\t//cout<<endl;\n\t\tdouble t=0;\n\t\twhile(1){\n\t\t\tt+=0.001;\n\t\t\tbool ans=true;\n\t\t\trep(i,49){\n\t\t\t\tif(hypot((double)(i-25),r+h[i]-t)<r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(hypot((double)(i-24),r+h[i]-t)<r){\n\t\t\t\t\tans=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ans)break;\n\t\t}\n\t\tcout<<t-0.001<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1194\n//\n//  Created by 13B15237 on 2015/06/22.\n//  Copyright (c) 2015??´ 13B15237. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Rect {\n    int l, r;\n    int h;\n};\n\nstruct Point {\n    int x, y;\n};\n\nstruct Area {\n    bool table[21][41];\n    \n    void clear() {\n        for (int y = 0; y < 21; ++y) {\n            for (int x = -20; x < 21; ++x) {\n                table[y][x+20] = false;\n            }\n        }\n    }\n    \n    void draw(Rect rect) {\n        for (int y = 0; y < rect.h; ++y) {\n            for (int x = rect.l; x < rect.r; ++x) {\n                table[y][x + 20] = true;\n            }\n        }\n    }\n    \n    void show() {\n        for (int y = 20; y >= 0; --y) {\n            for (int x = -20; x < 21; ++x) {\n                cout << (table[y][x+20] == true ? '#' : '_');\n            }\n            cout << endl;\n        }\n    }\n    \n    bool test(int r, int t) {\n        const int ybegin = max(0, t - 2 * r);\n        const int yend = t;\n        \n        for (int y = ybegin; y < yend; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == false) return false;\n            }\n        }\n        return true;\n    }\n    \n    Point calcMinDistPoint(int r, int maxt) {\n        double mindist = 30.0;\n        Point p = {0, 0};\n        \n        for (int y = max(0, maxt - 2 * r); y < maxt; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == true) continue;\n                \n                const int a = x < 0 ? abs(x + 1) : x;\n                const int b = y;\n                double dist = sqrt(a*a + b*b);\n                //printf(\"(%d, %d) = %f\\n\", x,y,dist);\n                \n                if (dist < mindist) {\n                    mindist = dist;\n                    p.x = x;\n                    p.y = y;\n                }\n            }\n        }\n        return p;\n    }\n};\n\nint R, N;\nvector<Rect> vrect;\nArea area;\n\nint main(int argc, const char * argv[]) {\n    while (1) {\n        cin >> R >> N;\n        if (!R && !N) break;\n        \n        area.clear();\n        vrect.clear();\n        vrect.resize(N);\n        for (auto r : vrect) {\n            cin >> r.l >> r.r >> r.h;\n            area.draw(r);\n        }\n        \n        //area.show();\n        \n        int tmax;\n        for (tmax = 0; tmax < 21; ++tmax) {\n            if (area.test(R, tmax) == false) break;\n        }\n        \n        /*\n        double t = static_cast<double>(tmax - 1);\n        while (1) {\n            double d = area.calcMinDist(R, t, tmax);\n            if (d < static_cast<double>(R)) break;\n            t += 0.001;\n        }\n         */\n        Point p = area.calcMinDistPoint(R, tmax);\n        const int dx = p.x < 0 ? abs(p.x + 1) : abs(p.x);\n        double dy = sqrt(R * R - dx * dx);\n        \n        \n        //cout << \"p = (\" << p.x << \", \" << p.y << \")\" << endl\n        //<< \"dy = \" << dy << \", R  = \" << R << endl;\n        \n        double t;\n        if (dy < (double)R) {\n            t = (double)(p.y) - dy;\n            t += ((double)tmax - 1.0);\n        } else {\n            t = (double)p.y;\n        }\n        \n        printf(\"%.4f\\n\", t);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<30;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nint main () {\n    int r, n;\n    while (cin >> r >> n, r + n) {\n        int base = 20;\n        vector<int> v(base * 3, 0);\n        REP (i, 0, n) {\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            REP (t, xl, xr) v[t + base] = max(v[t + base], h);\n        }\n\n        double le = -r, ri = 100;\n        double eps = 1e-9;\n        while (abs(le - ri) > eps) {\n            double mid = (le + ri) / 2;\n            bool check = true;\n            REP (i, 0, v.size()) {\n                int t = i - base;\n                if (r * r > t * t) {\n                    double y = mid + sqrt(r * r - t * t);\n                    if (y > v[i]) check = false;\n                }\n                t++;\n                if (r * r > t * t) {\n                    double y = mid + sqrt(r * r - t * t);\n                    if (y > v[i]) check = false;\n                }\n            }\n            if (check) {\n                le = mid;\n            } else {\n                ri = mid;\n            }\n        }\n        cout << fixed << setprecision(10) << (le + ri) / 2 + r << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, r;\n\twhile (cin >>r>>n, r) {\n\t\tmap<int, int> v;\n\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t\n\t\t\tFOR(j, a, b)v[j] = max(v[j], c);\n\t\t}\n\t\tFOR(i, -20, -r)v[i] = INF;\n\t\tFOR(i, r, 20)v[i] = INF;\n\t\tif (n==0) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\t\n\t\telse {\n\t\t\tdouble u = 21, l = -1;\n\t\t\twhile (u - l > EPS) {\n\t\t\t\tint flag = 1;\n\t\t\t\tdouble mid = (u + l) / 2;\n\t\t\t\tFOR(i, -20, 20) {\n\t\t\t\t\tint d = i;\n\t\t\t\t\tif (i < 0)d++;\n\t\t\t\t\tif (abs(i) > r)continue;\n\t\t\t\t\tdouble c = sqrt(r*r - d*d);\n\t\t\t\t\tif (c + mid > v[i]+r)flag = 0;\n\t\t\t\t}\n\t\t\t\tif (flag)l = mid;\n\t\t\t\telse u = mid;\n\t\t\t}\n\t\t\tcout << fixed << setprecision(4) << l << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <math.h>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt((double)r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD=1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n      int r,n;cin>>r>>n;\n      if(r==0) break;\n      VVI v(30,vector<int>(50,0));\n      for(int i=0;i<n;i++){\n          int xl,xr,h;cin>>xl>>xr>>h;\n          if(h==0) continue;\n          for(int j=0;j<h;j++){\n             v[j][xl+20]++;v[j][xr+20]--;\n          }\n      }\n      for(int i=0;i<20;i++)for(int j=1;j<40;j++){\n          v[i][j]+=v[i][j-1];\n          //cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<endl;\n      }\n      vector<P> build(30,P(20,20));\n      for(int i=0;i<20;i++){\n          int l=20,r=20;\n          for(int j=0;j<19;j++){\n              if(v[i][20+j]&&v[i][20-j-1]){\n                l=20-j-1;r=20+j;\n              }\n              else break;\n          }\n          build[i]=P(l,r);\n      }\n      //for(int i=0;i<5;i++) cout<<build[i].first<<\" \"<<build[i].second<<endl;\n      for(double i=0;i<=20;i+=0.0005){\n          int h=floor(i);\n          int l=build[h].first,ri=build[h].second;\n          if(l==ri){\n              cout<<i<<endl;\n              break;\n          }\n          //cout<<i<<\" \"<<l-20<<\" \"<<-sqrt(2*r*i-i*i)<<endl;\n          bool flag=true;\n          for(int j=0;j<=h;j++){\n              if(build[j].first-20<=-sqrt(2*r*(i-j)-(i-j)*(i-j))) continue;\n              else flag=false;\n          }\n          if(flag) continue;\n          //if(l-20<=-sqrt(2*r*i-i*i)) continue;\n          cout<<i<<endl;\n          break;\n      }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(int r,int n){\n  double tmp[60] = {};\n  double *height = tmp + 30;\n  for(int i = 0;i < n;++i){\n    int xl,xr;\n    double h;\n    cin >> xl >> xr >> h;\n    for(int i = xl;i <xr;++i){\n      height[i] = max(height[i],h);\n    }\n  }\n  double res = 100.0;\n  for(int i = 0;i < r;++i){\n    res = min(res, height[i] - sqrt(r*r - i*i) + r);\n  }\n  for(int i = 0;i > -r;--i){\n    res = min(res, height[i-1] - sqrt(r*r - i*i) + r);\n  }\n  cout << setprecision(15) << res << endl;\n}\n\nint main(void){\n  int r,n;\n  while(cin >> r >> n,\n\t!(r == 0 && n == 0)){\n    solve(r,n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint main(){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, r){\n    vector<int> hl(50, 0), hr(50, 0);\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl; j < xr; j++) {\n        hr[j + diff] = max(hr[j + diff], h);\n      }\n      for (int j = xl + 1; j <= xr; j++) {\n        hl[j + diff] = max(hl[j + diff], h);\n      }\n    }\n    double ans = 1e9;\n    for (int i = -r + 1; i < r; ++i) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>=R)return false;\n\tif(x<=-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>=c+R)return false;\n\tif(y<=c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tlong double radius;\n\tvector<long double>ans;\n\tcout<<setprecision(20);\n\twhile(cin>>radius>>N,r>0.5){\n\t\tvector<int>l(100);\n\t\tvector<int>r(100);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>L>>R>>K;\n\t\t\tr[L+50]=max(r[L+50],K);\n\t\t\tl[R+50]=max(l[R+50],K);\n\t\t\tfor(int j=L+51;j<R+50;j++){\n\t\t\t\tr[j]=max(r[j],K);\n\t\t\t\tl[j]=max(l[j],K);\n\t\t\t}\n\t\t}\n\t\tlong double ret=100;\n\t\tfor(int i=-radius+1;i<radius;i++){\n\t\t\tlong double h=min(r[i+50],l[i+50]);\n\t\t\tlong double amari=radius*radius;\n\t\t\tamari-=i*i;\n\t\t\tamari=sqrt(amari);\n\t\t\tamari-=radius;\n\t\t\tret=min(ret,h-amari);\n\t\t}\n\t\tans.push_back(ret);\n\t}\n\tfor(auto i:ans)cout<<i<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint maxH[101];\nint R;\n\nconst int CENTER = 50;\n\nint main()\n{\n    int N;\n    while (cin >> R >> N, R || N) {\n        memset(maxH, 0, sizeof(maxH));\n        rep(i, N) {\n            int x1, x2, y;\n            cin >> x1 >> x2 >> y;\n            for (int xx = x1; xx < x2; xx++) {\n                maxH[xx+CENTER] = max(maxH[xx+CENTER], y);\n            }\n        }\n\n        double ans = 1000000.0;\n        for (int x = -R + 1; x < R; x++) {\n            int idx = x + CENTER;\n            int h = min(maxH[idx-1], maxH[idx]);\n            double tmp =  h + R - sqrt(R*R - x*x);\n\n            // DUMP2(x, h);\n            // DUMP(tmp);\n\n            ans = min(ans, tmp);\n        }\n\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,N,n) for(int i=N;i>=n;i++)\n#define CH(n,a,b) (a)<=(n)&&(n)<(b)\n#define p(s) cout<<s<<endl;\ntypedef long long ll;\nusing namespace std;\n\nint grid[25][45];\n\nint main() {\n\n\tint n, r, lx, rx, h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0 && n == 0) break;\n\t\tREP(i,0,25)REP(j,0,45) grid[i][j] = 0;\n\t\tREP(ii,0,n){\n\t\t\tcin>>lx>>rx>>h;\n\t\t\tREP(k,lx+20,rx+20)REP(l,0,h)grid[l][k] = 1;\n\t\t\t/*\n\t\t\tREP(i,0,21)\n\t\t\t\t\t{\n\t\t\t\t\t\tREP(j,0,44){\n\t\t\t\t\t\t\tcout<<grid[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n/*\n\t\tREP(i,0,21)\n\t\t{\n\t\t\tREP(j,0,44){\n\t\t\t\tcout<<grid[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n*/\n\t\tbool flag = false;\n\t\tREP(i,0,21){\n\t\t\tREP(w,0,r){\n\t\t\t\tif( !(grid[i][-w+20-1] == 1 /*&& grid[i][-w+20+1] == 1*/) || !(grid[i][w+20] == 1 /*&& grid[i][w+20+1] == 1*/)){\n\t\t\t\t\tdouble ans = (double)r - (double)sqrt((double)r*(double)r - (double)w*(double)w);\n\t\t\t\t\t//cout<<\"i: \"<<i<<\" w: \"<<w<<endl;\n\t\t\t\t\tif(w == 0) printf(\"%.6f\\n\", (double)i);\n\t\t\t\t\telse printf(\"%.6f\\n\", ans);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nint fie[50][50];\nint r,n;\ndouble px[4]={0,0,1,1};\ndouble py[4]={0,1,0,1};\n\nbool C(double t){\n\tdouble sx=20.0,sy=(double)-r+t;\n\tfor(int i=20.0-r;i<=20+r;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tif(fie[i][j]==0){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tdouble x=(double)i+px[k],y=(double)j+py[k];\n\t\t\t\t\tdouble dr=sqrt(pow(sx-x,2)+pow(sy-y,2));\n\t\t\t\t\tif(dr<(double)r)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&r,&n);\n\t\tif(r+n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint xl,xr,h;\n\t\t\tscanf(\"%d %d %d\",&xl,&xr,&h);\n\t\t\txl+=20,xr+=20;\n\t\t\tfor(int i=xl;i<xr;i++){\n\t\t\t\tfor(int j=0;j<h;j++)fie[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tdouble resl=0.00,resr=50.00;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tdouble mid=(resl+resr)/2;\n\t\t\tif(C(mid))resl=mid;\n\t\t\telse resr=mid;\n\t\t}\n\t\tprintf(\"%.7f\\n\",resr);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    double r;\n    int n;\n    while (cin >> r >> n && n){\n        map<int, double> hl, hr;\n        while (n--){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            hr[xl] = fmax(hr[xl], h);\n            hl[xr] = fmax(hl[xr], h);\n            FOR(i,xl+1,xr-1){\n                hl[i] = fmax(hl[i], h);\n                hr[i] = fmax(hr[i], h);\n            }\n        }\n\n        double ans = 20.0;\n        FOR(i,-r+1,r-1){\n            double h = fmin(hl[i], hr[i]);\n            double y = r - sqrt(r*r-i*i);\n            ans = fmin(ans, y+h);\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS = 1e-14;\n\nstruct building {\n\tdouble l, r, h;\n};\n\nvoid solve() {\n\tdouble r;int N; cin >> r >> N;\n\tif (r==0&&N == 0)exit(0);\n\tvector<building>v;\n\tREP(i, N) {\n\t\tdouble L, R, H; cin >> L >> R >> H;\n\t\tv.push_back({ L,R,H });\n\t}\n\tdouble ok = 0, ng = 1000;\n\tREP(_, 50) {\n\n\t\tdouble mid = (ok + ng) / 2;\n\t\t/*cout << mid << endl;*/\n\t\tdouble d = 2 * r / 200000;\n\t\tREP(c, 200001) {\n\t\t\tdouble x = -r + d * c;\n\t\t\t//cout << \"x:\" << x << endl;\n\t\t\tif (r*r - x * x < 0 + EPS)continue;\n\t\t\tdouble y = sqrt(r*r - x * x)-r+mid;\n\t\t\tif (y < EPS)continue;\n\t\t\t//cout << \"y:\" << y << endl;\n\t\t\tbool good = false;\n\n\t\t\tREP(i, N) {\n\t\t\t\tif (v[i].l < x + EPS && x - EPS < v[i].r&&y - EPS < v[i].h) {\n\t\t\t\t\tgood = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!good) {\n\t\t\t\tng = mid;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tok = mid;\n\tEND:;\n\t}\n\tprintf(\"%.3lf\\n\",ok);\n}\n\nsigned main() {\n\twhile (true)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint r, n, xl, xr, h;\n\nint main(void) {\n  while(cin >> r >> n, r && n) {\n    map<pii, bool> m;\n    int mh = 0;\n    REP(i, 0, n) {\n      cin >> xl >> xr >> h;\n      REP(j, 0, h) REP(k, xl, xr) m[pii(j, k)] = true;\n      mh = max(mh, h);\n    }\n\n    // REP(i, 0, mh) {\n    //   REP(j, -r, r) {\n    //     cout << (m[pii(i, j)] ? 1 : 0);\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n\n    int y, x;\n    REP(i, 0, mh) {\n      REP(j, -r, r) {\n        if(!m[pii(i, j)]) {\n          y = i;\n          x = j;\n          goto BREAK;\n        }\n      }\n    }\nBREAK:\n\n    if(x < 0) x = -x - 1;\n    // cout << y << \" \" << x << endl;\n\n    double t = y - sqrt(r * r - x * x) + r;\n    printf(\"%.15f\\n\", max(0.0, t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\nbool box[21][41];\nvoid solve(int r,int n){\n  rep(y,21) rep(x,41) box[y][x]=false;\n  rep(i,n) {\n    int li,ri,hi;\n    cin >> li >> ri >> hi;\n\n    for(int y=0;y<hi;++y) {\n      for(int x=li+20;x<ri+20;++x){\n        box[y][x]=true;\n      }\n    }\n  }\n  auto ans=numeric_limits<double>::max();\n  rep(y,21){\n    for(int x=-r+20;x<r+20;++x) {\n      if(!box[y][x]){\n        double time;\n        if(x<20) time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-19.0, 2.0));\n        else time = (double) y+r-sqrt(pow((double)r,2.0)-pow(x-20.0, 2.0));\n        ans=min(ans,time);\n      }\n    }\n  }\n  printf(\"%.4lf\\n\",ans);\n}\n\nint main()\n{\n  int r,n;\n  while(cin>>r>>n && r){\n    solve(r,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tint r, n;\n\twhile (cin >> r >> n&&r) {\n\t\tV height(r * 2);\n\t\trep(i, n) {\n\t\t\tint lx, rx, h;\n\t\t\tcin >> lx >> rx >> h;\n\t\t\tlx += r;\n\t\t\trx += r;\n\t\t\tREP(i, max(0LL, lx), min(r * 2, rx)) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\t\tif (any_of(all(height), [](int x) { return x == 0; })) {\n\t\t\tprintf(\"%.5g\\n\", 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble ans = r * 2;\n\t\trep(x, r * 2) {\n\t\t\tint h = height[x];\n\t\t\t//?????????????????????????????????????????????????????????\n\t\t\tdouble sun = h + r - sqrt(r*r - pow(abs(r - x) - (r - x > 0), 2));\n\t\t\tans = min(ans, sun);\n\t\t}\n\t\tprintf(\"%.5g\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  double r;\n  int n;\n  double ans;\n  double left,right,h;\n\n  while(1){\n    cin >> r >> n;\n    if(r==0) break;\n    ans=21;\n    vector<double> takasahidari(41,0),takasamigi(41,0);\n    for(int i=0;i<n;i++){\n      cin >> left >> right >> h;\n      for(int j=left;j<right;j++){\n        takasahidari[j+20]=max(takasahidari[j+20],h);\n      }\n      for(int j=left+1;j<=right;j++){\n        takasamigi[j+20]=max(takasamigi[j+20],h);\n      }\n    }\n    /*\n    for(int i=0;i<41;i++){\n      cout << takasahidari[i] << \" \";\n    }\n    cout << endl;\n    for(int i=0;i<41;i++){\n      cout << takasamigi[i] << \" \";\n    }\n    cout << endl;\n    */\n    for(int i=21-r;i<=19+r;i++){\n      /*\n      if(ans>min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20))){\n        cout << \"(\" << i-20 << \",\" << min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)) << \")\" << endl;\n      }\n      */\n      if(takasahidari[i]>0&&takasamigi[i]>0){\n        ans=min(ans,min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)));\n      }\n\n\n\n    }\n    if(ans==21){\n      ans=0;\n    }\n    cout << fixed<<setprecision(6)<<ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint r, n, xl, xr, h;\n\nint main(void) {\n  while(cin >> r >> n, r) {\n    map<pii, bool> m;\n    int mh = 0;\n    REP(i, 0, n) {\n      cin >> xl >> xr >> h;\n      REP(j, 0, h) REP(k, xl, xr) m[pii(j, k)] = true;\n      mh = max(mh, h);\n    }\n\n    // REP(i, 0, mh) {\n    //   REP(j, -r, r) {\n    //     cout << (m[pii(i, j)] ? 1 : 0);\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n\n    int y, x = 10000;\n    REP(i, 0, mh + 1) {\n      REP(j, -r, r) {\n        if(!m[pii(i, j)]) {\n          int tmp;\n          y = i;\n          if(j < 0) tmp = -(j + 1);\n          else tmp = j;\n          x = min(x, tmp);\n        }\n      }\n      if(x != 10000) break;\n    }\n\n    // cout << y << \" \" << x << endl;\n\n    double t = y - sqrt(r * r - x * x) + r;\n    printf(\"%.4f\\n\", max(0.0, t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nconst double INFTY = 10000000;\n\nint main() {\n    int n;\n    double r;\n    int rint;\n    int x1,x2;\n    double h;\n    double ans;\n    for(;;){\n        cin >> r >> n;\n        rint = (int)r;\n        if(rint==0)break;\n        vector<double> height(2*rint,0);\n        for(int j=0; j<n ; j++){\n            cin >> x1 >> x2 >> h;\n            for(int i=max(0,x1+rint); i<min(x2+rint,2*rint); i++){\n                height[i] = max(height[i],h);\n            }\n        }\n        ans = INFTY;\n        for(int i=0; i<rint; i++){\n            ans = min(ans, height[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n        }\n        for(int i=rint; i<2*rint; i++){\n            ans = min(ans, height[i] + r -  sqrt(r*r - (i - r)*(i - r)));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, r;\n  vector<double> V(41,0);\n  while(cin >> r >> n, r||n){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    double xl, xr, h;\n    double ans = 1e9;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(abs(i+1-r) <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <iomanip>\n\n\nusing namespace std;\n\n\nint main()\n{\n\n\n\tint r, n;\n\twhile (cin >> r >> n && r){\n\n\t\tint xl[20], xr[20], h[20];\n\t\tint sx = 21;\n\t\tint th = 0;\n\t\tint gx = -21;\n\t\tint t;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (sx > xl[i] || (sx == xl[i] && th < h[i])){\n\t\t\t\tsx = xl[i];\n\t\t\t\tth = h[i];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t\tif (gx < xr[i]){\n\t\t\t\tgx = xr[i];\n\t\t\t}\n\t\t}\n\n\t\tmap<int, int> ma;\n\n\t\tfor (int x = -20; x <= 20; x++)ma[x] = 0;\n\t\tfor (int x = sx; x <= gx; x++){\n\n\t\t\tbool ef = false; int eh = -1;\n\t\t\tif (xr[t] == x){\n\t\t\t\tef = true; eh = 0;\n\t\t\t}\n\t\t\tint mh = th; int tt = t;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tif (xl[i] == x && mh < h[i]){\n\t\t\t\t\tmh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t\tif (x >= xl[i] && x < xr[i] && ef){\n\t\t\t\t\teh = h[i]; tt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mh != th){\n\t\t\t\tt = tt; th = mh;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (ef){\n\t\t\t\t\tth = eh; t = tt;\n\t\t\t\t}\n\t\t\tma[x] = th;\n\t\t}\n\n\t\tconst double PI = 3.14159265359;\n\t\tdouble ans = 1e9;\n\t\tfor (double x = -r; x <= r; x += 1e-5/2.0){\n\n\t\t\tdouble y = -double(r) + sqrt(double(r)*double(r) - x*x);\n\t\t\tint tx = (x >= 0 ? int(x) : int(x - (1.0 - 1e-7)));\n\t\t\tans = min(ans, double(ma[tx]) - y);\n\n\t\t}\n\n\t\tcout << setprecision(30) << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1194\n//\n//  Created by 13B15237 on 2015/06/22.\n//  Copyright (c) 2015??´ 13B15237. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Rect {\n    int l, r;\n    int h;\n};\n\nstruct Point {\n    int x, y;\n};\n\nstruct Area {\n    bool table[21][41];\n    \n    void clear() {\n        for (int y = 0; y < 21; ++y) {\n            for (int x = -20; x < 21; ++x) {\n                table[y][x+20] = false;\n            }\n        }\n    }\n    \n    void draw(Rect rect) {\n        for (int y = 0; y < rect.h; ++y) {\n            for (int x = rect.l; x < rect.r; ++x) {\n                table[y][x + 20] = true;\n            }\n        }\n    }\n    \n    void show() {\n        for (int y = 20; y >= 0; --y) {\n            for (int x = -20; x < 21; ++x) {\n                cout << (table[y][x+20] == true ? '#' : '_');\n            }\n            cout << endl;\n        }\n    }\n    \n    bool test(int r, int t) {\n        const int ybegin = max(0, t - 2 * r);\n        const int yend = t;\n        \n        for (int y = ybegin; y < yend; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == false) return false;\n            }\n        }\n        return true;\n    }\n    \n    Point calcMinDistPoint(int r, int maxt) {\n        double mindist = 30.0;\n        Point p = {0, 0};\n        \n        for (int y = max(0, maxt - 2 * r); y < maxt; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == true) continue;\n                \n                const int a = x < 0 ? abs(x + 1) : x;\n                const int b = y;\n                double dist = sqrt(a*a + b*b);\n                //printf(\"(%d, %d) = %f\\n\", x,y,dist);\n                \n                if (dist < mindist) {\n                    mindist = dist;\n                    p.x = x;\n                    p.y = y;\n                }\n            }\n        }\n        return p;\n    }\n};\n\nint R, N;\nvector<Rect> vrect;\nArea area;\n\nint main(int argc, const char * argv[]) {\n    while (1) {\n        cin >> R >> N;\n        if (!R && !N) break;\n        \n        area.clear();\n        vrect.clear();\n        vrect.resize(N);\n        for (auto r : vrect) {\n            cin >> r.l >> r.r >> r.h;\n            area.draw(r);\n        }\n        \n        //area.show();\n        \n        int tmax;\n        for (tmax = 0; tmax < 21; ++tmax) {\n            if (area.test(R, tmax) == false) break;\n        }\n        \n        /*\n        double t = static_cast<double>(tmax - 1);\n        while (1) {\n            double d = area.calcMinDist(R, t, tmax);\n            if (d < static_cast<double>(R)) break;\n            t += 0.001;\n        }\n         */\n        Point p = area.calcMinDistPoint(R, tmax);\n        const int dx = p.x < 0 ? abs(p.x + 1) : abs(p.x);\n        double dy = sqrt(R * R - dx * dx);\n        \n        \n        //cout << \"p = (\" << p.x << \", \" << p.y << \")\" << endl\n        //<< \"dy = \" << dy << \", R  = \" << R << endl;\n        double t;\n        if (p.x == 0) {\n            t = (double)p.y;\n        }\n        else {\n            if (dy < (double)R) {\n                t = (double)(tmax - 1) + ((double)p.y - dy);\n            } else {\n                t = (double)p.y;\n            }\n        }\n        \n        \n        printf(\"%.4f\\n\", t);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint xl[20], xr[20], h[20];\nconst double EPS = 1e-6;\nint main() {\n\tint R, n;\n\twhile (cin >> R >> n,R) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t}\n\t\tdouble l = 0, r = 60;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tdouble m = (l + r) / 2;\n\t\t\tbool OK = 1;\n\t\t\tfor (int j = 0; j <= 1<<17; j++) {\n\t\t\t\tdouble x = -R + (2 * R) / (double)(1<<17) * j;\n\t\t\t\tint Max = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (xl[k] <= x+EPS&&x <= xr[k]+EPS) {\n\t\t\t\t\t\tMax = max(Max, h[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble H = sqrt(R*R - x*x) + m - R;\n\t\t\t\tif (Max < H+EPS) {\n\t\t\t\t\tOK = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (OK) l = m; else r = m;\n\t\t}\n\t\tcout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Vampire\n#include<bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint h1[40];//x[0]:-20?-19, x[39]:19?20\nint h2[41];//判定用\nconst double EPS=1E-5;\n\nbool a(double t){\n  complex<double> c;\n  c.real()=0.0, c.imag()=t-r;\n  for(int i=0; i<41; i++){\n    complex<double> d;\n    d.real()=i-20; d.imag()=h2[i];\n    //printf(\"(%f, %f)->%f\\n\", d.real(), d.imag(), abs(c-d));\n    if(abs(c-d)<r-EPS)return true;//含む\n  }\n  return false;//含まない\n}\n\ndouble solve(){\n  double ret=0;\n  while(true){\n    //cout<<\"ret=\"<<ret<<endl;\n    if(a(ret))break;\n    ret+=0.001;\n  }\n  return ret-0.001;\n}\n\nint main(){\n  while(true){\n    cin>>r>>n;\n    if(r==0 && n==0)break;\n    memset(h1, 0, sizeof(h1));\n    memset(h2, 0, sizeof(h2));\n    for(int i=0; i<n; i++){\n      int xl, xr, h;\n      cin>>xl>>xr>>h;\n      xl+=20; xr+=20;\n      for(int j=xl; j<xr; j++)\n        if(h1[j]<h)h1[j]=h;\n    }\n    for(int i=1; i<40; i++)\n      h2[i]=min(h1[i-1], h1[i]);\n    /*\n    for(int i=0; i<41; i++)\n      cout<<h2[i]<<' ';\n      cout<<endl;*/\n    printf(\"%.8f\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iomanip>\n#ifndef _WIN32\n#include<iostream>\n#endif\n#include<algorithm>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i =(bg); i< (ed);i++)\n#define REP(i,n) FOR(i,0,n) \n\nint main(){\n\tcout << fixed;\n\tcout << setprecision(10);\n\tint R,N;\n\twhile (cin >> R >> N, R){\n\t\tvector<double> A(40, 0);\n\t\tvector<double> B(40, 0);\n\t\tREP(i, N){\n\t\t\tint lb, ub;\n\t\t\tdouble h;\n\t\t\tcin >> lb >> ub >> h;\n\t\t\tFOR(j, 1, 40)if (lb <= j - 1 && j <= ub)A[j] = max(A[j], h);\n\t\t\tFOR(j, 1, 40)if (lb <= -j && -j + 1 <= ub)B[j] = max(B[j], h);\n\n\t\t}\n\t\tdouble ans = 114514;\n\t\tFOR(i,1, R+1){\n\t\t\tdouble a = i - 1;\n\t\t\tdouble b = i;\n\t\t\tans = min(ans, A[i] - sqrt(R*R - a*a) + R);\n\t\t\tans = min(ans, A[i] - sqrt(R*R - b*b) + R);\n\t\t\tans = min(ans, B[i] - sqrt(R*R - a*a) + R);\n\t\t\tans = min(ans, B[i] - sqrt(R*R - b*b) + R);\n\t\t\t//cout << \" \" << ans << endl;\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h[41]; //-20, 20\nint R;\n\nbool ok(double t)\n{\n\tfor (int i = -R; i < R; i++){\n\t\tdouble ly = 0, ry = 0;\n\t\t\n\t\tly = max(ly, -R + t + sqrt(R * R - i * i));\n\t\try = max(ry, -R + t + sqrt(R * R - (i + 1) * (i + 1)));\n\t\t\n\t\tif (ly > h[i + 20] + 1e-10 || ry > h[i + 20] + 1e-10){\n\t\t\treturn (false);\n\t\t}\n\t}\n\t\n\treturn (true);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d %d\", &R, &n) && R){\n\t\tmemset(h, 0, sizeof(h));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint l, r, y;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &y);\n\t\t\t\n\t\t\tfor (int j = l; j < r; j++) h[j + 20] = max(h[j + 20], y);\n\t\t}\n\t\t\n\t\tdouble l = 0, r = 20;\n\t\t\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tif (ok((l + r) / 2)) l = (l + r) / 2;\n\t\t\telse r = (l + r) / 2;\n\t\t}\n\t\t\n\t\tprintf(\"%.10lf\\n\", (l + r) / 2);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tlong double radius;\n\tcout<<setprecision(20);\n\twhile(cin>>radius>>N,N){\n\t\tvector<int>l(100);\n\t\tvector<int>r(100);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>L>>R>>K;\n\t\t\tr[L+50]=max(r[L+50],K);\n\t\t\tl[R+50]=max(l[R+50],K);\n\t\t\tfor(int j=L+51;j<R+50;j++){\n\t\t\t\tr[j]=max(r[j],K);\n\t\t\t\tl[j]=max(l[j],K);\n\t\t\t}\n\t\t}\n\t\tlong double ret=100;\n\t\tfor(int i=-radius+1;i<radius;i++){\n\t\t\tlong double h=min(r[i+50],l[i+50]);\n\t\t\tlong double amari=radius*radius;\n\t\t\tamari-=i*i;\n\t\t\tamari=sqrt(amari);\n\t\t\tamari-=radius;\n\t\t\tret=min(ret,h-amari);\n\t\t}\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i-1] + r - sqrt(r*r - (i-r)*(i-r)));\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint main(){\n  double r;\n  int n;\n  double ans;\n  double left,right,h;\n\n  while(1){\n    cin >> r >> n;\n    if(r==0) break;\n    ans=21;\n    vector<double> takasahidari(41,0),takasamigi(41,0);\n    for(int i=0;i<n;i++){\n      cin >> left >> right >> h;\n      for(int j=left;j<right;j++){\n        takasahidari[j+20]=max(takasahidari[j+20],h);\n      }\n      for(int j=left+1;j<=right;j++){\n        takasamigi[j+20]=max(takasamigi[j+20],h);\n      }\n    }\n    /*\n    for(int i=0;i<41;i++){\n      cout << takasahidari[i] << \" \";\n    }\n    cout << endl;\n    for(int i=0;i<41;i++){\n      cout << takasamigi[i] << \" \";\n    }\n    cout << endl;\n    */\n    for(int i=20-r;i<=20+r;i++){\n      /*\n      if(ans>min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20))){\n        cout << \"(\" << i-20 << \",\" << min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)) << \")\" << endl;\n      }\n      */\n      if(takasahidari[i]>0&&takasamigi[i]>0){\n        ans=min(ans,min(takasahidari[i],takasamigi[i])+r-sqrt(r*r-(i-20)*(i-20)));\n      }else{\n        ans=min(ans,r-sqrt(r*r-(i-20)*(i-20)));\n      }\n\n\n\n    }\n    if(ans==21){\n      ans=0;\n    }\n    cout << fixed<<setprecision(6)<<ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nusing Real = long double;\nusing Point = complex<Real>;\nconst Real EPS = 1e-8;\n\nstruct Circle {\n    Point p;\n    Real r;\n    Circle() :p(Point(0, 0)), r(0) {}\n    Circle(Point _p, Real _r) :p(_p), r(_r) {}\n};\n\nusing Points = vector<Point>;\nusing Circles = vector<Circle>;\n\nbool eq(Real a, Real b) { return abs(a - b) < EPS; }\n\nint intersect(Circle c1, Circle c2) {\n    if (c1.r < c2.r) swap(c1, c2);\n    Real d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d) return 4;\n    if (eq(c1.r + c2.r, d)) return 3;\n    if (c1.r - c2.r < d) return 2;\n    if (eq(c1.r - c2.r, d)) return 1;\n    return 0;\n}\n\npair<Point, Point> crosspoint(Circle& c1, Circle& c2) {\n    Real d = abs(c1.p - c2.p);\n    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    Real t = arg(c2.p - c1.p);\n    Point p1 = c1.p + polar(c1.r, t + a);\n    Point p2 = c1.p + polar(c1.r, t - a);\n    return { p1, p2 };\n}\n\nReal scan() {\n    int x; scanf(\"%d\", &x);\n    return (Real)x;\n}\n\nvoid solve() {\n    int r; scanf(\"%d\", &r);\n    int n; scanf(\"%d\", &n); if (r == 0 and n == 0) exit(0);\n    if (n == 0) {\n        puts(\"0.000\");\n        return;\n    }\n    int offset = 20;\n    Real h[41][41] = {}; for (int i = 0; i <= 40; i++)for (int j = 0; j <= 40; j++) h[i][j] = 0;\n    for (int i = 0; i < n; i++) {\n        int l, r, th; scanf(\"%d %d %d\", &l, &r, &th);\n        for (int i = l; i < r; i++) {\n            chmax(h[i + offset][i + 1 + offset], (Real)th);\n        }\n    }\n    Real step = 0.0001;\n    Real cur = 0;\n    Point center(0.0, -(Real)r);\n    while (1) {\n        cur += step;\n        center += Point(0, step);\n        for (int i = -r; i < r; i++) {\n            Real H = h[i + offset][i + 1 + offset];\n            Real x[2] = { i + 1 - EPS, i + EPS };\n            for (int i = 0; i < 2; i++) {\n                Real t = sqrt(r * r - x[i] * x[i]) + center.imag();\n                if (t > H ) {\n                    cout << fixed << setprecision(4) << cur << \"\\n\";\n                    return;\n                }\n\n            }\n        }\n    }\n}\nint main()\n{\n    /*\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    */\n    int kkt = 89;\n    while (kkt) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint r, n;\nint ph[30], mh[30];\n\nint main(){\t\n\twhile(scanf(\"%d%d\",&r,&n),r||n){\n\t\tmemset(ph,0,sizeof(ph));\n\t\tmemset(mh,0,sizeof(mh));\n\t\trep(i,n){\n\t\t\tint a, b, x;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&x);\n\t\t\tif(a < 0 && b > 0){\n\t\t\t\tfor(int j = 0; j < b; j++) ph[j] = max(ph[j],x);\n\t\t\t\tfor(int j = 0; j > a; j--) mh[-j] = max(mh[-j],x);\n\t\t\t} else if(a >= 0){\n\t\t\t\tfor(int j = a; j < b; j++) ph[j] = max(ph[j],x);\n\t\t\t} else{\n\t\t\t\tfor(int j = b; j > a; j--) mh[-j] = max(mh[-j],x);\n\t\t\t}\n\t\t}\n\t\tdouble s = 0.0, e = 100.0, mid;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tmid = (s+e)/2.0;\n\t\t\tif(mid > (double)min(ph[0],mh[0])){\n\t\t\t\te = mid;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tfor(int j = -1*r+1; j <= r-1; j++){\n\t\t\t\tif(j <= 0){\n\t\t\t\t\tif((double)j*(double)j+((double)mh[-j]+(double)r-mid)*((double)mh[-j]+(double)r-mid) < (double)r*(double)r){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j >= 0){\n\t\t\t\t\tif((double)j*(double)j+((double)ph[j]+(double)r-mid)*((double)ph[j]+(double)r-mid) < (double)r*(double)r){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) s = mid;\n\t\t\telse e = mid;\n\t\t}\n\t\tprintf(\"%.9f\\n\",s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\nint n,r;\n//vector<double> keep_x;\n//vector<double> keep_y;\nmap<int, double> keep_y;  \nbool check2(double x,double y, double xl, double xr, double hei){\n  return xl <= x && x <= xr && y <= hei;\n}\nvoid addPoint(vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  keep_y = map<int, double>();\n  for(int i = 0;i < n;i++){\n\tfor(int j = xl[i];j < xr[i];j++){\n\t  keep_y[j] = max(keep_y[j], hei[i]);\n\t}\n  }\n}\ndouble dist(double x1,double y1,double x2,double y2){\n  return ((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}\nbool check(double h){//円内に, 候補点があり=> アウト日が出る\n  for(int i = -r;i <= r;i++){\n\tif(dist(i, keep_y[i], 0, h) < r*r || dist(i, keep_y[i-1], 0, h) < r*r){\n\t  return true;\n\t}\n  }\n  return false;\n}\n\ndouble bs(double h,vector<double> &xl,vector<double> &xr,vector<double> &hei){\n  double f = -r;\n  double e = h;  \n  while(e - f >= 0.0001){\n\tdouble mid = (f + e) / 2.0;\n\tif(check(mid)){\n\t  e = mid;\n\t}else{\n\t  f = mid;\n\t}\n  }\n  return f;\n}\nint main(){\n  \n  while(cin >> r >> n && n != 0){\n\tvector<double> xl(n);\n\tvector<double> xr(n);\n\tvector<double> hei(n);\n\tfor(int i = 0;i < n;i++){\n\t  cin >> xl[i] >> xr[i] >> hei[i];\n\t}\n\taddPoint(xl,xr,hei);\n\tcout << bs(keep_y[0]-r,xl,xr,hei) + r<< endl;\n\t \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS = 1e-14;\n\nstruct building {\n\tdouble l, r, h;\n};\n\nvoid solve() {\n\tdouble r;int N; cin >> r >> N;\n\tif (r==0&&N == 0)exit(0);\n\tvector<building>v;\n\tREP(i, N) {\n\t\tdouble L, R, H; cin >> L >> R >> H;\n\t\tv.push_back({ L,R,H });\n\t}\n\tdouble ok = 0, ng = 1000;\n\tREP(_, 50) {\n\n\t\tdouble mid = (ok + ng) / 2;\n\t\t/*cout << mid << endl;*/\n\t\tdouble d = 2 * r / 200000;\n\t\tREP(c, 200001) {\n\t\t\tdouble x = -r + d * c;\n\t\t\t//cout << \"x:\" << x << endl;\n\t\t\tif (r*r - x * x < 0 + EPS)continue;\n\t\t\tdouble y = sqrt(r*r - x * x)-r+mid;\n\t\t\tif (y < EPS)continue;\n\t\t\t//cout << \"y:\" << y << endl;\n\t\t\tbool good = false;\n\n\t\t\tREP(i, N) {\n\t\t\t\tif (v[i].l < x + EPS && x - EPS < v[i].r&&y - EPS < v[i].h) {\n\t\t\t\t\tgood = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!good) {\n\t\t\t\tng = mid;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tok = mid;\n\tEND:;\n\t}\n\tprintf(\"%.3lf\\n\",ok);\n}\n\nsigned main() {\n\twhile (true)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint x[22][42];\nint r, n;\nint dx[] = {0, -1, -1, 0};\nint dy[] = {0, 0, -1, -1};\n\nbool check(double t) {\n  repl(i, 1, 21)repl(j, 1, 41) {\n    if ((i - 1 - t + r) * (i - 1 - t + r) + (j - 21) * (j - 21) < r * r) {\n      rep(k, 4) {\n        if (x[i + dy[k]][j + dx[k]] == 0) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  rep(i, 22)rep(j, 42) x[i][j] = 1;\n\n  while(cin >> r >> n, r) {\n    repl(i, 1, 21)repl(j, 1, 41) x[i][j] = 0;\n\n    rep(i, n) {\n      int l, r, h;\n      cin >> l >> r >> h;\n\n      repl(k, 1, h + 1)repl(j, l + 21, r + 21) x[k][j] = 1;\n    }\n\n    double ok = 0, ng = 20, md;\n    rep(i, 100) {\n      md = (ok + ng) / 2;\n      if (check(md)) ok = md;\n      else ng = md;\n    }\n\n    printf(\"%.10f\\n\", ok);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS) return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nvoid vis2(P p){\n\tprintf(\"plot(%.5lf,%.5lf,0)\\n\",p.real(),p.imag());\n}\nint test(vector<G> &g,double t,double r){\n\tr -= 1e-4;\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(0);\n\tchkPoint.push_back(PI/2.);\n\tchkPoint.push_back(3*PI/2.);\n\tchkPoint.push_back(2*PI/2.);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tx = x - c.p;\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"cir(\" << c.p.real() << \",\" << c.p.imag() << \",\" << r << \")\" << endl;\n\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tP p1 = c.p+r*P(cos(th+1e-4),sin(th+1e-4));\n\t\t\tP p2 = c.p+r*P(cos(th-1e-4),sin(th-1e-4));\n\t\t\t//vis2(p1);\n\t\t\t//vis2(p2);\n\t\t\t//vis2(pp);\n\t\t\tif( contains(g[j],pp) && contains(g[j],p1) != OUT && contains(g[j],p2) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if(flag) vis2(pp);\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nvoid vis(G g){\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tcout << \"line(\" << curr(g,i).real() << \",\" << curr(g,i).imag() << \",\" << next(g,i).real() << \",\" << next(g,i).imag() << \")\" << endl;\n\t}\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\t//g.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl-1e-3,0},{xr+1e-3,0},{xr+1e-3,h},{xl-1e-3,h}});\n\t\t\t//vis(g[i]);\n\t\t}\n\t\t\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\ntypedef long long ll;\n\nint main(void){\n    int r,n,left,right,height;\n    double minh;\n    map<int,int> s;\n\n    while(1){\n        cin>>r>>n;\n        if(r==0&&n==0)break;\n        rep(i,21)s[i]=s[-i]=0;\n        while(n--){\n            cin>>left>>right>>height;\n            for(int i=left;i<right;++i){\n                if(s[i]<height)s[i]=height;\n            }\n        }\n        minh = 21;\n        rep(i,r){\n            minh = min(minh,min(s[i],s[-i-1])-sqrt(r*r-i*i));\n        }\n        printf(\"%.4f\\n\",minh+r);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nenum { OUT,ON,IN};\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,Polygon;\nstruct L : public vector<P> { L(const P &a,const P &b){ push_back(a); push_back(b); } };\nstruct C { P p; double r; C(const P &p,double r) : p(p),r(r){} C(){} };\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n\nint contains(const Polygon &P,const point &p){\n\tbool in = false;\n\tfor( int i = 0 ; i < P.size() ; i++ ){\n\t\tpoint a = curr(P,i) - p;\n\t\tpoint b = next(P,i) - p;\n\t\tif( imag(a) > imag(b) ) swap(a,b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a,b) < 0 ) in = !in;\n\t\t\tif( cross(a,b) == 0 && dot(a,b) <= 0 ) return ON;\n\t}\n\t\n\treturn in ? IN : OUT;\n}\nP getPedal(L l,P p){\n\tdouble A;\n\tif( abs(l[1].real()-l[0].real()) < EPS ){\n\t\treturn P(l[1].real(),p.imag());\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A;\n\tdouble b = 1;\n\tdouble c = A * l[0].real() - l[0].imag();\n\tdouble t = (a * p.real() + b*p.imag() + c ) / (a*a+b*b);\n\t//cout << p << endl;\n\treturn p - t * P(a,b);\n}\nvector<P> crossPointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS) return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\t\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tif( c.r*c.r-abs(p-c.p)*abs(p-c.p) < 1e-8 ) S = 0;\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nbool contain(C c,P p){\n\tif( p.imag() < EPS ) return true;\n\treturn abs(c.p-p) < c.r + EPS;\n}\ndouble PI = acos(-1);\n\nvoid vis2(P p){\n\tprintf(\"plot(%.5lf,%.5lf,0)\\n\",p.real(),p.imag());\n}\nint test(vector<G> &g,double t,double r){\n\tr -= 1e-4;\n\tC c = C(P(0,-r+t),r);\n\tvector<double> chkPoint;\n\tchkPoint.push_back(0);\n\tchkPoint.push_back(PI/2.);\n\tchkPoint.push_back(3*PI/2.);\n\tchkPoint.push_back(2*PI/2.);\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tauto cp = crossPointCL(L(curr(g[i],j),next(g[i],j)),c);\n\t\t\tfor( auto x : cp ){\n\t\t\t\tx = x - c.p;\n\t\t\t\tdouble th = atan2(x.imag(),x.real());\n\t\t\t\tchkPoint.push_back(th);\n\t\t\t\tchkPoint.push_back(th+1e-4);\n\t\t\t\tchkPoint.push_back(th-1e-4);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"cir(\" << c.p.real() << \",\" << c.p.imag() << \",\" << r << \")\" << endl;\n\n\tfor( auto th : chkPoint ){\n\t\tP pp = c.p + r*P(cos(th),sin(th));\n\t\tif( pp.imag() < EPS ) continue;\n\t\tbool flag = true;\n\t\tfor(int j = 0 ; j < g.size() ; j++){\n\t\t\tif( contains(g[j],pp) != OUT ) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if(flag) vis2(pp);\n\t\tif(flag) return false;\n\t}\n\treturn true;\n}\nvoid vis(G g){\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tcout << \"line(\" << curr(g,i).real() << \",\" << curr(g,i).imag() << \",\" << next(g,i).real() << \",\" << next(g,i).imag() << \")\" << endl;\n\t}\n}\nint main(){\n\tdouble r;\n\tint n;\n\twhile( cin >> r >> n && r){\n\t\tvector<G> g;\n\t\t//g.push_back({{-1000,-1000},{1000,-1000},{1000,0},{-1000,0}});\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble xl,xr,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tg.push_back({{xl,0},{xr,0},{xr,h},{xl,h}});\n\t\t\t//vis(g[i]);\n\t\t}\n\t\t\n\t\tdouble L = 0 , R = 1000;\n\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\tdouble M = (L+R) / 2.;\n\t\t\tif( !test(g,M,r) ){\n\t\t\t\tR = M;\n\t\t\t}else{\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, r;\n\twhile (cin >>r>>n, r) {\n\t\tmap<int, int> v;\n\t\tint cmin = INF, cmax = -INF;\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcmin = min(cmin, a);\n\t\t\tcmax = max(cmax, b);\n\t\t\tFOR(j, a, b)v[j] = max(v[j], c);\n\t\t}\n\t\tif (cmin == INF) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tdouble u = 20, l = 0;\n\t\t\twhile (u - l > EPS) {\n\t\t\t\tint flag = 1;\n\t\t\t\tdouble mid = (u + l) / 2;\n\t\t\t\tFOR(i, cmin, cmax) {\n\t\t\t\t\tint d = i;\n\t\t\t\t\tif (i < 0)d++;\n\t\t\t\t\tdouble c = sqrt(r*r - d*d);\n\t\t\t\t\tif (c + mid -r> v[i])flag = 0;\n\t\t\t\t}\n\t\t\t\tif (flag)l = mid;\n\t\t\t\telse u = mid;\n\t\t\t}\n\t\t\tcout << fixed << setprecision(4) << l << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#include <cstring>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nmap<int,double> mp;\nint r,n;\n\nbool inshadow(double y){\n    REP(i,r){\n        if(sqrt(r*r-i*i) > mp[i] - y)return false;\n        if(sqrt(r*r-i*i) > mp[-i-1] - y)return false;\n    }\n    return true;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin>>r>>n,r){\n        mp.clear();\n        FOR(i,-r,r)mp[i] = 0.0;\n        REP(i,n){\n            int x1,x2;\n            double h;\n            cin>>x1>>x2>>h;\n            for(int j = max(x1,-r);j < min(x2,r);j++){\n                mp[j] = max(h,mp[j]);\n            }\n        }\n        double lb=-r,rb=20.0;\n        for(int i = 0;i<100;i++){\n            double mid = (lb+rb)/2;\n            if(inshadow(mid))lb = mid;\n            else rb = mid;\n        }\n        cout << fixed << setprecision(4) << lb + r << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint y[50],r,n;\n\nbool check(double cy){\n  double x=sqrt(r*r-cy*cy);\n  if(cy>=0)x=r;\n  int L=-x-25.9999,R=x+25.9999;\n\n  for(int i=L;i<R;i++){\n    int x1=i-24-i/25;\n    double y1=y[i]-cy;\n    if(x1*x1+y1*y1<r*r)return 0;\n  }\n  return 1;\n}\n\nint main(){\n  while(1){\n    cin>>r>>n;\n    if(!r&&!n)break;\n    for(int i=0;i<50;i++)y[i]=0;\n\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      for(int j=x1;j<x2;j++) y[j+25]=max(y[j+25],h);\n    }\n    double ans=0;\n    while(check(ans-r))ans+=0.0009;\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<numeric>\n#include<cstdio>\n#include<iomanip>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i < n;i++)\n\t\nint r,n;\nmap<int ,map<int ,double> > biuld;\n\nbool judge(double high)\n{\n\tfor(int i = -r;i < r;i++)\n\t{\n\t\tdouble y = biuld[i][i+1] - high;\n\t\tif(y < 0 || i*i + y*y < r*r || (i+1)*(i+1) + y*y < r*r)\n\t\t\treturn true;\n\t}\n\treturn false;\n\t\n}\n\nint main()\n{\n\tcout << setprecision(4) << fixed;\n\t\n\twhile(cin >> r >> n,r)\n\t{\n\t\tbiuld.clear();\n\t\tdouble lx,rx,h;\n\t\tREP(i,n)\n\t\t{\n\t\t\tcin >> lx >> rx >> h;\n\t\t\tfor(int j = lx;j < rx;j++)\n\t\t\t{\n\t\t\t\tbiuld[j][j+1] = max(biuld[j][j+1],h);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble ub = -r,hb = 21;\n\t\tREP(i,100)\n\t\t{\n\t\t\tdouble mid = (ub+hb)/2;\n\t\t\tif(judge(mid))hb = mid;\n\t\t\telse ub = mid;\n\t\t//\tcout << ub << ' ' << hb << endl;\n\t\t}\n\t\t\n\t\tcout << ub + (double)r << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n//#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tint r, n;\n\twhile (cin >> r >> n && r) {\n\t\tV height(r * 2);\n\t\trep(i, n) {\n\t\t\tint lx, rx, h; cin >> lx >> rx >> h;\n\t\t\tlx += r;\n\t\t\trx += r;\n\t\t\tREP(i, max(0, lx), min(r * 2, rx)) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = r * 2;\n\t\trep(x, r * 2) {\n\t\t\tint h = height[x];\n\t\t\t//?????????????????????????????????????????????????????????\n\t\t\tdouble sun = h + r - sqrt(r * r - pow(abs(r - x) - (r - x > 0), 2));\n\t\t\tans = min(ans, sun);\n\t\t}\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//reference to\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1724480#1\n\n#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll r;\n  ll n;\n  while(cin >> r >> n ,n){\n    vector<ll> a(41,0);\n    ll l,u,h;\n    rep(i,n){\n      cin >> l >> u >> h; \n      l += 20;\n      u += 20;\n      REP(j,l,u){\n        a[j] = max(a[j],h);\n      }\n    } \n    double ans = 11000;\n    rep(i,40){\n      int x=abs(i-20)+(i-20>=0?0:-1);\n      if(x>=r)continue;\n      double tmp=r-sqrt(1.0*(r*r-x*x));\n      ans = min(ans,a[i]+tmp);\n    }\n    std::fcout(10) << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\nint r, n;\n\ndouble calc(int a, int height){\n    double x = sqrt((double)(r * r - a * a));\n    return (double)height - x;\n}\n\nint main() {\n    while (1) {\n        cin >> r >> n;\n        if(r + n == 0) break;\n        double ans = 20.0;\n        int height[41] = {};\n        rep(i, 0, n){\n            int xl, xr, h;\n            cin >> xl >> xr >> h;\n            xl += 20;\n            xr += 20;\n            rep(j, xl, xr){\n                height[j] = max(height[j], h);\n            }\n        }\n        rep(i, 20 - r, 20 + r){\n            int a = abs(i - 20);\n            double limit = calc(a, height[i]);\n            ans = min(ans, limit);\n            \n            // cout << i << ' ' << height[i] << ' ' << a << ' ' << limit << endl;\n\n            int a2 = abs(i + 1 - 20);\n            double limit2 = calc(a2, height[i]);\n            ans = min(ans, limit2);\n        }\n        printf(\"%.10f\\n\", ans + r);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tdouble r;\n\t\tdouble center;\n\t\tdouble high;\n\t\tdouble answer = 20.0;\n\t\tdouble maxhigh = 0.0;\n\t\tdouble smallhigh = 0.0;\n\t\tint n;\n\t\tdouble xl[21] = {}, xr[21] = {}, h[21] = {};\n\n\t\tcin >> r >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (h[i] > maxhigh) {\n\t\t\t\tmaxhigh = h[i];\n\t\t\t}\n\t\t\tif (xl[i] <= -r && xr[i] >= r && smallhigh < h[i]) {\n\t\t\t\tsmallhigh = h[i];\n\t\t\t}\n\t\t}\n\n\t\tanswer = maxhigh;\n\n\n\t\tfor (double i = smallhigh; i <= maxhigh; i += 0.0001) {\n\t\t\tcenter = -r + i;\n\n\n\t\t\tfor (double j = -r; j <= r; j += 0.0001) {\n\t\t\t\thigh = sqrt(r*r - j * j) + center;\n\n\t\t\t\t\n\n\t\t\t\t//cout << center << \" \" << high << endl;\n\n\t\t\t\tFOR(k, 1, n) {\n\t\t\t\t\tif (xl[k] <= j && xr[k] >= j && high <= h[k]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (high <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (k == n) {\n\t\t\t\t\t\tanswer = i - 0.0001;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (answer != maxhigh) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (answer != maxhigh) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\", answer);\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>=R)return false;\n\tif(x<=-R)return false;\n\tif(y1<=c&&c<=y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>=c+R)return false;\n\tif(y<=c-R)return false;\n\tif(x1<=0.0&&0.0<=x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i,(double)(i+1))){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)h[i+geta],(double)h[i+1+geta])){\n\t\t\t\t//cout << i+1 << ' ' << h[i+geta] << ' ' << h[geta+1+i] << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\thighest = max(hi,highest);\n\t\tfor(int j=l;j<r;j++){\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = (double)highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\nstruct Point {\n\n\n    double x, y;\n\n    Point() {\n        x = 0;\n        y = 0;\n    }\n\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n\n    inline Point operator+=(double s) {\n        this->y += s;\n    }\n\n//    constexpr Point operator+(Point rhs) const {\n//        return {x + rhs.x, y + rhs.y};\n//    }\n//\n//    constexpr Point operator-(Point rhs) const {\n//        return {x - rhs.x, y - rhs.y};\n//    }\n\n};\n\ninline Point operator+(double s, Point p) {\n    return {p.x, s + p.y};\n}\n\n\nstruct Rect {\n\n    Point left;\n    Point right;\n\n    Rect() {\n\n    }\n\n    Rect(int left_x, int right_x, int y) {\n        left = Point(left_x, y);\n        right = Point(right_x, y);\n    }\n\n};\n\nbool isSection(Point point, Rect rect) {\n    if (rect.left.x <= point.x && point.x <= rect.right.x && point.y <= rect.left.y) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n\n    while (true) {\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0) {\n            break;\n        }\n\n        vector<Point> circlePoints(100000);\n        REP(i, circlePoints.size()) {\n            double x = -r + ((2.0 * r) * ((double) i / (double) circlePoints.size()));\n            double y = sqrt(r * r - x * x);\n            circlePoints[i] = Point(x, y);\n        }\n\n        vector<Rect> rects(n + 1);\n        REP(i, n + 1) {\n            if (i == n) {\n                rects[n] = Rect(-1000, 1000, 0);\n            } else {\n                int left, right, h;\n                cin >> left >> right >> h;\n                rects[i] = Rect(left, right, h);\n            }\n        }\n\n        double diff = 20;\n\n        bool plus = true;\n        while (diff > 0.00001) {\n            if (plus) {\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += diff;\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n                if (good) {\n                    continue;\n                } else {\n                    diff /= 2.0000;\n                    plus = false;\n                    // cout << diff;\n                }\n\n            } else {\n\n\n                //cout << \"here\";\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += (-diff);\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n//                double largeY = -1;\n//                REP(i, circlePoints.size()) {\n//                    largeY = max(largeY, circlePoints[i].y);\n//                }\n\n                if (good) {\n                    diff /= 2.0000;\n                    plus = true;\n                    //cout << diff << endl;\n                } else {\n                    continue;\n                }\n            }\n        }\n\n        double largeY = -1;\n        REP(i, circlePoints.size()) {\n            largeY = max(largeY, circlePoints[i].y);\n        }\n\n\n        double ans = floor_n(largeY, 4);\n        cout << fixed << setprecision(4) << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,N,n) for(int i=N;i>=n;i++)\n#define CH(n,a,b) (a)<=(n)&&(n)<(b)\n#define p(s) cout<<s<<endl;\ntypedef long long ll;\nusing namespace std;\n\nbool grid[25][45];\n\nint main() {\n\tint n, r, lx, rx, h;\n\twhile(1){\n\t\tcin>>r>>n;\n\t\tif(r==0 && n == 0) break;\n\t\tREP(i,0,25)REP(j,0,45) grid[i][j] = 0;\n\t\tREP(ii,0,n){\n\t\t\tcin>>lx>>rx>>h;\n\t\t\tREP(k,lx+20,rx+20)REP(l,0,h)grid[l][k] = 1;\n\t\t}\n\t\tbool flag = false;\n\t\tREP(i,0,21){\n\t\t\tREP(w,0,r){\n\t\t\t\tif( (grid[i][-w+20-1] == 0) || (grid[i][w+20] == 0)){\n\t\t\t\t\tdouble ans = r - sqrt(r*r - w*w);\n\t\t\t\t\t//cout<<\"i: \"<<i<<\" w: \"<<w<<endl;\n\t\t\t\t\tif(w == 0) printf(\"%.6f\\n\", (double)i);\n\t\t\t\t\telse printf(\"%.6f\\n\", ans+i);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> should_check_h(40,0);\nvector< vector<int> > should_check_v(41,vector<int>(2,0));\nint n,r;\n\nbool check_h_(int l,int h,double c){\n    if(l<0){\n        if(((l+1)*(l+1)+(h-c)*(h-c))<r*r){\n            return false;\n        }\n    }else if(l>=0){\n        if((l*l+(h-c)*(h-c))<r*r){\n            return false;\n        }\n    }\n    return true;\n}\n\nbool check_v_(int l,int d,int u,double c){\n    double m;\n    if(d<=c && c<=u){\n        m=0;\n    }else{\n        m=min((u-c)*(u-c),(d-c)*(d-c));\n    }\n    if((l*l+m)<(r*r)) return false;\n    return true;\n}\n\nbool check(double c){\n    for(int i=0;i<40;i++){\n        //cout << \"h l:\" << i-20 << \" h:\" << should_check_h.at(i) << \" c:\" << c << \" result:\" <<check_h_(i-20,should_check_h.at(i),c) << endl;\n        if(!(check_h_(i-20,should_check_h.at(i),c))) return false;\n    }\n    for(int i=0;i<41;i++){\n        if(!(check_v_(i-20,should_check_v.at(i).at(0),should_check_v.at(i).at(1),c))) return false;\n    }\n    return true;\n}\n\nint main(){\n    cin >> r >> n;\n    while(n!=0 || r!=0){\n        for(int i=0;i<40;i++) should_check_h.at(i)=0;\n        for(int i=0;i<n;i++){\n            vector<int> p(3);\n            cin >> p.at(0) >> p.at(1) >> p.at(2);\n            for(int j=p.at(0);j<p.at(1);j++){\n                should_check_h.at(j+20)=max(should_check_h.at(j+20),p.at(2));\n            }\n        }\n        should_check_v.at(0).at(1)=20;\n        should_check_v.at(40).at(1)=20;\n        for(int i=1;i<40;i++){\n            int l=should_check_h.at(i-1);\n            int r_=should_check_h.at(i);\n            should_check_v.at(i).at(0)=min(l,r_);\n            should_check_v.at(i).at(1)=20;\n        }\n    /*\n    for(int i=0;i<40;i++) cout << should_check_h.at(i) << \" \";\n    cout << endl;\n    for(int i=0;i<41;i++) cout << should_check_v.at(i).at(0) << \" \" <<should_check_v.at(i).at(1) << \"  \";\n    cout << endl;\n    */\n\n   //二分探索\n   //cout << \"aaaaaaa\" << endl;\n   double a,b;a=-r;b=20;\n   while((a+0.00001)<b){\n       double m=(a+b)/2;\n       if(check(m)){\n           a=m;\n       }else{\n           b=m;\n       }\n   }\n   //cout << \"ccccccccccc\" << endl;\n   cout << a+r << endl;\n   cin >> r >> n;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define FOR(i,m,n) for(int (i)=(m);(i)<(n);(i)++)\n#define All(v) (v).begin(),(v).end()\ntypedef long long ll;\n\ndouble dist(double x1,double y1,double x2,double y2){\n    return pow(x2-x1,2) + pow(y2-y1,2);\n}\n\nint main(){\n    int r,n;\n    while(cin >> r >> n,r|n){\n        vector<int> height(41,0);\n        rep(i,n){\n            int a,b,h;\n            cin >> a >> b >> h;\n            a+=20,b+=20;\n            for(int i=a;i<b;i++){\n                height[i]=max(height[i],h);\n            }\n        }\n        int flag=0;\n        for(double c=-r;c<=20.0;c+=0.0005){\n            for(int i=-r;i<=r;i++){\n                if(dist((double)i,(double)min(height[i+20],height[i+20-1]),0.0,c)<(double)r*(double)r){\n                    cout << c+r << endl;\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag)break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\n\nint n,r;\nconst int INF = 1000000007;\n\nmap<int,int> bill;\n\nbool input(){\n\tcin>>r>>n;\n\tif(n==0 && r==0)return false;\n\t\n\tbill.clear();\n\treps(i,-20,20+1)bill[i] = 0;\n\t\n\trep(i,n){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t\n\t\treps(j,a,b){\n\t\t\tbill[j] = max(bill[j], c);\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble check(int x, int h){\n\t\n\tif(abs(x) >= r)return INF;\n\t\n\tdouble t = r - sqrt(r*r - x*x) + h;\n\t//printf(\"x = %d  h = %d  t=%lf\\n\",x,h,t);\n\t\n\t\n\treturn t;\n}\n\nvoid solve(){\n\t\n\tdouble ans = INF;\n\t\n\ttypedef map<int,int>::iterator itr;\n\t\n\tfor(itr a = bill.begin(); a!=bill.end(); a++){\n\t\tans = min(ans, check(a->first, a->second));\n\t\tans = min(ans, check(a->first+1, a->second));\n\t}\n\t\n\tprintf(\"%.9lf\\n\",ans);\n}\n\nint main(){\n\twhile(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint r, n;\nint H[64];\nint& Height(int x) {\n  return H[x + 32];\n}\n\nint main(int argc, char *argv[]) {\n\n\n  for(;;) {\n    for(int& h : H) h = 0;\n    scanf(\"%d %d\", &r, &n);\n    if( r == 0 and n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      int xl, xr, h;\n      scanf(\"%d %d %d\", &xl, &xr, &h);\n      for(int x = xl; x < xr; ++x) {\n        Height(x) = std::max(Height(x), h);\n      }\n    }\n    double res = 1048576;\n    for(int x = -r + 1; x < r; ++x) {\n      double t = (double)std::min(Height(x-1), Height(x)) - sqrt(r*r-x*x) + r;\n      res = std::min(res, t);\n    }\n    printf(\"%.20lf\\n\", res);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<map>\n#include<cstdio>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define pb push_back\n#define P pair<int,int>\n#define ll __int64\nint n;\ndouble r;\ndouble x[100],x2[100],h[100];\n\nbool che(double t){\ndouble fai;\nint B=10000;\ndouble fy;\n\nfor(int i=0;i<=B;i++){\n\tfai=M_PI*(double)i/(double)B;\n\tdouble nx=r*cos(fai);//円上のx\n\tdouble ny=r*sin(fai)+t-r;//円上のy\n\t\n\tfy=-10000;\n\tdouble fx=0;\n\tfor(int j=0;j<n;j++){\n\t\tif(x[j]<=nx&&nx<=x2[j])fy=max(fy,h[j]);\n\t}\n\t//cout<<nx<<\" \"<<ny<<\" \"<<fy<<endl;\n\t\n\tif(fy<=-9999||ny>fy)return 0;\n}\nreturn 1;\n\n}\nint main(){\nwhile(cin>>r>>n,r||n){\nrep(i,n)cin>>x[i]>>x2[i]>>h[i];\n\n\n\ndouble mid=0,l=0,r=1000;\nmid=(r+l)/2;\nfor(int i=0;i<60;i++){\n\tif(che(mid)){\n\t\tl=mid;\n\t}\n\telse{\n\t\tr=mid;\n\t}\n\tmid=(r+l)/2;\n}\n\nprintf(\"%.20lf\\n\",mid);\nrep(i,n)x[i]=x2[i]=h[i]=0;\n}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n\nstruct Point {\n\n\n    double x, y;\n\n    Point() {\n        x = 0;\n        y = 0;\n    }\n\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n\n    inline Point operator+=(double s) {\n        this->y += s;\n    }\n\n//    constexpr Point operator+(Point rhs) const {\n//        return {x + rhs.x, y + rhs.y};\n//    }\n//\n//    constexpr Point operator-(Point rhs) const {\n//        return {x - rhs.x, y - rhs.y};\n//    }\n\n};\n\ninline Point operator+(double s, Point p) {\n    return {p.x, s + p.y};\n}\n\n\nstruct Rect {\n\n    Point left;\n    Point right;\n\n    Rect() {\n\n    }\n\n    Rect(int left_x, int right_x, int y) {\n        left = Point(left_x, y);\n        right = Point(right_x, y);\n    }\n\n};\n\nbool isSection(Point point, Rect rect) {\n    if (rect.left.x <= point.x && point.x <= rect.right.x && point.y <= rect.left.y) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n\n    while (true) {\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0) {\n            break;\n        }\n\n        vector<Point> circlePoints(100000);\n        REP(i, circlePoints.size()) {\n            double x = -r + ((2.0 * r) * ((double) i / (double) circlePoints.size()));\n            double y = sqrt(r * r - x * x);\n            circlePoints[i] = Point(x, y);\n        }\n\n        vector<Rect> rects(n + 1);\n        REP(i, n + 1) {\n            if (i == n) {\n                rects[n] = Rect(-1000, 1000, 0);\n            }else{\n                int left, right, h;\n                cin >> left >> right >> h;\n                rects[i] = Rect(left, right, h);\n            }\n        }\n\n        double diff = 20;\n\n        bool plus = true;\n        while (diff > 0.00001) {\n            if (plus) {\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += diff;\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n                if (good) {\n                    continue;\n                } else {\n                    diff /= 2.0000;\n                    plus = false;\n                   // cout << diff;\n                }\n\n            } else {\n\n\n                //cout << \"here\";\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += (-diff);\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n//                double largeY = -1;\n//                REP(i, circlePoints.size()) {\n//                    largeY = max(largeY, circlePoints[i].y);\n//                }\n\n                if (good) {\n                    diff /= 2.0000;\n                    plus = true;\n                    //cout << diff << endl;\n                } else {\n                    continue;\n                }\n            }\n        }\n\n        double largeY = -1;\n        REP(i, circlePoints.size()) {\n            largeY = max(largeY, circlePoints[i].y);\n        }\n\n        cout << setprecision(10) << largeY << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nint main(void){\n    int r,n,left,right,height;\n    double minh;\n    map<int,int> s;\n\n    while(1){\n        /* ????????? */\n        rep(i,21)s[i]=s[-i]=0;\n\n        /* ??\\??? */\n        cin>>r>>n;\n        if(r==0&&n==0)break;\n        minh = 21;\n        while(n--){\n            cin>>left>>right>>height;\n            for(int i=left;i<right;++i){\n                if(s[i]<height)s[i]=height;\n            }\n        }\n\n        rep(i,r)minh = min(minh,min(s[i],s[-i-1])-sqrt(r*r-i*i));\n        printf(\"%.4f\\n\",minh+r);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint hs[100][100];\nint main(){\n  int n;\n  double r;\n  while(cin>>r>>n,r+n){\n    memset(hs,0,sizeof(hs));\n    for(int i=0;i<n;i++){\n      int x1,x2,h;\n      cin>>x1>>x2>>h;\n      x1+=20;\n      x2+=20;\n      for(int i=x1;i<x2;i++){\n\tfor(int j=0;j<=h;j++)\n\t  hs[i][j]=1;\n      }\n    }\n    auto check = [&](double t){\n      for(int i=0;i<r;i++){\n\tdouble x=i;\n\tint y=sqrt(r*r-x*x)+t+1-r;\n\t//cout<<i<<\" \"<<t<<\" \"<<y<<endl;\n\tif(y<0)continue;\n\tif(!hs[i+20][y])return false;\n\tif(!hs[-i+20-1][y])return false;\n\t\n      }\n      return true;\n    };\n    double ub=100,lb=0,mid;\n    for(int i=0;i<200;i++){\n      mid=(ub+lb)/2;\n      if(check(mid))lb=mid;\n      else ub=mid;\n    }\n    cout<<fixed<<setprecision(12)<<lb<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tint r, n;\n\tint buildings[40]{};\n\n\tbool is_safe(double time)\n\t{\n\t\tfor (int i{20 - r}; i < 20 + r; i++)\n\t\t{\n\t\t\tdouble height[2]{sqrt(r * r - (-20 + i) * (-20 + i)) - r + time, sqrt(r * r - (-20 + i + 1) * (-20 + i + 1)) - r + time};\n\t\t\tif (buildings[i] < height[0] || buildings[i] < height[1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tscanf(\"%d%d\", &r, &n);\n\t\tif (r == 0 && n == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int n_i{}; n_i < n; n_i++)\n\t\t{\n\t\t\tint l, r, h;\n\t\t\tscanf(\"%d%d%d\", &l, &r, &h);\n\t\t\tfor (int b_i{20 + l}; b_i < 20 + r; b_i++)\n\t\t\t\tbuildings[b_i] = std::max(buildings[b_i], h);\n\t\t}\n\n\t\tdouble safe{0}, out{20};\n\t\twhile (safe + 1e-4 < out)\n\t\t{\n\t\t\tdouble mid{(safe + out) / 2};\n\t\t\tif (is_safe(mid)) safe = mid;\n\t\t\telse out = mid;\n\t\t}\n\t\tprintf(\"%lf\\n\", out);\n\t\treturn;\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n#define all all(v) v.begin(),v.end()\n#define INF i<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\n\ntypedef long long ll;\n\n#define EPS (1e-10)\n\nclass Point {\n\tpublic:\n\tdouble x,y;\n\n\tPoint(double x = 0, double y = 0): x(x),y(y){}\n\n\tPoint operator + (Point P) { return Point(x+P.x, y+P.y);}\n\tPoint operator - (Point P) { return Point(x-P.x, y-P.y);}\n\tPoint operator * (double a) { return Point(a*x, a*y);}\n\tPoint operator / (double a) { return Point(x/a, y/a);}\n\n\tdouble abs_() { return sqrt(norm());}\n\tdouble norm() { return x*x+y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ndouble dot(Point a, Point b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a, Point b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif(cross(a,b) > EPS) return 1;\n\tif(cross(a,b) < -EPS) return -1;\n\tif(dot(a,b) < -EPS) return 2;\n\tif(a.norm() < b.norm() ) return -2;\n\n\treturn 0;\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon andrewScan( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3) return s;\n\tsort(s.begin(),s.end());\n\n\tu.pb(s[0]);\n\tu.pb(s[1]);\n\n\tfor(int i=2; i< s.size(); i++){\n\t\tfor(int n = u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i]) != -1; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\n\treturn u;\n}\n\nint main(){\n\twhile(1){\n\t\tint r;\n\t\tint n;\n\t\tPolygon pv;\n\t\tcin >> r >> n;\n\t\tif(r==0) break;\n\n\t\tmap<int,pii> mv;\n\n\t\trep(i,n){\n\t\t\tint xr,xl,h;\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tmv[xl].se = max(h,mv[xl].se);\n\t\t\tfor(int nx = xl+1;nx<xr;nx++){\n\t\t\t\tmv[nx].fi = max(h,mv[nx].fi);\n\t\t\t\tmv[nx].se = max(h,mv[nx].se);\t\t\n\t\t\t}\n\t\t\tmv[xr].fi = max(h,mv[xr].fi);\n\t\t\t/*\n\t\t\tpv.pb(Point(xl,0));\n\t\t\tpv.pb(Point(xr,0));\n\t\t\tpv.pb(Point(xl,h));\n\t\t\tpv.pb(Point(xr,h));\n\t\t\tif(xl < 0 && 0 < xr){\n\t\t\t\tpv.pb(Point(0,h));\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tmv[-r-1].fi = mv[-r-1].se;\n\t\tmv[r+1].se = mv[r+1].fi;\n\n\t\t// cout<<\"=======\"<<endl;\n\t\tfor(int i=-20;i<=20;i++){\n\t\t\t\n\t\t\t// cout << min(mv[i].fi,mv[i].se) << endl;\n\t\t\tpv.pb(Point(i,min(mv[i].fi,mv[i].se)));\n\t\t}\n\t\t// cout<<\"=======\"<<endl;\n\n/*\n\t\tfor(int i=-20;i<21;i++){\n\t\t\tpv.pb(Point(i,min(mv[i],mv[i+1])));\n\t\t}\n\n\t\tcout<<\"-----------\"<<endl;\n\t\trep(i,pv.size()){\n\t\t\tif(pv[i].y!=23)cout<<pv[i].x<<\" \"<<pv[i].y<<endl;\n\t\t}\n\t\tcout<<\"--------\"<<endl;\n*/\n\n\t\tfor(double t = 0; t<=20.1;t+=0.00005){\n\t\t\tPoint c = Point(0,-r+t);\n\t\t\trep(i,pv.size()){\n\t\t\t\tif((c-pv[i]).abs_()<=r){\n\t\t\t\t\t// cout<<(c-pv[i]).abs_()<<endl;\n\t\t\t\t\tprintf(\"%.4lf\\n\",t);\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\t/*\n\t\t// Polygon pt;\n\t\t// pt = andrewScan(pv);\n\t\t// rep(i,pv.size()){\n\t\t// \tcout << \"pv :\" << pv[i].x << \" \"<< pv[i].y << endl;\n\t\t// }\n\n\t\trep(i,pt.size()){\n\t\t\tcout << \"pt :\" << pt[i].x << \" \"<< pt[i].y << endl;\n\t\t}\n*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex< double > Point;\ntypedef vector< Point > Polygon;\nnamespace std{\n    bool operator < ( Point a, Point b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n};\nconst double INF = 1e12;\nconst double EPS = 1e-8;\nPoint NextPoint(){\n    Point P;\n    cin>>P.real()>>P.imag();\n    return P;\n}\nstruct Line : Polygon{\n    Line(){};\n    Line(Point p, Point q){push_back(p);push_back(q);}\n};\n \nstruct Circle{\n    Point p;\n    double r;\n    Circle();\n    Circle(Point a, double s){p = a,r = s;}\n};\ndouble cross(Point p, Point q){\n    return imag(conj(p)*q);\n}\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\nint ccw(Point a,Point b,Point c){\n    b -= a,c -= a;\n    if(cross(b,c) > 0)return 1;\n    if(cross(b,c) < 0)return -1;\n    if(dot(b,c) < 0 )return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\nPoint projection(Line l,Point p){\n    double t = dot(p - l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nbool intersectSP(Line s,Point p){\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble distanceSP(Line s,Point p){\n    const Point r = projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0] - p),abs(s[1] - p));\n}\nint main(){\n    int r,n;\n    while(cin>>r>>n,r){\n        int sc[50] = {};\n        for(int i = 0;i < n;i++){\n            int l,r,h;\n            cin>>l>>r>>h;\n            l+=21,r+=21;\n            for(int j = l;j < r;j++){\n                sc[j] = max(sc[j],h);\n            }\n        }\n        Polygon G;\n        G.push_back(Point(-100,0));\n        G.push_back(Point(0,0));\n        for(int i = 0;i < 45;i++){\n             \n            if(i != 0){\n                if(sc[i] != sc[i-1])\n                    G.push_back(Point(i,sc[i]));\n                 \n                G.push_back(Point(i+1,sc[i]));\n            }\n        }\n        G.push_back(Point(100,0));\n \n        for(int i = 0;i < G.size();i++){\n            //cout<<G[i].real()<<\" \"<<G[i].imag()<<endl;\n        }\n \n        double low = -r,high = 25;\n        int D = 50;\n        //cout<<sc[20]<<endl;\n        while(D--){\n            double mid = (low+high)/2;\n            Circle C = Circle(Point(21,mid),r-EPS);\n            double mi = INF;\n            for(int i = 0;i < G.size()-1;i++){\n                double dist = distanceSP(Line(G[i],G[i+1]),C.p);\n                mi = min(mi,dist);\n            }\n            //cout<<mid<<\" \"<<mi<<\" \"<<mid+r<<endl;\n            if(mi < r - EPS)high = mid;\n            else if(sc[21] < mid+r)high = mid;\n            else low = mid;\n        }\n        printf(\"%.4lf\\n\",low+r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct Circle {\n  Point p; double r;\n  Circle(const Point &p, double r) : p(p), r(r) { }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nvector<Point> crosspointsCC(const Circle& s,const Circle& t){\n  //ax + by + c = 0\n  double a = real(t.p) - real(s.p); //x1-x2;\n  double b = imag(t.p) - imag(s.p); //y1-y2;\n  double d = sqrt(a * a + b * b);\n  double theta = 0.0;\n\n  if(d > 0) {\n    theta = acos((d * d + s.r * s.r - t.r * t.r) / (2 * d * s.r));\n  }\n\n  double angle = atan2(b,a);\n  \n  vector<Point> res;\n  if(d < s.r + t.r){\n    res.push_back(Point(s.p.real() + s.r * cos(angle + theta), s.p.imag() + s.r * sin(angle + theta)));\n    res.push_back(Point(s.p.real() + s.r * cos(angle - theta), s.p.imag() + s.r * sin(angle - theta)));\n  }\n\n  else if(s.r + t.r - EPS <= d && d <= s.r + t.r + EPS){\n    res.push_back(Point(s.p.real() + s.r * cos(angle), s.p.imag() + s.r * sin(angle)));\n  }\n  \n  return res;\n}\n\nbool intersectCS(const Circle& s,const Line& t){\n  Point v = t[1] - t[0];\n  Point c = s.p - t[0];\n  Point b = s.p - t[1];\n  if(dot(v,c) < 0){\n    if(abs(c) < s.r) return true;\n    return false;\n  }\n  else{\n    if(dot(v,c) > dot(v,v)){\n      if(dot(s.r,s.r) > dot(b,b)) return true;\n      return false;\n    }\n    else{\n      if(dot(c,c) - dot(v,c) * dot(v,c) / dot(v,v) < dot(s.r,s.r)) return true;\n      if(abs(c) < s.r || abs(b) < s.r) return true;\n      return false;\n    }\n  }\n}\n\nPoint crosspointLL(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const Point &l,const Point &m){\n  return abs(cross(l,m)) / 2.0;\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool include(const Circle& s,Point t){\n  t -= s.p;\n  return dot(t,t) <= s.r * s.r + EPS;\n}\n\nint main(){\n  int r,n;\n  while(~scanf(\"%d %d\",&r,&n)){\n    if(r == 0 && n == 0) break;\n    \n    vector<Line> lines;\n    double lhs = -(double)r;\n    bool has_point[50][50] = {};\n    int min_x = 100;\n    int max_x = -100;\n    double max_h = 0.0;\n    for(int i = 0; i < n; i++){\n      int lx,rx;\n      int h;\n      scanf(\"%d %d %d\",&lx,&rx,&h);\n      for(int x = lx; x < rx; x++){\n        has_point[x + 20][h] = true;\n      }\n      min_x = min(lx,min_x);\n      max_x = max(rx,max_x);\n      max_h = max((double)h,max_h);\n    }\n\n    lines.push_back(Line(Point(-10000,0),Point(min_x,0)));\n    lines.push_back(Line(Point(max_x,0),Point(10000,0)));\n\n    for(int x = -20; x < 20; x++){\n      bool isok = false;\n      for(int y = 20; y >= 0; y--){\n        if(has_point[x + 20][y]){\n          //horizontal\n          lines.push_back(Line(Point(x,y),Point(x+1,y)));\n\n          //vertical\n          lines.push_back(Line(Point(x,y),Point(x,100)));\n          lines.push_back(Line(Point(x+1,y),Point(x+1,100)));\n          isok = true;\n          break;\n        }\n      }\n      if(!isok){\n          //horizontal\n        lines.push_back(Line(Point(x,0),Point(x+1,0)));\n\n        //vertical\n        lines.push_back(Line(Point(x,0),Point(x,100)));\n        lines.push_back(Line(Point(x+1,0),Point(x+1,100)));\n      }\n    }\n\n    double rhs = max_h;\n    for(int round = 0; round < 50; round++){\n      double mid = lhs + (rhs - lhs) / 2.0;\n      Circle c(Point(0,mid),r);\n      \n      bool has_crosspoint = false;\n      for(int i = 0; i < lines.size(); i++){\n        if(intersectCS(c,lines[i])){\n          has_crosspoint = true;\n          break;\n        }\n      }\n      \n      if(has_crosspoint){\n        rhs = mid;\n      }\n      else{\n        lhs = mid;\n      }\n    }\n    printf(\"%.4lf\\n\",rhs + (double)r);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n#define EPS 1e-7\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ndouble high[66];\nint n,r;\n\n//チェック関数\nbool check(double mid){\n\tfor(int i = 30-r;i < 30+r;i++){\n\t\tif(high[i] < mid)return false;\n\t\tdouble A = sqrt((i-30)*(i-30) + (high[i]-mid)*(high[i]-mid));\n\t\tdouble B = sqrt((i-29)*(i-29) + (high[i]-mid)*(high[i]-mid));\n\t\tif(min(A,B) < r + EPS)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> r >> n,r|n){\n\t\t//初期\n\t\tREP(i,66)high[i] = 0;\n\t\t\n\t\t\n\t\tREP(i,n){\n\t\t\tint a,b;\n\t\t\tdouble c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tfor(int j = a;j < b;j++){\n\t\t\t\thigh[j+30] = max(high[j+30],c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ちゃんと余裕をもって値をとる\n\t\tdouble tb = 100;\n\t\tdouble ub = -100;\n\t\tDBG(SHOW1d(high,66));\n\t\tREP(i,1000){\n\t\t\tdouble mid = (tb + ub) / 2;\n\t\t\tif(check(mid))ub = mid;\n\t\t\telse tb = mid;\n\t\t}\n\t\t\n\t\t//にぶたんで求めたのは中心の高さなので、半径の分だけ時間を足す\n\t\tcout << Decimal << (double)(ub+r) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <map>\nusing namespace std;\nint r,n,L,R,h,i,x;int main(){while(cin>>r>>n,r){map<int,int> A,B;for(i=0;i<n;i++){cin>>L>>R>>h;for(x=L;x<=R;x++){if(x!=R)A[x]=max(A[x],h);if(x!=L)B[x]=max(B[x],h);}}double res=99;for(i=-r;i<=r-1;i++){res=min(res,min(r-sqrt(r*r-i*i)+A[i],r-sqrt(r*r-(i+1)*(i+1))+B[i+1]));}cout<<res<<\"\\n\";}}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h[41]; //-20, 20\nint R;\n\nbool ok(double t)\n{\n\tfor (int i = -R; i < R; i++){\n\t\tdouble ly = 0, ry = 0;\n\t\t\n\t\tif (R * R - i * i >= 0) ly = max(ly, -R + t + sqrt(R * R - i * i));\n\t\tif (R * R - (i + 1) * (i + 1) >= 0) ry = max(ry, -R + t + sqrt(R * R - (i + 1) * (i + 1)));\n\t\t\n\t\tif (ly > h[i + 20] || ry > h[i + 20]){\n\t\t\treturn (false);\n\t\t}\n\t}\n\t\n\treturn (true);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d %d\", &R, &n) && n){\n\t\tmemset(h, 0, sizeof(h));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint l, r, y;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &y);\n\t\t\t\n\t\t\tfor (int j = l; j < r; j++) h[j + 20] = max(h[j + 20], y);\n\t\t}\n\t\t\n\t\tdouble l = 0, r = 20;\n\t\t\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tif (ok((l + r) / 2)) l = (l + r) / 2;\n\t\t\telse r = (l + r) / 2;\n\t\t}\n\t\t\n\t\tprintf(\"%.10lf\\n\", (l + r) / 2);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint R, N; \nint x1,x2,h;\nint B[50];\ndouble ans = 10000.0;\n\ndouble b(double x) {\n\treturn (double) B[(int) (x + 25.0)];\n\t\n}\n\ndouble sun(double x) {\n\tdouble r = R;\n\treturn sqrt(r * r - x * x) - r;\n}\n\ndouble f(double x) {\n\treturn b(x) - sun(x);\n}\n\nint main() {\n\tcin >> R >> N;\n\twhile(R + N) {\n\t\tans = 10000000.0;\n\t\tfor (int i = 0; i < 50; i ++) {\n\t\t\tB [i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x1 >> x2 >> h;\n\t\t\tx1 += 25;\n\t\t\tx2 += 25;\n\t\t\tfor (int x = x1; x < x2; x++ ) {\n\t\t\t\tB[x] = max(B[x], h);\n\t\t\t}\n\t\t}\n\t\tdouble r = R;\n\t\tfor (double x = -r; x < r; x += 0.0001) {\n\t\t\tans = min(ans, f(x));\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\tcin >> R >> N;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 2*r+1; ++i) V[i] = 0;\n    double ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = max(xl,-r); j < min(xr,r+1); ++j){\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i-1] + r - sqrt(r*r - (i-r)*(i-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\nint main(){\n\n  while(1){\n    int r,n;\n    cin >> r >> n;\n    if(r==0&&n==0) break;\n    int field[41]={};\n    int *hs = &field[20];\n\n    rep(i,n){\n      int x1,x2,h;\n      cin >> x1 >> x2 >> h;\n      REP(j,x1,x2) hs[j]=max(hs[j],h);\n    }\n    \n    double ans = 1e15;\n    for(int i=-r;i<r;i++){\n      double x;\n      if(i<0) x = i+1;\n      else x = i;\n      ans = min(ans,r-sqrt(r*r-x*x)+hs[i]);\n    }\n    \n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ndouble solve(int r, int n) {\n  vector<int> h(41);\n  for (int i = 0; i < n; i++) {\n    int xl, xr, hh;\n    cin >> xl >> xr >> hh;\n    xl += 20;\n    xr += 20;\n    for (int x = xl; x < xr; x++) {\n      h[x] = max(h[x], hh);\n    }\n  }\n  double ans = 1e9;\n  for (int i = -r + 1; i < r; i++) {\n    int x = i + 20;\n    int hh = min(h[x - 1], h[x]);\n    ans = min(ans, 1. * hh - sqrt(r * r - i * i) + r);\n  }\n  return ans;\n}\nsigned main() { \n  ios::sync_with_stdio(false); cin.tie(0);\n  int r, n;\n  while (cin >> r >> n) {\n    if (r == 0) return 0;\n    cout << setprecision(5) << fixed << solve(r, n) << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<pii> vp;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e18:1e9+10;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,R){\n\t\tvi in(60);\n\t\trep(i,n){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta+=30;b+=30;\n\t\t\tloop(j,a,b)in[j]=max(in[j],c);\n\t\t}\n\t\tdouble l=0,r=21;\n\t//\trep(i,60)cout<<\" \"<<in[i];cout<<endl;\n\t\twhile(r-l>0.0001){\n\t\t\tdouble h=(l+r)/2;\n\t\t\tbool H=true;\n\t\t\trep(q,50){\n\t\t\t\tint t=q-25;\n\t\t\t\tif(abs(t)>R)continue;\n\t\t\t\tint hi=min(in[t+29],in[t+30]);\n\t\t\t\tif(t==R)hi=in[t+29];\n\t\t\t\telse if(-t==R)hi=in[t+30];\n\t\t\t\tif(h-R>hi)H=false;\n\t\t\t\tif(R*R>abs(t)*abs(t)+abs(hi-(h-R))*abs(hi-(h-R)))H=false;\n\t\t\t}\n//\t\t\tcout<<shosu(4)<<h<<\" \"<<H<<endl;\n\t\t\tif(H)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tcout<<shosu(9)<<l<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <fstream>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <unordered_map>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\nconst double EPS = (1e-10);\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst Int MOD = 998244353;\n\nInt mod_pow(Int x, Int n) {\n    Int res = 1;\n    while(n > 0) {\n        if(n & 1) res = (res * x) % MOD; //ビット演算(最下位ビットが1のとき)\n        x = (x * x) % MOD;\n        n >>= 1; //右シフト(n = n >> 1)\n    }\n    return res;\n}\n\n//最大公約数\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\n//最小公倍数\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\n//入出力高速化(非同期化)\nvoid fast_input() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\ndouble solve(double r, int N) {\n    double EPS = 1e-9;\n    vector<int> L(N);\n    vector<int> R(N);\n    vector<int> H(N);\n    vector<int> h(45);\n    for (int i = 0; i < N; i++) {\n        cin >> L[i] >> R[i] >> H[i];\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = L[i] +20; j < R[i] +20 ; j++) {\n            h[j] = max(h[j], H[i]);\n        }\n    }\n    vector<int> tmp(45);\n    for (int i = 1; i < 45; i++) {\n        tmp[i] = min(h[i], h[i-1]);\n    }\n    h = tmp;\n\n    bool flag = true;\n    int center = -r;\n    while (flag) {\n        for (int i = 0; i < 45; i++) {\n            if ((double)r - sqrt((double)((20-i)*(20-i) + (h[i]-center)*(h[i]-center))) > EPS) {\n                flag = false;\n                break;\n            }\n            if (i == 44) center++;\n        }\n    }\n    \n    double ng, mid, ok;\n    ng = center, ok = center-1;\n    for (int i = 0; i < 100; i++) {\n        mid = (ok + ng) / 2.0;\n        bool flag = true;\n        for (int i = 0; i < 45; i++) {\n            if ((double)r - sqrt((double)((20-i)*(20-i) + (h[i]-mid)*(h[i]-mid))) > EPS) {\n                flag = false;\n                break;\n            }\n            if (i == 44) center++;\n        }\n        if (flag){\n            ok = mid;\n        }else{\n            ng = mid;\n        }\n    }\n    return ok + r;\n}\n\nint main(void) {\n    double R;\n    int N;\n    vector<double> ans;\n    while (1) {\n        cin >> R >> N;\n        if (R == 0 && N == 0) break;\n        ans.push_back(solve(R, N));\n    }\n    for (auto &i: ans) {\n        printf(\"%f\\n\", i);\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\n\nfloat solve(int r, vector<array<int, 3>>& vs)\n{\n    std::array<int, 41> imos;\n    for(auto& e: imos) e = 0;\n\n    for(auto& e: vs){\n        imos[e[0] + 20] += 1;\n        imos[e[1] + 20] += -1;\n    }\n\n    int s = 0;\n    for(auto& e: imos){\n        s += e;\n        e = s;\n    }\n\n    int maxL = 0, maxR = 0;\n    for(int i = 0; i <= 20; ++i){\n        if(imos[i+20] == 0)\n            break;\n        maxL = i + 1;\n    }\n    for(int i = 0; i >= -20; --i){\n        if(imos[i+20] == 0)\n            break;\n        maxR = -i;\n    }\n\n    // for(auto&e : imos)\n    //     cout << e << \", \";\n    // cout << endl << \"maxL: \" << maxL << \", maxR: \" << maxR << endl;\n\n    int width = (maxL < maxR ? maxL : maxR) * 2;\n    // if(width != 0) width -= 1;\n    if(width == 0) return 0;\n    if(width > r)\n        width = r*2;\n\n    // cout << width << endl;\n\n    int wh = width / 2;\n    float whf = wh;\n\n    float hd = r - sqrt(r*r - whf*whf);\n    if(!(hd > 0)) hd = 0;\n\n    std::array<int, 41> maxH;\n    for(auto& e: maxH) e = 0;\n    for(auto& e: vs){\n        for(int i = -20; i <= 20; ++i)\n            if(e[0] <= i && i < e[1]){\n                if(maxH[i+20] < e[2])\n                    maxH[i+20] = e[2];\n            }\n    }\n\n\n\n    float max = 0;\n    for(int i = -wh; i <= wh; ++i){\n        auto hh = sqrt(r*r - i*i) - (r - hd);\n        if(maxH[i+20] < hh && max < (hh - maxH[i+20])){\n            max = hh - maxH[i+20];\n        }\n    }\n\n    // cout << \"max: \" << max << endl;\n    // cout << \"hd: \" << hd << endl;\n\n    // for(auto&e : maxH)\n    //     cout << e << \", \";\n    // cout << endl;\n\n    if(max == 0){\n        float mm = 1024, ret = 0;\n        for(int i = -wh; i <= wh; ++i){\n            float rm1 = maxH[i+20] - sqrt(r*r - (i+1)*(i+1));\n            float rm2 = maxH[i+20] - sqrt(r*r - i*i);\n            float rm = rm1 < rm2 ? rm1 : rm2;\n            // cout << \"i: \" << i << \", rm1: \" << rm1 << \", rm2: \" << rm2 << endl;\n            if(maxH[i+20] != 0 && mm > rm){\n                mm = rm;\n                ret = rm + whf;\n            }\n        }\n\n        // cout << \"mm: \" << mm << endl;\n        return ret;\n    }\n\n    return hd - max;\n}\n\n\nint main(void)\n{\n    int r, n;\n    while(cin >> r >> n){\n        if(r == 0 && n == 0)\n            break;\n\n        vector<array<int, 3>> vs;\n        for(int i = 0; i < n; ++i){\n            array<int, 3> arr;\n            cin >> arr[0] >> arr[1] >> arr[2];\n            vs.push_back(arr);\n        }\n\n        cout << fixed << setprecision(4) << solve(r, vs) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tlong double radius;\n\tvector<long double>ans;\n\tcout<<setprecision(20);\n\twhile(cin>>radius>>N,radius>0.5){\n\t\tvector<int>l(100);\n\t\tvector<int>r(100);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>L>>R>>K;\n\t\t\tr[L+50]=max(r[L+50],K);\n\t\t\tl[R+50]=max(l[R+50],K);\n\t\t\tfor(int j=L+51;j<R+50;j++){\n\t\t\t\tr[j]=max(r[j],K);\n\t\t\t\tl[j]=max(l[j],K);\n\t\t\t}\n\t\t}\n\t\tlong double ret=100;\n\t\tfor(int i=-radius+1;i<radius;i++){\n\t\t\tlong double h=min(r[i+50],l[i+50]);\n\t\t\tlong double amari=radius*radius;\n\t\t\tamari-=i*i;\n\t\t\tamari=sqrt(amari);\n\t\t\tamari-=radius;\n\t\t\tret=min(ret,h-amari);\n\t\t}\n\t\tans.push_back(ret);\n\t}\n\tfor(auto i:ans)cout<<i<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n//#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tint r, n;\n\twhile (cin >> r >> n && r) {\n\t\tV height(r * 2);\n\t\trep(i, n) {\n\t\t\tint lx, rx, h; cin >> lx >> rx >> h;\n\t\t\tlx += r;\n\t\t\trx += r;\n\t\t\tREP(i, max(0, lx), min(r * 2, rx)) {\n\t\t\t\theight[i] = max(height[i], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = r * 2;\n\t\trep(x, r * 2) {\n\t\t\tint h = height[x];\n\t\t\tdouble a = sqrt(r * r - pow(abs(r - x) - (r - x < 0), 2));\n\t\t\tdouble sun = (double)(h + r) - a;\n\t\t\tans = min(ans, sun);\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint main(){\n  int n, r, diff = 20;\n  while(std::cin >> r >> n, r){\n    vector<int> hl(50, 0), hr(50, 0);\n    for (int i = 0; i < n; i++) {\n      int xl, xr, h;\n      std::cin >> xl >> xr >> h;\n      for (int j = xl; j < xr; j++) {\n        hr[j + diff] = max(hr[j + diff], h);\n      }\n      for (int j = xl + 1; j <= xr; j++) {\n        hl[j + diff] = max(hl[j + diff], h);\n      }\n    }\n    double ans = 1e9;\n    for (int i = -r + 1; i < r; ++i) {\n      ans = min(ans, min(hr[i + diff], hl[i + diff]) +\n                r - sqrt(r*r - i*i));\n    }\n    std::cout << setprecision(12) << fixed << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R, V, E;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tlong double r;\n\tvector<long double>ans;\n\tcin >> r >> N;\n\twhile (r>0.5) {\n\t\tmap<long double, long double>m;\n\t\tfor (long double j = -20; j <= 20; j+=0.5) {\n\t\t\tm[j] = 0;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a, b;\n\t\t\tlong double c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tfor (long double j = a; j <= b; j+=0.5) {\n\t\t\t\tm[j] = max(m[j], c);\n\t\t\t}\n\t\t}\n\t\tfor (long double i = -r + 0.5; i <= r - 0.5; i += 1) {\n\t\t\tm[i - 0.5] = min(m[i], m[i - 0.5]);\n\t\t\tm[i + 0.5] = min(m[i], m[i + 0.5]);\n\t\t}\n\t\tlong double ret = 10000;\n\t\tfor (int i = -r; i <= r; i++) {\n\t\t\tif (abs(i) > abs(r))continue;\n\t\t\tlong double box = sqrt(r*r - i * i);\n\t\t\tret = min(ret, m[i] - box + r);\n\t\t//\tcout << i << \" \" << m[i] << endl;\n\t\t}\n\t\tans.push_back(ret);\n\t\tcin >> r >> N;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << setprecision(20) << i << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\n\twhile (1) {\n\t\tdouble r;\n\t\tdouble center;\n\t\tdouble high;\n\t\tdouble answer = 20.0;\n\t\tdouble maxhigh = 0.0;\n\t\tint n;\n\t\tdouble xl[21] = {}, xr[21] = {}, h[21] = {};\n\n\t\tcin >> r >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> xl[i] >> xr[i] >> h[i];\n\t\t\tif (h[i] > maxhigh) {\n\t\t\t\tmaxhigh = h[i];\n\t\t\t}\n\t\t}\n\n\t\tanswer = maxhigh;\n\n\n\t\tfor (double i = 0; i <= maxhigh; i += 0.0001) {\n\t\t\tcenter = -r + i;\n\n\n\t\t\tfor (double j = -r; j <= r; j += 0.0001) {\n\t\t\t\thigh = sqrt(r*r - j * j) + center;\n\n\t\t\t\t\n\n\t\t\t\t//cout << center << \" \" << high << endl;\n\n\t\t\t\tFOR(k, 1, n) {\n\t\t\t\t\tif (xl[k] <= j && xr[k] >= j && high <= h[k]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (high <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (k == n) {\n\t\t\t\t\t\tanswer = i - 0.0001;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (answer != maxhigh) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (answer != maxhigh) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\", answer);\n\t}\n\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n#define MAX 100\ntypedef pair<int,int> pii;\ntypedef pair<double,pii> pp;\n\nint main(void) {\n    int R, N;\n    while (cin>>R>>N && R) {\n        vector<vector<int> > v(N, vector<int>(3));\n        vector<int> h(R*2+1);\n        for (int i = 0; i < N; i++) {\n            cin >> v[i][0] >> v[i][1] >> v[i][2];\n            if (v[i][0] > R || v[i][1] < -R) continue;\n            int l = max(v[i][0]+R, 0);\n            int r = min(v[i][1]+R , R*2+1);\n            for (int j = l; j < r; j++) h[j] = max(h[j], v[i][2]);\n        }\n        \n        double ans = 1e9;\n        for (int i = 0; i < R; i++) {\n            double x =sqrt(R*R - i*i);\n            ans = min(ans, 1.0*h[R-1-i]-x);\n            ans = min(ans, 1.0*h[R+i]-x);\n        }\n        printf(\"%.8lf\\n\",ans+R);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    while (par[x] != x)\n    {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\nint n;\nlong double r;\nint arr[50][50];\nint arr2[50];\nint tmp[50];\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n\n  while (cin >> r >> n)\n  {\n    if (r == 0 && n == 0)\n      break;\n\n    for (int i = 0; i < 50; i++)\n    {\n      arr2[i] = INT_MAX;\n      tmp[i] = 0;\n      for (int j = 0; j < 50; j++)\n        arr[i][j] = 0;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n      int xl, xr, h;\n      cin >> xl >> xr >> h;\n\n      xl += 21, xr += 21;\n\n      //cout << xl << \" \" << xr << endl;\n      for (int j = xl; j < xr; j++)\n      {\n        arr[j][j + 1] = max(arr[j][j + 1], h);\n      }\n\n      for (int j = xl; j <= xr; j++)\n      {\n        tmp[j] = max(tmp[j], h);\n      }\n    }\n\n    for (int i = 1; i < 50; i++)\n    {\n      arr2[i] = min(arr[i - 1][i], arr[i][i + 1]);\n      //cout << arr2[i] << \" \";\n    }\n    //cout << endl;\n\n    //太陽の中心は(21, 0)\n\n    long double mi = 1000000;\n    for (long double x = 21 - r; x <= r + 21; x += 1)\n    {\n      if (x == 21 - r)\n      {\n        long double t = (long double)(tmp[int(x)]) + r - sqrt(r * r - (x - 21) * (x - 21));\n        if (t < 0)\n          continue;\n        mi = min(mi, t);\n      }\n      else if (x == 21 + r)\n      {\n        long double t = (long double)(tmp[int(x)]) + r - sqrt(r * r - (x - 21) * (x - 21));\n        if (t < 0)\n          continue;\n        mi = min(mi, t);\n      }\n      else\n      {\n        long double t = (long double)(arr2[int(x)]) + r - sqrt(r * r - (x - 21) * (x - 21));\n        if (t < 0)\n          continue;\n        mi = min(mi, t);\n        //cout << x << \" \" << t << endl;\n      }\n    }\n    cout << mi << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,R;\n\twhile(cin>>R>>n,n){\n\t\tdouble l=-R,r;\n\t\tint ma=0;\n\t\tvi in(50,0);\n\t\twhile(n--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tloop(i,a,b)in[i+25]=max(in[i+25],c);\n\t\t}\n\t\tloop(i,1-R,R)ma=max(ma,in[i+25]);\n\t\tr=ma-R;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tbool q=true;\n\t\t\tloop(i,26-R,25+R){\n\t\t\t\tdouble dis=hypot(min(in[i],in[i-1])-h,i-25);\n//\t\t\t\tcout<<i-25<<\" \"<<dis<<endl;\n\t\t\t\tif(min(in[i],in[i-1])<h-R||dis+EPS<(double)R)q=false;\n\t\t\t}\n\t\t\tif(q)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.8f\\n\",l+R);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n#define INF 1145141145141919810.00000\nint t[100], s[100][100], v[100][2], r, n, a, b, c; double u[100], d, MINX;\nint main() {\n\twhile (true) {\n\t\tMINX = INF;\n\t\tmemset(u, INF, sizeof(u));\n\t\tmemset(s, 0, sizeof(s));\n\t\tmemset(t, 0, sizeof(t));\n\t\tmemset(v, 0, sizeof(v));\n\t\tcin >> r >> n; if (!r) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tfor (int i = a + 50; i < b + 50; i++) {\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\ts[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif (s[i][j] == 1) {\n\t\t\t\t\tv[i][0] = j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif (s[i - 1][j] == 1) {\n\t\t\t\t\tv[i][1] = j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[i] = min(v[i][0], v[i][1]);\n\t\t}\n\t\tfor (int i = 50 - r + 1; i <= 50 + r - 1; i++) {\n\t\t\td = sqrt(pow(r, 2) - pow(50 - i, 2));\n\t\t\tu[i] = t[i] + r - d;\n\t\t\tMINX = min(MINX, u[i]);\n\t\t}\n\t\tcout << fixed << setprecision(20) << MINX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-10;\n\n#define INF (1<<29)\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nmap<int, map<int, double>> height;\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  double r;\n  int n;\n  while (cin >> r >> n, r && n) {\n    height.clear();\n    int lx, rx, h;\n    int l_end = INF;\n    int r_end = -INF;\n    rep(i, n) {\n      cin >> lx >> rx >> h;\n      l_end = min(l_end, lx);\n      r_end = max(r_end, rx);\n      REP(j, lx, rx) {\n        height[j][j+1] = max(h, height[j][j+1]);\n      }\n    }\n\n    // simulation\n    double center = -r;\n    double step = 0.0001;\n    double ans = -step;\n    while (true) {\n      bool judge = true;\n      REP(i, l_end, r_end) {\n        int lx = i;\n        int rx = i + 1;\n        double h = height[lx][rx];\n        double dl = sqrt(fabs(h - center) * fabs(h - center) + abs(lx) * abs(lx));\n        double dr = sqrt(fabs(h - center) * fabs(h - center) + abs(rx) * abs(rx));\n        if (dl < r || dr < r) {\n          judge = false;\n          break;\n        }\n      }\n      if (!judge) break;\n      center += step;\n      ans += step;\n    }\n    cout << fixed << setprecision(4) << ans << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, R;\nbool fie[55][55];\nint dx[]={0,1,0};\nint dy[]={-1,0,1};\nbool used[55][55];\ntypedef complex<double> P;\nconst double EPS = 1e-8;\nbool check(int x,int y,int d){\n  if( 0 <= x && x <= 44 && 0 <= y && y <= 44 ){\n    if(!used[x][y]){\n      if( d == 0 ) return !fie[x-1][y] || !fie[x][y];\n      else if( d == 1 ) return !fie[x-1][y];\n      else return true;\n    }\n  }\n  return false;\n}\n\ndouble solve( P p,const vector<P>& ep ){\n  double x = abs(p.real()-22);\n  if( (int)x > R ) return -R;\n  P v = P(22, p.imag() - sqrt(R*R - x*x) );\n  for(int i=0;i<(int)ep.size();i++){\n    if( (double)R - EPS > abs( ep[i] - v ) ) return -R;\n  }\n  return v.imag();\n}\n\nint main(){\n  while( cin >> R >> N && (N|R) ){\n    double ra = R;\n    memset(fie,0,sizeof(fie));\n    for(int i=0;i<N;i++){\n      int xr,xl,h;\n      cin >> xr >> xl >> h;\n      xr+=22; xl+=22;\n      for(int j=xr;j<xl;j++)\n\tfor(int l=0;l<h;l++)\n\t  fie[j][l] = true;      \n    }\n    \n    memset(used,0,sizeof(used));\n    vector<P> ep;\n    int x=1,y=0;\n    while( !(x == 44 && y == 0) ){\n      used[x][y] = true;\n      ep.push_back( P( x, y ) );\n      for(int i=0;i<3;i++){\n\tint nx = x+dx[i], ny = y+dy[i];\n\tif( check(nx,ny,i) ){\t  \n\t  x = nx; y = ny;\n\t  break;\n\t}       \n      }\n    }\n\n    double res = -ra;\n    for(int i=0;i<(int)ep.size();i++){\n      res = max( res, solve(ep[i],ep) );      \n    }\n    printf(\"%.4lf\\n\", res + R );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint n,R;\ndouble h[50];//+20\ndouble hmax;\n\ndouble solve(double l,double r){//[l,r)\n\t//cout << \"--\" << l << \" \" << r << endl; \n\tif(r-l<0.00001) return l;\n\tdouble k = (l + r)/2;\n\tbool okflg = true;\n\tREP(i,(int)R+20){\n\t\tdouble x = (double) i - 20;\n\t\tif(abs(x) > R) continue;\n\t\tdouble y1 = sqrt(R*R - x*x);\n\t\tdouble y2 = sqrt(R*R - (x+1)*(x+1));\n\t\t//cout << y1+k-R << \" \" << h[i] << endl;\n\t\tif(y1 + k - R > h[i]|| y2 + k - R > h[i]) okflg = false;\n\t}\n\t//cout << \" \" << okflg << endl;\n\tif(okflg) return solve(k,r); \n\telse return solve(l,k);\n}\nint main(){\n\twhile(1){\n\t\tcin >> R >> n;\n\t\tif(n==0&&R==0) break;\n\t\tREP(i,50) h[i] = 0;\n\t\thmax = -1;\n\t\tREP(i,n){\n\t\t\tdouble a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tFOR(j,a+20,b+20) h[j] = max(h[j],c);\n\t\t\thmax = max(c,hmax);\n\t\t}\n\t\tcout << shosu(10) << solve(0,((double)hmax) + 0.001) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint r;\n\tint n;\n\twhile (cin >> r >> n, r){\n\t\tdouble hight[40] = {0};\n\t\tdouble suny[41];\n\t\tREP(i, 41)\n\t\t\tsuny[i] = -1e9;\n\t\tREP(i, 41){\n\t\t\tif (-r<=i - 20&&i-20<=r )\n\t\t\t\tsuny[i] = -(double)r + sqrt((double)r*(double)r - (double)(i - 20)*(double)(i - 20));\n\t\t}\n\t\tREP(i, n){\n\t\t\tint x, x2, h;\n\t\t\tcin >> x >> x2 >> h;\n\t\t\tREP(i,x2-x){\n\t\t\t\thight[x + 20+i] = max(hight[x + 20+i], (double)h);\n\t\t\t}\n\t\t}\n\t\tdouble mi = 100.0;\n\t\tREP(i, 41){\n\t\t\tif (abs(i - 20) <= r){\n\t\t\t\tif (i - 20==-r)\n\t\t\t\t\tmi = min(mi, hight[i] -suny[i]);\n\t\t\t\telse if (i - 20==r)\n\t\t\t\t\tmi = min(mi, hight[i-1] - suny[i]);\n\t\t\t\telse\n\t\t\t\t\tmi = min(mi, min(hight[i],hight[i-1]) - suny[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", mi);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n \n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\twhile(1){\n\t\tint n, b[42], x1, x2, h;\n\t\tdouble ans, r;\n\t\t\n\t\tcin >> r >> n;\n\t\tif (r==0 && n==0) break;\n\t\tREP(i,42) b[i] = 0;\n\t\t\n\t\tfor (int i=0; i<n; i++){\n\t\t\tcin >> x1 >> x2 >> h;\n\t\t\tfor (int j=x1+20; j<x2+20; j++){\n\t\t\t\tb[j] = max(b[j], h);\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = (double)INF;\n\t\tfor (int i=20-r; i<20+r; i++){\n\t\t\tint t = i - 20 + (i < 20);\n\t\t\t//cerr << r-sqrt(r*r-t*t) << endl;\n\t\t\tans = min(ans, (double)(r-sqrt(r*r-t*t)+b[i]));\n\t\t}\n\t\t\n\t\tprintf(\"%.4f\\n\", ans);\n\t\t\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) afor(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R-eps))return true;\n\telse return false;\n}\nbool out_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))>sq(R+eps))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(out_circle(c,x,y1)||out_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(out_circle(c,x1,y)||out_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<50;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R)return false;\n\tif(x<-R)return false;\n\tif(y1<c&&c<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R)return false;\n\tif(y<c-R)return false;\n\tif(x1<0.0&&0.0<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <map>\nusing namespace std;\nint r,n,L,R,h,i,x;int main(){while(cin>>r>>n,r){map<int,int> A,B;for(i=0;i<n;i++){cin>>L>>R>>h;for(x=L;x<=R;x++){if(x!=R)A[x]=max(A[x],h);if(x!=L)B[x]=max(B[x],h);}}float res=99;for(i=-r;i<=r-1;i++){res=min(res,min(r-sqrt(r*r-i*i)+A[i],r-sqrt(r*r-(i+1)*(i+1))+B[i+1]));}cout<<res<<\"\\n\";}}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\ntypedef long double ld;\ntypedef vector<ld> vd;\n\nconst ld EPS = 10e-10;\n\nld solve();\nbool search(const ld t, const ld r, vd& s);\n\nint main(void) {\n\t\n\twhile(true){\n\t\tld ans = solve();\n\t\tif( ans < 0.0 ) { break; }\n\t\tcout << fixed << setprecision(5) << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n\nbool search( const ld t, const ld r, vd& s ) {\n\n\tfor( int i = -20; i < 20; i++ ) {\n\n\t\tld d = (ld)i, e = (ld)(i+1);\n\t\tbool b[2] = {false,false};\n\n\t\t\n\t\tif(d>=-r+EPS&&d+EPS<=r)\n\t\t\tb[0] = sqrt(r*r-d*d)+t>r+s[i+20]+EPS;\n\t\tif(e>=-r+EPS&&e+EPS<=r)\n\t\t\tb[1] = sqrt(r*r-e*e)+t>r+s[i+20]+EPS;\n\n\t\tif( b[0]|b[1] ) {\n\t\t\t\treturn false;\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nld solve() {\n\n\t//????????¢?´¢\n\tld r, low, high, mid;\n\tint n, m;\n\tcin >> m >> n;\n\tif( m == 0 && n == 0 ) { return -1.0; }\n\tr = (ld)m;\n\n\tvd v(40,0.0);\n\n\tfor( int i = 0; i < n; i++ ) {\n\n\t\tint xl, xr;\n\t\tld h;\n\t\tcin >> xl >> xr >> h;\n\n\t\tfor( int j = xl+20; j < xr+20; j++ ) {\n\t\t\tif( v[j] < h ) {\n\t\t\t\tv[j] = h;\n\t\t\t}\n\t\t}\n\n\t}\n\tlow = 0.0;\n\thigh = 21.0;\n\n\t//low???????????????????????????\n\tfor( int i = 0; (i < 1000); i++ ) {\n\t\tmid = (high+low)/2.0;\n\t\tif( search(mid,r,v) ) {\n\t\t\tlow = mid;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn mid;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint r, n;\nint ph[30], mh[30];\n\nint main(){\t\n\twhile(scanf(\"%d%d\",&r,&n),r||n){\n\t\tmemset(ph,0,sizeof(ph));\n\t\tmemset(mh,0,sizeof(mh));\n\t\trep(i,n){\n\t\t\tint a, b, x;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&x);\n\t\t\tif(a < 0 && b > 0){\n\t\t\t\tfor(int j = 0; j < b; j++) ph[j] = max(ph[j],x);\n\t\t\t\tfor(int j = 0; j > a; j--) mh[-j] = max(mh[-j],x);\n\t\t\t} else if(a >= 0){\n\t\t\t\tfor(int j = a; j < b; j++) ph[j] = max(ph[j],x);\n\t\t\t} else{\n\t\t\t\tfor(int j = b; j > a; j--) mh[-j] = max(mh[-j],x);\n\t\t\t}\n\t\t}\n\t\tdouble s = 0.0, e = 100.0, mid;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tmid = (s+e)/2.0;\n\t\t\tif(mid > (double)min(ph[0],mh[0])){\n\t\t\t\te = mid;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tfor(int j = -1*r+1; j <= r-1; j++){\n\t\t\t\tif(j <= 0){\n\t\t\t\t\tif((double)mh[-j] < mid-(double)r){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((double)j*(double)j+((double)mh[-j]+(double)r-mid)*((double)mh[-j]+(double)r-mid) < (double)r*(double)r){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j >= 0){\n\t\t\t\t\tif((double)ph[j] < mid-(double)r){\n\t\t\t\t\t\tok  = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((double)j*(double)j+((double)ph[j]+(double)r-mid)*((double)ph[j]+(double)r-mid) < (double)r*(double)r){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) s = mid;\n\t\t\telse e = mid;\n\t\t}\n\t\tprintf(\"%.9f\\n\",s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nvoid solve(int n,int r){\n\tint le,ri,h;\n\tint right[21]={};\n\tint left[21]={};\n\tfor(int i=0;i<n;i++){\n\t\tcin >> le >> ri >> h;\n\t\tif(le<0&&ri<=0){\n\t\t\tfor(int j=-ri;j<-le;j++){\n\t\t\t\tleft[j] = max(left[j],h);\n\t\t\t}\n\t\t}else if(le<0&&ri>0){\n\t\t\tfor(int j=0;j<-le;j++){\n\t\t\t\tleft[j] = max(left[j],h);\n\t\t\t}\n\t\t\tfor(int j=0;j<ri;j++){\n\t\t\t\tright[j] = max(right[j],h);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=le;j<ri;j++){\n\t\t\t\tright[j] = max(right[j],h);\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=100.0;\n\tfor(int i=0;i<r;i++){\n\t\tans = min(ans,r-sqrt(r*r-i*i)+left[i]);\n\t\tans = min(ans,r-sqrt(r*r-i*i)+right[i]);\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\tint n,r;\n\twhile(1){\n\t\tcin >> r >> n;\n\t\tif(n==0&&r==0)break;\n\t\tsolve(n,r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int r, n;\n  int height[2][44];\n  while(cin >> r >> n, r || n) {\n    memset(height, 0, sizeof(height));\n    while(n--) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      for(int i = xl; i < xr; i++) height[0][i+22] = max(height[0][i+22], h);\n      for(int i = xr; i > xl; i--) height[1][i+22] = max(height[1][i+22], h);     \n    }\n    \n    double ans = 1 << 25;\n    for(int i = -r; i < r; i++) ans = min(ans, height[0][i+22] + r - sqrt(r*r - i*i));\n    for(int i = r; i > -r; i--) ans = min(ans, height[1][i+22] + r - sqrt(r*r - i*i));    \n    printf(\"%.4f\\n\", ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i-1] + r - sqrt(r*r - (i-r)*(i-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint buil[50] = {0};\ndouble sun[50] = {0.0};\n\nvoid sunset();\ndouble solve();\n\nint main() {\n  cout << fixed << setprecision(8);\n  int i, j, le, ri, he;\n  while(1) {\n    cin >> r >> n;\n    for(i = 0; i < 50; ++i) buil[i] = 0;\n    for(i = 0; i < 50; ++i) sun[i] = -99999;\n    sunset();\n    if(r + n == 0) break;\n    for(i = 0; i < n; ++i) {\n      cin >> le >> ri >> he;\n      for(j = le; j < ri; ++j)\n        buil[j + 22] = max(buil[j + 22], he);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nvoid sunset() {\n  int i;\n  double now;\n  for(i = 0; i <= r; ++i) {\n    if(i == 0)\n      now = 0;\n    else\n      now = sqrtl(r * r - i * i) - r;\n\n    sun[i + 22] = sun[22 - i] = now;\n  }\n}\n\ndouble solve() {\n  double answer = 10000;\n  for(int i = 22 - r; i <= 22 + r; ++i) {\n    if(i != 22 + r)\n      answer = min((double)buil[i] - sun[i], answer);\n    if(i != 22 - r)\n      answer = min((double)buil[i - 1] - sun[i], answer);\n  }\n  return answer;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\nstruct Point {\n\n\n    double x, y;\n\n    Point() {\n        x = 0;\n        y = 0;\n    }\n\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n\n    inline Point operator+=(double s) {\n        this->y += s;\n    }\n\n//    constexpr Point operator+(Point rhs) const {\n//        return {x + rhs.x, y + rhs.y};\n//    }\n//\n//    constexpr Point operator-(Point rhs) const {\n//        return {x - rhs.x, y - rhs.y};\n//    }\n\n};\n\ninline Point operator+(double s, Point p) {\n    return {p.x, s + p.y};\n}\n\n\nstruct Rect {\n\n    Point left;\n    Point right;\n\n    Rect() {\n\n    }\n\n    Rect(int left_x, int right_x, int y) {\n        left = Point(left_x, y);\n        right = Point(right_x, y);\n    }\n\n};\n\nbool isSection(Point point, Rect rect) {\n    if (rect.left.x <= point.x && point.x <= rect.right.x && point.y <= rect.left.y) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n\n    while (true) {\n        double r;\n        int n;\n        cin >> r >> n;\n\n        if (r == 0 && n == 0) {\n            break;\n        }\n\n        vector<Point> circlePoints(100000);\n        REP(i, circlePoints.size()) {\n            double x = -r + ((2.0 * r) * ((double) i / (double) circlePoints.size()));\n            double y = sqrt(r * r - x * x);\n            circlePoints[i] = Point(x, y);\n        }\n\n        vector<Rect> rects(n + 1);\n        REP(i, n + 1) {\n            if (i == n) {\n                rects[n] = Rect(-1000, 1000, 0);\n            } else {\n                int left, right, h;\n                cin >> left >> right >> h;\n                rects[i] = Rect(left, right, h);\n            }\n        }\n\n        double diff = 10;\n\n        bool plus = true;\n        while (diff > 0.000001) {\n            if (plus) {\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += diff;\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n                if (good) {\n                    continue;\n                } else {\n                    diff /= 2.0000;\n                    plus = false;\n                    // cout << diff;\n                }\n\n            } else {\n\n\n                //cout << \"here\";\n                REP(i, circlePoints.size()) {\n                    circlePoints[i] += (-diff);\n                }\n                vector<bool> goods(circlePoints.size(), false);\n\n                REP(i, rects.size()) {\n                    REP(j, circlePoints.size()) {\n                        if (goods[j] == false && isSection(circlePoints[j], rects[i])) {\n                            goods[j] = true;\n                        }\n                    }\n                }\n\n                bool good = true;\n                REP(i, goods.size()) {\n                    if (!goods[i]) good = false;\n                }\n\n\n                if (good) {\n                    diff /= 2.0000;\n                    plus = true;\n                    //cout << diff << endl;\n                } else {\n                    continue;\n                }\n            }\n        }\n\n        double largeY = -1;\n        REP(i, circlePoints.size()) {\n            largeY = max(largeY, circlePoints[i].y);\n        }\n\n\n//        double ans = floor_n(largeY, 4);\n        cout << fixed << setprecision(6) << largeY << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nint main() {\n\twhile (1) {\n\n\t\tint R, N; cin >> R >> N;\n\t\tif (!R)break;\n\t\tvector<int>heights(42,0);\n\t\t\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l, r, h; cin >> l >> r >> h;\n\t\t\tl += 21; r += 21;\n\t\t\tfor (int i = l; i < r; ++i) {\n\t\t\t\theights[i] = max(heights[i], h);\n\t\t\t}\n\t\t}\n\t\tvector<ld>times(41, 99999);\n\t\tfor (int i = 0; i < 41; ++i) {\n\t\t\tint dx = abs(i - 20);\n\t\t\tif (dx < R) {\n\t\t\t\tld dy = R-sqrtl(R*R - dx*dx);\n\t\t\t\ttimes[i] = min(heights[i+1],heights[i]) +dy;\n\t\t\t}\n\t\t}\n\t\tld ans = *min_element(times.begin(), times.end());\n\t\tcout << fixed<<setprecision(5)<<ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nvoid solve(int r, int n) {\n\tvector<int> interval_height(42, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tint left, right, h;\n\t\tcin >> left >> right >> h;\n\t\tfor (int j = left + 21; j < right + 21; j++) {\n\t\t\tif (interval_height[j] < h) {\n\t\t\t\tinterval_height[j] = h;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> height(r + 1, 0);\n\tfor (int i = 0; i < r; i++) {\n\t\tint left_min = min(interval_height[-i + 21 - 1], interval_height[-i + 21]);\n\t\tint right_min = min(interval_height[i + 21 - 1], interval_height[i + 21]);\n\t\theight[i] = min(left_min, right_min);\n\t}\n\n\tdouble t = 2 << 15;\n\tfor (int i = 0; i < r; i++) {\n\t\tdouble tt = height[i] + r - sqrt(r * r - i * i);\n\t\tif (tt < t) {\n\t\t\tt = tt;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(4) << t << endl;\n}\n\nint main() {\n\tint r, n;\n\twhile (cin >> r >> n && r && n) {\n\t\tsolve(r, n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint r, n, sl, sr, h; int height[40]; double sunrise[40];\n\n\twhile (true)\n\t{\n\t\tcin >> r >> n;\n\n\t\tif (r == 0 && n == 0) { break; }\n\n\t\tfor (int i = 0; i < 40; i++) { height[i] = 0; sunrise[i] = -50.0; }\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> sl >> sr >> h;\n\n\t\t\tfor (int j = sl; j < sr; j++)\n\t\t\t{\n\t\t\t\theight[j + 20] = max(h, height[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 20 - r; i < 20 + r; i++)\n\t\t{\n\t\t\tif (i < 20)\n\t\t\t{\n\t\t\t\tsunrise[i] = sqrt(r * r - (19 - i) * (19 - i)) - r;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsunrise[i] = sqrt(r * r - (i - 20) * (i - 20)) - r;\n\t\t\t}\n\t\t}\n\n\t\tdouble Answer = 100.0;\n\n\t\tfor (int i = 0; i < 40; i++)\n\t\t{\n\t\t\tAnswer = min(height[i] - sunrise[i], Answer);\n\t\t}\n\t\t\n\t\tcout << Answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ndouble f(double h, double r, double x) {\n    return h + r - sqrt(r*r - x*x);\n}\n\nint main() {\n    double r;\n    int n;\n    while (cin >> r >> n, (r != 0 || n != 0)) {\n        static const int OFFSET = 25;\n        vector<int> heights(50);\n        for (int i = 0; i < n; ++i) {\n            int left, right, height;\n            cin >> left >> right >> height;\n            for (int x = left; x < right; ++x)\n                heights[x+OFFSET] = max(heights[x+OFFSET], height);\n        }\n\n        double ans = HUGE_VAL;\n        for (int x = -r; x < r; ++x) {\n            double t;\n            if (x < 0)\n                t = f(heights[x+OFFSET], r, x+1);\n            if (x >= 0)\n                t = f(heights[x+OFFSET], r, x);\n            ans = min(ans, t);\n        }\n\n        cout << setprecision(20) << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1194\n//\n//  Created by 13B15237 on 2015/06/22.\n//  Copyright (c) 2015??´ 13B15237. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Rect {\n    int l, r;\n    int h;\n};\n\nstruct Point {\n    int x, y;\n};\n\nstruct Area {\n    bool table[21][41];\n    \n    void clear() {\n        for (int y = 0; y < 21; ++y) {\n            for (int x = -20; x < 21; ++x) {\n                table[y][x+20] = false;\n            }\n        }\n    }\n    \n    void draw(Rect rect) {\n        for (int y = 0; y < rect.h; ++y) {\n            for (int x = rect.l; x < rect.r; ++x) {\n                table[y][x + 20] = true;\n            }\n        }\n    }\n    \n    void show() {\n        for (int y = 20; y >= 0; --y) {\n            for (int x = -20; x < 21; ++x) {\n                cout << (table[y][x+20] == true ? '#' : '_');\n            }\n            cout << endl;\n        }\n    }\n    \n    bool test(int r, int t) {\n        const int ybegin = max(0, t - 2 * r);\n        const int yend = t;\n        \n        for (int y = ybegin; y < yend; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == false) return false;\n            }\n        }\n        return true;\n    }\n    \n    Point calcMinDistPoint(int r, int maxt) {\n        double mindist = 30.0;\n        Point p = {0, 0};\n        \n        for (int y = max(0, maxt - 2 * r); y < maxt; ++y) {\n            for (int x = -r; x < r; ++x) {\n                if (table[y][x+20] == true) continue;\n                \n                const int a = x < 0 ? abs(x + 1) : x;\n                const int b = y;\n                double dist = sqrt(a*a + b*b);\n                //printf(\"(%d, %d) = %f\\n\", x,y,dist);\n                \n                if (dist < mindist) {\n                    mindist = dist;\n                    p.x = x;\n                    p.y = y;\n                }\n            }\n        }\n        return p;\n    }\n};\n\nint R, N;\nvector<Rect> vrect;\nArea area;\n\nint main(int argc, const char * argv[]) {\n    while (1) {\n        cin >> R >> N;\n        if (!R && !N) break;\n        \n        area.clear();\n        vrect.clear();\n        vrect.resize(N);\n        for (auto r : vrect) {\n            cin >> r.l >> r.r >> r.h;\n            area.draw(r);\n        }\n        \n        //area.show();\n        \n        int tmax;\n        for (tmax = 0; tmax < 21; ++tmax) {\n            if (area.test(R, tmax) == false) break;\n        }\n        \n        /*\n        double t = static_cast<double>(tmax - 1);\n        while (1) {\n            double d = area.calcMinDist(R, t, tmax);\n            if (d < static_cast<double>(R)) break;\n            t += 0.001;\n        }\n         */\n        Point p = area.calcMinDistPoint(R, tmax);\n        const int dx = p.x < 0 ? abs(p.x + 1) : abs(p.x);\n        double dy = sqrt(R * R - dx * dx);\n        \n        \n        //cout << \"p = (\" << p.x << \", \" << p.y << \")\" << endl\n        //<< \"dy = \" << dy << \", R  = \" << R << endl;\n        double t = (double)(tmax - 1) + ((double)R - dy);\n        \n        printf(\"%.4f\\n\", t);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>R-eps)return false;\n\tif(x<-R+eps)return false;\n\tif(y1<c-eps&&c+eps<y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>c+R-eps)return false;\n\tif(y<c-R+eps)return false;\n\tif(x1<-eps&&eps<x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<100;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  double ans;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 41; ++i) V[i] = 0;\n    ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i-1] + r - sqrt(r*r - (i-r)*(i-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int r; //半径\n        int max=0;  //高さの最大値\n        int n;\n        cin >> r >> n;\n        int r_min = 0 - r; //半径のマイナス\n        double t=20.0;\n        int x_i[n],x_j[n],h[n];\n        for(int i=0;i<n;i++){\n            cin >> x_i[i] >> x_j[i] >> h[i];\n            if(max<h[i])    max=h[i];\n        }\n        int a[max][r+r];\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<max;j++){\n                for(int l=-r;l<r;l++){\n                    if(x_i[i]<=l && x_j[i]>l){\n                        if(h[i]>=j){\n                            a[j-1][l+r]++;\n                        }\n                    }\n                }\n            }\n        }\n        int count=0;\n        double u=0.0;\n        int min=10;\n        int h_a,x_a;\n        for(int i=0;i<max;i++){\n            for(int j=0;j<r+r;j++){\n                if(a[i][j]==0){\n                    if(j<r){\n                        if(min>i+(r-1)-j){\n                            min=i+(r-1)-j;\n                            h_a=i;\n                            x_a=(r-1)-j;\n                        }\n                    }else{\n                        if(min>i+j-r){\n                            min=i+j-r;\n                            h_a=i;\n                            x_a=j-r;\n                        }\n                    }\n                }\n            }\n        }\n        t=(double)r-sqrt(r*r-x_a*x_a)+(double)h_a;\n        printf(\"%.4f\",t);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n, r, h, V[41], xl, xr;\n  while(cin >> r >> n, r){\n    for(int i = 0; i < 2*r+1; ++i) V[i] = 0;\n    double ans = 20.0;\n    for(int i = 0; i < n; ++i){\n      cin >> xl >> xr >> h;\n      for(int j = xl; j < xr; ++j){\n\tif(j > r) break;\n\tV[j+r] = max(h, V[j+r]);\n      }\n      if(xr == r) V[2*r] = max(V[2*r],h);\n    }\n    for(int i = 0; i < 2*r+1; ++i){\n      ans = min(ans, V[i] + r - sqrt(r*r - (i-r)*(i-r)));\n      if(i+1-r <= r) ans = min(ans, V[i] + r - sqrt(r*r - (i+1-r)*(i+1-r)));\n      if(abs(i-1-r) <= r) ans = min(ans, V[i-1] + r - sqrt(r*r - (i-r)*(i-r)));\n    }\n    printf(\"%.4lf\\n\", ans);\n  }\t\t\t     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\n    for(int R, N; cin >> R >> N, R;){\n        map<int, int>H;\n        for(int i = 0; i < N; i++){\n            int l, r, h;\n            cin >> l >> r >> h;\n            for(int x = l; x < r; x++){\n                H[x] = max(H[x], h);\n            }\n        }\n        double ans = 1234567;\n        for(int X = -R; X < R; X++){\n            int x = X;\n            if(X < 0)x++;\n            double bottom = R - sqrt(R * R - x * x);\n            ans = min(ans, H[X] + bottom);\n        }\n        printf(\"%.9f\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nbool is[40][21];\ndouble eps=1e-9;\nint main(){\n\twhile(true){\n\t\tint r,n;\n\t\tcin>>r>>n;\n\t\tif(n==0) break;\n\t\trep(i,40) rep(j,21) is[i][j]=0;\n\t\trep(i,n){\n\t\t\tint a,b,h;\n\t\t\tcin>>a>>b>>h;\n\t\t\ta+=20,b+=20;\n\t\t\tfor(int x=a;x<b;x++) rep(y,h) is[x][y]=true;\n\t\t}\n\t\tvector<double> vc;\n\t\trep(x,r) rep(y,21){\n\t\t\tif(x*x>=r*r) continue;\n\t\t\tdouble t=y-sqrt(r*r-x*x);\n\t\t\tvc.pb(t);\n\t\t}\n\t\tsort(all(vc));\n\t\trep(i,vc.size()){\n\t\t\tdouble h=vc[i];\n\t\t\tbool can=true;\n\t\t\tfor(int x=-r;x<r;x++) rep(y,21){\n\t\t\t\tif(is[x+20][y]) continue;\n\t\t\t\tif(x*x+(y-h)*(y-h)<r*r+eps) can=false;\n\t\t\t\tif((x+1)*(x+1)+(y-h)*(y-h)<r*r+eps) can=false;\n\t\t\t}\n\t\t\tif(!can){\n\t\t\t\tprintf(\"%.4f\\n\",h+r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cmath>\n#include <climits>\n//#include \"h.h\"\nusing namespace std;\n\n#define ll long long\n#define pint pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mp make_pair\n#define pm(first, second) pb(mp(first, second))\n#define SPACE \" \"\n#define fpf first.first\n#define fps first.second\n#define spf second.first\n#define sps second.second\n\n#define all(X) (X).begin(), (X).end()\n\nint main(){\n\n\twhile(true){\n\t\tint R, N;\n\t\tcin >> R >> N;\n\t\tif(R == 0 && N == 0)break;\n\t\tdouble r = (double)R;\n\n\t\tint xl, xr;\n\t\tdouble h;\n\t\tvector<double> H(40, 0.0);\n\t\tfor(int i = 0; i < N; i ++){\n\t\t\tcin >> xl >> xr >> h;\n\t\t\tfor(int j = xl; j < xr; j ++){\n\t\t\t\tH[j + 20] = max(H[j + 20], h);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1000.0;\n\t\tfor(int i = -R; i < R; i ++){\n\t\t\t//t = 0のときの太陽の高いほうのy座標(幅が[i,i+1]の中で)\n\t\t\tdouble sun_edge_high = max(sqrt(r * r - (double)(i * i)), sqrt(r * r - (double)((i + 1) * (i + 1)))) - r;\n\t\t\tans = min(ans, H[i + 20] - sun_edge_high);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n\nint dx[3] = { 0,1,0 };\nint dy[3] = { -1,0,1 };\n// dir: ??????0, ??????1, ??????2\nvoid kado_mituketu(int x,int y,vector<pair<int, int>>& kado, bool grid[80][80],int dir) {\n\tif (x >= 61) {\n\t\tkado.push_back({ x,y + 1 });\n\t\treturn;\n\t}\n\tfor (int i = 2; i >= 0;i--) {\n\t\tif (i == 2 && dir == 0)continue;\n\t\tif (grid[x + dx[i]][y + dy[i]] == true) {\n\t\t\tif (dir != i) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (dir != 0) { kado.push_back({ x,y + 1 }); }\n\t\t\t\t\telse { kado.push_back({ x + 1,y + 1 }); }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (dir == 2) { kado.push_back({ x,y + 1 }); }\n\t\t\t\t\tkado.push_back({ x + 1,y + 1 });\n\t\t\t\t}\n\t\t\t\tdir = i;\n\t\t\t}\n\t\t\tkado_mituketu(x + dx[i], y + dy[i], kado, grid, dir);\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint r, n;\n\twhile (cin >> r >> n, r | n) {\n\t\tbool grid[80][80] = { false };\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint xl, xr, h; cin >> xl >> xr >> h;\n\t\t\tfor (int x = xl; x < xr;x++) {\n\t\t\t\tfor (int hh = 0;hh < h;hh++) {\n\t\t\t\t\tgrid[40 + x][40+hh] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 42;i++) grid[19 + i][39] = true;\n\t\tvector<pair<int, int>> kado;\n\t\tkado.push_back({ 20,40 });\n\t\tkado_mituketu(20,39,kado, grid, 1);\n\t\tdouble maxh = -1;\n\t\tfor (int h = -1; h <= 22;h++) {\n\t\t\tif (grid[40][40 + h]) maxh = max(maxh, (double)(h + 1));\n\t\t\tif (grid[39][40 + h])maxh = max(maxh, (double)(h + 1));\n\t\t}\n\t\tfor (int i = 0; i < kado.size();i++) {\n\t\t\tkado[i].first -= 40;kado[i].second -= 40;\n\t\t}\n\t\tdouble low = -r, up = maxh;\n\t\tfor(int i = 0; i < 100;i++){\n\t\t\tdouble mid = (low + up) / 2;\n\t\t\tCircle cir(Point(0, mid), r);\n\t\t\tbool f = false;\n\t\t\tfor (int i = 0; i < kado.size() - 1;i++) {\n\t\t\t\tLine line(Point(kado[i].first, kado[i].second), Point(kado[i + 1].first, kado[i + 1].second));\n\t\t\t\tauto pp = is_sc(cir, line);\n\t\t\t\tif (pp.size() == 0) continue;\n\t\t\t\tbool ff = false;\n\t\t\t\tfor (auto p : pp) {\n\t\t\t\t\tif ((p.imag() - mid) > eps) {\n\t\t\t\t\t\tup = mid;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tff = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ff) break;\n\t\t\t}\n\t\t\tif (f) continue;\n\t\t\tlow = mid;\n\t\t}\n\t\tcout << fixed << setprecision(6) << low + r << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define SZ 20\n\nint mat[SZ+1][2*SZ+1];  //no-shade:0, shade:plus, mat[height][width+20]\n\nint main(){\n  int r,n;\n  while(scanf(\"%d %d\",&r,&n), r|n){\n\n    // initialize\n    rep(i,SZ+1){\n      rep(j,2*SZ+1){\n\tmat[i][j]=0;\n      }\n    }\n\n    // input provess for imosu\n    rep(i,n){\n      int xl, xr, h;\n      scanf(\"%d %d %d\", &xl, &xr, &h);\n      mat[0][xl+20]++;\n      mat[0][xr+20]--;\n      mat[h][xl+20]--;\n      mat[h][xr+20]++;\n    }\n    \n    // imosu\n    rep(i,SZ){\n      repl(j,1,2*SZ){\n\tmat[i][j] += mat[i][j-1];\n      }\n    }\n    rep(i,2*SZ){\n      repl(j,1,SZ){\n\tmat[j][i] += mat[j-1][i];\n      }\n    }\n\n    // move sun from bottom\n    int t=0;\n    int w;\n    while(t<20){\n      w=0;\n      while(w<r){\n\tif(mat[t][20+w]>0 && mat[t][19-w]>0){\n\t  w++;\n\t}else{\n\t  break;\n\t}\n      }\n      if(w==r) t++;\n      else break;\n    }\n\n    if(t==20){\n      printf(\"20.0000\\n\");\n      continue;\n    }\n\n    double res = sqrt(r*r-w*w);\n    res = (double)(t+r) - res;\n\n    printf(\"%.4f\\n\", res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      ans = min(ans, t);\n    }\n    printf(\"%.4lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ndouble w[2][44];\ndouble s[44];\nint r;\nint n;\nint x1, x2, h;\ndouble nkr;\ndouble a[3];\n\nmain(){\n\twhile (cin >> r >> n, r || n){\n\t\tnkr = -1;\n\t\tfor (int i = 0; i<2; i++)for (int j = 0; j<44; j++) w[i][j] = 0;\n\n\t\tfor (int i = 0; i<n; i++){\n\t\t\tcin >> x1 >> x2 >> h;\n\n\t\t\tif (w[0][x2 + 20]<h || w[0][x2 + 20] == 0) w[0][x2 + 20] = h;\n\t\t\tif (w[1][x1 + 20]<h || w[1][x1 + 20] == 0) w[1][x1 + 20] = h;\n\t\t\tfor (int j = x1 + 21; j<x2 + 20; j++){\n\t\t\t\tif (w[0][j]<h || w[0][j] == 0) w[0][j] = h;\n\t\t\t\tif (w[1][j]<h || w[1][j] == 0) w[1][j] = h;\n\t\t\t}\n\n\t\t}\n\n\t\tnkr = w[1][20 - r] + r;\n\t\tfor (int i = r*(-1) + 1; i<r; i++){\n\t\t\ts[i + 20] = sqrt(r*r - i*i) - r;\n\t\t\tif (w[0][i + 20] - s[i + 20]<nkr) nkr = w[0][i + 20] - s[i + 20];\n\t\t\tif (w[1][i + 20] - s[i + 20]<nkr) nkr = w[1][i + 20] - s[i + 20];\n\t\t}\n\t\tif (w[0][20 + r] + r<nkr) nkr = w[0][20 + r] + r;\n\n\n\n\t\tprintf(\"%.4f\\n\", nkr);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int r, n;\n  int height[44];\n  while(cin >> r >> n, r || n) {\n    memset(height, 0, sizeof(height));\n    while(n--) {\n      int xl, xr, h; cin >> xl >> xr >> h;\n      for(int i = xl; i < xr; i++) height[i+22] = max(height[i+22], h);\n    }\n    double ans = 1 << 25;\n    for(int i = -r; i < r; i++) ans = min(ans, height[i+22] + r - sqrt(r*r - i*i));\n    printf(\"%.4f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint r, n, xl, xr, h;\n\nint main(void) {\n  while(cin >> r >> n, r && n) {\n    map<pii, bool> m;\n    int mh = 0;\n    REP(i, 0, n) {\n      cin >> xl >> xr >> h;\n      REP(j, 0, h) REP(k, xl, xr) m[pii(j, k)] = true;\n      mh = max(mh, h);\n    }\n\n    // REP(i, 0, mh) {\n    //   REP(j, -r, r) {\n    //     cout << (m[pii(i, j)] ? 1 : 0);\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n\n    int y, x;\n    REP(i, 0, mh) {\n      REP(j, -r, r) {\n        if(!m[pii(i, j)]) {\n          y = i;\n          x = j;\n          goto BREAK;\n        }\n      }\n    }\nBREAK:\n\n    if(x < 0) x = -x - 1;\n    // cout << y << \" \" << x << endl;\n\n    double t = y - sqrt(r * r - x * x) + r;\n    cout << max(0.0, t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define USE_CPP11\n// #define USE_PRINTF\n\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <numeric>\n#include <complex>\n#include <memory>\n#include <sstream>\n\n#ifdef USE_CPP11\n#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#endif\n\n#define PRINT(obj) cout << obj << endl\n#define REP(i, n) for(int (i) = 0; (i) < (n); i++)\n#define SPACE \" \"\n\ntypedef long long ll;\n\nconst int INF = 1e9 + 10;\n\nusing namespace std;\n\nnamespace Scanner {\n#ifdef USE_PRINTF\n  int    nextInt()    { int    d; scanf(\"%d\" , &d); return d; }\n  float  nextFloat()  { float  f; scanf(\"%f\" , &f); return f; }\n  double nextDouble() { double f; scanf(\"%lf\", &f); return f; }  \n  string nextString() { string s; scanf(\"%s\" , &s); return s; }\n  ll     nextll()     { ll     l; scanf(\"%ll\", &l); return l; }\n#else\n  int    nextInt()    { int    d; cin >> d; return d; }\n  float  nextFloat()  { float  f; cin >> f; return f; }\n  double nextDouble() { double f; cin >> f; return f; }  \n  string nextString() { string s; cin >> s; return s; }\n  ll     nextll()     { ll     l; cin >> l; return l; }\n#endif\n\n  string getLine() { \n    string input;\n    getline(cin, input);\n    return input;\n  }\n};\n\nnamespace myLibrary {\n  vector<string> split(const string& str, char delim) {\n    vector<string> ret;\n    size_t current = 0, found;\n    while ((found = str.find_first_of(delim, current)) != string::npos) {\n      ret.push_back(string(str, current, found - current));\n      current = found + 1;\n    }\n    ret.push_back(string(str, current, str.size() - current));\n    return ret;\n  }\n  \n#ifdef USE_CPP11\n  ///\n  /// higher-order functional\n  /// This is something like map in haskell, python, etc.\n  /// Sample usage:\n  ///   vector<int> a = {1, 2, 3, 4, 5};\n  ///   vector<int> b = myLibrary::_Map<int, int>(a, [](int n){\n  ///     return n * n;\n  ///   });\n  /// Result:\n  ///   b = 1, 4, 9, 16, 25\n  ///\n  template<typename T_IN, typename T_OUT, class Functor>\n  vector<T_OUT> _Map(vector<T_IN> src, Functor func) {\n    vector<T_OUT> ret;\n    for (int i = 0; i < src.size(); i++) {\n      ret.push_back(func(src[i]));\n    }\n    return ret;\n  }\n#endif\n\n};\n\nstruct Point {\npublic:\n  int y, x;\n  Point(int y, int x): y(y), x(x) { }\n  Point() { }\n};\n\n/// BEGIN //////////////////////////////////////////////////////////\n\nint main() {\n\n  while (true) {\n    int r = Scanner::nextInt();\n    int n = Scanner::nextInt();\n\n    if (r + n == 0) {\n      break;\n    }\n\n    int height[41] = { 0 };\n\n    int ymax = 0;\n    for (int i = 0; i < n; i++) {\n      int xl = Scanner::nextInt() + 20;\n      int xr = Scanner::nextInt() + 20;\n      int h  = Scanner::nextInt();\n\n      ymax = max(ymax, h);\n      for (int x = xl; x < xr; x++) {\n        height[x] = max(height[x], h);\n      }      \n    }  \n\n    double lt = 0, ht = ymax;\n\n    for (int i = 0; i < 100; i++) {\n      double mt = (lt + ht) / 2;\n      double y = mt - r;\n\n      bool isOK = true;\n\n      for (int i = 1; i < 41; i++) {\n        double dsq = 0;\n        if (i < 20) {\n          dsq = (i - 19) * (i - 19) + (height[i] - y) * (height[i] - y);\n        } else {\n          dsq = (i - 20) * (i - 20) + (height[i] - y) * (height[i] - y);\n        }\n        if (dsq < r * r) {\n          isOK = false;\n          break;\n        }\n      }\n\n      if (isOK) {\n        lt = mt;\n      } else {\n        ht = mt;\n      }\n    }\n\n    printf(\"%.15f\\n\", ht);\n\n  }\n\n  return 0;\n}\n\n/// END   //////////////////////////////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint r,n,L,R,h,i,x;\n\nint main(){\n\t\n\twhile(cin>>r>>n,r){\n\n\t\t\n\t\tint A[41]={},B[41]={};\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>L>>R>>h;\n\t\t\tfor(x=L;x<=R;){\n\t\t\t\tif(x!=R)A[x+20]=max(A[x+20],h);\n\t\t\t\tif(x!=L)B[x+20]=max(B[x+++20],h);\n\t\t\t}\t\n\t\t}\n\t\tdouble res=99;\n\t\tfor(i=-r;i<=r-1;){\n\t\t\tres=min(res,min(r-sqrt(r*r-i*i)+A[i+20],r-sqrt(r*r-(i+1)*(i+1))+B[i+++1+20]));\n\t\t}\n\t\tcout<<res<<\"\\n\";\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194&lang=jp\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<iomanip>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint r, n;\nmap<int,map<int,double>> height;\n\nbool judge(double base) {\n\tREP(x, -r, r) {\n\t\tdouble y = height[x][x+1] - base;\n\t\tif(x*x + y*y < r*r) {\n\t\t\treturn true;\n\t\t}\n\t\tif((x+1)*(x+1) + y*y < r*r) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcout << setprecision(5) << fixed;\n\t\n\twhile(cin >> r >> n, r != 0) {\t\n\t\theight.clear();\n\t\tdouble lx, rx, h;\n\t\trep(i, n) {\n\t\t\tcin >> lx >> rx >> h;\n\t\t\tREP(x, lx, rx) {\n\t\t\t\theight[x][x+1] = max(h, height[x][x+1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool is_dead=false;\n\t\tdouble base = -r;\n\t\tdouble t = 0.0, step=0.0001;\n\t\twhile(true) {\n\t\t\tbase += step; \n\t\t\tbool is_dead = judge(base);\n\t\t\tif(is_dead) break;\n\t\t\tt += step;\n\t\t}\n\n\t\tcout << t << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint pos(int n){\n\treturn n+50;\n}\nvoid mainmain(){\n\tint n,r;\n\twhile(cin>>r>>n,n||r){\n\t\tdouble rr=r;\n\t\tvint v1(100,0);\n\t\tvint v2(100,0);\n\t\trep(i,n){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\treep(j,a,b+1){\n\t\t\t\tif(j-a){\n\t\t\t\t\tif(v1[pos(j)]==0){\n\t\t\t\t\t\tv1[pos(j)]=c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tv1[pos(j)]=max(v1[pos(j)],c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j-b){\n\t\t\t\t\tif(v2[pos(j)]==0){\n\t\t\t\t\t\tv2[pos(j)]=c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tv2[pos(j)]=max(v2[pos(j)],c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans=1e200;\n\t\treep(i,-r,r+1){\n\t\t\tdouble h=-rr+sqrt(rr*rr-pow(abs(i),2));\n\t\t\t// cout<<i<<\" \"<<LDcout(h,10)<<endl;\n\t\t\t// cout<<v1[pos(i)]<<\" \"<<v2[pos(i)]<<endl;\n\t\t\tint mx=1e8;\n\t\t\tif(r+i) mx=min(mx,v1[pos(i)]);\n\t\t\tif(r-i) mx=min(mx,v2[pos(i)]);\n\t\t\tans=min(ans,mx-h);\n\t\t}\n\t\tcout<<LDcout(ans,10)<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(0);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int R, N;\n  while (cin >> R >> N && R + N ){\n    vector<int> LS(N);\n    vector<int> RS(N);\n    vector<int> HS(N);\n    \n    map<int, int> C[30];\n    \n    REP(i, N){\n      cin >> LS[i] >> RS[i] >> HS[i];\n      \n      REP2(j, LS[i], RS[i]){\n        REP(k, HS[i]){\n          C[k][j] = true;\n        }\n      }\n    }\n\n    // cout << C[3][0] << endl;\n    \n    vector<pair<int, int> > PS;\n    \n    REP2(x, -30, 30) REP(y, 25){\n      if (abs(x) >= R) continue;\n\n      bool ok = true;\n      REP(j, N) if (LS[j] < x && x < RS[j] && HS[j] > y){\n        ok = false;\n      }\n      \n      if (ok && (!C[y][x - 1] ||!C[y][x])){\n        // cout << x << \" \" << y << endl;\n         PS.push_back(make_pair(x, y));  \n      }\n      \n    }\n    \n    double res = 1e9;\n    for (auto p : PS){\n      res = min(res, R + p.second - sqrt(R * R - p.first * p.first));\n      // cout << p.first << \" \" << p.second << \" \" << res << endl;\n    }\n    printf(\"%.4lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint r,n;\ndouble R;\nconst int geta = 30;\nint h[100];\nbool in_circle(double c,double x,double y){\n\tif(sq(abs(y-c))+sq(abs(x))<sq(R))return true;\n\telse return false;\n}\nbool inter_vert(double c,double x,double y1,double y2){\n\tif(x>=R)return false;\n\tif(x<=-R)return false;\n\tif(y1<=c&&c<=y2){\n\t\tif(!in_circle(c,x,y1)||!in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x,y1)!=in_circle(c,x,y2))return true;\n\t\telse return false;\n\t}\n}\nbool inter_hori(double c,double y,double x1,double x2){\n\tif(y>=c+R)return false;\n\tif(y<=c-R)return false;\n\tif(x1<=0.0&&0.0<=x2){\n\t\tif(!in_circle(c,x1,y)||!in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}else{\n\t\tif(in_circle(c,x1,y)!=in_circle(c,x2,y))return true;\n\t\telse return false;\n\t}\n}\nbool check(double t){\n\tif(t-2.0*R>h[0])return true;\n\tfor(int i=-20;i<20;i++){\n\t\tif(inter_hori(t-R,(double)h[i+geta],(double)i+eps,(double)(i+1)-eps)){\n\t\t\t//cout << h[i+geta] << ' '  << i << ' ' << i+1 << endl;\n\t\t\treturn true;\n\t\t}\n\t\tif(h[i+geta]!=h[i+1+geta]){\n\t\t\tint y1 = min(h[i+geta],h[i+1+geta]);\n\t\t\tint y2 = max(h[i+geta],h[i+1+geta]);\n\t\t\tif(inter_vert(t-R,(double)(i+1),(double)y1+eps,(double)y2-eps)){\n\t\t\t\t//cout << i+1 << ' ' << y1 << ' ' << y2 << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve(){\n\tcin >> r >> n;\n\tR = r;\n\tmemset(h,0,sizeof(h));\n\tif(r==0&&n==0)return false;\n\tint l,r,hi;\n\tint highest = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> l >> r >> hi;\n\t\tfor(int j=l;j<r;j++){\n\t\t\thighest = max(highest,hi);\n\t\t\th[j+geta]=max(h[j+geta],hi);\n\t\t}\n\t}\n\tdouble low = 0.0, high = highest;\n\tfor(int i=0;i<20;i++){\n\t\t//printf(\"%.5f %.5f\\n\",low,high);\n\t\tdouble mid = (low+high)/2.0;\n\t\tif(check(mid))high = mid;\n\t\telse low = mid;\n\t}\n\tprintf(\"%.12f\\n\",low);\n\treturn true;\n}\nint main (){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint r, n;\nint _h[40], h[20];\n\ndouble calc()\n{\n\tconst auto PI = acos(-1.0);\n\tdouble res = 1e8;\n\tfor (int i = 0; i < 20; i++){\n\t\tdouble height = i < r ? sqrt(r * r - i * i) - r : -1e8;\n\t\tres = min(res, h[i] - height);\n\t}\n\treturn max(0.0, res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &r, &n), n){\n\t\tmemset(_h, 0, sizeof(_h));\n\t\tmemset(h, 0, sizeof(h));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tfor (int j = a + 20; j < b + 20; j++){\n\t\t\t\t_h[j] = max(_h[j], c);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 20; i++){\n\t\t\th[i] = min(_h[i + 20], _h[19 - i]);\n\t\t}\n\t\t\n\t\tprintf(\"%.20f\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\n\nconst int OFFSET=50;\nconst ld INF=1e4;\n\nld solve(int r,int n,vector<int> &rh){\n  ld t=INF;\n  for(int i=1;i<OFFSET*2;++i){\n    int x=i-OFFSET;\n    if(x<=-r || r<=x) continue;\n    int h=min(rh[i-1],rh[i]);\n    ld y=sqrt(r*r-x*x);\n\n\n    t=min(h-y,t);\n  }\n  return t+r;\n}\n\t \nint main(){\n  int r,n;\n  cout<<setprecision(10)<<fixed;\n  while(cin>>r>>n,r){\n    vector<int> xl(n);\n    vector<int> xr(n);\n    vector<int> h(n);\n    for(int i=0;i<n;i++){\n      cin>>xl[i]>>xr[i]>>h[i];\n    }\n    vector<vector<int>> f(30,vector<int>(OFFSET*2,0));\n    for(int i=0;i<n;i++){\n      for(int j=xl[i];j<xr[i];j++){\n\tfor(int k=0;k<h[i];k++){\n\t  f[k][j+OFFSET]=true;\n\t}\n      }\n    }\n\n    vector<int> rh(OFFSET*2,0);\n    for(int i=0;i<OFFSET*2;i++){\n      for(int j=29;j>=0;j--){\n\tif(f[j][i]){\n\t  rh[i]=j+1;\n\t  break;\n\t}\n      }\n    }\n    cout<<solve(r,n,rh)<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\n    while(true){\n\n        double r;\n        int n;\n\n        cin >> r >> n;\n\n        if(r == 0.0 && n == 0){\n            break;\n        }\n\n        int x[41] = {0};\n\n        for(int i=0; i<n; i++){\n            int lx,ly,h;\n\n            cin >> lx >> ly >> h;\n\n            for(int i=20+lx; i<20+ly; i++){\n                x[i] = max(x[i],h);\n            }\n        }\n\n        double ans = 0.0000;\n\n        while(true){\n\n            double survey = ans + 0.0001;\n\n            bool flag = true;\n\n            for(int i=-20; i<=20; i++){\n                double d_x = static_cast<double>(i);\n                if(r*r > d_x*d_x){\n                    double h = sqrt(r*r - d_x*d_x) + survey - r;\n                    if(h > x[i+20] || h > x[i+20 -1]){\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n\n            if(!flag){\n                break;\n            }\n\n            ans += 0.0001;\n\n        }\n\n        cout << fixed << setprecision(4) << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS 1e-12\n\nint _h[100], *h = &_h[50];\nint R, N;\nbool f(double y, int x) {\n\tint xx = x < 0 ? x+1 : x;\n\tdouble yy = sqrt(R*R - xx*xx) + y - R;\n\treturn yy <= h[x] + EPS;\n}\nbool f(double y) {\n\tfor (int dx = 0; dx < R; ++dx) {\n\t\tif ( !f(y, dx) || !f(y, -dx-1) ) return false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> R >> N, R || N) {\n\t\tfill(&_h[0], &_h[0]+100, 0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l, r, y; cin >> l >> r >> y;\n\t\t\tfor (int j = l; j < r; ++j) h[j] = max(h[j], y);\n\t\t}\n\t\tdouble l = 0, r = 20;\n\t\tfor (int t = 0; t < 100; ++t) {\n\t\t\tdouble m = (l + r) / 2;\n\t\t\tif ( f(m) ) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%.10f\\n\", l);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define ios() ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int,int>;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll INF = 1LL << 60;\nconstexpr int Inf = 1e9;\ninline int in() {int x; cin >> x; return x;}\ntemplate <typename T> inline void out(const T& x) {cout << x << endl;}\ntemplate <class T> inline bool chmin(T &a, T b){if (a > b){a = b;return 1;}return 0;}\ntemplate <class T> inline bool chmax(T &a, T b){if (a < b){a = b;return 1;}return 0;}\n//UP = 0;RIGHT = 1; DOWN = 2; LEFT =3;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b)\n{\n  if (a < b)\n    gcd(b, a);\n  int r;\n  while ((r = a % b))\n  {\n    a = b;\n    b = r;\n  }\n  return b;\n}\nvoid eratos(bool * isPrime,int max){\n  fill(isPrime,isPrime + max,true);\n  isPrime[0] = false; \n  isPrime[1] = false; \n  for(int i=2; i<=max/i; ++i) \n      if(isPrime[i]) \n          for(int j=2; j<=max/i; ++j) \n              isPrime[i*j] = false;    \n}\n//\n\nsigned main()\n{\n  ios();\n  while(true)\n  {\n    int r;\n    int n;\n    cin >> r >> n;\n    if(r + n == 0) break;\n    int h[42] = {0};\n    for(int i = 0;i<n;i++)\n    {\n      int l,r,hi;\n      cin >> l >> r>> hi;\n      for(int j = l+1 ; j <= r;j++)\n      {\n        chmax(h[j+20],hi);\n      }\n    }\n    double t_min = 1e9;\n    for(int i = 0;i<41;i++)\n    {\n      if(r * r - (i-20)*(i-20) <=0) continue;\n      if(h[i+1] > h[i]) \n      {\n        double tmp = h[i]-sqrt(r * r - (i-20)*(i-20)) +r;\n        chmin<double>(t_min,tmp);\n      }\n      \n\n      if(h[i+1] < h[i]) \n      {\n        double tmp = h[i+1]-sqrt(r * r - (i-20)*(i-20)) +r;\n        chmin<double>(t_min,tmp);\n      }\n\n    }\n    chmin<double>(t_min,min(h[20],h[21]));\n    cout << t_min << endl;\n  }\n  \n  \n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      //printf(\"%lf %lf %lf\\n\", my, dx, t);\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1194: Vampire\n// 2017.9.14 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-7\n#define INF 4096\n#define BASE 30\nint hi[60];\nint r;\n\ndouble tim(int x, int h)\n{\n\tx -= BASE; if (x < 0) x++;\n\tif (x > r || x < -r) return INF;  \n\treturn h+r-sqrt((double)(r*r-x*x));\n}\n\nint main()\n{\n\tint n, x, x1, x2, h;\n\tdouble min, t;\n\n\twhile (scanf(\"%d%d\", &r, &n) && r) {\n\t\tmemset(hi, 0, sizeof(hi));\n\t\twhile (n-- > 0) {\n\t\t\tscanf(\"%d%d%d\", &x1, &x2, &h); x1 += BASE, x2 += BASE;\n\t\t\tfor (x = x1; x < x2; x++) if (hi[x] < h) hi[x] = h;\n\t\t}\n\t\tmin = INF;\n\t\tfor (x = BASE-r; x < BASE+r; x++) {\n\t\t\tt = tim(x, hi[x]);\n\t\t\tif (fabs(t) <= EPS) { min = 0; break; }\n\t\t\tif (min-t > EPS || t <= min) min = t;\n\t\t}\n\t\tprintf(\"%.4lf\\n\", min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MIN_X (-20)\n#define MAX_X   20\n\nint hgt[MAX_X - MIN_X];\n#define height(x) (hgt[(x) - MIN_X])\n\ndouble solve(int r)\n{\n  int x, x0;\n  double y, t;\n  double min = height(0); /* the time when the sunlight comes at x=0 */\n  for (x = -r; x < r; x++) {\n    x0 = (x < 0 ? x + 1 : x);\n    y = sqrt(r * r - x0 * x0) - r; /* the top of the sun at x0 */\n    t = height(x) - y;\n    if (min > t) min = t;\n  }\n  return min;\n}\n\nint main()\n{\n  int r, n, h, i, x, x1, x2;\n  for (;;) {\n    scanf(\"%d%d\", &r, &n);  /* radius, # of bld. */\n    if (r == 0 && n == 0) break;\n\n    for (x = MIN_X; x < MAX_X; x++) height(x) = 0; /* initialize */\n    for (i = 0; i < n; i++) {\n      scanf(\"%d%d%d\", &x1, &x2, &h); /* left, right, height */\n      for (x = x1; x < x2; x++) {\n        if (height(x) < h) height(x) = h;\n      }\n    }\n    printf(\"%.4f\\n\", solve(r));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define max(a, b) ((a)>(b)?(a):(b))\n#define min(a, b) ((a)<(b)?(a):(b))\n\nint skyline[41];\n\ndouble calc(int x, int y, int r){\n\treturn y+r-sqrt((double)(r*r-x*x));\n}\n\nint main(void){\n\tint n,r;\n\twhile(scanf(\"%d %d\", &r, &n),r||n){\n\t\tint i,j,xl,xr,h;\n\t\tfor(i=0;i<41;i++) skyline[i]=0;\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d\", &xl, &xr, &h);\n\t\t\tfor(j=xl;j<xr;j++){\n\t\t\t\tif(skyline[j+20]<h)skyline[j+20]=h;\n\t\t\t}\n\t\t}\n\t\tdouble t=calc(0,min(skyline[19],skyline[20]),r);\n\t\tdouble tt;\n\t\tint tx,ty;\n\t\ttx=0;\n\t\tty=min(skyline[19],skyline[20]);\n\t\tfor(j=0;j<r-1;j++){\n\t\t\tif(skyline[j+20]>skyline[j+1+20]){\n\t\t\t\ttt=calc(j+1,skyline[j+1+20],r);\n\t\t\t\tif(tt<t){\n\t\t\t\t\ttx=j+1;\n\t\t\t\t\tty=skyline[j+21];\n\t\t\t\t}\n\t\t\t\tt=min(t,tt);\n\t\t\t}\n\t\t}\n\t\tfor(j=-1;j>0-r;j--){\n\t\t\tif(skyline[j+20]>skyline[j-1+20]){\n\t\t\t\ttt=calc(j,skyline[j-1+20],r);\n\t\t\t\tif(tt<t){\n\t\t\t\t\ttx=j;\n\t\t\t\t\tty=skyline[j+19];\n\t\t\t\t}\n\t\t\t\tt=min(t,tt);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%0.4f\\n\",t);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      //printf(\"%lf %lf %lf\\n\", my, dx, t);\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint ofs=21;\n\nint B[50],R,N,r,l,h,i,j,P[150][2],p;\ndouble ans;\n\nvoid ins(int y,int x)\n{\n\tP[p][0]=y;\n\tP[p][1]=x;\n\tp++;\n}\n\ndouble dis(int y,int x)\n{\n\tdouble h=sqrt(1.0*R*R-x*x);\n\tif(h>=R||y>=R)h=R-h+y;\n\telse h=R-h;\n\treturn h;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&R,&N),R;)\n\t{\n\t\tans=10000000;\n\t\tmemset(B,0,sizeof(B));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&r,&l,&h);\n\t\t\tfor(j=r+ofs;j<l+ofs;j++)\n\t\t\t\tB[j]=B[j]>h?B[j]:h;\n\t\t}\n\t\tfor(i=1,p=0;i<41;i++)\n\t\t{\n\t\t\tif(B[i]!=B[i-1])\n\t\t\t{\n\t\t\t\tins(B[i-1],i-ofs);\n\t\t\t\tins(B[i],i-ofs);\n\t\t\t}\n\t\t}\n\t\tins(B[ofs],0);\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tif(R>abs(P[i][1]))\n\t\t\t{\n\t\t\t\tdouble t=dis(P[i][0],P[i][1]);\n\t\t\t\tans=ans<t?ans:t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint ofs=21;\n\nint B[50],R,N,r,l,h,i,j,P[150][2],p;\ndouble ans;\n\nvoid ins(int y,int x)\n{\n\tP[p][0]=y;\n\tP[p][1]=x;\n\tp++;\n}\n\ndouble dis(int y,int x)\n{\n\tdouble h=sqrt(1.0*R*R-x*x);\n\tif(y>=R)h=R-h+y;\n\telse h=R-h;\n\treturn h;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&R,&N),R;)\n\t{\n\t\tans=10000000;\n\t\tmemset(B,0,sizeof(B));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&r,&l,&h);\n\t\t\tfor(j=r+ofs;j<l+ofs;j++)\n\t\t\t\tB[j]=B[j]>h?B[j]:h;\n\t\t}\n\t\tfor(i=1,p=0;i<41;i++)\n\t\t{\n\t\t\tif(B[i]!=B[i-1])\n\t\t\t{\n\t\t\t\tins(B[i-1],i-ofs);\n\t\t\t\tins(B[i],i-ofs);\n\t\t\t}\n\t\t}\n\t\tins(B[ofs],0);\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tif(R>abs(P[i][1]))\n\t\t\t{\n\t\t\t\tdouble t=dis(P[i][0],P[i][1]);\n\t\t\t\tans=ans<t?ans:t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint ofs=21;\n\nint B[50],R,N,r,l,h,i,j,P[150][2],p;\ndouble ans;\n\nvoid ins(int y,int x)\n{\n\tP[p][0]=y;\n\tP[p][1]=x;\n\tp++;\n}\n\ndouble dis(int y,int x)\n{\n\tdouble h=sqrt(1.0*R*R-x*x);\n\th=R-h+y;\n\treturn h;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&R,&N),R;)\n\t{\n\t\tans=10000000;\n\t\tmemset(B,0,sizeof(B));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&r,&l,&h);\n\t\t\tfor(j=r+ofs;j<l+ofs;j++)\n\t\t\t\tB[j]=B[j]>h?B[j]:h;\n\t\t}\n\t\tfor(i=1,p=0;i<41;i++)\n\t\t{\n\t\t\tif(B[i]!=B[i-1])\n\t\t\t{\n\t\t\t\tins(B[i-1],i-ofs);\n\t\t\t\tins(B[i],i-ofs);\n\t\t\t}\n\t\t}\n\t\tins(B[ofs],0);\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tif(R>abs(P[i][1]))\n\t\t\t{\n\t\t\t\tdouble t=dis(P[i][0],P[i][1]);\n\t\t\t\tans=ans<t?ans:t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=l;i<r;i++)\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n\nint main(){\n\tll n,r;\n\twhile(scanf(\"%lld%lld\",&r,&n),r){\n\t\tll aaa[50]={},*a=aaa+25;\n\t\ta[-r-1]=a[r]=1e9;\n\t\twhile(n--){\n\t\t\tll xl,xr,h;\n\t\t\tscanf(\"%lld%lld%lld\",&xl,&xr,&h);\n\t\t\trep(i,xl,xr)a[i]=max(a[i],h);\n\t\t}\n\t\tdouble ans=1e10;\n\t\t//地上に出るまでの時間+高さ\n\t\trep(i,-r,r+1)ans=min(ans,min(a[i-1],a[i])+r-sqrt(r*r-i*i));\n\t\tprintf(\"%f\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint ofs=21;\n\nint B[50],R,N,r,l,h,i,j,P[150][2],p;\ndouble ans;\n\nvoid ins(int y,int x)\n{\n\tP[p][0]=y;\n\tP[p][1]=x;\n\tp++;\n}\n\ndouble dis(int y,int x)\n{\n\tdouble h=sqrt(1.0*R*R-x*x);\n\tif(h>=R)h=R-h+y;\n\telse h=2*R-h;\n\treturn h;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&R,&N),R;)\n\t{\n\t\tans=10000000;\n\t\tmemset(B,0,sizeof(B));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&r,&l,&h);\n\t\t\tfor(j=r+ofs;j<l+ofs;j++)\n\t\t\t\tB[j]=B[j]>h?B[j]:h;\n\t\t}\n\t\tfor(i=1,p=0;i<41;i++)\n\t\t{\n\t\t\tif(B[i]!=B[i-1])\n\t\t\t{\n\t\t\t\tins(B[i-1],i-ofs);\n\t\t\t\tins(B[i],i-ofs);\n\t\t\t}\n\t\t}\n\t\tins(B[ofs],0);\n\t\tfor(i=0;i<p;i++)\n\t\t{\n\t\t\tif(R>abs(P[i][1]))\n\t\t\t{\n\t\t\t\tdouble t=dis(P[i][0],P[i][1]);\n\t\t\t\tans=ans<t?ans:t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      //printf(\"%lf %lf %lf\\n\", my, dx, t);\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      //printf(\"%lf %lf %lf\\n\", my, dx, t);\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX_X 21\nint hights_m[MAX_X];\nint hights_p[MAX_X];\n\n/* \n2 6\n-3 3 1\n-2 3 2\n-1 3 3\n0 3 4\n1 3 5\n2 3 6\n */\n\ndouble calc_dis(double x, double y)\n{\n  return sqrt(x * x + y * y);\n}\ndouble min = 1000000.0, min_x, min_y;\n\n\nvoid calc_min(double x, double y)\n{\n  double from_origin = calc_dis(x, y);\n  if(from_origin == min)\n    {\n      if(min_y < y)\n\t{\n\t  min = from_origin;\n\t  min_x = x;\n\t  min_y = y;\n\t}\n    }\n  else if(from_origin < min)\n    {\n      min = from_origin;\n      min_x = x;\n      min_y = y;\n    }\n  \n}\n\n\nvoid make_points()\n{\n  int i, p = 0, prev = 0;\n  double x, y;\n  for(i = 0; i < MAX_X; i++)\n    {\n      /* [0] [1] [2]*/\n      if(hights_m[i] != prev)\n\t{\n\t  x = (double)(i - MAX_X);\n\t  y = (double)prev;\n\t  calc_min(x, y);\n\n\t  y = (double)hights_m[i];\n\t  calc_min(x, y);\n\t}\n      prev = hights_m[i];\n    }\n  for(i = 0; i < MAX_X; i++)\n    {\n      /* 0 [0] 1 [1] 2 [2] 3*/\n      if(hights_p[i] != prev)\n\t{\n\t  x = (double)i;\n\t  y = (double)prev;\n\t  calc_min(x, y);\n\n\t  y = (double)hights_p[i];\n\t  calc_min(x, y);\n\t}\n      else if(i == 0)\n\t{\n\t  x = 0.0;\n\t  y = (double)hights_p[i];\n\t  calc_min(x, y);\n\t}\n      prev = hights_p[i];\n    }\n}\n\n\n\n\nint main(void)\n{\n  int n, r, i, j, right, left, hight;\n\n  while(scanf(\"%d %d\", &r, &n), n != 0 && r != 0)\n    {\n      for(i = 0; i < MAX_X; i++)\n\t{\n\t  hights_m[i] = 0;\n\t  hights_p[i] = 0;\n\t}\n  \n      for(i = 0; i < n; i++)\n\t{\n\t  scanf(\"%d %d %d\", &left, &right, &hight);\n\t  for(j = left; j < right; j++)\n\t    {\n\t      if(j < 0)\n\t\tif(hights_m[MAX_X + j] < hight)\n\t\t  hights_m[MAX_X + j] = hight;\n\t\telse\n\t\t  ;\n\t      else\n\t\tif(hights_p[j] < hight)\n\t\t  hights_p[j] = hight;\n\t    }\n\t}\n\n      make_points();\n\n      //      printf(\"min = %lf, (%lf, %lf)\\n\", min, min_x, min_y);\n\n      double l = sqrt((double)r * (double)r - min_x * min_x);\n      printf(\"%.4lf\\n\", min_y - l + r);\n      min = 1000000.0;\n      min_x = 1000000.0;\n      min_y = 1000000.0;\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define R_MAX 20\nint m[R_MAX*4+1];\nint main(){\n\tint r,n,x1,x2,h;\n\tfor(;scanf(\"%d%d\",&r,&n),r;memset(m,0,sizeof(m))){\n\t\tint left=0,right=0;\n\t\tfor(;n;n--){\n\t\t\tscanf(\"%d%d%d\",&x1,&x2,&h);x1=2*x1+2*R_MAX;x2=2*x2+2*R_MAX;\n\t\t\tfor(;x1<=x2;x1++)if(m[x1]<h)m[x1]=h;\n\t\t}\n\t\t//for(x1=-2*r-1;x1<=2*r+1;x1++)printf(\"%d %d\\n\",x1,m[x1+2*R_MAX]);\n\t\t//0〜2*rなるxに対する、p(x,m[x+r])との距離がrとなる、x=r上の点\n\t\tdouble ret=-1;\n\t\tfor(x1=0;x1<=2*r;x1++){\n\t\t\tint x=x1-r;\n\t\t\tint d=x>0?x:-x;\n\t\t\tdouble y=-sqrt(r*r-d*d);\n\t\t\t//入出力は通っているので一安心なのですが、この辺結構怪しいです\n\t\t\tif(x==0){\n\t\t\t\tif(ret<0||ret>y+r+m[2*R_MAX-1])ret=y+r+m[2*R_MAX-1];\n\t\t\t\tif(ret<0||ret>y+r+m[2*R_MAX+1])ret=y+r+m[2*R_MAX+1];\n\t\t\t}else{\n\t\t\t\tint add=x1==0||x1==2*r?0:x/d;\n\t\t\t\tif(ret<0||ret>y+r+m[2*R_MAX+2*x+add])ret=y+r+m[2*R_MAX+2*x+add];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,n) for(i=0;i<(int)(n);i++)\n#define X 100\n\ndouble min(double x, double y){\n  return x > y ? y : x;\n}\ndouble max(double x, double y){\n  return x > y ? x : y;\n}\n\nint main(){\n  int n;\n  double r;\n  while(scanf(\"%lf%d\", &r, &n) , n){\n    int x;\n    double h[1000]={};\n    int i;\n    rep(i,n){\n      int x1, x2, y;\n      scanf(\"%d%d%d\", &x1, &x2, &y);\n      x1+=X, x2+=X;\n      for(x=x1;x<x2;x++){\n\th[x] = max(h[x], y);\n      }\n    }\n    double ans = 100000;\n    for(x=X-r;x<X+r;x++){\n      double my = h[x];\n      double dx = x < X ? X-x-1 : X-x;\n      double t = my-sqrt(r*r-dx*dx)+r;\n      ans = min(ans, t);\n    }\n    printf(\"%.10lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX_X 21\nint hights_m[MAX_X];\nint hights_p[MAX_X];\n\ndouble solve(double r)\n{\n  int i, prev = 0;\n  double ans = (double)((hights_p[0] < hights_m[20])? hights_p[0] : hights_m[20] );\n  double x, y, l;\n  for(i = 1; i < MAX_X; i++)\n    {\n\n      prev = hights_m[i - 1];\n      if(MAX_X - i > r -1 )\n\tcontinue;\n      //      printf(\"ans = %lf\\n\", ans);\n      y = (double)((prev > hights_m[i])? hights_m[i]: prev);\n      x = (double)(i - MAX_X);\n      //      printf(\"(%lf, %lf)\\n\", x, y);\n      l = y - sqrt(r * r - x * x) + r;\n      ans = (double)((l < ans)? l: ans);\n    }\n  prev = hights_m[MAX_X - 1];\n  for(i = 0; i < MAX_X - 1; i++)\n    {\n      //      printf(\"ans = %lf\\n\", ans);\n      if(i > r - 1)\n\tbreak;\n      y = (double)((prev > hights_p[i])? hights_p[i]: prev);\n      x = (double)i;\n      //      printf(\"(%lf, %lf)\\n\", x, y);\n      l = y - sqrt(r * r - x * x) + r;\n      ans = (double)((l < ans)? l: ans);\n      prev = hights_p[i];\n    }\n  return ans;\n}\n  \n\n\nint main(void)\n{\n  int n, r, i, j, right, left, hight;\n\n  while(scanf(\"%d %d\", &r, &n), n != 0 || r != 0)\n    {\n      for(i = 0; i < MAX_X; i++)\n\t{\n\t  hights_m[i] = 0;\n\t  hights_p[i] = 0;\n\t}\n  \n      for(i = 0; i < n; i++)\n\t{\n\t  scanf(\"%d %d %d\", &left, &right, &hight);\n\t  for(j = left; j < right; j++)\n\t    {\n\t      if(j < 0)\n\t\tif(hights_m[MAX_X + j] < hight)\n\t\t  hights_m[MAX_X + j] = hight;\n\t\telse\n\t\t  ;\n\t      else\n\t\tif(hights_p[j] < hight)\n\t\t  hights_p[j] = hight;\n\t    }\n\t}\n\n      printf(\"%.4lf\\n\", solve((double)r));\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint main() {\n\n\tint n;\n\tdouble r,h;\n\tdouble x_l,x_r;\n\tint i,j;\n\tdouble b[41];\n\tdouble t;\n\tdouble x,y;\n\n\tfor(;;) {\n\t\tscanf(\"%lf %d\",&r,&n);\n\t\tif(r==0&&n==0)\n\t\t\tbreak;\n\n\t\tfor(i=0;i<41;i++)\n\t\t\tb[i]=0;\n\n\t\t//??????????????????????´?\n\t\tfor(i=0;i<n;i++) {\n\t\t\tscanf(\"%lf %lf %lf\",&x_l,&x_r,&h);\n\t\t\tfor(j=x_l+20;j<x_r+20;j++) {\n\t\t\t\tif(b[j]<h)\n\t\t\t\t\tb[j]=h;\n\t\t\t}\n\t\t}\n\n\t\t//????????????????????????????????§???????????´????????????????????????????¨????\n\t\tt=100;\n\t\tfor(j=(-r+20)+1;j<=(r+20)-1;j++) {\n\t\t\tx = j-20;\n\t\t\tif(b[j-1]<=b[j])\n\t\t\t\ty=b[j-1];\n\t\t\telse\n\t\t\t\ty=b[j];\n\n\t\t\tif(t>y+r-sqrt(r*r-x*x))\n\t\t\t\tt=y+r-sqrt(r*r-x*x);\n\n\t\t}\n\t\tprintf(\"%f\\n\",t);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define X_MAX 20\n#define H_MAX 20\n\nint arr[2 * H_MAX];\n\nint* heights = arr + H_MAX;\nint r;\n\nint check(double time)\n{\n    int x;\n\n    for(x = -r; x < 0; x++)\n        if(heights[x] < sqrt(r * r - (x + 1) * (x + 1)) - r + time)\n            return 0;\n\n    for(x = 0; x < r; x++)\n        if(heights[x] < sqrt(r * r - x * x) - r + time)\n            return 0;\n\n    return 1;\n}\n\nint main(void)\n{\n    int n, xl, xr, h;\n    double upper, lower, mean;\n\n    while(scanf(\"%d%d\", &r, &n), r + n)\n    {\n        for(xl = -X_MAX; xl < X_MAX; xl++)\n            heights[xl] = 0;\n\n        while(n--)\n        {\n            scanf(\"%d%d%d\", &xl, &xr, &h);\n            for(; xl < xr; xl++)\n                if(heights[xl] < h) heights[xl] = h;\n        }\n\n        upper = H_MAX;\n        lower = 0;\n        mean = (upper + lower) / 2;\n        while(upper - lower > 0.001)\n        {\n            if(check(mean)) lower = mean;\n            else upper = mean;\n            mean = (upper + lower) / 2;\n        }\n\n        printf(\"%lf\\n\", mean);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define inf 1e10\n#define min(x,y) x<y?x:y\ndouble cal_time(int r, int h, int x){\n    return h + r - sqrt(r*r-x*x);\n}\nint main(void){\n    int r, n, left, right, h;\n    while(1){\n        int x[40]={0};\n        scanf(\"%d%d\",&r,&n);\n        if(r==0 && n==0) break;\n        for(int i=0; i<n; i++){\n            scanf(\"%d%d%d\",&left,&right,&h);\n            for(int j=left; j<right; j++){\n                if(x[20+j] < h) x[20+j]=h;\n            }\n        }\n        double min=inf,tmp;\n        for(int i=-r+1; i<r; i++){\n            if((tmp=cal_time(r,min(x[i+19],x[i+20]),i)) < min){\n                min=tmp;\n            }\n        }\n        printf(\"%.4f\\n\",min);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1194\n   Vampire\n\n*/\n\n#include<stdio.h>\n#include<math.h>\n#define MAX_X 21\nint hights_m[MAX_X];\nint hights_p[MAX_X];\n\ndouble solve(double r)\n{\n  int i, prev = 0;\n  double ans = (double)((hights_p[0] < hights_m[20])? hights_p[0] : hights_m[20] );\n  double x, y, l;\n  for(i = 1; i < MAX_X; i++)\n    {\n\n      prev = hights_m[i - 1];\n      if(MAX_X - i > r -1 )\n\tcontinue;\n      y = (double)((prev > hights_m[i])? hights_m[i]: prev);\n      x = (double)(i - MAX_X);\n      l = y - sqrt(r * r - x * x) + r;\n      ans = (double)((l < ans)? l: ans);\n    }\n  prev = hights_m[MAX_X - 1];\n  for(i = 0; i < MAX_X - 1; i++)\n    {\n      if(i > r - 1)\n\tbreak;\n      y = (double)((prev > hights_p[i])? hights_p[i]: prev);\n      x = (double)i;\n      l = y - sqrt(r * r - x * x) + r;\n      ans = (double)((l < ans)? l: ans);\n      prev = hights_p[i];\n    }\n  return ans;\n}\n  \n\n\nint main(void)\n{\n  int n, r, i, j, right, left, hight;\n\n  while(scanf(\"%d %d\", &r, &n), n != 0 || r != 0)\n    {\n      for(i = 0; i < MAX_X; i++)\n\t{\n\t  hights_m[i] = 0;\n\t  hights_p[i] = 0;\n\t}\n      for(i = 0; i < n; i++)\n\t{\n\t  scanf(\"%d %d %d\", &left, &right, &hight);\n\t  for(j = left; j < right; j++)\n\t    {\n\t      if(j < 0)\n\t\tif(hights_m[MAX_X + j] < hight)\n\t\t  hights_m[MAX_X + j] = hight;\n\t\telse\n\t\t  ;\n\t      else\n\t\tif(hights_p[j] < hight)\n\t\t  hights_p[j] = hight;\n\t    }\n\t}\n      printf(\"%.4lf\\n\", solve((double)r));\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void) {\n\tint r,n;\n\twhile(scanf(\"%d%d\",&r,&n)==2 && (r!=0 || n!=0)) {\n\t\tint i,j;\n\t\tdouble answer = 1000.0;\n\t\t/* -20 [0] -19 [1] -18 ... -1 [19] 0 [20] 1 [21] 2 ... 19 [39] 20 */\n\t\tint tatemono[40];\n\t\tfor(i=0;i<40;i++)tatemono[i]=0;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tint x,y,h;\n\t\t\tif(scanf(\"%d%d%d\",&x,&y,&h)!=3)return 1;\n\t\t\tfor(j=x+20;j<y+20;j++) {\n\t\t\t\tif(h>tatemono[j])tatemono[j]=h;\n\t\t\t}\n\t\t}\n\t\tfor (i=-r+1;i<r;i++) {\n\t\t\tdouble offset=r-sqrt(r*r-i*i);\n\t\t\tdouble candidate=offset+tatemono[i<0?i+19:i+20];\n\t\t\tif(candidate<answer)answer=candidate;\n\t\t}\n\t\t/* i==0, left */\n\t\tif(tatemono[19]<answer)answer=tatemono[19];\n\t\tprintf(\"%.15f\\n\",answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX_X 21\nint hights_m[MAX_X];\nint hights_p[MAX_X];\n\n/* \n2 6\n-3 3 1\n-2 3 2\n-1 3 3\n0 3 4\n1 3 5\n2 3 6\n */\n\ndouble calc_dis(double x, double y)\n{\n  return sqrt(x * x + y * y);\n}\ndouble min = 1000000.0, min_x, min_y;\n\n\nvoid calc_min(double x, double y)\n{\n  double from_origin = calc_dis(x, y);\n  if(from_origin == min)\n    {\n      if(min_y < y)\n\t{\n\t  min = from_origin;\n\t  min_x = x;\n\t  min_y = y;\n\t}\n    }\n  else if(from_origin < min)\n    {\n      min = from_origin;\n      min_x = x;\n      min_y = y;\n    }\n  \n}\n\n\nvoid make_points()\n{\n  int i, p = 0, prev = 0;\n  double x, y;\n  for(i = 0; i < MAX_X; i++)\n    {\n      /* [0] [1] [2]*/\n      if(hights_m[i] != prev)\n\t{\n\t  x = (double)(i - MAX_X);\n\t  y = (double)prev;\n\t  calc_min(x, y);\n\n\t  y = (double)hights_m[i];\n\t  calc_min(x, y);\n\t}\n      prev = hights_m[i];\n    }\n  for(i = 0; i < MAX_X; i++)\n    {\n      /* 0 [0] 1 [1] 2 [2] 3*/\n      if(hights_p[i] != prev)\n\t{\n\t  x = (double)i;\n\t  y = (double)prev;\n\t  calc_min(x, y);\n\n\t  y = (double)hights_p[i];\n\t  calc_min(x, y);\n\t}\n      else if(i == 0)\n\t{\n\t  x = 0.0;\n\t  y = (double)hights_p[i];\n\t  calc_min(x, y);\n\t}\n      prev = hights_p[i];\n    }\n}\n\n\n\n\nint main(void)\n{\n  int n, r, i, j, right, left, hight;\n\n  while(scanf(\"%d %d\", &r, &n), n != 0 && r != 0)\n    {\n      for(i = 0; i < MAX_X; i++)\n\t{\n\t  hights_m[i] = 0;\n\t  hights_p[i] = 0;\n\t}\n  \n      for(i = 0; i < n; i++)\n\t{\n\t  scanf(\"%d %d %d\", &left, &right, &hight);\n\t  for(j = left; j < right; j++)\n\t    {\n\t      if(j < 0)\n\t\tif(hights_m[MAX_X + j] < hight)\n\t\t  hights_m[MAX_X + j] = hight;\n\t\telse\n\t\t  ;\n\t      else\n\t\tif(hights_p[j] < hight)\n\t\t  hights_p[j] = hight;\n\t    }\n\t}\n\n      make_points();\n\n      //      printf(\"min = %lf, (%lf, %lf)\\n\", min, min_x, min_y);\n\n      double l = sqrt((double)r * (double)r - min_x * min_x);\n      printf(\"%.4lf\\n\", min_y - l + r);\n      min = 1000000.0;\n      min_x = 1000000.0;\n      min_y = 1000000.0;\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX_X 21\nint hights_m[MAX_X];\nint hights_p[MAX_X];\n\ndouble solve(double r)\n{\n  int i, prev = 0;\n  double ans = (double)((hights_p[0] < hights_m[20])? hights_p[0] : hights_m[20] );\n  double x, y, l;\n  for(i = 1; i < MAX_X; i++)\n    {\n\n      prev = hights_m[i - 1];\n      if(MAX_X - i > r -1 )\n\tcontinue;\n      //      printf(\"ans = %lf\\n\", ans);\n      y = (double)((prev > hights_m[i])? hights_m[i]: prev);\n      x = (double)(i - MAX_X);\n      //      printf(\"(%lf, %lf)\\n\", x, y);\n      l = y - sqrt(r * r - x * x) + r;\n      ans = (double)((l < ans)? l: ans);\n    }\n  prev = hights_m[MAX_X - 1];\n  for(i = 0; i < MAX_X - 1; i++)\n    {\n      //      printf(\"ans = %lf\\n\", ans);\n      if(i > r - 1)\n\tbreak;\n      y = (double)((prev > hights_p[i])? hights_p[i]: prev);\n      x = (double)i;\n      //      printf(\"(%lf, %lf)\\n\", x, y);\n      l = y - sqrt(r * r - x * x) + r;\n      ans = (double)((l < ans)? l: ans);\n      prev = hights_p[i];\n    }\n  return ans;\n}\n  \n\n\nint main(void)\n{\n  int n, r, i, j, right, left, hight;\n\n  while(scanf(\"%d %d\", &r, &n), n != 0 && r != 0)\n    {\n      for(i = 0; i < MAX_X; i++)\n\t{\n\t  hights_m[i] = 0;\n\t  hights_p[i] = 0;\n\t}\n  \n      for(i = 0; i < n; i++)\n\t{\n\t  scanf(\"%d %d %d\", &left, &right, &hight);\n\t  for(j = left; j < right; j++)\n\t    {\n\t      if(j < 0)\n\t\tif(hights_m[MAX_X + j] < hight)\n\t\t  hights_m[MAX_X + j] = hight;\n\t\telse\n\t\t  ;\n\t      else\n\t\tif(hights_p[j] < hight)\n\t\t  hights_p[j] = hight;\n\t    }\n\t}\n\n      printf(\"%.4lf\\n\", solve((double)r));\n    }\n  return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.*\nfun main(args: Array<String>?): Unit {\n    while(true){\n        val (r, n) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (r == 0 && n == 0) return\n        val height = IntArray(41){0}\n        repeat(n){\n            val (xl, xr, h) = readLine()!!.trim().split(' ').map(String::toInt)\n            for (x in xl until xr) {\n                height[x + 20] = max(h, height[x + 20])\n            }\n        }\n        var last = Double.MAX_VALUE\n        for (x in 0 .. 20) last = min(last, lastTime(x, height[x + 20], r))\n        for (x in -20 until 0) last = min(last, lastTime(abs(x + 1), height[x + 20], r))\n        println(\"%.10f\".format(last))\n    }\n}\n\nfun lastTime(distance: Int, height: Int, radius: Int): Double {\n    return if (radius <= distance) Double.MAX_VALUE else radius - (sqrt(radius * radius * 1.0 - distance * distance) - height)\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint CENTER = 20;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint r = in.nextInt(), n = in.nextInt();\n\t\t\tif (r == 0) break;\n\t\t\t\n\t\t\tint[] height = new int[CENTER*2+1];\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xl = in.nextInt(), xr = in.nextInt(), h = in.nextInt();\n\t\t\t\tfor (int j = CENTER + xl; j < CENTER + xr; j++) {\n\t\t\t\t\theight[j] = Math.max(height[j], h);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Point> plist = new ArrayList<Point>();\n\t\t\tint prev = 0;\n\t\t\tfor (int i = 0; i < height.length; i++) {\n\t\t\t\tif (prev != height[i]) {\n\t\t\t\t\tplist.add(new Point(i-CENTER, height[i]));\n\t\t\t\t\tplist.add(new Point(i-CENTER, prev));\n\t\t\t\t}\n\t\t\t\tprev = height[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor (double t = 0; t <= 40; t += 0.00001) {\n\t\t\t\tdouble y = -r + t;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (Point pt : plist) {\n\t\t\t\t\tdouble dx = pt.x, dy = pt.y - y;\n\t\t\t\t\tif (dx * dx + dy * dy < r * r) ok = false; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!ok) {\n\t\t\t\t\tSystem.out.println(t-0.00001);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplist.clear();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=xl+20 && j!=xr+20 && x[1][j]==0){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(x[1][20+i]==0 || x[1][20-i]==0){\n\t\t\t\t\tflag = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", r-Math.sqrt(r*r-flag*flag));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", min+r);\n\t\t\t}\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int r, n;\n\tstatic int[] xl, xr, h;\n\t\n\tprivate static void start()\n\t{\n\t\tint i, j;\n\t\t\n\t\tPoint[] height = new Point[41];\n\t\tfor(i = 0;i < 41;i++)\n\t\t\theight[i] = new Point(0, 0);\n\t\t\n\t\tfor(i = 0;i < n;i++)\n\t\t\tfor(j = xl[i];j <= xr[i];j++)\n\t\t\t{\n\t\t\t\tif(j != xl[i]) height[j].x = Math.max(height[j].x, h[i]);\n\t\t\t\tif(j != xr[i]) height[j].y = Math.max(height[j].y, h[i]);\n\t\t\t}\n\t\t\n\t\tdouble min = Double.MAX_VALUE;\n\t\tfor(i = (20-r);i <= (20+r);i++)\n\t\t{\n\t\t\tif(i != (20-r))\n\t\t\t{\n\t\t\t\tdouble w = Math.abs(i - 20);\n\t\t\t\tdouble p = Math.sqrt(r*r - w*w);\n\t\t\t\tdouble t = (double)height[i].y - p + (double)r;\n\t\t\t\tmin = Math.min(min, t);\n\t\t\t}\n\t\t\t\n\t\t\tif(i != (20+r))\n\t\t\t{\n\t\t\t\tdouble w = Math.abs(i - 20);\n\t\t\t\tdouble p = Math.sqrt(r*r - w*w);\n\t\t\t\tdouble t = (double)height[i].x - p + (double)r;\n\t\t\t\tmin = Math.min(min, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.printf(\"%.04f\\n\", min);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tr = sca.nextInt();\n\t\t\tn = sca.nextInt();\n\t\t\tif(r == 0) break;\n\t\t\t\n\t\t\txl = new int[n];\n\t\t\txr = new int[n];\n\t\t\th = new int[n];\n\t\t\tfor(int i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\txl[i] = sca.nextInt() + 20;\n\t\t\t\txr[i] = sca.nextInt() + 20;\n\t\t\t\th[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tstart();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] += r;\n\t\t\t\txr[i] += r;\n\n\t\t\t\tint ll = Math.max(0, xl[i]);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i]));\n\n\t\t\t\tint c = h[i];\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// System.out.println(Arrays.toString(cover));\n\t\t\tdouble res = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tint xx = i - r > 0 ? i - r + 1 : r - i - 1;\n\t\t\t\tdouble t1 = cover[i]\n\t\t\t\t\t\t+ r\n\t\t\t\t\t\t* (1 - Math\n\t\t\t\t\t\t\t\t.sin(Math.acos((double) Math.abs(r - i) / r)));\n\t\t\t\tdouble t2 = cover[i] + r\n\t\t\t\t\t\t* (1 - Math.sin(Math.acos((double) xx / r)));\n\t\t\t\tres = Math.min(res, Math.min(t1, t2));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", res));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// AOJ 1194 \"バンパイア\" (ICPC国内予選 2014 Problem C)\nimport java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static double INF = 100.0;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int r = sc.nextInt();\n            int n = sc.nextInt();\n            if (r == 0) {\n                break;\n            }\n            \n            // field[y][x]: (x-20, y-1)にシルエット(境界も含む)があればtrue\n            boolean[][] field = new boolean[41][81];\n            Arrays.fill(field[0], true); // 地面に陰があると見なす\n            \n            for (int i = 0; i < n; i++) {\n                int xl = sc.nextInt();\n                int xr = sc.nextInt();\n                int h  = sc.nextInt();\n                \n                for (int j = 1; j <= 2 * h; j++) {\n                    Arrays.fill(field[j], (xl + 20) * 2, (xr + 20) * 2 + 1, true);\n                }\n            }\n            //printField(field);\n            \n            double minTime = INF;\n            for (int i = 0; i < field.length; i += 2) {\n                for (int j = 0; j < field[i].length; j += 2) {\n                    if (isBorder(field, j, i)) {\n                        // シルエットの上下の境界ならば、円との交点を求める\n                        double time = crossTime(j/2 - 20, i/2, r);\n                        minTime = Math.min(minTime, time);\n                    }\n                }\n            }\n            System.out.println(minTime);\n        }\n    }\n    \n    public static boolean isBorder(boolean[][] field, int x, int y) {\n        if (!field[y][x]) {\n            return false;\n        } else if (y == field.length - 1 || (x == 0 || x == field[y].length - 1) && !field[y+1][x]) {\n            return true;\n        } else if (!field[y+1][x]) {\n            return true;\n        } else {\n            int num = 0;\n            for (int i = 0; i <= 1; i++) {\n                for (int j = -1; j <= 1; j++) {\n                    if (x + j >= 0 && x + j < field[y+i].length && field[y+i][x+j]) {\n                        num++;\n                    }\n                }\n            }\n            return num == 5 ? true : false;\n        }\n    }\n    \n    public static double crossTime(int x, int y, int r) {\n        //System.out.println(\"x: \" + x + \", y: \" + y + \", r: \" + r);\n        int d = (int)Math.pow(-2 * (y + r), 2) - 4 * (x * x + y * y + 2 * y * r);\n        if (d <= 0) {\n            return INF;\n        } else {\n            double ans = (2 * (y + r) - Math.sqrt(d)) / 2;\n            //System.out.println(d + \" \" + Math.sqrt(d) + \" \" + ans);\n            return ans;\n        }\n    }\n    \n    public static void printField(boolean[][] field) {\n        for (int i = field.length - 1; i >= 0; i -= 2) {\n            for (int j = 0; j < field[i].length; j += 2) {\n                if (field[i][j]) {\n                    System.out.print(\"-\");\n                } else {\n                    System.out.print(\" \");\n                }\n            }\n            System.out.println();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j>xl+20 && j<xr+20 && x[1][j]==0){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tx[1][j] = x[0][j];\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][20+i]==0 || x[1][20-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", min+r);\n\t\t\t}\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][43];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+21; j<=xr+21; j++){\n\t\t\t\t\tif(x[0][j]<=h){\n\t\t\t\t\t\tif(j>xl+21 && j<xr+21){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(x[0][j-1]==0 && j==xl+21 && x[1][j]==0){\n\t\t\t\t\t\t\t}else if(x[0][j+1]==0 && j==xr+21 && x[1][j]==0){\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tif(j>xl+21 && j<xr+21){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][21+i]==0 || x[1][21-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][21+i], x[1][21-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\", min+r);\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j!=xl+20 && j!=xr+20 && x[1][j]==0){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tx[1][j] = x[0][j];\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(x[1][20+i]==0 || x[1][20-i]==0){\n\t\t\t\t\tflag = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", r-Math.sqrt(r*r-flag*flag));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", min+r);\n\t\t\t}\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int r, n;\n\tstatic int[] xl, xr, h;\n\t\n\tprivate static void start()\n\t{\n\t\tint i, j;\n\t\t\n\t\tPoint[] height = new Point[41];\n\t\tfor(i = 0;i < 41;i++)\n\t\t\theight[i] = new Point(0, 0);\n\t\t\n\t\tfor(i = 0;i < n;i++)\n\t\t\tfor(j = xl[i];j <= xr[i];j++)\n\t\t\t{\n\t\t\t\tif(j != xl[i]) height[j].x = Math.max(height[j].x, h[i]);\n\t\t\t\tif(j != xr[i]) height[j].y = Math.max(height[j].y, h[i]);\n\t\t\t}\n\t\t\n\t\tdouble min = Double.MAX_VALUE;\n\t\tfor(i = (20-r);i <= (20+r);i++)\n\t\t{\n\t\t\tif(i != (20-r))\n\t\t\t{\n\t\t\t\tdouble w = Math.abs(i - 20);\n\t\t\t\tdouble p = Math.sqrt(r*r - w*w);\n\t\t\t\tdouble t = (double)height[i].x - p + (double)r;\n\t\t\t\tmin = Math.min(min, t);\n\t\t\t}\n\t\t\t\n\t\t\tif(i != (20+r))\n\t\t\t{\n\t\t\t\tdouble w = Math.abs(i - 20);\n\t\t\t\tdouble p = Math.sqrt(r*r - w*w);\n\t\t\t\tdouble t = (double)height[i].y - p + (double)r;\n\t\t\t\tmin = Math.min(min, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.printf(\"%.04f\\n\", min);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tr = sca.nextInt();\n\t\t\tn = sca.nextInt();\n\t\t\tif(r == 0) break;\n\t\t\t\n\t\t\txl = new int[n];\n\t\t\txr = new int[n];\n\t\t\th = new int[n];\n\t\t\tfor(int i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\txl[i] = sca.nextInt() + 20;\n\t\t\t\txr[i] = sca.nextInt() + 20;\n\t\t\t\th[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tstart();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r+n == 0) continue;\n\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t}\n\t}\n\t\n\t\n\tstatic double solve(int r, int n) {\n\t\tint[] dp = new int[39];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\t\t\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.001) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1194().doIt();\n    }\n    class aoj1194{\n    \tint po_h[] = new int[21];\n    \tint ne_h[] = new int[21];\n    \tvoid clear(){\n    \t\tfor(int i = 0;i < 21;i++){\n    \t\t\tpo_h[i] = 0;\n    \t\t\tne_h[i] = 0;\n    \t\t}\n    \t}\n    \tvoid bar(int n){\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tint xl = sc.nextInt();\n    \t\t\tint xr = sc.nextInt();\n    \t\t\tint h = sc.nextInt();\n    \t\t\tif(xr <= 0){\n    \t\t\t\tfor(int j = -xr;j < -xl;j++){\n    \t\t\t\t\tne_h[j] = Math.max(ne_h[j], h);\n    \t\t\t\t}\n    \t\t\t}else if(xl >= 0){\n    \t\t\t\tfor(int j = xl;j < xr;j++){\n    \t\t\t\t\tpo_h[j] = Math.max(po_h[j], h);\n    \t\t\t\t}\n    \t\t\t}else{\n    \t\t\t\tfor(int j = 0;j < -xl;j++){\n    \t\t\t\t\tne_h[j] = Math.max(ne_h[j], h);\n    \t\t\t\t}\n    \t\t\t\tfor(int j = 0;j < xr;j++){\n    \t\t\t\t\tpo_h[j] = Math.max(po_h[j], h);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid check(){\n    \t\tfor(int i = 0;i < 21;i++){\n    \t\t\tSystem.out.print(ne_h[i]);\n    \t\t}\n    \t\tSystem.out.println();\n    \t\tfor(int i = 0;i < 21;i++){\n    \t\t\tSystem.out.print(po_h[i]);\n    \t\t}\n    \t\tSystem.out.println();\n    \t\tSystem.out.println();\n    \t}\n    \tdouble ans(int r){\n    \t\tdouble result = 10000;\n    \t\tfor(int i = 0;i < r;i++){\n    \t\t\tdouble line = Math.min(ne_h[i], po_h[i]);\n    \t\t\tdouble high = (double)r - Math.sqrt((double)(r * r - i*i));\n    \t\t\tline = line + high;\n    \t\t\tresult = Math.min(result, line);\n//    \t\t\tSystem.out.println(i+\"??????:\"+result+\" \"+high+\" \"+line);\n    \t\t}\n    \t\treturn result;\n    \t}\n    \tvoid doIt(){\n     \t\twhile(true){\n     \t\t\tint r = sc.nextInt();\n     \t\t\tint n = sc.nextInt();\n     \t\t\tif(r + n == 0)break;\n     \t\t\tclear();\n     \t\t\tbar(n);\n//     \t\t\tcheck();\n     \t\t\tSystem.out.printf(\"%.4f\\n\",ans(r));\n     \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static int[][] map;\n    static int[][] label;\n\n    static ArrayList<Integer> ans0;\n    static ArrayList<Integer> ans1;\n\n    static int R;\n    static int N;\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while(true){\n            R = scanner.nextInt();\n            if(R == 0)break;\n            N = scanner.nextInt();\n\n            int minx = 999999;\n            int miny = 999999;\n            double mindis = 99999;\n            map = new int[21][42];\n            for (int i = 0; i < N; i++) {\n                int x1 = scanner.nextInt();\n                int x2 = scanner.nextInt();\n                int h = scanner.nextInt();\n\n                yama(x1, x2, h);\n            }\n\n//            for (int i = 0; i < 20; i++) {\n//                System.out.print(9);\n//            }\n//            System.out.println();\n//             for (int i = 0; i < 21; i++) {\n//                for (int j = 0; j < 42; j++) {\n//                    System.out.print(map[i][j]);\n//                }\n//                System.out.println();\n//            }\n\n//            System.out.println(distance(1 , 2));\n\n            for (int i = 20 - R; i < 20 + R; i++) {\n                int ok = 0;\n                for (int j = 20; j >= 0; j--) {\n                    if(map[j][i] == 1){\n//                        System.out.println(j);\n//                        System.out.println(i - 20 + \" \" + (j + 1));\n//                        System.out.println(i - 19 + \" \" + (j + 1));\n                        if(i != 20 - R && mindis > distance(i - 20, j + 1)){\n                            mindis = distance(i - 20, j + 1);\n                            minx = i - 20;\n                            miny = j + 1;\n                        }\n                        if(i != 19 + R && mindis > distance(i - 19, j + 1)){\n                            mindis = distance(i - 19, j + 1);\n                            minx = i - 19;\n                            miny = j + 1;\n                        }\n                        ok = 1;\n                        break;\n                    }\n                }\n                if(ok == 0){\n//                    System.out.println(i - 20 + \" \" + 0);\n//                    System.out.println(i - 19 + \" \" + 0);\n                    if(mindis > distance(i - 20, 0)){\n                        mindis = distance(i - 20, 0);\n                        minx = i - 20;\n                        miny = 0;\n                    }\n                    if(mindis > distance(i - 19, 0)){\n                        mindis = distance(i - 19, 0);\n                        minx = i - 19;\n                        miny = 0;\n                    }\n                }\n            }\n\n//            System.out.println(mindis);\n//            System.out.println(minx + \" \" + (miny));\n//            System.out.println(((miny + 2) + ((1.0 * minx * minx) / (miny + 2))) - 2);\n            System.out.println(R + miny - Math.sqrt(R * R - minx * minx));\n//            System.out.println();\n\n\n//            for (int i = 0; i < 21; i++) {\n//                for (int j = 0; j < 42; j++) {\n//                    System.out.print(map[i][j]);\n//                }\n//                System.out.println();\n//            }\n\n\n\n\n\n        }\n    }\n\n    static double distance(int x, int y){\n\n        return (y + R) * (y + R) + x * x;\n    }\n\n    static void yama(int x1, int x2, int h){\n\n        for (int i = x1 + 20; i < x2 + 20; i++) {\n            for (int j = 0; j < h; j++) {\n                map[j][i] = 1;\n            }\n        }\n\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint r = ir.nextInt();\n\t\t\tint n = ir.nextInt();\n\t\t\tif (r == 0 && n == 0)\n\t\t\t\treturn;\n\t\t\tint offset = r + 1;\n\t\t\tint[] h = new int[offset << 1];\n\t\t\th[0] = h[(offset << 1) - 1] = 1 << 30;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xl = ir.nextInt();\n\t\t\t\tint xr = ir.nextInt();\n\t\t\t\tint xh = ir.nextInt();\n\t\t\t\tfor (int j = xl; j < xr; j++) {\n\t\t\t\t\th[j + offset] = Math.max(h[j + offset], xh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble mi = 1e9;\n\t\t\tfor (int i = -r; i <= r; i++) {\n\t\t\t\tmi = Math.min(mi, Math.min(h[i + offset - 1], h[i + offset]) + (double) r\n\t\t\t\t\t\t- Math.sqrt((double) r * r - (double) i * i));\n\t\t\t}\n\t\t\tout.println(mi);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static int[][] map;\n    static int[][] label;\n\n    static ArrayList<Integer> ans0;\n    static ArrayList<Integer> ans1;\n\n    static int R;\n    static int N;\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while(true){\n            R = scanner.nextInt();\n            if(R == 0)break;\n            N = scanner.nextInt();\n\n            int minx = 999999;\n            int miny = 999999;\n            double mindis = 99999;\n            map = new int[21][42];\n            for (int i = 0; i < N; i++) {\n                int x1 = scanner.nextInt();\n                int x2 = scanner.nextInt();\n                int h = scanner.nextInt();\n\n                yama(x1, x2, h);\n            }\n\n//            for (int i = 0; i < 20; i++) {\n//                System.out.print(9);\n//            }\n//            System.out.println();\n//             for (int i = 0; i < 21; i++) {\n//                for (int j = 0; j < 42; j++) {\n//                    System.out.print(map[i][j]);\n//                }\n//                System.out.println();\n//            }\n\n//            System.out.println(distance(1 , 2));\n\n            for (int i = 20 - R; i < 20 + R; i++) {\n                int ok = 0;\n                for (int j = 20; j >= 0; j--) {\n                    if(map[j][i] == 1){\n//                        System.out.println(j);\n//                        System.out.println(i - 20 + \" \" + (j + 1));\n//                        System.out.println(i - 19 + \" \" + (j + 1));\n                        if(i != 20 - R && mindis > distance(i - 20, j + 1)){\n                            mindis = distance(i - 20, j + 1);\n                            minx = i - 20;\n                            miny = j + 1;\n                        }\n                        if(i != 19 + R && mindis > distance(i - 19, j + 1)){\n                            mindis = distance(i - 19, j + 1);\n                            minx = i - 19;\n                            miny = j + 1;\n                        }\n                        ok = 1;\n                        break;\n                    }\n                }\n                if(ok == 0){\n//                    System.out.println(i - 20 + \" \" + 0);\n//                    System.out.println(i - 19 + \" \" + 0);\n                    if(mindis > distance(i - 20, 0)){\n                        mindis = distance(i - 20, 0);\n                        minx = i - 20;\n                        miny = 0;\n                    }\n                    if(mindis > distance(i - 19, 0)){\n                        mindis = distance(i - 19, 0);\n                        minx = i - 19;\n                        miny = 0;\n                    }\n                }\n            }\n\n//            System.out.println(mindis);\n//            System.out.println(minx + \" \" + (miny));\n//            System.out.println(((miny + 2) + ((1.0 * minx * minx) / (miny + 2))) - 2);\n            System.out.println(R + miny - Math.sqrt(R * R - minx * minx));\n//            System.out.println();\n\n\n//            for (int i = 0; i < 21; i++) {\n//                for (int j = 0; j < 42; j++) {\n//                    System.out.print(map[i][j]);\n//                }\n//                System.out.println();\n//            }\n\n\n\n\n\n        }\n    }\n\n    static double distance(int x, int y){\n\n        return (y + R) * (y + R) + x * x;\n    }\n\n    static void yama(int x1, int x2, int h){\n\n        for (int i = x1 + 20; i < x2 + 20; i++) {\n            for (int j = 0; j < h; j++) {\n                map[j][i] = 1;\n            }\n        }\n\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.xml.crypto.Data;\n\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n     \n     \npublic class Main {\n\tstatic int W;\n\tstatic int H;\n\tstatic int N;\n\tstatic boolean[][] fld;\n\tstatic int[] vx = new int[] {0,1,0,-1};\n\tstatic int[] vy = new int[] {1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r == 0 && n == 0) break;\n\t\t\tint[] max = new int[50];\n\t\t\tint[] cc  = new int[50];\n\t\t\tboolean[] xx = new boolean[50];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint xa = sc.nextInt();\n\t\t\t\tint xb = sc.nextInt();\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tif(xx[xa + 20]) {\n\t\t\t\t\tmax[xa + 20] = Math.max(Math.min(h, cc[xa + 20]),max[xa + 20]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\txx[xa + 20] = true;\n\t\t\t\t\tcc[xa + 20] = h;\n\t\t\t\t}\n\t\t\t\tif(xx[xb + 20]) {\n\t\t\t\t\tmax[xb + 20] = Math.max(Math.min(h, cc[xb + 20]),max[xb + 20]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\txx[xb + 20] = true;\n\t\t\t\t\tcc[xb + 20] = h;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor(int j = xa + 21; j < xb + 20; j++) {\n\t\t\t\t\tmax[j] = Math.max(max[j], h);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble t = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor(int i = 0; i < 50; i++) {\n\t\t\t\tint x = i-20;\n\t\t\t\tint y = max[i];\n\t\t\t\tint D = 4 * (r + y)*(r + y) - 4 * (x * x + y * y + 2 * r * y);\n\t\t\t\tif(D <= 0) continue; \n\t\t\t\tdouble tt = (2 * (r + y) - Math.sqrt(4 * (r + y)*(r + y) - 4 * (x * x + y * y + 2 * r * y))) / 2 + 0.0000000000000001;\n\t\t\t\tt = Math.min(tt, t);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.20f\\n\",t);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry{\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r+n == 0) break;\n\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t}\n\t\t} catch(Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\t\n\t\n\tstatic double solve(int r, int n) {\n\t\tint[] dp = new int[40];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\t\t\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.0005) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n\n  static final int MID = 20;\n\n  void run() {\n    for (; ; ) {\n      int r = ni();\n      int n = ni();\n\n      if ( (r | n) == 0 ) {\n        break;\n      }\n\n      boolean[][] field = new boolean[ 32 ][ 64 ];\n      for ( int i = 0; i < n; ++i ) {\n        int xl = ni();\n        int xr = ni();\n        int h = ni();\n\n        for ( int k = 1; k <= h; ++k ) {\n          for ( int j = xl; j < xr; ++j ) {\n            field[ k ][ j + MID ] = true;\n          }\n        }\n      }\n      int[] hs = new int[ 32 ];\n      for ( int i = 1; i <= 20; ++i ) {\n        for ( int w = 1; field[ i ][ MID + w - 1 ] && field[ i ][ MID - w ]; ++w ) {\n          hs[ i ] = w;\n        }\n      }\n\n      // p1\n//      debug(hs);\n      int h = 0;\n      for ( int i = 1; i <= 20; ++i ) {\n        if ( hs[ i ] < r ) {\n          break;\n        }\n        ++h;\n      }\n      // p2\n      double dh = 0;\n      for(int i = 1; i <= r * 10000; ++i ) {\n        double t = (1e-4 * i);\n        int W = hs[h + (int)t + 1];\n\n        double theta = Math.acos((r - t) / r);\n        double w = r * Math.sin(theta);\n        if(w > W) {\n          break;\n        }\n        dh = t;\n      }\n//      double right = r;\n//      while ( right - dh > 1e-6 ) {\n//        double mid = (dh + right) / 2;\n//        double theta = Math.acos((r - mid) / r);\n//        double w = r * Math.sin(theta);\n//        boolean flag = true;\n//\n////        debug(mid, w);\n//        for ( int i = 0; i <= mid; ++i ) {\n//          flag &= hs[ h + i + 1 ] >= w;\n//        }\n//\n//        if ( flag ) {\n//          dh = mid;\n//        } else {\n//          right = mid;\n//        }\n//      }\n\n//      debug(h, dh);\n\n      System.out.printf(\"%.4f\\n\", h + dh);\n    }\n  }\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n\n  static final int MID = 20;\n\n  void run() {\n    for (; ; ) {\n      int r = ni();\n      int n = ni();\n\n      if ( (r | n) == 0 ) {\n        break;\n      }\n\n      boolean[][] field = new boolean[ 32 ][ 64 ];\n      for ( int i = 0; i < n; ++i ) {\n        int xl = ni();\n        int xr = ni();\n        int h = ni();\n\n        for ( int k = 1; k <= h; ++k ) {\n          for ( int j = xl; j < xr; ++j ) {\n            field[ k ][ j + MID ] = true;\n          }\n        }\n      }\n      int[] hs = new int[ 32 ];\n      for ( int i = 1; i <= 20; ++i ) {\n        for ( int w = 1; field[ i ][ MID + w - 1 ] && field[ i ][ MID - w ]; ++w ) {\n          hs[ i ] = w;\n        }\n      }\n\n      // p1\n      debug(hs);\n      int h = 0;\n      for ( int i = 1; i <= 20; ++i ) {\n        if ( hs[ i ] < r ) {\n          break;\n        }\n        ++h;\n      }\n      // p2\n      double dh = 0;\n      double right = r;\n      while ( right - dh > 1e-6 ) {\n        double mid = (dh + right) / 2;\n        boolean flag = true;\n\n        debug(dh, mid, right);\n        for ( int i = 0; i <= mid; ++i ) {\n          double theta = Math.acos((r - (mid - i)) / r);\n          double w = r * Math.sin(theta);\n//          debug(\"\\t\", w, hs[h + i + 1]);\n          flag &= hs[ h + i + 1 ] >= w;\n        }\n\n        if ( flag ) {\n          dh = mid;\n        } else {\n          right = mid;\n        }\n      }\n\n//      debug(h, dh);\n\n      System.out.printf(\"%.4f\\n\", h + dh);\n//      System.out.println(h + dh);\n    }\n  }\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static int[][] map;\n    static int[][] label;\n\n    static ArrayList<Integer> ans0;\n    static ArrayList<Integer> ans1;\n\n    static int R;\n    static int N;\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while(true){\n            R = scanner.nextInt();\n            if(R == 0)break;\n            N = scanner.nextInt();\n\n            int minx = 999999;\n            int miny = 999999;\n            double mindis = 99999;\n            double minans = 9999999;\n            map = new int[21][42];\n            for (int i = 0; i < N; i++) {\n                int x1 = scanner.nextInt();\n                int x2 = scanner.nextInt();\n                int h = scanner.nextInt();\n\n                yama(x1, x2, h);\n            }\n\n//            for (int i = 0; i < 20; i++) {\n//                System.out.print(9);\n//            }\n//            System.out.println();\n//             for (int i = 0; i < 21; i++) {\n//                for (int j = 0; j < 42; j++) {\n//                    System.out.print(map[i][j]);\n//                }\n//                System.out.println();\n//            }\n\n//            System.out.println(distance(1 , 2));\n\n            for (int i = 20 - R; i < 20 + R; i++) {\n                int ok = 0;\n                for (int j = 20; j >= 0; j--) {\n                    if(map[j][i] == 1){\n//                        System.out.println(j);\n//                        System.out.println(i - 20 + \" \" + (j + 1));\n//                        System.out.println(i - 19 + \" \" + (j + 1));\n                        if(i != 20 - R && mindis > distance(i - 20, j + 1)){\n                            mindis = distance(i - 20, j + 1);\n                            minx = i - 20;\n                            miny = j + 1;\n                        }\n                        if(i != 19 + R && mindis > distance(i - 19, j + 1)){\n                            mindis = distance(i - 19, j + 1);\n                            minx = i - 19;\n                            miny = j + 1;\n                        }\n                        if(i != 20 - R)minans = Math.min(calc(i - 20, j + 1), minans);\n                        if(i != 20 + R)minans = Math.min(calc(i - 19, j + 1), minans);\n                        ok = 1;\n                        break;\n                    }\n                }\n                if(ok == 0){\n//                    System.out.println(i - 20 + \" \" + 0);\n//                    System.out.println(i - 19 + \" \" + 0);\n                    if(mindis > distance(i - 20, 0)){\n                        mindis = distance(i - 20, 0);\n                        minx = i - 20;\n                        miny = 0;\n                    }\n                    if(mindis > distance(i - 19, 0)){\n                        mindis = distance(i - 19, 0);\n                        minx = i - 19;\n                        miny = 0;\n                    }\n                    minans = Math.min(calc(i - 20, 0), minans);\n                    minans = Math.min(calc(i - 19, 0), minans);\n                }\n            }\n\n//            System.out.println(mindis);\n//            System.out.println(minx + \" \" + (miny));\n//            System.out.println(((miny + 2) + ((1.0 * minx * minx) / (miny + 2))) - 2);\n//            System.out.println(R + miny - Math.sqrt(R * R - minx * minx));\n//            String.format(\"%.4f\", R + miny - Math.sqrt(R * R - minx * minx));\n            System.out.println(minans);\n//            System.out.println();\n\n\n//            for (int i = 0; i < 21; i++) {\n//                for (int j = 0; j < 42; j++) {\n//                    System.out.print(map[i][j]);\n//                }\n//                System.out.println();\n//            }\n\n\n\n\n\n        }\n    }\n\n    static double calc(int x, int y){\n        return  R + y - Math.sqrt(R * R - x * x);\n    }\n\n    static double distance(int x, int y){\n\n        return (y + R) * (y + R) + x * x;\n    }\n\n    static void yama(int x1, int x2, int h){\n\n        for (int i = x1 + 20; i < x2 + 20; i++) {\n            for (int j = 0; j < h; j++) {\n                map[j][i] = 1;\n            }\n        }\n\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n\n  static final int MID = 20;\n\n  void run() {\n    for (; ; ) {\n      int r = ni();\n      int n = ni();\n\n      if ( (r | n) == 0 ) {\n        break;\n      }\n\n      boolean[][] field = new boolean[ 32 ][ 64 ];\n      for ( int i = 0; i < n; ++i ) {\n        int xl = ni();\n        int xr = ni();\n        int h = ni();\n\n        for ( int k = 1; k <= h; ++k ) {\n          for ( int j = xl; j < xr; ++j ) {\n            field[ k ][ j + MID ] = true;\n          }\n        }\n      }\n      int[] hs = new int[ 32 ];\n      for ( int i = 1; i <= 20; ++i ) {\n        for ( int w = 1; field[ i ][ MID + w - 1 ] && field[ i ][ MID - w ]; ++w ) {\n          hs[ i ] = w;\n        }\n      }\n\n      // p1\n//      debug(hs);\n      int h = 0;\n      for ( int i = 1; i <= 20; ++i ) {\n        if ( hs[ i ] < r ) {\n          break;\n        }\n        ++h;\n      }\n      // p2\n      double dh = 0;\n      double right = r;\n      while ( right - dh > 1e-6 ) {\n        double mid = (dh + right) / 2;\n        boolean flag = true;\n\n//        debug(dh, mid, right);\n        for ( int i = 0; i <= mid; ++i ) {\n          double theta = Math.acos((r - (mid - i)) / r);\n          double w = r * Math.sin(theta);\n//          debug(\"\\t\", w, hs[h + i + 1]);\n          flag &= hs[ h + i + 1 ] >= w;\n        }\n\n        if ( flag ) {\n          dh = mid;\n        } else {\n          right = mid;\n        }\n      }\n\n//      debug(h, dh);\n\n      System.out.printf(\"%.4f\\n\", h + dh);\n//      System.out.println(h + dh);\n    }\n  }\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\t// int xx = i - r > 0 ? i - r + 1 : r - i - 1;\n\t\t\t\tint xx = Math.abs(r - i - 1);\n\t\t\t\tdouble t1 = cover[i] - r\n\t\t\t\t\t\t* Math.sin(Math.acos((double) Math.abs(r - i) / r));\n\t\t\t\tdouble t2 = cover[i] - r * Math.sin(Math.acos((double) xx / r));\n\t\t\t\tans = Math.min(ans, Math.min(t1 + r, t2 + r));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", ans));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int r, n;\n\tstatic int[] xl, xr, h;\n\t\n\tstatic double[] building;\n\t\n\tprivate static void start()\n\t{\n\t\tint i, j;\n\t\t\n\t\t// building作成\n\t\tbuilding = new double[4000001];\n\t\tfor(i = 0;i < 4000001;i++) building[i] = 0;\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tfor(j = xl[i] * 100000;j <= xr[i] * 100000;j++)\n\t\t\t{\n\t\t\t\tbuilding[j] = Math.max(building[j], h[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 円と重なる時間を算出\n\t\tdouble min = Double.MAX_VALUE;\n\t\tfor(i = 2000000 - r*100000;i <= 2000000 + r*100000;i++)\n\t\t{\n\t\t\tdouble w = Math.abs((double)i / 100000 - 20);\n\t\t\tdouble p = Math.sqrt(r*r - w*w);\n\t\t\tdouble t = (double)building[i] - p + (double)r;\n\t\t\tmin = Math.min(min, t);\n\t\t}\n\t\t\n\t\tSystem.out.printf(\"%.04f\\n\", min);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tr = sca.nextInt();\n\t\t\tn = sca.nextInt();\n\t\t\tif(r == 0) break;\n\t\t\t\n\t\t\txl = new int[n];\n\t\t\txr = new int[n];\n\t\t\th = new int[n];\n\t\t\tfor(int i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\txl[i] = sca.nextInt() + 20;\n\t\t\t\txr[i] = sca.nextInt() + 20;\n\t\t\t\th[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tstart();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tdouble x = Math.abs(r - i);\n\n\t\t\t\tdouble o1 = cover[i] - r * Math.sin(Math.acos((double) x / r));\n\t\t\t\tdouble o2 = cover[i] - r\n\t\t\t\t\t\t* Math.sin(Math.acos((double) (x - 1) / r));\n\t\t\t\tans = Math.min(ans, Math.min(o1 + r, o2 + r));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", ans));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j>xl+20 && j<xr+20){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(x[1][j]!=0){\n\t\t\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][20+i]==0 || x[1][20-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", min+r);\n\t\t\t}\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n\n  static final int MID = 20;\n\n  void run() {\n    for (; ; ) {\n      int r = ni();\n      int n = ni();\n\n      if ( (r | n) == 0 ) {\n        break;\n      }\n\n      boolean[][] field = new boolean[ 32 ][ 64 ];\n      for ( int i = 0; i < n; ++i ) {\n        int xl = ni();\n        int xr = ni();\n        int h = ni();\n\n        for ( int k = 1; k <= h; ++k ) {\n          for ( int j = xl; j < xr; ++j ) {\n            field[ k ][ j + MID ] = true;\n          }\n        }\n      }\n      int[] hs = new int[ 32 ];\n      for ( int i = 1; i <= 20; ++i ) {\n        for ( int w = 1; field[ i ][ MID + w - 1 ] && field[ i ][ MID - w ]; ++w ) {\n          hs[ i ] = w;\n        }\n      }\n\n      // p1\n//      debug(hs);\n      int h = 0;\n      for ( int i = 1; i <= 20; ++i ) {\n        if ( hs[ i ] < r ) {\n          break;\n        }\n        ++h;\n      }\n      // p2\n      double dh = 0;\n//      for(int i = 1; i <= r * 10000; ++i ) {\n//        double t = (1e-4 * i);\n//        int W = hs[h + (int)t + 1];\n//\n//        double theta = Math.acos((r - t) / r);\n//        double w = r * Math.sin(theta);\n//        if(w > W) {\n//          break;\n//        }\n//        dh = t;\n//      }\n      double right = r;\n      while ( right - dh > 1e-6 ) {\n        double mid = (dh + right) / 2;\n        double theta = Math.acos((r - mid) / r);\n        double w = r * Math.sin(theta);\n        boolean flag = true;\n\n//        debug(mid, w);\n        for ( int i = 0; i <= mid; ++i ) {\n          flag &= hs[ h + i + 1 ] >= w;\n        }\n\n        if ( flag ) {\n          dh = mid;\n        } else {\n          right = mid;\n        }\n      }\n\n//      debug(h, dh);\n\n//      System.out.printf(\"%.3f\\n\", h + dh);\n      System.out.println(h + dh);\n    }\n  }\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j>xl+20 && j<xr+20){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(x[1][j]!=0){\n\t\t\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][20+i]==0 || x[1][20-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\", min+r);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\t//\tpublic static HashMap<Integer, Integer> hei = new HashMap<Integer, Integer>();\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif(r == 0) break;\n\t\t\tint[] h = new int[41];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint xl = in.nextInt();\n\t\t\t\tint xr = in.nextInt();\n\t\t\t\tint hei = in.nextInt();\n\t\t\t\tfor(int j=xl+20; j<xr+20; j++){\n\t\t\t\t\th[j] = Math.max(h[j], hei);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] p = new int[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tp[i+r-1] = Math.min(h[20+i], h[20+i-1]);\n\t\t\t}\n\t\t\tdouble[] circle = new double[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tcircle[i+r-1] = Math.sqrt(r*r-i*i)-r;\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\tout: for(double t=0.00001; t<=20.00000; t+=0.00001){\n\t\t\t\tfor(int i=0; i<r*2-1; i++){\n\t\t\t\t\tif(circle[i]+t > p[i]){\n\t\t\t\t\t\tres = t-0.00001;\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(String.format(\"%.4f\", res));\n\t\t}\n\t}\n\n\t//\tpublic static void setMap(int x, int y){\n\t//\t\tif(hei.containsKey(x)){\n\t//\t\t\tint by = hei.get(x);\n\t//\t\t\t\n\t//\t\t}else{\n\t//\t\t\thei.put(x, y);\n\t//\t\t}\n\t//\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\t//\tpublic static HashMap<Integer, Integer> hei = new HashMap<Integer, Integer>();\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif(r == 0) break;\n\t\t\tint[] h = new int[41];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint xl = in.nextInt();\n\t\t\t\tint xr = in.nextInt();\n\t\t\t\tint hei = in.nextInt();\n\t\t\t\tfor(int j=xl+20; j<xr+20; j++){\n\t\t\t\t\th[j] = Math.max(h[j], hei);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] p = new int[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tp[i+r-1] = Math.min(h[20+i], h[20+i-1]);\n\t\t\t}\n\t\t\tdouble[] circle = new double[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tcircle[i+r-1] = Math.sqrt(r*r-i*i)-r;\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\tout: for(double t=0.00001; t<=20.00000; t+=0.00001){\n\t\t\t\tfor(int i=0; i<r*2-1; i++){\n\t\t\t\t\tif(circle[i]+t > p[i]){\n\t\t\t\t\t\tres = t;\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t//\tpublic static void setMap(int x, int y){\n\t//\t\tif(hei.containsKey(x)){\n\t//\t\t\tint by = hei.get(x);\n\t//\t\t\t\n\t//\t\t}else{\n\t//\t\t\thei.put(x, y);\n\t//\t\t}\n\t//\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint r = ir.nextInt();\n\t\t\tint n = ir.nextInt();\n\t\t\tif (r == 0 && n == 0)\n\t\t\t\treturn;\n\t\t\tint offset = r + 1;\n\t\t\tint[] h = new int[offset << 1];\n\t\t\th[0] = h[(offset << 1) - 1] = 1 << 30;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xl = ir.nextInt();\n\t\t\t\tint xr = ir.nextInt();\n\t\t\t\tint xh = ir.nextInt();\n\t\t\t\tfor (int j = Math.max(-r, xl); j < Math.min(r, xr); j++) {\n\t\t\t\t\th[j + offset] = Math.max(h[j + offset], xh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble mi = 1e9;\n\t\t\tfor (int i = -r; i <= r; i++) {\n\t\t\t\tmi = Math.min(mi, Math.min(h[i + offset - 1], h[i + offset]) + (double) r\n\t\t\t\t\t\t- Math.sqrt((double) r * r - (double) i * i));\n\t\t\t}\n\t\t\tout.println(mi);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n\n  static final int MID = 20;\n\n  void run() {\n    for (; ; ) {\n      int r = ni();\n      int n = ni();\n\n      if ( (r | n) == 0 ) {\n        break;\n      }\n\n      boolean[][] field = new boolean[ 64 ][ 32 ];\n      for ( int i = 0; i < n; ++i ) {\n        int xl = ni();\n        int xr = ni();\n        int h = ni();\n\n        for ( int j = xl; j < xr; ++j ) {\n          for ( int k = 1; k <= h; ++k ) {\n            field[ k ][ j + MID ] = true;\n          }\n        }\n      }\n      int[] hs = new int[ 32 ];\n      for ( int i = 1; i <= 20; ++i ) {\n        for ( int w = 1; field[ i ][ MID + w - 1 ] && field[ i ][ MID - w ]; ++w ) {\n          hs[ i ] = w;\n        }\n      }\n\n      // p1\n//      debug(hs);\n      int h = 0;\n      for ( int i = 1; i <= 20; ++i ) {\n        if ( hs[ i ] < r ) {\n          break;\n        }\n        ++h;\n      }\n      // p2\n      double dh = 0;\n      double right = r;\n      while ( right - dh > 1e-6 ) {\n        double mid = (dh + right) / 2;\n        double theta = Math.acos((r - mid) / r);\n        double w = r * Math.sin(theta);\n        boolean flag = true;\n\n//        debug(mid, w);\n        for ( int i = 0; i <= mid; ++i ) {\n          flag &= hs[ h + i + 1 ] >= w;\n        }\n\n        if ( flag ) {\n          dh = mid;\n        } else {\n          right = mid;\n        }\n      }\n\n//      debug(h, dh);\n\n      System.out.printf(\"%.4f\\n\", h + dh);\n    }\n  }\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n\n  static final int MID = 20;\n\n  void run() {\n    for (; ; ) {\n      int r = ni();\n      int n = ni();\n\n      if ( (r | n) == 0 ) {\n        break;\n      }\n\n      boolean[][] field = new boolean[ 32 ][ 64 ];\n      for ( int i = 0; i < n; ++i ) {\n        int xl = ni();\n        int xr = ni();\n        int h = ni();\n\n        for ( int k = 1; k <= h; ++k ) {\n          for ( int j = xl; j < xr; ++j ) {\n            field[ k ][ j + MID ] = true;\n          }\n        }\n      }\n      int[] hs = new int[ 32 ];\n      for ( int i = 1; i <= 20; ++i ) {\n        for ( int w = 1; field[ i ][ MID + w - 1 ] && field[ i ][ MID - w ]; ++w ) {\n          hs[ i ] = w;\n        }\n      }\n\n      // p1\n//      debug(hs);\n      int h = 0;\n      for ( int i = 1; i <= 20; ++i ) {\n        if ( hs[ i ] < r ) {\n          break;\n        }\n        ++h;\n      }\n      // p2\n      double dh = 0;\n      double right = r;\n      while ( right - dh > 1e-6 ) {\n        double mid = (dh + right) / 2;\n        double theta = Math.acos((r - mid) / r);\n        double w = r * Math.sin(theta);\n        boolean flag = true;\n\n//        debug(mid, w);\n        for ( int i = 0; i <= mid; ++i ) {\n          flag &= hs[ h + i + 1 ] >= w;\n        }\n\n        if ( flag ) {\n          dh = mid;\n        } else {\n          right = mid;\n        }\n      }\n\n//      debug(h, dh);\n\n      System.out.printf(\"%.4f\\n\", h + dh);\n    }\n  }\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] map;\n\tstatic int[][] directions8= {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\tstatic int[][] directions4= {{-1,0},{1,0},{0,-1},{0,1}};\n\tstatic double ans;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif((n|r)==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//[x軸][y軸]\n\t\t\tboolean[][] plusArea = new boolean[20][20];\n\t\t\tboolean[][] minusArea = new boolean[20][20];\n\n\t\t\tfor(int i = 0;i<n ; i++) {\n\t\t\t\tint startX = sc.nextInt();\n\t\t\t\tint endX = sc.nextInt();\n\t\t\t\tint height = sc.nextInt();\n\n\t\t\tif(startX >= 0) {\n\t\t\t\tfor(int h = 0;h<height ; h++) {\n\t\t\t\t\tfor(int j = startX; j<endX; j++) {\n\t\t\t\t\t\tplusArea[j][h] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if (endX <= 0) {\n\t\t\t\tstartX *= -1;\n\t\t\t\tendX *= -1;\n\t\t\t\tfor(int h = 0;h<height ; h++) {\n\t\t\t\t\tfor(int j = endX; j< startX; j++) {\n\t\t\t\t\t\tminusArea[j][h] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tstartX *= -1;\n\t\t\t\tfor(int h = 0;h<height ; h++) {\n\t\t\t\t\tfor(int j = startX-1; j>=0; j--) {\n\t\t\t\t\t\tminusArea[j][h] = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 0; j<endX; j++) {\n\t\t\t\t\t\tplusArea[j][h] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\t\t\t//x軸、y軸。象限両用\n\t\t\tdouble dist[][] = new double[20][20];\n\n\t\t\tfor(int i = 0;i<20 ; i++) {\n\t\t\tArrays.fill(dist[i], Double.MAX_VALUE);\n\t\t\t}\n\n\t\t\t//全ての升について必要になる時間を出す\n\t\t\tfor(int i = 0;i<r ; i++) {\n\t\t\t\tfor(int j = 0;j<20 ; j++) {\n\n\t\t\t\t\tif(i == 0) {\n\t\t\t\t\t\tdist[i][j] = j;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(j==0) {\n\t\t\t\t\t\tdist[i][j] = j;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(j == 0) {\n\t\t\t\t\t\tdist[i][j] = r-Math.sqrt(r*r-i*i);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdist[i][j] = dist[i][j-1]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 20;\n\t\t\tfor(int i = 0;i<r ; i++) {\n\t\t\t\tfor(int j = 0;j<20 ; j++) {\n\t\t\t\t\tif(!plusArea[i][j] || !minusArea[i][j]) {\n\t\t\t\t\t\tif(ans > dist[i][j]) {\n\t\t\t\t\t\t\tans = dist[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\n\n\t}\n\n\t//BFS用に二つの配列を足し算する\n\tstatic int[] addArrayElms(int[] a, int[] b) {\n\t\tint[] c = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t\treturn c;\n\t}\n\n\t//\t//二分探索\n\t//k <= num となる最小の配列要素kのインデックスを返す\n\tstatic private int binarySearch(long num, long[] orderedArray){\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedArray.length;\n\t\tint mid;\n\n\t\twhile(upperBorder - lowerBorder >1) {\n\t\t\tmid = (upperBorder + lowerBorder)/2;\n\t\t\tif(orderedArray[mid]<=num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t}else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t//二分探索\n\t//k <= num となる最小のList要素kのインデックスを返す\n\tstatic private int binarySearch(long num, ArrayList<Long> orderedList){\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedList.size();\n\t\tint mid;\n\n\t\twhile(upperBorder - lowerBorder >1) {\n\t\t\tmid = (upperBorder + lowerBorder)/2;\n\t\t\tif(orderedList.get(mid)<=num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t}else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t//aとbの最小公倍数を求める\n\tpublic static int gcd(int a, int b) {\n\t\treturn b == 0 ? a: gcd(b, a % b);\n\t}\n\tpublic static long gcd(long a, long b) {\n\t\treturn b == 0 ? a: gcd(b, a % b);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tint xx = i - r > 0 ? i - r + 1 : r - i - 1;\n\t\t\t\tdouble t1 = cover[i] - r\n\t\t\t\t\t\t* Math.sin(Math.acos((double) Math.abs(r - i) / r));\n\t\t\t\tdouble t2 = cover[i] - r * Math.sin(Math.acos((double) xx / r));\n\t\t\t\tans = Math.min(ans, Math.min(t1 + r, t2 + r));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", ans));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// AOJ 1194 \"バンパイア\" (ICPC国内予選 2014 Problem C)\nimport java.util.Scanner;\n\npublic class Main {\n    public static double INF = 100.0;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int r = sc.nextInt();\n            int n = sc.nextInt();\n            if (r == 0) {\n                break;\n            }\n            \n            int[] field = new int[40]; // field[x]: 区間[x-20, x-19）地点の影の高さ\n            for (int i = 0; i < n; i++) {\n                int xl = sc.nextInt();\n                int xr = sc.nextInt();\n                int h  = sc.nextInt();\n                \n                for (int j = xl + 20; j < xr + 20; j++) {\n                    field[j] = Math.max(field[j], h);\n                }\n            }\n            //printHeight(field);\n            double minTime = INF;\n            for (int i = 0; i < field.length; i++) {\n                minTime = Math.min(minTime, crossTime(i - 20, field[i], r));\n                minTime = Math.min(minTime, crossTime(i + 1 - 20, field[i], r));\n            }\n            System.out.println(minTime);\n        }\n    }\n    \n    public static double crossTime(int x, int y, int r) {\n        //System.out.println(\"x: \" + x + \", y: \" + y + \", r: \" + r);\n        int d = (int)Math.pow(-2 * (y + r), 2) - 4 * (x * x + y * y + 2 * y * r);\n        if (d <= 0) {\n            return INF;\n        } else {\n            double ans = (2 * (y + r) - Math.sqrt(d)) / 2;\n            //System.out.println(d + \" \" + Math.sqrt(d) + \" \" + ans);\n            return ans;\n        }\n    }\n    \n    public static void printHeight(int[] field) {\n        for (int i = 0; i < field.length; i++) {\n            System.out.println((i - 20) + \"-\" + ((i - 20) + 1) + \": \" + field[i]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble res = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tint xx = i - r > 0 ? i - r + 1 : r - i - 1;\n\t\t\t\tdouble t1 = cover[i]\n\t\t\t\t\t\t+ r\n\t\t\t\t\t\t* (1 - Math\n\t\t\t\t\t\t\t\t.sin(Math.acos((double) Math.abs(r - i) / r)));\n\t\t\t\tdouble t2 = cover[i] + r\n\t\t\t\t\t\t* (1 - Math.sin(Math.acos((double) xx / r)));\n\t\t\t\tres = Math.min(res, Math.min(t1, t2));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", res));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r==0 && n==0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tsolve(r, n, xl, xr, h);\n\t\t}\n\t}\n\n\tpublic void solve(int r, int n, int[] xl, int[] xr, int[] h) {\n\t\t\n\t\t\n\t\tint[] cover = new int[2*r];\n\t\tfor(int i=0;i<xl.length;i++){\n\t\t\txl[i]+=r;\n\t\t\txr[i]+=r;\n\t\t\txl[i] = xl[i]<0 ? 0 : xl[i];\n\t\t\txr[i] = xr[i]<0 ? 0 : xr[i];\n\t\t\t\n\t\t\tint ll = Math.min(xl[i], xr[i]);\n\t\t\tint rr = Math.min(r*2, Math.max(xl[i], xr[i]));\n\t\t\t\n\t\t\tint c = h[i];\n\t\t\tfor(int j=ll;j<rr;j++){\n\t\t\t\tcover[j] = Math.max(cover[j], c);\n\t\t\t}\n\t\t}\n\t\t\n//\t\tSystem.out.println(Arrays.toString(cover));\n\t\tdouble res = 100000.0;\n\t\tfor(int i=0;i<cover.length;i++){\n\t\t\tint xx = i-r>0 ? i-r+1 : r-i-1;\n\t\t\tdouble t1 = cover[i] + r*(1-Math.sin(Math.acos((double)Math.abs(r-i)/r)));\n\t\t\tdouble t2 = cover[i] + r*(1-Math.sin(Math.acos((double)xx/r)));\n\t\t\tres = Math.min(res, Math.min(t1,t2));\n\t\t}\n\t\t\n\t\tSystem.out.println(String.format(\"%.4f\",res));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint R = sc.nextInt();\n\t\t\tint N = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tint[] H = new int[41];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tfor (int j = l; j < r; ++j) {\n\t\t\t\t\tH[j + 20] = Math.max(H[j + 20], h);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ans = 1e9;\n\t\t\tfor (int i = -R; i < R; ++i) {\n\t\t\t\tint h = H[i + 20];\n\t\t\t\tint w = i < 0 ? -i - 1 : i;\n\t\t\t\tdouble y = Math.sqrt(R * R - w * w);\n\t\t\t\tans = Math.min(ans, R + h - y);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\", ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Main {\n\tint r;\n\tSet<Point> list;\n\n\tclass Point implements Comparable<Point>{\n\t\tint x, y;\n\n\t\tPoint(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.x != o.x ? this.x - o.x : this.y - o.y;\n\t\t}\n\t}\n\n\tboolean check(double h) {\n\t\tfor (Point P: list) {\n\t\t\tdouble dx = Math.abs(1.0 * P.x - 20);\n\t\t\tdouble dy = Math.abs(1.0 * P.y - h);\n\t\t\tdouble len = Math.hypot(dx, dy);\n\t\t\tif (len < r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid makePointSet(int[] f) {\n\t\tlist = new TreeSet<Point>();\n\t\tif (f[0] != 0) {\n\t\t\tlist.add(new Point(0, f[0]));\n\t\t\tlist.add(new Point(0, 0));\n\t\t}\n\t\tfor (int i = 1; i < 50; i++) {\n\t\t\tif (f[i] == f[i - 1]) continue;\n\t\t\tlist.add(new Point(i, f[i - 1]));\n\t\t\tlist.add(new Point(i, f[i]));\n\t\t\t//\t\t\tlist.add(new Point(i, 0));\n\t\t}\n\n\t\t/*\n\t\tfor (Point P: list) {\n\t\t\tSystem.out.println((P.x - 20) + \", \" + P.y);\n\t\t}\n\t\tSystem.out.println();\n\t\t */\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tr = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif ((r | n) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] f = new int[50];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xl = sc.nextInt() + 20;\n\t\t\t\tint xr = sc.nextInt() + 20;\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tfor (int j = xl; j < xr; j++) {\n\t\t\t\t\tf[j] = Math.max(f[j], h);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmakePointSet(f);\n\n\t\t\tdouble low = -r, high = Math.max(f[19], f[20]) - r;\n\t\t\tdouble EPS = 1E-10;\n\t\t\twhile (EPS < high - low) {\n\t\t\t\tdouble mid = (low + high) / 2;\n\t\t\t\tif (check(mid)) {\n\t\t\t\t\tlow = mid;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(low + r);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r+n == 0) break;\n\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t}\n\t}\n\t\n\t\n\tstatic double solve(int r, int n) throws {\n\t\tint[] dp = new int[39];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\t\t\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.001) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry{\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r+n == 0) break;\n\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t}\n\t\t} catch(Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\t\n\t\n\tstatic double solve(int r, int n) {\n\t\tint[] dp = new int[40];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.0005) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist <= (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\t\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j>xl+20 && j<xr+20){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][20+i]==0 || x[1][20-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", min+r);\n\t\t\t}\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint CENTER = 20;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint r = in.nextInt(), n = in.nextInt();\n\t\t\tif (r == 0) break;\n\t\t\t\n\t\t\tint[] height = new int[CENTER*2+1];\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xl = in.nextInt(), xr = in.nextInt(), h = in.nextInt();\n\t\t\t\tfor (int j = CENTER + xl; j < CENTER + xr; j++) {\n\t\t\t\t\theight[j] = Math.max(height[j], h);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Point> plist = new ArrayList<Point>();\n\t\t\tint prev = 0;\n\t\t\tfor (int i = 0; i < height.length; i++) {\n\t\t\t\tif (prev != height[i]) {\n\t\t\t\t\tplist.add(new Point(i-CENTER, height[i]));\n\t\t\t\t\tplist.add(new Point(i-CENTER, prev));\n\t\t\t\t}\n\t\t\t\tprev = height[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor (double t = 0; t <= 40; t += 0.00001) {\n\t\t\t\tdouble y = -r + t;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (Point pt : plist) {\n\t\t\t\t\tdouble dx = pt.x, dy = pt.y - y;\n\t\t\t\t\tif (dx * dx + dy * dy < r * r) ok = false; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!ok) {\n\t\t\t\t\tSystem.out.println(t-0.00001);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile(true) {\n\t\t\ttry{\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(r+n == 0) continue;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t\t}catch(Exception e){\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic double solve(int r, int n) throws Exception {\n\t\tint[] dp = new int[39];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.001) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\t//\tpublic static HashMap<Integer, Integer> hei = new HashMap<Integer, Integer>();\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif(r == 0) break;\n\t\t\tint[] h = new int[41];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint xl = in.nextInt();\n\t\t\t\tint xr = in.nextInt();\n\t\t\t\tint hei = in.nextInt();\n\t\t\t\tfor(int j=xl+20; j<xr+20; j++){\n\t\t\t\t\th[j] = Math.max(h[j], hei);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] p = new int[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tp[i+r-1] = Math.min(h[20+i], h[20+i-1]);\n\t\t\t}\n\t\t\tdouble[] circle = new double[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tcircle[i+r-1] = Math.sqrt(r*r-i*i)-r;\n\t\t\t}\n\t\t\tdouble res = 100;\n\t\t\tfor(int i=0; i<r*2-1; i++){\n\t\t\t\tres = Math.min(res, p[i]-circle[i]);\n\t\t\t}\n\t\t\tSystem.out.println(String.format(\"%.4f\", res));\n\t\t}\n\t}\n\n\t//\tpublic static void setMap(int x, int y){\n\t//\t\tif(hei.containsKey(x)){\n\t//\t\t\tint by = hei.get(x);\n\t//\t\t\t\n\t//\t\t}else{\n\t//\t\t\thei.put(x, y);\n\t//\t\t}\n\t//\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r+n == 0) break;\n\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t}\n\t}\n\t\n\t\n\tstatic double solve(int r, int n) {\n\t\tint[] dp = new int[39];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\t\t\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.001) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint CENTER = 20;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint r = in.nextInt(), n = in.nextInt();\n\t\t\tif (r == 0) break;\n\t\t\t\n\t\t\tint[] height = new int[CENTER*2+1];\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xl = in.nextInt(), xr = in.nextInt(), h = in.nextInt();\n\t\t\t\tfor (int j = CENTER + xl; j < CENTER + xr; j++) {\n\t\t\t\t\theight[j] = Math.max(height[j], h);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Point> plist = new ArrayList<Point>();\n\t\t\tint prev = 0;\n\t\t\tfor (int i = 0; i < height.length; i++) {\n\t\t\t\tif (prev != height[i]) {\n\t\t\t\t\tplist.add(new Point(i-CENTER, height[i]));\n\t\t\t\t\tplist.add(new Point(i-CENTER, prev));\n\t\t\t\t}\n\t\t\t\tprev = height[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor (double t = 0; t <= 40; t += 0.0001) {\n\t\t\t\tdouble y = -r + t;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (Point pt : plist) {\n\t\t\t\t\tdouble dx = pt.x, dy = pt.y - y;\n\t\t\t\t\tif (dx * dx + dy * dy < r * r) ok = false; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!ok) {\n\t\t\t\t\tSystem.out.println(t-0.0001);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplist.clear();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j>xl+20 && j<xr+20){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(x[1][j]!=0){\n\t\t\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tif((j==xl+20 || j==xr+20) && x[1][j]==0){\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0; i<41; i++){\n\t\t\t\tSystem.out.println(x[0][i]+\" \"+x[1][i]);\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][20+i]==0 || x[1][20-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\", min+r);\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint r=sc.nextInt();\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tint[] b=new int[83];\n\t\t\t\tif(r==0 && n==0)\tbreak;\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tint lx=sc.nextInt();\n\t\t\t\t\tint rx=sc.nextInt();\n\t\t\t\t\tint h=sc.nextInt();\n\t\t\t\t\tfor(int j=lx*2+41; j<=rx*2+40; j++) {//start endわけるために2倍\n\t\t\t\t\t\tb[j]=Math.max(b[j], h);\n\t\t\t\t\t}\n\t\t\t\t}//入力\n\t\t\t\tdouble t=1000000000.0;\n\t\t\t\tfor(int i=0; i<=81; i++) {\n\t\t\t\t\tdouble x=(i/2)-20;\n\t\t\t\t\tif(r*r-x*x>0) {\n\t\t\t\t\t\tdouble y=b[i];\n\t\t\t\t\t\tt=Math.min(y+r-Math.sqrt(r*r-x*x), t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(t);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint CENTER = 20;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint r = in.nextInt(), n = in.nextInt();\n\t\t\tif (r == 0) break;\n\t\t\t\n\t\t\tint[] height = new int[CENTER*2+1];\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xl = in.nextInt(), xr = in.nextInt(), h = in.nextInt();\n\t\t\t\tfor (int j = CENTER + xl; j < CENTER + xr; j++) {\n\t\t\t\t\theight[j] = Math.max(height[j], h);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Point> plist = new ArrayList<Point>();\n\t\t\tint prev = 0;\n\t\t\tfor (int i = 0; i < height.length; i++) {\n\t\t\t\tif (prev != height[i]) {\n\t\t\t\t\tplist.add(new Point(i-CENTER, height[i]));\n\t\t\t\t\tplist.add(new Point(i-CENTER, prev));\n\t\t\t\t} else if (i == CENTER) {\n\t\t\t\t\tplist.add(new Point(0, height[i]));\n\t\t\t\t}\n\t\t\t\tprev = height[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor (double t = 0; t <= 40; t += 0.0001) {\n\t\t\t\tdouble y = -r + t;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (Point pt : plist) {\n\t\t\t\t\tdouble dx = pt.x, dy = pt.y - y;\n\t\t\t\t\tif (dx * dx + dy * dy < r * r) ok = false; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!ok) {\n\t\t\t\t\tSystem.out.println(t-0.0001);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplist.clear();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tint x = Math.abs(r - i);\n\t\t\t\tint xx = Math.abs(r - i - 1);\n\t\t\t\tdouble o1 = cover[i] - Math.sqrt(r * r - x * x);\n\t\t\t\tdouble o2 = cover[i] - Math.sqrt(r * r - xx * xx);\n\t\t\t\tans = Math.min(ans, Math.min(o1 + r, o2 + r));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", ans));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry{\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r+n == 0) break;\n\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t}\n\t\t} catch(Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\t\n\t\n\tstatic double solve(int r, int n) {\n\t\tint[] dp = new int[39];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\t\t\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.001) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j>xl+20 && j<xr+20){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(x[1][j]!=0){\n\t\t\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tif((j==xl+20 || j==xr+20) && x[1][j]==0){\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][20+i]==0 || x[1][20-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\", min+r);\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\t//\tpublic static HashMap<Integer, Integer> hei = new HashMap<Integer, Integer>();\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif(r == 0) break;\n\t\t\tint[] h = new int[41];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint xl = in.nextInt();\n\t\t\t\tint xr = in.nextInt();\n\t\t\t\tint hei = in.nextInt();\n\t\t\t\tfor(int j=xl+20; j<xr+20; j++){\n\t\t\t\t\th[j] = Math.max(h[j], hei);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] p = new int[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tp[i+r-1] = Math.min(h[20+i], h[20+i-1]);\n\t\t\t}\n\t\t\tdouble[] circle = new double[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tcircle[i+r-1] = Math.sqrt(r*r-i*i)-r;\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\tout: for(double t=0.00001; t<=20.00000; t+=0.00001){\n\t\t\t\tfor(int i=0; i<r*2-1; i++){\n\t\t\t\t\tif(circle[i]+t > p[i]){\n\t\t\t\t\t\tres = t-0.00001;\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t//\tpublic static void setMap(int x, int y){\n\t//\t\tif(hei.containsKey(x)){\n\t//\t\t\tint by = hei.get(x);\n\t//\t\t\t\n\t//\t\t}else{\n\t//\t\t\thei.put(x, y);\n\t//\t\t}\n\t//\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1194().doIt();\n    }\n    class aoj1194{\n    \tint po_h[] = new int[21];\n    \tint ne_h[] = new int[21];\n    \tvoid clear(){\n    \t\tfor(int i = 0;i < 21;i++){\n    \t\t\tpo_h[i] = 0;\n    \t\t\tne_h[i] = 0;\n    \t\t}\n    \t}\n    \tvoid bar(int n){\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tint xl = sc.nextInt();\n    \t\t\tint xr = sc.nextInt();\n    \t\t\tint h = sc.nextInt();\n    \t\t\tif(xr <= 0){\n    \t\t\t\tfor(int j = -xr + 1;j < -xl + 1;j++){\n    \t\t\t\t\tne_h[j] = h;\n    \t\t\t\t}\n    \t\t\t}else if(xl >= 0){\n    \t\t\t\tfor(int j = xl + 1;j < xr + 1;j++){\n    \t\t\t\t\tpo_h[j] = h;\n    \t\t\t\t}\n    \t\t\t}else{\n    \t\t\t\tfor(int j = 0;j < -xl + 1;j++){\n    \t\t\t\t\tne_h[j] = h;\n    \t\t\t\t}\n    \t\t\t\tfor(int j = 0;j < xr + 1;j++){\n    \t\t\t\t\tpo_h[j] = h;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid check(){\n    \t\tfor(int i = 0;i < 21;i++){\n    \t\t\tSystem.out.print(ne_h[i]);\n    \t\t}\n    \t\tSystem.out.println();\n    \t\tfor(int i = 0;i < 21;i++){\n    \t\t\tSystem.out.print(po_h[i]);\n    \t\t}\n    \t\tSystem.out.println();\n    \t\tSystem.out.println();\n    \t}\n    \tdouble ans(int r){\n    \t\tdouble result = 10000;\n    \t\tfor(int i = 1;i <= r;i++){\n    \t\t\tdouble line = Math.min(ne_h[i], po_h[i]);\n    \t\t\tdouble high = (double)r - Math.sqrt((double)(r * r - (i-1)*(i-1)));\n    \t\t\tline = line + high;\n    \t\t\tresult = Math.min(result, line);\n//    \t\t\tSystem.out.println(high);\n    \t\t}\n    \t\treturn result;\n    \t}\n    \tvoid doIt(){\n     \t\twhile(true){\n     \t\t\tint r = sc.nextInt();\n     \t\t\tint n = sc.nextInt();\n     \t\t\tif(r + n == 0)break;\n     \t\t\tclear();\n     \t\t\tbar(n);\n//     \t\t\tcheck();\n     \t\t\tSystem.out.printf(\"%.4f\",ans(r));\n     \t\t\tSystem.out.println();\n     \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.xml.crypto.Data;\n\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n     \n     \npublic class Main {\n\tstatic int W;\n\tstatic int H;\n\tstatic int N;\n\tstatic boolean[][] fld;\n\tstatic int[] vx = new int[] {0,1,0,-1};\n\tstatic int[] vy = new int[] {1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r == 0 && n == 0) break;\n\t\t\tint[] L = new int[50];\n\t\t\tint[] R = new int[50];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint xa = sc.nextInt();\n\t\t\t\tint xb = sc.nextInt();\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tL[xa + 20] = Math.max(h, L[xa + 20]);\n\t\t\t\tR[xb + 20] = Math.max(h, R[xb + 20]);\n\t\t\t\tfor(int j = xa + 21; j < xb + 20; j++) {\n\t\t\t\t\tL[j] = Math.max(h, L[j]);\n\t\t\t\t\tR[j] = Math.max(h, R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble t = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor(int i = 0; i < 50; i++) {\n\t\t\t\tint x = i-20;\n\t\t\t\tint y = Math.min(L[i], R[i]);\n\t\t\t\tint D = 4 * (r + y)*(r + y) - 4 * (x * x + y * y + 2 * r * y);\n\t\t\t\tif(D <= 0) continue; \n\t\t\t\tdouble tt = (2 * (r + y) - Math.sqrt(4 * (r + y)*(r + y) - 4 * (x * x + y * y + 2 * r * y))) / 2 + 0.0000000000000001;\n\t\t\t\tt = Math.min(tt, t);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.20f\\n\",t);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in,java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n\n    int r, n, i, j, xl, xr, h;\n    int[] maxh;\n    double t, mint;\n\n    for(;;){\n      r = sc.nextInt(); n = sc.nextInt();\n      if(r == 0 && n == 0)break;\n\n      maxh = new int[40];   //maxh[i] [i - 20, i - 19]\n      for(i = 0;i < 40;i++)maxh[i] = 0;\n\n      for(i = 0;i < n;i++){\n        xl = sc.nextInt(); xr = sc.nextInt(); h = sc.nextInt();\n        for(j = xl;j < xr;j++){   //silhouette\n          if(maxh[j + 20] < h)maxh[j + 20] = h;\n        }\n      }\n\n      mint = 21;\n      for(i = 0;i < r;i++){\n        t = (double)maxh[19 + i] + (double)r - Math.sqrt(r * r - i * i);\n        if(mint > t)mint = t;\n        t = (double)maxh[20 + i] + (double)r - Math.sqrt(r * r - i * i);\n        if(mint > t)mint = t;\n        t = (double)maxh[19 - i] + (double)r - Math.sqrt(r * r - i * i);\n        if(mint > t)mint = t;\n        t = (double)maxh[20 - i] + (double)r - Math.sqrt(r * r - i * i);\n        if(mint > t)mint = t;\n      }\n      out.println(mint);\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in,System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n \npublic class Main{\n\t\n \n\tpublic void solve(){\n\t\twhile(true){\n\t\t\tint R = nextInt();\n\t\t\tint N = nextInt();\n\t\t\tif(R == 0) break;\n\t\t\tint[] build = new int[41];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tint l = nextInt();\n\t\t\t\tint r = nextInt();\n\t\t\t\tint h = nextInt();\n\t\t\t\tfor(;  l < r; l++){\n\t\t\t\t\tbuild[l + 20] = Math.max(build[l + 20], h);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ans = 10000;\n\t\t\t\n\t\t\tfor(int i = 0; i <= 20; i++){\n\t\t\t\tif(i >= R) break;\n\t\t\t\tint h = build[i + 20];\n\t\t\t\tans = Math.min(ans, R + h - Math.sqrt(R * R - i * i));\n\t\t\t\t\n\t\t\t\th = build[20 - 1 - i];\n\t\t\t\tans = Math.min(ans, R + h - Math.sqrt(R * R - i * i));\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\t//\tpublic static HashMap<Integer, Integer> hei = new HashMap<Integer, Integer>();\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif(r == 1 && n == 13){\n\t\t\t\tSystem.out.println(r);\n\t\t\t}\n\t\t\tif(r == 0) break;\n\t\t\tint[] h = new int[41];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint xl = in.nextInt();\n\t\t\t\tint xr = in.nextInt();\n\t\t\t\tint hei = in.nextInt();\n\t\t\t\tfor(int j=xl+20; j<xr+20; j++){\n\t\t\t\t\th[j] = Math.max(h[j], hei);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] p = new int[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tp[i+r-1] = Math.min(h[20+i], h[20+i-1]);\n\t\t\t}\n\t\t\tdouble[] circle = new double[r*2-1];\n\t\t\tfor(int i=-r+1; i<r; i++){\n\t\t\t\tcircle[i+r-1] = Math.sqrt(r*r-i*i)-r;\n\t\t\t}\n\t\t\tdouble res = -1;\n\t\t\tout: for(double t=0.00001; t<=20.00000; t+=0.00001){\n\t\t\t\tfor(int i=0; i<r*2-1; i++){\n\t\t\t\t\tif(circle[i]+t > p[i]){\n\t\t\t\t\t\tres = t-0.00001;\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res < 0){\n\t\t\t\tres = 20;\n\t\t\t}\n\t\t\tSystem.out.println(String.format(\"%.4f\", res)+\": \"+r+\",\"+n);\n\t\t}\n\t}\n\n\t//\tpublic static void setMap(int x, int y){\n\t//\t\tif(hei.containsKey(x)){\n\t//\t\t\tint by = hei.get(x);\n\t//\t\t\t\n\t//\t\t}else{\n\t//\t\t\thei.put(x, y);\n\t//\t\t}\n\t//\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() {\n\t\tnew Vampire().main();\n\t}\n\n\tclass Vampire{\n\t\tfinal int MAX = Integer.MAX_VALUE;\n\t\tvoid main() {\n\t\t\twhile(true) {\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0 && r == 0)return;\n\t\t\t\tdouble ymin[] = new double[41];//xが整数\n\t\t\t\tdouble b[] = new double[40];//xが整数+0.5\n\t\t\t\tArrays.fill(ymin, MAX);\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tint left = sc.nextInt();\n\t\t\t\t\tint right = sc.nextInt();\n\t\t\t\t\tint h = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = left; j < right; j++) {\n\t\t\t\t\t\tb[j + 20] = Math.max(b[j + 20], h);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tymin[0] = b[0];\n\t\t\t\tymin[40] = b[39];\n\t\t\t\tfor(int i = -19; i < 20; i++) {\n\t\t\t\t\tymin[i + 20] = Math.min(b[i + 19], b[i + 20]);\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\tfor(int i = -20; i <= 20; i++) {\n\t\t\t\t\tif(i <= -r || i >= r) {\n\t\t\t\t\t\tymin[i + 20] = 21;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdouble x = Math.abs(i);\n\t\t\t\t\t\tdouble a = Math.acos(x /r);\n\t\t\t\t\t\tdouble diff = r * Math.sin(a);\n\t\t\t\t\t\t//System.out.println(x + \" \" + a + \" \" + diff);\n\t\t\t\t\t\tymin[i + 20] -= diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdouble min = 21.0;\n\t\t\t\tfor(int i = 0; i < 41; i++) {\n\t\t\t\t\tmin = Math.min(min, r + ymin[i]);\n\t\t\t\t}\n\t\t\t\t//System.out.println(Arrays.toString(ymin));\n\t\t\t\tSystem.out.println(Math.max(min, 0));\n\t\t\t}\n\n\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doIt();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tdouble x = Math.abs(r - i);\n\t\t\t\tdouble t1 = cover[i] - r * Math.sin(Math.acos((double) x / r));\n\t\t\t\tdouble t2 = cover[i] - r\n\t\t\t\t\t\t* Math.sin(Math.acos((double) (x + 1) / r));\n\t\t\t\tans = Math.min(ans, Math.min(t1 + r, t2 + r));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", ans));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint r, n, xl, xr, h, flag, temp;\n\t\tdouble min;\n\t\tint[][] x = new int[2][41];\n\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif(r==0 && n==0) break;\n\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txl = sc.nextInt();\n\t\t\t\txr = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tfor(int j=xl+20; j<=xr+20; j++){\n\t\t\t\t\tif(x[0][j]<h){\n\t\t\t\t\t\tif(j>xl+20 && j<xr+20){\n\t\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(x[1][j]!=0){\n\t\t\t\t\t\t\t\tx[1][j] = x[0][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[0][j] = h;\n\t\t\t\t\t}else if(x[1][j]<h){\n\t\t\t\t\t\tx[1][j] = h;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0; i<41; i++){\n\t\t\t\tSystem.out.println(x[0][i]+\" \"+x[1][i]);\n\t\t\t}\n\n\t\t\tflag = -1;\n\t\t\tmin = 20;\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tif(flag==-1 && (x[1][20+i]==0 || x[1][20-i]==0)){\n\t\t\t\t\tflag = i;\n\t\t\t\t}\n\t\t\t\ttemp = Math.min(x[1][20+i], x[1][20-i]);\n\t\t\t\tmin = Math.min(min, temp-Math.sqrt(r*r-i*i));\n\t\t\t}\n\t\t\tif(flag!=-1){\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", Math.min(r-Math.sqrt(r*r-flag*flag), min+r));\n\t\t\t}else{\n\t\t\t\tSystem.out.printf(\"%.4f\\n\", min+r);\n\t\t\t}\n\n\t\t\tArrays.fill(x[0], 0);\n\t\t\tArrays.fill(x[1], 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tint x = Math.abs(r - i);\n\t\t\t\tint xx = Math.abs(r - i - 1);\n\t\t\t\tdouble t1 = cover[i] - r * Math.sin(Math.acos((double) x / r));\n\t\t\t\tdouble t2 = cover[i] - r * Math.sin(Math.acos((double) xx / r));\n\t\t\t\tans = Math.min(ans, Math.min(t1 + r, t2 + r));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", ans));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.*;\n\n\nclass Main {\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry{\n\t\twhile(true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(r+n == 0) break;\n\t\t\tSystem.out.printf(\"%.4f\\n\", solve(r, n));\n\t\t}\n\t\t} catch(Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\t\n\t\n\tstatic double solve(int r, int n) {\n\t\tint[] dp = new int[40];\n\t\tHashMap<int[], Integer> map = new HashMap<int[], Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xl = sc.nextInt();\n\t\t\tint xr = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tfor(int j = xl; j < xr; j++) {\n\t\t\t\tint index = j + 20;\n\t\t\t\tdp[index] = Math.max(dp[index], h);\n\t\t\t}\n\t\t}\n\t\t// System.out.println(Arrays.toString(dp));\n\t\t\n\t\tfor(double ans = -r; ans < 20.0; ans += 0.001) {\n\t\t\tfor (int i = 1-r; i < r; i++) {\n\t\t\t\tint index = i + 20;\n\t\t\t\tint h = Math.min(dp[index-1], dp[index]);\n\t\t\t\t// System.out.println(index + \" \"+ h);\n\t\t\t\tdouble dist = sqdist(0.0, ans, (double)i, (double)h);\n\t\t\t\tif(dist < (double)(r*r)) {\n\t\t\t\t\treturn ans + (double)r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n\t// square を snippet から実装してください\n\tpublic static int sqdist(int x1, int y1, int x2, int y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double sqdist(double x1, double y1, double x2, double y2) {\n\t\treturn sq(x1 - x2) + sq(y1 - y2);\n\t}\n\n\tpublic static double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n\n\tpublic static double dist(double x1, double y1, double x2, double y2) {\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));\n\t}\n}\n\n\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint R = sc.nextInt();\n\t\t\tif (R == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\t\t\tArrayList<Integer[]> list = new ArrayList<Integer[]>();\n\t\t\tint[] horizon = new int[41];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tInteger[] put = { l, r, h };\n\t\t\t\tlist.add(put);\n\t\t\t\thorizon[l + 20]++;\n\t\t\t\thorizon[r + 20]--;\n\t\t\t}\n\n\t\t\tboolean covered = true;\n\t\t\tint cover = 0;\n\t\t\tint left = 0;\n\t\t\tint right = 0;\n\t\t\tfor (int i = 0; i < horizon.length; i++) {\n\t\t\t\tcover += horizon[i];\n\t\t\t\tif (cover == 0 && covered) {\n\t\t\t\t\tcovered = false;\n\t\t\t\t\tleft = i - 20;\n\t\t\t\t} else if (cover >= 1 && !covered) {\n\t\t\t\t\tcovered = true;\n\t\t\t\t\tright = i - 20;\n\t\t\t\t\tInteger[] put = { left, right, 0 };\n\t\t\t\t\tlist.add(put);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble t = -R;\n\t\t\tdouble step = 0.001;\n\t\t\trising: while (true) {\n\t\t\t\tfor (Integer[] bld : list) {\n\t\t\t\t\tint l = bld[0];\n\t\t\t\t\tint r = bld[1];\n\t\t\t\t\tdouble h = bld[2] - t;\n\n\t\t\t\t\t// 建物が太陽の内側にある時\n\t\t\t\t\tif (h * h + l * l < R * R || r * r + h * h < R * R) {\n\t\t\t\t\t\tSystem.out.println(R + t);\n\t\t\t\t\t\tbreak rising;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt += step;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] += r;\n\t\t\t\txr[i] += r;\n\t\t\t\txl[i] = Math.max(0, xl[i]);\n\t\t\t\txr[i] = Math.max(0, xr[i]);\n\n\t\t\t\tint ll = Math.min(xl[i], xr[i]);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(xl[i], xr[i]));\n\n\t\t\t\tint c = h[i];\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// System.out.println(Arrays.toString(cover));\n\t\t\tdouble res = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tint xx = i - r > 0 ? i - r + 1 : r - i - 1;\n\t\t\t\tdouble t1 = cover[i]\n\t\t\t\t\t\t+ r\n\t\t\t\t\t\t* (1 - Math\n\t\t\t\t\t\t\t\t.sin(Math.acos((double) Math.abs(r - i) / r)));\n\t\t\t\tdouble t2 = cover[i] + r\n\t\t\t\t\t\t* (1 - Math.sin(Math.acos((double) xx / r)));\n\t\t\t\tres = Math.min(res, Math.min(t1, t2));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", res));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint r = sc.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint[] xl = new int[n];\n\t\t\tint[] xr = new int[n];\n\t\t\tint[] h = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txl[i] = sc.nextInt();\n\t\t\t\txr[i] = sc.nextInt();\n\t\t\t\th[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint[] cover = new int[2 * r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ll = Math.max(0, xl[i] + r);\n\t\t\t\tint rr = Math.min(r * 2, Math.max(0, xr[i] + r));\n\n\t\t\t\tfor (int j = ll; j < rr; j++) {\n\t\t\t\t\tcover[j] = Math.max(cover[j], h[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 100000.0;\n\t\t\tfor (int i = 0; i < cover.length; i++) {\n\t\t\t\tint x = Math.abs(r - i);// 円の中心のx座標とビルの角のx座標の距離\n\t\t\t\tint xx = Math.abs(r - i - 1);// 円の中心のx座標とビルの角の右隣のx座標の距離\n\t\t\t\tdouble o1 = cover[i] - Math.sqrt(r * r - x * x);\n\t\t\t\tdouble o2 = cover[i] - Math.sqrt(r * r - xx * xx);\n\t\t\t\tans = Math.min(ans, Math.min(o1 + r, o2 + r));\n\t\t\t}\n\n\t\t\tSystem.out.println(String.format(\"%.4f\", ans));\n\t\t}\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "var r;\nvar n;\nvar x = [];\nvar e = [];\n\nfunction fill(a, b, h){\n\ta += 20;\n\tb += 20;\n\tx[a][0] += 1;\n\tx[a][h] -= 1;\n\tx[b][0] -= 1;\n\tx[b][h] += 1;\n}\n\nfunction integrate(){\n\trep(40, function(i){\n\t\trep(19, function(j){\n\t\t\tx[i][j + 1] += x[i][j];\n\t\t});\n\t});\n\trep(39, function(i){\n\t\trep(20, function(j){\n\t\t\tx[i + 1][j] += x[i][j];\n\t\t});\n\t});\n}\n\nfunction access(i, j){\n\treturn x[i + 20][j];\n}\n\nfunction calc_edge(){\n\te[0] = Infinity;\n\trep(20, function(i){\n\t\tvar a = 0;\n\t\trep(20, function(j){\n\t\t\tif(access(-j - 1, i)){\n\t\t\t\t++a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tvar b = 0;\n\t\trep(20, function(j){\n\t\t\tif(access(j, i)){\n\t\t\t\t++b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tvar c = Math.min(a, b);\n\t\te[i + 1] = c;\n\t\te[i] = Math.min(c, e[i]);\n\t});\n}\n\nfunction judge(h){\n\tvar b = true;\n\trep(21, function(i){\n\t\tvar dh = Math.abs(i - h);\n\t\tvar lim = r * r - dh * dh;\n\t\tif(lim < 0){\n\t\t\treturn;\n\t\t}\n\t\tlim = Math.sqrt(lim);\n\t\tif(lim > e[i]){\n\t\t\tb = false;\n\t\t\treturn false;\n\t\t}\n\t});\n\treturn b;\n}\n\nfunction main(){\n\twhile(r = scan()){\n\t\trep(41, function(i){\n\t\t\tx[i] = [];\n\t\t\trep(21, function(j){\n\t\t\t\tx[i][j] = 0;\n\t\t\t});\n\t\t});\n\n\t\tn = scan();\n\t\trep(n, function(){\n\t\t\tvar a = scan();\n\t\t\tvar b = scan();\n\t\t\tvar h = scan();\n\t\t\tfill(a, b, h);\n\t\t});\n\t\tintegrate();\n\n\t\tcalc_edge();\n\t\t\n\t\tvar a = 0, b = 20;\n\t\twhile(b - a > 1e-4){\n\t\t\tvar c = (a + b) / 2;\n\t\t\tif(judge(c - r)){\n\t\t\t\ta = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb = c;\n\t\t\t}\n\t\t}\n\t\tprint(a);\n\t}\n}\n\nfunction rep(a, b, c, u){\n\tif(c === u){\n\t\tc = b;\n\t\tb = a;\n\t\ta = 0;\n\t}\n\tfor(var i = a; i < b; ++i){\n\t\tif(c(i) === false){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvar input = '';\n\nfunction scan(){\n\treturn +input.pop();\n}\nfunction scan_string(){\n\treturn input.pop();\n} \nfunction print(val){\n\tconsole.log(val);\n}\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk){\n\tinput += chunk;\n});\nprocess.stdin.on('end', function(){\n\tinput = input.trim().split(/\\s+/).reverse();\n\tmain();\n});"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    r, n = gets.split.map(&:to_i)\n    break if r == 0 && n == 0\n    b = n.times.map{gets.split.map(&:to_i)}\n    h = Array.new(41,0)\n    b.each do |xl,xr,ht|\n        (xl+20).upto(xr+19) do |x|\n            h[x] = ht\n        end\n    end\n    ans = Float::INFINITY\n    (-r+20).upto(r+19) do |c|\n        dl = 20 - c\n        dr = dl - 1\n        ret1 = r - Math.sqrt(r * r - dl * dl) + h[c]\n        ans = ret1 if ret1 < ans\n        ret2 = r - Math.sqrt(r * r - dr * dr) + h[c]\n        ans = ret2 if ret2 < ans\n    end\n    p ans\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    r, n = gets.split.map(&:to_i)\n    break if r == 0 && n == 0\n    b = n.times.map{gets.split.map(&:to_i)}\n    h = Array.new(41,0)\n    b.each do |xl,xr,ht|\n        (xl+20).upto(xr+19) do |x|\n            h[x] = [ht,h[x]].max\n        end\n    end\n    ans = Float::INFINITY\n    (-r+20).upto(r+19) do |xl|\n        xr = xl + 1\n        dl = 20 - xl\n        dr = 20 - xr\n        ret1 = r - Math.sqrt(r * r - dl * dl) + h[xl]\n        ans = ret1 if ret1 < ans\n        ret2 = r - Math.sqrt(r * r - dr * dr) + h[xl]\n        ans = ret2 if ret2 < ans\n    end\n    puts sprintf('%.4f',ans)\nend"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nloop do\n    r, n = gets.split.map(&:to_i)\n    break if n == 0\n\n    shadow = Hash.new(0)\n    (1..n).each do\n        xl, xr, h = gets.split.map(&:to_i)\n        (xl..xr-1).each do |x|\n            shadow[x] = h if h > shadow[x]\n        end\n    end\n\n    t_min = Float::INFINITY\n\n    (-r+1..0).each do |x|\n        h = shadow[x-1]\n        t = h + r - sqrt(r*r-x*x)\n        t_min = t if t < t_min\n    end\n\n    (1..r-1).each do |x|\n        h = shadow[x]\n        t = h + r - sqrt(r*r-x*x)\n        t_min = t if t < t_min\n    end\n\n    p t_min\nend"
  },
  {
    "language": "Ruby",
    "code": "include Math \n\nloop do\n    r, n = gets.split.map(&:to_i)\n    break if r == 0 \n\n    shadow = Hash.new(0)\n    (1..n).each do \n        xl, xr, h = gets.split.map(&:to_i)\n        (xl..xr-1).each do |x|\n            shadow[x] = h if h > shadow[x]\n        end\n    end  \n\n    t_min = Float::INFINITY\n\n    (-r+1..0).each do |x|\n        h = shadow[x-1]\n        t = h + r - sqrt(r*r-x*x)\n        t_min = t if t < t_min\n    end  \n\n    (0..r-1).each do |x|\n        h = shadow[x]\n        t = h + r - sqrt(r*r-x*x)\n        t_min = t if t < t_min\n    end  \n\n    printf(\"%.4f\\n\", t_min)\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 1e-12\nDIV = 5000\nPIDIV = Math::PI / DIV\n\n### subroutines\n\ndef visible?(t)\n  y0 = t - $r\n  for d in (0..DIV)\n    th = PIDIV * d\n    x = $r * Math.cos(th)\n    y = $r * Math.sin(th) + y0\n    next if y <= 0.0\n\n    covered = false\n    $rects.each do |x0, x1, h|\n      if x >= x0 && x <= x1 && y <= h\n        covered = true\n        break\n      end\n    end\n    return true if ! covered\n  end\n  false\nend\n\n### main\n\nloop do\n  $r, $n = gets.split.map(&:to_i)\n  break if ($r | $n) == 0\n\n  $rects = $n.times.map{gets.split.map(&:to_i)}\n  #p $rects\n\n  t0 = 0.0\n  t1 = 20.0\n  while (t1 - t0 > DELTA)\n    t = (t0 + t1) / 2\n    if visible?(t)\n      t1 = t\n    else\n      t0 = t\n    end\n  end\n  puts t0\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nvoid main()\n{\n\t\n\twhile (1) {\n\t\tauto rn = readln.split.map!(to!int);\n\t\tauto r = rn[0];\n\t\tauto n = rn[1];\n\t\tif (r == 0 && n == 0) break;\n\n\t\tint hs[int];\n\t\tforeach (i; 0..n) {\n\t\t\tauto xh = readln.split.map!(to!int);\n\t\t\tforeach (j; xh[0]..xh[1]) {\n\t\t\t\ths[j] = max(hs.get(j, 0), xh[2]);\n\t\t\t} \n\t\t}\n\n\t\tauto res = double.max;\n\t\tforeach (i; -r..r) {\n\t\t\tres = min(res, hs.get(i, 0) - (r^^2 - i^^2).to!double.sqrt + r);\n\t\t\tres = min(res, hs.get(i, 0) - (r^^2 - (i+1)^^2).to!double.sqrt + r);\n\t\t}\n\n\t\tres.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int R, N;\n    int[] L = new int[41];\n    const P = 20;\n    bool input() {\n        scanf(\"%d %d\\n\", &R, &N);\n        if (R == 0 && N == 0) return false;\n        L[] = 0;\n        foreach (i; 0 .. N) {\n            int l, r, h;\n            scanf(\"%d %d %d\\n\", &l, &r, &h);\n            foreach (j; l .. r) {\n                L[j + P] = max(L[j + P], h);\n            }\n        }\n        return true;\n    }\n    bool C(double t) {\n        if (min(L[P - 1], L[P]) < t) return false;\n        for (int x = -19; x <= 20; x++) {\n            int y = min(L[x + P], L[x + P - 1]);\n            //writeln([t]);\n            //writeln([x, y]);\n            if (x * x + (t - R - y) * (t - R - y) < R * R) return false;\n        }\n        return true;\n    }\n    void solve() {\n        double lb = 0, ub = 21;\n        foreach (_; 0 .. 100) {\n            double mid = (lb + ub) / 2;\n            if (C(mid)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        writefln(\"%.4f\", lb);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef calc(x, h):\n    return max(h+r-sqrt(r**2 - x**2), 0)\nwhile 1:\n    r, n = map(int, raw_input().split())\n    if r == 0:\n        break\n    H = [0]*41\n    for i in xrange(n):\n        xl, xr, h = map(int, raw_input().split())\n        for j in xrange(xl, xr):\n            H[j] = max(H[j], h)\n    ans = 10**9\n    for i in xrange(-r, r):\n        print i, H[i], calc(i, H[i]), calc(i+1, H[i])\n        ans = min(ans, calc(i, H[i]), calc(i+1, H[i]))\n    print \"%.6f\" % ans"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nwhile True:\n    R, N = map(int, input().split())\n    if not (R | N):\n        break\n    geta = 20\n    buildings = [0] * (geta * 2)\n    for _ in range(N):\n        xl, xr, h = map(int, input().split())\n        for i in range(xl + geta, xr + geta):\n            buildings[i] = max(buildings[i], h)\n\n    print(min(buildings[i] - sqrt(R * R - (i - geta + (i < geta)) * (i - geta + (i < geta))) + R for i in range(-R + geta, R + geta)))"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\nimport itertools\nsys.setrecursionlimit(10**5)\nstdin = sys.stdin\nbisect_left = bisect.bisect_left\nbisect_right = bisect.bisect_right\ndef LI(): return list(map(int, stdin.readline().split()))\ndef LF(): return list(map(float, stdin.readline().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef II(): return int(stdin.readline())\ndef IF(): return float(stdin.readline())\ndef LS(): return list(map(list, stdin.readline().split()))\ndef S(): return list(stdin.readline().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\n\n#A\ndef A():\n    while True:\n        n = II()\n        if not n:\n            break\n        a = IR(n)\n        a.sort()\n        print(sum(a[1:-1])//(n-2))\n            \n    return\n\n#B\ndef B():\n    move = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    while True:\n        w, h = LI()\n        if w == h == 0:\n            break\n        field = SR(2 * h - 1)\n        check = [[True] * (2 * w - 1) for i in range(2 * h - 1)]\n        next = deque()\n        next.append((0, 0))\n        ans = 1\n        flg = True\n        \n        while next and flg:\n            now = next\n            next = deque()\n            while now:\n                x, y = now.pop()\n                for mx, my in move:\n                    mmx, mmy = x + mx, y + my\n                    if 0 <= mmx < 2 * w - 1 and 0 <= mmy < 2 * h - 1:\n                        if field[mmy][mmx] == '0' and check[mmy+my][mmx+mx]:\n                            next.append((mmx + mx, mmy + my))\n                            check[mmy + my][mmx + mx] = False\n                            if mmx+mx == 2 * w - 2 and mmy+my == 2 * h - 2:\n                                print(ans+1)\n                                flg = False\n                                next = deque()\n                                now = deque()\n                                break\n            ans += 1\n        if flg:\n            print(0)\n    return\n\n#C\ndef C():\n    while 1:\n        r, n = LI()\n        if r == n == 0:\n            break\n        lis = [0 for i in range(2 * r)]\n        ans = inf\n        for _ in range(n):\n            xl, xr, h = LI()\n            for i in range(2 * r):\n                if xl+r <= i < xr+r:\n                    lis[i] = max(lis[i], h)\n        for i in range(2 * r):\n            if i < r:\n                ans = min(ans, r - math.sqrt((r ** 2 - (r - i - 1)** 2)) + lis[i])\n            else:\n                ans = min(ans, r - math.sqrt((r ** 2 - (r - i)** 2)) + lis[i])\n        print(ans)\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == '__main__':\n    C()\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    R, N = map(int, input().split())\n    if not (R | N):\n        break\n    geta = 20\n    buildings = [0] * (geta * 2)\n    for _ in range(N):\n        xl, xr, h = map(int, input().split())\n        for i in range(xl + geta, xr + geta):\n            buildings[i] = max(buildings[i], h)\n\n    ans = 20\n    for i in range(-R + geta, R + geta):\n        if i < geta:\n            buildings[i] -= pow(R * R - (i - geta + 1) * (i - geta + 1), 0.5) - R\n        else:\n            buildings[i] -= pow(R * R - (i - geta) * (i - geta), 0.5) - R\n        ans = min(ans, buildings[i])\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "while True:\n    R, N = map(int, input().split())\n    if not (R | N):\n        break\n    geta = 20\n    buildings = [0] * (geta * 2)\n    for _ in range(N):\n        xl, xr, h = map(int, input().split())\n        for i in range(xl + geta, xr + geta):\n            buildings[i] = max(buildings[i], h)\n\n    left, right = 0, 20\n    while right - left > 1e-4:\n        mid = (left + right) / 2\n        flag = True\n        for i in range(-R + geta, R + geta):\n            if i < geta:\n                y = pow(R * R - (i - geta + 1) * (i - geta + 1), 0.5)\n                flag &= buildings[i] >= y - R + mid\n            else:\n                y = pow(R * R - (i - geta) * (i - geta), 0.5)\n                flag &= buildings[i] >= y - R + mid\n        if flag:\n            left = mid\n        else:\n            right = mid\n    print(\"{:.20f}\".format(left))"
  },
  {
    "language": "Python",
    "code": "import math\n\nwhile True:\n    r, n = map(int, input().split())\n    if r == 0 and n == 0:\n        break\n    sun_place = [-10000000000000000000 for _ in range(r)]\n    for i in range(r):\n        sun_place[i] = 0 - r + math.sqrt(r * r - i * i)\n\n    ans = 10000000000000000\n    bilding1 = [0 for i in range(len(sun_place))]\n    bilding2 = [0 for i in range(len(sun_place))]\n    for i in range(n):\n        x1, x2, h = map(int, input().split())\n        if x1 < -r:\n            x1 = -r\n        if r <= x2:\n            x2 = r\n        for j in range(x1, x2):\n            if j < 0:\n                j += 1\n                bilding1[abs(j)] = max(h, bilding1[abs(j)])\n            else:\n                bilding2[abs(j)] = max(h, bilding2[abs(j)])\n\n    for i in range(len(sun_place)):\n        ans = min(ans, bilding1[i] - sun_place[i])\n        ans = min(ans, bilding2[i] - sun_place[i])\n    print(ans)\n    # print(bilding1, bilding2)\n    # print(sun_place)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\nOFFSET = 20\n\ndef main():\n\n    while True:\n        r,n = map(int, sys.stdin.readline().split())\n        if r == 0 and n == 0:\n            break\n\n        seq = [0] * 40\n        for i in range(n):\n            x1,x2,h = map(int,sys.stdin.readline().split())\n            for k in range(x1, x2):\n                seq[k + OFFSET] = max(seq[k + OFFSET], h)\n\n        # ??????????????§??????????????? => ??????????????????????????¶??????????????°??????????????¶????????????\n        # seq[x] = [x,x+1]?????????h?????¨???\n        ans = 9999999999\n        for x in range(-r+1, r):\n            y = min(seq[x + OFFSET - 1], seq[x + OFFSET])\n            t = y + r - math.sqrt(r*r - x*x) # ???????????\\????????????\n            #print(\"r:{}\\tx:{}\\tx[]:{}\\ty:{}\\tt:{}\".format(r,x,seq[x + OFFSET],y,t))\n            ans = min(ans, t)\n\n        print(\"{0:.4f}\".format(ans))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "while 1:\n    r,n = map(int,raw_input().split())\n    if r == 0: break\n\n    h = {i:0 for i in xrange(-21,21)}\n    for loop in xrange(n):\n        xl,xr,hi = map(int,raw_input().split())\n        for i in xrange(xl,xr):\n            h[i] = max(h[i],hi)\n\n    for i in xrange(20,-21,-1):\n        h[i] = min(h[i-1],h[i])\n\n    y,d,u = 0,-r,h[0]-r\n    for loop in xrange(30):\n        if any(x**2+(y-h[x])**2 < r**2 for x in xrange(-20,21)):\n            u = y\n        else:\n            d = y\n        y = (d+u)/2.\n    print \"%.4f\"%abs(y+r)"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef calc(x, h):\n    return max(h+r-sqrt(r**2 - x**2), 0)\nwhile 1:\n    r, n = map(int, raw_input().split())\n    if r == 0:\n        break\n    H = [0]*41\n    for i in xrange(n):\n        xl, xr, h = map(int, raw_input().split())\n        for j in xrange(xl, xr):\n            H[j] = max(H[j], h)\n    ans = 10**9\n    for i in xrange(-r, r):\n        ans = min(ans, calc(i, H[i]), calc(i+1, H[i]))\n    print \"%.6f\" % ans"
  },
  {
    "language": "Python",
    "code": "while True:\n  r, n = list(map(int, input().split()))\n  if r==0:\n    break\n\n  b = [0 for i in range(60)]\n  for i in range(n):\n    ll, rr, x = list(map(int, input().split()))\n    for j in range(ll, rr):\n      b[30+j] = max(b[30+j], x)\n  b[30-r-1], b[30+r] = 1e9, 1e9\n\n  ans = 1e9\n  for x in range(30-r, 30+r+1):\n    t = (r**2-(x-30)**2)**(1/2)\n    cur = r-t+min(b[x], b[x-1])\n    ans = min(ans, cur)\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    R, N = map(int, input().split())\n    if not (R | N):\n        break\n    geta = 20\n    buildings = [0] * (geta * 2)\n    for _ in range(N):\n        xl, xr, h = map(int, input().split())\n        for i in range(xl + geta, xr + geta):\n            buildings[i] = max(buildings[i], h)\n\n    sun = [0] * (geta * 2)\n    for i in range(-R + geta, R + geta):\n        if i < geta:\n            buildings[i] -= pow(R * R - (i - geta + 1) * (i - geta + 1), 0.5) - R\n        else:\n            buildings[i] -= pow(R * R - (i - geta) * (i - geta), 0.5) - R\n\n\n    left, right = 0, 20\n    while right - left > 1e-4:\n        mid = (left + right) / 2\n        flag = True\n        for i in range(-R + geta, R + geta):\n            if i < geta:\n                flag &= buildings[i] >= mid\n            else:\n                y = pow(R * R - (i - geta) * (i - geta), 0.5)\n                flag &= buildings[i] >= mid\n        if flag:\n            left = mid\n        else:\n            right = mid\n    print(\"{:.20f}\".format(left))"
  },
  {
    "language": "Python",
    "code": "while True:\n    R, N = map(int, input().split())\n    if not (R | N):\n        break\n    geta = 20\n    buildings = [0] * (geta * 2)\n    for _ in range(N):\n        xl, xr, h = map(int, input().split())\n        for i in range(xl + geta, xr + geta):\n            buildings[i] = max(buildings[i], h)\n\n    print(min(buildings[i] - pow(R ** 2 - (i - geta + (i < geta)) ** 2, 0.5) + R for i in range(-R + geta, R + geta)))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef calc(p,x):\n    return p*(100+x)//100\n\n\nwhile True:\n    r,n = inpl()\n    if r == 0:\n        break\n    else:\n        heights = defaultdict(int)\n        ans = INF\n        for _ in range(n):\n            xl,xr,h = inpl()\n            heights[xl+0.1] = max(heights[xl+0.1],h)\n            heights[xr-0.1] = max(heights[xr-0.1],h)\n            for x in range(xl+1,xr):\n                heights[x-0.1] = max(heights[x-0.1],h)\n                heights[x+0.1] = max(heights[x+0.1],h)\n\n        for x in range(-23,23):\n            h = min(heights[x-0.1],heights[x+0.1])\n            #print(x,h)\n            if r > abs(x):\n                tmp = h - (r**2-x**2)**(1/2)\n                ans = min(ans,tmp+r)\n        print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        r,n = LI()\n        if r == 0 and n == 0:\n            break\n        a = [LI() for _ in range(n)]\n        d = collections.defaultdict(int)\n        for xl,xr,h in a:\n            for x in range(xl,xr):\n                if d[x] < h:\n                    d[x] = h\n        tr = inf\n        r2 = r**2\n        for x in range(-r,r):\n            h = d[x]\n            k = min(abs(x), abs(x+1))\n            t = (r2 - k**2) ** 0.5\n            xr = r - t + h\n            if tr > xr:\n                tr = xr\n\n        rr.append('{:0.9f}'.format(tr))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nwhile True:\n  (r, n) = map(int, raw_input().split())\n  if r + n == 0: break\n\n  hs = {}\n  for i in range(-22, 22 + 1):\n    hs[i] = 0\n\n  for _ in range(n):\n    (xl, xr, h) = map(int, raw_input().split())\n    for i in range(xl, xr):\n      hs[i] = max(hs[i], h)\n\n  ans = 10 ** 9\n  for i in range(-r, r):\n    p = i\n    if i < 0: p += 1\n    rr = hs[i] + r - math.sqrt(r * r - p * p)\n    ans = min(ans, rr)\n\n  print \"%.10f\" % max(0, ans)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    r,n = map(int,raw_input().split())\n    if r == 0: break\n\n    h = [0]*43\n    for loop in xrange(n):\n        xl,xr,hi = map(int,raw_input().split())\n        for i in xrange(xl+21,xr+21): h[i] = max(h[i],hi)\n    hu,hd = h[:],h[:]\n    for i in xrange(1,43):\n        if h[i-1] != h[i]:\n            hu[i] = max(h[i-1],h[i])\n            hd[i] = min(h[i-1],h[i])\n            \n    y,d,u = 0.,-r,r\n    for loop in xrange(30):\n        for x in xrange(1,43):\n            if (x-21)**2+(y-hu[x])**2 < r**2 or (x-21)**2+(y-hd[x])**2 < r**2:\n                u = y\n                break\n        else:\n            d = y\n        y = (u+d)/2\n    print \"%.5f\"%(y+r)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    r,n = map(int,raw_input().split())\n    if r == 0: break\n\n    h = [0]*43\n    for loop in xrange(n):\n        xl,xr,hi = map(int,raw_input().split())\n        for i in xrange(xl+21,xr+21): h[i] = max(h[i],hi)\n    hu,hd = h[:],h[:]\n    for i in xrange(1,43):\n        if h[i-1] != h[i]:\n            hu[i] = max(h[i-1],h[i])\n            hd[i] = min(h[i-1],h[i])\n            \n    y,d,u = 0.,-r,r\n    for loop in xrange(30):\n        for x in xrange(1,43):\n            if (x-21)**2+(y-hu[x])**2 < r**2 or (x-21)**2+(y-hd[x])**2 < r**2:\n                u = y\n                break\n        else:\n            d = y\n        y = (u+d)/2\n    print \"%.4f\"%(y+r)"
  },
  {
    "language": "Python",
    "code": "\n#C\nwhile 1:\n    r,n = map(int, input().split())\n    if r == n == 0:break\n    ans = [[float(\"inf\") for i in range(100)] for j in range(100)]\n    for y in range(100):\n        for j in range(2*r):\n            x = j-r\n            if x < 0:\n                x += 1\n            ans[y][j] = r+y-(r**2-x**2)**0.5\n    for i in range(n):\n        a,b,h = map(int, input().split())\n        for x in range(a,b):\n            j = x+r\n            for y in range(h):\n                ans[y][j] = float(\"inf\")\n    a = float(\"inf\")\n    for i in ans:\n        a = min(min(i),a)\n    print(a)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom math import sqrt\ndef inpl(): return list(map(int, input().split()))\nR, N = inpl()\nwhile R:\n    H = [0] * 41\n    r0 = 0\n    l0 = 0\n    for _ in range(N):\n        l, r, h = inpl()\n        if l < 0 and r >= 0:\n            l0 = max(l0, h)\n        if l <= 0 and r > 0:\n            r0 = max(r0, h)\n\n        l += (l <= 0)\n        r -= (r >= 0)\n\n        for i in range(l, r+1):\n            if i != 0:\n                H[i+20] = max(H[i+20], h)\n    H[20] = min(l0, r0)\n    ans = 20\n    for x in range(-R+1, R):\n        time = R - sqrt(R**2 - x**2) + H[x+20]\n        ans = min(ans, time)\n    print(ans)\n    R, N = inpl()\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    R, N = map(int, input().split())\n    if not (R | N):\n        break\n    geta = 20\n    buildings = [0] * (geta * 2)\n    for _ in range(N):\n        xl, xr, h = map(int, input().split())\n        for i in range(xl + geta, xr + geta):\n            buildings[i] = max(buildings[i], h)\n\n    left, right = 0, 20\n    for _ in range(100):\n        mid = (left + right) / 2\n        flag = True\n        for i in range(-R + geta, R + geta):\n            if i < geta:\n                y = pow(R * R - (i - geta + 1) * (i - geta + 1), 0.5)\n                flag &= buildings[i] >= y - R + mid\n            else:\n                y = pow(R * R - (i - geta) * (i - geta), 0.5)\n                flag &= buildings[i] >= y - R + mid\n        if flag:\n            left = mid\n        else:\n            right = mid\n    print(\"{:.20f}\".format(left))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nEPS = 1e-9\n\ndef normalize(x):\n    return 2 * (x + 20)\n\ndef check(seg, r, t):\n\n    for x in range(40 - r, 40 + r + 1):\n        ok = False\n        for s in seg:\n            if s[2] < t - r:\n                #print(\"over!!!! x:{}, s[2]:{}, t-r:{}\",x,s[2],t-r)\n                return False\n            if s[0] <= x and x <= s[1]:\n                k1 = (s[0] - 40)**2 + (s[2] - (t - r))**2\n                k2 = (s[1] - 40)**2 + (s[2] - (t - r))**2\n                #print(\"\\tx:{}\\ts[2]:{}\\tt/2:{}\\tr:{}\\tk1:{}\\tk2:{}\\tkk:{}\".format(x, s[2], t/2, r, k1, k2,kk))\n                if k1 >= r*r and k2 >= r*r:\n                    ok = True\n                    break\n\n        if not ok:\n            return False\n\n    return True\n\ndef main():\n\n    while True:\n        r,n = map(int, sys.stdin.readline().split())\n        if r == 0 and n == 0:\n            break\n\n        seq = [0] * 100 # 2?????§?¨??????????\n        for i in range(n):\n            x1,x2,h = map(int, sys.stdin.readline().split())\n            for x in range(normalize(x1), normalize(x2) + 1):\n                seq[x] = max(seq[x], 2*h)\n\n        prev = 0\n        st = 0\n        seg = []\n        for i in range(100):\n            if prev != seq[i]:\n                if i % 2 == 0 :\n                    seg.append( [st, i, prev] )\n                    st = i\n                else:\n                    seg.append( [st, i - 1, prev] )\n                    st = i - 1\n                prev = seq[i]\n\n        # ????????????????????¨?????????????????????????????????????????§?????????append?????????\n        # ??????1??\\?????????????????\\???\n        r *= 2\n        seg = [ x for x in seg if x[2] > 0 and (40 - r <= x[0] or x[1] <= 40 + r)]\n\n        # ????????§?¨???????????????????????????????????????????????????????\n        for i in range(len(seg) - 1):\n            if seg[i][1] == seg[i + 1][0]:\n                if seg[i][2] > seg[i + 1][2]:\n                    seg[i + 1][0] += EPS\n                elif seg[i][2] < seg[i + 1][2]:\n                    seg[i][1] -= EPS\n        \n        #print(seg)\n\n        tl = 0.0\n        tr = 40.0\n        for k in range(60):\n            tm = (tr + tl) / 2.0\n            if check(seg, r, tm):\n                tl = tm\n            else:\n                tr = tm\n\n        print(\"{0:.4f}\".format(tl / 2))\n\n\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\nfrom math import *\n\nwhile True:\n    r, n = map(int, raw_input().split())\n    if r == 0:\n        break\n\n    m = {}\n    for i in range(-50, 50):\n        m[i] = 0\n\n    for loop in range(n):\n        x1, x2, h = map(int, raw_input().split())\n        for i in range(x1, x2):\n            m[i] = max(m[i], h)\n\n    ans = 100\n    for i in range(-r, 0):\n        rem = r - sqrt(r * r - (i + 1) * (i + 1)) + m[i]\n        ans = min(rem, ans)\n\n    for i in range(0, r):\n        rem = r - sqrt(r * r - i * i) + m[i]\n        ans = min(rem, ans)\n\n    print ans\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef ri(): return int(input())\ndef rli(): return list(map(int, input().split()))\n\nr, n = rli()\nwhile(r != 0):\n    shade = [0 for i in range(41)]\n    shade[40] = 1145148101919\n    t = [1145148101919 for i in range(41)]\n    for i in range(n):\n        xl, xr, h = rli()\n        for j in range(xl+20, xr+20):\n            shade[j] = max(shade[j], h)\n    shade[20-r-1] = 1145148101919\n    shade[20+r] = 1145148101919\n\n    for i in range(20-r, 20+r+1):\n        x = 20-i\n        t[i] = min(shade[i-1], shade[i]) - math.sqrt(r**2 - x**2) + r\n\n    print(min(t))\n    r, n = rli()"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n# -*- coding: utf-8 -*-\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\ndef main():\n    rr = []\n\n    while True:\n        r, n = map(int, input().split())\n\n        if r == 0 and n == 0:\n            break\n        a = [list(map(int, input().split())) for _ in range(n)]\n\n        d = defaultdict(int)\n        for xl, xr, h in a:\n            for x in range(xl, xr):\n                if d[x] < h:\n                    d[x] = h\n\n        tr = float('inf')\n        r2 = r**2\n        for x in range(-r, r):\n            h = d[x]\n            k = min(abs(x), abs(x+1))\n            t = (r2-k**2) ** 0.5\n            xr = r-t+h\n            if tr > xr:\n                tr = xr\n        rr.append('{:0.9f}'.format(tr))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    r,n = map(int,raw_input().split())\n    if r == 0: break\n\n    h = [0]*43\n    for loop in xrange(n):\n        xl,xr,hi = map(int,raw_input().split())\n        for i in xrange(xl+21,xr+21): h[i] = max(h[i],hi)\n    hu,hd = h[:],h[:]\n    for i in xrange(1,43):\n        if h[i-1] != h[i]:\n            hu[i] = max(h[i-1],h[i])\n            hd[i] = min(h[i-1],h[i])\n            \n    y,d,u = 0.,-r,r\n    for loop in xrange(30):\n        if any((x-21)**2+min((y-hd[x])**2,(y-hu[x]))**2 < r**2 for x in xrange(1,42)):\n            u = y\n        else:\n            d = y\n        y = (u+d)/2\n    print \"%.5f\"%(y+r)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    co=[0 for i in range(40)]\n    r,n=map(int,input().split())\n    if r==n==0:\n        break\n    for i in range(n):\n        a,b,h=map(int,input().split())\n        a+=20\n        b+=20\n        for j in range(a,b):\n            co[j]=max(co[j],h)\n    r_list=[]\n    for i in range(r):\n        r_list.append((r**2-i**2)**0.5+500)\n    r_list=[-9999 for j in range(20-r)]+r_list[::-1]+r_list+[-9999 for j in range(20-r)]\n    for i in range(40):\n        if co[i]<r_list[i]:\n            tmp=r_list[i]\n            r_list=list(map(lambda x:x-(tmp-co[i]),r_list))\n    print(r_list[20])\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    r,n = map(int,raw_input().split())\n    if r == 0: break\n\n    h = [0]*43\n    for loop in xrange(n):\n        xl,xr,hi = map(int,raw_input().split())\n        for i in xrange(xl+21,xr+21): h[i] = max(h[i],hi)\n    hu,hd = h[:],h[:]\n    for i in xrange(1,43):\n        if h[i-1] != h[i]:\n            hu[i] = max(h[i-1],h[i])\n            hd[i] = min(h[i-1],h[i])\n            \n    y,d,u = 0.,-r,r\n    for loop in xrange(30):\n        if any((x-21)**2+(y-hd[x])**2 < r**2 for x in xrange(1,42)):\n            u = y\n        else:\n            d = y\n        y = (u+d)/2\n    print \"%.5f\"%(y+r)"
  }
]