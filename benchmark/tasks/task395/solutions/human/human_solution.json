[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P, P> PP;\nconstexpr ll MOD = ll(1e9 + 7);\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-9;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i > 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct edge{\n    int to, cap, rev, id;\n    bool isrev, ininv;\n};\n\nvector<vector<edge> > G;\nvector<bool> used;\n\nvoid add_edge(int from, int to, int cap, int id, bool inv){\n    G[from].emplace_back((edge){to, cap, int(G[to].size()), id, false, inv});\n    G[to].emplace_back((edge){from, 0, int(G[from].size())-1, id, true, inv});\n}\n\n// 増加路の探索\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(auto &e : G[v]){\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    used.resize(G.size());\n    int flow = 0;\n    while(1){\n        fill(used.begin(), used.end(), false);\n        int f = dfs(s, t, IINF);\n        if(f==0) break;\n        flow += f;\n    }\n    return flow;\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m;\n    G.resize(n);\n    for(int i=0;i<m;i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        add_edge(u, v, 1, i, false);\n        add_edge(v, u, 1, i, true);\n    }\n    cin >> s >> t;\n    s--; t--;\n    cout << max_flow(s, t) << endl;\n    vector<int> r;\n    for(int i=0;i<n;i++){\n        for(auto &e : G[i]){\n            if(e.isrev && e.ininv && e.cap > 0){\n                r.push_back(e.id);\n            }\n        }\n    }\n    cout << r.size() << endl;\n    for(auto id : r){\n        cout << id+1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\nstruct edge {int to,cap,rev,id;};\nconst int MAX_V=302,inf=500;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from, int to, int cap, int id){\n\tedge e1={to,cap,G[to].size(),id},e2={from,0,G[from].size(),-1};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t}\n}\nint main(){\n\tint n,m,x[1000],y[1000];\n\tcin >> n >> m;\n\tint s=0,t=n+1;\n\trep(i,m){\n\t\tcin >> x[i] >> y[i];\n\t\tadd_edge(x[i],y[i],1,-1);\n\t\tadd_edge(y[i],x[i],1,i);\n\t}\n\tint ss,tt;\n\tcin >> ss >> tt;\n\tadd_edge(s,ss,inf,-1);\n\tadd_edge(tt,t,inf,-1);\n\tcout << max_flow(s,t) << endl;\n\tbool ans[1000]={};\n\trep1(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tedge e=G[i][j];\n\t\t\tif(e.id<0) continue;\n\t\t\tif(e.cap==0) ans[e.id]=true;\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,n) if(ans[i]) cnt++;\n\tcout << cnt << endl;\n\trep(i,n) if(ans[i]) cout << i+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define V 13100\n#define E 1000100 \n#define inf 0x3f3f3f3f\nusing namespace std;\nint vis[V];\nint dist[V];\nint pre[V];\nint ans1,ans2;\nint n,m;\nstruct Edge{\n    int u,v,cap,flow,cost,next,id;\n}edge[E];\nint head[V],cnt;\n\nvoid init(){\n    cnt=0;ans1=ans2=0;\n    memset(head,-1,sizeof(head));\n}\nvoid addedge(int u,int v,int c,int cost,int id)\n{\n    edge[cnt].u=u;edge[cnt].v=v;edge[cnt].cost=cost;edge[cnt].id=id;\n    edge[cnt].cap=c;edge[cnt].flow=0;edge[cnt].next=head[u];head[u]=cnt++;\n    \n\n    edge[cnt].u=v;edge[cnt].v=u;edge[cnt].cost=-cost;edge[cnt].id=id;\n    edge[cnt].cap=0;edge[cnt].flow=0;edge[cnt].next=head[v];head[v]=cnt++;\n}\n\nbool spfa(int begin,int end){\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=n;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=inf;\n    }\n    vis[begin]=1;\n    dist[begin]=0;\n    q.push(begin);\n    while(!q.empty()){\n        u=q.front();\n        q.pop();\n        vis[u]=0;\n        for(int i=head[u];i!=-1;i=edge[i].next){\n            //if(edge[i].c>0){\n                v=edge[i].v;\n                if(edge[i].cap>edge[i].flow && dist[v]>dist[u]+edge[i].cost){\n                    dist[v]=dist[u]+edge[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n    }\n    if(pre[end] == -1) return false;\n    else return true;\n}\n\nvoid MCMF(int begin,int end){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(begin,end)){\n        flow=inf;\n        for(int i=pre[end];i!=-1;i=pre[edge[i^1].v])\n            if(flow>edge[i].cap-edge[i].flow)\n                flow=edge[i].cap-edge[i].flow;\n        for(int i=pre[end];i!=-1;i=pre[edge[i^1].v]){\n            edge[i].flow+=flow;\n            edge[i^1].flow-=flow;\n            ans2 += edge[i].cost*flow;\n        }\n        ans1 += flow;\n    }\n}\n\nint main()\n{\n   // freopen(\"in.txt\",\"r\",stdin);\n    int a,b,c;\n    int s,t;\n    while(scanf(\"%d %d\",&n,&m)!=EOF){\n        init();\n\t\tfor(int i=1;i<=m;i++){\n            scanf(\"%d %d\",&a,&b);\n            addedge(a,b,1,0,i);\n            addedge(b,a,1,1,i);\n        }\n        scanf(\"%d %d\",&s,&t);\n        MCMF(s,t);\n        printf(\"%d\\n%d\\n\",ans1,ans2);\n        vector<int>v;\n\t\tfor (int i=1;i<=n;i++)\n\t\t    for (int j=head[i];j!=-1;j=edge[j].next)\n\t\t    \tif (edge[j].flow==1 && edge[j].cost){\n\t\t    \t\tv.push_back(edge[j].id);\n\t\t\t\t} \n\n\t\tfor (int i=0;i<v.size();i++)\n\t\t\tprintf(\"%d\\n\",v[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nint m,n,s,t,fl;\nint x[1001],y[1001];\nint g[301][301];\nint g2[301][301];\nint visit[301];\nstack<int> rev;\n\nint main(){\n\n\n  cin >> n >> m;\n\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++)g[i][j] = 0;\n  }\n\n  for(int i=1;i<=m;i++){\n    cin >> x[i] >> y[i];\n    g[x[i]][y[i]] = i;\n    g2[x[i]][y[i]] = i;\n    g2[y[i]][x[i]] = i;\n  }\n\n  cin >> s >> t;\n  fl = 0;\n  while(1){\n    /*\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++)cout << g2[i][j] << \" \";\n      cout << endl;\n    }\n    */\n    for(int i=1;i<=n;i++)visit[i] = 0;\n    queue<int> q;\n    q.push(s);\n    int tmp = 0;\n    visit[s] = s;\n    while(q.size()){\n      tmp = q.front();\n      q.pop();\n      if(tmp == t)break;\n      for(int i=1;i<=n;i++){\n\tif(g2[tmp][i] && !visit[i]){\n\t  q.push(i);\n\t  visit[i] = tmp;\n\t}\n      }\n    }\n    \n    if(tmp == t){\n      fl++;\n      while(tmp!=s){\n\tif(!g[visit[tmp]][tmp])rev.push(g2[visit[tmp]][tmp]);\n\tg2[visit[tmp]][tmp] = 0;\n\tg2[tmp][visit[tmp]] = 0;\n\ttmp = visit[tmp];\n      }\n    }else break;\n  }\n\n  cout << fl << endl;\n  cout << (int)rev.size() << endl;\n  while(rev.size()){\n    cout << rev.top() << endl;\n    rev.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\nstruct Edge {\n    int to, flow, cap, rev;\n    bool is_rev;    // 逆辺かどうか\n    Edge(int to, int flow, int cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev) {\n        assert(this->cap >= 0);\n    }\n};\n\n// 最大流問題をO(F|E|)で解く\nclass FordFulkerson {\npublic:\n    unsigned int num_of_node = 0;   // ノード数\n    map<int, vector<Edge>> G;       // グラフの隣接リスト表現\n\n    FordFulkerson(unsigned int num_of_node) : num_of_node(num_of_node) {\n    }\n\n    // fromからtoへ向かう容量capの辺とその逆辺をグラフに追加する\n    void add_edge(int from, int to, int cap) {\n        this->G[from].emplace_back(Edge(to, 0, cap, (int)this->G[to].size(), false));          // 辺\n        this->G[to].emplace_back(Edge(from, cap, 0, (int)this->G[from].size() - 1, true));     // 逆辺\n    }\n\n    // sからtへの最大流を求める O(F|E|)\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            vector<bool> used(this->num_of_node, false); // DFSですでに調べたかのフラグ\n            int f = dfs(s, t, INT_MAX, used);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n    }\n\n    // 水の流れたエッジを取得する\n    set<pair<int, int>> get_used_edges() {\n        set<pair<int, int>> used_edges;\n\n        for (auto p : this->G) {\n            int from = p.first;\n            for (Edge edge : p.second) {\n                int flow = edge.flow;\n                bool is_rev = edge.is_rev;\n\n                if (not is_rev and flow > 0) {\n                    int to = edge.to;\n                    used_edges.insert(make_pair(from , to));\n                }\n            }\n        }\n        return used_edges;\n    }\n\nprivate:\n    // vからtへf流したときの流れた量\n    int dfs(int from, int to, int f, vector<bool> &used) {\n        if (from == to) { return f; }\n        used[from] = true;\n        for (Edge &e : G[from]) {\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, to, min(f, e.cap - e.flow), used);\n                if (d > 0) {\n                    e.flow += d;                 // 辺\n                    G[e.to][e.rev].flow -= d;    // 逆辺\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M, S, T;\n    cin >> N >> M;\n    FordFulkerson ff(N + 10);\n    V<pair<int, int>> edges;\n    FOR(i, 0, M) {\n        int x, y;\n        cin >> x >> y;\n        edges.emplace_back(make_pair(x, y));\n        ff.add_edge(x, y, 1);\n        ff.add_edge(y, x, 1);\n\n    }\n    cin >> S >> T;\n\n    int flow = ff.max_flow(S, T);\n\n    vector<int> ans;\n    auto used_edges = ff.get_used_edges();\n    FOE(edge, used_edges) {\n        int from = edge.first;\n        int to = edge.second;\n\n        FOR(i, 0, edges.size()) {\n            int from2 = edges[i].first;\n            int to2 = edges[i].second;\n\n            if (from == to2 and to == from2) {\n                ans.emplace_back(i + 1);\n                break;\n            }\n        }\n    }\n    sort(ALL(ans));\n\n    print(flow);\n    print(ans.size());\n    FOE(x, ans) {\n        print(x);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    level.clear(); level.resize(G.size(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge& e : G[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.clear(); iter.resize(G.size(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    each(e, dinic.G[v]) {\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  each(e, used_rev) cout << e+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass Edge{\npublic:\n  int _to;\n  int _capacity;\n  int _reverse;\n  Edge(int to,int capacity,int reverse) :\n    _to(to), _capacity(capacity), _reverse(reverse) {}\n};\n\nclass FordFulkerson {\nprivate:\n  int _n;\n  bool* _used;\n  vector<Edge>* _edges;\n  map<P,int> _id;\npublic:\n  FordFulkerson(int n){\n    _n = n;\n    _used = new bool[n+1]();\n    _edges = new vector<Edge>[n+1];\n  }\n  void set_id(map<P,int> id){\n    _id = id;\n  }\n  \n  void add_edge(int from,int to,int capacity = 1){\n    _edges[from].push_back(Edge(to,capacity,_edges[to].size()));\n    _edges[to].push_back(Edge(from,0,_edges[from].size()-1));\n  }\n\n  int dfs(int current,int sink,int flow){\n    if(current == sink) return flow;\n    _used[current] = true;\n    for(int i=0;i<_edges[current].size();i++){\n      int to = _edges[current][i]._to;\n      if(_used[to]) continue;\n\n      int d = dfs(to,sink,min(flow,_edges[current][i]._capacity));\n      if(d <= 0) continue;\n      \n      _edges[current][i]._capacity -= d;\n      _edges[to][_edges[current][i]._reverse]._capacity += d;\n      return d;\n    }\n    \n    return 0;\n  }\n\n  int compute_max_flow(int source,int sink){\n    int res = 0;\n    while(true){\n      int tmp = dfs(source,sink,INF);\n      if(tmp == 0) break;\n      res += tmp;\n    }\n    return res;\n  }\n\n  set<int> compute_reverse(){\n    set<int> res;\n    for(map<P,int>::iterator it = _id.begin(); it != _id.end(); it++){\n      int from = it->first.first;\n      int to = it->first.second;\n      for(int i = 0; i < _edges[from].size();i++){\n              if(to == _edges[from][i]._to){\n          if(_edges[from][i]._capacity == 1){\n            res.insert(it->second);\n          }\n              }\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int num_of_crossings;\n  int num_of_roads;\n  while(~scanf(\"%d %d\",\n               &num_of_crossings,\n               &num_of_roads)){\n    \n    FordFulkerson fordfulkerson(num_of_crossings);\n    map<P,int> id;\n    for(int road_i = 0; road_i < num_of_roads; road_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      fordfulkerson.add_edge(from,to);\n      fordfulkerson.add_edge(to,from);\n      id[P(from,to)] = id.size();\n    }\n    int source,sink;\n    scanf(\"%d %d\",&source,&sink);\n    cout << fordfulkerson.compute_max_flow(source,sink) << endl;\n    \n    fordfulkerson.set_id(id);\n    set<int> res = fordfulkerson.compute_reverse();\n    cout << res.size() << endl;\n    for(set<int>::iterator it = res.begin(); it != res.end(); it++){\n      cout << *it << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nint N, M;\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while(f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if(min_cost[p.second] < p.first) continue;\n                for(int i = 0; i < graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if(e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if(min_cost[t] == INF) return -1;\n            for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n       }\n       return ret;\n    }\n\n    void output() {\n        for(int i = 0; i < graph.size(); i++) {\n            for(auto &e : graph[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nmap<i_i, int> mp;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    PrimalDual<ll, ll> graph(N);\n    for(int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        graph.add_edge(a, b, 1, 0);\n        graph.add_edge(b, a, 1, 1);\n        mp[{a, b}] = i + 1;\n    }\n    int S, T;\n    cin >> S >> T;\n    S--;\n    T--;\n    int x = 0;\n    while(true) {\n        if(graph.min_cost_flow(S, T, 1) == -1) break;\n        //cerr << \"A\" << endl;\n        x++;\n    }\n    cout << x << endl;\n    vector<int> v;\n    for(int i = 0; i < N; i++) {\n        for(auto e : graph.graph[i]) {\n            if(e.cost == 1 and !e.isrev and e.cap == 0) {\n                v.push_back(mp[{e.to, i}]);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    cout << v.size() << endl;\n    for(auto e : v) {\n        cout << e << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nconst int MAXN=301;\n//int flow[MAXN][MAXN];\n//int map[MAXN][MAXN];\nint residual[MAXN][MAXN];\nint pre[MAXN];\nbool reversed[1001];//,flagc;\nint n=0,m=0,sum=0,start=0,end=0,re=0,num=0;\nclass vertex\n{\n      public:\n             int pos;\n             int value;\n};\n/*class vertexplus\n{\n      public:\n             int pos;\n             int num;\n};*/\nstruct cmp\n{\n       bool operator()(const vertex &a,const vertex &b)\n        {\n                return a.value>b.value;     \n        }  \n};\npriority_queue <vertex,vector<vertex>,cmp> q1;\npriority_queue <vertex,vector<vertex>,cmp> q2;\npriority_queue <vertex,vector<vertex>,cmp> q3;\npriority_queue <vertex,vector<vertex>,cmp> q4;\nvoid init(void)\n{\n     memset(reversed,0,sizeof(reversed));\n     //memset(map,0,sizeof(map));\n     memset(residual,0,sizeof(residual));\n     int n1=0,n2=0,cap=0;\n     for (int i=1;i<=m;i++)\n     {\n         cin>>n1>>n2;++cap;\n         residual[n1][n2]=cap;\n     }\n     //memcpy(map,residual,sizeof(map));\n     cin>>start>>end;\n     return;\n}\n/*void search(int pos)\n{\n    if (q3.empty()) return;\n    vertexplus tmp=q3.front();\n    int first=tmp.num,tmppos;\n    bool flag=false;\n    q3.pop();q3.push(tmp);\n    while (!q3.empty()&&(!flag||q3.front().num!=first))\n    {\n          flag=1;\n          tmp=q3.front();\n          if (tmp.pos!=pos) {q3.pop();q3.push(tmp);continue;}\n          tmppos=pos;\n          while (tmppos!=start)\n          {\n           \n           reversed[residual[pre[tmppos]][tmppos]]=1;re++;\n           residual[pre[tmppos]][tmppos]=0;\n           residual[tmppos][pre[tmppos]]=0;\n           tmppos=pre[tmppos];\n          }\n          q3.pop();\n          sum++;\n          flagc=1;\n          break;\n    }\n    return;\n} */\nint bfs1(void)\n{\n    vertex tmp,tmpn;\n    //vertexplus tmpp;\n    bool flag=false;//,flagp=false;\n    bool visit[MAXN];\n    //int minvalue=9999999;\n    memset(visit,0,sizeof(visit)); \n    memset(pre,0,sizeof(pre));\n    visit[start]=1;\n    while (!q1.empty())\n    {\n          tmp=q1.top();q1.pop();\n          if (tmp.pos==end) {flag=1;break;}\n         // flagp=0;\n          for (int i=1;i<=n;i++)\n          {\n              if (visit[i]||i==start) continue;\n              if (residual[tmp.pos][i])\n              {\n               tmpn.pos=i;tmpn.value=tmp.value+1;pre[i]=tmp.pos;\n               q1.push(tmpn);\n               visit[i]=1;//flagp=1;\n               //if (minvalue>residual[tmp.pos][i]) minvalue=residual[tmp.pos][i];\n              }\n          }\n          /*if (!flagp) \n          {\n           tmpp.pos=tmp.pos;\n           tmpp.num=++num;\n           q3.push(tmpp);\n          }*/\n    }\n    //while (!q.empty()) q.pop();\n    if (!flag) return -1;\n    else return 1;\n}\nint bfs2(void)\n{\n    vertex tmp,tmpn;\n    bool flag=false;//,flagp=false;\n    bool visit[MAXN];\n    //int minvalue=9999999;\n    memset(visit,0,sizeof(visit)); \n    visit[start]=1;\n    while (!q2.empty())\n    {\n          tmp=q2.top();q2.pop();\n          if (tmp.pos==end) {flag=1;break;}\n          //flagp=0;\n          for (int i=1;i<=n;i++)\n          {\n              if (visit[i]||i==start) continue;\n              if (residual[tmp.pos][i]>0)\n              {\n               tmpn.pos=i;tmpn.value=tmp.value+1;pre[i]=tmp.pos;\n               q2.push(tmpn);\n               visit[i]=1;//flagp=1;\n               //if (minvalue>residual[tmp.pos][i]) minvalue=residual[tmp.pos][i];\n              }\n          }\n          //if (!flagp) search(tmp.pos);\n    }\n    //while (!q.empty()) q.pop();\n    if (!flag) return -1;\n    else return 1;\n}\nint bfs4(int s,int visit[])\n{\n    vertex tmp,tmpn;\n    bool flag=false,flagp=false;\n    bool visitb[MAXN];\n    //int minvalue=9999999;\n    memset(visitb,0,sizeof(visitb)); \n    visitb[s]=1;\n    tmp.pos=s;tmp.value=0;\n     q4.push(tmp);\n    while (!q4.empty())\n    {\n          tmp=q4.top();q4.pop();\n          if (tmp.pos==end) {flag=1;break;}\n          flagp=0;\n          for (int i=1;i<=n;i++)\n          {\n              if (visitb[i]||i==start||(visit[i]>0&&visit[i]<visit[tmp.pos])) continue;\n              if (residual[i][tmp.pos]>0)\n              {\n               tmpn.pos=i;tmpn.value=tmp.value+1;pre[i]=tmp.pos;\n               q4.push(tmpn);\n               visitb[i]=1;flagp=1;\n               //if (minvalue>residual[tmp.pos][i]) minvalue=residual[tmp.pos][i];\n              }\n          }\n          //if (!flagp) bfs4(tmp.pos); \n    }\n    while (!q4.empty()) q4.pop();\n    if (!flag) return 0;\n    else \n    {\n           int tmppos=end;sum++;\n           while (tmppos!=s)\n           {\n            reversed[residual[tmppos][pre[tmppos]]]=1;re++;\n            residual[pre[tmppos]][tmppos]=0;\n            residual[tmppos][pre[tmppos]]=0;\n            tmppos=pre[tmppos];\n           }\n           tmppos=s;\n           while (tmppos!=start)\n           {\n            residual[pre[tmppos]][tmppos]=0;\n            residual[tmppos][pre[tmppos]]=0;\n            tmppos=pre[tmppos];\n           }\n         return 1;\n    }\n}\nint bfs3(void)\n{\n    vertex tmp,tmpn;\n    bool flag=false,flagp=false;\n    int visit[MAXN];\n    //int minvalue=9999999;\n    memset(visit,0,sizeof(visit)); \n    visit[start]=1;\n    while (!q3.empty())\n    {\n          tmp=q3.top();q3.pop();\n          if (tmp.pos==end) {flag=1;break;}\n          flagp=0;\n          for (int i=1;i<=n;i++)\n          {\n              if ((visit[i]>0&&visit[i]<tmp.value)||i==start) continue;\n              if (residual[tmp.pos][i]>0)\n              {\n               tmpn.pos=i;tmpn.value=tmp.value+1;pre[i]=tmp.pos;\n               q3.push(tmpn);\n               visit[i]=tmpn.value;flagp=1;\n               //if (minvalue>residual[tmp.pos][i]) minvalue=residual[tmp.pos][i];\n              }\n          }\n          if (!flagp) flag=bfs4(tmp.pos,visit); \n    }\n    //while (!q.empty()) q.pop();\n    if (!flag) return -1;\n    else return 1;\n}\nint edmondskarp1(void)\n{\n     int change=0,tmppos,tot=0;\n     vertex tmp;\n     tmp.pos=start;tmp.value=0;\n     q1.push(tmp);\n     while ((change=bfs1())>0)\n     {\n           tmppos=end;tot+=1;\n           while (tmppos!=start)\n           {\n            residual[pre[tmppos]][tmppos]=0;\n            residual[tmppos][pre[tmppos]]=0;\n            tmppos=pre[tmppos];\n           }\n     } \n     return tot;\n}\nint edmondskarp2(void)\n{\n     int change=0,tmppos,tot=0;\n     vertex tmp;\n     tmp.pos=start;tmp.value=0;\n     q2.push(tmp);//flagc=0;\n     memset(pre,0,sizeof(pre));\n     while ((change=bfs2())>0)\n     {\n           //if (flagc) {flagc=0;continue;}\n           //flagc=0;\n           tmppos=end;tot+=1;\n           while (tmppos!=start)\n           {\n            reversed[residual[pre[tmppos]][tmppos]]=1;re++;\n            residual[pre[tmppos]][tmppos]=0;\n            residual[tmppos][pre[tmppos]]=0;\n            tmppos=pre[tmppos];\n           }\n     } \n     return tot;\n}\nint edmondskarp3(void)\n{\n     int change=0,tmppos,tot=0;\n     vertex tmp;\n     tmp.pos=start;tmp.value=0;\n     q3.push(tmp);//flagc=0;\n     memset(pre,0,sizeof(pre));\n     while ((change=bfs3())>0)\n     {\n           //if (flagc) {flagc=0;continue;}\n           //flagc=0;\n     } \n     return tot;\n}\nint main()\n{\n     int maxp=0;\n     while(     cin>>n>>m)\n     { sum=0;re=0;maxp=0;\n     init();      \n     sum+=edmondskarp1();\n     start+=end;end=start-end;start=start-end;\n     //memcpy(residual,map,sizeof(map));\n     //cout<<q3.size()<<endl;\n     sum+=edmondskarp2();\n     start+=end;end=start-end;start=start-end;\n     edmondskarp3();\n     cout<<sum<<endl;\n     cout<<re<<endl;\n     if (re>0)\n     {\n     for (int i=1;i<=m;i++)\n      if (reversed[i]) maxp=i;\n     for (int i=1;i<maxp;i++)\n      if (reversed[i]) cout<<i<<endl;\n     cout<<maxp<<endl; \n     }\n     }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\n#define MAX_V 300\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct edge{int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to){\n\tG[from].push_back((edge){to, 1, G[to].size()});\n\tG[to].push_back((edge){from, 1, G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0, sizeof(iter));\n\t\tint f;\n\t\twhile((f = dfs(s, t, INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nint n, m, s, t;\nint brd[300][300];\nbool used[300][300];\n\nint main(){\n\trep(i,300) rep(j,300) brd[i][j] = -1;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tbrd[x][y] = i+1;\n\t\tif(!used[x][y]){\n\t\t\tadd_edge(x,y);\n\t\t\tused[x][y] = true;\n\t\t\tused[y][x] = true;\n\t\t}\n\t}\n\tcin >> s >> t;\n\ts--; t--;\n\tcout << max_flow(s,t) << endl;\n\tint r = 0;\n\tvector<int> out;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tif(G[i][j].cap == 0 && brd[i][G[i][j].to] == -1){\n\t\t\t\tr++;\n\t\t\t\tout.push_back(brd[G[i][j].to][i]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << r << endl;\n\tsort(out.begin(),out.end());\n\trep(i,out.size()) cout << out[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#define MAX_S (1<<10)+10\n#define MAX_V 500\n#define MAX_N MAX_V\n#define INF 1000009\nusing namespace std;\n\nstruct edge {\n    int to, cap, rev;\n    bool isRev;\n    bool isOri;\n    int id;\n\n    edge(int t, int c, int r, bool ir, bool io,int iid)\n            : to(t), cap(c), rev(r), isRev(ir), isOri(io),id(iid) { }\n\n    edge() { }\n};\n\ntemplate <class T>\ninline bool scan_d(T &ret)\n{\n    char c;\n    int sgn;\n    if(c=getchar(),c==EOF) return 0; //EOF\n    while(c!=' -' &&(c<'0' ||c>'9' )) c=getchar();\n    sgn=(c==' -' )?-1:1;\n    ret=(c==' -' )?0:(c-'0' );\n    while(c=getchar(),c>='0' &&c<='9' ) ret=ret*10+(c-'0' );\n    ret*=sgn;\n    return 1;\n}\n\nvector<edge> G[MAX_N];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid init(int totNode) {\n    for (int i = 0; i <= totNode; i++)\n        G[i].clear();\n    memset(level, 0, sizeof(level));\n    memset(iter, 0, sizeof(iter));\n}\n\nvoid add_edge(int from,int to,int cap,bool io,int id) {\n    G[from].push_back(edge (to, cap, G[to].size(),0,io,id));\n    G[to].push_back(edge (from, 0, G[from].size() - 1,1,io,id));\n}\n\nvoid bfs(int s) {\n    queue<int> que;\n    memset(level, -1, sizeof(level));\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v,int t,int f) {\n    if (v == t)return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t) {\n    int flow = 0;\n    for (; ;) {\n        bfs(s);\n        if (level[t] < 0)return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, INF)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint S,T;\n\nint N,M;\n\nvector<int> ans;\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add_edge(u, v, 1, 1, i + 1);\n        add_edge(v, u, 1, 0, i + 1);\n    }\n    scanf(\"%d%d\", &S, &T);\n    int f = max_flow(S, T);\n    printf(\"%d\\n\", f);\n    for (int i = 1; i <= N; i++)\n        for (int j = 0; j < G[i].size(); j++)\n            if (G[i][j].isRev == 0 && G[i][j].isOri == 0 && G[i][j].cap == 0)\n                ans.push_back(G[i][j].id);\n    printf(\"%d\\n\", ans.size());\n    for (int i = 0; i < ans.size(); i++)\n        printf(\"%d\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 310\n\nstruct Info{\n\tvoid set(int arg_rev_from,int arg_rev_index){\n\t\trev_from = arg_rev_from;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint rev_from,rev_index;\n};\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t}\n\tint to,capacity,rev_index;\n};\n\nint V,E;\n\nvector<Edge> G[NUM];\nInfo info[1010];\nint dist[NUM];\nint cheked_index[NUM];\n\n\nvoid add_edge(int index,int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size()));\n\tG[to].push_back(Edge(from,capacity,G[from].size()-1));\n\tinfo[index].set(to,G[to].size()-1);\n}\n\n\nvoid bfs(int source){\n\tfor(int i = 0; i < V; i++)dist[i] = -1;\n\tqueue<int> Q;\n\tdist[source] = 0;\n\tQ.push(source);\n\n\twhile(!Q.empty()){\n\t\tint node_id = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tEdge &e = G[node_id][i];\n\t\t\tif(e.capacity > 0 && dist[e.to] < 0){\n\t\t\t\tdist[e.to] = dist[node_id]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow;\n\n\tfor(int &i = cheked_index[node_id]; i < G[node_id].size(); i++){\n\t\tEdge &e = G[node_id][i];\n\t\tif(e.capacity > 0 && dist[node_id] < dist[e.to]){\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity));\n\t\t\tif(tmp_flow > 0){\n\t\t\t\te.capacity -= tmp_flow;\n\t\t\t\tG[e.to][e.rev_index].capacity = 1;\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nint max_flow(int source,int sink){\n\tint flow = 0,add;\n\twhile(true){\n\t\tbfs(source);\n\t\tif(dist[sink] < 0)break;\n\t\tfor(int i = 0; i < V; i++)cheked_index[i] = 0;\n\t\twhile((add = dfs(source,sink,BIG_NUM)) > 0){\n\t\t\tflow += add;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tadd_edge(loop,from,to,1);\n\t}\n\n\tint source,sink;\n\tscanf(\"%d %d\",&source,&sink);\n\tsource--;\n\tsink--;\n\n\tint flow = max_flow(source,sink);\n\n\tqueue<int> Q;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tif(G[info[loop].rev_from][info[loop].rev_index].capacity == 0){\n\t\t\tQ.push(loop+1);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",flow);\n\tprintf(\"%lld\\n\",Q.size());\n\twhile(!Q.empty()){\n\t\tprintf(\"%d\\n\",Q.front());\n\t\tQ.pop();\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cap,rev,num,add;\n\tEdge(){}\n\tEdge(int s, int d, int cp, int r, int n, int a)\n\t\t:src(s),dst(d),cap(cp),rev(r),num(n), add(a)\n\t{}\n};\n\nconst int INF = (1<<28);\n\ntypedef vector<vector<Edge> > Graph;\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=e.cap;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tgraph[p][i].cap -= f;\n\t\t\tgraph[next][e.rev].cap += f;\n\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\t\t\t\tif(level[e.dst]!=-1) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.dst]=level[n]+1;\n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int d, int c, int f, int n, int a, Graph& g)\n{\n\tg[s].push_back(Edge(s,d,f,g[d].size()  , n, a));\n\tg[d].push_back(Edge(d,s,0,g[s].size()-1, n, 0)); \n}\n\nvoid solve()\n{\n\tint N,M,S,T;\n\tcin >> N >> M;\n\n\tGraph g(N);\n\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tadd_edge(s-1, t-1, 0, 1, i, 0, g);\n\t\tadd_edge(t-1, s-1, 1, 1, i, 1, g);\n\t}\n\n\tcin >> S >> T;\n\tcout << dinic(S-1,T-1,g) << endl;\n\n\tvector<int> res;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<g[i].size(); j++)\n\t{\n\t\tif(g[i][j].add == 1 && g[i][j].cap == 0)\n\t\t\tres.push_back(g[i][j].num);\n\t}\n\n\tcout << res.size() << endl;\n\tsort(res.begin(), res.end());\n\tfor(int i=0; i<res.size(); i++)\n\t\tcout << res[i] + 1 << endl;\n\n}\n\nint main()\n{\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#define residue(s,t) (capacity[s][t]-flow[s][t])\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    int capacity[300][300] = {};\n    int flow[300][300] = {};\n    int X[1000], Y[1000];\n    REP(i, M){\n      cin>>X[i]>>Y[i];\n      X[i]--; Y[i]--;\n      capacity[X[i]][Y[i]]++;\n      capacity[Y[i]][X[i]]++;\n    }\n    int S, T;\n    cin>>S>>T;\n    S--; T--;\n    int total = 0;\n    while(true){\n      queue<int> que;\n      int prev[300]; memset(prev, -1, sizeof(prev));\n      que.push(S); prev[S] = S;\n      while(!que.empty() && prev[T] < 0){\n        int u = que.front(); que.pop();\n        REP(v, N) if(prev[v] < 0 && residue(u, v) > 0){\n          prev[v] = u;\n          que.push(v);\n        }\n      }\n      if(prev[T] < 0) break;\n      int inc = M;\n      for(int u = T; prev[u] != u; u = prev[u]){\n        inc = min(inc, residue(prev[u], u));\n      }\n      for(int u = T; prev[u] != u; u = prev[u]){\n        flow[prev[u]][u] += inc;\n        flow[u][prev[u]] -= inc;\n      }\n      total += inc;\n    }\n    vector<int> rev_road;\n    REP(i, M){\n      if(flow[X[i]][Y[i]] > 0){\n        flow[X[i]][Y[i]]--;\n      }else if(flow[Y[i]][X[i]] > 0){\n        flow[Y[i]][X[i]]--;\n        rev_road.push_back(i + 1);\n      }\n    }\n    cout<<total<<endl;\n    cout<<rev_road.size()<<endl;\n    REP(i, rev_road.size()) cout<<rev_road[i]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\n\nconst int MAX_V = 2010; //?????????????????°\nstruct Flow{\n\tstruct edge{\n\t\tint to, cap, rev;\n\t};\n\tvector<edge> G[MAX_V];//??£??\\?????????\n\tbool used[MAX_V];\n \n\tvoid add_edge(int from, int to, int cap){\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n\t}\n\t//?¢???????????????¢???\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < G[v].size(); ++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t//s??????t???????????§???\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif(f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\nint N, M;\nint X[310], Y[310];\nint S, T;\nint main(void) {\n\tscanf(\"%d %d\", &N, &M);\n\trep(i, M) scanf(\"%d %d\", &X[i], &Y[i]);\n\trep(i, M) X[i]--, Y[i]--;\n\tscanf(\"%d %d\", &S, &T);\n\tS--, T--;\n\n\tFlow fw;\n\trep(i, M) fw.add_edge(X[i], Y[i], 1), fw.add_edge(Y[i], X[i], 1);\n\tint ret = fw.max_flow(S, T);\n\n\tint memo[310][310] = {-1}; // ?????£?????????cap\n\trep(i, MAX_V) for(auto& u : fw.G[i]) memo[i][u.to] = u.cap;\n\n\tset<int> ans;\n\trep(i, M) {\n\t\tif(memo[Y[i]][X[i]] == 0) ans.insert(i);\n\t}\n\tprintf(\"%d\\n\", ret);\n\tprintf(\"%d\\n\", ans.size());\n\tfor(auto u : ans) printf(\"%d\\n\", u + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    level.clear(); level.resize(G.size(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge& e : G[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.clear(); iter.resize(G.size(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    each(e, dinic.G[v]) {\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  rep(i, used_rev.size()) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n\nint MaxFlow(const Graph &g, int s, int t, Matrix &flow) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  flow = Matrix(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.front();\n      que.pop();\n      if (parent[node.dest] != -1) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight f = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      f = min(f, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      flow[from][to] += f;\n      flow[to][from] -= f;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += f;\n  }\n  return ret;\n}\n\nvoid AddEdge(Graph &g, int from, int to, Weight capacity) {\n  g[from].push_back(Edge(from, to, capacity));\n  g[to].push_back(Edge(to, from, capacity));\n}\n\nint main() {\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    Graph g(n);\n    vector<Edge> edges;\n    REP(i, m) {\n      int f, t;\n      scanf(\"%d %d\", &f, &t);\n      f--; t--;\n      AddEdge(g, t, f, 1);\n      edges.push_back(Edge(f, t, 1));\n    }\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    s--; t--;\n    Matrix flow;\n    int f = MaxFlow(g, s, t, flow);\n    vector<int> ans;\n    REP(i, m) {\n      if (flow[edges[i].dest][edges[i].src] == 1) { ans.push_back(i + 1); }\n    }\n    printf(\"%d\\n%d\\n\", f, (int)ans.size());\n    FORIT(it, ans) {\n      printf(\"%d\\n\", *it);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\n\nconst int MAX_V = 2010; //?????????????????°\nstruct Flow{\n\tstruct edge{\n\t\tint to, cap, rev;\n\t};\n\tvector<edge> G[MAX_V];//??£??\\?????????\n\tbool used[MAX_V];\n \n\tvoid add_edge(int from, int to, int cap){\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n\t}\n\t//?¢???????????????¢???\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < G[v].size(); ++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t//s??????t???????????§???\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif(f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\nint N, M;\nint X[310], Y[310];\nint S, T;\nint main(void) {\n\tscanf(\"%d %d\", &N, &M);\n\trep(i, M) scanf(\"%d %d\", &X[i], &Y[i]);\n\trep(i, M) X[i]--, Y[i]--;\n\tscanf(\"%d %d\", &S, &T);\n\tS--, T--;\n\n\tFlow fw;\n\trep(i, M) fw.add_edge(X[i], Y[i], 1), fw.add_edge(Y[i], X[i], 1);\n\tint ret = fw.max_flow(S, T);\n\n\tint memo[310][310]; // ?????£?????????cap\n\trep(i, MAX_V) for(auto& u : fw.G[i]) memo[i][u.to] = u.cap;\n\n\tset<int> ans;\n\trep(i, M) {\n\t\tif(memo[Y[i]][X[i]] == 0) ans.insert(i);\n\t}\n\tprintf(\"%d\\n\", ret);\n\tprintf(\"%d\\n\", ans.size());\n\tfor(auto u : ans) printf(\"%d\\n\", u + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 334\n#define INF 1e9\n\nstruct Edge{\n    int to,cap,rev;\n    Edge(int to,int cap,int rev) :\n        to(to),cap(cap),rev(rev) {}\n};\n\nvector<Edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back(Edge(to,cap,G[to].size()));\n    G[to].push_back(Edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> Q;\n    level[s] = 0;\n    Q.push(s);\n    while(!Q.empty()){\n        int v = Q.front(); Q.pop();\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v] + 1;\n                Q.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v,int t,int f){\n    if(v == t) return f;\n    for(int &i = iter[v] ; i < (int)G[v].size() ; i++){\n        Edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]){\n            int d = dfs(e.to,t,min(f,e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    for(;;){\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f = dfs(s,t,INF)) > 0){\n            flow += f;\n        }\n    }\n}\n\nint main(){\n    int N,M,S,T,a,b;\n    int edge[MAX_V][MAX_V];\n    memset(edge,-1,sizeof(edge));\n    cin >> N >> M;\n    for(int i = 0 ; i < M ; i++){\n        cin >> a >> b;\n        a--; b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n        edge[b][a] = i;\n    }\n    cin >> S >> T; S--; T--;\n    int res = max_flow(S,T);\n    cout << res << endl;\n    vector<int> v;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < (int)G[i].size() ; j++){\n            int to = G[i][j].to;\n            if(edge[i][to] == -1) continue;\n            if(G[i][j].cap == 0){\n                v.push_back(edge[i][to]);\n            }\n            edge[i][to] = -1;\n        }\n    }\n    sort(v.begin(),v.end());\n    int size = v.size();\n    cout << size << endl;\n    for(int i = 0 ; i < size ; i++){\n        cout << v[i]+1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int NV = 305;\nconst int NE = 45000;\n\nstruct ISAP {\n    int n, size;\n    int head[NV];\n    int dis[NV], gap[NV], pre[NV], cur[NV];\n    int maxflow;\n\n    struct Edge {\n        int v, w, next;\n        Edge () {}\n        Edge (int V, int NEXT, int W = 0) : v(V), next(NEXT), w(W) { }\n    }E[NE];\n\n    void init(int x) {\n        n = x, size = 0;\n        for (int i = 0; i <= n; i++) {\n            head[i] = -1;\n        }\n    }\n\n    inline void insert(int u, int v, int w = 0) {\n        E[size] = Edge(v, head[u], w);\n        head[u] = size++;\n        E[size] = Edge(u, head[v], w); //豬??蜿榊髄蟒コ霎ケ\n        head[v] = size++;\n    }\n\n    int MaxFlow(int src, int des) {\n        maxflow = 0;\n        gap[0] = n;\n        for (int i = 0; i <= n; i++) {\n            dis[i] = gap[i] = 0;\n        }\n        for (int i = 0; i <= n; i++) {\n            cur[i] = head[i];\n        }\n        int u = pre[src] = src;\n        int aug = -1;\n        while (dis[src] < n) {//扈捺據譚。莉カ1\nloop:\n            for (int &i = cur[u]; i != -1; i = E[i].next) {\n                int v = E[i].v;\n                if (E[i].w && dis[u] == dis[v] + 1) {\n                    aug = min(aug, E[i].w);\n                    pre[v] = u;\n                    u = v;\n                    if (v == des) {//謇セ蛻ー荳?擅蠅槫ケソ霍ッ?梧峩譁ー\n                        maxflow += aug;\n                        // //菫ョ謾ケ谿倶ス咏ス醍サ?\n                        for (u = pre[u]; v != src; v = u, u = pre[u]) {\n                            E[cur[u]].w -= aug;//豁」蜷題セケ\n                            E[cur[u]^1].w += aug;//蜿榊髄霎ケ\n                        }\n                        aug = INT_MAX;\n                    }//if\n                    goto loop;\n                }//for\n            }//for\n            //蟇サ謇セ譛?ー冗噪霍晉ヲサ譬?捷?悟ケカ菫ョ謾ケ蠖灘燕轤ケ    荳コ譛?ー冗噪譬?捷+1\n            int mdis = n;\n            for (int i = head[u]; i != -1; i = E[i].next) {\n                int v = E[i].v;\n                if (E[i].w && mdis > dis[v]) {\n                    cur[u] = i;\n                    mdis = dis[v];\n                }\n            }//for\n\n            //GAP 莨伜喧 譁ュ螻ょ?霍ウ蜃コ 扈捺據譚。莉カ2\n            if ((--gap[dis[u]]) == 0) {\n                break;\n            }\n            gap[dis[u] = mdis + 1]++;//蟆?凶譛芽ッ・譬?捷逧?焚驥丞刈1\n            u = pre[u];//蠖灘燕闃らせ 霑∫ァサ荳?クェ\n        }//while\n        return maxflow;\n    }//ISAP\n}G;\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\tG.init(n);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tif (u == v) {\n\t\t\tcontinue;\n\t\t}\n\t\tG.insert(u, v, 1);\n\t}\n\tint s, t;\n\tscanf(\"%d%d\", &s, &t);\n\tprintf(\"%d\\n\", G.MaxFlow(s, t));\n\t\n\tint total = 0, ans[10005];\n\n\tfor (int i = 0; i < G.size; i++) {\n\t\tif (G.E[i].w > 1) //螯よ棡闃らせ霑俶怏谿倶ス呻シ域イ。豬∬ソ?シ?\n\t\t\tif (i % 2 == 0)\n\t\t\t\tans[total++] = i/2+1; //螳樣刔霎ケ莉?蠑?ァ区?隶ー\n\t}\n\n\tprintf(\"%d\\n\", total);\n\tfor (int i = 0; i < total; i++) {\n\t\tprintf(\"%d\\n\", ans[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int to, cap, rev; };\nint V, E, S, T, c[109][109]; vector<int> used; vector<vector<edge> > G;\nvoid add_edge(int v1, int v2, int cap) {\n\tG[v1].push_back(edge{ v2, cap, (int)G[v2].size() });\n\tG[v2].push_back(edge{ v1, 0, (int)G[v1].size() - 1 });\n}\nint rec(int p, int t, int f) {\n\tif (p == t) return f;\n\tused[p] = 1;\n\tfor (auto &e : G[p]) {\n\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\tint res = rec(e.to, t, min(e.cap, f));\n\t\tif (res) {\n\t\t\tc[p][e.to]++;\n\t\t\te.cap -= res, G[e.to][e.rev].cap += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint ret = 0;\n\twhile (true) {\n\t\tused = vector<int>(V, 0);\n\t\tint res = rec(s, t, 2147483647);\n\t\tif (!res) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> V >> E; G.resize(V);\n\tvector<int> x1(E), x2(E);\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x1[i] >> x2[i]; x1[i]--, x2[i]--;\n\t\tadd_edge(x1[i], x2[i], 1);\n\t\tadd_edge(x2[i], x1[i], 1);\n\t}\n\tcin >> S >> T; S--, T--;\n\tcout << max_flow(S, T) << endl;\n\tint ret = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) ret++;\n\t}\n\tcout << ret << endl;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2304.cc: Reverse Roads\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 300;\nconst int MAX_M = 1000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\n/* global variables */\n\npii es[MAX_M];\nvpii nbrs[MAX_N];\nint minfs[MAX_N], flows[MAX_N][MAX_N], prvs[MAX_N];\n\n/* subroutines */\n\nint maxflow(int st, int gl) {\n  memset(flows, 0, sizeof(flows));\n  int max_flow = 0;\n\n  for (;;) {\n    //printf(\"max_flow = %d, limit = %d\\n\", max_flow, limit);\n\n    memset(prvs, -1, sizeof(prvs));\n    prvs[st] = st;\n    minfs[st] = INF;\n\n    queue<int> q;\n    q.push(st);\n\n    while (! q.empty()) {\n      int ui = q.front(); q.pop();\n\n      if (ui == gl) break;\n      vpii& nbru = nbrs[ui];\n      for (vpii::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n        int vi = vit->first;\n        int vc = vit->second - flows[ui][vi];\n        if (prvs[vi] < 0 && vc > 0) {\n          prvs[vi] = ui;\n          minfs[vi] = (minfs[ui] < vc) ? minfs[ui] : vc;\n          q.push(vi);\n        }\n      }\n    }\n\n    if (prvs[gl] < 0) break;\n\n    int min_flow = minfs[gl];\n    for (int j = gl; j != st;) {\n      int i = prvs[j];\n      flows[i][j] += min_flow;\n      flows[j][i] -= min_flow;\n      j = i;\n    }\n\n    max_flow += min_flow;\n  }\n\n  return max_flow;\n}\n\n/* main */\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int xi, yi;\n    cin >> xi >> yi;\n    xi--, yi--;\n    nbrs[xi].push_back(pii(yi, 1));\n    nbrs[yi].push_back(pii(xi, 1));\n\n    es[i] = pii(xi, yi);\n  }\n\n  int st, gl;\n  cin >> st >> gl;\n  st--, gl--;\n\n  int mf = maxflow(st, gl);\n\n  vi vs;\n  for (int i = 0; i < m; i++)\n    if (flows[es[i].first][es[i].second] < 0) vs.push_back(i);\n\n  printf(\"%d\\n\", mf);\n  printf(\"%lu\\n\", vs.size());\n  for (int i = 0; i < vs.size(); i++) printf(\"%d\\n\", vs[i] + 1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n    int rIdx;\n};\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ¹ª·ÅÉè³êÄ¢é©Ç¤©\nbool decided[10001];\nbool isRevEdge[10001];\n\nvoid add_edge(int from,int to,int cap,int idx){\n\tedge e;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n    e.rIdx=idx;\n\tG[from].push_back(e);\n\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n    if(v==t)\n\t\treturn f;\n\tused[v]=true;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tedge &e = G[v][i];\n        // Vµ¢¹©Ç¤©\n        bool ok=false;\n        bool change=false;\n        if(!decided[e.rIdx]){\n            ok=true;\n            decided[e.rIdx]=true;\n            // tü«É¬µÄ¨­\n            if(e.cap==0){\n                change=true;\n                isRevEdge[e.rIdx]=true;\n                G[e.to][e.rev].cap=0;\n                e.cap=1;\n            }\n        }\n        if(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n            else{\n                // ¡ñÏXÅ«È¢êÅAtü«É¬µÄ¢éÌÅ êÎAC³·é\n                if(ok){\n                    decided[e.rIdx]=false;\n                    if(isRevEdge[e.rIdx]&&change){\n                        isRevEdge[e.rIdx]=false;\n                        G[e.to][e.rev].cap=1;\n                        e.cap=0;\n                    }\n                }\n            }\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n    fill(isRevEdge,isRevEdge+10001,false);\n    fill(decided,decided+10001,false);\n\twhile(1){\n\t\tfill(used,used+MAX_V,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++){\n        int from,to;\n        cin>>from>>to;\n        add_edge(from,to,1,i);\n    }\n    int s,t;\n    cin>>s>>t;\n    int res=max_flow(s,t);\n    cout<<res<<endl;\n    set<int> ss;\n    for(int i = 0; i < m; i++)\n        if(isRevEdge[i])\n            ss.insert(i);\n    cout<<ss.size()<<endl;\n    for(set<int>::iterator it = ss.begin();it!=ss.end();it++)\n        cout<<(*it+1)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  void add_undirected_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, cap, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  MaxFlow mf(N);\n  vector<pll> edges;\n  REP(i, 0, M) {\n    ll X, Y;\n    cin >> X >> Y;\n    X--;\n    Y--;\n    mf.add_undirected_edge(X, Y, 1);\n    edges.push_back(pll(X, Y));\n  }\n  ll S, T;\n  cin >> S >> T;\n  S--;\n  T--;\n\n  ll f = mf.max_flow(S, T);\n  vector<ll> idx;\n  REP(i, 0, N) {\n    for(auto e : mf.E[i]) {\n      if(binary_search(edges.begin(), edges.end(), pll(e.to, i)) && e.cap == 0) {\n        idx.push_back(lower_bound(edges.begin(), edges.end(), pll(e.to, i)) - edges.begin());\n      }\n    }\n  }\n\n  cout << f << endl;\n  cout << idx.size() << endl;\n  for(auto i : idx) cout << i + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cap,rev,num,add;\n\tEdge(){}\n\tEdge(int s, int d, int cp, int r, int n, int a)\n\t\t:src(s),dst(d),cap(cp),rev(r),num(n), add(a)\n\t{}\n};\n\nconst int INF = (1<<28);\n\ntypedef vector<vector<Edge> > Graph;\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=e.cap;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tgraph[p][i].cap -= f;\n\t\t\tgraph[next][e.rev].cap += f;\n\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\t\t\t\tif(level[e.dst]!=-1) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.dst]=level[n]+1;\n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int d, int c, int f, int n, int a, Graph& g)\n{\n\tg[s].push_back(Edge(s,d,f,g[d].size()  , n, a));\n\tg[d].push_back(Edge(d,s,0,g[s].size()-1, n, 0)); \n}\n\nint main()\n{\n\tint N,M,S,T;\n\tcin >> N >> M;\n\n\tGraph g(N);\n\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tadd_edge(s-1, t-1, 0, 1, i, 0, g);\n\t\tadd_edge(t-1, s-1, 1, 1, i, 1, g);\n\t}\n\n\tcin >> S >> T;\n\tcout << dinic(S-1,T-1,g) << endl;\n\n\tvector<int> res;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<g[i].size(); j++)\n\t{\n\t\tif(g[i][j].add == 1 && g[i][j].cap == 0)\n\t\t\tres.push_back(g[i][j].num);\n\t}\n\n\tcout << res.size() << endl;\n\tsort(res.begin(), res.end());\n\tfor(int i=0; i<res.size(); i++)\n\t\tcout << res[i] + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n\ntemplate <typename T>\npair<T, vector<vector<T> > >\nedmonds_karp(const vector<vector<T> >& capacity, int source, int sink)/*{{{*/\n{\n  const int N = capacity.size();\n  vector<vector<T> > flow(N, vector<T>(N, 0));\n  T max_flow = 0;\n\n  while (true) {\n    vector<int> parent(N, -1);\n    queue<int> q;\n    q.push(source);\n\n    while (!q.empty() && parent[sink] < 0) {\n      const int v = q.front();\n      q.pop();\n\n      for (int u = 0; u < N; u++) {\n        if (parent[u] < 0 && capacity[v][u] - flow[v][u] > 0) {\n          parent[u] = v;\n          if (u == sink) {\n            break;\n          }\n          q.push(u);\n        }\n      }\n    }\n\n    if (parent[sink] < 0) {\n      break;\n    }\n\n    T aug = numeric_limits<T>::max();\n    for (int v = sink; v != source; v = parent[v]) {\n      const int u = parent[v];\n      aug = min(aug, capacity[u][v] - flow[u][v]);\n    }\n    max_flow += aug;\n    for (int v = sink; v != source; v = parent[v]) {\n      const int u = parent[v];\n      flow[u][v] += aug;\n      flow[v][u] -= aug;\n    }\n  }\n\n  return make_pair(max_flow, flow);\n}/*}}}*/\n\nint main()\n{\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int> > capacity(N, vector<int>(N, 0));\n  vector<pair<int,int> > edges;\n  for (int i = 0; i < M; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u;  --v;\n    ++capacity[u][v];\n    ++capacity[v][u];\n    edges.push_back(make_pair(u, v));\n  }\n  int S, T;\n  cin >> S >> T;\n  --S;  --T;\n\n  const pair<int, vector<vector<int> > > r = edmonds_karp(capacity, S, T);\n  cout << r.first << endl;\n  vector<int> ans;\n  const vector<vector<int> >& flow = r.second;\n  for (int i = 0; i < M; i++) {\n    if (flow[edges[i].second][edges[i].first] > 0) {\n      ans.push_back(i);\n    }\n  }\n  cout << ans.size() << endl;\n  for (vector<int>::const_iterator it = ans.begin(); it != ans.end(); ++it) {\n    cout << *it+1 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#define MAX_N 305\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nstruct edge{int to,cap,rev,id;};\nvector<edge>G[MAX_N];\nint N,M,S,T;\nbool flg[MAX_N];\nset<int>revd;\nvoid add_edge(int f,int t,int cap,int id)\n{\n\tedge a={t,cap,G[t].size(),id},\n\t\t b={f,cap,G[f].size(),id+M};\n\tG[f].push_back(a);\n\tG[t].push_back(b);\n}\n\nint dfs(int n,int g,int f)\n{\n\tif(n==g)return f;\n\tflg[n]=true;\n\tfor(int i=0;i<G[n].size();i++)\n\t{\n\t\tedge &e=G[n][i];\n\t\tif(!flg[e.to]&&e.cap>0)\n\t\t{\n\t\t\tint d=dfs(e.to,g,min(f,e.cap));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tif(e.id>=M)revd.insert(e.id-M);\n\t\t\t\telse if(e.id<M&&e.cap==0)revd.erase(e.id);\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_frow(int s,int t)\n{\n\tint flow=0;\n\trevd.clear();\n\tfor(;;)\n\t{\n\t\tmemset(flg,0,sizeof(flg));\n\t\tint f=dfs(s,t,100000000);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--,y--;\n\t\tadd_edge(x,y,1,i);\n\t}\n\tscanf(\"%d%d\",&S,&T);\n\tS--;T--;\n\tprintf(\"%d\\n\",max_frow(S,T));\n\tprintf(\"%d\\n\",revd.size());\n\tfor(set<int>::iterator it=revd.begin();it!=revd.end();it++)\n\t\tprintf(\"%d\\n\",*it+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\ntemplate <class Cap, bool isDirect>\nstruct MaxFlow {\n    struct Edge {\n        int src, dst;\n        Cap cap;\n        Edge(int src, int dst, Cap cap)\n            : src(src), dst(dst), cap(cap){};\n    };\n\n    using Edges = std::vector<Edge>;\n    using Graph = std::vector<std::vector<int>>;\n\n    Edges edges;\n    Graph graph;\n    std::vector<bool> visited;\n\n    explicit MaxFlow(int n)\n        : graph(n), visited(n) {}\n\n    void span(int u, int v, Cap cap) {\n        graph[u].push_back(edges.size());\n        edges.emplace_back(u, v, cap);\n\n        graph[v].push_back(edges.size());\n        edges.emplace_back(v, u, (isDirect ? 0 : cap));\n    }\n\n    int dfs(int v, int g, Cap f) {\n        if (v == g) return f;\n\n        visited[v] = true;\n        for (auto eidx : graph[v]) {\n            auto& edge = edges[eidx];\n\n            if (edge.cap > 0 && !visited[edge.dst]) {\n                Cap df = dfs(edge.dst, g, std::min(f, edge.cap));\n\n                if (df > 0) {\n                    edge.cap -= df;\n                    auto& redge = edges[eidx ^ 1];\n                    redge.cap += df;\n                    return df;\n                }\n            }\n        }\n        return 0;\n    }\n\n    Cap exec(int s, int g) {\n        constexpr Cap INF = std::numeric_limits<Cap>::max();\n\n        Cap ret = 0;\n        while (true) {\n            std::fill(visited.begin(), visited.end(), false);\n            Cap flow = dfs(s, g, INF);\n            if (flow == 0) return ret;\n            ret += flow;\n        }\n    }\n};\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    MaxFlow<int, false> mf(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        mf.span(--u, --v, 1);\n    }\n\n    int s, t;\n    std::cin >> s >> t;\n    std::cout << mf.exec(--s, --t) << \"\\n\";\n\n    std::vector<int> revs;\n    for (int i = 0; i < m; ++i) {\n        if (mf.edges[i * 2 + 1].cap == 0) revs.push_back(i + 1);\n    }\n\n    std::cout << revs.size() << \"\\n\";\n    for (auto i : revs) std::cout << i << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\n\nint M;\n\nstruct Dinic {\n    struct edge { int idx, to, cap, rev; };\n    int V, E;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    Dinic(int V) : V(V) { G.assign(V, vector<edge>()); }\n\n    // 0-indexed\n    void add_edge(int from, int to, int cap, int idx) {\n        G[from].push_back((edge){idx, to, cap, (int)G[to].size()});\n        G[to].push_back((edge){-1, from, 0, (int)(G[from].size() - 1)});\n        E++;\n    }\n\n    void bfs(int s) {\n        level.assign(V, -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for (auto &e : G[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = itr[v]; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    // s --> t\n    int max_flow(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V, 0);\n            while ((f = dfs(s, t, INF)) > 0) ret += f;\n        }\n        return ret;\n    }\n\n    pair<int, set<int>> solve(int s, int t) {\n        int mxf = max_flow(s, t);\n        set<int> edges;\n        REP(i, V) {\n            FORE(e, G[i]) {\n                if (e.cap == 0 && e.idx > M) {\n                    edges.insert(e.idx - M);\n                }\n            }\n        }\n        return {mxf, edges};\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N >> M;\n    Dinic dinic(N);\n    REP(i, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        dinic.add_edge(a, b, 1, i + 1);\n        dinic.add_edge(b, a, 1, M + (i + 1));\n    }\n    int S, T;\n    cin >> S >> T;\n    S--, T--;\n\n    auto ans = dinic.solve(S, T);\n    cout << ans.first << endl;\n    cout << SZ(ans.second) << endl;\n    FORE(x, ans.second) cout << x << endl;\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  \n  int A[1001],B[1001];\n  for(int i=0,a,b;i<m;i++){\n    cin>>A[i]>>B[i];\n    add_edge(A[i],B[i],1);\n    add_edge(B[i],A[i],1);\n  }\n  int s,t;\n  cin>>s>>t;\n  cout <<max_flow(s,t)<<endl;\n\n  vector<int> ans;  \n  for(int i=0;i<m;i++){\n    int a=A[i],b=B[i];\n    int flg=0;\n    for(int j=0;j<G[a].size();j++)\n      if(G[a][j].to==b&&G[a][j].cap>=1)flg=1;\n    if(flg) ans.push_back(i+1);\n  }\n\n  cout <<ans.size()<<endl;\n  for(int i=0;i<ans.size();i++)cout<<ans[i]<<endl;\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\n\nconst int MAX_V = 2010; //?????????????????°\nstruct Flow{\n\tstruct edge{\n\t\tint to, cap, rev;\n\t};\n\tvector<edge> G[MAX_V];//??£??\\?????????\n\tbool used[MAX_V];\n \n\tvoid add_edge(int from, int to, int cap){\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n\t}\n\t//?¢???????????????¢???\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < G[v].size(); ++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t//s??????t???????????§???\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif(f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\nint N, M;\nint X[310], Y[310];\nint S, T;\nint main(void) {\n\tscanf(\"%d %d\", &N, &M);\n\trep(i, M) scanf(\"%d %d\", &X[i], &Y[i]);\n\tscanf(\"%d %d\", &S, &T);\n\n\tFlow fw;\n\trep(i, M) fw.add_edge(X[i], Y[i], 1), fw.add_edge(Y[i], X[i], 1);\n\tint ret = fw.max_flow(S, T);\n\tset<int> ans;\n\trep(i, M) {\n\t\tfor(auto& u : fw.G[Y[i]]) if(u.to == X[i] && u.cap == 0){\n\t\t\tans.insert(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\tprintf(\"%d\\n\", ans.size());\n\tfor(auto u : ans) printf(\"%d\\n\", u + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define INF 2000000000\n#define typec int//type of cost\nconst int pN=500,eN=10000;\nstruct Edge{\n\tint u,v,next;\n\ttypec w;\n};\nEdge edge[eN];\nint en,head[pN],cur[pN],ps[pN],dep[pN];\nvoid insert(int u,int v){\n\tedge[en].u=u;\n\tedge[en].v=v;\n\tedge[en].w=1;\n\tedge[en].next=head[u];\n\thead[u]=en++;\n\tedge[en].u=v;\n\tedge[en].v=u;\n\tedge[en].w=1;//æåä¸º0ï¼æ åä¸ºc\n\tedge[en].next=head[v];\n\thead[v]=en++;\n}\ntypec max_flow(int n,int s,int t){\n\ttypec tr,res=0;\n\tint i,j,k,f,r,top;\n\twhile(1){\n\t\tmemset(dep,-1,n*sizeof(int));\n\t\tfor(f=dep[ps[0]=s]=0,r=1;f!=r;)\n\t\t\tfor(i=ps[f++],j=head[i];j!=-1;j=edge[j].next){\n\t\t\t\tif(edge[j].w&&-1==dep[k=edge[j].v]){\n\t\t\t\t\tdep[k]=dep[i]+1;\n\t\t\t\t\tps[r++]=k;\n\t\t\t\t\tif(k==t){\n\t\t\t\t\t\tf=r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1==dep[t])break;\n\t\t\tmemcpy(cur,head,n*sizeof(int));\n\t\t\tfor(i=s,top=0;;){\n\t\t\t\tif(i==t){\n\t\t\t\t\tfor(k=0,tr=INF;k<top;++k)\n\t\t\t\t\t\tif(edge[ps[k]].w<tr)\n\t\t\t\t\t\t\ttr=edge[ps[f=k]].w;\n\t\t\t\t\t\tfor(k=0;k<top;++k)\n\t\t\t\t\t\t\tedge[ps[k]].w-=tr,edge[ps[k]^1].w+=tr;\n\t\t\t\t\t\tres+=tr;\n\t\t\t\t\t\ti=edge[ps[top=f]].u;\n\t\t\t\t}\n\t\t\t\tfor(j=cur[i];cur[i]!=-1;j=cur[i]=edge[cur[i]].next)\n\t\t\t\t\tif(edge[j].w&&dep[i]+1==dep[edge[j].v])break;\n\t\t\t\t\tif(cur[i]!=-1){\n\t\t\t\t\t\tps[top++]=cur[i];\n\t\t\t\t\t\ti=edge[cur[i]].v;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(0==top)break;\n\t\t\t\t\t\tdep[i]=-1;\n\t\t\t\t\t\ti=edge[ps[--top]].u;\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\treturn res;\n}\nint N,M,S,E;\nvoid get_data(){\n\tint i;\n\tscanf(\"%d%d\",&N,&M);\n\tmemset(head,-1,sizeof(head));en=0;\n\tint u,v;\n\tfor(i=0;i<M;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tinsert(u,v);\n\t}\n\tscanf(\"%d%d\",&S,&E);\n\tS--;E--;\n}\nvoid run(){\n\tint flow=max_flow(N,S,E);\n\tint cnt=0,i,res[1000];\n\tfor(i=0;i<en;i+=2){\n\t\tif(edge[i].w==2)res[cnt++]=i/2+1;\n\t}\n\tprintf(\"%d\\n%d\\n\",flow,cnt);\n\tfor(i=0;i<cnt;i++)printf(\"%d\\n\",res[i]);\n}\nint main(){\n\tget_data();\n\trun();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct FordFulkerson{\n    struct Edge {\n        int to,cap,rev;\n        Edge(int to=0,int cap=0,int rev=0) :\n            to(to),cap(cap),rev(rev){}\n    };\n\n    int V;\n    vector<vector<Edge> > G;\n    vector<bool> used;\n\n    FordFulkerson(int V) : V(V) {\n        G.resize(V);\n        used.assign(V,false);\n    }\n\n    void add_edge(int from,int to,int cap) {\n        G[from].pb(Edge(to,cap,G[to].size()));\n        G[to].pb(Edge(from,0,G[from].size()-1));\n    }\n\n    int dfs(int v,int t,int f) {\n        if(v==t) return f;\n        used[v]=true;\n        for(int i=0;i<G[v].size();i++) {\n            Edge &e=G[v][i];\n\n            if(!used[e.to] && e.cap>0) {\n                int d=dfs(e.to,t,min(f,e.cap));\n                if(d>0) {\n                    e.cap-=d;\n                    G[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s,int t) {\n        int flow=0;\n        while(1) {\n            used.assign(V,false);\n            int f=dfs(s,t,INF);\n            if(f==0) break;\n            flow+=f;\n        }\n\n        return flow;\n    }\n    void dump() {\n        rep(i,V) {\n            printf(\"%d size=%d\\n\",i,G[i].size());\n            rep(j,G[i].size()) {\n                Edge e=G[i][j];\n                printf(\" %d->%d cap:%d rev=%d\\n\",i,e.to,e.cap,e.rev);\n            }\n        }\n    }\n    void func(set<int> S[],vector<P> &ans) {\n        rep(i,V) {\n            rep(j,G[i].size()) {\n                Edge e=G[i][j];\n                if(e.cap==0) {\n                    if(!S[i].count(e.to)) ans.pb(P(e.to,i));\n                }\n            }\n        }\n        sort(all(ans));\n        ans.erase(unique(all(ans)),ans.end());\n    }\n};\nint n,m;\nint s,t;\nint main() {\n    cin>>n>>m;\n    FordFulkerson ff(n);\n    set<int> S[300];\n    map<P,int> in;\n    rep(i,m) {\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        ff.add_edge(x,y,1);\n        ff.add_edge(y,x,1);\n        S[x].insert(y);\n        in[P(x,y)]=i+1;\n    }\n    cin>>s>>t;\n    s--,t--;\n    cout<<ff.max_flow(s,t)<<endl;\n    vector<P> ans;\n    ff.func(S,ans);\n    cout<<ans.size()<<endl;\n    rep(i,ans.size()) cout<<in[ans[i]]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <string>\nusing namespace std;\nconst int N = 310;\nint ans[N*N],x[N*N],y[N*N],data[N][N];\nint n,m,map[N][N],path[N],flow[N],s,t,vis[N][N];\nqueue<int> q;\nint bfs()\n{\n\tint u,i;\n\twhile(!q.empty())\tq.pop();\n\tmemset(path,-1,sizeof(path));\n\tq.push(s);\n\tflow[s]=100000;path[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tu=q.front();\n\t\tq.pop();\n\t\tif(u==t) break;\n\t\tfor(i=1;i<=t;i++)\n\t\t\tif(path[i]==-1&&map[u][i])\n\t\t\t{\n\t\t\t\tflow[i]=flow[u]<map[u][i]?flow[u]:map[u][i];\n\t\t\t\tpath[i]=u;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n\tif(path[t]==-1)//\n\t\treturn -1;\n\telse\n\t\treturn flow[t];\n}\nint EK()\n{\n\tint step,max_flow=0,now,pre;\n\twhile((step=bfs())!=-1)\n\t{\n\t\tmax_flow+=step;\n\t\tnow=t;\n\t\twhile(now!=s)\n\t\t{\n\t\t\tpre=path[now];\n\t\t\tmap[pre][now]-=step;\n\t\t\tmap[now][pre]+=step;\n\t\t\tnow=pre;\n\t\t}\n\t}\n\treturn max_flow;\n}\nint main()\n{\n\tint i,u,v;\n\twhile(scanf(\"%d%d\",&n,&m)==2)\n\t{\n\t\tmemset(map,-1,sizeof(map));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(data,0,sizeof(data));\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tx[i]=u;\n\t\t\ty[i]=v;\n\t\t\tdata[u][v]=1;\n\t\t\tmap[u][v]=map[v][u]=1;\n\t\t}\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tprintf(\"%d\\n\",EK());\n\t\tint r=0;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tu=x[i];v=y[i];\n\t\t\tif(map[v][u]==0)\n\t\t\t\tif(data[v][u]^data[u][v])\n\t\t\t\tans[r++]=i;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t\tfor(i=0;i<r;i++)\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef vector<vector<int> > G;\n\nint flow(G &g, int s, int d){\n  int n = g.size();\n  int ans = 0;\n\n  while(true){\n    vector<int> prevs(n,-1);\n    queue<int> q;\n    bool ok = false;\n    \n    prevs[s]=n;\n    q.push(s);\n    while(!q.empty()){\n      int now = q.front();\n      q.pop();\n      if(now == d){\n        ok = true;\n        break;\n      }\n      for(int i=0;i<n;i++){\n        if(g[now][i]>0){\n          if(prevs[i]==-1){\n            prevs[i]=now;\n            q.push(i);\n          }\n        }\n      }\n    }\n\n    if(!ok) return ans;\n\n    int f = 100000;\n    int pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      f = min(f,g[pos2][pos]);\n      pos = pos2;\n    }\n    pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      g[pos2][pos]-=f;\n      g[pos][pos2]+=f;\n      pos = pos2;\n    }\n    ans += f;\n  }\n}\n\nmap<pair<int,int>, int> id;\n\nint main(){\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n\n  vector<vector<int> > g(n, vector<int>(n));\n\n  REP(i,m){\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    g[a-1][b-1] = 1;\n    g[b-1][a-1] = 1;\n    id[make_pair(a-1,b-1)] = i;\n  }\n\n  int s, t;\n  scanf(\"%d%d\", &s, &t);\n\n  //REP(i,n){REP(j,n) printf(\"%2d \", g[i][j]); puts(\"\");}\n\n  int ans = flow(g, s-1, t-1);\n  vector<int> rev;\n\n  //REP(i,n){REP(j,n) printf(\"%2d \", g[i][j]); puts(\"\");}\n\n  REP(i,n) REP(j,n) if(g[i][j] == 2){\n    if(id.count(make_pair(i,j))) rev.push_back(id[make_pair(i,j)] + 1);\n  }\n  sort(rev.begin(), rev.end());\n\n  printf(\"%d\\n\", ans);\n  printf(\"%d\\n\", rev.size());\n  REP(i,rev.size()) printf(\"%d\\n\", rev[i]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \nstruct P\n{\n  int to,cap,rev;\n  P(int to=-1,int cap=-1,int rev=-1):to(to),cap(cap),rev(rev){}\n};\ntypedef vector<int> VI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\ntypedef pair<int,int> Pes;\nint N,M,s,t;\nVVP G;\nvector<int> level,iter;\nvector<Pes> vec;\nvector<int> pvec;\nbool sign;\n \nvoid add_edge(int from,int to,int i)\n{\n  if(sign)vec.push_back(Pes(from,G[from].size())),\n        pvec.push_back(i);\n  G[from].push_back(P(to,1,G[to].size()));\n  G[to].push_back(P(from,0,G[from].size()-1));\n}\n \nvoid bfs()\n{\n  deque<int> deq;\n  deq.push_back(s);\n  level[s] = 0;\n  while(!deq.empty())\n    {\n      int p = deq.front(); deq.pop_front();\n      rep(i,G[p].size())\n    {\n      P pes = G[p][i];\n      int v = pes.to;\n      if(level[v] == -1 && pes.cap > 0)\n        {\n          level[v] = level[p]+1;\n          deq.push_back(v);\n        }\n    }\n    }\n}\n \nint dfs(int v,int flow)\n{\n  if(v == t)return flow;\n \n  for(int &i = iter[v];i < G[v].size();i++)\n    {\n      P p = G[v][i];\n \n      if(p.cap <= 0)continue;\n      if(level[v] < level[p.to])\n    {\n      int d = dfs(p.to,min(flow,p.cap));\n      if(d <= 0)continue;\n      G[v][i].cap -= d;\n      G[p.to][p.rev].cap += d;\n      return d;\n         \n    }\n    }\n  return 0;\n}\n \nint maximum_flow()\n{\n  int res = 0;\n  iter.resize(N);\n  level.resize(N);\n  while(1)\n    {\n      rep(i,N)\n    iter[i] = 0,level[i] = -1;\n       bfs();\n       \n       if(level[t] < 0)return res;\n       int f;\n   \n       while((f = dfs(s,(1<<29))) > 0)\n     res += f;\n      \n    }\n  return res;\n}\n \nint main()\n{\n  cin >> N >> M;\n  G.resize(N);\n  rep(i,M)\n    {\n      int from,to;\n      cin >> from >> to;\n      from--,to--;\n      sign = false;\n      add_edge(from,to,i);\n      sign = true;\n      add_edge(to,from,i);\n    }\n  cin >> s >> t;\n  s--,t--;\n   \n  int mexico = maximum_flow();\n  int cnt = 0;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)cnt++;\n    }\n \n  cout << mexico << endl;\n  cout << cnt << endl;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)\n    cout << pvec[i]+1  << endl;\n    }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\ntypedef pair<int,int> pii;\nmap<pii, int> se;\nvector<pii> ans;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight edmonds_karp(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow(n, Array(n)), capacity(n, Array(n));\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n  \n  Weight total = 0;\n  while(1) {\n    queue<int> Q; Q.push(s);\n    vector<int> prev(n, -1); prev[s] = s;\n    while(!Q.empty() && prev[t] < 0) { // s ツつゥツづァ t ツづ鳴猟ャツつケツづゥツ路ツづーBFSツづ個ゥツづつつッツづゥツ。\n      int u = Q.front(); Q.pop();\n      REP(v, n) if (prev[v] < 0 && RESIDUE(u, v) > 0) {\n        prev[v] = u;\n        Q.push(v);\n      }\n    }\n    if (prev[t] < 0) break;\n    Weight inc = INF;\n    for (int j=t; prev[j]!=j; j=prev[j])\n      inc = min(inc, RESIDUE(prev[j], j));\n    for (int j=t; prev[j]!=j; j=prev[j])\n      flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc; // ツ逆ツ陛督づ掲low ツつゥツづァツ暗クツつュツつアツづづ可淞つオツ姪淞つケツづゥツづヲツつ、ツづ可つキツづゥツ。\n    // ツづつづ慊づィツ、flow ツつェツ猟ャツづェツつスツづつアツづォツづ個逆ツ古シツつォツづ個陛督づ可甘鳴つオツづСESIDUE ツつェツつサツづ個閉ェツ妥・ツつォツつュツづ按づゥツ。\n    total += inc;\n  }\n  REP(i,n) {\n    REP(j,n) {\n      if (flow[i][j] > 0) {\n        if (se.count(pii(i,j)) == 0) {\n          ans.push_back(pii(i,j));\n        }\n      }\n    }\n  }\n  return total;\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  int s,t;\n  REP(i,m) {\n    int x,y;\n    cin >> x >>y;\n    x--;y--;\n    g[x].push_back(Edge(x,y,1));\n    g[y].push_back(Edge(y,x,1));\n    se[pii(x,y)] = i+1;\n  }\n  cin >> s >> t;\n  s--;t--;\n  cout << edmonds_karp(g, s, t) << endl;\n  cout << ans.size() << endl;\n  vector<int> v;\n  FOR(it, ans) {\n    v.push_back(se[pii(it->second, it->first)]);\n  }\n  sort(ALL(v));\n  FOR(it,v)\n    cout << *it << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 301;\nconst int MAX_E = 10001;\nconst int INF = (1<<25);\nstruct edge{int to,cap,rev,num;bool isrev;};\nvector<edge> V[MAX];\nbool used[MAX];\nbool R[MAX_E];\nint N,M;\nint s,g;\n\nvoid input(){\n  cin >> N >> M;\n  for(int i = 0; i < M; i++){\n    int a,b;\n    cin >> a >> b;\n    V[a].push_back((edge){b,1,V[b].size(),i,false});\n    V[b].push_back((edge){a,1,V[a].size()-1,i,true});\n  }\n  cin >> s >> g;\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  \n  for(int i = 0; i < (int)V[v].size(); i++){\n    edge& e = V[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tV[e.to][e.rev].cap += d;\n\tR[e.num] = e.isrev;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  while(1){\n    memset(used,false,sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\n\nvoid solve(){\n\n  cout << max_flow(s,g) << endl;\n\n  vector<int> req;\n  for(int i = 0; i < M; i++)\n    if(R[i]) req.push_back(i+1);\n\n  cout << req.size() << endl;\n  for(int i = 0; i < (int)req.size(); i++)\n    cout << req[i] << endl;\n  \n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\nstruct edge {int to,cap,rev,id;};\nconst int MAX_V=400,inf=1000;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from, int to, int cap, int id){\n\tedge e1={to,cap,G[to].size(),id},e2={from,0,G[from].size(),-1};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t}\n}\nint main(){\n\tint n,m,x[1000],y[1000];\n\tcin >> n >> m;\n\tint s=0,t=n+1;\n\trep(i,m){\n\t\tcin >> x[i] >> y[i];\n\t\tadd_edge(x[i],y[i],1,-1);\n\t\tadd_edge(y[i],x[i],1,i);\n\t}\n\tint ss,tt;\n\tcin >> ss >> tt;\n\tadd_edge(s,ss,inf,-1);\n\tadd_edge(tt,t,inf,-1);\n\tcout << max_flow(s,t) << endl;\n\tbool ans[1000]={};\n\trep1(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tedge e=G[i][j];\n\t\t\tif(e.id<0) continue;\n\t\t\tif(e.cap==0) ans[e.id]=true;\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,m) if(ans[i]) cnt++;\n\tcout << cnt << endl;\n\trep(i,m) if(ans[i]) cout << i+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <climits>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MAX_N = 300;\nconst int MAX_M = MAX_N * (MAX_N - 1) / 2;\n\nint n, m;\nint s, t;\nint capacity[MAX_N][MAX_N];\nint flow[MAX_N][MAX_N];\nvector<int> graph[MAX_N];\n\nbool used[MAX_N];\nint dfs(int from, int to, int f) {\n\tif (from == to) return f;\n\tused[from] = true;\n\tfor (unsigned i = 0; i < graph[from].size(); i++) {\n\t\tconst int next = graph[from][i];\n\t\tconst int cap = capacity[from][next];\n\t\tif (!used[next] && cap - flow[from][next] > 0) {\n\t\t\tconst int d = dfs(next, t, min(f, cap));\n\t\t\tflow[from][next] += d;\n\t\t\tflow[next][from] -= d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow() {\n\tint res = 0;\n\twhile (true) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INT_MAX);\n\t\tif (f == 0) return res;\n\t\tres += f;\n\t}\n}\n\nint main () {\n\tvector<pair<int, int> > edges;\n\t\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tcapacity[x][y]++;\n\t\tcapacity[y][x]++;\n\t\tedges.push_back(make_pair(x, y));\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tcin >> s >> t;\n\ts--; t--;\n\t\n\tcout << max_flow() << endl;\n\t\n\tvector<int> ans;\n\tfor (int i = 0; i < m; i++) {\n\t\tpair<int, int>& e = edges[i];\n\t\tif (flow[e.second][e.first] > 0) {\n\t\t\tans.push_back(i);\n\t\t}\n\t}\n\tcout << ans.size() << endl;\n\tfor (unsigned i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G[v].size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n// Dinic を信じろ\n\ntemplate <typename CapTp=int, typename CostTp=int>\nstruct Edge {\n    int to, rev;\n    CapTp cap; CostTp cost;\n    bool is_rev;\n    Edge(int t, bool f, int r, CapTp ca, CostTp co=0)\n        : to(t), rev(r), cap(ca), cost(co), is_rev(f) {}\n};\n\ntemplate<typename CapTp=int>\nstruct Dinic {\n    using Graph = vector< vector< Edge<CapTp> > >;\n    Graph G;\n    vector<int> level, iter;\n    const CapTp IA;\n    vector< pair<int, int> > r_edges;\n    Dinic(int N, CapTp IA_=1<<29) : IA(IA_) {\n        G.resize(N);\n        level.resize(N);\n        iter.resize(N);\n    }\n    void add_edge(int from, int to, CapTp cap) {\n        G[from].emplace_back(to, false, G[to].size(), cap);\n        G[to].emplace_back(from, true, G[from].size() - 1, 0);\n        r_edges.emplace_back(to, G[to].size() - 1);\n    }\n    CapTp get_flowed_cap(size_t k) {\n        if(r_edges.size() <= k) return -1;\n        int v, i; tie(v, i) = r_edges[k];\n        return G[v][i].cap;\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> que; que.push(s);\n        level[s] = 0;\n        while(!que.empty()) {\n            int temp = que.front(); que.pop();\n            for(size_t i=0; i<G[temp].size(); i++) {\n                auto &e = G[temp][i];\n                if(e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[temp] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    CapTp dfs(int v, int t, CapTp f) {\n        if(v == t) return f;\n        for(int &i = iter[v]; i<(int)G[v].size(); i++) {\n            auto &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                CapTp d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    CapTp max_flow(int s, int t) {\n        CapTp flow = 0.0, f;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            while( (f = dfs(s, t, IA)) > 0 ) flow += f;\n        }\n    }\n};\n\n// 最小流量制約付きフロー\n// u から v に最小 lb, 最大 ub 流す\ntemplate<typename flow_type>\nstruct Dinic_lr {\n    Dinic<flow_type> fl;\n    int S, T;\n    flow_type sum_lb;\n\n    Dinic_lr() {}\n    Dinic_lr(int N) : fl(N+2, 0), S(N), T(N+1), sum_lb(0) {}\n\n    void add_edge(int u, int v, flow_type lb, flow_type ub) {\n        assert(0 <= lb && lb <= ub);\n        if(u == v || ub == 0) return;\n        fl.add_edge(u, v, ub - lb);\n        fl.add_edge(S, v, lb);\n        fl.add_edge(u, T, lb);\n        sum_lb += lb;\n    }\n\n    flow_type max_flow(int s, int t) {\n        flow_type a = fl.max_flow(S, T);\n        flow_type b = fl.max_flow(s, T);\n        flow_type c = fl.max_flow(S, t);\n        flow_type d = fl.max_flow(s, t);\n        return (a + c == sum_lb && a + b == sum_lb) ? b + d : -1;\n    }\n};\n\n\nvoid GRL_6_A() {\n    int V, E; scanf(\"%d%d\", &V, &E);\n    Dinic<> fl(V);\n    for(int i=0; i<E; i++) {\n        int u, v, c; scanf(\"%d%d%d\", &u, &v, &c);\n        fl.add_edge(u, v, c);\n    }\n    int source = 0, sink = V - 1;\n    printf(\"%d\\n\", fl.max_flow(source, sink));\n}\n\n// 復元の Verify\nvoid AOJ2304() {\n    int N, M; scanf(\"%d%d\", &N, &M);\n    Dinic<> fl(N);\n    for(int i=0; i<M; i++) {\n        int u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n        fl.add_edge(u, v, 1);\n        fl.add_edge(v, u, 1); // 逆向きの辺 (これに流れるかどうか？)\n    }\n    int source, sink; scanf(\"%d%d\", &source, &sink);\n    source--; sink--;\n    \n    int flow = fl.max_flow(source, sink);\n    printf(\"%d\\n\", flow);\n    vector<int> ans;\n    for(int i=0; i<M; i++) {\n        int k = 2*i + 1;\n        if(fl.get_flowed_cap(k) == 1) ans.emplace_back(i + 1);\n    }\n    printf(\"%zu\\n\", ans.size());\n    for(auto k : ans) printf(\"%d\\n\", k);\n}\n\nint main() {\n    // GRL_6_A();\n    AOJ2304();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\n\n\nstruct tumiki {\n\tlong long int x;\n\tlong long int y;\n\tlong long int id;\n};\n\nclass Compare {\npublic:\n\tbool operator()(const pair<int,long long  int>&l, const pair<int, long long int >&r) {\n\t\treturn l.second > r.second;\n\t}\n};\n\nstruct island {\n\tint id;\n\tint sink;\n\tvector<pair<int,int> >edges;\n\tisland(int N):edges(N) {\n\n\t}\n};\n\n\n\n\n#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = 2147483647;\n\ntypedef int Weight;\nstruct Edge {\n\tint id;\n\tbool real;\n\tint src, dst;\n\tWeight weight;\n\tEdge(bool real,int id,int src, int dst, Weight weight) :\n\t\tid(id),real(real),src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\nvector<pair<int, int>>uses;\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &g, int s, int t) {\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tint now = t;\n\t\twhile (prev[now]!=now&&prev[now]!=-1) {\n\t\t\tuses.push_back({ prev[now], now });\n\t\t\tnow = prev[now];\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tGraph g(N);\n\t\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tg[x].push_back(Edge(true,i,x, y, 1));\n\t\tg[y].push_back(Edge(false, i,y, x, 1));\n\t}\n\tint S, T; cin >> S >> T;\n\tS--; T--;\n\tint ans=maximumFlow(g, S, T);\n\n\tvector<int>changes(N, 1);\n\tfor (int i = 0; i < uses.size(); ++i) {\n\t\tfor (int j = 0; j < g[uses[i].first].size(); ++j) {\n\t\t\tif (g[uses[i].first][j].dst == uses[i].second){\n\t\t\t\tif (g[uses[i].first][j].real) {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvector<int>cs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (changes[i] == 0) {\n\t\t\tcs.push_back(i + 1);\n\t\t}\n\t}\n\tcout << ans << endl << cs.size() << endl;\n\tfor (int i = 0; i < cs.size(); ++i) {\n\t\tcout << cs[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\nstruct Edge {\n    const int to;         // 行き先のノードid\n    int flow;             // 流量\n    const int cap;        // 容量\n    const int rev;        // 逆辺のノードid\n    const bool is_rev;    // 逆辺かどうか\n    Edge(int to, int flow, int cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev) {\n        assert(this->cap >= 0);\n    }\n};\n\n// 最大流問題をO(F|E|)で解く\nclass FordFulkerson {\npublic:\n    const unsigned int num_of_node = 0;   // ノード数\n    map<int, vector<Edge>> G;       // グラフの隣接リスト表現\n\n    FordFulkerson(unsigned int num_of_node) : num_of_node(num_of_node) {\n    }\n\n    // fromからtoへ向かう容量capの辺とその逆辺をグラフに追加する\n    void add_edge(int from, int to, int cap) {\n        this->G[from].emplace_back(Edge(to, 0, cap, (int)this->G[to].size(), false));          // 辺\n        this->G[to].emplace_back(Edge(from, cap, cap, (int)this->G[from].size() - 1, true));     // 逆辺\n    }\n\n    // sからtへの最大流を求める O(F|E|)\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            vector<bool> used(this->num_of_node, false); // DFSですでに調べたかのフラグ\n            int f = dfs(s, t, INT_MAX, used);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n    }\n\n    // 水の流れたエッジを取得する\n    set<pair<int, int>> get_used_edges() {\n        set<pair<int, int>> used_edges;\n\n        for (auto p : this->G) {\n            int from = p.first;\n            for (Edge edge : p.second) {\n                int flow = edge.flow;\n                bool is_rev = edge.is_rev;\n\n                if (not is_rev and flow > 0) {\n                    int to = edge.to;\n                    used_edges.insert(make_pair(from , to));\n                }\n            }\n        }\n        return used_edges;\n    }\n\nprivate:\n    // vからtへf流したときの流れた量\n    int dfs(int from, int to, int f, vector<bool> &used) {\n        if (from == to) { return f; }\n        used[from] = true;\n        for (Edge &e : G[from]) {\n            int rest = e.cap - e.flow;\n            if (!used[e.to] && rest > 0) {\n                int d = dfs(e.to, to, min(f, rest), used);\n                if (d > 0) {\n                    e.flow += d;                 // 辺\n                    G[e.to][e.rev].flow -= d;    // 逆辺\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M, S, T;\n    cin >> N >> M;\n    FordFulkerson ff(N + 10);\n    V<pair<int, int>> edges;\n    FOR(i, 0, M) {\n        int x, y;\n        cin >> x >> y;\n        edges.emplace_back(make_pair(x, y));\n        ff.add_edge(x, y, 1);\n        ff.add_edge(y, x, 1);\n\n    }\n    cin >> S >> T;\n\n    int flow = ff.max_flow(S, T);\n\n    vector<int> ans;\n    auto used_edges = ff.get_used_edges();\n    FOE(edge, used_edges) {\n        int from = edge.first;\n        int to = edge.second;\n\n        FOR(i, 0, edges.size()) {\n            int from2 = edges[i].first;\n            int to2 = edges[i].second;\n\n            if (from == to2 and to == from2) {\n                ans.emplace_back(i + 1);\n                break;\n            }\n        }\n    }\n    sort(ALL(ans));\n\n    print(flow);\n    print(ans.size());\n    FOE(x, ans) {\n        print(x);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  //int ans = dinic.max_flow(S, T);\n  int ans = 1;\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://acm.hust.edu.cn:8080/judge/contest/view.action?cid=7068#problem/E\n\n#include <stdio.h>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 310;\nconst int MAXM = 1010;\nconst int INF = 1000000000;\n\nint head[MAXN];\nbool dele[MAXM], g[MAXN][MAXN];\nint e_cnt,  src, sink, n, m;\n\nstruct Edg\n{\n    int v, flow, next, id, from;\n}edg[MAXM * 4];\n\nvoid inline add(int a, int b, int c, int id)\n{\n    edg[e_cnt].v = b; edg[e_cnt].next = head[a];  edg[e_cnt].from = a;\n    edg[e_cnt].id = id; edg[e_cnt].flow = c; head[a] = e_cnt++;\n}\n\nint dis[MAXN], work[MAXN];\nbool bfs()\n{\n    memset(dis, -1, sizeof(dis));\n    queue<int> q;\n    q.push(src);    dis[src] = 0;\n    while(!q.empty())\n    {\n        int u = q.front();  q.pop();\n        for(int i = head[u]; i != -1; i = edg[i].next)\n        {\n            int v = edg[i].v;\n            if(dis[v] == -1 && edg[i].flow > 0)\n            {\n                dis[v] = dis[u] + 1;\n                q.push(v);\n                if(v == sink)  return 1;\n            }\n        }\n    }\n    return 0;\n}\nint dinic(int x, int flow)\n{\n    if(x == sink)  return flow;\n    for(int &i = work[x]; i != -1; i = edg[i].next)\n    {\n        int v = edg[i].v;\n        if(dis[v] == dis[x] + 1 && edg[i].flow > 0)\n        {\n            int tmp = dinic(v, min(flow, edg[i].flow));\n            edg[i].flow -= tmp;\n            edg[i ^ 1].flow += tmp;\n            if(tmp)  return tmp;\n        }\n    }\n    return 0;\n}\n\nint maxflow()\n{\n    int res(0);\n    while(bfs())\n    {\n        for(int i = 0; i < MAXN; ++i)   work[i] = head[i];\n        while(int g = dinic(src, INF))  res += g;\n    }\n    return res;\n}\nvoid read()\n{\n    memset(head, -1, sizeof(head));\n    memset(g, 0, sizeof(g));\n    e_cnt = 0;\n    for(int i = 0; i < m; ++i)\n    {\n        int ta, tb;\n        scanf(\"%d%d\", &ta, &tb);\n        add(ta, tb, 1, i + 1);\n        add(tb, ta, 0, i + 1);\n        g[ta][tb] = 1;\n    }\n    scanf(\"%d%d\", &src, &sink);\n}\nint main()\n{\n    while(scanf(\"%d%d\", &n, &m) != EOF)\n    {\n        read();\n        int ret = maxflow();\n        memset(dele, 0, sizeof(dele));\n        for(int i = 0; i < e_cnt; i+= 2)\n        {\n            int ta = edg[i].from, tb = edg[i].v;\n            if(edg[i].flow == 0 && g[ta][tb])\n                dele[edg[i].id] = 1;\n        }\n        for(int i = 0; i < e_cnt; ++i)\n        {\n            if(!dele[edg[i].id])\n            {\n                edg[i].flow = 1;\n                //printf(\"%d %d  %d\\n\", edg[i].id, edg[i].from, edg[i].v);\n            }\n        }\n        ret += maxflow();\n\n        vector<int> ans;\n        for(int i = 0; i < e_cnt; ++i)\n        {\n            int ta = edg[i].from, tb = edg[i].v;\n            if(!dele[edg[i].id] && edg[i].flow == 0 && !g[ta][tb])\n            {\n                if(find(ans.begin(), ans.end(), edg[i].id) == ans.end())  ans.push_back(edg[i].id);\n            }\n        }\n        printf(\"%d\\n\", ret);\n        printf(\"%d\\n\", ans.size());\n        for(int i = 0; i < ans.size(); ++i)\n            printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //s??????????????¢\n\t\tint iter[MAX_V]; //???????????§??????????????£??????\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<Edge> G[MAX_V];\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tint g[305][305] = {{0}};\n\tFlow flow;\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a][b] = i + 1;\n\t\tflow.addEdge(a,b,1);\n\t\tflow.addEdge(b,a,1);\n\t}\n\n\tint s, t;\n\tcin >> s >> t;\n\ts--; t--;\n\tcout << flow.fordFulkerson(s,t) << endl;\n\n\tset<int> v;\n\trep(i,n){\n\t\tfor(auto j : flow.G[i]){\n\t\t\tif(j.cap == 0 && g[i][j.to] == 0){\n\t\t\t\tv.emplace(g[j.to][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << v.size() << endl;\n\tfor(auto i : v){\n\t\tcout << i  << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V), iter(V){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    fill(level.begin(), level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(iter.begin(), iter.end(), 0);\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cap,rev,num,add;\n\tEdge(){}\n\tEdge(int s, int d, int cp, int r, int n, int a)\n\t\t:src(s),dst(d),cap(cp),rev(r),num(n), add(a)\n\t{}\n};\n\nconst int INF = (1<<28);\n\ntypedef vector<vector<Edge> > Graph;\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=e.cap;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tgraph[p][i].cap -= f;\n\t\t\tgraph[next][e.rev].cap += f;\n\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\t\t\t\tif(level[e.dst]!=-1) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.dst]=level[n]+1;\n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int d, int c, int n, int a, Graph& g)\n{\n\tg[s].push_back(Edge(s,d,c,g[d].size()  , n, 0));\n\tg[d].push_back(Edge(d,s,c,g[s].size()-1, n, 1)); \n}\n\nint main()\n{\n\tint N,M,S,T;\n\tcin >> N >> M;\n\n\tGraph g(N);\n\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tadd_edge(s-1, t-1, 1, i, 0, g);\n\t}\n\n\tcin >> S >> T;\n\tcout << dinic(S-1,T-1,g) << endl;\n\n\tvector<int> res;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<g[i].size(); j++)\n\t{\n\t\tif(g[i][j].add == 1 && g[i][j].cap == 0)\n\t\t\tres.push_back(g[i][j].num);\n\t}\n\n\tcout << res.size() << endl;\n\tfor(int i=0; i<res.size(); i++)\n\t\tcout << res[i] + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n// #define int long long\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000               // 2e9\n#define LLINF 2000000000000000000ll  // 2e18 (llmax:9e18)\n#define fi first\n#define sec second\n#define all(x) (x).begin(), (x).end()\n#define sq(x) ((x) * (x))\n#define dmp(x) cerr << #x << \": \" << x << endl;\n\ntemplate <class T>\nvoid chmin(T &a, const T &b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\nvoid chmax(T &a, const T &b) {\n  if (a < b) a = b;\n}\n\ntemplate <class T>\nusing MaxHeap = priority_queue<T>;\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nvector<T> vect(int len, T elem) {\n  return vector<T>(len, elem);\n}\n\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.fi << ',' << p.sec;\n  return os;\n}\ntemplate <class T, class U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.fi >> p.sec;\n  return is;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) {\n    os << vec[i];\n    if (i + 1 < vec.size()) os << ' ';\n  }\n  return os;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) is >> vec[i];\n  return is;\n}\nvoid fastio() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n}\n\n#define endl \"\\n\"\n\nstruct edge {\n  int to, cap, rev, id;\n  edge(int to, int cap, int rev, int id) : to(to), cap(cap), rev(rev), id(id) {}\n};\nvector<vector<edge>> G;\nvector<bool> used;\nvoid add_edge(int from, int to, int cap, int id) {\n  G[from].pb(edge(to, cap, G[to].size(), id));\n  G[to].pb(edge(from, cap, G[from].size() - 1, -1 - id));\n}\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] && e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s, int t) {\n  int flow = 0;\n  for (;;) {\n    for (int i = 0; i < used.size(); i++) used[i] = false;\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nvoid solve() {\n  int N, M;\n  cin >> N >> M;\n  G.resize(N);\n  for (int i = 0; i < N; i++) G[i].clear();\n  used.assign(N, false);\n  for (int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    add_edge(a, b, 1, i);\n  }\n  int S, T;\n  cin >> S >> T;\n  S--;\n  T--;\n  int f = max_flow(S, T);\n  vector<int> ans;\n  for (int i = 0; i < N; i++) {\n    for (const edge &e : G[i]) {\n      if (e.cap == 0 && e.id < 0) { ans.push_back(-e.id - 1); }\n    }\n  }\n  cout << f << endl;\n  cout << ans.size() << endl;\n  for (int i = 0; i < ans.size(); i++) { cout << ans[i] + 1 << endl; }\n  return;\n}\n\nsigned main() {\n  fastio();\n  solve();\n  // int t; cin >> t; while(t--)solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int to, cap, rev; };\nint V, E, S, T, c[309][309]; vector<int> used; vector<vector<edge> > G;\nvoid add_edge(int v1, int v2, int cap) {\n\tG[v1].push_back(edge{ v2, cap, (int)G[v2].size() });\n\tG[v2].push_back(edge{ v1, 0, (int)G[v1].size() - 1 });\n}\nint rec(int p, int t, int f) {\n\tif (p == t) return f;\n\tused[p] = 1;\n\tfor (auto &e : G[p]) {\n\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\tint res = rec(e.to, t, min(e.cap, f));\n\t\tif (res) {\n\t\t\tc[p][e.to]++;\n\t\t\te.cap -= res, G[e.to][e.rev].cap += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint ret = 0;\n\twhile (true) {\n\t\tused = vector<int>(V, 0);\n\t\tint res = rec(s, t, 2147483647);\n\t\tif (!res) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> V >> E; G.resize(V);\n\tvector<int> x1(E), x2(E);\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x1[i] >> x2[i]; x1[i]--, x2[i]--;\n\t\tadd_edge(x1[i], x2[i], 1);\n\t\tadd_edge(x2[i], x1[i], 1);\n\t}\n\tcin >> S >> T; S--, T--;\n\tcout << max_flow(S, T) << endl;\n\tint ret = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) ret++;\n\t}\n\tcout << ret << endl;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n\nusing namespace std;\n#define inf  1000000\nint MIN(int a,int b){return a<b?a:b;}\n#define N 700\n#define M 4000\nstruct node\n{\n    int e,first[N],next[M],v[M],w[M],f[M];\n    void init(int n){fill(first,first+n+10,-1);e=0;}\n    void add_edge(int a,int b,int c,int index)\n    {\n        v[e]=b;w[e]=c;next[e]=first[a];first[a]=e++;f[e]=index;\n        v[e]=a;w[e]=0;next[e]=first[b];first[b]=e++;f[e]=index;\n    }\n}T;\nint n,m,s,t;\nint h[N],gap[N];\nint sap_gap(int u,int f)\n{\n    if(u==t) return f;\n    int minh=n-1,l=f,d;\n    for(int i=T.first[u];i!=-1;i=T.next[i])\n        if(T.w[i])\n        {\n            if(h[T.v[i]]+1==h[u])\n            {\n                d=sap_gap(T.v[i],MIN(T.w[i],l));\n                T.w[i]-=d;T.w[i^1]+=d;l-=d;\n                if(h[s]>=n)  return f-l;\n                if(!l) break;\n            }\n            minh=MIN(minh,h[T.v[i]]);\n        }\n    if(l==f)\n    {\n        if(--gap[h[u]]==0) h[s]=n;\n        gap[h[u]=minh+1]++;\n    }\n    return f-l;\n}\nint isap(int source,int sink)\n{\n    int flow=0;\n    s=source;t=sink;\n    fill(h,h+n+1,0);\n    fill(gap,gap+n+1,0);\n    gap[source]=n;\n    while(h[source]<n)\n        flow+=sap_gap(source,inf);\n    return flow;\n}\nint maze[N][N];\nint visit[M],fa[M];\nint main() {\n    //freopen(\"in\",\"r\",stdin);\n    //freopen(\"out\",\"w\",stdout);\n    while(~scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n        memset(maze,0,sizeof(maze));\n        memset(fa,0,sizeof(fa));\n        memset(visit,0,sizeof(visit));\n        T.init(2*n);\n        int i,j,a,b;\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            maze[b][a]=i;\n            T.add_edge(b+n,a,1,1);\n            T.add_edge(a+n,b,1,1);\n        }\n        for(i=1;i<=n;i++) T.add_edge(i,i+n,inf,0);\n        scanf(\"%d%d\",&s,&t);\n        t=t+n;\n        int tot=n;\n        n=n*2;\n        printf(\"%d\\n\",isap(s,t));\n        for(i=tot+1;i<=n;i++)\n        {\n            for(j=T.first[i];j!=-1;j=T.next[j])\n            {\n                if(T.v[j]<=tot&&T.w[j]==0)\n                {\n                    visit[maze[i-tot][T.v[j]]]=1;\n                }\n            }\n        }\n        int num=0;\n        for(i=1;i<=m;i++) if(visit[i]) num++;\n        printf(\"%d\\n\",num);\n        for(i=1;i<=m;i++)\n            if(visit[i]) printf(\"%d\\n\",i);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<stdlib.h>\n#include<ctype.h>\n#include<queue>\n#include<bitset>\n#include<deque>\n#include<set>\n#include<time.h>\n#include<math.h>\n#include<sstream>\n#include<functional>\n#include<stack>\n#include<map>\n#include<vector>\nusing namespace std;\n\n#define LL long long\nint Map[309][309],dg[309];\nstruct node{\n\tint cnt;\n\tint id;\n\tint bid;\n\tint path[309];\n};\nint vis[1009],pp[1009];\nvoid coppy(node &tmp,node st){\n\ttmp.cnt=st.cnt;\n\tfor(int i=0;i<st.cnt;i++)\n\t\ttmp.path[i]=st.path[i];\n}\nint main()\n{\n\t\n\tint n,m;\n\tint u,v,s,t;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(Map,0,sizeof(Map));\n\t\tint cnt=1;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tMap[u][v]=cnt++;\n\t\t}\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tqueue<node>qu;\n\t\twhile(!qu.empty())\n\t\t\tqu.pop();\n\t\tnode st;\n\t\tst.id = s;\n\t\tst.bid=st.cnt=0;\n\t\tqu.push(st);\n\n\t\tint anscnt=0,fans=0;\n\t\twhile(!qu.empty()){\n\t\t\tst = qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tif(st.id == t){\n\t\t\t\tfans++;\n\t\t\t\tfor(int i=0;i<st.cnt;i++)\n\t\t\t\t\tpp[anscnt++]=st.path[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(vis[st.bid])\n\t\t\t\tcontinue;\n\t\t\tvis[st.bid]=1;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\n\t\t\t\tif(Map[st.id][i])\n\t\t\t\t{\n\t\t\t\t\tnode tmp ;\n\t\t\t\t\tcoppy(tmp,st);\n\t\t\t\t\ttmp.id=i;\n\t\t\t\t\ttmp.bid = Map[st.id][i];\n\t\t\t\t\t//vis[i]=1;\n\t\t\t\t\tqu.push(tmp);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(Map[i][st.id]){\n\t\t\t\t\tnode tmp;\n\t\t\t\t\tcoppy(tmp,st);\n\t\t\t\t\t//vis[i]=1;\n\t\t\t\t\ttmp.id=i;\n\t\t\t\t\ttmp.bid = Map[st.id][i];\n\t\t\t\t\ttmp.path[tmp.cnt++]= Map[i][st.id];\n\t\t\t\t\tqu.push(tmp);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n%d\\n\",fans,anscnt);\n\t\tsort(pp,pp+anscnt);\n\t\tfor(int i=0;i<anscnt;i++){\n\t\t\tprintf(\"%d\\n\",pp[i]);\n\t\t}\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef int Weight;\nstruct Edge {\n\tint s, d;\n\tWeight w;\n\tEdge(int s, int d, Weight w) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &o)const {\n\t\treturn w != o.w ? w > o.w : s != o.s ? s < o.s : d < o.d;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n#define EACH(it,c) for(auto it=c.begin();it!=c.end();it++)\nWeight augment(const Graph &g, const Matrix &capacity, Matrix &flow, const vi &level, vector<bool> &finished, int u, int t, Weight cur) {\n\tif(u == t || cur == 0) {\n\t\treturn cur;\n\t}\n\tif(finished[u]) {\n\t\treturn 0;\n\t}\n\tfinished[u] = true;\n\tEACH(e, g[u]) {\n\t\tif(level[e->d] > level[u]) {\n\t\t\tWeight f = augment(g, capacity, flow, level, finished, e->d, t, min(cur, RESIDUE(u, e->d)));\n\t\t\tif(f > 0) {\n\t\t\t\tflow[u][e->d] += f;\n\t\t\t\tflow[e->d][u] -= f;\n\t\t\t\tfinished[u];\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nWeight maximumFlow(const Graph &g, int s, int t, Matrix &flow) {\n\tint n = g.size();\n\tMatrix capacity(n, Array(n));\n\tREP(u, n) {\n\t\tEACH(e, g[u]) {\n\t\t\tcapacity[e->s][e->d] += e->w;\n\t\t}\n\t}\n\tWeight total = 0;\n\tbool cont = true;\n\twhile(cont) {\n\t\tcont = false;\n\t\tvi level(n, -1);\n\t\tlevel[s] = 0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\tfor(int d = n; !Q.empty() && level[Q.front()] < d; ) {\n\t\t\tint u = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(u == t) {\n\t\t\t\td = level[u];\n\t\t\t}\n\t\t\tEACH(e, g[u]) {\n\t\t\t\tif(RESIDUE(u, e->d) > 0 && level[e->d] == -1) {\n\t\t\t\t\tQ.push(e->d);\n\t\t\t\t\tlevel[e->d] = level[u] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> finished(n);\n\t\tfor(Weight f = 1; f > 0; ) {\n\t\t\tf = augment(g, capacity, flow, level, finished, s, t, INF);\n\t\t\tif(f == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal += f;\n\t\t\tcont = true;\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvi X(M), Y(M);\n\tGraph o(N, Edges()), c(N, Edges());\n\tREP(i, M) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--;\n\t\tY[i]--;\n\t\to[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[Y[i]].push_back(Edge(Y[i], X[i], 1));\n\t}\n\n\tint S, T;\n\tcin >> S >> T;\n\tS--;\n\tT--;\n\tMatrix flow(N, Array(N, 0));\n\tWeight maxFlow = maximumFlow(c, S, T, flow);\n\tcout << maxFlow << endl;\n\tvi reversedRoads;\n\tREP(i, M) {\n\t\tif(flow[Y[i]][X[i]] > 0) {\n\t\t\treversedRoads.push_back(i+1);\n\t\t}\n\t}\n\tint size = reversedRoads.size();\n\tcout << size << endl;\n\tREP(i, size) {\n\t\tcout << reversedRoads[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  \n  int A[1001],B[1001];\n  for(int i=0,a,b;i<m;i++){\n    cin>>A[i]>>B[i];\n    add_edge(A[i],B[i],1);\n    add_edge(B[i],A[i],1);\n  }\n  int s,t;\n  cin>>s>>t;\n  cout <<max_flow(s,t)<<endl;\n\n  vector<int> ans;  \n  for(int i=0;i<m;i++){\n    int a=A[i],b=B[i];\n    int flg=0;\n    for(int j=0;j<G[a].size();j++)\n      if(G[a][j].to==b&&G[a][j].cap>=1)flg=1;\n    if(flg) ans.push_back(i+1);\n  }\n\n  cout <<ans.size()<<endl;\n  for(int i=0;i<ans.size();i++)cout<<ans[i]<<endl;\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nclass max_flow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tmax_flow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tint add(int from, int to, int cap) {\n        int idx=G[from].size();\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n        return idx;\n\t}\n\tint dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n    int revcap(int from,int idx){\n        return G[from][idx].cap;\n    }\n};\n\nstruct Edge{\n    int from,to,cap,idx;\n    Edge(int from,int to, int cap, int idx):from(from),to(to),cap(cap),idx(idx){}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;cin>>n>>m;\n    max_flow mf(n);\n    vector<Edge> es;\n    for(int i=0;i<m;i++){\n        int x,y;cin>>x>>y;\n        x--;y--;\n        int idx;\n        mf.add(x,y,1);\n        idx = mf.add(y,x,1);\n        es.push_back(Edge(y,x,1,idx));\n    }\n    int st,gt;cin>>st>>gt;\n    st--;gt--;\n    cout<<mf.dinic(st,gt)<<endl;\n    vector<int> res;\n    for(int i=0;i<m;i++){\n        if(mf.revcap(es[i].from, es[i].idx)<es[i].cap) res.push_back(i+1);\n    }\n    int sz=res.size();\n    cout<<sz<<endl;\n    for(int i=0;i<sz;i++) cout<<res[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ntemplate<class T>\nstruct AdjMatrix:public vector< vector<T> >{\n\tAdjMatrix(int n,const vector<T> &v=vector<T>()):vector< vector<T> >(n,v){}\n};\n\ntemplate<class T>\nT augment(const AdjMatrix<T> &capa,int src,int snk,AdjMatrix<T> &flow){\n\tint n=capa.size();\n\tvector<int> parent(n,-1); parent[src]=-2;\n\n\tT water=0;\n\tqueue< pair<T,int> > qu; qu.push(make_pair(INF,src));\n\twhile(!qu.empty()){\n\t\tpair<T,int> a=qu.front(); qu.pop();\n\t\tint u=a.second;\n\t\tT w=a.first;\n\t\tif(u==snk){ water=w; break; }\n\t\trep(v,n) if(parent[v]==-1 && capa[u][v]-flow[u][v]>0) {\n\t\t\tqu.push(make_pair(min(w,capa[u][v]-flow[u][v]),v));\n\t\t\tparent[v]=u;\n\t\t}\n\t}\n\n\tif(water==0) return 0;\n\n\tfor(int v=snk,u=parent[snk];v!=src;v=u,u=parent[u]){\n\t\tflow[u][v]+=water;\n\t\tflow[v][u]-=water;\n\t}\n\n\treturn water;\n}\n\ntemplate<class T>\nT FordFulkerson(const AdjMatrix<T> &capa,int src,int snk,AdjMatrix<T> &flow){\n\tint n=capa.size();\n\n\tT ans=0;\n\twhile(1){\n\t\tT water=augment(capa,src,snk,flow);\n\t\tif(water==0) break;\n\t\t// if(water<EPS) break;\n\t\tans+=water;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic pair<bool,int> adj[300][300];\n\tAdjMatrix<int> capa(n,vector<int>(n));\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tadj[u][v]=make_pair(true,i);\n\t\tcapa[u][v]=capa[v][u]=1;\n\t}\n\tint s,t; scanf(\"%d%d\",&s,&t); s--; t--;\n\n\tint cnt=0;\n\tAdjMatrix<int> flow(n,vector<int>(n));\n\tint amount=FordFulkerson(capa,s,t,flow);\n\trep(u,n) rep(v,n) {\n\t\tif(adj[u][v].first && flow[v][u]>0) cnt++;\n\t}\n\tprintf(\"%d\\n%d\\n\",amount,cnt);\n\trep(u,n) rep(v,n) {\n\t\tif(adj[u][v].first && flow[v][u]>0) printf(\"%d\\n\",adj[u][v].second+1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nstruct edge{ int to,cap,rev,id;};\nvector<edge> G[100010];\nbool used[100010];\n\nvoid add_edge(int from ,int to, int cap,int id){\n \tG[from].push_back((edge){to,cap,(ll)G[to].size(),id});\n \tG[to].push_back((edge){from,0,(ll)G[from].size()-1,id});\n}\n\nint ddfs(int v,int t,int f){\nif(v==t) return f;\nused[v]=true;\nfor(int i=0;i<G[v].size();i++){\nedge &e=G[v][i];\nif(!used[e.to] && e.cap>0){\nint d=ddfs(e.to,t,min(f,e.cap));\nif(d>0){\ne.cap -=d;\nG[e.to][e.rev].cap +=d;\nreturn d;\n}\n}\n}\nreturn 0;\n}\n\nint max_flow(int s ,int t){\nint flow=0;\nfor(;;){\nmemset(used,0,sizeof(used));\nint f =ddfs(s,t,inf);\nif(f==0) return flow;\nflow +=f;\n}\n}\nvector<pa> ve;\nvector<int> ans;\nint a[1100]={0};\n     signed main(){\nint n,m;\n     \tcin>>n>>m;\n     \tve.pb(mp(0,0));\n     \tfor(int i=1;i<=m;i++){\n     \t\tint y,yy;\n     \t\tcin>>y>>yy;\n     \t\tadd_edge(y,yy,1,i*2-1);\n     \t\tadd_edge(yy,y,1,i*2);\n     \t\tve.pb(mp(y,yy));\n     \t\tve.pb(mp(yy,y));\n     \t}\n     \tint s,t;\n     \tcin>>s>>t;\n     \tcout<<max_flow(s,t)<<endl;\n     \tfor(int i=1;i<=n;i++){\n     \t\tfor(auto v:G[i]){\n     //\t\t\tcout<<i<<\" \"<<v.to<<\" \"<<v.cap<<\" \"<<v.id<<endl;\n     \t\t\tif(i==ve[v.id].first && v.to==ve[v.id].second && v.cap==(v.id%2?0:1) )a[(v.id+1)/2]++;\n     \t\t\tif(v.to==ve[v.id].first && i==ve[v.id].second && v.cap==(v.id%2?1:0) )a[(v.id+1)/2]++;\n     \t\t}\n     \t}\n     \tfor(int i=1;i<m+1;i++){\n     //\t\tcout<<a[i]<<endl;\n     \t\tif(a[i]==0) ans.pb(i);\n     \t}\n     \tcout<<ans.size()<<endl;\n     \tfor(auto v:ans) cout<<v<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 301,M = N*(N-1)*2;\nint n,m;\nint hd[N],nx[M],to[M],cap[M],ect;\n\ninline void addEdge(int u,int v,int c)\n{\n    nx[ect] = hd[u];\n    to[ect] = v;\n    cap[ect] = c;\n    hd[u] = ect++;\n}\n\ninline void AddEdge(int u,int v,int c)\n{\n    addEdge(u,v,c);\n    addEdge(v,u,0);\n}\n\nint S,T;\nint vis[N],clk;\nint lv[N],q[N];\nint cur[N];\n\nbool bfs()\n{\n    int l = 0,r = 0;\n    clk++;\n    q[r++] = S; vis[S] = clk; lv[S] = 0;\n    while(l<r){\n        int u = q[l++];\n        for(int i = hd[u]; ~i; i = nx[i]){\n            int v = to[i];\n            if(vis[v] != clk && cap[i]>0){\n                vis[v] = clk;\n                lv[v] = lv[u]+1;\n                q[r++] = v;\n            }\n        }\n    }\n    return vis[T] == clk;\n}\n\nint aug(int u,int a)\n{\n    if(u == T||!a) return a;\n    int flow = 0,f;\n    for(int &i = cur[u]; ~i; i = nx[i]){\n        int v = to[i];\n        if(lv[v] == lv[u]+1 && (f = aug(v,min(cap[i],a)))>0){\n            cap[i] -= f; cap[i^1] += f;\n            a -= f; flow += f;\n            if(!a) break;\n        }\n    }\n    return flow;\n}\nconst int INF = 0x3f3f3f3f;\nint MaxFlow()\n{\n    int flow = 0;\n    while(bfs()){\n        memcpy(cur,hd,sizeof(hd));\n        flow += aug(S,INF);\n    }\n    return flow;\n}\n\n//#define LOCAL\nint main()\n{\n#ifdef LOCAL\n    freopen(\"in.txt\",\"r\",stdin);\n#endif\n    scanf(\"%d%d\",&n,&m);\n    memset(hd,-1,sizeof(hd));\n    for(int i = 0; i < m; i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        AddEdge(u,v,1);\n        AddEdge(v,u,1);\n    }\n    scanf(\"%d%d\",&S,&T);\n    printf(\"%d\\n\",MaxFlow());\n    vector<int> ans;\n    for(int i = 0,mi = m*4; i < mi; i += 4){\n        if(cap[i+3] > 0){\n            ans.push_back(i/4+1);\n        }\n    }\n    printf(\"%d\",(int)ans.size());\n    for(int i = 0; i < (int)ans.size(); i++){\n        printf(\"\\n%d\",ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#include<map>\n#include<stack>\n#include<string>\n#include<bitset>\n#define LL long long\n\nconst int MAXN=707;\nconst int MAXM=0;\nconst long long LLINF=9000000000000000000;\nconst int INF=1000000000;//careful because of floyed and so on\nconst int MOD=1000000007;\ndouble eps=0.00000001;\n\nusing namespace std;\n\nstruct Edge{\n    int from,to,cap,flow,cost,id;\n};\n\nint n,m;\nint S,T;\nvector<int>G[MAXN];\nvector<Edge>edges;\nbool inq[MAXN];\nint p[MAXN];\nint a[MAXN];\nint d[MAXN];\nbool ans[MAXN];\n\nvoid mcmf_clear(){\n    edges.clear();\n    for (int i=0;i<MAXN;i++) G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap,int cost,int id){\n    edges.push_back((Edge){from,to,cap,0,cost,id});\n    edges.push_back((Edge){to,from,0,0,-cost,id});\n    int sz=edges.size();\n    G[from].push_back(sz-2);\n    G[to].push_back(sz-1);\n}\n\nbool bellman_ford(int& flow,long long& cost){\n    for (int i=0;i<MAXN;i++) d[i]=INF;\n    memset(inq,0,sizeof(inq));\n    d[S]=0;\n    inq[S]=1;\n    p[S]=0;\n    a[S]=INF;\n    queue<int>Q;\n    while (!Q.empty())Q.pop();\n    Q.push(S);\n    while (!Q.empty()){\n            int u=Q.front();\n            Q.pop();\n            inq[u]=0;\n            for(int i=0;i<(int)G[u].size();i++){\n                    Edge& e=edges[G[u][i]];\n                    if (e.cap>e.flow && d[e.to]>d[u]+e.cost){\n                            d[e.to]=d[u]+e.cost;\n                            p[e.to]=G[u][i];\n                            a[e.to]=min(a[u],e.cap-e.flow);\n                            if (!inq[e.to]){\n                                    Q.push(e.to);\n                                    inq[e.to]=1;\n                            }\n                    }\n            }\n    }\n    if (d[T]==INF) return false;\n    flow+=a[T];\n    cost+=(long long)d[T]*(long long)a[T];\n    for (int u=T;u!=S;u=edges[p[u]].from){\n            edges[p[u]].flow+=a[T];\n            edges[p[u]^1].flow-=a[T];\n    }\n    return true;\n}\n\nint mincost_maxflow(long long& cost){\n    int flow=0;\n    cost=0;\n    while (bellman_ford(flow,cost));\n    return flow;\n}\n\nint main(){\n    while (scanf(\"%d%d\",&n,&m)==2){\n            mcmf_clear();\n            memset(ans,0,sizeof(ans));\n            for (int i=1;i<=m;i++){\n                    int x,y;\n                    scanf(\"%d%d\",&x,&y);\n                    add_edge(x,y,1,0,i);\n                    add_edge(y,x,1,1,i);\n            }\n            scanf(\"%d%d\",&S,&T);\n            int maxflow;\n            long long mincost;\n            maxflow=mincost_maxflow(mincost);\n            printf(\"%d\\n%lld\\n\",maxflow,mincost);\n            for (int i=0;i<(int)edges.size();i++){\n                    Edge e=edges[i];\n                    if (e.cost>0 && e.flow>0) ans[e.id]=1;\n            }\n            for (int i=1;i<=n;i++){\n                    if (ans[i]) printf(\"%d\\n\",i);\n            }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev, isr;\n};\n\nvector<Edge>G[309]; bool used[309]; int N, M, A[1009], B[1009];\n\nvoid add_edge(int u, int v, int c) {\n\tG[u].push_back(Edge{ v,c,(int)G[v].size(),0 });\n\tG[v].push_back(Edge{ u,0,(int)G[u].size() - 1,1 });\n}\nint dfs(int pos, int to, int fl) {\n\tif (pos == to) return fl;\n\tused[pos] = true;\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tint t = G[pos][i].to;\n\t\tif (used[t] == true || G[pos][i].cap == 0) continue;\n\n\t\tint V = dfs(t, to, min(fl, G[pos][i].cap)); if (V == 0) continue;\n\n\t\tG[pos][i].cap -= V;\n\t\tG[t][G[pos][i].rev].cap += V;\n\t\treturn V;\n\t}\n\treturn 0;\n}\nint max_flow(int u, int v) {\n\tint flow = 0;\n\twhile (true) {\n\t\tfor (int i = 1; i <= N; i++) used[i] = false;\n\t\tint GG = dfs(u, v, 1000000007);\n\t\tif (GG == 0) break;\n\t\tflow += GG;\n\t}\n\treturn flow;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tadd_edge(A[i], B[i], 1);\n\t\tadd_edge(B[i], A[i], 1);\n\t}\n\tint S, T; cin >> S >> T;\n\n\tint I = max_flow(S, T); vector<int>vec;\n\tfor (int i = 1; i <= M; i++) {\n\t\tint T1 = 0, T2 = 0;\n\t\tfor (int j = 0; j < G[A[i]].size(); j++) {\n\t\t\tif (G[A[i]][j].to == B[i] && G[A[i]][j].isr == 0) { T1 = G[A[i]][j].cap; }\n\t\t}\n\t\tfor (int j = 0; j < G[B[i]].size(); j++) {\n\t\t\tif (G[B[i]][j].to == A[i] && G[B[i]][j].isr == 0) { T2 = G[B[i]][j].cap; }\n\t\t}\n\t\tif (T1 > T2) vec.push_back(i);\n\t}\n\tcout << I << endl;\n\tcout << vec.size() << endl;\n\tfor (int i = 0; i < vec.size(); i++) cout << vec[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define MAX_V 300\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];  //??°???????????????\nint level[MAX_V];       //?§??????????????????¢\nint iter[MAX_V];        //???????????§????????????\n\n// from??????to?????????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(  (edge){ to  ,cap,(int)G[to  ].size()   }  );\n\tG[to  ].push_back(  (edge){ from,0  ,(int)G[from].size()-1 }  );\n}\n\n// s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s){\n\trep(i,MAX_V)level[i]=-1;\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();que.pop();\n\t\t\n\t\trep(i,G[v].size()){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s,int t){\n\tif(s==t)return INF;\n\tint flow=0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tvector<vector<int>> d(n,vector<int>(n,-1));\n\t\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\td[b][a]=i+1;\n\t\tadd_edge(a,b,1);\n\t\tadd_edge(b,a,1);\n\t}\n\t\n\tint s,t;\n\tcin>>s>>t;\n\ts--,t--;\n\t\n\tvector<edge> Gt[MAX_V];\n\trep(i,MAX_V)Gt[i] = G[i];\n\t\n\tint res = max_flow(s,t);\n\t\n\tset<int> ans;\n\trep(i,MAX_V){\n\t\trep(j,G[i].size()){\n\t\t\tif(Gt[i][j].cap==1&&G[i][j].cap==0){\n\t\t\t\tif(d[i][G[i][j].to]!=-1)ans.insert(d[i][G[i][j].to]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\tcout<<ans.size()<<endl;\n\n\tfor(auto &elm:ans){\n\t\tcout<<elm<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst int NN=50*50*2+1;\n\nstruct edge\n{\n\tint s;\n\tint t;\n\tint st;\n\tint ts;\n\tint init;\n\tint nex(int a){\n\t\treturn a==s?t:s;\n\t}\n\tint res(int a){\n\t\treturn a==s?st:ts;\n\t}\n\tvoid use(int a, int v){\n\t\tif(a==s){\n\t\t\tst-=v;\n\t\t\tts+=v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tst+=v;\n\t\t\tts-=v;\n\t\t}\n\t}\n};\ntypedef vector<edge*>::iterator It;\ntemplate<int NN, int MM>\nstruct MaxFlow\n{\n\tedge es[MM];\n\tint esize;\n\tvector<edge*> edges[NN];\n\tvoid add(int a, int b, int v)\n\t{\n\t\tes[esize].s=a;\n\t\tes[esize].t=b;\n\t\tes[esize].st=v;\n\t\tes[esize].ts=v;\n\t\tes[esize].init=v;\n\t\tedges[a].push_back(es+esize);\n\t\tedges[b].push_back(es+esize);\n\t\tesize++;\n\t}\n\tedge* pre[NN];\n\tint done[NN];\n\tint q[NN];\n\tint s;\n\tint t;\n\tint flow()\n\t{\n\tint ret=0;\n\tint f=0;\n\twhile(1){\n\t\tf++;\n\t\tint qs=0;\n\t\tint qe=1;\n\t\tq[0]=s;\n\t\tdone[s]=f;\n\t\twhile(qs<qe){\n\t\t\tint top=q[qs++];\n\t\t\tfor(It it=edges[top].begin();it!=edges[top].end();it++){\n\t\t\t\tint nex=(*it)->nex(top);\n\t\t\t\tif((*it)->res(top)&&done[nex]!=f){\n\t\t\t\t\tq[qe++]=nex;\n\t\t\t\t\tpre[nex]=*it;\n\t\t\t\t\tdone[nex]=f;\n\t\t\t\t\tif(nex==t){\n\t\t\t\t\t\tgoto OK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\nOK:\n\t\tint p=t;\n\t\tint res=INT_MAX;\n\t\twhile(p!=s){\n\t\t\tint pp=pre[p]->nex(p);\n\t\t\tres=min(res,pre[p]->res(pp));\n\t\t\tp=pp;\n\t\t}\n\t\tp=t;\n\t\twhile(p!=s){\n\t\t\tint pp=pre[p]->nex(p);\n\t\t\tpre[p]->use(pp,res);\n\t\t\tp=pp;\n\t\t}\n\t\tret+=res;\n\t}\n\treturn ret;\n\t}\n};\n\nMaxFlow<300, 1000> mf;\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tfor(int i=0;i<M;i++){\n\t\tint X,Y;\n\t\tcin >> X >> Y;\n\t\tmf.add(X,Y,1);\n\t}\n\tcin >> mf.s >> mf.t;\n\tcout << mf.flow() << endl;\n\tint rev=0;\n\tfor(int i=0;i<mf.esize;i++){\n\t\tif(mf.es[i].st>mf.es[i].init){\n\t\t\trev++;\n\t\t}\n\t}\n\tcout << rev << endl;\n\tfor(int i=0;i<mf.esize;i++){\n\t\tif(mf.es[i].st>mf.es[i].init){\n\t\t\tcout << i+1<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    //level.clear(); level.resize(G.size(), -1);\n    fill(level.begin(), level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //iter.clear(); iter.resize(G.size(), 0);\n      fill(iter.begin(), iter.end(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    rep(i, dinic.G[v].size()) {\n      edge& e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  rep(i, used_rev.size()) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Teletubbies\n * Created Time:  2012年08月29日 星期三 12&#26102;39分28秒\n * File Name: e.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <time.h>\n#include <cctype>\n#include <functional>\n#include <deque>\n#include <iomanip>\n#include <bitset>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#include <utility>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORD(i,a,b) for (int i=(a); i>=(b); i--)\n#define REP(i,b) FOR(i,0,b)\n#define sf scanf\n#define pf printf\nusing namespace std;\nconst int maxint = -1u>>1;\nconst double pi = 3.14159265358979323;\nconst double eps = 1e-8;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<int>::iterator vit;\n#define maxn 310\n#define maxm 500000\nint eh[maxn], tot, cur[maxn];\nconst int inf = 1 << 30;\nint dist[maxn];\nint s, t;\nint n, m;\n\nstruct Edge {\n    int u, v, cap, flow, next;\n}et[maxm];\n\nvoid init() {\n    tot = 0;\n    memset(eh, -1, sizeof(eh));\n}\n\nvoid add(int u, int v, int cap, int flow) {\n    Edge e = {u, v, cap, flow, eh[u]};\n    et[tot] = e;\n    eh[u] = tot++;\n}\n\nvoid addedge(int u, int v, int cap) {\n    add(u, v, cap, 0), add(v, u, cap, 0);\n}\n    \nbool bfs() {\n    int que[maxn];\n    int head = 0, tail = 0;\n    memset(dist, -1, sizeof(dist));\n    dist[t] = 0;\n    que[tail++] = t;\n    while(head < tail && dist[s] == -1) {\n        int u = que[head++];\n        for(int i = eh[u]; i != -1; i = et[i].next) {\n            int v = et[i].v;\n            if(et[i^1].cap > et[i^1].flow && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                que[tail++] = v;\n            }\n        }\n    }\n    return dist[s] != -1;\n}\n\nint dfs(int u, int d) {\n    if(u == t) return d;\n    int l = d;\n    //cout << u << \"********\" <<  endl;\n    for(int &i = cur[u]; i != -1; i = et[i].next) {\n        int v = et[i].v;\n        if(et[i].cap > et[i].flow && dist[u] == dist[v] + 1) {\n            //cout << v << \" \" << d << endl;\n            int tmp = dfs(v, min(l, et[i].cap - et[i].flow));\n            //cout << v << \"tmp = \" << tmp << endl;\n            et[i].flow += tmp;\n            et[i^1].flow -= tmp;\n            l -= tmp;\n            if(l == 0) break;\n        }\n    }\n    //cout << d -  l << \"asdfads\" << endl;\n    return d - l;\n}\n\nint Dinic() {\n    int flow = 0;\n    while(bfs()) {\n        //cout << \"dist\" << endl;\n        //for(int i = 1; i <= n; i++) {\n            //cout << dist[i] << endl;\n        //}\n        for(int i = 1; i <= n; i++) cur[i] = eh[i];\n        flow += dfs(s, inf);\n    }\n    return flow;\n}\n\nint main() \n{\n    //freopen(\"in1.txt\", \"r\", stdin);\n    //freopen(\"E.out3\", \"w\", stdout);\n    \n    while(~scanf(\"%d%d\", &n, &m)) {\n        init();\n        int u, v;\n        for(int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &u, &v);\n            addedge(u, v, 1);\n            //cout << u << \" \" << v << endl;\n        }\n        scanf(\"%d%d\", &s, &t);\n        int ans = Dinic();\n        printf(\"%d\\n\", ans);\n        vector<int> vec;\n        vec.clear();\n        //cout << tot << endl;\n        for(int i = 0; i < tot; i += 2) {\n            //cout << et[i].u << \" \" << et[i].v << \" \" << et[i].flow << endl;\n            if(et[i].flow < 0) {\n                vec.pb(i / 2 + 1);\n            }\n        }\n        printf(\"%d\\n\", vec.size());\n        for(int i = 0; i < vec.size(); i++) {\n            printf(\"%d\\n\", vec[i]);\n        }\n        break;\n    }\n    \n    //while(1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\nstruct edge {int to,cap,rev,id;};\nconst int MAX_V=302,inf=500;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from, int to, int cap,int id){\n\tedge e1={to,cap,G[to].size(),id},e2={from,0,G[from].size(),-1};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t}\n}\nint main(){\n\tint n,m,x[300],y[300];\n\tcin >> n >> m;\n\tint s=0,t=n+1;\n\trep(i,m){\n\t\tcin >> x[i] >> y[i];\n\t\tadd_edge(x[i],y[i],1,-1);\n\t\tadd_edge(y[i],x[i],1,i);\n\t}\n\tint ss,tt;\n\tcin >> ss >> tt;\n\tadd_edge(s,ss,inf,-1);\n\tadd_edge(tt,t,inf,-1);\n\tcout << max_flow(s,t) << endl;\n\tbool ans[300]={};\n\trep1(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tedge e=G[i][j];\n\t\t\tif(e.id<0) continue;\n\t\t\tif(e.cap==0) ans[e.id]=true;\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,n) if(ans[i]) cnt++;\n\tcout << cnt << endl;\n\trep(i,n) if(ans[i]) cout << i+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nconst int maxm = 200005;\nconst int maxn = 200005;\nconst int inf = 0x7fffffff;\n\nstruct DINIC {\n\tint s, t, maxflow, tmp, tot;\n\tint eu[maxm], et[maxm], ef[maxm], ep[maxm];\n\tint d[maxn], a[maxn];\n\tbool v[maxn];\n\tqueue<int> q;\n\tvoid add(int x,int y,int c,int l) {\n\t\t++ tot;\n\t\tet[tot] = y;\n\t\teu[tot] = c;\n\t\tef[tot] = a[x];\n\t\ta[x] = tot;\n\t\tep[tot] = tot + l;\n\t}\n\n\tbool bfs() {\n\t\tmemset(d,0,sizeof d);\n\t\tmemset(v,0,sizeof v);\n\t\tq.push(s);\n\t\td[s] = 1;\n\t\twhile(!q.empty()) {\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i = a[now]; i; i = ef[i]) {\n\t\t\t\tif(eu[i]>0 && d[et[i]]==0) {\n\t\t\t\t\td[et[i]] = d[now] + 1;\n\t\t\t\t\tq.push(et[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d[t] != 0;\n\t}\n\n\tint dfs(int x, int y) {\n\t\tif(x == t) {\n\t\t\ttmp+=y;\n\t\t\treturn y;\n\t\t}\n\t\tv[x] = 1;\n\t\tint z = 0;\n\t\tfor(int i = a[x]; i; i = ef[i]) {\n\t\t\tif(eu[i]>0 && d[x]+1==d[et[i]] && y!=0 && !v[et[i]]) {\n\t\t\t\tint j = dfs(et[i], min(y, eu[i]));\n\t\t\t\tif(j) {\n\t\t\t\t\teu[i] -= j;\n\t\t\t\t\teu[ep[i]] += j;\n\t\t\t\t\tz += j;\n\t\t\t\t\ty -= j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}   \n\n\tvoid dinic() {\n\t\ttmp = 0;\n\t\twhile(bfs()) {\n\t\t\twhile(dfs(s, inf)) {\n\t\t\t\tmaxflow += tmp; \n\t\t\t\ttmp = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\ttot = 0;\n\t\tmaxflow = 0;\n\t\tmemset(a, 0, sizeof a);\n\t\tmemset(ef, 0, sizeof ef);\n\t}\n} flow;\n\nvoid make_graph() {\n\tint n,m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tflow.add(x, y, 1, 1);\n\t\tflow.add(y, x, 1, -1);\n\t}\n\tscanf(\"%d%d\", &flow.s, &flow.t);\n}\n\nint main() {\n\tint T;\n//\tscanf(\"%d\", &T);\n\t//while(T --) \n\t{\n\t\tmake_graph();\n\t\tflow.dinic();\n\t\tprintf(\"%d\\n\", flow.maxflow);\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= flow.tot; ++ i) {\n\t\t\tif(flow.eu[i] == 0 && i % 2 == 0) ans ++;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\tfor(int i = 1; i <= flow.tot; ++ i) {\n\t\t\tif(flow.eu[i] == 0 && i % 2 == 0) printf(\"%d\\n\", i/2);\n\t\t}\n\t\tflow.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nconst int MAXV = 333;\nclass FordFulkerson {\n\tprivate:\n\tstruct edge {int to, cap, rev;};\n\tvector<edge> g[MAXV];\n\tbool used[MAXV];\n\tpublic:\n\tbool gy[MAXV][MAXV];\n\t// fromからtoへ向かう要領capの辺をグラフに追加する\n\tvoid add_edge(int from, int to, int cap) {\n\t\tg[from].push_back((edge){to, cap, (int)g[to].size()});\n\t\tg[to].push_back((edge){from, 0, (int)g[from].size()-1});\n\t}\n\tvoid gyaku(int from, int to) {\n\t\tgy[from][to] = 1;\n\t}\n\t// 増加パスをdfsで探す\n\tint dfs(int v, int t, int f) {\n\t\tif (v==t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\tedge &e = g[v][i];\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\t\tif (d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t// sからtへの最大流を求める\n\tint getflow(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint f = dfs(s,t,(int)1e9+10);\n\t\t\tif (f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t// 行きの容量が0かつ逆辺の容量が1の辺のうち、与えられた辺と逆向きのものを列挙\n\tvi revs() {\n\t\tvi res;\n\t\trep(i,MAXV) rep(j,g[i].size()) {\n\t\t\tint fr = i, to = g[i][j].to;\n\t\t\tedge &x = g[i][j], &y = g[g[i][j].to][g[i][j].rev];\n\t\t\tif (x.cap==0 && y.cap==1 && gy[fr][to]) res.pb(to);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n, m, x, y, s, t;\nFordFulkerson ff;\n\nsigned main() {\n\tcin >> n >> m;\n\trep(i,m) {\n\t\tcin >> x >> y;\n\t\tff.add_edge(x,y,1), ff.add_edge(y,x,1);\n\t\tff.gyaku(y,x);\n\t}\n\tcin >> s >> t;\n\t\n\tint res = ff.getflow(s,t);\n\tcout << res << ln;\n\tvi ch = ff.revs();\n\tunq(ch);\n\tcout << ch.size() << ln;\n\trep(i,ch.size()) cout << ch[i] << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef int Weight;\nstruct Edge {\n\tint s, d;\n\tWeight w;\n\tEdge(int s, int d, Weight w) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &o)const {\n\t\treturn w != o.w ? w > o.w : s != o.s ? s < o.s : d < o.d;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n#define EACH(i,c) for(auto i=(c).begin();i!=(c).end();i++)\nWeight augment(const Graph &g, const Matrix &capacity, Matrix &flow, const vi &level, vector<bool> &finished, int u, int t, Weight cur) {\n\tif(u == t || cur == 0) {\n\t\treturn cur;\n\t}\n\tif(finished[u]) {\n\t\treturn 0;\n\t}\n\tfinished[u] = true;\n\tEACH(e, g[u]) {\n\t\tif(level[e->d] > level[u]) {\n\t\t\tWeight f = augment(g, capacity, flow, level, finished, e->d, t, min(cur, RESIDUE(u, e->d)));\n\t\t\tif(f > 0) {\n\t\t\t\tflow[u][e->d] += f;\n\t\t\t\tflow[e->d][u] -= f;\n\t\t\t\tfinished[u];\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nWeight maximumFlow(const Graph &g, int s, int t, Matrix &flow) {\n\tint n = g.size();\n\tMatrix capacity(n, Array(n));\n\tREP(u, n) {\n\t\tEACH(e, g[u]) {\n\t\t\tcapacity[e->s][e->d] += e->w;\n\t\t}\n\t}\n\tWeight total = 0;\n\tbool cont = true;\n\twhile(cont) {\n\t\tcont = false;\n\t\tvi level(n, -1);\n\t\tlevel[s] = 0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\tfor(int d = n; !Q.empty() && level[Q.front()] < d; ) {\n\t\t\tint u = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(u == t) {\n\t\t\t\td = level[u];\n\t\t\t}\n\t\t\tEACH(e, g[u]) {\n\t\t\t\tif(RESIDUE(u, e->d) > 0 && level[e->d] == -1) {\n\t\t\t\t\tQ.push(e->d);\n\t\t\t\t\tlevel[e->d] = level[u] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> finished(n);\n\t\tfor(Weight f = 1; f > 0; ) {\n\t\t\tf = augment(g, capacity, flow, level, finished, s, t, INF);\n\t\t\tif(f == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal += f;\n\t\t\tcont = true;\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvi X(M), Y(M);\n\tGraph o(N, Edges()), c(N, Edges());\n\tREP(i, M) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--;\n\t\tY[i]--;\n\t\to[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[Y[i]].push_back(Edge(Y[i], X[i], 1));\n\t}\n\n\tint S, T;\n\tcin >> S >> T;\n\tS--;\n\tT--;\n\tMatrix flow(N, Array(N, 0));\n\tWeight maxFlow = maximumFlow(c, S, T, flow);\n\tcout << maxFlow << endl;\n\tvi reversedRoads;\n\tREP(i, M) {\n\t\tif(flow[Y[i]][X[i]] > 0) {\n\t\t\treversedRoads.push_back(i+1);\n\t\t}\n\t}\n\tint size = reversedRoads.size();\n\tcout << size << endl;\n\tREP(i, size) {\n\t\tcout << reversedRoads[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#include<map>\n#include<stack>\n#include<string>\n#include<bitset>\n#define LL long long\n\nconst int MAXN=307;\nconst int MAXM=0;\nconst long long LLINF=9000000000000000000;\nconst int INF=1000000000;//careful because of floyed and so on\nconst int MOD=1000000007;\ndouble eps=0.00000001;\n\nusing namespace std;\n\nstruct Edge{\n    int from,to,cap,flow,id;\n    bool r;\n};\n\nint n,m;\nint S,T;\nvector<int>G[MAXN];\nvector<Edge>edges;\nbool vis[MAXN];\nint d[MAXN];\nint cur[MAXN];\nbool ans[MAXN];\n\nvoid add_edge(int from,int to,int cap,int id,bool r){\n    edges.push_back((Edge){from,to,cap,0,id,r});\n    edges.push_back((Edge){to,from,0,0,id,r});\n    int sz=edges.size();\n    G[from].push_back(sz-2);\n    G[to].push_back(sz-1);\n}\n\nvoid dinic_clear(){\n    edges.clear();\n    for (int i=0;i<MAXN;i++) G[i].clear();\n}\n\nbool BFS(){\n    queue<int>Q;\n    while (!Q.empty()) Q.pop();\n    memset(vis,0,sizeof(vis));\n    vis[S]=1;\n    d[S]=0;\n    Q.push(S);\n    while (!Q.empty()){\n            int x=Q.front();\n            Q.pop();\n            int sz=G[x].size();\n            for (int i=0;i<sz;i++){\n                    Edge& e=edges[G[x][i]];\n                    if (!vis[e.to] && e.cap>e.flow){\n                            vis[e.to]=1;\n                            d[e.to]=d[e.from]+1;\n                            Q.push(e.to);\n                    }\n            }\n    }\n    return vis[T];\n}\n\nint DFS(int x,int a){\n    if (x==T || a==0) return a;\n    int flow=0,f;\n    for (int& i=cur[x];i<(int)G[x].size();i++){\n            Edge& e=edges[G[x][i]];\n            if (d[x]+1==d[e.to] && (f=DFS(e.to,min(a,e.cap-e.flow)))>0){\n                    e.flow+=f;\n                    edges[G[x][i]^1].flow-=f;\n                    flow+=f;\n                    a-=f;\n                    if (a==0) break;\n            }\n    }\n    return flow;\n}\n\nint max_flow(){\n    int flow=0;\n    while (BFS()){\n            memset(cur,0,sizeof(cur));\n            flow+=DFS(S,INF);\n    }\n    return flow;\n}\n\nint main(){\n    dinic_clear();\n    memset(ans,0,sizeof(ans));\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=m;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            add_edge(x,y,1,i,0);\n            add_edge(y,x,1,i,1);\n    }\n    scanf(\"%d%d\",&S,&T);\n    printf(\"%d\\n\",max_flow());\n    for (int i=0;i<(int)edges.size();i++){\n            Edge e=edges[i];\n            if (e.cap>0 && e.r==1 && e.flow>0){\n                    ans[e.id]=1;\n            }\n    }\n    int cnt=0;\n    for (int i=1;i<=n;i++){\n            if (ans[i]) cnt++;\n    }\n    printf(\"%d\\n\",cnt);\n    for (int i=1;i<=n;i++){\n            if (ans[i]) printf(\"%d\\n\",i);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#define oo INT_MAX\n\nstruct edge{int v,g,next;} a[400000];\nint H[400],d[400],C[400],N,M,u,v,c,cnt,ans,S,T,k,i,j;\n\nint min(int x,int y){\n    return x<y?x:y;   \n}\n\nint add(int u,int v,int c){\n    a[++cnt].v=v; a[cnt].g=c; a[cnt].next=H[u]; H[u]=cnt;\n}\n\nint build(int u,int v,int c){\n    add(u,v,c);\n    add(v,u,0);   \n}\n\nint sap(int u,int flow){\n    int f=0,tt,delta;\n    if (u==T) return flow;\n    for (tt=H[u];tt;tt=a[tt].next){\n        v=a[tt].v;\n        if (a[tt].g && d[u]==d[v]+1){\n           delta=sap(v,min(flow,a[tt].g));\n           a[tt].g-=delta; a[tt+(tt&1?1:-1)].g+=delta; f+=delta; flow-=delta;\n           if (!flow) break;             \n        }\n    }\n    if (!f){\n       --C[d[u]];\n       if (!C[d[u]]) d[S]=N+2;\n       ++C[++d[u]];      \n    }\n    return f;   \n}\n\nint main()\n{\n    while (~scanf(\"%d%d\",&N,&M)){\n        memset(H,0,sizeof(H));\n        memset(d,0,sizeof(d));\n        memset(C,0,sizeof(C)); \n        cnt=0; C[0]=N;\n        for (i=1;i<=M;i++){\n            scanf(\"%d%d\",&u,&v);\n            build(u,v,1); build(v,u,1);\n        }\n        scanf(\"%d%d\",&S,&T);\n        ans=0;\n        while (d[S]<=N+1) ans+=sap(S,oo);\n        printf(\"%d\\n\",ans);\n        ans=0;\n        for (i=1;i<=M;i++) ans+=a[4*i-3].g;\n        printf(\"%d\\n\",ans);\n        for (i=1;i<=M;i++)\n            if (a[4*i-3].g) printf(\"%d\\n\",i);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string.h>\n#include <cmath>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nvector< vector<edge> > G(300);\nint level[300];\nint iter[300];\nint INF = 100000000;\n\nvoid bfs(int s){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  int a, b;\n  map<pair<int,int>,int> mp;\n  for(int i = 0; i < M; ++i){\n    cin >> a >> b;\n    --a;--b;\n    mp[make_pair(a,b)] = i+1;\n    mp[make_pair(b,a)] = -i-1;\n    G[a].push_back((edge){b,1,G[b].size()});\n    G[b].push_back((edge){a,0,G[a].size()-1});\n    G[b].push_back((edge){a,1,G[a].size()});\n    G[a].push_back((edge){b,0,G[b].size()-1});\n  }\n  int s, t;\n  cin >> s >> t;\n  --s;--t;\n  cout <<  max_flow(s,t) << endl;\n  set<int> V;\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < G[i].size(); ++j){\n      edge e = G[i][j];\n      if(e.cap == 0 && mp[make_pair(i,e.to)] < 0){\n        V.insert(abs(mp[make_pair(i,e.to)]));\n      }\n    }\n  }\n  cout << V.size() << endl;\n  for(set<int>::iterator itr = V.begin(); itr != V.end(); ++itr) cout << *itr << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\t\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nconst int MAX_V=1000;\nconst int INF=1000000000;\nconst int MAX_E=200000;\n\nstruct edge{\n\tint to,cap,rev,id;\n\tint flow;\n\tedge(int to_,int cap_,int rev_,int id_){\n\t\tto=to_;\n\t\tcap=cap_;\n\t\trev=rev_;\n\t\tid=id_;\n\t\tflow=0;\n\t}\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// idxðßé\nint lineIdx[MAX_V][MAX_V];\n\n// edgeðÇÁ\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,cap,G[from].size()-1,id));\n    lineIdx[from][to]=G[from].size()-1;\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<(int)G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\t// Ü¾t[ð¬¹éÈçÎA¬·\n\t\tif(!used[e.to]&&e.flow<e.cap){\n\t\t\t// ¡ñÌ¬Ê\n\t\t\tint quan=e.cap-e.flow;\n\t\t\tint d=dfs(e.to,t,min(f,quan));\n\t\t\tif(d>0){\n\t\t\t\te.flow+=d;\n\t\t\t\t// ½ÎÉÍ}CiXÌvfðüêÄ¨­\n\t\t\t\tG[e.to][e.rev].flow=-e.flow;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\telse flow+=f;\n\t}\n\treturn 0;\n}\n\npair<int,int> egs[10001];\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++){\n        int x,y;\n        cin>>x>>y;\n        add_edge(x,y,1,i);\n        egs[i].first=x;\n        egs[i].second=y;\n    }\n    int s,t;\n    cin>>s>>t;\n    int res=max_flow(s,t);\n    vector<int> rev;\n    for(int i = 0; i < m; i++){\n        int a=lineIdx[egs[i].first][egs[i].second];\n        if(G[egs[i].first][a].flow<0)\n            rev.push_back(i+1);\n    }\n    cout<<res<<endl;\n    cout<<rev.size()<<endl;\n    for(int i=0;i<rev.size();i++)\n        cout<<rev[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct P\n{\n  int to,cap,rev;\n  P(int to=-1,int cap=-1,int rev=-1):to(to),cap(cap),rev(rev){}\n};\ntypedef vector<int> VI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\ntypedef pair<int,int> Pes;\nint N,M,s,t; \nVVP G;\nvector<int> level,iter;\nvector<Pes> vec;\nvector<int> pvec;\nbool sign;\n\nvoid add_edge(int from,int to,int i)\n{\n  if(sign)vec.push_back(Pes(from,G[from].size())),\n\t    pvec.push_back(i);\n  G[from].push_back(P(to,1,G[to].size()));\n  G[to].push_back(P(from,0,G[from].size()-1));\n}\n\nvoid bfs()\n{\n  deque<int> deq;\n  deq.push_back(s);\n  level[s] = 0;\n  while(!deq.empty())\n    {\n      int p = deq.front(); deq.pop_front();\n      rep(i,G[p].size())\n\t{\n\t  P pes = G[p][i];\n\t  int v = pes.to;\n\t  if(level[v] == -1 && pes.cap > 0)\n\t    {\n\t      level[v] = level[p]+1;\n\t      deq.push_back(v);\n\t    }\n\t}\n    }\n}\n\nint dfs(int v,int flow)\n{\n  if(v == t)return flow;\n\n  for(int &i = iter[v];i < G[v].size();i++)\n    {\n      P p = G[v][i];\n\n      if(p.cap <= 0)continue;\n      if(level[v] < level[p.to])\n\t{\n\t  int d = dfs(p.to,min(flow,p.cap));\n\t  if(d <= 0)continue;\n\t  G[v][i].cap -= d;\n\t  G[p.to][p.rev].cap += d;\n\t  return d;\n\t    \n\t}\n    }\n  return 0;\n}\n\nint maximum_flow()\n{\n  int res = 0;\n  iter.resize(N);\n  level.resize(N);\n  while(1)\n    {\n      rep(i,N)\n\titer[i] = 0,level[i] = -1;\n       bfs();\n      \n       if(level[t] < 0)return res;\n       int f;\n  \n       while((f = dfs(s,(1<<29))) > 0)\n\t res += f;\n\t \n    }\n  return res;\n}\n\nint main()\n{\n  cin >> N >> M;\n  G.resize(N);\n  rep(i,M)\n    {\n      int from,to;\n      cin >> from >> to;\n      from--,to--;\n      sign = false;\n      add_edge(from,to,i);\n      sign = true;\n      add_edge(to,from,i);\n    }\n  cin >> s >> t;\n  s--,t--;\n  \n  int mexico = maximum_flow();\n  int cnt = 0;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)cnt++;\n    }\n\n  cout << mexico << endl;\n  cout << cnt << endl;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)\n\tcout << pvec[i]+1 << endl;\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass Edge{\npublic:\n  int _to;\n  int _capacity;\n  int _reverse;\n  int _id;\n  Edge(int to,int capacity,int reverse) :\n    _to(to), _capacity(capacity), _reverse(reverse) {}\n  Edge(int to,int capacity,int reverse,int id) :\n    _to(to), _capacity(capacity), _reverse(reverse),_id(id) {}\n};\n\nclass FordFulkerson {\nprivate:\n  int _n;\n  bool *_used;\n  vector<Edge>* _edges;\n  void fill_used(){\n    fill(_used,_used + (_n+1) ,false);\n  }\npublic:\n  FordFulkerson(int n){\n    _n = n;\n    _edges = new vector<Edge>[n+1];\n    _used = new bool[n+1]();\n  }\n\n  void add_edge(int from,int to,int capacity,int id){\n    _edges[from].push_back(Edge(to,capacity,_edges[to].size(),id));\n    _edges[to].push_back(Edge(from,capacity,_edges[from].size()-1,-id));\n  }\n\n  int dfs(int current,int sink,int flow){\n    if(current == sink) return flow;\n    _used[current] = true;\n    for(int i=0;i<_edges[current].size();i++){\n      Edge& e = _edges[current][i];\n      int to = e._to;\n      if(_used[to] || e._capacity <= 0) continue;\n\n      int d = dfs(to,sink,min(flow,e._capacity));\n      if(d <= 0) continue;\n      \n      e._capacity -= d;\n      _edges[to][e._reverse]._capacity += d;\n      return d;\n    }\n    \n    return 0;\n  }\n\n  int compute_max_flow(int source,int sink){\n    int res = 0;\n    while(true){\n      fill_used();\n      int tmp = dfs(source,sink,INF);\n      if(tmp == 0) break;\n      res += tmp;\n    }\n    return res;\n  }\n\n  set<int> compute_reverse(){\n    set<int> res;\n    for(int from = 1; from <= _n; from++){\n      for(int i = 0; i < _edges[from].size();i++){\n        Edge& e = _edges[from][i];\n        if(_edges[e._to][e._reverse]._capacity > 1\n           && e._id < 0){\n          res.insert(-1 * e._id);\n        }\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int num_of_crossings;\n  int num_of_roads;\n  while(~scanf(\"%d %d\",\n               &num_of_crossings,\n               &num_of_roads)){\n    \n    FordFulkerson fordfulkerson(num_of_crossings);\n\n    vector<P> roads;\n    for(int road_i = 1; road_i <= num_of_roads; road_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      fordfulkerson.add_edge(from,to,1,road_i);\n      roads.push_back(P(from,to));\n    }\n\n    int source,sink;\n    scanf(\"%d %d\",&source,&sink);\n    cout << fordfulkerson.compute_max_flow(source,sink) << endl;\n    \n    set<int> res = fordfulkerson.compute_reverse();\n    cout << res.size() << endl;\n    for(set<int>::iterator it = res.begin(); it != res.end(); it++){\n      cout << *it << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nconst int MAXV = 333;\nclass FordFulkerson {\n\tprivate:\n\tstruct edge {int to, cap, rev;};\n\tvector<edge> g[MAXV];\n\tbool used[MAXV];\n\tint gy[MAXV][MAXV];\n\tpublic:\n\t// fromからtoへ向かう要領capの辺をグラフに追加する\n\tvoid add_edge(int from, int to, int cap) {\n\t\tg[from].push_back((edge){to, cap, (int)g[to].size()});\n\t\tg[to].push_back((edge){from, 0, (int)g[from].size()-1});\n\t}\n\tvoid gyaku(int from, int to, int num) {\n\t\tgy[from][to] = num;\n\t}\n\t// 増加パスをdfsで探す\n\tint dfs(int v, int t, int f) {\n\t\tif (v==t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\tedge &e = g[v][i];\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\t\tif (d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t// sからtへの最大流を求める\n\tint getflow(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint f = dfs(s,t,(int)1e9+10);\n\t\t\tif (f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t// 行きの容量が0かつ逆辺の容量が1の辺のうち、与えられた辺と逆向きのものを列挙\n\tvi revs() {\n\t\tvi res;\n\t\trep(i,MAXV) rep(j,g[i].size()) {\n\t\t\tint fr = i, to = g[i][j].to;\n\t\t\tedge &x = g[i][j], &y = g[g[i][j].to][g[i][j].rev];\n\t\t\tif (x.cap==0 && y.cap==1 && gy[fr][to]) res.pb(gy[fr][to]);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n, m, x, y, s, t;\nFordFulkerson ff;\n\nsigned main() {\n\tcin >> n >> m;\n\trep(i,m) {\n\t\tcin >> x >> y;\n\t\tff.add_edge(x,y,1), ff.add_edge(y,x,1);\n\t\tff.gyaku(y,x,i+1);\n\t}\n\tcin >> s >> t;\n\t\n\tint res = ff.getflow(s,t);\n\tcout << res << ln;\n\tvi ch = ff.revs();\n\tunq(ch);\n\tcout << ch.size() << ln;\n\trep(i,ch.size()) cout << ch[i] << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define FINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nstruct edge {\n  int to, cap, rev;\n  edge() {}\n  edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nconst int MAX_V = 310;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].emplace_back(to, cap, G[to].size());\n  G[to].emplace_back(from, 0, G[from].size()-1);\n}\n\nvoid bfs(int s) {\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while (!que.empty()) {\n    int v = que.front(); que.pop();\n    for (int i = 0; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[e.to] < 0) {\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  for (int &i = iter[v]; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (e.cap > 0 && level[v] < level[e.to]) {\n      int d = dfs(e.to, t, min(f,e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  for (;;) {\n    bfs(s);\n    if (level[t] < 0) return flow;\n    memset(iter, 0, sizeof(iter));\n    int f;\n    while ((f = dfs(s, t, INF)) > 0) {\n      flow += f;\n    }\n  }\n}\n\nint N,M;\nint X[1010],Y[1010];\nint S,T;\nint idx[1010];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> N >> M;\n  REP(i,M) {\n    cin >> X[i] >> Y[i];\n    X[i]--; Y[i]--;\n    idx[i] = G[X[i]].size();\n    add_edge(X[i],Y[i],1);\n    add_edge(Y[i],X[i],1);\n  }\n  cin >> S >> T;\n  S--; T--;\n  int flow = max_flow(S,T);\n  vector<int> ans;\n  REP(i,M) {\n    if (G[X[i]][idx[i]].cap == 1) ans.push_back(i+1);\n  }\n  cout << flow << endl;\n  cout << ans.size() << endl;\n  for (int v : ans) cout << v << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight = long long;\n\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int cost;\n  Edge(int src, int dst, Weight weight, int cost = 0)\n      : src(src), dst(dst), weight(weight), cost(cost) {}\n};\n\nauto operator<(const Edge &e, const Edge &f) {\n  if (e.weight != f.weight)\n    return e.weight > f.weight;\n  else if (e.src != f.src)\n    return e.src < f.src;\n  else\n    return e.dst < f.dst;\n}\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nint main() {\n  int n, m, c;\n  while (cin >> n >> m >> c, n) {\n    vector<vector<int>> flag(n, vector<int>(m, 1e9));\n    Graph g(n);\n    for (int i = 0; i < m; ++i) {\n      int f, t, cc;\n      cin >> f >> t >> cc;\n      g[f - 1].emplace_back(f - 1, t - 1, cc);\n    }\n    deque<Edge> q;\n    for (q.emplace_back(-2, 0, 0, 0); !q.empty();) {\n      Edge e = q.front();\n      // cout << e.src << endl;\n      if (e.dst == n - 1) {\n        cout << e.cost << endl;\n        goto BREAK;\n      }\n      q.pop_front();\n      for (auto ge : g[e.dst]) {\n        if (flag[ge.dst][e.cost + 1] > e.weight)\n          q.emplace_back(ge.src, ge.dst, e.weight, e.cost + 1);\n        if (ge.weight + e.weight > c) continue;\n        if (flag[ge.dst][e.cost] > ge.weight + e.weight)\n          q.emplace_front(ge.src, ge.dst, ge.weight + e.weight, e.cost);\n      }\n    }\n    cout << \"impossible\" << endl;\n  BREAK:;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N, M, S, T;\n    cin >> N >> M;\n    using P = pair<int, int>;\n    vector<P> edge;\n    vector<vector<int>> g(N, vector<int>(N, 0));\n    for (int i = 0, u, v; i < M; i++) { (cin >> u >> v), edge.push_back({u - 1, v - 1}), g[u - 1][v - 1] = g[v - 1][u - 1] = 1; }\n    cin >> S >> T;\n    S--, T--;\n    vector<bool> used(N, false);\n    auto dfs = [&](auto&& self, const int s, const int f) -> int {\n        if (s == T) { return f; }\n        used[s] = true;\n        for (int i = 0; i < N; i++) {\n            if (used[i] or g[s][i] == 0) { continue; }\n            const int d = self(self, i, min(f, g[s][i]));\n            if (d == 0) { continue; }\n            return g[s][i] -= d, g[i][s] += d, d;\n        }\n        return 0;\n    };\n    int flow = 0;\n    while (true) {\n        fill(used.begin(), used.end(), false);\n        const int f = dfs(dfs, S, 1 << 30);\n        if (f == 0) { break; }\n        flow += f;\n    }\n    cout << flow << endl;\n    vector<int> ans;\n    for (int i = 0; i < M; i++) {\n        const int u = edge[i].first, v = edge[i].second;\n        if (g[u][v] == 2) { ans.push_back(i); }\n    }\n    cout << ans.size() << endl;\n    for (const int a : ans) { cout << a + 1 << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nint path[301][301];\n\nclass Edge{\npublic:\n  int _to;\n  int _capacity;\n  int _reverse;\n  int _id;\n  Edge(int to,int capacity,int reverse) :\n    _to(to), _capacity(capacity), _reverse(reverse) {}\n  Edge(int to,int capacity,int reverse,int id) :\n    _to(to), _capacity(capacity), _reverse(reverse),_id(id) {}\n};\n\nclass FordFulkerson {\nprivate:\n  int _n;\n  bool *_used;\n  vector<Edge>* _edges;\n  void fill_used(){\n    fill(_used,_used + (_n+1) ,false);\n  }\npublic:\n  FordFulkerson(int n){\n    _n = n;\n    _edges = new vector<Edge>[n+1];\n    _used = new bool[n+1]();\n  }\n\n  void add_edge(int from,int to,int capacity,int id){\n    _edges[from].push_back(Edge(to,capacity,_edges[to].size(),id));\n    _edges[to].push_back(Edge(from,capacity,_edges[from].size()-1,-id));\n  }\n\n  int dfs(int current,int sink,int flow){\n    if(current == sink) return flow;\n    _used[current] = true;\n    for(int i=0;i<_edges[current].size();i++){\n      Edge& e = _edges[current][i];\n      int to = e._to;\n      if(_used[to] || e._capacity <= 0) continue;\n\n      int d = dfs(to,sink,min(flow,e._capacity));\n      if(d <= 0) continue;\n      \n      e._capacity -= d;\n      _edges[to][e._reverse]._capacity += d;\n      path[current][to] -= d;\n      path[to][current] += d;\n      return d;\n    }\n    \n    return 0;\n  }\n\n  int compute_max_flow(int source,int sink){\n    int res = 0;\n    while(true){\n      fill_used();\n      int tmp = dfs(source,sink,INF);\n      if(tmp == 0) break;\n      res += tmp;\n    }\n    return res;\n  }\n\n  set<int> compute_reverse(const vector<P>& roads,int path[301][301]){\n    set<int> res;\n    for(int road_i = 0; road_i < roads.size();road_i++){\n      int from = roads[road_i].first;\n      int to = roads[road_i].second;\n\n      if(path[to][from] == 0){\n         res.insert(road_i + 1);\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int num_of_crossings;\n  int num_of_roads;\n  while(~scanf(\"%d %d\",\n               &num_of_crossings,\n               &num_of_roads)){\n    \n    FordFulkerson fordfulkerson(num_of_crossings);\n\n    memset(path,0,sizeof(path));\n    vector<P> roads;\n    for(int road_i = 1; road_i <= num_of_roads; road_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      fordfulkerson.add_edge(from,to,1,road_i);\n      path[from][to] = path[to][from] = 1;\n      roads.push_back(P(from,to));\n    }\n\n    int source,sink;\n    scanf(\"%d %d\",&source,&sink);\n    cout << fordfulkerson.compute_max_flow(source,sink) << endl;\n    \n    set<int> res = fordfulkerson.compute_reverse(roads,path);\n    cout << res.size() << endl;\n    for(set<int>::iterator it = res.begin(); it != res.end(); it++){\n      cout << *it << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\nstruct edge {int to,cap,rev,id;};\nconst int MAX_V=302,inf=500;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from, int to, int cap, int id){\n\tedge e1={to,cap,G[to].size(),id},e2={from,0,G[from].size(),-1};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t}\n}\nint main(){\n\tint n,m,x[300],y[300];\n\tcin >> n >> m;\n\tint s=0,t=n+1;\n\trep(i,m){\n\t\tcin >> x[i] >> y[i];\n\t\tadd_edge(x[i],y[i],1,-1);\n\t\tadd_edge(y[i],x[i],1,i);\n\t}\n\tint ss,tt;\n\tcin >> ss >> tt;\n\tadd_edge(s,ss,inf,-1);\n\tadd_edge(tt,t,inf,-1);\n\tcout << max_flow(s,t) << endl;\n\tbool ans[300]={};\n\trep1(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tedge e=G[i][j];\n\t\t\tif(e.id<0) continue;\n\t\t\tif(e.cap==0) ans[e.id]=true;\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,n) if(ans[i]) cnt++;\n\tcout << cnt << endl;\n\trep(i,n) if(ans[i]) cout << i+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, y, m; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nstruct flow_network {\n\tint n;\n\tstruct edge { int v; ll c; int rev; };\n\tvector< vector<edge> > G;\n\tflow_network(int _n) : n(_n), G(_n) {}\n\tll* add_edge(int u, int v, ll c) {\n\t\tedge e = {v, c, G[v].size()}, _e = {u, 0, G[u].size()};\n\t\tG[u].push_back(e); G[v].push_back(_e);\n\t\treturn &(G[u][G[u].size() - 1].c);\n\t}\n\tll dfs(int u, int t, ll f, vector<bool>& vis) {\n\t\tif (u == t) return f;\n\t\tvis[u] = true;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge& e = G[u][i];\n\t\t\tif (vis[e.v] || e.c == 0) continue;\n\t\t\tll d = min(e.c, dfs(e.v, t, min(f, e.c), vis));\n\t\t\tif (d == 0) continue;\n\t\t\te.c -= d;\n\t\t\tG[e.v][e.rev].c += d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\tll max_flow(int s, int t) {\n\t\tll res = 0;\n\t\tfor (;;) {\n\t\t\tvector<bool> vis(n);\n\t\t\tll f = dfs(s, t, LLONG_MAX, vis);\n\t\t\tif (f == 0) return res;\n\t\t\tres += f;\n\t\t}\n\t}\n};\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tflow_network fn(N);\n\tvector<ll*> a(M), b(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tint X, Y; cin >> X >> Y;\n\t\tX--; Y--;\n\t\ta[i] = fn.add_edge(X, Y, 1);\n\t\tb[i] = fn.add_edge(Y, X, 1);\n\t}\n\tint S, T; cin >> S >> T;\n\tS--; T--;\n\tcout << fn.max_flow(S, T) << endl;\n\tvector<int> v;\n\tfor (int i = 0; i < M; i++)\n\t\tif (*a[i] && !*b[i])\n\t\t\tv.push_back(i);\n\tcout << v.size() << endl;\n\tfor (int j = 0; j < v.size(); j++)\n\t\tcout << v[j] + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef int Weight;\nstruct Edge {\n\tint s, d;\n\tWeight w;\n\tEdge(int s, int d, Weight w) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &o)const {\n\t\treturn w != o.w ? w > o.w : s != o.s ? s < o.s : d < o.d;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n#define EACH(i,t,c) for(t::const_iterator i=(c).begin();i!=(c).end();i++)\nWeight augment(const Graph &g, const Matrix &capacity, Matrix &flow, const vi &level, vector<bool> &finished, int u, int t, Weight cur) {\n\tif(u == t || cur == 0) {\n\t\treturn cur;\n\t}\n\tif(finished[u]) {\n\t\treturn 0;\n\t}\n\tfinished[u] = true;\n\tEACH(e, Edges, g[u]) {\n\t\tif(level[e->d] > level[u]) {\n\t\t\tWeight f = augment(g, capacity, flow, level, finished, e->d, t, min(cur, RESIDUE(u, e->d)));\n\t\t\tif(f > 0) {\n\t\t\t\tflow[u][e->d] += f;\n\t\t\t\tflow[e->d][u] -= f;\n\t\t\t\tfinished[u];\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nWeight maximumFlow(const Graph &g, int s, int t, Matrix &flow) {\n\tint n = g.size();\n\tMatrix capacity(n, Array(n));\n\tREP(u, n) {\n\t\tEACH(e, Edges, g[u]) {\n\t\t\tcapacity[e->s][e->d] += e->w;\n\t\t}\n\t}\n\tWeight total = 0;\n\tbool cont = true;\n\twhile(cont) {\n\t\tcont = false;\n\t\tvi level(n, -1);\n\t\tlevel[s] = 0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\tfor(int d = n; !Q.empty() && level[Q.front()] < d; ) {\n\t\t\tint u = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(u == t) {\n\t\t\t\td = level[u];\n\t\t\t}\n\t\t\tEACH(e, g[u]) {\n\t\t\t\tif(RESIDUE(u, e->d) > 0 && level[e->d] == -1) {\n\t\t\t\t\tQ.push(e->d);\n\t\t\t\t\tlevel[e->d] = level[u] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> finished(n);\n\t\tfor(Weight f = 1; f > 0; ) {\n\t\t\tf = augment(g, capacity, flow, level, finished, s, t, INF);\n\t\t\tif(f == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal += f;\n\t\t\tcont = true;\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvi X(M), Y(M);\n\tGraph o(N, Edges()), c(N, Edges());\n\tREP(i, M) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--;\n\t\tY[i]--;\n\t\to[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[Y[i]].push_back(Edge(Y[i], X[i], 1));\n\t}\n\n\tint S, T;\n\tcin >> S >> T;\n\tS--;\n\tT--;\n\tMatrix flow(N, Array(N, 0));\n\tWeight maxFlow = maximumFlow(c, S, T, flow);\n\tcout << maxFlow << endl;\n\tvi reversedRoads;\n\tREP(i, M) {\n\t\tif(flow[Y[i]][X[i]] > 0) {\n\t\t\treversedRoads.push_back(i+1);\n\t\t}\n\t}\n\tint size = reversedRoads.size();\n\tcout << size << endl;\n\tREP(i, size) {\n\t\tcout << reversedRoads[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n    int rIdx;\n};\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ¹ª·ÅÉè³êÄ¢é©Ç¤©\nbool decided[10001];\nbool isRevEdge[10001];\n\nvoid add_edge(int from,int to,int cap,int idx){\n\tedge e;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n    e.rIdx=idx;\n\tG[from].push_back(e);\n\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n// ÁpXðTõ\nint dfs(int v,int t,int f){\n    if(v==t)\n\t\treturn f;\n\tused[v]=true;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tedge &e = G[v][i];\n        // Vµ¢¹©Ç¤©\n        bool ok=false;\n        bool change=false;\n        if(!decided[e.rIdx]){\n            ok=true;\n            decided[e.rIdx]=true;\n            // tü«É¬µÄ¨­\n            if(e.cap==0){\n                change=true;\n                isRevEdge[e.rIdx]=true;\n                G[e.to][e.rev].cap=0;\n                e.cap=1;\n            }\n        }\n        if(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n            else{\n                // ¡ñÏXÅ«È¢êÅAtü«É¬µÄ¢éÌÅ êÎAC³·é\n                if(ok){\n                    decided[e.rIdx]=false;\n                    if(isRevEdge[e.rIdx]&&change){\n                        isRevEdge[e.rIdx]=false;\n                        G[e.to][e.rev].cap=1;\n                        e.cap=0;\n                    }\n                }\n            }\n\t\t}\n        else{\n            if(ok){\n                decided[e.rIdx]=false;\n                if(isRevEdge[e.rIdx]&&change){\n                    isRevEdge[e.rIdx]=false;\n                    G[e.to][e.rev].cap=1;\n                    e.cap=0;\n                }\n            }\n        }\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n    fill(isRevEdge,isRevEdge+10001,false);\n    fill(decided,decided+10001,false);\n\twhile(1){\n\t\tfill(used,used+MAX_V,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++){\n        int from,to;\n        cin>>from>>to;\n        add_edge(from,to,1,i);\n    }\n    int s,t;\n    cin>>s>>t;\n    int res=max_flow(s,t);\n    cout<<res<<endl;\n    set<int> ss;\n    for(int i = 0; i < m; i++)\n        if(isRevEdge[i])\n            ss.insert(i);\n    cout<<ss.size()<<endl;\n    for(set<int>::iterator it = ss.begin();it!=ss.end();it++)\n        cout<<(*it+1)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Teletubbies\n * Created Time:  2012年08月29日 星期三 12&#26102;39分28秒\n * File Name: e.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <time.h>\n#include <cctype>\n#include <functional>\n#include <deque>\n#include <iomanip>\n#include <bitset>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#include <utility>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORD(i,a,b) for (int i=(a); i>=(b); i--)\n#define REP(i,b) FOR(i,0,b)\n#define sf scanf\n#define pf printf\nusing namespace std;\nconst int maxint = -1u>>1;\nconst double pi = 3.14159265358979323;\nconst double eps = 1e-8;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<int>::iterator vit;\n#define maxn 310\n#define maxm 500000\nint eh[maxn], tot, cur[maxn];\nconst int inf = 1 << 30;\nint dist[maxn];\nint s, t;\nint n, m;\n\nstruct Edge {\n    int u, v, cap, flow, next;\n}et[maxm];\n\nvoid init() {\n    tot = 0;\n    memset(eh, -1, sizeof(eh));\n}\n\nvoid add(int u, int v, int cap, int flow) {\n    Edge e = {u, v, cap, flow, eh[u]};\n    et[tot] = e;\n    eh[u] = tot++;\n}\n\nvoid addedge(int u, int v, int cap) {\n    add(u, v, cap, 0), add(v, u, cap, 0);\n}\n    \nbool bfs() {\n    int que[maxn];\n    int head = 0, tail = 0;\n    memset(dist, -1, sizeof(dist));\n    dist[t] = 0;\n    que[tail++] = t;\n    while(head < tail && dist[s] == -1) {\n        int u = que[head++];\n        for(int i = eh[u]; i != -1; i = et[i].next) {\n            int v = et[i].v;\n            if(et[i^1].cap > et[i^1].flow && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                que[tail++] = v;\n            }\n        }\n    }\n    return dist[s] != -1;\n}\n\nint dfs(int u, int d) {\n    if(u == t) return d;\n    int l = d;\n    //cout << u << \"********\" <<  endl;\n    for(int &i = cur[u]; i != -1; i = et[i].next) {\n        int v = et[i].v;\n        if(et[i].cap > et[i].flow && dist[u] == dist[v] + 1) {\n            //cout << v << \" \" << d << endl;\n            int tmp = dfs(v, min(l, et[i].cap - et[i].flow));\n            //cout << v << \"tmp = \" << tmp << endl;\n            et[i].flow += tmp;\n            et[i^1].flow -= tmp;\n            l -= tmp;\n            if(l == 0) break;\n        }\n    }\n    //cout << d -  l << \"asdfads\" << endl;\n    return d - l;\n}\n\nint Dinic() {\n    int flow = 0;\n    while(bfs()) {\n        //cout << \"dist\" << endl;\n        //for(int i = 1; i <= n; i++) {\n            //cout << dist[i] << endl;\n        //}\n        for(int i = 1; i <= n; i++) cur[i] = eh[i];\n        flow += dfs(s, inf);\n    }\n    return flow;\n}\n\nint main() \n{\n    while(~scanf(\"%d%d\", &n, &m)) {\n        init();\n        int u, v;\n        for(int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &u, &v);\n            addedge(u, v, 1);\n            //cout << u << \" \" << v << endl;\n        }\n        scanf(\"%d%d\", &s, &t);\n        int ans = Dinic();\n        printf(\"%d\\n\", ans);\n        vector<int> vec;\n        vec.clear();\n        //cout << tot << endl;\n        for(int i = 0; i < tot; i += 2) {\n            //cout << et[i].u << \" \" << et[i].v << \" \" << et[i].flow << endl;\n            if(et[i].flow < 0) {\n                vec.pb(i / 2 + 1);\n            }\n        }\n        printf(\"%d\\n\", vec.size());\n        for(int i = 0; i < vec.size(); i++) {\n            printf(\"%d\\n\", vec[i]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define INF 2000000000\n#define typec int//type of cost\nconst int pN=500,eN=10000;\nstruct Edge{\n\tint u,v,next;\n\ttypec w;\n};\nEdge edge[eN];\nint en,head[pN],cur[pN],ps[pN],dep[pN];\nvoid insert(int u,int v){\n\tedge[en].u=u;\n\tedge[en].v=v;\n\tedge[en].w=1;\n\tedge[en].next=head[u];\n\thead[u]=en++;\n\tedge[en].u=v;\n\tedge[en].v=u;\n\tedge[en].w=1;//æåä¸º0ï¼æ åä¸ºc\n\tedge[en].next=head[v];\n\thead[v]=en++;\n}\ntypec max_flow(int n,int s,int t){\n\ttypec tr,res=0;\n\tint i,j,k,f,r,top;\n\twhile(1){\n\t\tmemset(dep,-1,n*sizeof(int));\n\t\tfor(f=dep[ps[0]=s]=0,r=1;f!=r;)\n\t\t\tfor(i=ps[f++],j=head[i];j!=-1;j=edge[j].next){\n\t\t\t\tif(edge[j].w&&-1==dep[k=edge[j].v]){\n\t\t\t\t\tdep[k]=dep[i]+1;\n\t\t\t\t\tps[r++]=k;\n\t\t\t\t\tif(k==t){\n\t\t\t\t\t\tf=r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1==dep[t])break;\n\t\t\tmemcpy(cur,head,n*sizeof(int));\n\t\t\tfor(i=s,top=0;;){\n\t\t\t\tif(i==t){\n\t\t\t\t\tfor(k=0,tr=INF;k<top;++k)\n\t\t\t\t\t\tif(edge[ps[k]].w<tr)\n\t\t\t\t\t\t\ttr=edge[ps[f=k]].w;\n\t\t\t\t\t\tfor(k=0;k<top;++k)\n\t\t\t\t\t\t\tedge[ps[k]].w-=tr,edge[ps[k]^1].w+=tr;\n\t\t\t\t\t\tres+=tr;\n\t\t\t\t\t\ti=edge[ps[top=f]].u;\n\t\t\t\t}\n\t\t\t\tfor(j=cur[i];cur[i]!=-1;j=cur[i]=edge[cur[i]].next)\n\t\t\t\t\tif(edge[j].w&&dep[i]+1==dep[edge[j].v])break;\n\t\t\t\t\tif(cur[i]!=-1){\n\t\t\t\t\t\tps[top++]=cur[i];\n\t\t\t\t\t\ti=edge[cur[i]].v;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(0==top)break;\n\t\t\t\t\t\tdep[i]=-1;\n\t\t\t\t\t\ti=edge[ps[--top]].u;\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\treturn res;\n}\nint N,M,S,E;\nvoid get_data(){\n\tint i;\n\tscanf(\"%d%d\",&N,&M);\n\tmemset(head,-1,sizeof(head));en=0;\n\tint u,v;\n\tfor(i=0;i<M;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tinsert(u,v);\n\t}\n\tscanf(\"%d%d\",&S,&E);\n\tS--;E--;\n}\nvoid run(){\n\tint flow=max_flow(N,S,E);\n\tint cnt=0,i,res[1000];\n\tfor(i=0;i<en;i+=2){\n\t\tif(edge[i].w==2)res[cnt++]=i/2+1;\n\t}\n\tprintf(\"%d\\n%d\\n\",flow,cnt);\n\tfor(i=0;i<cnt;i++)printf(\"%d\\n\",res[i]);\n}\nint main(){\n\tget_data();\n\trun();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n\nusing namespace std;\n#define inf  1000000\nint MIN(int a,int b){return a<b?a:b;}\n#define N 700\n#define M 4000\nstruct node\n{\n    int e,first[N],next[M],v[M],w[M],f[M];\n    void init(int n){fill(first,first+n+10,-1);e=0;}\n    void add_edge(int a,int b,int c,int index)\n    {\n        v[e]=b;w[e]=c;next[e]=first[a];first[a]=e++;f[e]=index;\n        v[e]=a;w[e]=0;next[e]=first[b];first[b]=e++;f[e]=index;\n    }\n}T;\nint n,m,s,t;\nint h[N],gap[N];\nint sap_gap(int u,int f)\n{\n    if(u==t) return f;\n    int minh=n-1,l=f,d;\n    for(int i=T.first[u];i!=-1;i=T.next[i])\n        if(T.w[i])\n        {\n            if(h[T.v[i]]+1==h[u])\n            {\n                d=sap_gap(T.v[i],MIN(T.w[i],l));\n                T.w[i]-=d;T.w[i^1]+=d;l-=d;\n                if(h[s]>=n)  return f-l;\n                if(!l) break;\n            }\n            minh=MIN(minh,h[T.v[i]]);\n        }\n    if(l==f)\n    {\n        if(--gap[h[u]]==0) h[s]=n;\n        gap[h[u]=minh+1]++;\n    }\n    return f-l;\n}\nint isap(int source,int sink)\n{\n    int flow=0;\n    s=source;t=sink;\n    fill(h,h+n+1,0);\n    fill(gap,gap+n+1,0);\n    gap[source]=n;\n    while(h[source]<n)\n        flow+=sap_gap(source,inf);\n    return flow;\n}\nint maze[N][N];\nint visit[M],fa[M];\nint main() {\n    //freopen(\"in\",\"r\",stdin);\n    //freopen(\"out\",\"w\",stdout);\n    while(~scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n        memset(maze,0,sizeof(maze));\n        memset(fa,0,sizeof(fa));\n        memset(visit,0,sizeof(visit));\n        T.init(2*n);\n        int i,j,a,b;\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            maze[b][a]=i;\n            T.add_edge(b+n,a,1,1);\n            T.add_edge(a+n,b,1,1);\n        }\n        for(i=1;i<=n;i++) T.add_edge(i,i+n,inf,0);\n        scanf(\"%d%d\",&s,&t);\n        t=t+n;\n        int tot=n;\n        n=n*2;\n        printf(\"%d\\n\",isap(s,t));\n        for(i=tot+1;i<=n;i++)\n        {\n            for(j=T.first[i];j!=-1;j=T.next[j])\n            {\n                if(T.v[j]<=tot&&T.w[j]==0)\n                {\n                    visit[maze[i-tot][T.v[j]]]=1;\n                }\n            }\n        }\n        int num=0;\n        for(i=1;i<=m;i++) if(visit[i]) num++;\n        printf(\"%d\\n\",num);\n        for(i=1;i<=m;i++)\n            if(visit[i]) printf(\"%d\\n\",i);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1000\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev,re;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap,int re){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),re});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\nint main(){\n  int n,m,c=1,s,t;\n  cin>>n>>m;\n  while(m--){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    add_edge(a,b,1,-1);\n    add_edge(b,a,1,c++);\n  }\n  cin>>s>>t;s--,t--;\n  cout<<max_flow(s,t)<<endl;\n  vector<int>ans;\n  for(int i=0;i<1000;i++){\n    for(int j=0;j<G[i].size();j++){\n      if(G[i][j].re!=-1&&G[i][j].cap==0)ans.push_back(G[i][j].re);\n    }\n  }\n  cout<<ans.size()<<endl;\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++){\n    cout<<ans[i]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\n\nstruct edge{ int to, cap, rev; };\n\nint n,m,s,t;\nint x[1000],y[1000];\nint fl,v;\nbool visitv[300],visite[1000];\nvector<int> r;\n\nvector<edge> G[300];\nbool used[300];\n\nvoid add_edge(int from,int to, int cap){\n  G[from].push_back( (edge){to,cap,G[to].size()});\n  G[to].push_back( (edge){from,0,G[form].size()-1});\n}\n\nint dfs(int v, int t, int f){\n  if(v==t)return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap -= d;\n\tG[e.cap][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  cin >> m >> n;\n  for(int i=0;i<m;i++){\n    cin >> x >> y;\n    add_edge(x,y,1);\n  }\n  cin >> s >> t;\n\n  fl = max_flow(s,t);\n\n  for(int i=0;i<n;i++)visitv[i] = false;\n  for(int i=0;i<m;i++)visite[i] = false;\n\n  queue<int> q;\n  q.push(t);"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <iostream>\n#include <map>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1 << 29;\n\n// Dinic を信じろ\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate<typename T>\nstruct Dinic {\n    int N, M;\n    Graph<T> G;\n    vector<int> level, iter;\n    Dinic(int n, int m) : N(n), M(m) {\n        G.resize(N);\n        level.resize(N);\n        iter.resize(N);\n    }\n    void add_edge(int from, int to, T cost) {\n        G[from].push_back(Edge<T>(to  , cost, G[to  ].size()    ));\n        G[to  ].push_back(Edge<T>(from, cost , G[from].size() - 1));\n    }\n    void readGraph() {\n        for(int i=0; i<M; i++) {\n            int a, b; T c;\n            cin >> a >> b >> c;\n            // a--; b--;\n            add_edge(a, b, c);\n        }\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> que; que.push(s);\n        level[s] = 0;\n        while(!que.empty()) {\n            int temp = que.front(); que.pop();\n            for(size_t i=0; i<G[temp].size(); i++) {\n                Edge<T> &e = G[temp][i];\n                if(e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[temp] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    T dfs(int v, int t, T f) {\n        if(v == t) return f;\n        for(int &i = iter[v]; i<(int)G[v].size(); i++) {\n            Edge<T> &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T max_flow(int s, int t) {\n        T flow = 0.0, f;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            while( (f = dfs(s, t, INF)) > 0 ) flow += f;\n        }\n    }\n};\n\nint main() {\n    int N, M; cin >> N >> M;\n\n    Dinic<int> fl(N, M);\n    map< pair<int, int>, int > edges;\n    for(int i=0; i<M; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n\n        edges[make_pair(u, v)] = i + 1;\n        fl.add_edge(u, v, 1);\n    }\n\n    int S, T; cin >> S >> T;\n    S--; T--;\n\n    cout << fl.max_flow(S, T) << endl;\n    vector<int> vertices;\n    for(int i=0; i<N; i++) {\n        for(auto e : fl.G[i]) {\n            int u = i, v = e.to;\n\n            if(edges.count(make_pair(v, u))) {\n                if(e.cap == 0) vertices.push_back(edges[ make_pair(v, u) ]);\n            }\n        }\n    }\n    cout << vertices.size() << endl;\n    sort(vertices.begin(), vertices.end());\n    for(auto x : vertices) cout << x << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n\nusing namespace std;\n#define inf  1000000\nint MIN(int a,int b){return a<b?a:b;}\n#define N 700\n#define M 4000\nstruct node\n{\n    int e,first[N],next[M],v[M],w[M],f[M];\n    void init(int n){fill(first,first+n+10,-1);e=0;}\n    void add_edge(int a,int b,int c,int index)\n    {\n        v[e]=b;w[e]=c;next[e]=first[a];first[a]=e++;f[e]=index;\n        v[e]=a;w[e]=0;next[e]=first[b];first[b]=e++;f[e]=index;\n    }\n}T;\nint n,m,s,t;\nint h[N],gap[N];\nint sap_gap(int u,int f)\n{\n    if(u==t) return f;\n    int minh=n-1,l=f,d;\n    for(int i=T.first[u];i!=-1;i=T.next[i])\n        if(T.w[i])\n        {\n            if(h[T.v[i]]+1==h[u])\n            {\n                d=sap_gap(T.v[i],MIN(T.w[i],l));\n                T.w[i]-=d;T.w[i^1]+=d;l-=d;\n                if(h[s]>=n)  return f-l;\n                if(!l) break;\n            }\n            minh=MIN(minh,h[T.v[i]]);\n        }\n    if(l==f)\n    {\n        if(--gap[h[u]]==0) h[s]=n;\n        gap[h[u]=minh+1]++;\n    }\n    return f-l;\n}\nint isap(int source,int sink)\n{\n    int flow=0;\n    s=source;t=sink;\n    fill(h,h+n+1,0);\n    fill(gap,gap+n+1,0);\n    gap[source]=n;\n    while(h[source]<n)\n        flow+=sap_gap(source,inf);\n    return flow;\n}\nint maze[N][N];\nint visit[M],fa[M];\nint main() {\n    //freopen(\"in\",\"r\",stdin);\n    //freopen(\"out\",\"w\",stdout);\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        memset(maze,0,sizeof(maze));\n        memset(fa,0,sizeof(fa));\n        memset(visit,0,sizeof(visit));\n        T.init(2*n);\n        int i,j,a,b;\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            maze[b][a]=i;\n            T.add_edge(b+n,a,1,1);\n            T.add_edge(a+n,b,1,1);\n        }\n        for(i=1;i<=n;i++) T.add_edge(i,i+n,inf,0);\n        scanf(\"%d%d\",&s,&t);\n        t=t+n;\n        int tot=n;\n        n=n*2;\n        printf(\"%d\\n\",isap(s,t));\n        for(i=tot+1;i<=n;i++)\n        {\n            for(j=T.first[i];j!=-1;j=T.next[j])\n            {\n                if(T.v[j]<=tot&&T.w[j]==0)\n                {\n                    visit[maze[i-tot][T.v[j]]]=1;\n                }\n            }\n        }\n        int num=0;\n        for(i=1;i<=m;i++) if(visit[i]) num++;\n        printf(\"%d\\n\",num);\n        for(i=1;i<=m;i++)\n            if(visit[i]) printf(\"%d\\n\",i);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include <iostream> \n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include<algorithm>\n#define N 320\n#define M (N*N*6+100)\n#define inf 999999999\n#define INT_MAX1 (1<<30)\nusing namespace std;\n\n\nint mk[M];\nint n,m,s,t,num,adj[N],dis[N],q[N];\nstruct edge\n{\n\tint v,w,pre;\n}e[M];\nvoid insert(int u,int v,int w)\n{\n\te[num]=(edge){v,w,adj[u]};\n\tadj[u]=num++;\n\te[num]=(edge){u,w,adj[v]};\n\tadj[v]=num++;\n}\nint bfs()\n{\n\tint i,x,v,tail=0,head=0;\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\tq[tail++]=s;\n\twhile(head<tail)\n\t{\n\t\tx=q[head++];\t\t\n\t\tfor(i=adj[x];i!=-1;i=e[i].pre)\n\t\t\tif(e[i].w&&dis[v=e[i].v]==0)\n\t\t\t{\n\t\t\t\tdis[v]=dis[x]+1;\n\t\t\t\tif(v==t)\n\t\t\t\t\treturn 1;\n\t\t\t\tq[tail++]=v;\n\t\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int s,int limit)\n{\n\tif(s==t)\n\t\treturn limit;\n\tint i,v,tmp,cost=0;\n\tfor(i=adj[s];i!=-1;i=e[i].pre)\n\t\tif(e[i].w&&dis[s]==dis[v=e[i].v]-1)\n\t\t{\n\t\t\ttmp=dfs(v,min(limit-cost,e[i].w));\n\t\t\tif(tmp>0)\n\t\t\t{\n\t\t\t\te[i].w-=tmp;\n\t\t\t\te[i^1].w+=tmp;\n\t\t\t\tcost+=tmp;\n\t\t\t\tif(limit==cost)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse dis[v]=-1;\n\t\t}\n\treturn cost;\n}\nint Dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t\tans+=dfs(s,INT_MAX1);\n\treturn ans;\n}\nint main ()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint t1,t2;\n\tnum=0;\n\tint mm=2*n+1;\n\tmemset(adj,-1,sizeof(adj));\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tinsert (t1,t2,1);\n\t//\tinsert(t2,++mm,1);\n\t///\tinsert(mm,t1,1);\n\t}\n\tscanf(\"%d%d\",&s,&t);\n\tint res=Dinic();\n\tint cnt=0;\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tif (e[i*2+1].w==0)\n\t\t{\n\t\t\tmk[cnt++]=i+1;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\tcout<<cnt<<endl;\n\tfor (int i=0;i<cnt;i++)\n\t\tcout<<mk[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nconst int NMAX = 310;\nconst int MMAX = 1010;\nconst int INF = MMAX * 6;\n\nstruct edge { \n  int to, cap, rev, id;\n  bool reversal;\n};\n\nvector<edge> G[NMAX];\nbool used[NMAX];\n\nvoid add_edge(int from, int to, int cap, int id, bool reversal) {\n  G[from].push_back((edge){to, cap, G[to].size(), id, reversal});\n  G[to].push_back((edge){from, 0, G[from].size() - 1, 0, false});\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] and e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  while (true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main() {\n  int n, m, s, t;\n  cin >> n >> m;\n  REP(i, m) {\n    int x, y;\n    cin >> x >> y;\n    add_edge(x, y, 1, i + 1, false);\n    add_edge(y, x, 1, i + 1, true);\n  }\n  cin >> s >> t;\n  cout << max_flow(s, t) << endl;\n\n  vector<int> reverse_roads;\n/*  REP(v, n + 1) {\n    REP(i, G[v].size()) {\n      edge e = G[v][i];\n      cout << \"G[\" << v << \"][\" << i << \"]\";\n      cout << \"to=\" << e.to;\n      cout << \"cap=\" << e.cap;\n      cout << \"rev=\" << e.rev;\n      cout << \"id=\" << e.id;\n      cout << \"reversal=\" << e.reversal << endl;\n    }\n  }*/\n  REP(v, n + 1) {\n    REP(e, G[v].size()) {\n      if (G[v][e].reversal and G[v][e].cap == 0) {\n        reverse_roads.push_back(G[v][e].id);\n      }\n    }\n  }\n  sort(reverse_roads.begin(), reverse_roads.end());\n  int len = reverse_roads.size();\n  cout << len << endl;\n  REP(i, len) {\n    cout << reverse_roads[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define INF (1<<20)\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nEdges es;\nWeight maximumFlow(const Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow(n, Array(n)), capacity(n, Array(n));\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n\n  Weight total = 0;\n  while (1) {\n    queue<int> Q; Q.push(s);\n    vector<int> prev(n, -1); prev[s] = s;\n    while (!Q.empty() && prev[t] < 0) {\n      int u = Q.front(); Q.pop();\n      FOR(e,g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n        prev[e->dst] = u;\n        Q.push(e->dst);\n      }\n    }\n    if (prev[t] < 0){\n\t\tbreak;\n\t}\n    Weight inc = INF;\n    for (int j = t; prev[j] != j; j = prev[j])\n      inc = min(inc, RESIDUE(prev[j], j));\n    for (int j = t; prev[j] != j; j = prev[j])\n      flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n    total += inc;\n  }\n  vector<int> res;\n\tfor(int i = 0 ; i < es.size() ; i++){\n\t\tint x = es[i].src;\n\t\tint y = es[i].dst;\n\t\tif( flow[x][y] < 0 ){\n\t\t\tres.push_back(i);\n\t\t}\n\t}\n\tcout << total << endl;\n\tcout << res.size() << endl;\n\tfor(int i = 0 ; i < res.size() ; i++)\n\t\tcout << res[i]+1 << endl;\n}\n\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tGraph g(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tg[a].push_back(Edge(a,b,1));\n\t\tg[b].push_back(Edge(b,a,1));\n\t\tes.push_back(Edge(a,b,1));\n\t}\n\tint s,t;\n\tcin >> s >> t;\n\ts--,t--;\n\tmaximumFlow(g,s,t);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_V 1000\n\nstruct edge{\n\tlong long int to, cap, rev; // 行き先、容量、逆辺\n};\n\nvector<edge> G[MAX_V] = {};\nbool used[MAX_V];\n\n// from から to へ向かう容量 cap の辺を張る\nvoid add_edge(long long int from, long long int to, long long int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, cap, G[from].size() - 1}); // 無向辺\n}\n\n// 増加パスを dfs で探す\nlong long int dfs(int v, int t, long long int f){\n\tif(v == t){\n\t\treturn f;\n\t}\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tlong long int d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// s から t への最大流を求める\nlong long int max_flow(int s, int t){\n\tlong long int flow = 0;\n\twhile(true){\n\t\tfill(used, used + MAX_V, 0);\n\t\tlong long int f = dfs(s, t, INF);\n\t\tif(f == 0){\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint N, M, S, T;\n\tcin >> N >> M;\n\tmap<P, int> m;\n\tfor(int i = 0; i < M; i++){\n\t\tP p;\n\t\tcin >> p.first >> p.second;\n\t\tp.first--;\n\t\tp.second--;\n\t\tm[p] = i + 1;\n\t\tadd_edge(p.first, p.second, 1);\n\t}\n\tcin >> S >> T;\n\tS--;\n\tT--;\n\tlong long int F = max_flow(S, T);\n\t\n\tvector<int> vec;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tint u = i;\n\t\t\tint v = G[i][j].to;\n\t\t\tP p = make_pair(v, u);\n\t\t\tif(G[i][j].cap == 0 && m.find(p) != m.end()){\n\t\t\t\tvec.push_back(m[p]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << F << endl;\n\t\n\tcout << vec.size() << endl;\n\t\n\tsort(vec.begin(), vec.end());\n\t\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tcout << vec[i] << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\nconst int maxn=330;\nconst int maxm=330*330*4;\nusing namespace std;struct edge\n{\n  int v,next,flow;\n}e[maxm];\nint st[maxn];\nint now[maxn],sumd[maxn],dis[maxn],fanhui[maxn],pre[maxn];\nint nn,n,m,maxflow;\nint start,end,zong;\n\nvoid addedge(int u,int v,int flow)\n{\n    e[nn].v=v;\n    e[nn].flow=flow;\n    e[nn].next=st[u];\n    st[u]=nn++;\n\n    e[nn].v=u;\n    e[nn].flow=0;\n    e[nn].next=st[v];\n    st[v]=nn++;\n}\nvoid init()\n{\n    memset(st,-1,sizeof(st));\n    memset(dis,0,sizeof(dis));\n    memset(sumd,0,sizeof(sumd));\n    nn=0;\n}\nint mflow()\n{\n    maxflow=0;\n    sumd[0]=zong;\n    int u=start,flow=99999999,t,dmin,mark;\n    bool flag;\n    while (dis[start]<zong)\n    {\n        fanhui[u]=flow;\n        flag=false;\n        for(t=now[u];t!=-1;t=e[t].next)\n        {\n            int v=e[t].v;\n            if (e[t].flow>0 && dis[u]==dis[v]+1)\n            {\n                flag=true;\n                now[u]=t;\n                flow=min(e[t].flow,flow);\n                pre[v]=t;\n                u=v;\n                if (u==end)         //update\n                {\n                    maxflow+=flow;\n                    while (u!=start)\n                    {\n                        e[pre[u]].flow-=flow;\n                        e[pre[u]^1].flow+=flow;\n                        u=e[pre[u]^1].v;\n                    }\n                    flow=99999999;\n                }\n                break;\n            }\n        }\n        if (flag)\n            continue;\n\n        dmin=zong-1;\n        for(t=st[u];t!=-1;t=e[t].next)\n            if (e[t].flow>0 && dis[e[t].v]<dmin)\n            {\n                mark=t;\n                dmin=dis[e[t].v];\n            }\n        now[u]=mark;\n\n        sumd[dis[u]]--;\n        if (!sumd[dis[u]])\n            break;\n        dis[u]=dmin+1;\n        sumd[dis[u]]++;\n\n        if (u!=start)\n        {\n            u=e[pre[u]^1].v;\n            flow=fanhui[u];\n        }\n    }\n    return maxflow;\n}\nvector<int> Eg;\nint main()\n{\n    int i;\n    while (cin>>n>>m)\n    {\n        init();\n        int tx,ty;\n        for (i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&tx,&ty);\n            addedge(tx,ty,1);\n            addedge(ty,tx,1);\n        }\n        for (i=1;i<=n;i++)\n            now[i]=st[i];\n        scanf(\"%d%d\",&start,&end);\n        zong=n;\n        printf(\"%d\\n\",mflow());\n        int Ans=0;\n        Eg.clear();\n        for (i=0;i<nn;i+=4)\n        {\n            if (e[i+3].flow==1)\n            {\n                Ans++;\n                Eg.push_back(i/4+1);\n            }\n        }\n        printf(\"%d\\n\",Ans);\n        for (i=0;i<Eg.size();i++)\n            printf(\"%d\\n\",Eg[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cap,rev,num,add;\n\tEdge(){}\n\tEdge(int s, int d, int cp, int r, int n, int a)\n\t\t:src(s),dst(d),cap(cp),rev(r),num(n), add(a)\n\t{}\n};\n\nconst int INF = (1<<28);\n\ntypedef vector<vector<Edge> > Graph;\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=e.cap;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tgraph[p][i].cap -= f;\n\t\t\tgraph[next][e.rev].cap += f;\n\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\t\t\t\tif(level[e.dst]!=-1) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.dst]=level[n]+1;\n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int d, int c, int n, int a, Graph& g)\n{\n\tg[s].push_back(Edge(s,d,c,g[d].size()  , n, a));\n\tg[d].push_back(Edge(d,s,0,g[s].size()-1, n, 0)); \n}\n\nint main()\n{\n\tint N,M,S,T;\n\tcin >> N >> M;\n\n\tGraph g(N);\n\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tadd_edge(s-1, t-1, 1, i, 0, g);\n\t\tadd_edge(t-1, s-1, 1, i, 1, g);\n\t}\n\n\tcin >> S >> T;\n\tcout << dinic(S-1,T-1,g) << endl;\n\n\tvector<int> res;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<g[i].size(); j++)\n\t{\n\t\tif(g[i][j].add == 1 && g[i][j].cap == 0)\n\t\t\tres.push_back(g[i][j].num);\n\t}\n\n\tcout << res.size() << endl;\n\t//sort(res.begin(), res.end());\n\tfor(int i=0; i<res.size(); i++)\n\t\tcout << res[i] + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\nvector<bool> used;\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(e.cap, f));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tint N = G.size();\n\t\tused = vector<bool>(G.size(), false);\n\t\tint flow = dfs(s, t, 1e9);\n\t\tif (flow > 0) {\n\t\t\tres += flow;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\nvoid add_edge(int u, int v, int cap) {\n\tG[u].push_back((Edge){v, cap, (int)G[v].size()});\n\tG[v].push_back((Edge){u, cap, (int)G[u].size()-1});\n}\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tG.resize(N);\n\tvector<P> edges;\n\tmap<P, int> tbl;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; --a, --b;\n\t\tedges.push_back( P(a, b) );\n\t\ttbl[edges[i]] = i;\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u = edges[i].first, v = edges[i].second;\n\t\tadd_edge(u, v, 1);\n\t}\n\tint S, T; cin >> S >> T; --S, --T;\n\tcout << max_flow(S, T) << endl;\n\n\tvector<int> ans;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\tEdge& e = G[i][j];\n\t\t\tif (e.cap == 0) {\n\t\t\t\tif (tbl.find(P(e.to, i)) != tbl.end()) {\n\t\t\t\t\tans.push_back(tbl[P(e.to, i)]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\tcout << ans.size() << endl;\n\tfor (int i = 0; i < ans.size(); ++i) {\n\t\tcout << ans[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 511 , M = 100011 , INF = (int)1e9;\n\nclass Edge\n{\n    public:\n    int id , s , t , cf , next;\n    Edge(){}\n    Edge(int _id , int _s,int _t,int _cf):id(_id),s(_s),t(_t),cf(_cf){}\n}e[M];\n\nint first[N] , e_cnt , n , m;\n\nint h[N] , gap[N] , cur[N] , sc ,sk;\n\nbool vis[N][N];\n\nvoid init()\n{\n    for(int i=1;i<=N;i++)\n       first[i] = -1;\n    e_cnt = 0;\n}\n\nvoid insert(int id , int s,int t,int cf)\n{\n    e[e_cnt] = Edge(id,s,t,cf);\n    e[e_cnt].next = first[s] ;  first[s] = e_cnt++;\n}\nint check(int s,int low)\n{\n      if(s==sk) return low;\n      for(int i=cur[s],flow;i+1;i=e[i].next)\n      {\n            int t=e[i].t;\n            if(e[i].cf && h[s]==h[t]+1 && (flow=check(t,low<e[i].cf?low:e[i].cf)))\n            {\n                e[i].cf-=flow;\n                e[i^1].cf+=flow;\n                cur[s]=i;\n                return flow;\n            }\n            if(h[sc]>=n) return 0;\n      }\n      int mn=n;\n      for(int i=first[s];i+1;i=e[i].next)\n      {\n          int t=e[i].t;\n          if(e[i].cf && h[t]+1<mn) mn=h[t]+1;\n      }\n      gap[mn]++;gap[h[s]]--;\n      if(gap[h[s]]<=0) h[sc]=n;\n      h[s]=mn;\n      if(mn!=n) cur[s]=first[s];\n      return 0;\n}\n\nint sap()\n{\n    int res=0;\n    memset(h,0,sizeof(h));\n    for(int i=1;i<=n;i++)\n    {\n        cur[i]=first[i];\n        gap[i]=0;\n    }\n    gap[0]=n;\n    while(h[sc]<n) res+=check(sc,INF);\n    return res;\n}\n\nvoid sol()\n{\n    vector<int> v;\n    v.clear();\n    for(int i=0;i<e_cnt;i++)\n        if( e[i].cf == 0  && vis[e[i].s][e[i].t] == 0)\n            v.push_back(e[i].id);\n    sort(v.begin() , v.end());\n    unique(v.begin(),v.end());\n    printf(\"%d\\n\",v.size());\n    for(int i=0;i<v.size();i++)\n        printf(\"%d\\n\",v[i]);\n}\n\nint main()\n{\n//    freopen(\"std.in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&m)!=-1)\n    {\n        init();\n        memset(vis,0,sizeof(vis));\n        int s , t;\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&s,&t);\n            insert(i , s , t , 1 );\n            insert(i , t , s , 1);\n            vis[s][t] = 1;\n        }\n        scanf(\"%d%d\",&sc,&sk);\n        printf(\"%d\\n\",sap());\n        sol();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\n\n\nstruct tumiki {\n\tlong long int x;\n\tlong long int y;\n\tlong long int id;\n};\n\nclass Compare {\npublic:\n\tbool operator()(const pair<int,long long  int>&l, const pair<int, long long int >&r) {\n\t\treturn l.second > r.second;\n\t}\n};\n\nstruct island {\n\tint id;\n\tint sink;\n\tvector<pair<int,int> >edges;\n\tisland(int N):edges(N) {\n\n\t}\n};\n\n\n\n\n#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = 2147483647;\n\ntypedef int Weight;\nstruct Edge {\n\tint id;\n\tbool real;\n\tint src, dst;\n\tWeight weight;\n\tEdge(bool real,int id,int src, int dst, Weight weight) :\n\t\tid(id),real(real),src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\nvector<pair<int, int>>uses;\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &g, int s, int t) {\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tint now = t;\n\t\twhile (prev[now]!=now&&prev[now]!=-1) {\n\t\t\tuses.push_back({ prev[now], now });\n\t\t\tnow = prev[now];\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tGraph g(N);\n\t\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tg[x].push_back(Edge(true,i,x, y, 1));\n\t\tg[y].push_back(Edge(false, i,y, x, 1));\n\t}\n\tint S, T; cin >> S >> T;\n\tS--; T--;\n\tint ans=maximumFlow(g, S, T);\n\n\tvector<int>changes(M, 1);\n\tfor (int i = 0; i < uses.size(); ++i) {\n\t\tfor (int j = 0; j < g[uses[i].first].size(); ++j) {\n\t\t\tif (g[uses[i].first][j].dst == uses[i].second){\n\t\t\t\tif (g[uses[i].first][j].real) {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvector<int>cs;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (changes[i] == 0) {\n\t\t\tcs.push_back(i + 1);\n\t\t}\n\t}\n\tcout << ans << endl << cs.size() << endl;\n\tfor (int i = 0; i < cs.size(); ++i) {\n\t\tcout << cs[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {\n    int to, cap, rev;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint dfs(graph& g, vector<bool>& used, int v, int t, int f) {\n    if(v == t) {\n        return f;\n    }\n    used[v] = true;\n    for(int i=0; i<g[v].size(); ++i) {\n        edge& e = g[v][i];\n        if(!used[e.to] && e.cap > 0) {\n            int d = dfs(g, used, e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                g[e.to][e.rev].cap = d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(graph& g, int s, int t) {\n    int flow = 0;\n    int INF = 1e9;\n    vector<bool> used(g.size());\n    while(true) {\n        fill(used.begin(), used.end(), false);\n        int f = dfs(g, used, s, t, INF);\n        if(f == 0) {\n            return flow;\n        }\n        flow += f;\n    }\n}\n\npair<int, int> add_edge(graph& g, int from, int to, int cap) {\n    g[from].push_back(edge{to, cap, static_cast<int>(g[to].size())});\n    g[to].push_back(edge{from, 0, static_cast<int>(g[from].size()-1)});\n    return make_pair(from, (int)g[from].size()-1);\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    graph g(N);\n    vector<pair<int, int>> idx(M);\n    for(int i=0; i<M; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        add_edge(g, x, y, 1);\n        idx[i] = add_edge(g, y, x, 1);\n    }\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    int flow = max_flow(g, s, t);\n    vector<int> res;\n    for(int i=0; i<M; ++i) {\n        if(g[idx[i].first][idx[i].second].cap == 0) {\n            res.push_back(i+1);\n        }\n    }\n    cout << flow << endl;\n    cout << res.size() << endl;\n    for(auto x : res) {\n        cout << x << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  //int level[333], iter[333];\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V), iter(V){};\n  /*\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  */\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    fill(level.begin(), level.end(), -1);\n    //memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G[v].size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(iter.begin(), iter.end(), 0);\n      //memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <climits>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MAX_N = 300;\nconst int MAX_M = MAX_N * (MAX_N - 1) / 2;\n\nint n, m;\nint s, t;\nint capacity[MAX_N][MAX_N];\nint flow[MAX_N][MAX_N];\nvector<int> graph[MAX_N];\n\nbool used[MAX_N];\nint dfs(int from, int to, int f) {\n\tif (from == to) return f;\n\tused[from] = true;\n\tfor (unsigned i = 0; i < graph[from].size(); i++) {\n\t\tconst int next = graph[from][i];\n\t\tconst int cap = capacity[from][next];\n\t\tif (!used[next] && cap - flow[from][next] > 0) {\n\t\t\tconst int d = dfs(next, t, min(f, cap));\n\t\t\tif (d > 0) {\n\t\t\t\tflow[from][next] += d;\n\t\t\t\tflow[next][from] -= d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow() {\n\tint res = 0;\n\twhile (true) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INT_MAX);\n\t\tif (f == 0) return res;\n\t\tres += f;\n\t}\n}\n\nint main () {\n\tvector<pair<int, int> > edges;\n\t\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tcapacity[x][y]++;\n\t\tcapacity[y][x]++;\n\t\tedges.push_back(make_pair(x, y));\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tcin >> s >> t;\n\ts--; t--;\n\t\n\tcout << max_flow() << endl;\n\t\n\tvector<int> ans;\n\tfor (int i = 0; i < m; i++) {\n\t\tpair<int, int>& e = edges[i];\n\t\tif (flow[e.second][e.first] > 0) {\n\t\t\tans.push_back(i);\n\t\t}\n\t}\n\tcout << ans.size() << endl;\n\tfor (unsigned i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint n,m,cap[300][300];\nvector<bool> used(300);\n\nint dfs(int v,int t,int f){\n    if(v==t) return f;\n    used[v]=true;\n    rep(i,0,n){\n        if(used[i] or !cap[v][i]) continue;\n        int d=dfs(i,t,f);\n        if(d>0){\n            cap[v][i]-=d;\n            if(!cap[i][v]) cap[i][v]+=d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow=0;\n    while(true){\n        fill(used.begin(),used.end(),false);\n        int f=dfs(s,t,1);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\nvoid solve(){\n    int s,t;\n    cin >> n >> m;\n\n    vector<pii> edges;\n    rep(i,0,m){\n        int x,y;\n        cin >> x >> y;\n        --x;\n        --y;\n        cap[x][y]=1;\n        cap[y][x]=1;\n        edges.emplace_back(make_pair(x,y));\n    }\n    cin >> s >> t;\n    --s;\n    --t;\n\n    cout << max_flow(s,t) << endl;\n    vector<int> ids;\n    rep(i,0,m) if(cap[edges[i].first][edges[i].second] and !cap[edges[i].second][edges[i].first]) ids.emplace_back(i+1);\n    cout << ids.size() << endl;\n    for(const auto id:ids) cout << id << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n\nint MaxFlow(const Graph &g, int s, int t, Matrix &flow) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  flow = Matrix(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.front();\n      que.pop();\n      if (parent[node.dest] != -1) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight f = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      f = min(f, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      flow[from][to] += f;\n      flow[to][from] -= f;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += f;\n  }\n  return ret;\n}\n\nvoid AddEdge(Graph &g, int from, int to, Weight capacity) {\n  g[from].push_back(Edge(from, to, capacity));\n  g[to].push_back(Edge(to, from, capacity));\n}\n\nint main() {\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    Graph g(n);\n    vector<Edge> edges;\n    REP(i, m) {\n      int f, t;\n      scanf(\"%d %d\", &f, &t);\n      f--; t--;\n      AddEdge(g, t, f, 1);\n      edges.push_back(Edge(f, t, 1));\n    }\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    s--; t--;\n    Matrix flow;\n    int f = MaxFlow(g, s, t, flow);\n    vector<int> ans;\n    REP(i, m) {\n      if (flow[edges[i].dest][edges[i].src] == 1) { ans.push_back(i + 1); }\n    }\n    printf(\"%d\\n%d\\n\", f, (int)ans.size());\n    FORIT(it, ans) {\n      printf(\"%d\\n\", *it);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//qscqesze\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <bitset>\n#include <vector>\n#include <sstream>\n#include <queue>\n#include <typeinfo>\n#include <fstream>\n#include <map>\n#include <stack>\ntypedef long long ll;\nusing namespace std;\n//freopen(\"D.in\",\"r\",stdin);\n//freopen(\"D.out\",\"w\",stdout);\n#define sspeed ios_base::sync_with_stdio(0);cin.tie(0)\n#define maxn 200500\n#define mod 1001\n#define eps 1e-9\n#define pi 3.1415926\nint Num;\n//const int inf=0x7fffffff;\nconst ll inf=999999999;\ninline ll read()\n{\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n//*************************************************************************************\nconst int MAXN = 1000;\nconst int MAXM = 150000;\nconst int INF = 0x3f3f3f3f;\nstruct Edge\n{\n    int to, next, cap, flow, cost, id;\n    int x, y;\n} edge[MAXM],HH[MAXN],MM[MAXN];\nint head[MAXN],tol;\nint pre[MAXN],dis[MAXN];\nbool vis[MAXN];\nint N, M;\nchar map[MAXN][MAXN];\nvoid init()\n{\n    N = MAXN;\n    tol = 0;\n    memset(head, -1, sizeof(head));\n}\nvoid addedge(int u, int v, int cap, int cost,int id)//左端点，右端点，容量，花?, ?号\n{\n    edge[tol]. to = v;\n    edge[tol]. cap = cap;\n    edge[tol]. cost = cost;\n    edge[tol]. flow = 0;\n    edge[tol]. next = head[u];\n    edge[tol].id = id;\n    head[u] = tol++;\n    edge[tol]. to = u;\n    edge[tol]. cap = 0;\n    edge[tol]. cost = -cost;\n    edge[tol]. flow = 0;\n    edge[tol]. next = head[v];\n    edge[tol].id = id;\n    head[v] = tol++;\n}\nbool spfa(int s, int t)\n{\n    queue<int>q;\n    for(int i = 0; i < N; i++)\n    {\n        dis[i] = INF;\n        vis[i] = false;\n        pre[i] = -1;\n    }\n    dis[s] = 0;\n    vis[s] = true;\n    q.push(s);\n    while(!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        vis[u] = false;\n        for(int i = head[u]; i != -1; i = edge[i]. next)\n        {\n            int v = edge[i]. to;\n            if(edge[i]. cap > edge[i]. flow &&\n                    dis[v] > dis[u] + edge[i]. cost )\n            {\n                dis[v] = dis[u] + edge[i]. cost;\n                pre[v] = i;\n                if(!vis[v])\n                {\n                    vis[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if(pre[t] == -1) return false;\n    else return true;\n}\n//返回的是最大流， cost存的是最小?用\nvector<int> ans;\nint minCostMaxflow(int s, int t, int &cost)\n{\n    int flow = 0;\n    cost = 0;\n    while(spfa(s,t))\n    {\n        int Min = INF;\n        for(int i = pre[t]; i != -1; i = pre[edge[i^1]. to])\n        {\n            if(Min > edge[i]. cap - edge[i]. flow)\n                Min = edge[i]. cap - edge[i]. flow;\n        }\n        for(int i = pre[t]; i != -1; i = pre[edge[i^1]. to])\n        {\n            edge[i]. flow += Min;\n            edge[i^1]. flow -= Min;\n            cost += edge[i]. cost * Min;\n        }\n        flow += Min;\n    }\n    return flow;\n}\n\nvector<int> Q;\nint main()\n{\n    init();\n    int n=read(),m=read();\n    for(int i=0;i<m;i++)\n    {\n        int x=read(),y=read();\n        addedge(x,y,1,0,i+1);\n        addedge(y,x,1,1,i+1);\n    }\n    int s=read(),t=read();\n    int ans1 = 0,ans2 = 0;\n    ans1 = minCostMaxflow(s,t,ans2);\n\n    for(int i=1;i<=n;i++)\n    {\n        for(int j = head[i]; j != -1; j = edge[j]. next)\n        {\n            if(edge[j].flow == 1)\n            {\n                if(edge[j].cost)\n                {\n                    Q.push_back(edge[j].id);\n                }\n            }\n        }\n    }\n\n\n    printf(\"%d\\n%d\\n\",ans1,ans2);\n    for(int i=0;i<Q.size();i++)\n        printf(\"%d\\n\",Q[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\nconst int INF = 1 << 29;\n\nstruct Edge {\n  int to, cap, cost, rev;\n  Edge(int t, int ca, int co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\nusing Graph = vector< vector<Edge> >;\n\nstruct Flow {\n  vector< vector<Edge> > G;\n  const int MAXC = 1 << 29;\n  int n;\n  vector<bool> used;\n  vector<int> prevv, preve, dist;\n  Flow(int n_) : G(n_), n(n_), used(n_, false),\n                 prevv(n_), preve(n_), dist(n_, MAXC) {}\n\n  void add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to  ].push_back(Edge(from, 0, -cost, G[from].size() - 1));\n  }\n\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++) {\n      Edge &e = G[v][i];\n      if(!used[e.to] and e.cap > 0) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while(1) {\n      fill(used.begin(), used.end(), false);\n      int f = dfs(s, t, INF);\n      if(f == 0) return flow;\n      flow += f;\n    }\n  }\n\n  int mincost_flow(int s, int t, int f) {\n    int res = 0;\n    int ma = MAXC;\n    while(f > 0) {\n      fill(dist.begin(), dist.end(), ma);\n      dist[s] = 0;\n      bool update = true;\n      while(update) {\n        update = false;\n        for(int v=0; v<n; v++) {\n          if(dist[v] == ma) continue;\n          for(int i=0; i<G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if(e.cap > 0 and dist[e.to] > dist[v] + e.cost) {\n              dist[e.to ] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if(dist[t] == ma) return -1;\n      int d = f;\n      for(int v=t; v!=s; v=prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for(int v=t; v!=s; v=prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  int N, M; cin >> N >> M;\n\n  Flow fl1(N), fl2(N);\n  vector< vector< pair<int, int> > > rec(N);\n  vector<int> cnt(N);\n  for(int i=0; i<M; i++) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    \n    fl1.add_edge(u, v, 1, 0);\n    fl1.add_edge(v, u, 1, 1);\n    \n    fl2.add_edge(u, v, 1, 0);\n    cnt[u]++; cnt[v]++;\n\n    {\n      int k = cnt[v];\n      rec[v].emplace_back(i, k);\n    }\n    fl2.add_edge(v, u, 1, 1);\n    cnt[u]++; cnt[v]++;\n  }\n\n  int source, sink; cin >> source >> sink;\n  source--, sink--;\n\n  int flow = fl1.max_flow(source, sink);\n  cout << flow << endl;\n\n  int edges = fl2.mincost_flow(source, sink, flow);\n  cout << edges << endl;\n\n  vector<int> ans;\n  for(int i=0; i<N; i++) {\n    for(auto e : rec[i]) {\n      int edge_id, rev_id; tie(edge_id, rev_id) = e;\n      if(fl2.G[i][rev_id].cap == 0) {\n        Edge e = fl2.G[i][rev_id];\n        // fprintf(stderr, \"cap = %d, cost = %d, rev = %d\\n\", e.cap, e.cost, e.rev);\n        // fprintf(stderr, \"u = %d, v = %d\\n\", i + 1, e.to + 1);\n        ans.emplace_back(edge_id);\n      }\n    }\n  }\n\n  assert(edges == ans.size());\n\n  for(auto e : ans) cout << e + 1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntemplate<class T>\nstruct FordFulkerson{\n\tstruct Edge{\n\t\tint to,rev,id;\n\t\tbool isRev;\n\t\tT cap;\n\t\tEdge(int to,T cap,int rev,int id,bool isRev) : to(to),rev(rev),cap(cap),isRev(isRev),id(id){}\n\t};\n\n\tvector<vector<Edge>> G;\n\tvector<bool> used;\n\n\tFordFulkerson(int n) : G(n),used(n){}\n\n\tvoid addEdge(int from,int to,T cap,int id,bool isDirected = true){\n\t\tG[from].emplace_back(to,cap,G[to].size(),id,false);\n\t\tG[to].emplace_back(from,isDirected ? 0 : cap,G[from].size() - 1,id,true);\n\t}\n\n\tT dfs(int v,int t,T f){\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor(auto &e : G[v]){\n\t\t\tif(!used[e.to] && e.cap){\n\t\t\t\tT d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tT flow(int s,int t){\n\t\tT ret = 0;\n\t\twhile(1){\n\t\t\tfill(used.begin(),used.end(),0);\n\t\t\tT f = dfs(s,t,numeric_limits<T>::max());\n\t\t\tif(!f) return ret;\n\t\t\tret += f;\n\t\t}\n\t}\n};\n\nsigned main(){\n\tint n,m,s,t;\n\tcin >> n >> m;\n\tFordFulkerson<int> ff(n);\n\tfor(int i = 0;i < m;i++){\n\t\tint x,y;\n\t\tcin >> x >> y; x--;y--;\n\t\tff.addEdge(x,y,1,i,false);\n\t}\n\tcin >> s >> t; s--;t--;\n\tcout << ff.flow(s,t) << endl;\n\tvector<int> rev;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(const auto &e : ff.G[i]){\n\t\t\tif(e.cap == 2 && !e.isRev) rev.push_back(e.id);\n\t\t}\n\t}\n\tcout << rev.size() << endl;\n\tfor(int v : rev) cout << v + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 511 , M = 100011 , INF = 0x7fffffff;\n\nclass Edge\n{\n    public:\n    int id , s , t , cf , next;\n    Edge(){}\n    Edge(int _id , int _s,int _t,int _cf):id(_id),s(_s),t(_t),cf(_cf){}\n}e[M];\n\nint first[N] , e_cnt , n , m;\n\nint h[N] , gap[N] , cur[N] , sc ,sk;\n\nbool vis[N][N];\n\nvoid init()\n{\n    for(int i=1;i<=N;i++)\n       first[i] = -1;\n    e_cnt = 0;\n}\n\nvoid insert(int id , int s,int t,int cf)\n{\n    e[e_cnt] = Edge(id,s,t,cf);\n    e[e_cnt].next = first[s] ;  first[s] = e_cnt++;\n}\nint check(int s,int low)\n{\n      if(s==sk) return low;\n      for(int i=cur[s],flow;i+1;i=e[i].next)\n      {\n            int t=e[i].t;\n            if(e[i].cf && h[s]==h[t]+1 && (flow=check(t,low<e[i].cf?low:e[i].cf)))\n            {\n                e[i].cf-=flow;\n                e[i^1].cf+=flow;\n                cur[s]=i;\n                return flow;\n            }\n            if(h[sc]>=n) return 0;\n      }\n      int mn=n;\n      for(int i=first[s];i+1;i=e[i].next)\n      {\n          int t=e[i].t;\n          if(e[i].cf && h[t]+1<mn) mn=h[t]+1;\n      }\n      gap[mn]++;gap[h[s]]--;\n      if(gap[h[s]]<=0) h[sc]=n;\n      h[s]=mn;\n      if(mn!=n) cur[s]=first[s];\n      return 0;\n}\n\nint sap()\n{\n    int res=0;\n    memset(h,0,sizeof(h));\n    for(int i=1;i<=n;i++)\n    {\n        cur[i]=first[i];\n        gap[i]=0;\n    }\n    gap[0]=n;\n    while(h[sc]<n) res+=check(sc,INF);\n    return res;\n}\n\nvoid sol()\n{\n    vector<int> v;\n    v.clear();\n    for(int i=0;i<e_cnt;i+=2)\n        if( e[i^1].cf == 0)\n            v.push_back(e[i^1].id);\n    sort(v.begin() , v.end());\n    unique(v.begin(),v.end());\n    int cnt = 0;\n    for(int i=0;i<v.size();i++)\n        if(v[i] != v[i-1]) cnt++;\n    printf(\"%d\\n\",cnt);\n    for(int i=0;i<cnt;i++)\n        printf(\"%d\\n\",v[i]);\n}\n\nint main()\n{\n//    freopen(\"std.in\",\"r\",stdin);\n//cout<<INF<<endl;\n    while(scanf(\"%d%d\",&n,&m)!=-1)\n    {\n        init();\n        memset(vis,0,sizeof(vis));\n        int s , t;\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&s,&t);\n            insert(i , s , t , 1 );\n            insert(i , t , s , 1);\n            vis[s][t] = 1;\n        }\n        scanf(\"%d%d\",&sc,&sk);\n        printf(\"%d\\n\",sap());\n        sol();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst int NN=50*50*2+1;\n\nstruct edge\n{\n\tint s;\n\tint t;\n\tint st;\n\tint ts;\n\tint init;\n\tint nex(int a){\n\t\treturn a==s?t:s;\n\t}\n\tint res(int a){\n\t\treturn a==s?st:ts;\n\t}\n\tvoid use(int a, int v){\n\t\tif(a==s){\n\t\t\tst-=v;\n\t\t\tts+=v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tst+=v;\n\t\t\tts-=v;\n\t\t}\n\t}\n};\ntypedef vector<edge*>::iterator It;\ntemplate<int NN, int MM>\nstruct MaxFlow\n{\n\tedge es[MM];\n\tint esize;\n\tvector<edge*> edges[NN];\n\tvoid add(int a, int b, int v)\n\t{\n\t\tes[esize].s=a;\n\t\tes[esize].t=b;\n\t\tes[esize].st=v;\n\t\tes[esize].ts=v;\n\t\tes[esize].init=v;\n\t\tedges[a].push_back(es+esize);\n\t\tedges[b].push_back(es+esize);\n\t\tesize++;\n\t}\n\tedge* pre[NN];\n\tint done[NN];\n\tint q[NN];\n\tint s;\n\tint t;\n\tint flow()\n\t{\n\tint ret=0;\n\tint f=0;\n\twhile(1){\n\t\tf++;\n\t\tint qs=0;\n\t\tint qe=1;\n\t\tq[0]=s;\n\t\tdone[s]=f;\n\t\twhile(qs<qe){\n\t\t\tint top=q[qs++];\n\t\t\tfor(It it=edges[top].begin();it!=edges[top].end();it++){\n\t\t\t\tint nex=(*it)->nex(top);\n\t\t\t\tif((*it)->res(top)&&done[nex]!=f){\n\t\t\t\t\tq[qe++]=nex;\n\t\t\t\t\tpre[nex]=*it;\n\t\t\t\t\tdone[nex]=f;\n\t\t\t\t\tif(nex==t){\n\t\t\t\t\t\tgoto OK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\nOK:\n\t\tint p=t;\n\t\tint res=INT_MAX;\n\t\twhile(p!=s){\n\t\t\tint pp=pre[p]->nex(p);\n\t\t\tres=min(res,pre[p]->res(pp));\n\t\t\tp=pp;\n\t\t}\n\t\tp=t;\n\t\twhile(p!=s){\n\t\t\tint pp=pre[p]->nex(p);\n\t\t\tpre[p]->use(pp,res);\n\t\t\tp=pp;\n\t\t}\n\t\tret+=res;\n\t}\n\treturn ret;\n\t}\n};\n\nMaxFlow<300, 1000> mf;\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tfor(int i=0;i<M;i++){\n\t\tint X,Y;\n\t\tcin >> X >> Y;\n\t\tmf.add(X,Y,1);\n\t}\n\tcin >> mf.s >> mf.t;\n\tcout << mf.flow() << endl;\n\tint rev=0;\n\tfor(int i=0;i<mf.esize;i++){\n\t\tif(mf.es[i].st>mf.es[i].init){\n\t\t\trev++;\n\t\t}\n\t}\n\tcout << rev << endl;\n\tfor(int i=0;i<mf.esize;i++){\n\t\tif(mf.es[i].st>mf.es[i].init){\n\t\t\tcout << i+1<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* monkukui 競技プログラミング用のテンプレート  (ここから) */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nusing ll = long long int;\nusing lnt = long long int;\nusing graph = vector<vector<int>>;\nusing wgraph = vector<vector<pair<int, long long int>>>;\nlong long int INF = 1001001001001001LL;\nint inf = 100100100;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\nlong long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nlong long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ninline void yes(){ cout << \"yes\" << endl; }\ninline void Yes(){ cout << \"Yes\" << endl; }\ninline void YES(){ cout << \"YES\" << endl; }\ninline void no(){ cout << \"no\" << endl; }\ninline void No(){ cout << \"No\" << endl; }\ninline void NO(){ cout << \"NO\" << endl; }\ninline void possible(){ cout << \"possible\" << endl; }\ninline void Possible(){ cout << \"Possible\" << endl; }\ninline void POSSIBLE(){ cout << \"POSSIBLE\" << endl; }\ninline void impossible(){ cout << \"impossible\" << endl; }\ninline void Impossible(){ cout << \"Impossible\" << endl; }\ninline void IMPOSSIBLE(){ cout << \"IMPOSSIBLE\" << endl; }\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = 1; i <= (n); i++)\n#define drep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define srep(i,s,t) for(int i = s; i < t; i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n\n/* monkukui 競技プログラミング用のテンプレート (ここまで)*/\n\n\n// verified : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_A\n// O(E V^2)\n\n// [使い方]\n// add_edge(from, to, cap) :  from から to へ 容量 cap の辺を貼る\n// max_flow(s, t) :  s から t への最大フローを返す\n\ntemplate< typename T >\nstruct Dinic{\n    const T inf;\n\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n        bool isrev;\n    };\n\n    vector<vector<edge>> g;\n    vector<int> min_cost, iter;\n\n    Dinic(int V) : inf(numeric_limits<T>::max()), g(V){}\n\n\n    // 0-indexed\n    void add_edge(int from, int to, T cap){\n        g[from].emplace_back((edge){to, cap, (int)g[to].size(), false});\n        g[to].emplace_back((edge){from, 0, (int)g[from].size() - 1, true});\n    }\n\n    bool bfs(int s, int t) {\n        min_cost.assign(g.size(), -1);\n        queue<int> que;\n        min_cost[s] = 0;\n        que.push(s);\n        while(!que.empty() && min_cost[t] == -1){\n            int p = que.front();\n            que.pop();\n            for(auto &e : g[p]) {\n                if(e.cap > 0 && min_cost[e.to] == -1){\n                    min_cost[e.to] = min_cost[p] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return min_cost[t] != -1;\n    }\n    \n    T dfs(int idx, const int t, T flow){\n        if(idx == t) return flow;\n        for(int &i = iter[idx]; i < g[idx].size(); i++){\n            edge &e = g[idx][i];\n            if(e.cap > 0 && min_cost[idx] < min_cost[e.to]){\n                T d = dfs(e.to, t, min(flow, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    // 0-indexed\n    T max_flow(int s, int t){\n        T flow = 0;\n        while(bfs(s, t)){\n            iter.assign(g.size(), 0);\n            T f = 0;\n            while((f = dfs(s, t, inf)) > 0) flow += f;\n        }\n\n        return flow;\n    }\n    \n    void output(vector<vector<int>> &A) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &e : g[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = g[e.to][e.rev];\n                //cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n                if(rev_e.cap == 1) A[i][e.to] = 1;\n            }\n        }\n    }\n};\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  Dinic<int> dc(n);\n  set<pair<int, int>> st;\n  map<pair<int, int>, int> mp;\n\n  for(int i = 0; i < m; i++) {\n    int u, v; cin >> u >> v;\n    u--;\n    v--;\n    st.insert({u, v});\n    mp[make_pair(u, v)] = i + 1;\n    dc.add_edge(u, v, 1);\n    dc.add_edge(v, u, 1);\n  }\n  \n\n  int s, t; cin >> s >> t;\n  s--;\n  t--;\n  auto hoge = dc.max_flow(s, t);\n  cout << hoge << endl;\n\n  vector<int> ans;\n  vector<vector<int>> A(500, vector<int> (500, 0));\n  dc.output(A);\n  for(int i = 0; i < 500; i++) {\n    for(int j = 0; j < 500; j++) {\n      if(A[i][j] == 1 and A[j][i] == 1) {\n        A[i][j] = 0;\n        A[j][i] = 0;\n      }\n    }\n  }\n  \n  for(int i = 0; i < 500; i++) {\n    for(int j = 0; j < 500; j++) {\n      if(A[i][j] == 1) {\n        if(st.find({i, j}) == st.end()) ans.push_back(mp[make_pair(j, i)]);\n      }\n    }\n  }\n\n  cout << ans.size() << endl;\n  for(auto val : ans) cout << val << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n* E.cpp\n*\n*  Created on: Oct 9, 2012\n*      Author: carber\n*/\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int N = 333;\nconst int E = 45000;\n\n#define typec int                   // type of cost \nconst typec inf = 0x3f3f3f3f;       // max of cost \nstruct edge { int x, y, nxt; typec c; } bf[E]; \nint ne, head[N], cur[N], ps[N], dep[N]; \nvoid addedge(int x, int y, typec c) \n{  // add an arc(x -> y, c); vertex: 0 ~ n-1; \n    bf[ne].x = x; bf[ne].y = y; bf[ne].c = c; \n    bf[ne].nxt = head[x]; head[x] = ne++; \n    bf[ne].x = y; bf[ne].y = x; bf[ne].c = c; \n    bf[ne].nxt = head[y]; head[y] = ne++; \n} \ntypec flow(int n, int s, int t) \n{ \n    typec tr, res = 0; \n    int i, j, k, f, r, top; \n    while (1) { \n        memset(dep, -1, n * sizeof(int)); \n        for (f = dep[ps[0] = s] = 0, r = 1; f != r; ) \n            for (i = ps[f++], j = head[i]; j; j = bf[j].nxt) \n            { \n                if (bf[j].c && -1 == dep[k = bf[j].y]){ \n                    dep[k] = dep[i] + 1; ps[r++] = k; \n                    if (k == t) { f = r; break; } \n                } \n            } \n            if (-1 == dep[t]) break; \n\n            memcpy(cur, head, n * sizeof(int)); \n            for (i = s, top = 0; ; ) { \n                if (i == t) { \n                    for (k = 0, tr = inf; k < top; ++k) \n                        if (bf[ps[k]].c < tr) \n                            tr = bf[ps[f = k]].c; \n                    for (k = 0; k < top; ++k) \n                        bf[ps[k]].c -= tr, bf[ps[k]^1].c += tr; \n                    res += tr;  i = bf[ps[top = f]].x; \n                } \n                for  (j=cur[i]; cur[i]; j = cur[i] = bf[cur[i]].nxt) \n                    if  (bf[j].c && dep[i]+1 == dep[bf[j].y])  break; \n                if (cur[i]) { \n                    ps[top++] = cur[i]; \n                    i = bf[cur[i]].y; \n                } \n                else { \n                    if (0 == top) break; \n                    dep[i] = -1; i = bf[ps[--top]].x; \n                } \n            } \n    } \n    return res; \n}\n\n#include <vector>\nvoid solved(int nT) {\n    int n, m, u, v;\n    while (EOF != scanf(\"%d %d\", &n, &m)) {\n        ne = 2, memset(head, 0, sizeof(head));\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", &u, &v);\n            --u, --v;\n            if (u == v) while (true);\n            addedge(u, v, 1);\n        }\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        --s, --t;\n        int result = flow(n, s, t);\n        vector<int> ret;\n        for (int se = 2; se < ne; se += 2) {\n            if (bf[se].c == 2) ret.push_back(se >> 1);\n        }\n        printf(\"%d\\n\", result);\n        printf(\"%d\\n\", (int)ret.size());\n        for (int i = 0; i < (int)ret.size(); ++i) {\n            printf(\"%d\\n\", ret[i]);\n        }\n    }\n}\n\nint main() {\n    int T = 1;\n    for (int nT = 1; nT <= T; ++nT) {\n        solved(nT);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAXV = 300;\nconst int MAXE = MAXV * MAXV;\nconst int MAXF = (1<<29);\ntypedef int F;\n\nstruct MaxFlow {\n    F cap[MAXE], flow[MAXE];\n    int V, E, level[MAXV], prev[MAXE], edge[MAXV], to[MAXE];\n    MaxFlow(int n) : E(0), V(n) {\n        memset(prev, -1, sizeof(prev));\n        memset(edge, -1, sizeof(edge));\n    }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // make level graph (bfs)\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    int augment(int s, int t, F f) { // find augment path (dfs)\n        if (s == t || f == 0) return f;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f, cap[e] - flow[e]));\n                if (g > 0) {\n                    flow[e] += g, flow[e^1] -= g;\n                    return g;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int f, ret = 0;\n        for (bool cont = true; cont; ) {\n            cont = false;\n            make_level(s);\n            while ((f = augment(s, t, MAXF)) > 0) {\n                cont = true;\n                ret += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int x[MAXE], y[MAXE];\n    int N,M,a,b;\n    cin>>N>>M;\n    MaxFlow mf(N);\n    for (int i=0; i<M; ++i) {\n        cin>>a>>b; a--, b--;\n        mf.add_edge(a, b, 1, 1);\n        x[i] = a, y[i] = b;\n    }\n    cin>>a>>b; a--, b--;\n    cout<<mf.max_flow(a, b)<<endl;\n    vector<int> rev;\n    for (int i=0; i<M; ++i) {\n        int e = mf.edge[y[i]];\n        while(e != -1) {\n            if (mf.to[e] == x[i] && mf.flow[e] > 0) rev.push_back(i);\n            e = mf.prev[e];\n        }\n    }\n    cout<<rev.size()<<endl;\n    for (int i=0; i<rev.size(); ++i) cout<<rev[i]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass Edge\n{\npublic:\n  int to, cap, rev, idx;\n  bool isRev;\n  Edge(int _to = 0, int _cap = 0, int _rev = 0, int _idx = 0, bool _isRev = false)\n    :to(_to), cap(_cap), rev(_rev), idx(_idx), isRev(_isRev) {} \n};\n\nvoid add_edge(vector<vector<Edge> >& g, int from, int to, int cap, int idx, bool isRev)\n{\n  g[from].push_back(Edge(to, cap, g[to].size(), idx, isRev));\n  g[to].push_back(Edge(from, 0, g[from].size()-1, idx, isRev));\n}\n\nint ff(vector<vector<Edge> >& g, vector<int>& used, int s, int t, int f, vector<int>& rev)\n{\n  if (s == t)\n    return f;\n  used[s] = 1;\n  \n  for (unsigned int i = 0; i < g[s].size(); ++i) {\n    Edge& e = g[s][i];\n    if (!used[e.to] && e.cap > 0) {\n      int d = ff(g, used, e.to, t, min(f, e.cap), rev);\n      if (d > 0) {\n\tif (e.isRev)\n\t  rev.push_back(e.idx);\n\te.cap -= d;\n\tg[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint solve(vector<vector<Edge> >& g, int s, int t, vector<int>& rev)\n{\n  int flow = 0;\n  for ( ; ; ) {\n    vector<int> used(g.size(), 0);\n    int f = ff(g, used, s, t, INF, rev);\n    if (f == 0)\n      return flow;\n    flow += f;\n  }\n}\n\nint main()\n{\n  int N, M;\n  while (~scanf(\"%d %d\", &N, &M)) {\n    vector<vector<Edge> > g(N);\n    for (int i = 0; i < M; ++i) {\n      int X, Y;\n      scanf(\"%d %d\", &X, &Y);\n      --X;\n      --Y;\n      add_edge(g, X, Y, 1, i+1, false);\n      add_edge(g, Y, X, 1, i+1, true);\n    }\n    int S, T;\n    scanf(\"%d %d\", &S, &T);\n    --S;\n    --T;\n\n    vector<int> rev;\n    printf(\"%d\\n\", solve(g, S, T, rev));\n    printf(\"%d\\n\", rev.size());\n    for (unsigned int i = 0; i < rev.size(); ++i)\n      printf(\"%d\\n\", rev[i]);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 333 , M = N*N*4 , INF = 0x7fffffff;\n\nclass Edge\n{\n    public:\n    int id , s , t , cf , next;\n    Edge(){}\n    Edge(int _id , int _s,int _t,int _cf):id(_id),s(_s),t(_t),cf(_cf){}\n}e[M];\n\nint first[N] , e_cnt , n , m;\n\nint h[N] , gap[N] , cur[N] , sc ,sk;\n\nbool vis[N][N];\n\nvoid init()\n{\n    for(int i=1;i<=N;i++)\n       first[i] = -1;\n    e_cnt = 0;\n}\n\nvoid insert(int id , int s,int t,int cf)\n{\n    e[e_cnt] = Edge(id,s,t,cf);\n    e[e_cnt].next = first[s] ;  first[s] = e_cnt++;\n}\nint check(int s,int low)\n{\n      if(s==sk) return low;\n      for(int i=cur[s],flow;i+1;i=e[i].next)\n      {\n            int t=e[i].t;\n            if(e[i].cf && h[s]==h[t]+1 && (flow=check(t,low<e[i].cf?low:e[i].cf)))\n            {\n                e[i].cf-=flow;\n                e[i^1].cf+=flow;\n                cur[s]=i;\n                return flow;\n            }\n            if(h[sc]>=n) return 0;\n      }\n      int mn=n;\n      for(int i=first[s];i+1;i=e[i].next)\n      {\n          int t=e[i].t;\n          if(e[i].cf && h[t]+1<mn) mn=h[t]+1;\n      }\n      gap[mn]++;gap[h[s]]--;\n      if(gap[h[s]]<=0) h[sc]=n;\n      h[s]=mn;\n      if(mn!=n) cur[s]=first[s];\n      return 0;\n}\n\nint sap()\n{\n    int res=0;\n    memset(h,0,sizeof(h));\n    for(int i=1;i<=n;i++)\n    {\n        cur[i]=first[i];\n        gap[i]=0;\n    }\n    gap[0]=n;\n    while(h[sc]<n) res+=check(sc,INF);\n    return res;\n}\n\nvoid sol()\n{\n    vector<int> v;\n    v.clear();\n    for(int i=0;i<e_cnt;i+=4)\n        if( e[i].cf == 1 && e[i+2].cf == 0)\n            v.push_back(e[i].id);\n    sort(v.begin() , v.end());\n    unique(v.begin(),v.end());\n    int cnt = 0;\n    for(int i=0;i<v.size();i++)\n        if(v[i] != v[i-1]) cnt++;\n    printf(\"%d\\n\",cnt);\n    for(int i=0;i<cnt;i++)\n        printf(\"%d\\n\",v[i]);\n}\n\nint main()\n{\n//    freopen(\"std.in\",\"r\",stdin);\n//cout<<INF<<endl;\n    while(scanf(\"%d%d\",&n,&m)!=-1)\n    {\n        init();\n//        memset(vis,0,sizeof(vis));\n        int s , t;\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&s,&t);\n            insert(i , s , t , 1 );\n            insert(i , t , s , 0);\n            insert(i , t , s , 1);\n            insert(i , s , t , 0);\n//            vis[s][t] = 1;\n        }\n        scanf(\"%d%d\",&sc,&sk);\n        printf(\"%d\\n\",sap());\n        sol();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  void add_undirected_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, cap, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  MaxFlow mf(N);\n  map<ll, ll> edges;\n  REP(i, 0, M) {\n    ll X, Y;\n    cin >> X >> Y;\n    X--;\n    Y--;\n    mf.add_undirected_edge(X, Y, 1);\n    edges[X * N + Y] = i;\n  }\n  ll S, T;\n  cin >> S >> T;\n  S--;\n  T--;\n\n  ll f = mf.max_flow(S, T);\n  vector<ll> idx;\n  REP(i, 0, N) {\n    for(auto e : mf.E[i]) {\n      if(edges.count(e.to * N + i) && e.cap == 0) {\n        idx.push_back(edges[e.to * N + i]);\n      }\n    }\n  }\n\n  cout << f << endl;\n  cout << idx.size() << endl;\n  for(auto i : idx) cout << i + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int to, cap, rev, id; bool is_rev; };\nint V, E, S, T; vector<int> used; vector<vector<edge> > G;\nvoid add_edge(int v1, int v2, int cap, int id) {\n\tG[v1].push_back(edge{ v2, cap, (int)G[v2].size(), id, false });\n\tG[v2].push_back(edge{ v1, 0, (int)G[v1].size() - 1, id, true });\n}\nint rec(int p, int t, int f) {\n\tif (p == t) return f;\n\tused[p] = 1;\n\tfor (auto &e : G[p]) {\n\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\tint res = rec(e.to, t, min(e.cap, f));\n\t\tif (res) {\n\t\t\te.cap -= res, G[e.to][e.rev].cap += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint ret = 0;\n\twhile (true) {\n\t\tused = vector<int>(V, 0);\n\t\tint res = rec(s, t, 2147483647);\n\t\tif (!res) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> V >> E; G.resize(V);\n\tvector<int> x1(E), x2(E);\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x1[i] >> x2[i]; x1[i]--, x2[i]--;\n\t\tadd_edge(x1[i], x2[i], 1, i);\n\t\tadd_edge(x2[i], x1[i], 1, -1);\n\t}\n\tcin >> S >> T; S--, T--;\n\tcout << max_flow(S, T) << endl;\n\tvector<int> ret;\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (edge e : G[i]) {\n\t\t\tif (e.is_rev && e.id >= 0 && e.cap == 0) ret.push_back(e.id);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\tcout << ret.size() << endl;\n\tfor (int i : ret) cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    level.clear(); level.resize(G.size(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge& e : G[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.clear(); iter.resize(G.size(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    each(e, dinic.G[v]) {\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  each(e, used_rev) cout << e+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntemplate< typename flow_t >\nstruct FordFulkerson {\n    struct edge {\n        int to;\n        flow_t cap;\n        int rev;\n        bool isrev;\n        int id;\n        edge(int to, flow_t cap, int rev, bool isrev, int id) :\n            to(to), cap(cap), rev(rev), isrev(isrev), id(id) {}\n        friend ostream& operator<<(ostream& os, const edge& e) {\n            return os << \"{to:\" << e.to << \",cap:\" << e.cap\n                      << \",isrev:\" << e.isrev << \"}\";\n        }\n    };\n\n    vector<vector<edge>> g;\n    vector<int> used;\n    const flow_t inf;\n    int timestamp;\n\n    FordFulkerson(int n) : inf(numeric_limits<flow_t>::max()), timestamp(0) {\n        g.resize(n);\n        used.assign(n, -1);\n    }\n\n    void add_edge(int src, int to, flow_t cap, int id) {\n        g[src].emplace_back(to, cap, (int)g[to].size(), false, id);\n        g[to].emplace_back(src, cap, (int)g[src].size()-1, true, id);\n    }\n\n    flow_t dfs(int v, const int t, flow_t flow) {\n        if(v == t) return flow;\n        used[v] = timestamp;\n        for(auto &e : g[v]) {\n            if(e.cap > 0 && used[e.to] != timestamp) {\n                flow_t d = dfs(e.to, t, min(flow, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    flow_t max_flow(int s, int t) {\n        flow_t flow = 0;\n        for(flow_t f; (f = dfs(s, t, inf)) > 0; timestamp++) {\n            flow += f;\n        }\n        return flow;\n    }\n};\n\nint main()\n{\n    int n, m; cin >> n >> m;\n\n    FordFulkerson<int> ford(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v; cin >> u >> v; --u, --v;\n        ford.add_edge(u, v, 1, i);\n    }\n\n    int S, T; cin >> S >> T; --S, --T;\n\n    int flow = ford.max_flow(S, T);\n    cout << flow << endl;\n\n    vector<int> flip;\n    for (auto v : ford.g) {\n        for (auto e : v) {\n            if (e.isrev && e.cap == 0) {\n                flip.push_back(e.id);\n            }\n        }\n    }\n\n    cout << flip.size() << endl;\n    for (auto i : flip) {\n        cout << i+1 << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#define MAX_V 2000\n#define INF 1e5\nusing namespace std;\nint n,m,S,T;\nint V;\nstruct edge{\n\tint to,cap,rev,id;\n\tedge(int tt=0,int cc=0,int rr=0,int ii=0){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t\tid=ii;\n\t}\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int from,int to,int cap,int id){\n\tG[from].push_back(edge(to,cap,G[to].size(),id));\n\tG[to].push_back(edge(from,cap,G[from].size()-1,-id));\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\tint S=n,T=S+1;\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tscanf(\"%d %d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tadd_edge(f,t,1,i+1);\n\t}\n\tint s,t;\n\tscanf(\"%d %d\",&s,&t);\n\ts--;\n\tt--;\n\tadd_edge(S,s,INF,0);\n\tadd_edge(t,T,INF,0);\n\tint res=max_flow(S,T);\n\tvector<int> res_edge;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tif(G[i][j].id>0 && G[i][j].cap==2){\n\t\t\t\tres_edge.push_back(G[i][j].id);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\tprintf(\"%d\\n\",res_edge.size());\n\tfor(int i=0;i<res_edge.size();i++){\n\t\tprintf(\"%d\\n\",res_edge[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint op[310][310];\nint vis[90010];\nint N,M,R,S,ans=0;\nint visn[400];\n\nbool dfs(int f)\n{\n    visn[f]=1;\n    int i;\n    int flag=0;\n    if(op[f][S])\n    {\n        ans++;\n        flag=1;\n    }\n    if(op[S][f])\n    {\n        ans++;\n        vis[op[S][f]]=1;\n        op[f][S]=op[S][f];\n        op[S][f]=0;\n        flag=1;\n    }\n\n    for(i=1;i<=M;i++)\n    {\n        if(!op[f][i]||visn[i]==1) continue;\n\n        if(dfs(i))\n        {\n            flag=1;\n        }\n    }\n\n    for(i=1;i<=M;i++)\n    {\n        if(!op[i][f]||vis[i]==1) continue;\n\n        if(dfs(i))\n        {\n            vis[op[i][f]]=1;\n            op[f][i]=op[i][f];\n            op[i][f]=0;\n            flag=1;\n        }\n    }\n\n    visn[f]=0;\n    if(flag) return true;\n    return false;\n}\n\nint main()\n{\n    int x,y,i;\n    scanf(\"%d%d\",&N,&M);\n    memset(op,0,sizeof(op));\n    memset(vis,0,sizeof(vis));\n    memset(visn,0,sizeof(visn));\n    for(i=1;i<=M;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        op[x][y]=i;\n    }\n    scanf(\"%d%d\",&R,&S);\n\n    visn[S]=1;\n    dfs(R);\n    printf(\"%d\\n\",ans);\n\n    ans=0;\n    for(i=1;i<=90001;i++)\n    {\n        if(vis[i]) ans++;\n    }\n    printf(\"%d\\n\",ans);\n\n    for(i=1;i<=90001;i++)\n    {\n        if(vis[i]) printf(\"%d\\n\",i);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* monkukui 競技プログラミング用のテンプレート  (ここから) */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nusing ll = long long int;\nusing lnt = long long int;\nusing graph = vector<vector<int>>;\nusing wgraph = vector<vector<pair<int, long long int>>>;\nlong long int INF = 1001001001001001LL;\nint inf = 100100100;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\nlong long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nlong long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ninline void yes(){ cout << \"yes\" << endl; }\ninline void Yes(){ cout << \"Yes\" << endl; }\ninline void YES(){ cout << \"YES\" << endl; }\ninline void no(){ cout << \"no\" << endl; }\ninline void No(){ cout << \"No\" << endl; }\ninline void NO(){ cout << \"NO\" << endl; }\ninline void possible(){ cout << \"possible\" << endl; }\ninline void Possible(){ cout << \"Possible\" << endl; }\ninline void POSSIBLE(){ cout << \"POSSIBLE\" << endl; }\ninline void impossible(){ cout << \"impossible\" << endl; }\ninline void Impossible(){ cout << \"Impossible\" << endl; }\ninline void IMPOSSIBLE(){ cout << \"IMPOSSIBLE\" << endl; }\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = 1; i <= (n); i++)\n#define drep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define srep(i,s,t) for(int i = s; i < t; i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n\n/* monkukui 競技プログラミング用のテンプレート (ここまで)*/\n\n\n// verified : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_A\n// O(E V^2)\n\n// [使い方]\n// add_edge(from, to, cap) :  from から to へ 容量 cap の辺を貼る\n// max_flow(s, t) :  s から t への最大フローを返す\n\ntemplate< typename T >\nstruct Dinic{\n    const T inf;\n\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n        bool isrev;\n    };\n\n    vector<vector<edge>> g;\n    vector<int> min_cost, iter;\n\n    Dinic(int V) : inf(numeric_limits<T>::max()), g(V){}\n\n\n    // 0-indexed\n    void add_edge(int from, int to, T cap){\n        g[from].emplace_back((edge){to, cap, (int)g[to].size(), false});\n        g[to].emplace_back((edge){from, 0, (int)g[from].size() - 1, true});\n    }\n\n    bool bfs(int s, int t) {\n        min_cost.assign(g.size(), -1);\n        queue<int> que;\n        min_cost[s] = 0;\n        que.push(s);\n        while(!que.empty() && min_cost[t] == -1){\n            int p = que.front();\n            que.pop();\n            for(auto &e : g[p]) {\n                if(e.cap > 0 && min_cost[e.to] == -1){\n                    min_cost[e.to] = min_cost[p] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return min_cost[t] != -1;\n    }\n    \n    T dfs(int idx, const int t, T flow){\n        if(idx == t) return flow;\n        for(int &i = iter[idx]; i < g[idx].size(); i++){\n            edge &e = g[idx][i];\n            if(e.cap > 0 && min_cost[idx] < min_cost[e.to]){\n                T d = dfs(e.to, t, min(flow, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    // 0-indexed\n    T max_flow(int s, int t){\n        T flow = 0;\n        while(bfs(s, t)){\n            iter.assign(g.size(), 0);\n            T f = 0;\n            while((f = dfs(s, t, inf)) > 0) flow += f;\n        }\n\n        return flow;\n    }\n    \n    void output(vector<vector<int>> &A) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &e : g[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = g[e.to][e.rev];\n                //cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n                if(rev_e.cap == 1) A[i][e.to] = 1;\n            }\n        }\n    }\n};\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  Dinic<int> dc(n);\n  set<pair<int, int>> st;\n  map<pair<int, int>, int> mp;\n\n  for(int i = 0; i < m; i++) {\n    int u, v; cin >> u >> v;\n    u--;\n    v--;\n    st.insert({u, v});\n    mp[make_pair(u, v)] = i + 1;\n    dc.add_edge(u, v, 1);\n    dc.add_edge(v, u, 1);\n  }\n  \n\n  int s, t; cin >> s >> t;\n  s--;\n  t--;\n  auto hoge = dc.max_flow(s, t);\n  cout << hoge << endl;\n\n  vector<int> ans;\n  vector<vector<int>> A(500, vector<int> (500, 0));\n  dc.output(A);\n  for(int i = 0; i < 500; i++) {\n    for(int j = 0; j < 500; j++) {\n      if(A[i][j] == 1 and A[j][i] == 1) {\n        A[i][j] = 0;\n        A[j][i] = 0;\n      }\n    }\n  }\n  \n  for(int i = 0; i < 500; i++) {\n    for(int j = 0; j < 500; j++) {\n      if(A[i][j] == 1) {\n        if(st.find({i, j}) == st.end()) ans.push_back(mp[make_pair(j, i)]);\n      }\n    }\n  }\n\n  cout << ans.size() << endl;\n  for(auto val : ans) cout << val << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\n/*\nint maxflow(const vector<vector<pair<int, int> >  > &flow_v, int s, int g) {\n    const int size = flow_v.size();\n\n    vector<vector<int> > capacity(size, vector<int>(size, 0));\n    for(int i = 0; i < size; ++i) {\n        for(int j = 0; j < flow_v[i].size(); ++j) {\n            int to = flow_v[i][j].first;\n            int cost = flow_v[i][j].second;\n            capacity[i][to] = cost;\n        }\n    }\n    vector<vector<int> > flow(size, vector<int>(size, 0));\n\n    int ans = 0;\n    while(true) {\n        queue<int> q;\n        vector<int> prev(size, -1);\n        prev[s] = s;\n        q.push(s);\n        while(!q.empty()) {\n            int n = q.front();\n            q.pop();\n            for(int i = 0; i < size; ++i) {\n                if(capacity[n][i] - flow[n][i] <= 0) continue;\n                if(prev[i] != -1) continue;\n                prev[i] = n;\n                q.push(i);\n                if(i == g) goto endloop;\n            }\n        }\nendloop:\n        if(prev[g] == -1) break;\n        int res = INT_MAX;\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            res = min(res, capacity[prev[i]][i]-flow[prev[i]][i]);\n        }\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            flow[orev[i]][i] += res;\n            flow[i][prev[i]] -= res;\n        }\n        ans += res;\n    }\n    return ans;\n}\n*/\n\nint main() {\n    ios::sync_with_stdio(0);\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int> > v(N+1, vector<int>(N+1, 0));\n    vector<vector<int> > d(N+1, vector<int>(N+1, 0));\n    vector<vector<int> > num(N+1, vector<int>(N+1, 0));\n    for(int i = 0; i < M; ++i) {\n        int x, y;\n        cin >> x >> y;\n        v[x][y] = v[y][x] = 1;\n        d[x][y] = 1;\n        num[x][y] = num[y][x] = i+1;\n    }\n\n    int S, G;\n    cin >> S >> G;\n\n    int ans = 0;\n    vector<int> flips;\n    while(true) {\n        bool modified = false;\n\n        queue<int> q;\n        vector<int> prev(N+1, -1);\n        prev[S] = 0;\n        q.push(S);\n        while(!q.empty()) {\n            int p = q.front();\n            q.pop();\n\n            if(p == G) {\n                ++ans;\n                int cur = p;\n                while(cur != S) {\n                    if(!d[prev[cur]][cur]) {\n                        flips.push_back(num[prev[cur]][cur]);\n                    }\n                    v[cur][prev[cur]] = v[prev[cur]][cur] = 0;\n                    cur = prev[cur];\n                }\n                modified = true;\n                break;\n            }\n\n            for(int i = 0; i < N+1; ++i) {\n                if(v[p][i] && prev[i] == -1) {\n                    prev[i] = p;\n                    q.push(i);\n                }\n            }\n        }\n        if(!modified) break;\n    }\n\n    cout << ans << endl;\n    cout << flips.size() << endl;;\n    for(int i = 0; i < flips.size(); ++i) {\n        cout << flips[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev, back;\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, rev = c, back = d;\n\t}\n};\n\n\nint N, M;\nint S, T;\nvector<edge> G[305];\nbool used[305];\n\nvoid add_edge(int s, int t, int cap, int back)\n{\n\tG[s].push_back( edge(t, cap, G[t].size(), 0) );\n\tG[t].push_back( edge(s, 0, G[s].size()-1, back) );\n}\n\nint dfs(int v, int f)\n{\n\tif(v == T) return f;\n\tused[v] = true;\n\t\n\tint ret;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap == 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\tcin >> N >> M;\n\t\n\tint x, y;\n\tfor(int i = 1; i <= M; i++){\n\t\tcin >> x >> y;\n\t\tadd_edge(x, y, 1, 0);\n\t\tadd_edge(y, x, 1, i);\n\t}\n\tcin >> S >> T;\n\t\n\tint flow = 0, ret;\n\twhile(1){\n\t\tfor(int i = 1; i <= N; i++) used[i] = false;\n\t\tret = dfs(S, inf);\n\t\tif(ret == 0) break;\n\t\tflow += ret;\n\t}\n\t\n\tint cnt = 0;\n\tvector<int> ans;\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].back && G[i][j].cap){\n\t\t\t\tcnt++;\n\t\t\t\tans.push_back(G[i][j].back);\n\t\t\t}\n\t\t}\n\t}\n\tcout << flow << endl;\n\tcout << cnt << endl;\n\tfor(int i = 0; i < cnt; i++){\n\t\tcout << ans[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\nint N,M;\nstruct edge{\n  int to,cap,rev;\n};\nvector<edge> G[333];\nint E[333][333];\n\nvoid add_edge(int to,int from,int cap){\n  G[from].push_back( (edge){to,cap,G[to].size()} );\n  G[to].push_back( (edge){from,0,G[from].size()-1} );\n\n  G[from].push_back( (edge){to,0,G[to].size()} );\n  G[to].push_back( (edge){from,cap ,G[from].size()-1} );\n}\n\nbool used[333];\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap) );\n      if( d > 0 ){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    if( f == 0 ) return flow;\n    flow+=f;\n  }\n}\n\nvector<int> ans;\n\nvoid revdfs(int v,int t){\n  if( v == t ) return;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge e = G[v][i];\n    if( used[e.to] ) continue;\n    if( e.cap > 0 ){\n      // printf(\" %d -> %d == %d \\n\",e.to,v,E[e.to][v]); \n      if( E[e.to][v] > 0 ) ans.push_back( E[e.to][v] );\n      revdfs(e.to,t);\n    }\n  }\n  return ;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int x,y;\n    cin >> x >> y;\n    E[y][x] = i+1;\n    add_edge(x,y,1);\n  }\n  int s,t;\n  cin >> s >> t;\n  int res = max_flow(s,t);\n  cout << res << endl;\n  memset(used,0,sizeof(used));\n  revdfs(t,s);\n  sort(ans.begin(),ans.end());\n  ans.erase(unique(ans.begin(),ans.end()),ans.end());\n  cout << ans.size() << endl;\n  for(int i=0;i<(int)ans.size();i++) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nconst int NMAX = 310;\nconst int MMAX = 1010;\nconst int INF = MMAX * 6;\n\nstruct edge { \n  int to, cap, rev, id;\n  bool reversal;\n};\n\nvector<edge> G[NMAX];\nbool used[NMAX];\n\nvoid add_edge(int from, int to, int cap, int id, bool reversal) {\n  G[from].push_back((edge){to, cap, G[to].size(), id, reversal});\n  G[to].push_back((edge){from, 0, G[from].size() - 1, 0, false});\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] and e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  while (true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main() {\n  int n, m, s, t;\n  cin >> n >> m;\n  REP(i, m) {\n    int x, y;\n    cin >> x >> y;\n    add_edge(x, y, 1, i + 1, false);\n    add_edge(y, x, 1, i + 1, true);\n  }\n  cin >> s >> t;\n  cout << max_flow(s, t) << endl;\n\n  vector<int> reverse_roads;\n/*  REP(v, n + 1) {\n    REP(i, G[v].size()) {\n      edge e = G[v][i];\n      cout << \"G[\" << v << \"][\" << i << \"]\";\n      cout << \"to=\" << e.to;\n      cout << \"cap=\" << e.cap;\n      cout << \"rev=\" << e.rev;\n      cout << \"id=\" << e.id;\n      cout << \"reversal=\" << e.reversal << endl;\n    }\n  }*/\n  REP(v, n + 1) {\n    REP(e, G[v].size()) {\n      if (G[v][e].reversal and G[v][e].cap == 0) {\n        reverse_roads.push_back(G[v][e].id);\n      }\n    }\n  }\n  sort(reverse_roads.begin(), reverse_roads.end());\n  int len = reverse_roads.size();\n  cout << len << endl;\n  REP(i, len) {\n    cout << reverse_roads[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1000000000;\nconst int N = 610;\n#define CLR(arr,val) memset(arr,val,sizeof(arr));\n#define min(a,b) ((a)<(b)?(a):(b))\n\n#define MAXN 610\ntypedef int elem_t;\n\nelem_t maxflow(int n,elem_t mat[][MAXN],int source,int sink,elem_t flow[][MAXN]){\n\tint pre[MAXN],que[MAXN],p,q,t,i,j;\n\telem_t d[MAXN],s;\n\tif (source==sink)\n\t\treturn inf;\n\tfor (i=0;i<n;i++)\n\t\tfor (j=0;j<n;j++)\n\t\t\tflow[i][j]=0;\n\tfor (pre[sink]=1;pre[sink];){\n\t\tfor (i=0;i<n;pre[i++]=0);\n\t\tpre[t=source]=source+1,d[t]=inf;\n\t\tfor (p=0,q=1;p<q&&!pre[sink];t=que[++p])\n\t\t\tfor (i=0;i<n;i++)\n\t\t\t\tif (!pre[i]&&mat[t][i]&&(s=mat[t][i]-flow[t][i])>0)\n\t\t\t\t\tpre[que[q++]=i]=t+1,d[i]=d[t]<s?d[t]:s;\n\t\t\t\telse if (!pre[i]&&mat[i][t]&&(s=flow[i][t])>0)\n\t\t\t\t\tpre[que[q++]=i]=-t-1,d[i]=d[t]<s?d[t]:s;\n\t\tfor (i=sink;pre[i]&&i!=source;)\n\t\t\tif (pre[i]>0)\n\t\t\t\tflow[pre[i]-1][i]+=d[sink],i=pre[i]-1;\n\t\t\telse\n\t\t\t\tflow[i][-pre[i]-1]-=d[sink],i=-pre[i]-1;\n\t}\n\tfor (s=i=0;i<n;i++)\n\t\ts+=flow[source][i];\n\treturn s;\n}\n\nint mat[MAXN][MAXN],flow[MAXN][MAXN],a[N],b[N],s,t,ans[N],cnt;\nint main(){\n\tint n,m;\n\twhile( scanf(\"%d%d\", &n, &m) != EOF ){\n\t\tCLR( mat, 0 );\n\t\tfor(int i=0 ; i < m ; ++i){\n\t\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\t\tmat[a[i]][b[i]] = mat[b[i]+n][a[i]+n] = 1;\n\t\t}\n\t\tfor(int i=1 ; i <= n ; ++i)\n\t\t\tmat[i][i+n] = mat[i+n][i] = inf;\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tmat[0][s] = inf;\n\t\tmat[t+n][2*n+1] = inf;\n\t\tint mf = maxflow(2*n+2,mat,0,2*n+1,flow);\n\t\tprintf(\"%d\\n\", mf);\n\t\tCLR( ans, 0 );\n\t\tcnt = 0;\n\t\tfor(int i=0 ; i < m ; ++i)\n\t\t\tif( flow[b[i]+n][a[i]+n] != 0 )\n\t\t\t\tans[cnt++] = i+1;\n\t\tprintf(\"%d\\n\", cnt);\n\t\tfor(int i=0 ; i < cnt ; ++i)\n\t\t\tprintf(\"%d\\n\", ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n, m;\n\nstruct Edge {\n  int dst, cap;\n  Edge *rev;\n  Edge(): dst(0), cap(0), rev(nullptr){}\n  Edge(int dst, int cap, Edge *rev): dst(dst), cap(cap), rev(rev){}\n};\n\nvector<Edge> g[300];\n\nvoid addEdge(int src, int dst){\n  g[src].emplace_back(dst, 1, nullptr);\n  g[dst].emplace_back(src, 0, nullptr);\n  g[src].back().rev = &g[dst].back();\n  g[dst].back().rev = &g[src].back();\n\n  g[dst].emplace_back(src, 1, nullptr);\n  g[src].emplace_back(dst, 0, nullptr);\n  g[dst].back().rev = &g[src].back();\n  g[src].back().rev = &g[dst].back();\n}\n\nbool used[300];\n\nint dfs(int v, int t, int f){\n  if (v == t) return f;\n  used[v] = true;\n  each(e, g[v]){\n    if (!used[e.dst] && e.cap > 0){\n      int d = dfs(e.dst, t, min(f, e.cap));\n      if (d > 0){\n        e.cap -= d;\n        e.rev->cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t){\n  int flow = 0;\n  while (true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, inf);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nEdge *tar[1000];\n\nint main(){\n  cin >> n >> m;\n  rep(i, n) g[i].reserve(m * 2);\n  rep(i, m){\n    int s, t;\n    cin >> s >> t, s--, t--;\n    addEdge(s, t);\n    tar[i] = &g[t].back();\n  }\n  int s, t;\n  cin >> s >> t, s--, t--;\n  cout << maxFlow(s, t) << endl;\n  vector<int> res;\n  rep(i, m){\n    if (tar[i]->cap == 0){// 逆向きの辺が使われている\n      res.push_back(i + 1);\n    }\n  }\n  cout << res.size() << endl;\n  each(x, res) cout << x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int MAXV = 305;\nconst int INF = (1<<28);\n\nstruct Edge {int to, cap, rev; };\n\nint N, M;\nvector<Edge> G[MAXV];\nbool used[MAXV];\nvector<pair<int,int> > roads;\n\nvoid init() {\n  for(int i = 0; i < MAXV; ++i) G[i].clear();\n  roads.clear();\n}\n\nvoid addEdge(int from, int to, int cap) {\n  G[from].push_back((Edge){to, cap, G[to].size()});\n  G[to].push_back((Edge){from, 0, G[from].size() - 1});\n\n  swap(from, to);\n  G[from].push_back((Edge){to, cap, G[to].size()});\n  G[to].push_back((Edge){from, 0, G[from].size() - 1});\n\n  roads.push_back(make_pair(from, G[from].size()-1));\n}\n\nint dfs(int v, int t, int f) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    Edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t) {\n  int flow = 0;\n  for(;;) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main() {\n  int tc = 0;\n  while(cin >> N >> M && (N|M)) {\n    init();\n    for(int i = 0; i < M; ++i) {\n      int a, b;\n      cin >> a >> b;\n      --a; --b;\n      addEdge(a, b, 1);\n    }\n    int s, t;\n    cin >> s >> t;\n    --s; --t;\n    int res = maxFlow(s, t);\n    if(tc++) cout << endl;\n    cout << res << endl;\n    vector<int> v;\n    for(int i = 0; i < roads.size(); ++i) {\n      if(G[roads[i].first][roads[i].second].cap == 0) {\n        v.push_back(i+1);\n      }\n    }\n    cout << v.size() << endl;\n    for(int i = 0; i < v.size(); ++i) {\n      cout << v[i] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-10L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nint dist[400][400];\nvector<int> vertexs[400];\nint s, t;\nint n, m;\nint visited[400];\nint dfs(int now) {\n    if (now == t) {\n        return 1;\n    }\n    visited[now] = 1;\n    for (auto x : vertexs[now]) {\n        if (dist[now][x] >= 1) {\n            if (visited[x] == 1) continue;\n            int hoge = dfs(x);\n            if (hoge == 1) {\n                dist[now][x]--;\n                dist[x][now]++;\n                return hoge;\n            }\n        }\n    }\n    return 0;\n}\nint cnt[500];\nint expected[500][500];\nvoid solve(){\n    cin >> n >> m;\n    vector<pair<int, int>> edges;\n    REP(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        edges.push_back(mp(a, b));\n        dist[a][b]++;\n        dist[b][a]++;\n        expected[a][b]++;\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    cin >> s >> t;\n    s--; t--;\n    int answer = 0;\n    while (dfs(s)) {\n        REP(i, n) {\n            visited[i] = 0;\n        }\n        answer++;\n    }\n    cout << answer << endl;\n    vector<int> ans;\n    REP(i, edges.size()) {\n        if (dist[edges[i].first][edges[i].second] > expected[edges[i].first][edges[i].second]) {\n            ans.push_back(i);\n            dist[edges[i].first][edges[i].second]++;\n        }\n    }\n    cout << ans.size() << endl;\n    REP(i, ans.size()) {\n        cout << ans[i] +1<< endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://acm.hust.edu.cn:8080/judge/contest/view.action?cid=7068#problem/E\n\n#include <stdio.h>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 310;\nconst int MAXM = 1010;\nconst int INF = 1000000000;\n\nint head[MAXN];\nbool dele[MAXM], g[MAXN][MAXN];\nint e_cnt,  src, sink, n, m;\n\nstruct Edg\n{\n    int v, flow, next, id, from;\n}edg[MAXM * 4];\n\nvoid inline add(int a, int b, int c, int id)\n{\n    edg[e_cnt].v = b; edg[e_cnt].next = head[a];  edg[e_cnt].from = a;\n    edg[e_cnt].id = id; edg[e_cnt].flow = c; head[a] = e_cnt++;\n}\n\nint dis[MAXN], work[MAXN];\nbool bfs()\n{\n    memset(dis, -1, sizeof(dis));\n    queue<int> q;\n    q.push(src);    dis[src] = 0;\n    while(!q.empty())\n    {\n        int u = q.front();  q.pop();\n        for(int i = head[u]; i != -1; i = edg[i].next)\n        {\n            int v = edg[i].v;\n            if(dis[v] == -1 && edg[i].flow > 0)\n            {\n                dis[v] = dis[u] + 1;\n                q.push(v);\n                if(v == sink)  return 1;\n            }\n        }\n    }\n    return 0;\n}\nint dinic(int x, int flow)\n{\n    if(x == sink)  return flow;\n    for(int &i = work[x]; i != -1; i = edg[i].next)\n    {\n        int v = edg[i].v;\n        if(dis[v] == dis[x] + 1 && edg[i].flow > 0)\n        {\n            int tmp = dinic(v, min(flow, edg[i].flow));\n            edg[i].flow -= tmp;\n            edg[i ^ 1].flow += tmp;\n            if(tmp)  return tmp;\n        }\n    }\n    return 0;\n}\n\nint maxflow()\n{\n    int res(0);\n    while(bfs())\n    {\n        for(int i = 0; i < MAXN; ++i)   work[i] = head[i];\n        while(int g = dinic(src, INF))  res += g;\n    }\n    return res;\n}\nvoid read()\n{\n    memset(head, -1, sizeof(head));\n    memset(g, 0, sizeof(g));\n    e_cnt = 0;\n    for(int i = 0; i < m; ++i)\n    {\n        int ta, tb;\n        scanf(\"%d%d\", &ta, &tb);\n        add(ta, tb, 1, i + 1);\n        add(tb, ta, 0, i + 1);\n        g[ta][tb] = 1;\n    }\n    scanf(\"%d%d\", &src, &sink);\n}\nint main()\n{\n    while(scanf(\"%d%d\", &n, &m) != EOF)\n    {\n        read();\n        int ret = maxflow();\n        memset(dele, 0, sizeof(dele));\n        for(int i = 0; i < e_cnt; i+= 2)\n        {\n            int ta = edg[i].from, tb = edg[i].v;\n            if(edg[i].flow == 0 && g[ta][tb])\n                dele[edg[i].id] = 1;\n        }\n        for(int i = 0; i < e_cnt; ++i)\n        {\n            if(!dele[edg[i].id])\n            {\n                edg[i].flow = 1;\n                //printf(\"%d %d  %d\\n\", edg[i].id, edg[i].from, edg[i].v);\n            }\n            else  edg[i].flow = 0;\n        }\n        ret += maxflow();\n\n        vector<int> ans;\n        for(int i = 0; i < e_cnt; ++i)\n        {\n            int ta = edg[i].from, tb = edg[i].v;\n            if(!dele[edg[i].id] && edg[i].flow == 0 && !g[ta][tb])\n            {\n                if(find(ans.begin(), ans.end(), edg[i].id) == ans.end())  ans.push_back(edg[i].id);\n            }\n        }\n        printf(\"%d\\n\", ret);\n        printf(\"%d\\n\", ans.size());\n        for(int i = 0; i < ans.size(); ++i)\n            printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"stdio.h\"\n#include\"string.h\"\n#include\"algorithm\"\n#include\"queue\"\n#include\"map\"\nusing namespace std;\nconst int maxn=400000;\nconst int ma=400;\nconst int oo=0x7fffffff;\nint s,t,vh[ma],h[ma],n,m,out[200000],ad;\nint vis[333][333];\nint mark[333][333];\nstruct al{\n    int to,v,o,f,t;\n    al *next,*r;\n}edge[maxn],*first[maxn],*cur[maxn],*cp;\nvoid add(int x,int y,int o,int t)\n{\n\tal *p=cp++,*q=cp++;\n\tp->to=y;\n\tp->v=1;\n\tp->t=t;\n\tp->next=first[x];\n\tp->o=o;\n\tfirst[x]=q->r=p;\n\tq->to=x;\n\tq->v=0;\n\tq->next=first[y];\n\tq->t=t;\n\tq->o=o;\n\tfirst[y]=p->r=q;\n}\nint sap(int x,int v)\n{\n\tif(x==t)return v;\n\tint minh=n-1,d;\n\tfor(al *p=cur[x];p;p=p->next)\n\t{\n\t\tif(p->v>0&&h[x]==h[p->to]+1)\n\t\t{\n\t\t\tcur[x]=p;\n\t\t\tif((d=sap(p->to,min(p->v,v)))>0)\n\t\t\t{\n\t\t\t\tp->v-=d;\n\t\t\t\tp->r->v+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\tif(h[s]>=n)return 0;\n\t\t}\n\t}\n\tif(--vh[h[x]]==0)h[s]=n;\n\tfor(al *p=cur[x]=first[x];p;p=p->next)\n\t{\n\t\tif(p->v>0&&h[p->to]<minh)\n\t    minh=h[p->to];\n\t}\n\t++vh[h[x]=minh+1];\n    return 0;\n}\nint maxflow()\n{\n\tmemcpy(cur,first,sizeof(cur));\n\tmemset(h,0,sizeof(h));\n\tmemset(vh,0,sizeof(vh));\n\tint d,res=0;\n\twhile(h[s]<n)\n\t{\n\t\tif((d=sap(s,oo))>0)\n\t\tres+=d;\n\t}\n\treturn res;\n}\nvoid init()\n{\n\tmemset(first,0,sizeof(first));\n\tmemset(vis,0,sizeof(vis));\n\tmemset(mark,0,sizeof(mark));\n\tcp=edge;\n\tad=0;\n}\nvoid dfs(int x)\n{\n\tif(x==t)return;\n\tfor(al *p=first[x];p;p=p->next)\n\tif(!p->f&&p->v==0){\n\t\tp->f=0;\n\t dfs(p->to);\n\t if(!vis[x][p->to])out[ad++]=p->o;\n\t}\n}\nint main()\n{\n    while(~scanf(\"%d %d\",&n,&m))\n    {\n    \tinit();int x,y;\n    \tfor(int i=0;i<m;i++)\n    \t{\n\t    \tscanf(\"%d %d\",&x,&y);\n\t    \tadd(x,y,1,i+1);\n\t    \tadd(y,x,1,i+1);\n\t    \t//vis[x][y]=i+1;\n\t    }\n\t    scanf(\"%d %d\",&s,&t);\n\t    int res=maxflow();\n\t    //dfs(s);\n\t    ad=0;\n\t    al *tmp;\n\t    for(tmp=&edge[0];tmp!=cp;)\n\t    {\n\t    \t//printf(\"%d %d %d\\n\",tmp->to,tmp->r->to,tmp->r->v);\n    \t\tif(tmp->r->v==0)\n    \t\t\tout[ad++]=tmp->t;\n   \t\t\ttmp+=4;\n    \t}\n\t    printf(\"%d\\n\",res);\n\t    printf(\"%d\\n\",ad);\n\t    for(int i=0;i<ad;i++)\n\t    printf(\"%d\\n\",out[i]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://acm.hust.edu.cn:8080/judge/contest/view.action?cid=7068#problem/E\n\n#include <stdio.h>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 310;\nconst int MAXM = 1010;\nconst int INF = 1000000000;\n\nint head[MAXN];\nbool dele[MAXM], g[MAXN][MAXN];\nint e_cnt,  src, sink, n, m;\n\nstruct Edg\n{\n    int v, flow, next, id, from;\n}edg[MAXM * 4];\n\nvoid inline add(int a, int b, int c, int id)\n{\n    edg[e_cnt].v = b; edg[e_cnt].next = head[a];  edg[e_cnt].from = a;\n    edg[e_cnt].id = id; edg[e_cnt].flow = c; head[a] = e_cnt++;\n}\n\nint dis[MAXN], work[MAXN];\nbool bfs()\n{\n    memset(dis, -1, sizeof(dis));\n    queue<int> q;\n    q.push(src);    dis[src] = 0;\n    while(!q.empty())\n    {\n        int u = q.front();  q.pop();\n        for(int i = head[u]; i != -1; i = edg[i].next)\n        {\n            int v = edg[i].v;\n            if(dis[v] == -1 && edg[i].flow > 0)\n            {\n                dis[v] = dis[u] + 1;\n                q.push(v);\n                if(v == sink)  return 1;\n            }\n        }\n    }\n    return 0;\n}\nint dinic(int x, int flow)\n{\n    if(x == sink)  return flow;\n    for(int &i = work[x]; i != -1; i = edg[i].next)\n    {\n        int v = edg[i].v;\n        if(dis[v] == dis[x] + 1 && edg[i].flow > 0)\n        {\n            int tmp = dinic(v, min(flow, edg[i].flow));\n            edg[i].flow -= tmp;\n            edg[i ^ 1].flow += tmp;\n            if(tmp)  return tmp;\n        }\n    }\n    return 0;\n}\n\nint maxflow()\n{\n    int res(0);\n    while(bfs())\n    {\n        for(int i = 0; i < MAXN; ++i)   work[i] = head[i];\n        while(int g = dinic(src, INF))  res += g;\n    }\n    return res;\n}\nvoid read()\n{\n    memset(head, -1, sizeof(head));\n    e_cnt = 0;\n    for(int i = 0; i < m; ++i)\n    {\n        int ta, tb;\n        scanf(\"%d%d\", &ta, &tb);\n        add(ta, tb, 1, i + 1);\n        add(tb, ta, 1, i + 1);\n    }\n    scanf(\"%d%d\", &src, &sink);\n}\nint main()\n{\n    while(scanf(\"%d%d\", &n, &m) != EOF)\n//    scanf(\"%d%d\", &n, &m);\n    {\n        read();\n        int ret = maxflow();\n        vector<int> ans;\n        for(int i = 0; i < e_cnt; i += 2)\n        {\n            int ta = edg[i].from, tb = edg[i].v;\n            if(edg[i].flow == 2)  ans.push_back(edg[i].id);\n//            {\n//                if(find(ans.begin(), ans.end(), edg[i].id) == ans.end())  ans.push_back(edg[i].id);\n//            }\n        }\n        printf(\"%d\\n\", ret);\n        printf(\"%d\\n\", ans.size());\n        for(int i = 0; i < ans.size(); ++i)\n            printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2304>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct DINIC{\n#define MAX_V 334\n    typedef long long ll;\n    typedef ll CapType;\n    struct edge {\n        int to; // 行き先\n        CapType cap; // 容量\n        int rev; // 逆辺\n        edge() {}\n        edge(int to, CapType cap, int rev) :to(to), cap(cap), rev(rev) {}\n    };\n    vector<edge> G[MAX_V]; // グラフの隣接リスト表現\n    ll level[MAX_V]; // sからの距離\n    ll iter[MAX_V]; // どこまで調べ終わったか\n    \n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_directed_edge(int from, int to, CapType cap) {\n        G[from].push_back(edge(to, cap, (int)G[to].size()));\n        G[to].push_back(edge(from, 0, (int)G[from].size() - 1));\n    }\n    void add_undirected_edge(int from, int to, CapType cap) {\n        G[from].push_back(edge(to, cap, (int)G[to].size()));\n        G[to].push_back(edge(from, cap, (int)G[from].size() - 1));\n    }\n    \n    // sからの最短距離をBFSで計算する\n    void bfs(int s){\n        fill(level,level+MAX_V,-1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()){\n            int v = q.front(); q.pop();\n            for(int i = 0; i < (int)G[v].size();i++){\n                edge& e = G[v][i];\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    \n    // 増加パスをDFSで探す\n    CapType dfs(int v, int t,CapType f){\n        if(v == t) return f;\n        for(ll &i = iter[v]; i < G[v].size();i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                CapType d = dfs(e.to,t,min(f,e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    CapType max_flow(int s,int t){\n        CapType flow = 0;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter,iter+MAX_V,0);\n            CapType f;\n            while((f = dfs(s,t,LINF)) > 0){\n                flow += f;\n            }\n        }\n    }\n};\n\n//int main(void) {\n//    cin.tie(0); ios::sync_with_stdio(false);\n//    int V,E; cin >> V >> E;\n//    DINIC Flow;\n//    for(int i = 0; i < E;i++){\n//        int u,v; ll cap; cin >> u >> v >> cap;\n//        Flow.add_directed_edge(u,v,cap);\n//    }\n//    cout << Flow.max_flow(0, V-1) << endl;\n//    return 0;\n//}\n\nvoid solve(){\n    int N,M; cin >> N >> M;\n    vector<vector<pii>> Graph(N,vector<pii>(N,make_pair(0,-1)));\n    DINIC dinic;\n    for(int i = 0; i < M;i++){\n        int u,v; cin >> u >> v; u--; v--;\n        Graph[u][v] = {1,i};\n        Graph[v][u] = {-1,i};\n        dinic.add_undirected_edge(u,v,1);\n    }\n    int S,T; cin >> S >> T;\n    S--; T--;\n    cout << dinic.max_flow(S, T) << endl;\n    vector<int> ans;\n    for(int i = 0; i < N; i++){\n        for(auto e:dinic.G[i]){\n            if(e.cap != 0 ) continue;\n            int u = i,v = e.to;\n            if(Graph[u][v].first == -1){\n                ans.push_back(Graph[u][v].second);\n            }\n        }\n    }\n    sort(ans.begin(),ans.end());\n    cout << ans.size() << endl;\n    for(auto A:ans){\n        cout << A+1 << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tint DFS(int v,int t,int f,vi& iter,vi level){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),iter,level);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid BFS(int s,vi& level){\n\t\tlevel=vi(V,-1);\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\tedge &e=g[v][i];\n\t\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(edge{t,1,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,1,(int)g[s].size()-1});\n\t}\n\tint Dinic(int s,int t){\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tvi iter(V),level;\n\t\t\tBFS(s,level);\n\t\t\tif(level[t]<0) return res;\n\t\t\tint f;\n\t\t\twhile((f=DFS(s,t,inf,iter,level))>0) res+=f;\n\t\t}\n\t}\n\tvoid Open(map<P,int> m){\n\t\tint res=0;\n\t\tvi a;\n\t\tfor(int i=0;i<V;i++) for(int j=0;j<g[i].size();j++){\n\t\t\tedge &e=g[i][j];\n\t\t\tint v=e.to,I=m[{i,v}];\n\t\t\tif(I&&e.cap==2){\n\t\t\t\ta.push_back(I);\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t\tfor(int i=0;i<res;i++) cout<<a[i]<<endl;\n\t}\n};\n\nint n,m,s,t;\n\nint main(){\n\tcin>>n>>m;\n\tNetwork nt(n);\n\tmap<P,int> M;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tM[{u,v}]=i+1;\n\t\tnt.add_edge(u,v);\n\t}\n\tcin>>s>>t;\n\tcout<<nt.Dinic(s-1,t-1)<<endl;\n\tnt.Open(M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1012345678;\nstruct edge {\n\tint to, cap, rev, id;\n};\nvoid add_edge(int a, int b, int id, vector<vector<edge> > &G) {\n\tG[a].push_back(edge{ b, 1, int(G[b].size()), id });\n\tG[b].push_back(edge{ a, 0, int(G[a].size()) - 1, id });\n}\nint find_augment(int pos, int tar, int curmax, vector<vector<edge> > &G, vector<bool> &vis) {\n\tif (pos == tar) return curmax;\n\tvis[pos] = true;\n\tfor (edge &e : G[pos]) {\n\t\tif (vis[e.to] || e.cap == 0) continue;\n\t\tint res = find_augment(e.to, tar, min(curmax, e.cap), G, vis);\n\t\tif (res > 0) {\n\t\t\te.cap -= res;\n\t\t\tG[e.to][e.rev].cap += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int S, int T, vector<vector<edge> > &G) {\n\tint V = G.size();\n\tint ans = 0;\n\twhile (true) {\n\t\tvector<bool> vis(V, false);\n\t\tint res = find_augment(S, T, inf, G, vis);\n\t\tif (res > 0) ans += res;\n\t\telse break;\n\t}\n\treturn ans;\n}\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<vector<edge> > G(N);\n\tvector<int> X(M), Y(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin >> X[i] >> Y[i]; --X[i], --Y[i];\n\t\tadd_edge(X[i], Y[i], i, G);\n\t\tadd_edge(Y[i], X[i], i, G);\n\t}\n\tint S, T;\n\tcin >> S >> T; --S, --T;\n\tint ret = max_flow(S, T, G);\n\tcout << ret << endl;\n\tvector<int> elist;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint revused = 0;\n\t\tfor (edge e : G[X[i]]) {\n\t\t\tif (e.to == Y[i]) revused += e.cap;\n\t\t}\n\t\tif (revused == 2) {\n\t\t\telist.push_back(i);\n\t\t}\n\t}\n\tcout << elist.size() << endl;\n\tfor (int i : elist) cout << i + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, y, m; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nstruct flow_network {\n\tint n;\n\tstruct edge { int v; ll c; int rev; int i; };\n\tvector< vector<edge> > G;\n\tflow_network(int _n) : n(_n), G(_n) {}\n\tvoid add_edge(int u, int v, ll c, int i) {\n\t\tedge e = {v, c, G[v].size(), i}, _e = {u, 0, G[u].size(), -1};\n\t\tG[u].push_back(e); G[v].push_back(_e);\n\t}\n\tll dfs(int u, int t, ll f, vector<bool>& vis) {\n\t\tif (u == t) return f;\n\t\tvis[u] = true;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge& e = G[u][i];\n\t\t\tif (vis[e.v] || e.c == 0) continue;\n\t\t\tll d = min(e.c, dfs(e.v, t, min(f, e.c), vis));\n\t\t\tif (d == 0) continue;\n\t\t\te.c -= d;\n\t\t\tG[e.v][e.rev].c += d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\tll max_flow(int s, int t) {\n\t\tll res = 0;\n\t\tfor (;;) {\n\t\t\tvector<bool> vis(n);\n\t\t\tll f = dfs(s, t, LLONG_MAX, vis);\n\t\t\tif (f == 0) return res;\n\t\t\tres += f;\n\t\t}\n\t}\n};\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tflow_network fn(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint X, Y; cin >> X >> Y;\n\t\tX--; Y--;\n\t\tfn.add_edge(X, Y, 1, i);\n\t\tfn.add_edge(Y, X, 1, i + M);\n\t}\n\tint S, T; cin >> S >> T;\n\tS--; T--;\n\tcout << fn.max_flow(S, T) << endl;\n\tvector<bool> v(M, true);\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (int j = 0; j < fn.G[u].size(); j++) {\n\t\t\tflow_network::edge& e = fn.G[u][j];\n\t\t\tif (e.i >= 0 && e.i < M && e.c == 0) v[e.i] = false;\n\t\t\tif (e.i >= M && e.c == 1) v[e.i - M] = false;\n\t\t}\n\t}\n\tvector<int> w;\n\tfor (int i = 0; i < M; i++)\n\t\tif (v[i]) w.push_back(i);\n\tcout << w.size() << endl;\n\tfor (int j = 0; j < w.size(); j++)\n\t\tcout << w[j] + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);++i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntemplate< typename FLOW >\nclass Dinic {\nprivate:\n\tstruct Edge { int id, to; FLOW cost; int rev; };\n\t\n\tint N;\n\tvector< vector< Edge > > edges;\n\tvector< int > level, iter;\n\t\npublic:\n\tDinic(int n) : N(n), edges(n), level(n, -1), iter(n, 0) {}\n\t\n\tvoid addEdge(int id, int from, int to) {\n\t\tedges[from].push_back(Edge{id, to, 1, size_of(edges[to])});\n\t\tedges[to].push_back(Edge{0, from, FLOW(), size_of(edges[from]) - 1});\n\t}\n\t\n\tvoid bfs(int s) {\n\t\tfill(allof(level), -1);\n\t\tqueue< int > que; que.push(s);\n\t\tlevel[s] = 0;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\t\n\t\t\tfor (auto& e : edges[v]) {\n\t\t\t\tif (e.cost > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tFLOW dfs(int v, int t, FLOW f) {\n\t\tif (v == t) return f;\n\t\t\n\t\tint enums = size_of(edges[v]);\n\t\t\n\t\tfor (int& i = iter[v]; i < enums; ++i) {\n\t\t\tEdge& e = edges[v][i];\n\t\t\t\n\t\t\tif (e.cost > 0 && level[v] < level[e.to]) {\n\t\t\t\tFLOW d = dfs(e.to, t, min(f, e.cost));\n\t\t\t\t\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cost -= d;\n\t\t\t\t\tedges[e.to][e.rev].cost += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn FLOW(-1);\n\t}\n\t\n\tFLOW maxFlow(int s, int t) {\n\t\tFLOW f = FLOW();\n\t\t\n\t\twhile (1) {\n\t\t\tbfs(s);\n\t\t\t\n\t\t\tif (level[t] < 0) return f;\n\t\t\t\n\t\t\tfill(allof(iter), 0);\n\t\t\tFLOW fl;\n\t\t\twhile ((fl = dfs(s, t, FLOW(1e9))) > 0) f += fl;\n\t\t};\n\t}\n\t\n\tvoid printAnswer() {\n\t\tvector< int > ans;\n\t\t\n\t\tfor_(v,0,N) {\n\t\t\tfor (auto& e : edges[v]) {\n\t\t\t\tif (e.cost == 0 && e.id < 0) ans.push_back(-e.id);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(allof(ans));\n\t\tint m = size_of(ans);\n\t\tcout << m << endl;\n\t\tfor_(i,0,m) cout << ans[i] << endl;\n\t}\n};\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\t\n\tDinic< int > dinic(N);\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tdinic.addEdge(i + 1, u, v);\n\t\tdinic.addEdge(-(i + 1), v, u);\n\t}\n\t\n\tint S, T;\n\tcin >> S >> T;\n\t--S; --T;\n\t\n\tcout << dinic.maxFlow(S, T) << endl;\n\tdinic.printAnswer();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 301;\nconst int INF = (1<<28);\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[N];\nbool used[N];\nvector<pair<int, int> > data;\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, cap, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  while(1){\n    fill(used, used+N, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nvoid solve(int n, int m, int s, int t){\n  cout << max_flow(s, t) << endl;\n  vector<int> ans;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<G[data[i].second].size();j++){\n      if(G[data[i].second][j].to == data[i].first && G[data[i].second][j].cap == 0){\n        ans.push_back(i+1);\n        break;\n      }\n    }\n  }\n  cout << ans.size() << endl;\n  for(int i=0;i<ans.size();i++) cout << ans[i] << endl;\n}\n\nmain(){\n  int n, m, s, t;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a, b;\n    cin >> a >> b;\n    add_edge(a, b, 1);\n    data.push_back(make_pair(a, b));\n  }\n  cin >> s >> t;\n  solve(n, m, s, t);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<stdlib.h>\n#include<ctype.h>\n#include<queue>\n#include<bitset>\n#include<deque>\n#include<set>\n#include<time.h>\n#include<math.h>\n#include<sstream>\n#include<functional>\n#include<stack>\n#include<map>\n#include<vector>\nusing namespace std;\n\n#define LL long long\nint Map[309][309],dg[309];\nstruct node{\n\tint cnt;\n\tint id;\n\tint bid;\n\tint path[309];\n};\nint vis[1009],pp[1009];\nvoid coppy(node &tmp,node st){\n\ttmp.cnt=st.cnt;\n\tfor(int i=0;i<st.cnt;i++)\n\t\ttmp.path[i]=st.path[i];\n}\nint main()\n{\n\t\n\tint n,m;\n\tint u,v,s,t;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(Map,0,sizeof(Map));\n\t\tint cnt=1;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tMap[u][v]=cnt++;\n\t\t}\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tqueue<node>qu;\n\t\twhile(!qu.empty())\n\t\t\tqu.pop();\n\t\tnode st;\n\t\tst.id = s;\n\t\tst.bid=st.cnt=0;\n\t\tqu.push(st);\n\n\t\tint anscnt=0,fans=0;\n\t\twhile(!qu.empty()){\n\t\t\tst = qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tif(st.id == t){\n\t\t\t\tfans++;\n\t\t\t\tfor(int i=0;i<st.cnt;i++)\n\t\t\t\t\tpp[anscnt++]=st.path[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(vis[st.bid])\n\t\t\t\tcontinue;\n\t\t\tvis[st.bid]=1;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\n\t\t\t\tif(Map[st.id][i])\n\t\t\t\t{\n\t\t\t\t\tnode tmp ;\n\t\t\t\t\tcoppy(tmp,st);\n\t\t\t\t\ttmp.id=i;\n\t\t\t\t\ttmp.bid = Map[st.id][i];\n\t\t\t\t\tvis[tmp.bid]=1;\n\t\t\t\t\tqu.push(tmp);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(Map[i][st.id]){\n\t\t\t\t\tnode tmp;\n\t\t\t\t\tcoppy(tmp,st);\n\t\t\t\t\t\n\t\t\t\t\ttmp.id=i;\n\t\t\t\t\ttmp.bid = Map[i][st.id];\n\t\t\t\t\ttmp.path[tmp.cnt++]= Map[i][st.id];\n\t\t\t\t\tvis[tmp.bid]=1;\n\t\t\t\t\tqu.push(tmp);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n%d\\n\",fans,anscnt);\n\t\tsort(pp,pp+anscnt);\n\t\tfor(int i=0;i<anscnt;i++){\n\t\t\tprintf(\"%d\\n\",pp[i]);\n\t\t}\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  void add_undirected_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, cap, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  MaxFlow mf(N);\n  vector<pll> edges;\n  REP(i, 0, M) {\n    ll X, Y;\n    cin >> X >> Y;\n    X--;\n    Y--;\n    mf.add_undirected_edge(X, Y, 1);\n    edges.push_back(pll(X, Y));\n  }\n  ll S, T;\n  cin >> S >> T;\n  S--;\n  T--;\n\n  ll f = mf.max_flow(S, T);\n  vector<ll> idx;\n  REP(i, 0, N) {\n    for(auto e : mf.E[i]) {\n      if(binary_search(edges.begin(), edges.end(), pll(e.to, i)) && e.cap == 0) {\n        idx.push_back(lower_bound(edges.begin(), edges.end(), pll(i, e.to)) - edges.begin());\n      }\n    }\n  }\n\n  cout << f << endl;\n  cout << idx.size() << endl;\n  for(auto i : idx) cout << i << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MAX_V = 1000;\nconst int INF = 1<<29;\n\nstruct Edge {\n    int rev, from, to, cap, icap;\n    Edge(int r, int f, int t, int c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\nstruct Graph {\n    int V;\n    vector<Edge> list[MAX_V];\n    \n    Graph(int n = 0) : V(n) {for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n    void init(int n = 0) {V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n\tvoid resize(int n = 0) {V = n;}\n    void reset() {for (int i = 0; i < V; ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap;}\n    inline vector<Edge>& operator [] (int i) {return list[i];}\n    \n    Edge &redge(Edge e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev+1];\n    }\n    \n    void addedge(int from, int to, int cap) {\n        list[from].push_back(Edge(list[to].size(), from, to, cap));\n        list[to].push_back(Edge(list[from].size()-1, to, from, 0));\n    }\n    \n    void addbiedge(int from, int to, int cap) {\n        list[from].push_back(Edge(list[to].size(), from, to, cap));\n        list[to].push_back(Edge(list[from].size()-1, to, from, cap));\n    }\n    \n    friend ostream& operator << (ostream& s, const Graph& G) {\n        for (int i = 0; i < G.V; ++i) {s << i << \" : \" << G.list[i];}\n        return s;\n    }\n};\n\nGraph G;\n\n\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid dibfs(Graph &G, int s) {\n    memset(level, -1, sizeof(level));\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n            Edge &e = G[v][i];\n            if (level[e.to] < 0 && e.cap > 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint didfs(Graph &G, int v, int t, int f) {\n    if (v == t) return f;\n    for(int &i = iter[v]; i < G[v].size(); ++i) {\n        Edge &e = G[v][i], &re = G.redge(e);\n        if (level[v] < level[e.to] && e.cap > 0) {\n            int d = didfs(G, e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                re.cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint Dinic(Graph &G, int s, int t) {\n    int res = 0;\n    while (true) {\n        dibfs(G, s);\n        if (level[t] < 0) return res;\n        memset(iter, 0, sizeof(iter));\n        int flow;\n        while ((flow = didfs(G, s, t, INF)) > 0) {\n            res += flow;\n        }\n    }\n}\n    \n    \nint V, E, s, t, a, b;\n\nmap<pint,int> ma;\n\n\n\nint main() {\n    while (cin >> V >> E) {\n        G.init(V); ma.clear();\n        for (int i = 0; i < E; ++i) {\n            cin >> a >> b;\n            --a; --b;\n            G.addbiedge(a, b, 1);\n            ma[ pint(a,b) ] = i+1;\n        }\n        cin >> s >> t;\n        --s; --t;\n        \n        int res = Dinic(G, s, t);\n        \n        cout << res << endl;\n        vint ans;\n        for (int i = 0; i < V; ++i) {\n            for (int j = 0; j < G[i].size(); ++j) {\n                if (ma.count(pint(i,G[i][j].to)) && G[i][j].cap == 2) {\n                    ans.PB(ma[pint(i,G[i][j].to)]);\n                    //cout << ma[pint(i,G[i][j].to)] << endl;\n                }\n            }\n        }\n        cout << ans.size() << endl;\n        for (int i = 0; i < ans.size(); ++i) cout << ans[i] << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\nint N,M;\nstruct edge{\n  int to,cap,rev;\n};\nvector<edge> G[333];\nint E[333][333];\n\nvoid add_edge(int to,int from,int cap){\n  G[from].push_back( (edge){to,cap,G[to].size()} );\n  G[to].push_back( (edge){from,0,G[from].size()-1} );\n\n  G[from].push_back( (edge){to,0,G[to].size()} );\n  G[to].push_back( (edge){from,cap ,G[from].size()-1} );\n}\n\nbool used[333];\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap) );\n      if( d > 0 ){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    if( f == 0 ) return flow;\n    flow+=f;\n  }\n}\n\nvector<int> ans;\n\nvoid revdfs(int v,int t){\n  if( v == t ) return;\n  used[v] = true;\n  bool tof[333]={};\n  for(int i=0;i<(int)G[v].size();i++){\n    edge e = G[v][i];\n    if( e.cap == 0 ) tof[e.to] = true;\n  }\n  for(int i=0;i<(int)G[v].size();i++){\n    edge e = G[v][i];\n    if( used[e.to] ) continue;\n    if( !tof[e.to] ) {\n      // printf(\" %d -> %d == %d \\n\",e.to,v,E[e.to][v]); \n      if( E[e.to][v] > 0 ) ans.push_back( E[e.to][v] );\n      revdfs(e.to,t);\n    }\n  }\n  return ;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int x,y;\n    cin >> x >> y;\n    E[y][x] = i+1;\n    add_edge(x,y,1);\n  }\n  int s,t;\n  cin >> s >> t;\n  int res = max_flow(s,t);\n  cout << res << endl;\n  memset(used,0,sizeof(used));\n  revdfs(t,s);\n  sort(ans.begin(),ans.end());\n  ans.erase(unique(ans.begin(),ans.end()),ans.end());\n  cout << ans.size() << endl;\n  for(int i=0;i<(int)ans.size();i++) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\nint flow[310],path[310],map[310][310],maps[310][310],arsum[100010];\nint start,end,n,m,sum;\nint que[2][310],t[2],h[2];\nint BFS(void)\n{\n    int node;\n    t[0]=h[0]=0;\n    que[0][t[0]++]=start;\n    int i=1,j;\n    memset(path,-1,sizeof(path));\n    flow[start]=110;\n    while(i)\n    {\n        //puts(\"2\");\n        h[i&1]=t[i&1]=0;\n        while(h[(i-1)&1]<t[(i-1)&1])\n        {\n            node=que[(i-1)&1][h[(i-1)&1]++];\n            for(j=1;j<=n;j++)\n                if(j!=start&&map[node][j]>0&&path[j]==-1)\n                {\n                   // puts(\"3\");\n                    if(flow[node]<map[node][j]) flow[j]=flow[node];\n                    else flow[j]=map[node][j];\n                    path[j]=node;\n                    que[i&1][t[i&1]++]=j;\n                }\n        }\n        if(h[i&1]==t[i&1]||path[end]!=-1)\n                break;\n        i++;\n    }\n    //printf(\"%d\\n\",path[end]);\n    if(path[end]==-1)\n            return -1;\n    return flow[end];\n}\nint EK(void)\n{\n    int temp,ans=0,pre,d;\n    while((temp=BFS())!=-1)\n    {\n       // puts(\"1\");\n        ans+=temp;\n        d=end;\n        pre=path[d];\n        if(maps[pre][d])arsum[sum++]=maps[pre][d];\n        while(d!=start)\n        {\n            map[pre][d]-=temp;\n            map[d][pre]+=temp;\n            d=pre,pre=path[d];\n            if(maps[pre][d])arsum[sum++]=maps[pre][d];\n        }\n    }\n    return ans;\n}\nint main()\n{\n    int i,a,b;\n\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        memset(map,0,sizeof(map));\n        memset(maps,0,sizeof(maps));\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            maps[b][a]=i;\n            map[a][b]=1;\n            map[b][a]=1;\n        }\n        scanf(\"%d%d\",&start,&end);\n        sum=0;\n        printf(\"%d\\n\",EK());\n        sort(arsum,arsum+sum);\n        printf(\"%d\\n\",sum);\n        for(i=0;i<sum;i++)\n            if(i==0)\n                printf(\"%d\\n\",arsum[i]);\n            else if(arsum[i]!=arsum[i-1])\n                printf(\"%d\\n\",arsum[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass Edge\n{\npublic:\n  int to, cap, rev, idx;\n  bool isRev;\n  Edge(int _to = 0, int _cap = 0, int _rev = 0, int _idx = 0, bool _isRev = false)\n    :to(_to), cap(_cap), rev(_rev), idx(_idx), isRev(_isRev) {} \n};\n\nvoid add_edge(vector<vector<Edge> >& g, int from, int to, int cap, int idx, bool isRev)\n{\n  g[from].push_back(Edge(to, cap, g[to].size(), idx, isRev));\n  g[to].push_back(Edge(from, 0, g[from].size()-1, idx, isRev));\n}\n\nint ff(vector<vector<Edge> >& g, vector<int>& used, int s, int t, int f, set<int>& rev)\n{\n  if (s == t)\n    return f;\n  used[s] = 1;\n  \n  for (unsigned int i = 0; i < g[s].size(); ++i) {\n    Edge& e = g[s][i];\n    if (!used[e.to] && e.cap > 0) {\n      int d = ff(g, used, e.to, t, min(f, e.cap), rev);\n      if (d > 0) {\n\tif (e.isRev)\n\t  rev.insert(e.idx);\n\te.cap -= d;\n\tg[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint solve(vector<vector<Edge> >& g, int s, int t, set<int>& rev)\n{\n  int flow = 0;\n  for ( ; ; ) {\n    vector<int> used(g.size(), 0);\n    int f = ff(g, used, s, t, INF, rev);\n    if (f == 0)\n      return flow;\n    flow += f;\n  }\n}\n\nint main()\n{\n  int N, M;\n  while (~scanf(\"%d %d\", &N, &M)) {\n    vector<vector<Edge> > g(N);\n    for (int i = 0; i < M; ++i) {\n      int X, Y;\n      scanf(\"%d %d\", &X, &Y);\n      --X;\n      --Y;\n      add_edge(g, X, Y, 1, i+1, false);\n      add_edge(g, Y, X, 1, i+1, true);\n    }\n    int S, T;\n    scanf(\"%d %d\", &S, &T);\n    --S;\n    --T;\n\n    set<int> rev;\n    printf(\"%d\\n\", solve(g, S, T, rev));\n    printf(\"%d\\n\", rev.size());\n    for (set<int>::iterator it = rev.begin(); it !=  rev.end(); ++it)\n      printf(\"%d\\n\", *it);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"stdio.h\"\n#include\"string.h\"\n#include\"algorithm\"\n#include\"queue\"\n#include\"map\"\nusing namespace std;\nconst int maxn=400000;\nconst int ma=400;\nconst int oo=0x7fffffff;\nint s,t,vh[ma],h[ma],n,m,out[200000],ad;\nint vis[333][333];\nint mark[333][333];\nstruct al{\n    int to,v,o,f,t;\n    al *next,*r;\n}edge[maxn],*first[maxn],*cur[maxn],*cp;\nvoid add(int x,int y,int o,int t)\n{\n\tal *p=cp++,*q=cp++;\n\tp->to=y;\n\tp->v=1;\n\tp->t=t;\n\tp->next=first[x];\n\tp->o=o;\n\tfirst[x]=q->r=p;\n\tq->to=x;\n\tq->v=0;\n\tq->next=first[y];\n\tq->t=t;\n\tq->o=o;\n\tfirst[y]=p->r=q;\n}\nint sap(int x,int v)\n{\n\tif(x==t)return v;\n\tint minh=n-1,d;\n\tfor(al *p=cur[x];p;p=p->next)\n\t{\n\t\tif(p->v>0&&h[x]==h[p->to]+1)\n\t\t{\n\t\t\tcur[x]=p;\n\t\t\tif((d=sap(p->to,min(p->v,v)))>0)\n\t\t\t{\n\t\t\t\tp->v-=d;\n\t\t\t\tp->r->v+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\tif(h[s]>=n)return 0;\n\t\t}\n\t}\n\tif(--vh[h[x]]==0)h[s]=n;\n\tfor(al *p=cur[x]=first[x];p;p=p->next)\n\t{\n\t\tif(p->v>0&&h[p->to]<minh)\n\t    minh=h[p->to];\n\t}\n\t++vh[h[x]=minh+1];\n    return 0;\n}\nint maxflow()\n{\n\tmemcpy(cur,first,sizeof(cur));\n\tmemset(h,0,sizeof(h));\n\tmemset(vh,0,sizeof(vh));\n\tint d,res=0;\n\twhile(h[s]<n)\n\t{\n\t\tif((d=sap(s,oo))>0)\n\t\tres+=d;\n\t}\n\treturn res;\n}\nvoid init()\n{\n\tmemset(first,0,sizeof(first));\n\tmemset(vis,0,sizeof(vis));\n\tmemset(mark,0,sizeof(mark));\n\tcp=edge;\n\tad=0;\n}\nvoid dfs(int x)\n{\n\tif(x==t)return;\n\tfor(al *p=first[x];p;p=p->next)\n\tif(!p->f&&p->v==0){\n\t\tp->f=0;\n\t dfs(p->to);\n\t if(!vis[x][p->to])out[ad++]=p->o;\n\t}\n}\nint main()\n{\n    while(~scanf(\"%d %d\",&n,&m))\n    {\n    \tinit();int x,y;\n    \tfor(int i=0;i<m;i++)\n    \t{\n\t    \tscanf(\"%d %d\",&x,&y);\n\t    \tadd(x,y,1,i+1);\n\t    \tadd(y,x,1,i+1);\n\t    \t//vis[x][y]=i+1;\n\t    }\n\t    scanf(\"%d %d\",&s,&t);\n\t    int res=maxflow();\n\t    //dfs(s);\n\t    ad=0;\n\t    al *tmp;\n\t    for(tmp=&edge[0];tmp!=cp;)\n\t    {\n\t    \t//printf(\"%d %d %d\\n\",tmp->to,tmp->r->to,tmp->r->v);\n    \t\tif(tmp->r->v==0||(tmp+2)->v==0)\n    \t\t\tout[ad++]=tmp->t;\n   \t\t\ttmp+=4;\n    \t}\n\t    printf(\"%d\\n\",res);\n\t    printf(\"%d\\n\",ad);\n\t    for(int i=0;i<ad;i++)\n\t    printf(\"%d\\n\",out[i]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint infact[300][300] = {};\n\nstruct edge{\n    int to, cap, rev;\n};\n\n#define MAX_V 300\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\n// v...target vertex, t...end vertex, f...maximum flow \nint dfs(int v, int t, int f){\n    if(v == t)  return f;\n\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                infact[v][e.to] = 1;\n                infact[e.to][v] = -1;\n                return d;\n            }\n        }\n    }\n\n    return 0;\n}\n\nconst int INF = 1<<29;\n\n// maxflow from s to t\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0)  return flow;\n        flow += f;\n    }\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    int v[n][n];\n    for(int i = 0; i < n*n; i++)    v[i/n][i%n] = 0;\n    vector<int> a(m), b(m);\n    for(int i = 0; i < m; i++){\n        cin >> a[i] >> b[i];\n        a[i]--, b[i]--;\n        add_edge(a[i], b[i], 1);\n        add_edge(b[i], a[i], 1);\n        v[a[i]][b[i]] = 1;\n        v[b[i]][a[i]] = -1;\n    }\n    int s, t;\n    cin >> s >> t;\n    cout << max_flow(--s, --t) << endl;\n    vector<int> ans;\n    for(int i = 0; i < m; i++){\n        if(v[a[i]][b[i]]*infact[a[i]][b[i]] == -1)  ans.push_back(i+1);\n    }\n    cout << ans.size() << endl;\n    for(int val : ans)  cout << val << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<ctime>\n#define eps 1e-9\n#define ALL(x) x.begin(),x.end()\n#define INS(x) inserter(x,x.begin())\n#define rep(i,j,k) for(int i=j;i<=k;i++)\n#define MAXN 10005\n#define MAXM 40005\n#define INF 0x3fffffff\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n#define lc (k<<1)\n#define rc ((k<<1)|1)\n#define mii ((l+r)>>1)\n#define fk puts(\"fuck!\")\n#define clr(x,y) memset(x,y,sizeof(x))\nusing namespace std;\ntypedef long long LL;\nint i,j,k,n,m,x,y,T,mx,mi,cas,num,len;\nbool flag;\n\n\nconst int inf = 0x3f3f3f3f;\nstruct edgenode\n{\n    int from,to,next,flag;\n    int cap;\n}edge[MAXM];\nint Edge,head[MAXN],ps[MAXN],dep[MAXN];\n\nvoid add_edge(int x,int y,int c,int flag)\n{\n    edge[Edge].from=x;\n    edge[Edge].to=y;\n    edge[Edge].cap=c;\n    edge[Edge].flag=flag;\n    edge[Edge].next=head[x];\n    head[x]=Edge++;\n\n    edge[Edge].from=y;\n    edge[Edge].to=x;\n    edge[Edge].cap=0;\n    edge[Edge].flag=flag;\n    edge[Edge].next=head[y];\n    head[y]=Edge++;\n}\n\nint dinic(int n,int s,int t)\n{\n    int tr,flow=0;\n    int i,j,k,l,r,top;\n    while(1){\n        memset(dep,-1,(n+1)*sizeof(int));\n        for(l=dep[ps[0]=s]=0,r=1;l!=r;)//BFS部分，将?定?分?\n        {\n            for(i=ps[l++],j=head[i];j!=-1;j=edge[j].next)\n            {\n                if (edge[j].cap&&-1==dep[k=edge[j].to])\n                {\n                    dep[k]=dep[i]+1;ps[r++]=k;\n                    if(k==t)\n                    {\n                        l=r;\n                        break;\n                    }\n                }\n            }\n        }\n        if(dep[t]==-1)break;\n\n        for(i=s,top=0;;)//DFS部分\n        {\n            if(i==t)//当前点就是?点?\n            {\n                for(k=0,tr=inf;k<top;++k)\n                    if(edge[ps[k]].cap<tr)tr=edge[ps[l=k]].cap;\n\n                for(k=0;k<top;++k)\n                    edge[ps[k]].cap-=tr,edge[ps[k]^1].cap+=tr;\n\n                flow+=tr;\n                i=edge[ps[top=l]].from;\n            }\n\n            for(j=head[i];j!=-1;j=edge[j].next)//找当前点所指向的点\n                if(edge[j].cap&&dep[i]+1==dep[edge[j].to]) break;\n\n            if(j!=-1)\n            {\n                ps[top++]=j;//当前点有所指向的点，把?个点加入?中\n                i=edge[j].to;\n            }\n            else\n            {\n                if (!top) break;//当前点没有指向的点，回溯\n                dep[i]=-1;\n                i=edge[ps[--top]].from;\n            }\n        }\n    }\n    return flow;\n}\n\nvector<int> ans;\nint main()\n{\n    memset(head,-1,sizeof(head));\n    Edge=0;\n\tscanf(\"%d%d\",&n,&m);\n    for (i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        add_edge(x,y,1,1);\n        add_edge(y,x,1,0);\n    }\n    int S,T;\n    scanf(\"%d%d\",&S,&T);\n    printf(\"%d\\n\",dinic(n+3,S,T));\n\n    ans.clear();\n    for (i=0;i<Edge;i+=2)\n    {\n        if (edge[i].flag==0 && edge[i].cap==0)\n        {\n            ans.PB(i/4+1);\n        }\n    }\n    printf(\"%d\\n\",ans.size());\n    for (i=0;i<ans.size();i++)\n    {\n        printf(\"%d\\n\",ans[i]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V), iter(V){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    fill(level.begin(), level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int i = 0; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(iter.begin(), iter.end(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    rep(i, dinic.G[v].size()) {\n      edge& e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  rep(i, used_rev.size()) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n    int rIdx;\n};\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ツ督ケツつェツつキツづづ可個按津ィツつウツづェツづつ「ツづゥツつゥツづつ、ツつゥ\nbool decided[10001];\nbool isRevEdge[10001];\n\n\nvector<edge> candidate[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int idx){\n\tedge e;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n    e.rIdx=idx;\n\tG[from].push_back(e);\n\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n// ツ堕敖嘉パツスツづーツ探ツ催オ\nint dfs(int v,int t,int f){\n\tif(v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n        // ツ新ツつオツつ「ツ督ケツつゥツづつ、ツつゥ\n        if(!decided[e.rIdx]){\n            decided[e.rIdx]=true;\n            // ツ逆ツ古シツつォツづ可猟ャツつオツづつィツつュ\n            if(e.cap==0){\n                isRevEdge[e.rIdx]=true;\n                G[e.to][e.rev].cap-=1;\n                e.cap++;\n            }\n        }\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n    fill(isRevEdge,isRevEdge+10001,false);\n    fill(decided,decided+10001,false);\n\twhile(1){\n\t\tfill(used,used+MAX_V,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow += f;\n\t}\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++){\n        int from,to;\n        cin>>from>>to;\n        add_edge(from,to,1,i);\n    }\n    int s,t;\n    cin>>s>>t;\n    int res=max_flow(s,t);\n    cout<<res<<endl;\n    set<int> ss;\n    for(int i = 0; i < m; i++)\n        if(isRevEdge[i])\n            ss.insert(i);\n    cout<<ss.size()<<endl;\n    for(set<int>::iterator it = ss.begin();it!=ss.end();it++){\n        cout<<(*it+1)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\n//edmonds_carpツづ個ヘツδ仰パツー\n//Verified PKU 1459\nbool find_augment_path(const vector<vector<int> > &capacity, const vector<vector<int> > &flow, vector<int> &augment_path, int S, int G) {\n    int N = (int)capacity.size();\n    queue<int> q;\n    vector<int> prev(N, -1);\n    q.push(S);\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        if(u == G) {\n            int pos = 0;\n            int v = G;\n            while(v != -1) {\n                augment_path[pos++] = v;\n                v = prev[v];\n            }\n            reverse(augment_path.begin(), augment_path.begin()+pos);\n            return true;\n        }\n        //Sourceツづ鳴づ債行ツつゥツづ按つ「ツづヲツつ、ツづ可つキツづゥ\n        for(int i = 0; i < N; ++i) {\n            if(i == S) continue;\n            if(prev[i] != -1) continue;\n            if(capacity[u][i] - flow[u][i] > 0) {\n                prev[i] = u;\n                q.push(i);\n            }\n        }\n    }\n    return false;\n}\n\n//Verified PKU 1459\n//ツノツーツド[S]ツつェSource, [G]ツつェTerminal\nvoid edmonds_carp(const vector<vector<int> > &capacity, vector<vector<int> > &flow, int S, int G) {\n    int N = (int)capacity.size();\n    vector<int> augment_path(N, -1);\n    while(find_augment_path(capacity, flow, augment_path, S, G)) {\n        int aug = INT_MAX;\n        for(int i = 0; augment_path[i] != G; ++i)\n            aug = min(aug, capacity[augment_path[i]][augment_path[i+1]] - flow[augment_path[i]][augment_path[i+1]]);\n        for(int i = 0; augment_path[i] != G; ++i) {\n            int u = augment_path[i], v = augment_path[i+1];\n            flow[u][v] += aug;\n            flow[v][u] = -flow[u][v];\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int> > capacity(N+1, vector<int>(N+1, 0)), capacity_idx(N+1, vector<int>(N+1, 0));\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        capacity[a][b] = capacity[b][a] = 1;\n        capacity_idx[a][b] = i+1;\n    }\n\n    int S, G;\n    cin >> S >> G;\n    vector<vector<int> > flow(N+1, vector<int>(N+1, 0));\n    edmonds_carp(capacity, flow, S, G);\n\n    int cap = 0;\n    for(int i = 1; i <= N; ++i) {\n        if(flow[i][G] != 0) cap += flow[i][G];\n    }\n\n    vector<int> changes;\n    for(int i = 1; i <= N; ++i) {\n        for(int j = 1; j <= N; ++j) {\n            if(flow[i][j] > 0) {\n                if(!capacity_idx[i][j]) changes.push_back(capacity_idx[j][i]);\n            }\n        }\n    }\n\n    cout << cap << endl;\n    cout << changes.size() << endl;\n    for(int i = 0; i < changes.size(); ++i) {\n        cout << changes[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    level.clear(); level.resize(G.size(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.clear(); iter.resize(G.size(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    rep(i, dinic.G[v].size()) {\n      edge& e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  rep(i, used_rev.size()) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntemplate<typename T>\nstruct Dinic{\n  struct edge{int to;T cap,rev;bool hoge,re;};\n  const T Inf = 1e9;\n  int V;\n  std::vector<std::vector<edge>>G;\n  std::vector<int> level;\n  std::vector<int> iter;\n  Dinic(int n):G(n),level(n),iter(n),V(n){}\n  void addEdge(int from, int to, T cap, bool hoge){\n    G[from].push_back((edge){to, cap, (T)G[to].size(),hoge,false});\n    G[to].push_back((edge){from, 0, (T)G[from].size()-1,hoge,true});\n  }\n  \n  void bfs(int s){\n    std::fill(level.begin(),level.end(),-1);\n    std::queue<int>que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n      int v = que.front();\n      que.pop();\n      for(int i = 0;i < G[v].size();i++){\n\tedge &e = G[v][i];\n\tif(e.cap>0 && level[e.to] < 0){\n\t  level[e.to] = level[v]+1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  \n  T dfs(int v,int t,T f){\n    if(v == t)return f;\n    for(int &i = iter[v];i < G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n\tT d = dfs(e.to, t ,std::min(f,e.cap));\n\tif(d > 0){\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    } \n    return 0;\n  }\n\n  T execution(int s, int t){\n    T flow = 0;\n    while(true){\n      bfs(s);\n      if(level[t] < 0)return flow;\n      std::fill(iter.begin(),iter.end(),0);\n      //memset(iter_,0,sizeof(iter_));\n      T f;\n      while((f = dfs(s,t,Inf))>0){\n\tflow += f;\n      }\n    }\n  }\n};\n\nmap<pair<int,int>,int>ma;\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,m;cin>>n>>m;\n  Dinic<int>dinic(n);\n  for(int i=0;i<m;i++){\n    int f,t;cin>>f>>t;\n    f--;t--;\n    ma[mp(f,t)] = i+1;\n    dinic.addEdge(f,t,1,false);\n    dinic.addEdge(t,f,1,true);\n  }\n  int s,t;cin>>s>>t;\n  s--;t--;\n  cout<<dinic.execution(s,t)<<endl;\n  set<int> ans;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<dinic.G[i].size();j++){\n      if(dinic.G[i][j].cap > 0){\n\tif(dinic.G[i][j].re == true || (dinic.G[i][j].hoge == true)){\n\t  if(ma[mp(i,dinic.G[i][j].to)] != 0){\n\t    ans.insert(ma[mp(i,dinic.G[i][j].to)]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans.size()<<endl;\n  for(auto a:ans)cout<<a<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (?????????,??????,??????)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 334; // TODO:initialize\nconst int F_INF = 1234567; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,cap,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nint main()\n{\n    int n,m;\n    cin >>n >>m;\n    vector<int> x(m), y(m);\n    rep(i,m)\n    {\n        cin >>x[i] >>y[i];\n        --x[i];\n        --y[i];\n        add_edge(x[i],y[i],1);\n    }\n\n    int S,T;\n    cin >>S >>T;\n    --S;\n    --T;\n\n    cout << max_flow(S,T) << endl;\n\n    vector<int> ans;\n    rep(i,m)\n    {\n        for(const auto &e:G[x[i]])\n        {\n            if(e.to==y[i] && e.cap==2)\n            {\n                ans.pb(i);\n                break;\n            }\n        }\n    }\n\n    cout << ans.size() << endl;\n    rep(i,ans.size()) cout << ans[i]+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\n\n\nstruct tumiki {\n\tlong long int x;\n\tlong long int y;\n\tlong long int id;\n};\n\nclass Compare {\npublic:\n\tbool operator()(const pair<int,long long  int>&l, const pair<int, long long int >&r) {\n\t\treturn l.second > r.second;\n\t}\n};\n\nstruct island {\n\tint id;\n\tint sink;\n\tvector<pair<int,int> >edges;\n\tisland(int N):edges(N) {\n\n\t}\n};\n\n\n\n\n#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = 2147483647;\n\ntypedef int Weight;\nstruct Edge {\n\tint id;\n\tbool real;\n\tint src, dst;\n\tWeight weight;\n\tEdge(bool real,int id,int src, int dst, Weight weight) :\n\t\tid(id),real(real),src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\nvector<pair<int, int>>uses;\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &g, int s, int t) {\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tint now = t;\n\t\twhile (prev[now]!=now&&prev[now]!=-1) {\n\t\t\tuses.push_back({ prev[now], now });\n\t\t\tnow = prev[now];\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tGraph g(N);\n\t\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tg[x].push_back(Edge(true,i,x, y, 1));\n\t\tg[y].push_back(Edge(false, i,y, x, 1));\n\t}\n\tint S, T; cin >> S >> T;\n\tS--; T--;\n\tint ans=maximumFlow(g, S, T);\n\n\tvector<int>changes(M, 1);\n\tfor (int i = 0; i < uses.size(); ++i) {\n\t\tfor (int j = 0; j < g[uses[i].first].size(); ++j) {\n\t\t\tif (g[uses[i].first][j].dst == uses[i].second){\n\t\t\t\tif (g[uses[i].first][j].real) {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvector<int>cs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (changes[i] == 0) {\n\t\t\tcs.push_back(i + 1);\n\t\t}\n\t}\n\tcout << ans << endl << cs.size() << endl;\n\tfor (int i = 0; i < cs.size(); ++i) {\n\t\tcout << cs[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f,N=5000;\nstruct Edge{int fr,to;};\nvector<Edge>E;\nvector<int>G[N];\nbitset<N>Used;\nint\tDis[N],Src[N];\nvoid addEdge(const int x,const int y){\n\tE.push_back((Edge){x,y});G[x].push_back(E.size()-1);\n\tE.push_back((Edge){y,x});G[y].push_back(E.size()-1);\n}\nbool bfs(const int St,const int Ed){\n\tmemset(Dis,0x3f,sizeof(Dis));\n\tqueue<int> que;que.push(St);Dis[St]=0;\n\twhile(!que.empty()){\n\t\tint t=que.front();que.pop();\n\t\tfor(int i=0;i<G[t].size();i++){\n\t\t\tEdge tmp=E[G[t][i]];int j=G[t][i],w=j%2;\n\t\t\tif(Dis[tmp.to]>Dis[t]+w&&!Used[j]&&!Used[j^1])\n\t\t\t\tDis[tmp.to]=Dis[t]+w,Src[tmp.to]=j,que.push(tmp.to);\n\t\t}\n\t}\n\treturn Dis[Ed]<INF;\n}\nint dfs(const int St,const int Ed){\n\tfor(int i=Ed;i!=St;i=E[Src[i]].fr)\n\t\tUsed.set(Src[i]);\n\treturn 1;\n}\nvoid solveProblem(const int St,const int Ed){\n\tint maxFlow=0,reEdge=0;\n\tqueue<int> que;\n\twhile(bfs(St,Ed))\n\t\tmaxFlow+=dfs(St,Ed);\n\tcout<<maxFlow<<endl;\n\tfor(int i=1;i<E.size();i+=2)\n\t\tif(Used[i])\n\t\t\treEdge++,que.push(i/2+1);\n\tcout<<reEdge<<endl;\n\twhile(!que.empty())\n\t\tcout<<que.front()<<endl,que.pop();\n}\nint main(void){\n\tint n,m,x,y;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t\tcin>>x>>y,addEdge(x,y);\n\tcin>>x>>y;\n\tUsed.reset();\n\tsolveProblem(x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAXV = 300;\nconst int MAXE = MAXV * MAXV;\nconst int MAXF = (1<<29);\ntypedef int F;\n\nstruct MaxFlow {\n    F cap[MAXE], flow[MAXE];\n    int V, E, level[MAXV], prev[MAXE], edge[MAXV], to[MAXE];\n    MaxFlow(int n) : E(0) {\n        V = n;\n        memset(flow, 0, sizeof(flow));\n        memset(prev, -1, sizeof(prev));\n        memset(edge, -1, sizeof(edge));\n    }\n    void add_edge(int s, int t, F f, F g = 0) {\n        cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // make level graph (bfs)\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    int augment(int s, int t, F f) { // find augment path (dfs)\n        if (s == t || f == 0) return f;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f, cap[e] - flow[e]));\n                if (g > 0) {\n                    flow[e] += g, flow[e^1] -= g;\n                    return g;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int f, ret = 0;\n        for (bool cont = true; cont; ) {\n            cont = false;\n            make_level(s);\n            while ((f = augment(s, t, MAXF)) > 0) {\n                cont = true;\n                ret += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int x[MAXE], y[MAXE];\n    int N,M,a,b;\n    cin>>N>>M;\n    MaxFlow mf(N);\n    for (int i=0; i<M; ++i) {\n        cin>>a>>b; a--, b--;\n        mf.add_edge(a, b, 1, 1);\n        x[i] = a, y[i] = b;\n    }\n    cin>>a>>b; a--, b--;\n    cout<<mf.max_flow(a, b)<<endl;\n    vector<int> rev;\n    for (int i=0; i<M; ++i) {\n        int e = mf.edge[y[i]];\n        while(e != -1) {\n            if (mf.to[e] == x[i] && mf.flow[e] > 0) rev.push_back(i);\n            e = mf.prev[e];\n        }\n    }\n    cout<<rev.size()<<endl;\n    for (int i=0; i<rev.size(); ++i) cout<<rev[i]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<28\n#define MAX_V 500\nstruct edge { int to,cap,rev; };\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nint add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n  return G[from].size()-1;\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front();que.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e = G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n\tlevel[e.to]=level[v]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\ntypedef pair<int,int> P;\nint main(){\n  int n,m,i,j,k,s,t;\n  vector<P> v;\n  vector<int> ans;\n  cin>>n>>m;\n  for(i=0;i<m;i++) {\n    cin>>s>>t;\n    add_edge(s,t,1);\n    v.push_back(P(t,add_edge(t,s,1)));\n  }\n  cin>>s>>t;\n  cout << max_flow(s,t) << endl;\n  for(i=0;i<m;i++){\n    if(G[v[i].first][v[i].second].cap) continue;\n    ans.push_back(i+1);\n  }\n  cout<<ans.size()<<endl;\n  for(i=0;i<ans.size();i++) cout<<ans[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n#define maxn 200000\n#define maxe 1000000\n#define MAX 999999999\nstruct bian\n{\n\tint u,v,flow,cap;\n\tint next,pair;\n}edge[maxe];\nint head[maxn];\nint n,m;\nint ans[1100];\nint top;\nint dis[maxn];\nint s,t;\nint have[310][310];\nint lc[maxn];\nint pre[maxn];\nint ce[maxn];\nint num;\nint sap()\n{\n\tint a,f,u,tmp,neck,h;\n\tint i;\n\tmemset(dis,0,sizeof(dis));\n\tmemset(lc,0,sizeof(lc));\n\tmemset(pre,-1,sizeof(pre));\n\tfor(i=1;i<=n;i++)\n\t\tce[i]=head[i];\n//\tlc[n]=n;\n\tlc[0]=n;\n\tf=0;\n\tu=s;\n\twhile(dis[s]<n)\n\t{\n\t\tif(u==t)\n\t\t{\n\t\t\ta=MAX;\n\t\t\tfor(i=s;i!=t;i=edge[ce[i]].v)\n\t\t\t{\n\t\t\t\tif(a>edge[ce[i]].cap)\n\t\t\t\t{\n\t\t\t\t\tneck=i;\n\t\t\t\t\ta=edge[ce[i]].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=s;i!=t;i=edge[ce[i]].v)\n\t\t\t{\n\t\t\t\ttmp=ce[i];\n\t\t\t\tedge[tmp].cap-=a;\n\t\t\t\tedge[tmp].flow+=a;\n\t\t\t\ttmp=edge[tmp].pair;\n\t\t\t\tedge[tmp].cap+=a;\n\t\t\t\tedge[tmp].flow-=a;\n\t\t\t}\n\t\t\tf+=a;\n\t\t\tu=neck;\n\t\t}\n\t\tfor(h=ce[u];h!=-1;h=edge[h].next)\n\t\tif(edge[h].cap>0&&dis[u]==dis[edge[h].v]+1)\n\t\t\tbreak;\n\t\tif(h!=-1)\n\t\t{\n\t\t\tce[u]=h;\n\t\t\tpre[edge[h].v]=u;\n\t\t\tu=edge[h].v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(--lc[dis[u]]==0)\n\t\t\t\tbreak;\n\t\t\tce[u]=head[u];\n\t\t\ttmp=n-1;\n\t\t\tfor(h=head[u];h!=-1;h=edge[h].next)\n\t\t\t\tif(edge[h].cap>0)\n\t\t\t\t\ttmp=min(tmp,dis[edge[h].v]);\n\t\t\tdis[u]=tmp+1;\n\t\t\tlc[dis[u]]++;\n\t\t\tif(u!=s)\n\t\t\t\tu=pre[u];\n\t\t}\n\t}\n\treturn f;\n}\nvoid add(int u,int v,int w)\n{\n\tedge[num].u=u;\n\tedge[num].v=v;\n\tedge[num].flow=0;\n\tedge[num].cap=w;\n\tedge[num].next=head[u];\n\tedge[num].pair=num+1;\n\thead[u]=num++;\n\tedge[num].u=v;\n\tedge[num].v=u;\n\tedge[num].flow=0;\n\tedge[num].cap=1;\n\tedge[num].next=head[v];\n\tedge[num].pair=num-1;\n\thead[v]=num++;\n}\nint main()\n{\n//\tfreopen(\"1.txt\",\"r\",stdin);\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tnum=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(have,0,sizeof(have));\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tadd(u,v,1);\n\t\t\thave[u][v]=i;\n\t\t}\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tprintf(\"%d\\n\",sap());\n\t\ttop=0;\n\t\tfor(int i=0;i<num;i++)\n\t\t{\n\t\t\tif(edge[i].flow<0)\n\t\t\t{\n\t\t\t\tint u=edge[i].u;\n\t\t\t\tint v=edge[i].v;\n\t\t\t\tif(have[u][v])\n\t\t\t\t\tans[top++]=have[u][v];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",top);\n\t\tfor(int i=0;i<top;i++)\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int inf =1 << 29;\nstruct edge{int to,cap,rev,idx;};\n\nclass dinic{\n\tpublic :\n\t\tvector< vector<edge> > G;\n\n\t\tvoid init(int _n){\n\t\t\tn=_n;\n\t\t\tG.resize(n);\n\t\t\titer.resize(n);\n\t\t\tlevel.resize(n);\n\t\t}\n\n\t\tvoid add_edge(int from,int to ,int cap, int i){\n\t\t\tG[from].push_back((edge){to,cap,(int)G[to].size(),i});\n\t\t\tG[to].push_back((edge){from,0,(int)G[from].size()-1,-1});\n\t\t}\n\t\n\t\tvoid add_edge_both(int from,int to ,int cap, int i){\n\t\t\tadd_edge(from,to,cap,i);\n\t\t\tadd_edge(to,from,cap,i);\n\t\t}\n\t\n\t\tint max_flow(int s,int t){\n\t\t\tint flow=0;\n\t\t\tfor(;;){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t]<0) return flow;\n\t\t\t\titer.assign(n,0);\n\t\t\t\tint f;\n\t\t\t\twhile((f=dfs(s,t,DINIC_INF))>0){\n\t\t\t\t\tflow+=f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprivate:\n\t\tint n;\n\t\tstatic const int DINIC_INF = inf;\n\t\tvi level;\n\t\tvi iter;\n\t\n\t\tvoid bfs(int s){\n\t\t\tlevel.assign(n,-1);\n\t\t\tqueue<int> que;\n\t\t\tlevel[s]=0;\n\t\t\tque.push(s);\n\t\t\twhile(!que.empty()){\n\t\t\t\tint v=que.front();que.pop();\n\t\t\t\tfor(int i=0;i< (int)G[v].size(); i++){\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0 && level[e.to] <0){\n\t\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dfs(int v,int t,int f){\n\t\t\tif(v==t) return f;\n\t\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\t\tedge &e= G[v][i];\n\t\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\t\tif(d>0){\n\t\t\t\t\t\te.cap -=d;\n\t\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\t\n};\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m; cin >> n >> m;\n    dinic d; d.init(n);\n    using Ein = tuple<int, int>;\n    vector<Ein> edges(m);\n    rep(i, m){\n        int a, b; cin >> a >> b;\n        a--, b--;\n        edges[i] = Ein(a, b);\n        d.add_edge_both(a, b, 1, i);\n    }\n    int S, T; cin >> S >> T; S--, T--;\n\n    int res = d.max_flow(S, T);\n    set<int> s;\n    rep(v, n){\n        for(auto& e : d.G[v]){\n            int i = e.idx;\n            if(i == -1) continue;\n            int a, b; tie(a, b) = edges[i];\n            if(e.cap == 0 and v != a){\n                s.insert(i);\n            }\n        }\n    }\n\n    cout << res << endl;\n    cout << s.size() << endl;\n    for(auto& e : s){\n        cout << e + 1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAXV = 300;\nconst int MAXE = MAXV * MAXV;\nconst int MAXF = (1<<29);\ntypedef int F;\n\nstruct MaxFlow {\n    F cap[MAXE], flow[MAXE];\n    int V, E, level[MAXV], prev[MAXE], edge[MAXV], to[MAXE];\n    MaxFlow(int n) : E(0) {\n        V = n;\n        memset(flow, 0, sizeof(flow));\n        memset(prev, -1, sizeof(prev));\n        memset(edge, -1, sizeof(edge));\n    }\n    void add_edge(int s, int t, F f, F g = 0) {\n        cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // make level graph (bfs)\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    int augment(int s, int t, F f) { // find augment path (dfs)\n        if (s == t || f == 0) return f;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f, cap[e] - flow[e]));\n                if (g > 0) {\n                    flow[e] += g, flow[e^1] -= g;\n                    return g;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int f, ret = 0;\n        for (bool cont = true; cont; ) {\n            cont = false;\n            make_level(s);\n            while ((f = augment(s, t, MAXF)) > 0) {\n                cont = true;\n                ret += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int x[MAXE], y[MAXE];\n    int N,M,a,b;\n    cin>>N>>M;\n    MaxFlow mf(N);\n    for (int i=0; i<M; ++i) {\n        cin>>a>>b; a--, b--;\n        mf.add_edge(a, b, 1, 1);\n        x[i] = a, y[i] = b;\n    }\n    cin>>a>>b; a--, b--;\n    cout<<mf.max_flow(a, b)<<endl;\n    vector<int> rev;\n    for (int i=0; i<M; ++i) {\n        int e = mf.edge[y[i]];\n        while(e != -1) {\n            if (mf.to[e] == x[i] && mf.flow[e] > 0) rev.push_back(i);\n            e = mf.prev[e];\n        }\n    }\n    cout<<rev.size()<<endl;\n    for (int i=0; i<rev.size(); ++i) cout<<rev[i]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int to, cap, rev, id; bool is_rev; };\nint V, E, S, T; vector<int> used; vector<vector<edge> > G;\nvoid add_edge(int v1, int v2, int cap, int id) {\n\tG[v1].push_back(edge{ v2, cap, (int)G[v2].size(), id, false });\n\tG[v2].push_back(edge{ v1, 0, (int)G[v1].size() - 1, id, true });\n}\nint rec(int p, int t, int f) {\n\tif (p == t) return f;\n\tused[p] = 1;\n\tfor (auto &e : G[p]) {\n\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\tint res = rec(e.to, t, min(e.cap, f));\n\t\tif (res) {\n\t\t\te.cap -= res, G[e.to][e.rev].cap += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint ret = 0;\n\twhile (true) {\n\t\tused = vector<int>(V, 0);\n\t\tint res = rec(s, t, 2147483647);\n\t\tif (!res) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> V >> E; G.resize(V);\n\tvector<int> x1(E), x2(E);\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x1[i] >> x2[i]; x1[i]--, x2[i]--;\n\t\tadd_edge(x1[i], x2[i], 1, i);\n\t\tadd_edge(x2[i], x1[i], 1, -1);\n\t}\n\tcin >> S >> T; S--, T--;\n\tcout << max_flow(S, T) << endl;\n\tvector<int> ret;\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (edge e : G[i]) {\n\t\t\tif (!e.is_rev && e.id >= 0 && e.cap == 0) ret.push_back(e.id);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\tcout << ret.size() << endl;\n\tfor (int i : ret) cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Flow = int;\nstruct FlowEdge {\n  int src, dst;\n  Flow cap;\n  int id;\n  bool dir;\n  int rev;\n  FlowEdge(const int s = 0, const int d = 0, const Flow c = 0, const int id = 0, const bool dir = false, const int r = 0) : src(s), dst(d), cap(c), id(id), dir(dir), rev(r) {}\n};\n\nusing FlowEdges = std::vector<FlowEdge>;\n\nclass FlowGraph {\n  std::vector<FlowEdges> g;\n  using iterator = std::vector<FlowEdges>::iterator;\n  using const_iterator = std::vector<FlowEdges>::const_iterator;\n\npublic:\n  FlowGraph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  FlowEdges &operator[](const int i) & { return g[i]; }\n\n  void addEdge(const int src, const int dst, const int id, const Flow c = 1) {\n    g[src].emplace_back(src, dst, c, id, true, g[dst].size());\n    g[dst].emplace_back(dst, src, c, id, false, g[src].size() - 1);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\n// Change it to 'FlowGraph &g' when you need a residual network\ntemplate<Flow inf = std::numeric_limits<Flow>::max() / 8> Flow dinic(FlowGraph &g, const int source, const int sink) {\n  std::vector<int> level(g.size()), iter(g.size());\n  auto bfs = [&] {\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> q;\n    level[source] = 0;\n    q.push(source);\n    while (q.size()) {\n      int v = q.front();\n      q.pop();\n      for (auto &e : g[v]) {\n        if (level[e.dst] >= 0 || e.cap <= 0) continue;\n        level[e.dst] = level[v] + 1;\n        q.push(e.dst);\n      }\n    }\n    return level[sink] >= 0;\n  };\n  std::function<Flow(int, Flow)> dfs = [&](int v, Flow f) -> Flow {\n    if (v == sink) return f;\n    Flow s = 0;\n    for (; iter[v] < g[v].size(); iter[v]++) {\n      auto &e = g[v][iter[v]];\n      if (level[v] >= level[e.dst] || e.cap <= 0) continue;\n      Flow d = dfs(e.dst, min(f, e.cap));\n      e.cap -= d;\n      g[e.dst][e.rev].cap += d;\n      s += d;\n      f -= d;\n      if (f == 0) break;\n    }\n    return s;\n  };\n  Flow s = 0;\n  while (bfs()) {\n    std::fill(iter.begin(), iter.end(), 0);\n    s += dfs(source, inf);\n  }\n  return s;\n}\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  FlowGraph g(n);\n  rep(i, m) {\n    int x, y;\n    cin >> x >> y;\n    g.addEdge(--x, --y, i + 1);\n  }\n  int s, t;\n  cin >> s >> t;\n  --s, --t;\n  Flow f = dinic(g, s, t);\n  vi v;\n  for (auto &es : g) {\n    for (auto &e : es) {\n      if (e.cap < 1 && !e.dir) v.push_back(e.id);\n    }\n  }\n  sort(all(v));\n  cout << f << endl;\n  cout << v.size() << endl;\n  for (auto x : v) cout << x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct P\n{\n  int to,cap,rev;\n  P(int to=-1,int cap=-1,int rev=-1):to(to),cap(cap),rev(rev){}\n};\ntypedef vector<int> VI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\ntypedef pair<int,int> Pes;\nint N,M,s,t; \nVVP G;\nvector<int> level,iter;\nvector<Pes> vec;\nvector<int> pvec;\nbool sign;\n\nvoid add_edge(int from,int to,int i)\n{\n  if(sign)vec.push_back(Pes(from,G[from].size())),\n\t    pvec.push_back(i);\n  G[from].push_back(P(to,1,G[to].size()));\n  G[to].push_back(P(from,0,G[from].size()-1));\n}\n\nvoid printVVP()\n{\n  cout << \"printVVP----------\" << endl;\n  rep(i,G.size())\n    {\n      rep(j,G[i] .size())\n\t{\n\t  cout << \"(\" << G[i][j].to << \",\" << G[i][j].cap << \",\" << G[i][j].rev << \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid bfs()\n{\n  deque<int> deq;\n  deq.push_back(s);\n  level[s] = 0;\n  while(!deq.empty())\n    {\n      int p = deq.front(); deq.pop_front();\n      rep(i,G[p].size())\n\t{\n\t  P pes = G[p][i];\n\t  int v = pes.to;\n\t  if(level[v] == -1 && pes.cap > 0)\n\t    {\n\t      level[v] = level[p]+1;\n\t      deq.push_back(v);\n\t    }\n\t}\n    }\n}\n\nvoid printVI(VI &g)\n{\n  cout <<\"printVI-------------\" << endl;\n  rep(i,g.size())\n    {\n      cout << g[i] << \" \";\n    }\n  cout << endl;\n}\n\nint dfs(int v,int flow)\n{\n  if(v == t)return flow;\n\n  for(int &i = iter[v];i < G[v].size();i++)\n    {\n      P p = G[v][i];\n\n      if(p.cap <= 0)continue;\n      if(level[v] < level[p.to])\n\t{\n\t  int d = dfs(p.to,min(flow,p.cap));\n\t  if(d <= 0)continue;\n\t  G[v][i].cap -= d;\n\t  G[p.to][p.rev].cap += d;\n\t  return d;\n\t    \n\t}\n    }\n  return 0;\n}\n\nint maximum_flow()\n{\n  int res = 0;\n  iter.resize(N);\n  level.resize(N);\n  while(1)\n    {\n      rep(i,N)\n\titer[i] = 0,level[i] = -1;\n       bfs();\n      \n       if(level[t] < 0)return res;\n       int f;\n  \n       while((f = dfs(s,(1<<29))) > 0)\n\t res += f;\n\t \n    }\n  return res;\n}\n\nint main()\n{\n  cin >> N >> M;\n  G.resize(N);\n  rep(i,M)\n    {\n      int from,to;\n      cin >> from >> to;\n      from--,to--;\n      sign = false;\n      add_edge(from,to,i);\n      sign = true;\n      add_edge(to,from,i);\n    }\n  cin >> s >> t;\n  s--,t--;\n  \n  int mexico = maximum_flow();\n  int cnt = 0;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)cnt++;\n    }\n\n  cout << mexico << endl;\n  cout << cnt << endl;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)\n\tcout << pvec[i]+1 << endl;\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstruct MaxFlow {\n  struct Edge {int to, cap, rev;};\n\n  const static int INF = 1e9;\n\n  int v;\n  vector<vector<Edge> > g;\n  vector<int> level, iter;\n\n  MaxFlow() : v(0) {}\n\n  int next() {\n    g.push_back(vector<Edge>());\n    level.push_back(0);\n    iter.push_back(0);\n    return v++;\n  }\n  \n  void add_edge(int from, int to, int cap) {\n    g[from].push_back((Edge){to, cap, int(g[to].size())});\n    g[to].push_back((Edge){from, cap, int(g[from].size()) - 1});\n  }\n\n  void bfs(int s) {\n    fill(level.begin(), level.end(), -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      rep (i, g[v].size()) {\n\tEdge &e = g[v][i];\n\tif (e.cap == 0 || level[e.to] >= 0) continue;\n\tlevel[e.to] = level[v] + 1;\n\tque.push(e.to);\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < int(g[v].size()); ++i) {\n      Edge &e = g[v][i];\n      if (e.cap == 0 || level[v] >= level[e.to]) continue;\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d == 0) continue;\n      e.cap -= d;\n      g[e.to][e.rev].cap += d;\n      return d;\n    }\n    return 0;\n  }\n\n  int run(int s, int t) {\n    int flow = 0, f;\n    while (true) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      fill(iter.begin(), iter.end(), 0);\n      while ((f = dfs(s, t, INF)) > 0) flow += f;\n    }\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  MaxFlow mf;\n  rep (i, n) mf.next();\n  vector<pair<int, int> > edge;\n  rep (i, m) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    mf.add_edge(x, y, 1);\n    edge.push_back(make_pair(x, y));\n  }\n  int s, t;\n  cin >> s >> t;\n  --s; --t;\n  cout << mf.run(s, t) << endl;\n  vector<int> res;\n  rep (i, m) {\n    bool found = false;\n    rep (j, mf.g[edge[i].second].size()) if (mf.g[edge[i].second][j].to == edge[i].first && mf.g[edge[i].second][j].cap == 0) found = true;\n    if (found) res.push_back(i + 1);\n  }\n  cout << res.size() << endl;\n  rep (i, res.size()) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int N=333;\nconst int E=1008611;\nconst int inf=1<<29;\n#define LL int\nstruct edge{\n    int u,v;\n    LL c,f;\n    int next;\n};\nint eh[N],tot;\nedge et[E];\nvoid add(int u,int v,LL c,LL f){\n    edge e={u,v,c,f,eh[u]};\n    et[tot]=e,eh[u]=tot++;\n}\nvoid addedge(int u,int v,LL c){\n    add(u,v,c,0),add(v,u,0,0);\n}\nint cur[N],cnt[N],dis[N],pre[N];\nLL low[N];\nvoid rebfs(int s,int t,int n){\n    for(int i=0;i<=n;i++){\n        cnt[i]=0;\n        dis[i]=n;\n    }\n    queue<int>q;\n    dis[t]=0;\n    cnt[0]=1;\n    q.push(t);\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(int now=eh[u];now!=-1;now=et[now].next){\n            if(et[now^1].c==0||dis[et[now].v]<n)continue;\n            dis[et[now].v]=dis[u]+1;\n            cnt[dis[et[now].v]]++;\n            q.push(et[now].v);\n        }\n    }\n}\nLL isap(int s,int t,int n) {      //s襍キ轤ケ?荊扈育せ?系荳コ轤ケ謨ー\n    rebfs(s,t,n);            //鬚?、?炊譛?洒霍ッ譬?捷\n    int u,v,now,i;\n    for(i=0;i<=n;i++) low[i]=0;\n    for(u=0;u<=n;u++) cur[u]=eh[u];\n    LL flow=0;\n    u=s;\n    low[s]=inf;\n    while(dis[s]<n){\n        for(now=cur[u];now!=-1;now=et[now].next)\n            if(et[now].c-et[now].f>0 && dis[u]==dis[v=et[now].v]+1)\n                break;\n        if(now!=-1){\n            cur[u]=now,pre[v]=now;\n            low[v]=et[now].c-et[now].f;\n            low[v]=min(low[v],low[u]);\n            u=v;\n            if(u==t){\n                for(;u!=s;u=et[pre[u]].u){\n                    et[pre[u]].f+=low[t];\n                    et[pre[u]^1].f-=low[t];\n                }\n                flow+=low[t];low[s]=inf;\n            }\n        }\n        else{\n            if(--cnt[dis[u]]==0) break;\n            dis[u]=n;\n            cur[u]=eh[u];\n            for(now=eh[u];now!=-1;now=et[now].next)\n                if(et[now].c-et[now].f>0 && dis[u]>dis[et[now].v]+1)\n                    dis[u]=dis[et[now].v]+1;\n            cnt[dis[u]]++;\n            if(u!=s) u=et[pre[u]].u;\n        }\n    }\n    return flow;\n}\nbool g[N][N];\nvoid init(){\n    tot=0;\n    memset(eh,-1,sizeof(eh));\n    memset(g,0,sizeof(g));\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        init();\n        while(m--){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            g[u][v]=1;\n            addedge(u,v,1);\n            addedge(v,u,1);\n        }\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%d\\n\",isap(s,t,n));\n        int cnt=0;\n        vector<int>r;\n        for(int i=0,j=1;i<tot;i+=4,j++){\n            int u=et[i].u,v=et[i].v;\n            if(et[i].f==0) swap(u,v);\n            if(!g[u][v]){\n                cnt++;\n                r.push_back(j);\n            }\n        }\n        printf(\"%d\\n\",cnt);\n        for(int i=0;i<cnt;i++) printf(\"%d\\n\",r[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define LOOP(i,x,n) for(int i=x;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define MP make_pair\n#define FIR first\n#define SEC second\n#define int long long\nusing namespace std;\nconst int MOD=1000000007;\nconst int INF=1000000009;\n\ntypedef int Flow;\nstruct Edge{\n  int src;int dst;int rev;\n  Flow cap;\n  Edge(int s=0,int d=0,Flow c=0,int r=0):\n  src(s),dst(d),cap(c),rev(r){}\n};\n\nusing Graph = vector<vector<Edge>>;\nGraph g;\nbool used[100005];\nint n,m;\n\nvector<int> times(1000);\n\n\nvoid add(int src,int dst,int cap){\n  g[src].emplace_back(src,dst,cap,g[dst].size());\n  g[dst].emplace_back(dst,src,0,g[src].size()-1);\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  REP(i,g[v].size()){\n    Edge &e=g[v][i];\n    if(!used[e.dst]&&e.cap>0){\n      int d=dfs(e.dst,t,min(f,e.cap));\n      if(d>0){\n        times[i]++;\n        e.cap-=d;\n        g[e.dst][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maximum_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+100005,0);\n    int f=dfs(s,t,INF);\n    if(!f) return flow;\n    flow+=f;\n  }\n}\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  g=Graph(500);\n  REP(i,m){\n    int x,y;\n    cin>>x>>y;\n    add(x,y,1);\n    add(y,x,1);\n  }\n  int s,t;\n  cin>>s>>t;\n  cout<<maximum_flow(s,t)<<endl;\n  int sum=0;\n  LOOP(i,1,n+1)if(times[i]>=1)sum++;\n  cout<<sum<<endl;\n  if(sum!=0){\n    LOOP(i,1,n+1){\n      if(times[i]>0)cout<<i<<endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#define sf scanf\n#define pf printf\nusing namespace std;\nqueue<int> road;\nconst int maxn = 300 +10;\nbool initial_edge[maxn][maxn];\nint Edge[maxn][maxn][2];\nbool vis[maxn][maxn];\nbool vis_node[maxn];\nint n,m;\nint S,T;\nint ans;\nvoid read()\n{\n    memset(initial_edge,0,sizeof(initial_edge));\n    memset(Edge,0,sizeof(Edge));\n    memset(vis,0,sizeof(vis));\n    int i,j;\n    sf(\"%d%d\",&n,&m);\n    for(int k = 1;k <= m;++k)\n    {\n        sf(\"%d%d\",&i,&j);\n        Edge[i][j][0] = Edge[j][i][0] = true;\n        Edge[i][j][1] = Edge[j][i][1] = k;\n        initial_edge[i][j] = true;\n    }\n    sf(\"%d%d\",&S,&T);\n}\n\n\nbool dfs(int cur)\n{\n//    pf(\"%d\\n\",cur);\n    if(cur == T)\n    {\n        ans++;\n        return true;\n    }\n    for(int i = 1;i <= n;++i)\n    {\n        if(!vis_node[i] && !vis[cur][i] && Edge[cur][i][0])\n        {\n            vis_node[i] = true;\n            if( dfs(i) )\n            {\n//                pf(\"cur  = %d i = %d \",cur,i);\n                vis[cur][i] = vis[i][cur] = true;\n                if( Edge[cur][i][0] != initial_edge[cur][i])\n                {\n                    road.push(Edge[cur][i][1]);\n                }\n                return true;\n            }\n            vis_node[i] = false;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n//    freopen(\"read.txt\",\"r\",stdin);\n    read();\n    memset(vis_node,0,sizeof(vis_node));\n//    pf(\"%d %d\",S,T);\n    while(true)\n    {\n        vis_node[S] = true;\n        if( !dfs(S) )\n            break;\n        memset(vis_node,0,sizeof(vis_node));\n    }\n    pf(\"%d\\n%d\\n\",ans,road.size());\n    while(!road.empty())\n    {\n        cout << road.front() << endl;\n        road.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<stdlib.h>\n#include<ctype.h>\n#include<queue>\n#include<bitset>\n#include<deque>\n#include<set>\n#include<time.h>\n#include<math.h>\n#include<sstream>\n#include<functional>\n#include<stack>\n#include<map>\n#include<vector>\nusing namespace std;\n\n#define maxn 309\n#define inf 1000000\n//------------------------Dinic模板\nstruct edge\n{\n    int v, Next;\n    int val;\n} net[ 100010 ];\n\nint level[maxn], Qu[maxn], out[maxn],Next[maxn];\nclass Dinic {\npublic:\n    int end;\n    Dinic() {\n        end = 0;\n        memset( Next, -1, sizeof(Next) );\n    }\n    inline void insert( int x, int y, int c) {\n        net[end].v = y, net[end].val = c,\n        net[end].Next = Next[x],\n        Next[x] = end ++;\n        net[end].v = x, net[end].val = c,\n        net[end].Next = Next[y],\n        Next[y] = end ++;\n    }\n    bool BFS( int S, int E ) {\n        memset( level, -1, sizeof(level) );\n        int low = 0, high = 1;\n        Qu[0] = S, level[S] = 0;\n        for( ; low < high; ) {\n            int x = Qu[low];\n            for( int i = Next[x]; i != -1; i = net[i].Next ) {\n                if( net[i].val == 0 ) continue;   \n                int y = net[i].v;   \n                if( level[y] == -1 ) {   \n                    level[y] = level[x] + 1;   \n                    Qu[ high ++] = y;   \n                }\n            }\n            low ++;\n        }\n        return level[E] != -1;\n    }\n    int MaxFlow( int S, int E ){\n        int maxflow = 0;\n        for( ; BFS(S, E) ; ) {\n            memcpy( out, Next, sizeof(out) );\n            int now = -1;\n            for( ;; ) {\n                if( now < 0 ) {\n                    int cur = out[S];\n                    for(; cur != -1 ; cur = net[cur].Next )\n                        if( net[cur].val && out[net[cur].v] != -1 && level[net[cur].v] == 1 )   \n                            break;\n                    if( cur >= 0 ) Qu[ ++now ] = cur, out[S] = net[cur].Next;   \n                    else break;\n                }\n                int u = net[ Qu[now] ].v;\n                if( u == E ) {\n                    int flow = inf;\n                    int index = -1;\n                    for( int i = 0; i <= now; i ++ ) {\n                        if( flow > net[ Qu[i] ].val )\n                            flow = net[ Qu[i] ].val, index = i;\n                    }\n                    maxflow += flow;\n                    for( int i = 0; i <= now; i ++ )\n                        net[Qu[i]].val -= flow, net[Qu[i]^1].val += flow;   \n                    for( int i = 0; i <= now; i ++ ) {\n                        if( net[ Qu[i] ].val == 0 ) {\n                            now = index - 1;\n                            break;\n                        }\n                    }\n                }\n                else{\n                    int cur = out[u];\n                    for(; cur != -1; cur = net[cur].Next )\n                        if (net[cur].val && out[net[cur].v] != -1 && level[u] + 1 == level[net[cur].v])   \n                            break;\n                    if( cur != -1 )\n                        Qu[++ now] = cur, out[u] = net[cur].Next;\n                    else out[u] = -1, now --;\n                }\n            }\n        }\n        return maxflow;\n    }\n};\nint Map[309][309];\nint main()\n{\n\t\n\tint n,m;\n\tint u,v,s,t;\n\t\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tmemset(Map,0,sizeof(Map));\n\t\tint cnt=1;\n\t\tDinic ss;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tMap[u][v]=cnt++;\n\t\t\tss.insert(u,v,1);\n\t\t\t//ss.insert(v,u,1);\n\t\t}\n\t\tcin >> s >> t;\n\t\tcout <<ss.MaxFlow(s,t) <<endl;\n\t\tint ans[309];\n\t\tcnt=0;\n\t\tfor(int i=0;i<ss.end;i++){\n\t\t\tif(net[i].val > 0 && i%2==0)\n\t\t\t\tans[cnt++] = i/2+1;\n\t\t}\n\t\tcout << cnt << endl;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\n#define EACH(i,t,c) for(t::const_iterator i=(c).begin();i!=(c).end();++i)\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst int INF=INT_MAX/10;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight augment(const Graph &g, const Matrix &capacity, Matrix &flow,\n    const vector<int> &level, vector<bool> &finished, int u, int t, Weight cur) {\n  if (u == t || cur == 0) return cur;\n  if (finished[u]) return 0;\n  finished[u] = true;\n  EACH(e, Edges, g[u]) if (level[e->dst] > level[u]) {\n    Weight f = augment(g, capacity, flow, level, finished,\n        e->dst, t, min(cur, RESIDUE(u, e->dst)));\n    if (f > 0) {\n      flow[u][e->dst] += f; flow[e->dst][u] -= f;\n      finished[u] = false;\n      return f;\n    }\n  }\n  return 0;\n}\nWeight maximumFlow(const Graph &g, int s, int t, Matrix &flow) {\n  int n = g.size();\n  Matrix capacity(n, Array(n)); // adj. matrix\n  REP(u,n) EACH(e,Edges,g[u]) capacity[e->src][e->dst] += e->weight;\n\n  Weight total = 0;\n  for (bool cont = true; cont; ) {\n    cont = false;\n    vector<int> level(n, -1); level[s] = 0; // make layered network\n    queue<int> Q; Q.push(s);\n    for (int d = n; !Q.empty() && level[Q.front()] < d; ) {\n      int u = Q.front(); Q.pop();\n      if (u == t) d = level[u];\n      EACH(e, Edges, g[u]) if (RESIDUE(u,e->dst) > 0 && level[e->dst] == -1)\n        Q.push(e->dst), level[e->dst] = level[u] + 1;\n    }\n    vector<bool> finished(n); // make blocking flows\n    for (Weight f = 1; f > 0; ) {\n      f = augment(g, capacity, flow, level, finished, s, t, INF);\n      if (f == 0) break;\n      total += f; cont = true;\n    }\n  }\n  return total;\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tGraph g(n,Edges());\n\tGraph gNondir(n,Edges());\n\tvi x(m),y(m);\n\tREP(i,m){\n\t\tcin>>x[i]>>y[i],x[i]--,y[i]--;\n\t\tg[x[i]].push_back(Edge(x[i],y[i],1));\n\t\tgNondir[x[i]].push_back(Edge(x[i],y[i],1));\n\t\tgNondir[y[i]].push_back(Edge(y[i],x[i],1));\n\t}\n\tint start,goal;\n\tcin>>start>>goal,start--,goal--;\n\n\tMatrix flow(n, Array(n));\n\tWeight mf=maximumFlow(gNondir,start,goal,flow);\n\tcout<<mf<<endl;\n\tvi reversed;\n\tREP(i,m){\n\t\tif(flow[y[i]][x[i]]>0){\n\t\t\treversed.push_back(i+1);\n\t\t}\n\t}\n\tcout<<reversed.size()<<endl;\n\tREP(i,reversed.size()){\n\t\tcout<<reversed[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,a,b;\nint G[500][500];\nint from[3000],to[3000];\nbool visited[500];\n\nbool dfs(int pos,int ti){\n  if(pos==ti)return true;\n  visited[pos]=true;\n  for(int i=1;i<=N;i++){\n    if(visited[i])continue;\n    if(G[pos][i]==0)continue;\n    if(dfs(i,ti)){\n      G[pos][i]--;\n      G[i][pos]++;\n      return true;\n    }\n  }\n  return false;\n}\n\nint max_flow(int si,int ti){\n  int res=0;\n  while(1){\n    for(int i=1;i<=N;i++)visited[i]=false;\n    if(dfs(si,ti))res++;\n    else break;\n  }\n  return res;\n}\n\nint main(){\n  cin>>N>>M;\n  for(int i=1;i<=M;i++){\n    cin>>a>>b;\n    G[a][b]++;\n    G[b][a]++;\n    from[i]=a;\n    to[i]=b;\n  }\n  cin>>a>>b;\n  cout<<max_flow(a,b)<<endl;\n  vector<int> ans;\n  for(int i=1;i<=M;i++){\n    a=from[i],b=to[i];\n    if(G[b][a]==0)ans.push_back(i);\n  }\n  cout<<ans.size()<<endl;\n  for(int i=0;i<(int)ans.size();i++)cout<<ans[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1000000000;\nconst int N = 610;\n#define CLR(arr,val) memset(arr,val,sizeof(arr));\n#define min(a,b) ((a)<(b)?(a):(b))\n\n#define MAXN 610\ntypedef int elem_t;\n\nelem_t maxflow(int n,elem_t mat[][MAXN],int source,int sink,elem_t flow[][MAXN]){\n\tint pre[MAXN],que[MAXN],p,q,t,i,j;\n\telem_t d[MAXN],s;\n\tif (source==sink)\n\t\treturn inf;\n\tfor (i=0;i<n;i++)\n\t\tfor (j=0;j<n;j++)\n\t\t\tflow[i][j]=0;\n\tfor (pre[sink]=1;pre[sink];){\n\t\tfor (i=0;i<n;pre[i++]=0);\n\t\tpre[t=source]=source+1,d[t]=inf;\n\t\tfor (p=0,q=1;p<q&&!pre[sink];t=que[++p])\n\t\t\tfor (i=0;i<n;i++)\n\t\t\t\tif (!pre[i]&&mat[t][i]&&(s=mat[t][i]-flow[t][i])>0)\n\t\t\t\t\tpre[que[q++]=i]=t+1,d[i]=d[t]<s?d[t]:s;\n\t\t\t\telse if (!pre[i]&&mat[i][t]&&(s=flow[i][t])>0)\n\t\t\t\t\tpre[que[q++]=i]=-t-1,d[i]=d[t]<s?d[t]:s;\n\t\tfor (i=sink;pre[i]&&i!=source;)\n\t\t\tif (pre[i]>0)\n\t\t\t\tflow[pre[i]-1][i]+=d[sink],i=pre[i]-1;\n\t\t\telse\n\t\t\t\tflow[i][-pre[i]-1]-=d[sink],i=-pre[i]-1;\n\t}\n\tfor (s=i=0;i<n;i++)\n\t\ts+=flow[source][i];\n\treturn s;\n}\n\nint mat[MAXN][MAXN],flow[MAXN][MAXN],a[N],b[N],s,t,ans[N],cnt;\nint main(){\n\tint n,m;\n\twhile( scanf(\"%d%d\", &n, &m) != EOF ){\n\t\tCLR( mat, 0 );\n\t\tfor(int i=0 ; i < m ; ++i){\n\t\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\t\tmat[a[i]][b[i]] = mat[b[i]+n][a[i]+n] = 1;\n\t\t}\n\t\tfor(int i=1 ; i <= n ; ++i) mat[i][i+n] = inf;\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tmat[0][s] = inf;\n\t\tmat[t+n][2*n+1] = inf;\n\t\tint mf = maxflow(2*n+2,mat,0,2*n+1,flow);\n\t\tprintf(\"%d\\n\", mf);\n\t\tCLR( ans, 0 );\n\t\tcnt = 0;\n\t\tfor(int i=0 ; i < m ; ++i)\n\t\t\tif( flow[b[i]+n][a[i]+n] != 0 )\n\t\t\t\tans[cnt++] = i+1;\n\t\tprintf(\"%d\\n\", cnt);\n\t\tfor(int i=0 ; i < cnt ; ++i)\n\t\t\tprintf(\"%d\\n\", ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#define FOR(i,s,t) for (int i = s; i < t; i++)\n#define SZ(x) (int)x.size()\nusing LL = long long; using ll = LL;\nusing VI = vector<int>; using VL = vector<LL>;\nconst LL INF = 1e9; const LL LINF = 1e18;\n#define debug(x) cout<<#x<<\":=\"<<x<<endl\ntypedef pair<ll, ll> pll;\n\nstruct FF {\n#define MS  1005\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge() {}\n\t\tedge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {}\n\t};\n\tvector<edge>G[MS];\n\tbool used[MS];\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].emplace_back(edge(to, cap, (int)G[to].size()));\n\t\tG[to].emplace_back(edge(from, cap, (int)G[from].size()-1));\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tused[v] = 1;\n\t\tFOR(i, 0, SZ(G[v])) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tconst int inf = INT_MAX;\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, inf);\n\t\t\tif (f == 0)return flow;\n\t\t\tflow += f;\n\t\t}\n\t\treturn -1;\n\t}\n#undef MS\n};\n\nint main() {\n\n\tint N, M; int s, t;\n\t// 1-index\n\tcin >> N >> M;\n\tvector<VI> G(N);\n\tmap<pll, int>Map;\n\tFF F;\n\tvector<pll>inedge(M);\n\tFOR(i, 0, M) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\t\n\t\tinedge[i] = pll(x, y);\n\t\tF.add_edge(x, y, 1);\n\t\tG[x].push_back(y);\n\t\tMap[pll(x, y)] = i+1;\n\t}\n\tcin >> s >> t;\n\ts--, t--;\n\tcout << F.max_flow(s, t) << endl;\n\tset<int> ans;\n\tFOR(i, 0, M) {\n\t\tint x, y; tie(x, y) = inedge[i];\n\t\tFOR(j, 0, SZ(F.G[x])) {\n\t\t\tint nv = F.G[x][j].to;\n\t\t\tif (nv == y) { // 本来の有向辺\n\t\t\t\tif (F.G[x][j].cap==2) {\n\t\t\t\t\tans.insert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << SZ(ans) << endl;\n\tfor (auto it : ans) {\n\t\tcout << it+1 << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nconst int fa=401;\nconst int ma=99999999;\nusing namespace std;\nint n,m;\nint mp[fa][fa];\nint cost[fa][fa];\nstruct wgh\n{\n    int x,y;\n}a[10001];\nint d[fa],nu;\nint path[fa],b[100001];\nint ans;bool v[fa];\nint x,y,z,w,s,t;\nbool spfa()\n{\n    int i,j,l,r;\n    memset(path,0,sizeof(path));\n    memset(v,false,sizeof(v));\n    for(i=1;i<=n;i++)d[i]=ma;\n    l=0;r=1;\n    d[s]=0;b[r]=s;v[s]=true;\n    while(l<r)\n    {\n        l++;i=b[l];\n        v[i]=false;\n        for(j=1;j<=n;j++)\n        if(mp[i][j]>0&&d[j]>d[i]+cost[i][j])\n        {\n            if(!v[j])\n            {\n                b[++r]=j;\n                v[j]=true;\n            }\n            d[j]=d[i]+cost[i][j];\n            path[j]=i;\n        }\n    }\n    if(d[t]==ma)return false;\n    return true;\n}\nint minflow()\n{\n    int mincost=0,maxflow=0,minf=0;\n    if(s==t)return 0;\n    while(spfa())\n    {\n        int now=t,neck=ma;\n        while(now!=s)\n        {\n            int pre=path[now];\n            if(neck>mp[pre][now])\n            neck=mp[pre][now];\n            now=pre;\n        }\n        maxflow+=neck;\n        now=t;\n        while(now!=s)\n        {\n            int pre=path[now];\n            mp[pre][now]-=neck;\n            mp[now][pre]+=neck;\n            cost[now][pre]=-cost[pre][now];\n            mincost+=cost[pre][now]*neck;\n            //minf+=neck;\n            now=pre;\n        }\n    }\n    printf(\"%d\\n\",maxflow);\n    return mincost;\n\n}\nint main()\n{\n    int i,j;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n        {\n            mp[i][j]=0;\n            cost[i][j]=ma;\n        }\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&x,&y);\n            mp[x][y]=1;\n            cost[x][y]=0;\n            mp[y][x]=1;\n            cost[y][x]=1;\n            nu++;\n            a[nu].x=x;a[nu].y=y;\n        }\n        scanf(\"%d %d\",&s,&t);\n        ans=minflow();\n        printf(\"%d\\n\",ans);\n        for(i=1;i<=m;i++)\n        {\n            if(mp[a[i].y][a[i].x]==0)\n            printf(\"%d\\n\",i);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n #include<cstring>\n #include<queue>\n #include<cmath>\n using namespace std;\n const int Ni = 300;\n const int MAX = 1<<26;\n struct Edge{\n     int u,v,c;\n     int next;\n }edge[4000];\n int n,m;\n int edn;//\\u8fb9\\u6570\n int p[Ni];//\\u7236\\u4eb2\n int d[Ni];\n int sp,tp;//\\u539f\\u70b9\\uff0c\\u6c47\\u70b9\n\n void addedge(int u,int v,int c)\n {\n     edge[edn].u=u; edge[edn].v=v; edge[edn].c=c;\n     edge[edn].next=p[u]; p[u]=edn++;\n\n     edge[edn].u=v; edge[edn].v=u; edge[edn].c=0;\n     edge[edn].next=p[v]; p[v]=edn++;\n }\n int bfs()\n {\n     queue <int> q;\n     memset(d,-1,sizeof(d));\n     d[sp]=0;\n     q.push(sp);\n     while(!q.empty())\n     {\n         int cur=q.front();\n         q.pop();\n         for(int i=p[cur];i!=-1;i=edge[i].next)\n         {\n             int u=edge[i].v;\n             if(d[u]==-1 && edge[i].c>0)\n             {\n                 d[u]=d[cur]+1;\n                 q.push(u);\n             }\n         }\n     }\n     return d[tp] != -1;\n }\n int dfs(int a,int b)\n {\n     int r=0;\n     if(a==tp)return b;\n     for(int i=p[a];i!=-1 && r<b;i=edge[i].next)\n     {\n         int u=edge[i].v;\n         if(edge[i].c>0 && d[u]==d[a]+1)\n         {\n             int x=min(edge[i].c,b-r);\n             x=dfs(u,x);\n             r+=x;\n             edge[i].c-=x;\n             edge[i^1].c+=x;\n         }\n     }\n     if(!r)d[a]=-2;\n     return r;\n }\n\n int dinic(int sp,int tp)\n {\n     int total=0,t;\n     while(bfs())\n     {\n         while(t=dfs(sp,MAX))\n         total+=t;\n     }\n     return total;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tedn=0;\n\tmemset(p,-1,sizeof(p));\n\tfor (int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\taddedge(a-1,b-1,1);\n\t\taddedge(b-1,a-1,1);\n\t}\n\tscanf(\"%d%d\",&sp,&tp);\n\tsp--;\n\ttp--;\n\tint ans=dinic(sp,tp),tot=0;\n\tfor (int i=0;i<m;i++) if (edge[i*4+2].c==0) tot++;\n\tprintf(\"%d\\n%d\\n\",ans,tot);\n\tfor (int i=0;i<m;i++) if (edge[i*4+2].c==0) printf(\"%d\\n\",i+1);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n#include <climits>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n \n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n \ntypedef pair<int,int> pii;\nmap<pii, int> se;\nvector<pii> ans;\n \n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight edmonds_karp(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow(n, Array(n)), capacity(n, Array(n));\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n   \n  Weight total = 0;\n  while(1) {\n    queue<int> Q; Q.push(s);\n    vector<int> prev(n, -1); prev[s] = s;\n    while(!Q.empty() && prev[t] < 0) {\n      int u = Q.front(); Q.pop();\n      REP(v, n) if (prev[v] < 0 && RESIDUE(u, v) > 0) {\n        prev[v] = u;\n        Q.push(v);\n      }\n    }\n    if (prev[t] < 0) break;\n    Weight inc = INF;\n    for (int j=t; prev[j]!=j; j=prev[j])\n      inc = min(inc, RESIDUE(prev[j], j));\n    for (int j=t; prev[j]!=j; j=prev[j])\n      flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc; \n    total += inc;\n  }\n  REP(i,n) {\n    REP(j,n) {\n      if (flow[i][j] > 0) {\n        if (se.count(pii(i,j)) == 0) {\n          ans.push_back(pii(i,j));\n        }\n      }\n    }\n  }\n  return total;\n}\n \nint main() {\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  int s,t;\n  REP(i,m) {\n    int x,y;\n    cin >> x >>y;\n    x--;y--;\n    g[x].push_back(Edge(x,y,1));\n    g[y].push_back(Edge(y,x,1));\n    se[pii(x,y)] = i+1;\n  }\n  cin >> s >> t;\n  s--;t--;\n  cout << edmonds_karp(g, s, t) << endl;\n  cout << ans.size() << endl;\n  vector<int> v;\n  FOR(it, ans) {\n    v.push_back(se[pii(it->second, it->first)]);\n  }\n  sort(ALL(v));\n  FOR(it,v)\n    cout << *it << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstruct edge{\n\tint s,f,c,r;\n} e[1000];\nint n,m,top,sp,fp,vis[1000];\nvector <int> g[300];\nint DFS(int v){\n\tif (v==fp) return 1;\n\tint sz=g[v].size();\n\tvis[v]=1;\n\tfor (int i=0;i<sz;i++){\n\t\tedge ed=e[g[v][i]];\n\t\tif (ed.s==v){\n\t\t\tint u=ed.f;\n                \tif (vis[u]||ed.c==0) continue;\n\t\t\tif (DFS(u)){\n\t\t\t\te[g[v][i]].c=0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint u=ed.s;\n                \tif (vis[u]||ed.c==1) continue;\t\t\t\n\t\t\tif (DFS(u)){\n\t\t\t\te[g[v][i]].c=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tvis[v]=0;\n\treturn 0;\n}\nint solve(){\n\tint ans=0;\n\tmemset(vis,0,sizeof(vis));\n\twhile (DFS(sp)){\n\t\tans++;\n\t\tmemset(vis,0,sizeof(vis));\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[top].s=a-1;\n\t\te[top].f=b-1;\n\t\te[top].c=1;\n\t\tg[a-1].push_back(top);\n\t\tg[b-1].push_back(top++);\n\t\te[top].s=b-1;\n\t\te[top].f=a-1;\n\t\te[top].c=1;\n\t\tg[a-1].push_back(top);\n\t\tg[b-1].push_back(top++);\n\t}\n\tscanf(\"%d%d\",&sp,&fp);\n\tsp--;\n\tfp--;\n\tint ans=solve(),tot=0;\n\tfor (int i=0;i<m;i++) if (e[i*2+1].c==0) tot++;\n\tprintf(\"%d\\n%d\\n\",ans,tot);\n\tfor (int i=0;i<m;i++) if (e[i*2+1].c==0) printf(\"%d\\n\",i+1);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct edge{\n  int to, cap, rev;\n  edge(int to=0, int cap=0, int rev=0):to(to),cap(cap),rev(rev){}\n};\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nconst int MAX = 300;\nconst int INF = 1 << 29;\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back(edge(to, cap, G[to].size()));\n  G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  while(1){\n    fill(used,used+MAX,false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int n,m,s,t;\n  while(cin >> n >> m){\n    vector<P2> v;\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin >> a >> b;\n      add_edge(a,b,1);\n      add_edge(b,a,1);\n      v.push_back(P2(i+1, P(b,G[b].size()-1)));\n    }\n    cin >> s >> t;\n\n    cout << max_flow(s,t) << endl;\n    for(int i=0;i<v.size();i++){\n      if(G[v[i].second.first][v[i].second.second].cap == 1){\n        v.erase(v.begin()+i);\n        i--;\n      }\n    }\n    cout << v.size() << endl;\n    for(int i=0;i<v.size();i++) cout << v[i].first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* **********************************************\n\n    File Name: main.cpp\n\n    Auther: zhengdongjian@tju.edu.cn\n\n    Created Time: 2015/8/26 ????????? ?????? 2:12:40\n\n*********************************************** */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 0xfffffff;\nconst int MAX = 307;\nconst int MAX_M = MAX * MAX << 1;\n\nstruct Edge {\n\tint to;\n\tint cap;\n\tint id;\n\tint nxt;\n\tint bakup;\n\tvoid set(int _to, int _cap, int _id, int _nxt) {\n\t\tto = _to;\n\t\tcap = _cap;\n\t\tid = _id;\n\t\tnxt = _nxt;\n\t}\n} G[MAX_M];\nint Q[MAX << 1];\nint head[MAX], tot;\nint level[MAX];\nint iter[MAX];\nint n, m, s, t;\n\ninline void add_edge(int u, int v, int c, int id) {\n\tG[tot].set(v, c, id, head[u]);\n\tG[tot].bakup = c;\n\thead[u] = tot++;\n\tG[tot].set(u, c, -id, head[v]);\n\tG[tot].bakup = 0;\n\thead[v] = tot++;\n}\n\nbool bfs() {\n\tint le = 0, ri = 0;\n\tQ[ri++] = s;\n\tmemset(level, -1, sizeof(level));\n\tlevel[s] = 0;\n\twhile (le < ri) {\n\t\tint p = Q[le++];\n\t\tif (p == t) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfor (int i = head[p]; ~i; i = G[i].nxt) {\n\t\t\t//puts(\"flag1\");\n\t\t\tEdge& e = G[i];\n\t\t\tif (level[e.to] == -1 && e.cap > 0) {\n\t\t\t\tlevel[e.to] = level[p] + 1;\n\t\t\t\tQ[ri++] = G[i].to;\n\t\t\t\t//printf(\"push %d, level = %d\\n\", G[i].to, level[e.to]);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint dfs(int s, int t, int flow) {\n\tif (s == t) return flow;\n\tint sum = 0, tp;\n\tfor (int& i = iter[s]; ~i; i = G[i].nxt) {\n\t\tEdge& e = G[i];\n\t\tif (e.cap > 0 && level[e.to] == level[s] + 1) {\n\t\t\ttp = dfs(e.to, t, min(flow, e.cap));\n\t\t\tflow -= tp;\n\t\t\te.cap -= tp;\n\t\t\tG[i ^ 1].cap += tp;\n\t\t\tsum += tp;\n\t\t\tif (flow == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dinic() {\n\tint sum = 0;\n\twhile (bfs()) {\n\t\tmemcpy(iter, head, sizeof(int) * (n + 1));\n\t\tint tp;\n\t\twhile ((tp = dfs(s, t, INF)) > 0) {\n\t\t\tsum += tp;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\twhile (cin >> n >> m) {\n\t\tmemset(head, -1, sizeof(int) * (n + 1));\n\t\ttot = 0;\n\t\tint u, v;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tcin >> u >> v;\n\t\t\tadd_edge(u, v, 1, i + 1);\n\t\t}\n\t\t/*\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tprintf(\"%d:\", i);\n\t\t\tfor (int j = head[i]; ~j; j = G[j].nxt) {\n\t\t\t\tprintf(\" %d\", G[j].to);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tcin >> s >> t;\n\t\tint maxflow = dinic();\n\t\tcout << maxflow << endl;\n\t\tset<int> st;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = head[i]; ~j; j = G[j].nxt) {\n\t\t\t\tEdge& e = G[j];\n\t\t\t\tif (e.bakup > 0) {\n\t\t\t\t\tif (e.cap > e.bakup) {\n\t\t\t\t\t\tst.insert(e.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << st.size() << endl;\n\t\tfor (set<int>::iterator it = st.begin(); it != st.end(); ++it) {\n\t\t\tcout << *it << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 200000;\nstruct edge{\n    int from,to,num;\n    int cap,flow;\n    edge(int u= 0,int v=0,int c=0,int f=0):from(u),to(v),cap(c),flow(f){}\n};\n\nstruct ISAP{\n    int head[MAX];\n    int next[MAX];\n    int tot;\n    edge edges[2 * MAX];\n    int que[MAX],front,tail;\n    int d[MAX];\n    bool vis[MAX];\n    int num[MAX];\n    int pre[MAX];\n    int cur[MAX];\n    int s,t,n;\n    edge cut[2 * MAX];\n    int cut_cnt;\n    void init(int n){\n        this->n = n;\n        memset(head,-1,sizeof(head));\n        tot = cut_cnt =  0;//\n    }\n    void addedge(int from,int to, int cap){\n        edges[tot] = edge{from,to,cap,0};//豕ィ諢乗裏蜷題セケ蜥梧怏蜷題セケ\n        next[tot] = head[from], head[from] = tot++;\n        edges[tot] = edge{to,from,cap,0};\n        next[tot] = head[to],head[to] = tot++;\n    }\n    void bfs(){\n        memset(vis,0,sizeof(vis));\n        front = tail = 0;\n        d[t] = 0;\n        vis[t] = true;\n        que[tail++] = t;\n        while(front < tail){\n            int u = que[front++];\n            for(int v = head[u]; v != -1; v = next[v]){\n                edge & e = edges[v^1];\n                if(e.cap > e.flow && !vis[e.from]){\n                    d[e.from] = d[u] + 1;\n                    vis[e.from] = true;\n                    que[tail++] = e.from;\n                }\n            }\n        }\n    }\n    int Augment(){\n        int x = t,a = INF;\n        while(x != s){\n            edge& e = edges[pre[x]];\n            a = min(a,e.cap - e.flow);\n            x = e.from;\n        }\n\n        x = t;\n        while(x != s){\n            edges[pre[x]].flow += a;\n            edges[pre[x]^1].flow -= a;\n            x = edges[pre[x]].from;\n        }\n        return a;\n    }\n    int maxflow(int s, int t){\n        this->s = s, this->t = t;\n        memset(num,0,sizeof(num));\n        int flow = 0;\n        bfs();\n        for(int i = 1; i <= n; ++i){\n            num[d[i]]++,cur[i] = head[i];\n        }\n        int x = s;\n        while(d[s] < n){\n            if(x == t){\n                flow += Augment();\n                x = s;\n            }\n            bool ok = false;\n            for(int &v = cur[x]; v != -1; v = next[v]){\n                edge& e = edges[v];\n                if(e.cap > e.flow && d[x] == d[e.to] + 1){\n                    ok = true;\n                    pre[x = e.to] = v;\n                    break;\n                }\n            }\n            if(!ok){\n                int m = n - 1;\n                for(int v = head[x]; v != -1; v = next[v]){\n                    edge & e = edges[v];\n                    if(e.cap > e.flow) m = min(m,d[e.to]);\n                }\n                if(--num[d[x]] == 0) break;\n                num[d[x]=m+1]++;\n                cur[x] = head[x];\n                if(x != s) x = edges[pre[x]].from;\n            }\n        }\n        return flow;\n    }\n    void mincut(){\n        bfs();\n        for(int i = 0 ;i < tot; ++i){\n            edge & e = edges[i];\n            if(!vis[e.from] && vis[e.to] && e.cap > 0)\n                cut[cut_cnt++] = e;\n        }\n    }\n    void print(){\n        printf(\"Graph:\\n\");\n        for(int i = 0 ; i < tot; ++i){\n            edge & e = edges[i];\n            printf(\"%d->%d c:%d f:%d\\n\",e.from,e.to,e.cap,e.flow);\n        }\n    }\n    void solve(int s, int t){\n        printf(\"%d\\n\",maxflow(s,t));\n        vector<int> ans;\n        for(int i = 0; i < tot; i += 2){\n            edge & e = edges[i];\n            if(e.flow < 0 )\n                ans.push_back(i / 2 + 1);\n        }\n        printf(\"%d\\n\",ans.size());\n        for(int i = 0, sz = ans.size(); i < sz; ++ i)\n            printf(\"%d\\n\",ans[i]);\n    }\n}solve;\n\n\nint main(void)\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int N,M;\n    int u,v;\n    int s,t;\n    scanf(\"%d %d\", &N,&M);\n    solve.init(N);\n    for(int i = 0; i < M; ++i){\n        scanf(\"%d %d\", &u,&v);\n        solve.addedge(u,v,1);\n    }\n    scanf(\"%d %d\", &s,&t);\n    solve.solve(s,t);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n//Ford-Fulkerson O(FE)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tvector<vector<pair<pair<int,int>,T> > >G;\n\tvector<int>used;\n\tMF(int n_=0):G(n_),used(n_,0){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back(make_pair(\n\t\t\tmake_pair(to,G[to].size()),cap\n\t\t));\n\t\tG[to].push_back(make_pair(\n\t\t\tmake_pair(from,G[from].size()-1),0\n\t\t));\n\t}\n\tT dfs(int u,int t,T f,int dfstime)\n\t{\n\t\tif(u==t)return f;\n\t\tused[u]=dfstime;\n\t\tfor(pair<pair<int,int>,T>&e:G[u])\n\t\t{\n\t\t\tif(used[e.first.first]<dfstime&&e.second>0)\n\t\t\t{\n\t\t\t\tT d=dfs(e.first.first,t,min(f,e.second),dfstime);\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.second-=d;\n\t\t\t\t\tG[e.first.first][e.first.second].second+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(int dfstime=1;;dfstime++)\n\t\t{\n\t\t\tT f=dfs(s,t,numeric_limits<T>::max(),dfstime);\n\t\t\tif(f>0)ret+=f;\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n};\nint N,M,S,T;\nint GID[1000];\nint B[1000];\nmain()\n{\n\tcin>>N>>M;\n\tMF<int>mf(N);\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\ta--,b--;\n\t\tmf.add_edge(a,b,1);\n\t\tmf.add_edge(b,a,1);\n\t\tGID[i]=mf.G[b].size()-1;\n\t\tB[i]=b;\n\t}\n\tcin>>S>>T;\n\tcout<<mf.max_flow(S-1,T-1)<<endl;\n\tvector<int>ret;\n\tfor(int i=0;i<M;i++)if(mf.G[B[i]][GID[i]].second==0)ret.push_back(i+1);\n\tcout<<ret.size()<<endl;\n\tfor(int u:ret)cout<<u<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nstruct edge{int to,cap,rev,id;};//ikisaki youryou gyakuhen\nclass MF{//max flow\n\tpublic:\n\tint n;\n\tvector<vector<edge> >G;//[MAX];\n\tvector<bool>used;//[MAX];\n\tMF(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int from, int to, int cap,int id){\n\t\tedge q={to,cap,int(G[to].size()),id};\n\t\tG[from].push_back(q);\n\t\tq={from,cap,int(G[from].size()-1),-id};\n\t\tG[to].push_back(q);\n\t}\n\tint dfs(int v,int t, int f) {\n\t\tif(v==t)return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(used[e.to]||e.cap<=0) continue;\n\t\t\tint d =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(int s,int t) {//from s to t,ford_fulkerson\n\t\tint flow=0,f;\n\t\twhile(1){\n\t\t\tused=vector<bool>(n,false);\n\t\t\tf=dfs(s,t,inf);\n\t\t\tif(f==0)return flow;\n\t\t\tflow+=f;\n\t\t}\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tMF mf(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tmf.add_edge(a,b,1,i+1);\n\t}\n\tint s,t;\n\tcin>>s>>t;\n\ts--;t--;\n\tint flow=mf.mf(s,t);\n\tvi out;\n\trep(i,n)rep(j,mf.G[i].size()){\n\t\tedge e=mf.G[i][j];\n\t\tif(e.id<0&&e.cap==0)out.pb(-e.id);\n\t}\n\t\n\tcout<<flow<<endl;\n\tcout<<out.size()<<endl;\n\trep(i,out.size())cout<<out[i]<<endl;\n}\n\n/*\nint n;\nvvi in;\nmap<pii,int>ma;\nbool dfs(int a){\n\trep(i,n+1){\n\t\tif(i==n)return true;\n\t\tif(in[i][3]==0){\n\t\t\t\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vvi(n,vi(4));\n\t\tma.clear();\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tchar c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tin[i]={a,b,c=='y',0};\n\t\t\tma[{a,b}]=i+1;\n\t\t\tif(c=='x')a++;\n\t\t\telse b++;\n\t\t\tma[{a,b}]=i+1;\n\t\t}\n\t\tif(dfs(0))cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}\n*/\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef int Weight;\nstruct Edge {\n\tint s, d;\n\tWeight w;\n\tEdge(int s, int d, Weight w) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &o)const {\n\t\treturn w != o.w ? w > o.w : s != o.s ? s < o.s : d < o.d;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n#define EACH(i,t,c) for(t::const_iterator i=(c).begin();i!=(c).end();i++)\nWeight augment(const Graph &g, const Matrix &capacity, Matrix &flow, const vi &level, vector<bool> &finished, int u, int t, Weight cur) {\n\tif(u == t || cur == 0) {\n\t\treturn cur;\n\t}\n\tif(finished[u]) {\n\t\treturn 0;\n\t}\n\tfinished[u] = true;\n\tEACH(e, Edges, g[u]) {\n\t\tif(level[e->d] > level[u]) {\n\t\t\tWeight f = augment(g, capacity, flow, level, finished, e->d, t, min(cur, RESIDUE(u, e->d)));\n\t\t\tif(f > 0) {\n\t\t\t\tflow[u][e->d] += f;\n\t\t\t\tflow[e->d][u] -= f;\n\t\t\t\tfinished[u];\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nWeight maximumFlow(const Graph &g, int s, int t, Matrix &flow) {\n\tint n = g.size();\n\tMatrix capacity(n, Array(n));\n\tREP(u, n) {\n\t\tEACH(e, Edges, g[u]) {\n\t\t\tcapacity[e->s][e->d] += e->w;\n\t\t}\n\t}\n\tWeight total = 0;\n\tbool cont = true;\n\twhile(cont) {\n\t\tcont = false;\n\t\tvi level(n, -1);\n\t\tlevel[s] = 0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\tfor(int d = n; !Q.empty() && level[Q.front()] < d; ) {\n\t\t\tint u = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(u == t) {\n\t\t\t\td = level[u];\n\t\t\t}\n\t\t\tEACH(e, Edges, g[u]) {\n\t\t\t\tif(RESIDUE(u, e->d) > 0 && level[e->d] == -1) {\n\t\t\t\t\tQ.push(e->d);\n\t\t\t\t\tlevel[e->d] = level[u] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> finished(n);\n\t\tfor(Weight f = 1; f > 0; ) {\n\t\t\tf = augment(g, capacity, flow, level, finished, s, t, INF);\n\t\t\tif(f == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal += f;\n\t\t\tcont = true;\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvi X(M), Y(M);\n\tGraph o(N, Edges()), c(N, Edges());\n\tREP(i, M) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--;\n\t\tY[i]--;\n\t\to[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[Y[i]].push_back(Edge(Y[i], X[i], 1));\n\t}\n\n\tint S, T;\n\tcin >> S >> T;\n\tS--;\n\tT--;\n\tMatrix flow(N, Array(N, 0));\n\tWeight maxFlow = maximumFlow(c, S, T, flow);\n\tcout << maxFlow << endl;\n\tvi reversedRoads;\n\tREP(i, M) {\n\t\tif(flow[Y[i]][X[i]] > 0) {\n\t\t\treversedRoads.push_back(i+1);\n\t\t}\n\t}\n\tint size = reversedRoads.size();\n\tcout << size << endl;\n\tREP(i, size) {\n\t\tcout << reversedRoads[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\nvector<bool> used;\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tused[s] = true;\n\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(e.cap, f));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tint N = G.size();\n\t\tused = vector<bool>(G.size(), false);\n\t\tint flow = dfs(s, t, 1e9);\n\t\tif (flow > 0) {\n\t\t\tres += flow;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\nvoid add_edge(int u, int v, int cap) {\n\tG[u].push_back((Edge){v, cap, (int)G[v].size()});\n\tG[v].push_back((Edge){u, cap, (int)G[u].size()-1});\n}\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tG.resize(N);\n\tvector<P> edges;\n\tmap<P, int> tbl;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; --a, --b;\n\t\tedges.push_back( P(a, b) );\n\t\ttbl[edges[i]] = i;\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u = edges[i].first, v = edges[i].second;\n\t\tadd_edge(u, v, 1);\n\t}\n\tint S, T; cin >> S >> T; --S, --T;\n\tcout << max_flow(S, T) << endl;\n\n\tvector<int> ans;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\tEdge& e = G[i][j];\n\t\t\tif (e.cap == 0) {\n\t\t\t\tif (tbl.find(P(e.to, i)) != tbl.end()) {\n\t\t\t\t\tans.push_back(tbl[P(e.to, i)]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\tcout << ans.size() << endl;\n\tfor (int i = 0; i < ans.size(); ++i) {\n\t\tcout << ans[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\nconst int maxn=305;\nconst int inf=0x7fffffff;\nint r[maxn][maxn]; \nbool visit[maxn];\nint pre[maxn];\nint m,n;\nint x,prin[100000];\nbool bfs(int s,int t)  \n{\n    int p;\n    queue<int > q;\n    memset(pre,-1,sizeof(pre));\n    memset(visit,false,sizeof(visit));\n\n    pre[s]=s;\n    visit[s]=true;\n    q.push(s);\n    while(!q.empty())\n    {\n        p=q.front();\n        q.pop();\n        for(int i=1;i<=n;i++)\n        {\n            if((r[p][i]>0||r[i][p]>0)&&!visit[i])\n            {\n                r[p][i]=1;\n                pre[i]=p;\n                visit[i]=true;\n                if(i==t) return true;\n                q.push(i);\n            }\n        }\n    }\n    return false;\n}\nint num[305][305]={0};\nint EdmondsKarp(int s,int t)\n{\n   int flow=0,d,i;\n   while(bfs(s,t))\n   {\n       d=inf;\n       for(i=t;i!=s;i=pre[i])\n       d=d<r[pre[i]][i]? d:r[pre[i]][i];\n       for(i=t;i!=s;i=pre[i])\n       {\n           if(r[pre[i]][i]&&r[i][pre[i]])\n           prin[x++]=num[i][pre[i]]+1;\n           //cout<<num[i][pre[i]]<<endl;\n           r[pre[i]][i]=0;\n           r[i][pre[i]]=0;\n       }\n       flow+=d;\n   }\n   return flow;\n}\n\nint a,b;\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        int u,v;\n        memset(r,0,sizeof(r));\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            num[v][u]=i;\n            num[u][v]=i;\n            r[u][v]+=1;\n        }\n        scanf(\"%d%d\",&a,&b);\n        x=0;\n        printf(\"%d\\n\",EdmondsKarp(a,b));\n        cout<<x<<endl;\n        for(int i=0;i<x;i++)\n        printf(\"%d\\n\",prin[i]);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cap,rev,num,add;\n\tEdge(){}\n\tEdge(int s, int d, int cp, int r, int n, int a)\n\t\t:src(s),dst(d),cap(cp),rev(r),num(n), add(a)\n\t{}\n};\n\nconst int INF = (1<<28);\n\ntypedef vector<vector<Edge> > Graph;\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=e.cap;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tgraph[p][i].cap -= f;\n\t\t\tgraph[next][e.rev].cap += f;\n\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\t\t\t\tif(level[e.dst]!=-1) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.dst]=level[n]+1;\n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int d, int c, int n, int a, Graph& g)\n{\n\tg[s].push_back(Edge(s,d,c,g[d].size()  , n, a));\n\tg[d].push_back(Edge(d,s,0,g[s].size()-1, n, 0)); \n}\n\nint main()\n{\n\tint N,M,S,T;\n\tcin >> N >> M;\n\n\tGraph g(N);\n\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tadd_edge(s-1, t-1, 1, i, 0, g);\n\t\tadd_edge(t-1, s-1, 1, i, 1, g);\n\t}\n\n\tcin >> S >> T;\n\tcout << dinic(S-1,T-1,g) << endl;\n\n\tvector<int> res;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<g[i].size(); j++)\n\t{\n\t\tif(g[i][j].add == 1 && g[i][j].cap == 0)\n\t\t\tres.push_back(g[i][j].num);\n\t}\n\n\tcout << res.size() << endl;\n\tsort(res.begin(), res.end());\n\tfor(int i=0; i<res.size(); i++)\n\t\tcout << res[i] + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAX = 200000;\nstruct edge{\n    int from,to,num;\n    int cap,flow;\n    edge(int u= 0,int v=0,int c=0,int f=0):from(u),to(v),cap(c),flow(f){}\n};\n\nstruct ISAP{\n    int head[MAX];\n    int next[MAX];\n    int tot;\n    edge edges[2 * MAX];\n    int que[MAX],front,tail;\n    int d[MAX];\n    bool vis[MAX];\n    int num[MAX];\n    int pre[MAX];\n    int cur[MAX];\n    int s,t,n;\n    edge cut[2 * MAX];\n    int cut_cnt;\n    void init(int n){\n        this->n = n;\n        memset(head,-1,sizeof(head));\n        tot = cut_cnt =  0;//\n    }\n    void addedge(int from,int to, int cap){\n        edges[tot] = edge{from,to,cap,0};//注意无向?和有向?\n        next[tot] = head[from], head[from] = tot++;\n        edges[tot] = edge{to,from,cap,0};\n        next[tot] = head[to],head[to] = tot++;\n    }\n    void bfs(){\n        memset(vis,0,sizeof(vis));\n        front = tail = 0;\n        d[t] = 0;\n        vis[t] = true;\n        que[tail++] = t;\n        while(front < tail){\n            int u = que[front++];\n            for(int v = head[u]; v != -1; v = next[v]){\n                edge & e = edges[v^1];\n                if(e.cap > e.flow && !vis[e.from]){\n                    d[e.from] = d[u] + 1;\n                    vis[e.from] = true;\n                    que[tail++] = e.from;\n                }\n            }\n        }\n    }\n    int Augment(){\n        int x = t,a = INF;\n        while(x != s){\n            edge& e = edges[pre[x]];\n            a = min(a,e.cap - e.flow);\n            x = e.from;\n        }\n\n        x = t;\n        while(x != s){\n            edges[pre[x]].flow += a;\n            edges[pre[x]^1].flow -= a;\n            x = edges[pre[x]].from;\n        }\n        return a;\n    }\n    int maxflow(int s, int t){\n        this->s = s, this->t = t;\n        memset(num,0,sizeof(num));\n        int flow = 0;\n        bfs();\n        for(int i = 1; i <= n; ++i){\n            num[d[i]]++,cur[i] = head[i];\n        }\n        int x = s;\n        while(d[s] < n){\n            if(x == t){\n                flow += Augment();\n                x = s;\n            }\n            bool ok = false;\n            for(int &v = cur[x]; v != -1; v = next[v]){\n                edge& e = edges[v];\n                if(e.cap > e.flow && d[x] == d[e.to] + 1){\n                    ok = true;\n                    pre[x = e.to] = v;\n                    break;\n                }\n            }\n            if(!ok){\n                int m = n - 1;\n                for(int v = head[x]; v != -1; v = next[v]){\n                    edge & e = edges[v];\n                    if(e.cap > e.flow) m = min(m,d[e.to]);\n                }\n                if(--num[d[x]] == 0) break;\n                num[d[x]=m+1]++;\n                cur[x] = head[x];\n                if(x != s) x = edges[pre[x]].from;\n            }\n        }\n        return flow;\n    }\n    void mincut(){\n        bfs();\n        for(int i = 0 ;i < tot; ++i){\n            edge & e = edges[i];\n            if(!vis[e.from] && vis[e.to] && e.cap > 0)\n                cut[cut_cnt++] = e;\n        }\n    }\n    void print(){\n        printf(\"Graph:\\n\");\n        for(int i = 0 ; i < tot; ++i){\n            edge & e = edges[i];\n            printf(\"%d->%d c:%d f:%d\\n\",e.from,e.to,e.cap,e.flow);\n        }\n    }\n    void solve(int s, int t){\n        printf(\"%d\\n\",maxflow(s,t));\n        vector<int> ans;\n        for(int i = 0; i < tot; i += 2){\n            edge & e = edges[i];\n            if(e.flow < 0 )\n                ans.push_back(i / 2 + 1);\n        }\n        printf(\"%d\\n\",ans.size());\n        for(int i = 0, sz = ans.size(); i < sz; ++ i)\n            printf(\"%d\\n\",ans[i]);\n    }\n}solve;\n\n\nint main(void)\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int N,M;\n    int u,v;\n    int s,t;\n    scanf(\"%d %d\", &N,&M);\n    solve.init(N);\n    for(int i = 0; i < M; ++i){\n        scanf(\"%d %d\", &u,&v);\n        solve.addedge(u,v,1);\n    }\n    scanf(\"%d %d\", &s,&t);\n    solve.solve(s,t);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    level.clear(); level.resize(G.size(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge& e : G[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.clear(); iter.resize(G.size(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    each(e, dinic.G[v]) {\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  rep(i, used_rev.size()) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef double Double;\n\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst Double EPS = 1e-9;\n\ntypedef int flow_type;\n\nstruct DN_Edge {\n\tint to; flow_type cost; int rev; bool flag, rev_f;\n\tDN_Edge(int _to, flow_type _cost, int _rev,\n\t\t\tbool _flag, bool _rev_f) : to(_to), cost(_cost),\n\t\t\t\t\t\t\t\t\t rev(_rev), flag(_flag), rev_f(_rev_f) {}\n};\n\nstruct Dinic {\n\tint V;\n\tvector< vector< DN_Edge > > edges;\n\tvector< int > level, iter;\n\t\n\tDinic(int _n) : V(_n), edges(_n, vector< DN_Edge >()), level(_n, -1), iter(_n, 0) {}\n\t\n\tvoid add_edge(int _f, int _t, flow_type _c, bool flag) {\n\t\tedges[_f].push_back(DN_Edge(_t, _c, size_of(edges[_t]), flag, false));\n\t\tedges[_t].push_back(DN_Edge(_f, flow_type(), size_of(edges[_f]) - 1, flag, true));\n\t}\n\t\n\tvoid bfs(int _s) {\n\t\tfill(allof(level), -1);\n\t\tqueue<int> q; q.push(_s);\n\t\tlevel[_s] = 0;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tint e_size = size_of(edges[v]);\n\t\t\t\n\t\t\tfor_(i,0,e_size) {\n\t\t\t\tDN_Edge e = edges[v][i];\n\t\t\t\tif (e.cost > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tflow_type dfs(int _v, int _t, flow_type _f) {\n\t\tif (_v == _t) return _f;\n\t\tint e_size = size_of(edges[_v]);\n\t\t\n\t\tfor (int &i = iter[_v]; i < e_size; ++i) {\n\t\t\tDN_Edge &e = edges[_v][i];\n\t\t\t\n\t\t\tif (e.cost > 0 && level[_v] < level[e.to]) {\n\t\t\t\tflow_type d = dfs(e.to, _t, min(_f, e.cost));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cost -= d;\n\t\t\t\t\tedges[e.to][e.rev].cost += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tflow_type max_flow(int _s, int _t) {\n\t\tflow_type flow = flow_type();\n\t\twhile (1) {\n\t\t\tbfs(_s);\n\t\t\tif (level[_t] < 0) return flow;\n\t\t\tfill(allof(iter), 0);\n\t\t\tflow_type f;\n\t\t\twhile ((f = dfs(_s, _t, iINF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpair<int, set< int > > rev_cnt() {\n\t\tint resi = 0;\n\t\tset< int > resv;\n\t\t\n\t\tfor_(v,0,V) {\n\t\t\tint e_size = size_of(edges[v]);\n\t\t\t\n\t\t\tfor_(i,0,e_size) {\n\t\t\t\tDN_Edge e = edges[v][i];\n\t\t\t\t\n\t\t\t\tif (!e.rev_f && e.flag && e.cost == 0) {\n\t\t\t\t//cout << \"Edge(\" << v << \",\" << e.to << \",\" << e.cost << \",\" << e.rev << \",\" \n\t\t\t\t//\t<< ( (e.flag) ? \"rev\" : \"no_rev\") << \")\" << endl;\n\t\t\t\t\tresi++;\n\t\t\t\t\tresv.insert(e.to + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn make_pair(resi, resv);\n\t}\n};\n\nint N, M;\nint X[1010], Y[1010];\nint S, T;\n\nvoid solve() {\n\tDinic dinic(N);\n\tfor_(i,0,M) {\n\t\tdinic.add_edge(X[i] - 1, Y[i] - 1, 1, false);\n\t\tdinic.add_edge(Y[i] - 1, X[i] - 1, 1, true);\n\t}\n\t\n\tcout << dinic.max_flow(S - 1, T - 1) << endl;\n\tpair<int, set< int > > piv = dinic.rev_cnt();\n\t\n\tcout << piv.first << endl;\n\tset< int > ansv = piv.second;\n\tset< int >::iterator it = ansv.begin();\n\tfor(; it != ansv.end(); ++it) cout << *it << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor_(i,0,M) cin >> X[i] >> Y[i];\n\tcin >> S >> T;\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_V = 301;\n\nstruct edge\n{\n\tint to,cap,rev,kind;\n};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int ord)\n{\n\tG[from].push_back((edge){to,cap,G[to].size(),ord+1});\n\tG[to].push_back((edge){from,cap,G[from].size()-1,-ord-1});\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t){\n\t\treturn f;\n\t}\n\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        add_edge(a-1,b-1,1,i);\n    }\n    int s,t;\n    cin >> s >> t;\n    cout << max_flow(s-1,t-1) << \"\\n\";\n    vector<int> vec;\n    rep(i,n){\n        rep(j,G[i].size()){\n            if(G[i][j].cap == 0 && G[i][j].kind < 0){\n                vec.pb(-G[i][j].kind-1);\n            }\n        }\n    }\n    sort(all(vec));\n    cout << vec.size() << \"\\n\";\n    rep(i,vec.size()){\n        cout << vec[i]+1 << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 334\n#define INF 1e9\n\nstruct Edge{\n    int to,cap,rev;\n    Edge(int to,int cap,int rev) :\n        to(to),cap(cap),rev(rev) {}\n};\n\nvector<Edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back(Edge(to,cap,G[to].size()));\n    G[to].push_back(Edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> Q;\n    level[s] = 0;\n    Q.push(s);\n    while(!Q.empty()){\n        int v = Q.front(); Q.pop();\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v] + 1;\n                Q.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v,int t,int f){\n    if(v == t) return f;\n    for(int &i = iter[v] ; i < (int)G[v].size() ; i++){\n        Edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]){\n            int d = dfs(e.to,t,min(f,e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    for(;;){\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f = dfs(s,t,INF)) > 0){\n            flow += f;\n        }\n    }\n}\n\nint main(){\n    int N,M,S,T,a,b;\n    int edge[MAX_V][MAX_V];\n    memset(edge,-1,sizeof(edge));\n    cin >> N >> M;\n    for(int i = 0 ; i < M ; i++){\n        cin >> a >> b;\n        a--; b--;\n        add_edge(a,b,1);\n        add_edge(b,a,1);\n        edge[b][a] = i;\n    }\n    cin >> S >> T; S--; T--;\n    int res = max_flow(S,T);\n    cout << res << endl;\n    vector<int> v;\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < (int)G[i].size() ; j++){\n            int to = G[i][j].to;\n            if(edge[i][to] == -1) continue;\n            if(G[i][j].cap == 0){\n                v.push_back(edge[i][to]);\n            }\n            edge[i][to] = -1;\n        }\n    }\n    sort(v.begin(),v.end());\n    int size = v.size();\n    cout << size << endl;\n    for(int i = 0 ; i < size ; i++){\n        cout << v[i]+1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint const inf = 1<<29;\nstruct Dinic {\npublic:\n    typedef int Capacity;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<int> level, iter;\n\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        int revEdge;\n        bool isRev;\n        bool isRev2;\n        int id;\n        Edge(int dst_, Capacity cap_, int revEdge_, bool isRev_, bool isRev2_, int id_)\n            :dst(dst_), cap(cap_), cap_orig(cap_), revEdge(revEdge_), isRev(isRev_), isRev2(isRev2_), id(id_) {\n        }\n    };\n\n    Dinic(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)), level(n_), iter(n_) {}\n\n    void add_edge(int src, int dst, Capacity cap, bool isRev2, int id){\n        g[src].emplace_back(Edge(dst, cap, g[dst].size(), false, isRev2, id));\n        g[dst].emplace_back(Edge(src, 0, g[src].size() - 1, true, isRev2, id));\n    }\n\n    // src->dstへの最大フローを流す\n    Capacity solve(int src, int dst) {\n        int flow = 0;\n        while(1){\n            bfs(src);\n            if (level[dst] < 0) return flow;\n            fill(all(iter), 0);\n            int f;\n            while ((f = dfs(src, dst, inf)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\nprivate:\n    void bfs(int s) {\n        level.assign(n,-1);\n        queue<int> q; // 辺の数でみた最短距離\n        level[s] = 0;\n        q.push(s);\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            rep(i,g[v].size()){\n                Edge& e = g[v][i];\n                if (e.cap > 0 && level[e.dst] < 0) {\n                    level[e.dst] = level[v] + 1;\n                    q.push(e.dst);\n                }\n            }\n        }\n    }\n\n    Capacity dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.dst]) {\n                int d = dfs(e.dst, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.dst][e.revEdge].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    // 現在の容量を表示\n    // フローを流した分だけ破壊的に容量が減る実装になっている\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size()){\n                Edge & e=g[i][j];\n                if(!e.isRev) printf(\"%3d->%3d (flow:%d)\\n\", (int)i, e.dst, e.cap);\n            }\n        }\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view_flow(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", (int)i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n\n    void doit(){\n        vector<int> ans;\n        rep(i,g.size()){\n            rep(j,g[i].size()){\n                if(!g[i][j].isRev && g[i][j].isRev2 && g[i][j].cap==0){\n                    ans.pb(g[i][j].id);\n                }\n            }\n        }\n        cout << ans.size() << endl;\n        rep(i,ans.size()){\n            cout << ans[i] << endl;\n        }\n    }\n};\n\nint main(){\n    int n,m;\n    while(cin >> n >> m){\n        Dinic g(n);\n        rep(i,m){\n            int x,y; cin >> x >> y;\n            x--; y--;\n            g.add_edge(x,y,1,false,i+1);\n            g.add_edge(y,x,1,true,i+1);\n        }\n        int s,t;\n        cin >> s >> t;\n        s--; t--;\n        int f = g.solve(s,t);\n        cout << f << endl;\n        g.doit();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nint main()\n{\n    int N, M, S, T;\n    cin >> N >> M;\n    using P = pair<int, int>;\n    vector<P> edge;\n    vector<vector<int>> g(N, vector<int>(N, 0));\n    for (int i = 0, u, v; i < M; i++) { (cin >> u >> v), edge.push_back({u - 1, v - 1}), g[u - 1][v - 1] = g[v - 1][u - 1] = 1; }\n    cin >> S >> T;\n    S--, T--;\n    vector<bool> used(N, false);\n    auto dfs = fix([&](auto&& self, const int s, const int f) -> int {\n        if (s == T) { return f; }\n        used[s] = true;\n        for (int i = 0; i < N; i++) {\n            if (used[i] or g[s][i] == 0) { continue; }\n            const int d = self(self, i, min(f, g[s][i]));\n            if (d == 0) { continue; }\n            return g[s][i] -= d, g[i][s] += d, d;\n        }\n        return 0;\n    });\n    int flow = 0;\n    while (true) {\n        fill(used.begin(), used.end(), false);\n        const int f = dfs(S, 1 << 30);\n        if (f == 0) { break; }\n        flow += f;\n    }\n    cout << flow << endl;\n    vector<int> ans;\n    for (int i = 0; i < M; i++) {\n        const int u = edge[i].first, v = edge[i].second;\n        if (g[u][v] == 2) { ans.push_back(i); }\n    }\n    cout << ans.size() << endl;\n    for (const int a : ans) { cout << a + 1 << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst int MAX_N = 300;\nstruct edge {int to, cap, rev;};\nvector<edge> G[MAX_N+1];\nbool used[MAX_N+1];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f) {\n  if(v == t) return f;\n  used[v] = true;\n  REP(i, G[v].size()) {\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  while(true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint g[305][305];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, s, t;\n  cin >> n >> m;\n  REP(i, m) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    g[y][x] = i+1;\n    add_edge(x, y, 1);\n    add_edge(y, x, 1);\n  }\n  cin >> s >> t;\n  s--, t--;\n\n  cout << max_flow(s, t) << endl;\n  VI ans;\n  REP(i, n) {\n    for(edge e: G[i]) {\n      // i->e.toの辺について\n      if(e.cap == 0 && G[e.to][e.rev].cap == 1) {\n        if(g[i][e.to]) {\n          ans.PB(g[i][e.to]);\n        }\n      }\n    }\n  }\n  sort(ALL(ans));\n  ans.erase(unique(ALL(ans)), ans.end());\n  cout << ans.size() << endl;\n  for(int i: ans) cout << i << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 305\nusing namespace std;\ntypedef pair<int,int> P;\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,cap,G[from].size()-1});\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nmap<P,int> A;\n\nint main(){\n  int n,m,a,b,s,t;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    add_edge(a,b,1);\n    A[P(a,b)]=i;\n  }\n  cin>>s>>t;\n  s--,t--;\n  int ans=max_flow(s,t);\n  vector<int> ans2;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++){\n      int from=i,to=G[i][j].to;\n      if(A.count(P(from,to))&&G[i][j].cap==2)\n\tans2.push_back(A[P(from,to)]);\n    }\n  cout<<ans<<endl;\n  sort(ans2.begin(),ans2.end());\n  cout<<ans2.size()<<endl;\n  for(int i=0;i<ans2.size();i++)cout<<ans2[i]+1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \nstruct P\n{\n  int to,cap,rev;\n  P(int to=-1,int cap=-1,int rev=-1):to(to),cap(cap),rev(rev){}\n};\ntypedef vector<int> VI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\ntypedef pair<int,int> Pes;\nint N,M,s,t;\nVVP G;\nvector<int> level,iter;\nvector<Pes> vec;\nvector<int> pvec;\nbool sign;\n \nvoid add_edge(int from,int to,int i)\n{\n  if(sign)vec.push_back(Pes(from,G[from].size())),\n        pvec.push_back(i);\n  G[from].push_back(P(to,1,G[to].size()));\n  G[to].push_back(P(from,0,G[from].size()-1));\n}\n \nvoid bfs()\n{\n  deque<int> deq;\n  deq.push_back(s);\n  level[s] = 0;\n  while(!deq.empty())\n    {\n      int p = deq.front(); deq.pop_front();\n      rep(i,G[p].size())\n    {\n      P pes = G[p][i];\n      int v = pes.to;\n      if(level[v] == -1 && pes.cap > 0)\n        {\n          level[v] = level[p]+1;\n          deq.push_back(v);\n        }\n    }\n    }\n}\n \nint dfs(int v,int flow)\n{\n  if(v == t)return flow;\n \n  for(int &i = iter[v];i < G[v].size();i++)\n    {\n      P p = G[v][i];\n \n      if(p.cap <= 0)continue;\n      if(level[v] < level[p.to])\n    {\n      int d = dfs(p.to,min(flow,p.cap));\n      if(d <= 0)continue;\n      G[v][i].cap -= d;\n      G[p.to][p.rev].cap += d;\n      return d;\n         \n    }\n    }\n  return 0;\n}\n \nint maximum_flow()\n{\n  int res = 0;\n  iter.resize(N);\n  level.resize(N);\n  while(1)\n    {\n      rep(i,N)\n    iter[i] = 0,level[i] = -1;\n       bfs();\n       \n       if(level[t] < 0)return res;\n       int f;\n   \n       while((f = dfs(s,(1<<29))) > 0)\n     res += f;\n      \n    }\n  return res;\n}\n \nint main()\n{\n  cin >> N >> M;\n  G.resize(N);\n  rep(i,M)\n    {\n      int from,to;\n      cin >> from >> to;\n      from--,to--;\n      sign = false;\n      add_edge(from,to,i);\n      sign = true;\n      add_edge(to,from,i);\n    }\n  cin >> s >> t;\n  s--,t--;\n   \n  int mexico = maximum_flow();\n  int cnt = 0;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)cnt++;\n    }\n \n  cout << mexico << endl;\n  cout << cnt << endl;\n  rep(i,vec.size())\n    {\n      int p1 = vec[i].first,p2= vec[i].second;\n      if(G[p1][p2].cap != 1)\n    cout << pvec[i]+1 << \"   \" << endl;\n    }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst int NN=50*50*2+1;\n\nstruct edge\n{\n\tint s;\n\tint t;\n\tint st;\n\tint ts;\n\tint init;\n\tint nex(int a){\n\t\treturn a==s?t:s;\n\t}\n\tint res(int a){\n\t\treturn a==s?st:ts;\n\t}\n\tvoid use(int a, int v){\n\t\tif(a==s){\n\t\t\tst-=v;\n\t\t\tts+=v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tst+=v;\n\t\t\tts-=v;\n\t\t}\n\t}\n};\ntypedef vector<edge*>::iterator It;\ntemplate<int NN, int MM>\nstruct MaxFlow\n{\n\tedge es[MM];\n\tint esize;\n\tvector<edge*> edges[NN];\n\tvoid add(int a, int b, int v)\n\t{\n\t\tes[esize].s=a;\n\t\tes[esize].t=b;\n\t\tes[esize].st=v;\n\t\tes[esize].ts=v;\n\t\tes[esize].init=v;\n\t\tedges[a].push_back(es+esize);\n\t\tedges[b].push_back(es+esize);\n\t\tesize++;\n\t}\n\tedge* pre[NN];\n\tint done[NN];\n\tint q[NN];\n\tint s;\n\tint t;\n\tint flow()\n\t{\n\tint ret=0;\n\tint f=0;\n\twhile(1){\n\t\tf++;\n\t\tint qs=0;\n\t\tint qe=1;\n\t\tq[0]=s;\n\t\tdone[s]=f;\n\t\twhile(qs<qe){\n\t\t\tint top=q[qs++];\n\t\t\tfor(It it=edges[top].begin();it!=edges[top].end();it++){\n\t\t\t\tint nex=(*it)->nex(top);\n\t\t\t\tif((*it)->res(top)&&done[nex]!=f){\n\t\t\t\t\tq[qe++]=nex;\n\t\t\t\t\tpre[nex]=*it;\n\t\t\t\t\tdone[nex]=f;\n\t\t\t\t\tif(nex==t){\n\t\t\t\t\t\tgoto OK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\nOK:\n\t\tint p=t;\n\t\tint res=INT_MAX;\n\t\twhile(p!=s){\n\t\t\tint pp=pre[p]->nex(p);\n\t\t\tres=min(res,pre[p]->res(pp));\n\t\t\tp=pp;\n\t\t}\n\t\tp=t;\n\t\twhile(p!=s){\n\t\t\tint pp=pre[p]->nex(p);\n\t\t\tpre[p]->use(pp,res);\n\t\t\tp=pp;\n\t\t}\n\t\tret+=res;\n\t}\n\treturn ret;\n\t}\n};\n\nMaxFlow<301, 1000> mf;\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tfor(int i=0;i<M;i++){\n\t\tint X,Y;\n\t\tcin >> X >> Y;\n\t\tmf.add(X,Y,1);\n\t}\n\tcin >> mf.s >> mf.t;\n\tcout << mf.flow() << endl;\n\tint rev=0;\n\tfor(int i=0;i<mf.esize;i++){\n\t\tif(mf.es[i].st>mf.es[i].init){\n\t\t\trev++;\n\t\t}\n\t}\n\tcout << rev << endl;\n\tfor(int i=0;i<mf.esize;i++){\n\t\tif(mf.es[i].st>mf.es[i].init){\n\t\t\tcout << i+1<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[300][300],n,m,s,t;\nvector<pair<int,int> > b,c;\nvoid fi(int p){\n  int i;\n  if(p==t){\n    if(c.size()<b.size())\n      c=b;\n    return;\n  }\n  for(i=0;i<n;++i){\n    if(!a[p][i]&&!a[i][p])\n      continue;\n    int q=a[p][i],r=a[i][p];\n    a[p][i]=a[i][p]=0;\n    b.push_back(make_pair(p,i));\n    fi(i);\n    b.pop_back();\n    a[p][i]=q;\n    a[i][p]=r;\n  }\n  return;\n}\nint main(){\n  int i;\n  //int n,m;\n  cin>>n>>m;\n  //int a[300][300];\n  map<pair<int,int>,int> d;\n  for(i=0;i<m;++i){\n    int p,q;\n    cin>>p>>q;\n    --p;\n    --q;\n    a[p][q]=-1;\n    d[make_pair(p,q)]=i+1;\n  }\n  //int s,t;\n  cin>>s>>t;\n  --s;\n  --t;\n  b.reserve(n);\n  c.reserve(n);\n  fi(s);\n  cout<<c.size()<<endl;\n  int ct=0;  \n  for(i=0;i<(int)c.size();++i){\n    if(!a[c[i].first][c[i].second])\n      ++ct;\n  }\n  cout<<ct<<endl;\n  vector<int> e;\n  e.reserve(ct);\n  for(i=0;i<(int)c.size();++i){\n    if(!a[c[i].first][c[i].second])\n      e.push_back(d[make_pair(c[i].second,c[i].first)]);\n  }\n  sort(e.begin(),e.end());\n  for(i=0;i<(int)e.size();++i)\n    cout<<e[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  xioumu\n * Created Time:  2012/10/8 14:10:09\n * File Name: E.cpp\n * solve: E.cpp\n */\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define sz(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr(x) memset(x,0,sizeof(x))\n#define clrs( x , y ) memset(x,y,sizeof(x))\n#define out(x) printf(#x\" %d\\n\", x)\ntypedef long long lint;\nconst int maxint = -1u>>1;\nconst double esp = 1e-8;\n#define inf 10000000 \n#define maxn 400 \n#define maxm 2000000\nint e[maxn][maxn] ;\nint n , m , ans , S , T ;\nint dui[maxm] ;\nint d[maxn] ;\nbool bj[maxn] ;\nint x[2000],y[2000];\nvector<int> ret ;\nint dfs(int t,int v){//dfs謇セ霑樒サュ蠅槫ケソ霍ッ蠕?\tif (t==T || v==0) return v;\n\tint ans=0,flow;\n\tfor (int i=1;i<=n;i++){\n\t\tif (e[t][i]>0 && d[i]==d[t]+1){\n\t\t\tflow=dfs(i,min(v,e[t][i]));//騾貞ス貞セ怜芦荳矩擇逧?庄謾ケ霑幃?\n\t\t\te[t][i]-=flow;e[i][t]+=flow;//菫ョ謾ケ隸・霎ケ豬??\n\t\t\tv-=flow;ans+=flow;//菫ョ謾ケ髦亥? 譖エ譁ー豬??\n\t\t\tif (v==0) break;\n\t\t}\n\t}\n\treturn ans;\n}\nbool bfs(int s){\n\tint head,last,x;\n\tmemset(d,0,sizeof(d));\n\tmemset(bj,false,sizeof(bj));\n\td[s]=1;head=0;last=1;dui[last]=s;bj[s]=true;\n\twhile (head<last){\n\t\tx=dui[++head];\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (!bj[i] && e[x][i]>0){\n\t\t\t\tbj[i]=true;\n\t\t\t\td[i]=d[x]+1;\n\t\t\t\tdui[++last]=i;\n\t\t\t}\n\t\t}\n\t}\n\treturn bj[T];\n}\nvoid clrr(){\n    ans = 0 ; clr(e) ; ret.clear() ;\n}\nint main(){\n    while ( scanf(\"%d%d\" , &n , &m ) == 2 ) {\n        clrr() ;\n        //cout<<n<<m<<endl;\n        repf( i , 1 , m ) {\n            scanf(\"%d%d\" , &x[i] , &y[i] ) ;\n            if ( e[x[i]][y[i]] == 1 ) while ( 1 ) ;\n            e[x[i]][y[i]] = e[y[i]][x[i]] = 1 ;\n        }\n        repf( i, 1 , m )\n            repf( j , 1 , m ) {\n                if ( i == j ) continue ;\n                if ( x[i] == x[j] && y[i] == y[j] ) while( 1 ) ;\n                if ( x[i] == y[j] && x[j] == y[i] ) while( 1 ) ;\n            }\n        //repf( i , 1 , n ) {\n            //repf( j , 1 , n ) \n                //cout<<e[i][j]<<\" \";\n            //cout<<endl;\n        //}\n        scanf(\"%d%d\" , &S , &T ) ;\n        while ( bfs( S ) ) \n            ans += dfs( S , inf ) ;\n        //cout<<\"------------------------------------------------\"<<endl;\n        printf(\"%d\\n\" , ans ) ;\n        repf( i , 1 , m ) \n            if ( e[y[i]][x[i]] == 0 ) \n                ret.push_back(i) ;\n        printf(\"%d\\n\" , ret.size() ) ;\n        if ( ret.size() != 0 ) {\n            rep( i , ret.size() - 1 ) \n                printf(\"%d\\n\" , ret[i] ) ;\n            printf(\"%d\\n\" , ret[ret.size()-1]);\n        }\n        //cout<<\"-------------------------------------------------\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\nconst int maxn=330;\nconst int maxm=330*330*4;\nusing namespace std;struct edge\n{\n  int v,next,flow;\n}e[maxm];\nint st[maxn];\nint now[maxn],sumd[maxn],dis[maxn],fanhui[maxn],pre[maxn];\nint nn,n,m,maxflow;\nint start,end,zong;\n\nvoid addedge(int u,int v,int flow)\n{\n    e[nn].v=v;\n    e[nn].flow=flow;\n    e[nn].next=st[u];\n    st[u]=nn++;\n\n    e[nn].v=u;\n    e[nn].flow=0;\n    e[nn].next=st[v];\n    st[v]=nn++;\n}\nvoid init()\n{\n    memset(st,-1,sizeof(st));\n    memset(dis,0,sizeof(dis));\n    memset(sumd,0,sizeof(sumd));\n    nn=0;\n}\nint mflow()\n{\n    maxflow=0;\n    sumd[0]=zong;\n    int u=start,flow=99999999,t,dmin,mark;\n    bool flag;\n    while (dis[start]<zong)\n    {\n        fanhui[u]=flow;\n        flag=false;\n        for(t=now[u];t!=-1;t=e[t].next)\n        {\n            int v=e[t].v;\n            if (e[t].flow>0 && dis[u]==dis[v]+1)\n            {\n                flag=true;\n                now[u]=t;\n                flow=min(e[t].flow,flow);\n                pre[v]=t;\n                u=v;\n                if (u==end)         //update\n                {\n                    maxflow+=flow;\n                    while (u!=start)\n                    {\n                        e[pre[u]].flow-=flow;\n                        e[pre[u]^1].flow+=flow;\n                        u=e[pre[u]^1].v;\n                    }\n                    flow=99999999;\n                }\n                break;\n            }\n        }\n        if (flag)\n            continue;\n\n        dmin=zong-1;\n        for(t=st[u];t!=-1;t=e[t].next)\n            if (e[t].flow>0 && dis[e[t].v]<dmin)\n            {\n                mark=t;\n                dmin=dis[e[t].v];\n            }\n        now[u]=mark;\n\n        sumd[dis[u]]--;\n        if (!sumd[dis[u]])\n            break;\n        dis[u]=dmin+1;\n        sumd[dis[u]]++;\n\n        if (u!=start)\n        {\n            u=e[pre[u]^1].v;\n            flow=fanhui[u];\n        }\n    }\n    return maxflow;\n}\nvector<int> Eg;\nint main()\n{\n    int i;\n    while (cin>>n>>m)\n    {\n        init();\n        int tx,ty;\n        for (i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&tx,&ty);\n            addedge(tx,ty,1);\n            addedge(ty,tx,1);\n        }\n        for (i=1;i<=n;i++)\n            now[i]=st[i];\n        scanf(\"%d%d\",&start,&end);\n        zong=n;\n        printf(\"%d\\n\",mflow());\n        int Ans=0;\n        Eg.clear();\n        for (i=0;i<nn;i+=4)\n        {\n            if (e[i+3].flow==1)\n            {\n                Ans++;\n                Eg.push_back(i/4+1);\n            }\n        }\n        printf(\"%d\\n\",Ans);\n        for (i=0;i<Eg.size();i++)\n            printf(\"%d\\n\",Eg[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\n#define MAX_V 302\n#define INF 999999999\n\nclass Edge{\npublic:\n  int to,cap,rev;\n  Edge(){}\n  Edge(int _to,int _cap,int _rev){\n    to = _to;\n    cap = _cap;\n    rev = _rev;\n  }\n};\n\nint n,m;\nint id[302][302];\nvector<Edge> G[MAX_V];\nset<int> ans;\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back(Edge(to,cap,G[to].size()));\n  G[to].push_back(Edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f,bool *used){\n  if(v == t) return f;\n  used[v] = true;\n  rep(i,G[v].size()){\n    Edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap),used);\n      if(d > 0){\n        if(id[v][e.to] == -1){\n          ans.insert(id[e.to][v]);\n        }\n\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  while(1){\n    bool used[MAX_V];\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF,used);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(void){\n  while(cin>>n>>m){\n    memset(id,-1,sizeof(id));\n    rep(i,MAX_V) G[i].clear();\n    rep(i,m){\n      int a,b;\n      cin>>a>>b;\n      add_edge(a,b,1);\n      add_edge(b,a,1);\n      id[a][b] = i+1;\n    }\n    int s,t;\n    cin>>s>>t;\n    ans.clear();\n    cout<<max_flow(s,t)<<endl;\n    cout<<ans.size()<<endl;\n    foreach(i,ans){\n      cout<<(*i)<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string.h>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nvector< vector<edge> > G(100);\nint level[100];\nint iter[100];\nint INF = 100000000;\n\nvoid bfs(int s){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  int a, b;\n  map<pair<int,int>,int> mp;\n  for(int i = 0; i < M; ++i){\n    cin >> a >> b;\n    --a;--b;\n    mp[make_pair(a,b)] = i+1;\n    mp[make_pair(b,a)] = -i-1;\n    G[a].push_back((edge){b,1,G[b].size()});\n    G[b].push_back((edge){a,0,G[a].size()-1});\n    G[b].push_back((edge){a,1,G[a].size()});\n    G[a].push_back((edge){b,0,G[b].size()-1});\n  }\n  int s, t;\n  cin >> s >> t;\n  --s;--t;\n  cout <<  max_flow(s,t) << endl;\n  set<int> V;\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < G[i].size(); ++j){\n      edge e = G[i][j];\n      if(e.cap == 0 && mp[make_pair(i,e.to)] < 0){\n        V.insert(abs(mp[make_pair(i,e.to)]));\n      }\n    }\n  }\n  cout << V.size() << endl;\n  for(set<int>::iterator itr = V.begin(); itr != V.end(); ++itr) cout << *itr << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef double Double;\n\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst Double EPS = 1e-9;\n\ntypedef int flow_type;\n\nstruct DN_Edge {\n\tint to; flow_type cost; int rev; bool flag, rev_f; int id;\n\tDN_Edge(int _to, flow_type _cost, int _rev,\n\t\t\tbool _flag, bool _rev_f, int _id = -1) : to(_to), cost(_cost),\n\t\t\t\t\t\t\t\t\t rev(_rev), flag(_flag), rev_f(_rev_f), id(_id) {}\n};\n\nstruct Dinic {\n\tint V;\n\tvector< vector< DN_Edge > > edges;\n\tvector< int > level, iter;\n\t\n\tDinic(int _n) : V(_n), edges(_n, vector< DN_Edge >()), level(_n, -1), iter(_n, 0) {}\n\t\n\tvoid add_edge(int _f, int _t, flow_type _c, bool flag, int id) {\n\t\tedges[_f].push_back(DN_Edge(_t, _c, size_of(edges[_t]), flag, false, id));\n\t\tedges[_t].push_back(DN_Edge(_f, flow_type(), size_of(edges[_f]) - 1, flag, true));\n\t}\n\t\n\tvoid bfs(int _s) {\n\t\tfill(allof(level), -1);\n\t\tqueue<int> q; q.push(_s);\n\t\tlevel[_s] = 0;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tint e_size = size_of(edges[v]);\n\t\t\t\n\t\t\tfor_(i,0,e_size) {\n\t\t\t\tDN_Edge e = edges[v][i];\n\t\t\t\tif (e.cost > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tflow_type dfs(int _v, int _t, flow_type _f) {\n\t\tif (_v == _t) return _f;\n\t\tint e_size = size_of(edges[_v]);\n\t\t\n\t\tfor (int &i = iter[_v]; i < e_size; ++i) {\n\t\t\tDN_Edge &e = edges[_v][i];\n\t\t\t\n\t\t\tif (e.cost > 0 && level[_v] < level[e.to]) {\n\t\t\t\tflow_type d = dfs(e.to, _t, min(_f, e.cost));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cost -= d;\n\t\t\t\t\tedges[e.to][e.rev].cost += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tflow_type max_flow(int _s, int _t) {\n\t\tflow_type flow = flow_type();\n\t\twhile (1) {\n\t\t\tbfs(_s);\n\t\t\tif (level[_t] < 0) return flow;\n\t\t\tfill(allof(iter), 0);\n\t\t\tflow_type f;\n\t\t\twhile ((f = dfs(_s, _t, iINF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpair<int, vector< int > > rev_cnt() {\n\t\tint resi = 0;\n\t\tvector< int > resv;\n\t\t\n\t\tfor_(v,0,V) {\n\t\t\tint e_size = size_of(edges[v]);\n\t\t\t\n\t\t\tfor_(i,0,e_size) {\n\t\t\t\tDN_Edge e = edges[v][i];\n\t\t\t\t\n\t\t\t\tif (!e.rev_f && e.flag && e.cost == 0) {\n\t\t\t\t//cout << \"Edge(\" << v << \",\" << e.to << \",\" << e.cost << \",\" << e.rev << \",\" \n\t\t\t\t//\t<< ( (e.flag) ? \"rev\" : \"no_rev\") << \")\" << endl;\n\t\t\t\t\tresi++;\n\t\t\t\t\tresv.push_back(e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn make_pair(resi, resv);\n\t}\n};\n\nint N, M;\nint X[1010], Y[1010];\nint S, T;\n\nvoid solve() {\n\tDinic dinic(N);\n\tfor_(i,0,M) {\n\t\tdinic.add_edge(X[i] - 1, Y[i] - 1, 1, false, -1);\n\t\tdinic.add_edge(Y[i] - 1, X[i] - 1, 1, true, i + 1);\n\t}\n\t\n\tcout << dinic.max_flow(S - 1, T - 1) << endl;\n\tpair<int, vector< int > > piv = dinic.rev_cnt();\n\t\n\tcout << piv.first << endl;\n\tvector< int > ansv = piv.second;\n\tfor_(i,0,size_of(ansv)) cout << ansv[i] << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor_(i,0,M) cin >> X[i] >> Y[i];\n\tcin >> S >> T;\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <string>\n\nusing namespace std;\n\nconst int MM = 900010;\nconst int NN = 3010;\nconst int INF = 0x7fffffff;\n\nstruct data\n{\n\tint u, v;\n}mat[MM];\n\ntypedef struct node{\n    int v, w;\n    struct node *nxt, *op;\n\tint ju;\n}NODE;\n\nNODE edg[MM]; // 菫晏ュ俶園譛臥噪霎ケ\nNODE *Tlink[NN]; // 隶ー蠖戊鰍轤ケ謇?惠體セ陦ィ逧?ヲ冶鰍轤ケ\nint h[NN];    // 霍晉ヲサ譬?捷?瑚ョー蠖墓ッ丈クェ轤ケ蛻ー豎?せ逧?キ晉ヲサ?瑚ソ咎?逧?キ晉ヲサ謖?噪譏ッ螻よ焚\nint num[NN];  // gap莨伜喧?梧?蜿キ荳コi逧?。カ轤ケ荳ェ謨ー\n\nint M, N, idx, S, T, n; // S 陦ィ遉コ貅千せ?卦陦ィ遉コ豎?せ?系陦ィ遉コ闃らせ荳ェ謨ー, idx鄂ョ0\nvoid add(int u, int v, int c, int fl){\n    idx++;\n    edg[idx].v = v;\n    edg[idx].w = c;\n    edg[idx].nxt = Tlink[u];\n    edg[idx].op = edg + idx + 1;\n\tedg[idx].ju = -1;\n    Tlink[u] = edg + idx;    \n    idx++;\n    edg[idx].v = u;\n    edg[idx].w = 0;\n    edg[idx].nxt = Tlink[v];\n    edg[idx].op = edg + idx - 1;\n\tedg[idx].ju = fl;\n    Tlink[v] = edg + idx;\n}\n\nint Min(int a, int b){\n    return a < b ? a : b;\n}\n\nint aug(int u, int flow){\n    if (u == T) return flow;\n    int l = flow;  // l陦ィ遉コ蜑ゥ菴吝ョケ驥?    int mytmp = n - 1;\n    for (NODE *p = Tlink[u]; p; p = p->nxt){\n        if (h[u] == h[p->v] + 1 && p->w){\n            int f = aug(p->v, Min(l, p->w));\n            l -= f;\n            p->w -= f;\n            p->op->w += f;\n            if (l == 0 || h[S] == n) return flow - l; // gap\n        }\n        // 霑咎?譏ッ譛牙黄菴吝ョケ驥冗噪蜿ッ陦瑚セケ\n        if (p->w > 0 && h[p->v] < mytmp){\n            mytmp = h[p->v]; \n        }\n    }\n    if(l == flow){//  螯よ棡豐。譛画伽蛻ー蠅樊オ?シ梧燕菫ョ謾ケ譬?捷?悟?蠑?ァ句?髞吩コ?シ御ケ滓擶蜈キ逧?ソ?コ?・ス螟夐「?        num[h[u]]--;   // gap\n        if (num[h[u]] == 0) h[S] = n; // gap?梧ッ丈クェ轤ケ逧?キ晉ヲサ蛟シ譛?、壻クコn - 1?瑚ソ咎?隶セ荳コn 陦ィ遉コ譁ュ螻ゆコ?        else{\n            h[u] = mytmp + 1;\n            num[h[u]]++;   // gap\n        }\n    }\n    return flow - l;\n}\n/*n陦ィ遉コ諤サ轤ケ逧?クェ謨ー?悟桁諡ャ貅千せ蜥梧ア?せ*/\nint sap(){\n    int ans = 0;\n    memset(h, 0, sizeof(h)); // h 菫晏ュ倡噪譏ッ霍晉ヲサ譬?捷(蛻ー豎?せ逧?\n    memset(num, 0, sizeof(num));\n    num[0] = n;\n    while(h[S] < n){\n        ans += aug(S, INF);\n    }\n    return ans;\n}\n\nint res[1010];\nvector<int> ve;\n\nint main(void)\n{\n\twhile(scanf(\"%d %d\", &N, &M) != EOF)\n\t{\n\t\tmemset(Tlink, 0, sizeof(Tlink));\n\t\tidx = 0;\n\t\tfor(int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tadd(i + N, i + N + M, 1, 0);\n\t\t\tadd(a, i + N, 1, 0);\n\t\t\tadd(i + N + M, b, 1, 0);\n\t\t\tadd(b, i + N, 1, 0);\n\t\t\tadd(i + N + M, a, 1, 0);\n\t\t\tres[i] = idx;\n\t\t}\n\t\tscanf(\"%d %d\", &S, &T);\n\t\tn = N + M + M + 1;\n\t\tint ans = sap();\n\t\tprintf(\"%d\\n\", ans);\n\t\tve.clear();\n\t\tfor(int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tif(edg[res[i]].w)\n\t\t\t\tve.push_back(i);\n\t\t}\n\t\tprintf(\"%d\\n\", ve.size());\n\t\tif(ve.size() > 0)\n\t\t\tfor(int i = 0; i < ve.size(); ++i)\n\t\t\t\tprintf(\"%d\\n\", ve[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    const Weight INF=1e9+7;\n    int N;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Graph g;\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);    \n    Weight maxFlow(int s,int t);\n};\n\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\n\nWeight Flow::maxFlow(int s,int t){\n    Weight flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        Weight f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Flow flow(n);\n    map<pair<int,int>,int> edgemp;\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        edgemp[{a,b}]=i+1;\n        flow.addEdge(a,b,1);\n        flow.addEdge(b,a,1);\n    }\n    int s,t;\n    cin>>s>>t;\n    s--,t--;\n    int res=flow.maxFlow(s,t);\n    set<int> revs;\n    for(int i=0;i<n;i++){\n        for(auto &e:flow.g[i]){\n            if(e.cap==0){\n                int a=e.to;\n                int b=i;\n                if(edgemp.count({a,b})){\n                    revs.insert(edgemp[{a,b}]);\n                }\n            }\n        }\n    }\n    cout<<res<<endl;\n    cout<<revs.size()<<endl;\n    for(auto &e:revs) cout<<e<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\nint N,M;\nstruct edge{\n  int to,cap,rev;\n};\nvector<edge> G[333];\nint E[333][333];\n\nvoid add_edge(int to,int from,int cap){\n  G[from].push_back( (edge){to,cap,G[to].size()} );\n  G[to].push_back( (edge){from,0,G[from].size()-1} );\n\n  G[from].push_back( (edge){to,0,G[to].size()} );\n  G[to].push_back( (edge){from,cap ,G[from].size()-1} );\n}\n\nbool used[333];\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap) );\n      if( d > 0 ){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    if( f == 0 ) return flow;\n    flow+=f;\n  }\n}\n\nvector<int> ans;\n\nvoid redfs(int v,int t){\n  if( v == t ) return;\n  used[v] = true;\n  bool tof[333]={};\n  for(int i=0;i<(int)G[v].size();i++){\n    edge e = G[v][i];\n    if( e.cap > 0 ) tof[e.to] = true;\n  }\n  for(int i=0;i<(int)G[v].size();i++){\n    edge e = G[v][i];\n    if( used[e.to] ) continue;\n    if( !tof[e.to] ) {\n      // printf(\" %d -> %d == %d \\n\",e.to,v,E[e.to][v]); \n      if( E[v][e.to] > 0 ) ans.push_back( E[v][e.to] );\n      redfs(e.to,t);\n    }\n  }\n  return ;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int x,y;\n    cin >> x >> y;\n    E[y][x] = i+1;\n    add_edge(y,x,1);\n  }\n  int s,t;\n  cin >> s >> t;\n  int res = max_flow(s,t);\n  cout << res << endl;\n  memset(used,0,sizeof(used));\n  redfs(s,t);\n  sort(ans.begin(),ans.end());\n  ans.erase(unique(ans.begin(),ans.end()),ans.end());\n  cout << ans.size() << endl;\n  for(int i=0;i<(int)ans.size();i++) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    //level.clear(); level.resize(G.size(), -1);\n    fill(level.begin(), level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //iter.clear(); iter.resize(G.size(), 0);\n      fill(iter.begin(), iter.end(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    rep(i, dinic.G[v].size()) {\n      edge& e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  rep(i, used_rev.size()) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nstruct Edge{\n\tint src,dst,flow,capacity,next;\n\tEdge(){}\n\tEdge(int s,int d,int f,int c,int n):src(s),dst(d),flow(f),capacity(c),next(n){}\n};\n\nvoid AddEdge(vector<Edge>& es,vi& head,int src,int dst,int flow,int capacity){\n\tes.push_back(Edge(src,dst,flow,capacity,head[src]));\n\thead[src]=es.size()-1;\n}\n\nvi BFS(const vector<Edge>& es,const vi& head,int begin)\n{\n\tint size=head.size();\n\tvi label(size,size);\n\tqueue<pii> q;\n\tq.push(mp(begin,0));\n\twhile(q.size()){\n\t\tpii cur=q.front(); q.pop();\n\t\tif(label[cur.first]<=cur.second)\n\t\t\tcontinue;\n\t\tlabel[cur.first]=cur.second;\n\t\tfor(int i=head[cur.first];i!=-1;i=es[i].next)\n\t\t\tif(es[i].capacity-es[i].flow>0)\n\t\t\t\tq.push(mp(es[i].dst,cur.second+1));\n\t}\n\treturn label;\n}\n\nint DFS(vector<Edge>& es,vi& head,int v,int end,const vi& label,int f)\n{\n\tif(v==end)\n\t\treturn f;\n\tfor(int& i=head[v];i!=-1;i=es[i].next){\n\t\tEdge& e=es[i];\n\t\tif(label[e.src]>=label[e.dst])\n\t\t\tcontinue;\n\t\tint residue=e.capacity-e.flow;\n\t\tif(residue<=0)\n\t\t\tcontinue;\n\t\tint augment=DFS(es,head,e.dst,end,label,min(residue,f));\n\t\tif(augment>0){\n\t\t\te.flow+=augment;\n\t\t\tes[i^1].flow-=augment;\n\t\t\treturn augment;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Dinic(vector<Edge>& es,const vi& head,int begin,int end)\n{\n\tint size=head.size();\n\tfor(;;){\n\t\tvi label=BFS(es,head,begin);\n\t\tif(label[end]==size)\n\t\t\tbreak;\n\t\tvi temp=head;\n\t\twhile(DFS(es,temp,begin,end,label,INFTY))\n\t\t\t;\n\t}\n\tint res=0;\n\tfor(int i=head[begin];i!=-1;i=es[i].next)\n\t\tres+=es[i].flow;\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m);){\n\t\tvector<Edge> es; es.reserve(m*2);\n\t\tvi head(n,-1);\n\t\trep(i,m){\n\t\t\tint s,d; scanf(\"%d%d\",&s,&d); s--; d--;\n\t\t\tAddEdge(es,head,s,d,0,1);\n\t\t\tAddEdge(es,head,d,s,0,1);\n\t\t}\n\t\tint s,t; scanf(\"%d%d\",&s,&t); s--; t--;\n\t\t\n\t\tint f=Dinic(es,head,s,t);\n\t\tvi rs;\n\t\trep(i,m) if(es[i*2+1].flow==1)\n\t\t\trs.push_back(i);\n\t\t\n\t\tprintf(\"%d\\n%d\\n\",f,rs.size());\n\t\trep(i,rs.size())\n\t\t\tprintf(\"%d\\n\",rs[i]+1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nconst int V = 305;\nconst int E = 1005;\nconst int oo = 0x3f3f3f3f;\nstruct Edge\n{\n\tint num, ne, cap, id;\n} e[2 * E];\n\nint d[V], p[V], pre[V], pree[V], low[V];\nint gap[V], cur[V];\nint n, K, ed, st;\n\nvoid add(const int& u, const int& v, const int& cap, const int& id)\n{\n\te[K].num = v;\n\te[K].cap = cap;\n\te[K].ne = p[u];\n\te[K].id = id;\n\tp[u] = K++;\n\te[K].num = u;\n\te[K].cap = cap;\n\te[K].ne = p[v];\n\te[K].id = -id;\n\tp[v] = K++;\n}\n\nint sap()\n{\n\tint ret = 0;\n\tbool fail;\n\tmemset(low, 0, sizeof(low));\n\tmemset(gap, 0, sizeof(gap));\n\tmemset(d, 0, sizeof(d));\n\tfor (int i = 0; i < n; i++)\n\t\tcur[i] = p[i];\n\n\tlow[st] = oo;\n\tgap[0] = n;\n\tint u = st;\n\twhile (d[st] < n)\n\t{\n\t\tfail = true;\n\t\tfor (int i = cur[u]; ~i; i = e[i].ne)\n\t\t{\n\t\t\tint v = e[i].num;\n\t\t\tcur[u] = i;\n\t\t\tif (e[i].cap && d[u] == d[v] + 1)\n\t\t\t{\n\t\t\t\tpre[v] = u;\n\t\t\t\tpree[v] = i;\n\t\t\t\tlow[v] = min(low[u], e[i].cap);\n\t\t\t\tu = v;\n\t\t\t\tif (u == ed)\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\te[pree[u]].cap -= low[ed];\n\t\t\t\t\t\te[pree[u] ^ 1].cap += low[ed];\n\t\t\t\t\t\tu = pre[u];\n\t\t\t\t\t} while (u != st);\n\t\t\t\t\tret += low[ed];\n\t\t\t\t}\n\t\t\t\tfail = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fail)\n\t\t{\n\t\t\tgap[d[u]]--;\n\t\t\tif (!gap[d[u]]) return ret;\n\t\t\td[u] = n;\n\t\t\tfor (int i = p[u]; ~i; i = e[i].ne)\n\t\t\t{\n\t\t\t\tif (e[i].cap) d[u] = min(d[u], d[e[i].num] + 1);\n\t\t\t}\n\t\t\tgap[d[u]]++;\n\t\t\tcur[u] = p[u];\n\t\t\tif (u != st) u = pre[u];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint ax[10000], top;\n\nint main()\n{\n#ifdef __FISH__\n    if (fopen(\"in.txt\", \"r\") != NULL)\n        freopen(\"in.txt\", \"r\", stdin);\n#endif\n\tint m, u, v;\n\t\n\twhile (scanf(\"%d%d\", &n, &m) == 2) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i] = -1;\n\t\tK = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tadd(u - 1, v - 1, 1, i + 1);\n\t\t}\n\t\tscanf(\"%d%d\", &st, &ed);\n\t\tst--;\n\t\ted--;\n\t\tprintf(\"%d\\n\", sap());\n\t\ttop = 0;\n\t\tfor (int i = 0; i < K; i++)\n\t\t\tif (e[i].cap == 0 && e[i].id < 0) ax[top++] = -e[i].id;\n\t\tsort(ax, ax + top);\n\t\ttop = unique(ax, ax + top) - ax;\n\t\tprintf(\"%d\\n\", top);\n\t\tfor (int i = 0; i < top; i++)\n\t\t\tprintf(\"%d\\n\", ax[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  xioumu\n * Created Time:  2012/10/8 14:10:09\n * File Name: E.cpp\n * solve: E.cpp\n */\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define sz(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr(x) memset((x), 0, sizeof((x)))\n#define clrs( x , y ) memset((x), (y), sizeof((x)))\n#define out(x) printf(#x\" %d\\n\", x)\ntypedef long long lint;\nconst int maxint = -1u>>1;\nconst double esp = 1e-8;\n#define inf 10000000 \n#define maxn 400 \n#define maxm 2000000\nint e[maxn][maxn] ;\nint n , m , ans , S , T ;\nint dui[maxm] ;\nint d[maxn] ;\nbool bj[maxn] ;\nint x[maxm],y[maxm];\nvector<int> ret ;\nint dfs(int t,int v){\n\tif (t==T || v==0) return v;\n\tint ans=0,flow;\n\tfor (int i=1;i<=n;i++){\n\t\tif (e[t][i]>0 && d[i]==d[t]+1){\n\t\t\tflow=dfs(i,min(v,e[t][i]));\n\t\t\te[t][i]-=flow;e[i][t]+=flow;\n\t\t\tv-=flow;ans+=flow;\n\t\t\tif (v==0) break;\n\t\t}\n\t}\n\treturn ans;\n}\nbool bfs( int s ) {\n    int head , last , x ;\n    clr(d) ; clr(bj) ;\n    d[s] = 1 ; head = 0 ; last = 1 ; dui[last] = s ; bj[s] = true ;\n    while ( head < last ) {\n         x = dui[++head] ;\n         //if(x == T) return true; \n         for ( int i = 1 ; i <= n ; i ++ ) \n             if ( ! bj[i] && e[x][i] > 0 ) {\n                bj[i] = true ;\n                d[i] = d[x] + 1 ;\n                dui[++last] = i ;\n             }\n    }\n    return bj[T] ;\n}\n\nvoid clrr(){\n    ans = 0 ; clr(e) ; ret.clear() ;\n}\nint main(){\n    while ( scanf(\"%d%d\" , &n , &m ) != EOF ) {\n        clrr() ;\n        //cout<<n<<m<<endl;\n        repf( i , 1 , m ) {\n            scanf(\"%d%d\" , &x[i] , &y[i] ) ;\n            if ( e[x[i]][y[i]] == 1 ) while ( 1 ) ;\n            e[x[i]][y[i]] = e[y[i]][x[i]] = 1 ;\n            //if(x[i] == y[i] > n) while(1);\n        }\n        repf( i, 1 , m )\n            repf( j , 1 , m ) {\n                if ( i == j ) continue ;\n                if ( x[i] == x[j] && y[i] == y[j] ) while( 1 ) ;\n                if ( x[i] == y[j] && x[j] == y[i] ) while( 1 ) ;\n            }\n        //repf( i , 1 , n ) {\n            //repf( j , 1 , n ) \n                //cout<<e[i][j]<<\" \";\n            //cout<<endl;\n        //}\n        scanf(\"%d%d\" , &S , &T ) ;\n        while ( bfs( S ) ) \n            ans += dfs( S , inf ) ;\n        //cout<<\"------------------------------------------------\"<<endl;\n        printf(\"%d\\n\" , ans ) ;\n        repf( i , 1 , m ) \n            if ( e[y[i]][x[i]] == 0 ) \n                ret.push_back(i) ;\n        printf(\"%d\\n\" , ret.size() ) ;\n        if ( ret.size() != 0 ) {\n            rep( i , ret.size() - 1 ) \n                printf(\"%d\\n\" , ret[i] ) ;\n            printf(\"%d\\n\" , ret[ret.size()-1]);\n        }\n        //cout<<\"-------------------------------------------------\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight = long long;\n\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int cost;\n  Edge(int src, int dst, Weight weight, int cost = 0)\n      : src(src), dst(dst), weight(weight), cost(cost) {}\n};\n\nauto operator<(const Edge &e, const Edge &f) {\n  if (e.weight != f.weight)\n    return e.weight > f.weight;\n  else if (e.src != f.src)\n    return e.src < f.src;\n  else\n    return e.dst < f.dst;\n}\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nint main() {\n  int n, m, c;\n  while (cin >> n >> m >> c, n) {\n    vector<vector<int>> flag(n, vector<int>(m, 1e9));\n    Graph g(n);\n    for (int i = 0; i < m; ++i) {\n      int f, t, cc;\n      cin >> f >> t >> cc;\n      g[f - 1].emplace_back(f - 1, t - 1, cc);\n    }\n    deque<Edge> q;\n    for (q.emplace_back(-2, 0, 0, 0); !q.empty();) {\n      Edge e = q.front();\n      // cout << e.src << endl;\n      if (e.dst == n - 1) {\n        cout << e.cost << endl;\n        goto BREAK;\n      }\n      q.pop_front();\n      for (auto ge : g[e.dst]) {\n        if (flag[ge.dst][e.cost + 1] > e.weight)\n          q.emplace_back(ge.src, ge.dst, e.weight, e.cost + 1);\n        if (ge.weight + e.weight > c) continue;\n        if (flag[ge.dst][e.cost] > ge.weight + e.weight)\n          q.emplace_front(ge.src, ge.dst, ge.weight + e.weight, e.cost);\n      }\n    }\n    cout << \"impossible\" << endl;\n  BREAK:;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef int F;\nconst int MAXV = 301;\nconst int MAXE = MAXV * MAXV;\nconst F MAXF = 1<<29;\n\nstruct MaxFlow {\n    F cap[2*MAXE], flow[2*MAXE];\n    int V, E, level[MAXV], edge[MAXV];\n    int prev[2*MAXE], to[2*MAXE];\n    MaxFlow(int n) : E(0), V(n) { memset(edge, -1, sizeof(edge)); }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // bfs\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    F augment(int s, int t, F f) { // dfs\n        if (s == t || f == 0) return f;\n        F r = 0;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f - r, cap[e] - flow[e]));\n                if (g > 0) flow[e] += g, flow[e^1] -= g, r += g;\n                if (r == f) return r;\n            }\n        }\n        return r;\n    }\n    F max_flow(int s, int t) {\n        F f = 1, ret = 0;\n        for (; f > 0; ) {\n            make_level(s);\n            f = augment(s, t, MAXF);\n            ret += f;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int x[MAXE], y[MAXE];\n    int N,M,a,b;\n    cin>>N>>M;\n    MaxFlow mf(N);\n    for (int i=0; i<M; ++i) {\n        cin>>a>>b; a--, b--;\n        mf.add_edge(a, b, 1, 1);\n        x[i] = a, y[i] = b;\n    }\n    cin>>a>>b; a--, b--;\n    cout<<mf.max_flow(a, b)<<endl;\n    vector<int> rev;\n    for (int i=0; i<M; ++i) {\n        int e = mf.edge[y[i]];\n        while(e != -1) {\n            if (mf.to[e] == x[i] && mf.flow[e] > 0) rev.push_back(i);\n            e = mf.prev[e];\n        }\n    }\n    cout<<rev.size()<<endl;\n    for (int i=0; i<rev.size(); ++i) cout<<rev[i]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nmap<P, int> rev;\nvector<int> ans;\ntemplate< typename flow_t >\nstruct Dinic {\n  const flow_t INF;\n  struct edge {\n    int to;\n    flow_t cap;\n    int rev;\n    bool isrev;\n    int idx;\n  };\n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter;\n  Dinic(int V) : INF(numeric_limits< flow_t >::max()), graph(V) {}\n  void add_edge(int from, int to, flow_t cap, int idx = -1) {\n    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false, idx});\n    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true, idx});\n  }\n  bool bfs(int s, int t) {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty() && min_cost[t] == -1) {\n      int p = que.front();\n      que.pop();\n      for(auto &e : graph[p]) {\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return min_cost[t] != -1;\n  }\n  flow_t dfs(int idx, const int t, flow_t flow) {\n    if(idx == t) return flow;\n    for(int &i = iter[idx]; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        flow_t d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  flow_t max_flow(int s, int t) {\n    flow_t flow = 0;\n    while(bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      flow_t f = 0;\n      while((f = dfs(s, t, INF)) > 0) flow += f;\n    }\n    return flow;\n  }\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        if(rev_e.cap==1 && rev[{i, e.to}] > 0) {\n          ans.push_back(rev[{i, e.to}]);\n        }\n      }\n    }\n  }\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, m; cin >> n >> m;\n  Dinic<int> flow(n);\n  for(int i=0;i<m;++i) {\n    int a, b; cin >> a >> b;\n    a--; b--;\n    flow.add_edge(a, b, 1);\n    flow.add_edge(b, a, 1);\n    rev[{b, a}] = i+1;\n  }\n  int s, t; cin >> s >> t;\n  s--; t--;\n  int f = flow.max_flow(s, t);\n  flow.output();\n  cout << f << endl;\n  cout << (int)(ans.size()) << endl;\n  for(auto &e: ans) {\n    cout << e << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<ctime>\nusing namespace std;\nconst int MAX=1005;\nconst int inf=1<<20;\nstruct node\n{\n    int v,c,next,id;\n}g[MAX*100];\nint adj[MAX],cur[MAX],dis[MAX],pre[MAX],num[MAX],res[MAX],flag[MAX];\nint n,m,e,s,t,vn,f,cnt;\nvoid add(int u,int v,int c,int id)\n{\n    g[e].v=v; g[e].c=c; g[e].id=id; g[e].next=adj[u]; adj[u]=e++;\n    g[e].v=u; g[e].c=0; g[e].id=id; g[e].next=adj[v]; adj[v]=e++;\n}\nint sap()\n{\n    int i,u,v,flag,aug=inf,flow=0;\n    for(i=1;i<=vn;i++)\n    {\n        cur[i]=adj[i];\n        num[i]=dis[i]=0;\n    }\n    num[0]=vn;\n    pre[s]=u=s;\n    while(dis[s]<vn)\n    {\n        flag=0;\n        for(i=cur[u];i!=-1;i=g[i].next)\n        {\n            v=g[i].v;\n            if(g[i].c&&dis[u]==dis[v]+1)\n            {\n                flag=1;\n                aug=min(aug,g[i].c);\n                pre[v]=u;\n                cur[u]=i;\n                u=v;\n                if(u==t)\n                {\n                    flow+=aug;\n                    while(u!=s)\n                    {\n                        u=pre[u];\n                        g[cur[u]].c-=aug;\n                        g[cur[u]^1].c+=aug;\n                    }\n                    aug=inf;\n                }\n                break;\n            }\n        }\n        if(flag)\n            continue;\n        if(--num[dis[u]]==0)\n            break;\n        for(dis[u]=vn,i=adj[u];i!=-1;i=g[i].next)\n        {\n            v=g[i].v;\n            if(g[i].c&&dis[v]<dis[u])\n            {\n                dis[u]=dis[v];\n                cur[u]=i;\n            }\n        }\n        dis[u]++;\n        num[dis[u]]++;\n        u=pre[u];\n    }\n    return flow;\n}\nint main()\n{\n    int i,j,k;\n    while(scanf(\"%d%d\",&vn,&m)!=EOF)\n    {\n        memset(adj,-1,sizeof(adj));\n        e=0;\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&j,&k);\n            add(j,k,1,i+1); add(k,j,1,i+1);\n        }\n        scanf(\"%d%d\",&s,&t);\n        int max_flow=sap();\n        k=0;\n        memset(flag,false,sizeof(flag));\n        for(i=0;i<e;i+=4)\n        {\n            if(g[i+2].c+g[i+3].c==1)\n                flag[g[i].id]=true;\n        }\n        for(i=1;i<=m;i++)\n            if(flag[i])\n                res[k++]=i;\n        printf(\"%d\\n%d\\n\",max_flow,k);\n        for(i=0;i<k;i++)\n            printf(\"%d\\n\",res[i]);\n    }\n    return 0;\n}\n/*\n2 1\n2 1\n2 1\n\n2 1\n1 2\n2 1\n\n3 3\n3 2\n1 2\n3 1\n1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 666;\nconst int inf = 0x3f3f3f;\n\nint g[MAXN][MAXN];\nint mat[MAXN][MAXN], flow[MAXN][MAXN];\n\nint max_flow(int n, int source, int sink)\n{\n    int pre[MAXN], que[MAXN], d[MAXN], p, q, t, i, j;\n    if (source == sink)\n        return 0;\n    for (i = 0; i < n; i++)\n        for (j = 0; j < n; flow[i][j++] = 0);\n    for (;;) {\n        for(i = 0; i < n; pre[i++] = 0);\n        pre[t=source] = source + 1, d[t] = inf;\n        for (p = q = 0; p <= q && !pre[sink]; t = que[p++])\n            for (i = 0; i < n; i++)\n                if (!pre[i] && (j = mat[t][i] - flow[t][i]))\n                    pre[que[q++]=i] = t + 1, d[i] = d[t] < j ? d[t] : j;\n                else if (!pre[i] && (j = flow[i][t]))\n                    pre[que[q++]=i] = -t-1, d[i] = d[t] < j ? d[t] : j;\n        if (!pre[sink]) break;\n        for (i = sink; i != source;)\n            if (pre[i] > 0)\n                flow[pre[i]-1][i] += d[sink], i = pre[i] - 1;\n            else\n                flow[i][-pre[i]-1] -= d[sink], i = -pre[i] - 1;\n    }\n    for (j = i = 0; i < n; j += flow[source][i++]);\n    return j;\n}\n\nint main()\n{\n    int n, m, x, y;\n    scanf (\"%d %d\", &n, &m);\n    for (int i = 1; i <= m; i++)\n    {\n        scanf (\"%d %d\", &x, &y);\n        x--, y--;\n        mat[x][y] = mat[y][x] = 1;\n        g[x][y] = i; g[y][x] = 0;\n    }\n    scanf (\"%d %d\", &x, &y);\n    x--, y--;\n    printf (\"%d\\n\", max_flow(n, x, y));\n    vector<int> ans;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if(flow[i][j] && !g[i][j] && g[j][i])\n                ans.push_back(g[j][i]);\n    printf (\"%d\\n\", (int)ans.size());\n    //sort(ans.begin(), ans.end());\n    for (int i = 0; i < (int)ans.size(); i++)\n        printf (\"%d\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge {\n  int to, cap, rev, cost;\n};\n\nconstexpr int MAX_V = 1000;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nint flag[MAX_V][MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back(edge{to, cap, (int)G[to].size(), cost});\n  G[to].push_back(edge{from, 0, (int)G[from].size() - 1, -cost});\n}\n\nvoid bfs(int s) {\n  fill_n(level, MAX_V, -1);\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n    for (int i = 0; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[e.to] < 0) {\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  for (int &i = iter[v]; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (e.cap > 0 && level[v] < level[e.to]) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s, int t) {\n  int flow = 0;\n  for (;;) {\n    bfs(s);\n    if (level[t] < 0) return flow;\n    fill_n(iter, MAX_V, 0);\n    int f;\n    while ((f = dfs(s, t, numeric_limits<int>::max())) > 0) {\n      flow += f;\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    add_edge(a, b, 1, 0);\n    add_edge(b, a, 1, 0);\n    flag[b][a] = i + 1;\n  }\n  int s, t;\n  cin >> s >> t;\n  cout << max_flow(s, t) << endl;\n  set<int> ans;\n  for (int i = 0; i < MAX_V; ++i) {\n    for (auto e : G[i]) {\n      if (flag[i][e.to] && e.cap < 1) ans.insert(flag[i][e.to]);\n    }\n  }\n  cout << ans.size() << endl;\n  for (auto x : ans) {\n    cout << x << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct flowGraph{\n\tstruct edge{ int to, cap, rev, id; };\n\t\n\tint n, *level, *iter;\n\tvector<vector<edge> > G;\n\t\n\tflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\titer = new int[n]; level = new int[n];\n\t}\n\t~flowGraph(){\n\t\tdelete iter; delete level;\n\t}\n\t\n\tvoid add(int s, int t, int cap, int id){\n\t\tG[s].pb((edge){t, cap, G[t].size(), 0});\n\t\tG[t].pb((edge){s, 0, G[s].size() - 1, id});\n\t}\n\tvoid bfs(int s){\n\t\trep(i, n) level[i] = -1;\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\t\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, G[v].size()){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\trep(i, n) iter[i] = 0;\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, inf)) > 0) flow += f;\n\t\t}\n\t}\n};\n\nint main(){\n\tint n, m, s, t;\n\tcin >> n >> m;\n\tflowGraph g(n);\n\trep(i, m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg.add(a, b, 1, i + 1);\n\t\tg.add(b, a, 1, -i -1);\n\t}\n\tcin >> s >> t;\n\tcout << g.max_flow(s - 1, t - 1) << endl;\n\tvi res;\n\trep(i, n) each(j, g.G[i]) if(j->id < 0 && j->cap > 0) res.pb(-j->id);\n\tcout << res.size() << endl;\n\trep(i, res.size()) cout << res[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=305,INF=1<<30;\nstruct edge{int to,cap,rev,id,check;};\n\nvector<edge> G[MAX];\nint level[MAX];\nint iter[MAX];\n\nvoid add_edge(int from,int to,int cap,int id){\n    G[from].push_back((edge){to,cap,int(G[to].size()),id,1});\n    G[to].push_back((edge){from,0,int(G[from].size())-1,id,0});\n}\n\nvoid BFS(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s] =0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front();que.pop();\n        for(int i=0;i<G[v].size();i++){\n            edge &e =G[v][i];\n            if(e.cap>0&&level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint DFS(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<G[v].size();i++){\n        edge &e =G[v][i];\n        if(e.cap>0&&level[v]<level[e.to]){\n            int d= DFS(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow=0;\n    for(;;){\n        BFS(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=DFS(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    vector<pair<int,int>> E(M);\n    for(int i=0;i<M;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        add_edge(a,b,1,-1);\n        add_edge(b,a,1,i);\n        E[i]=mp(a,b);\n    }\n    int s,t;cin>>s>>t;\n    s--;t--;\n    cout<<max_flow(s,t)<<endl;\n    \n    set<int> ans;\n    for(int i=0;i<N;i++){\n        for(auto x:G[i]){\n            if(x.check==1){\n                if(x.cap==0&&x.id>=0) ans.insert(x.id);\n            }\n        }\n    }\n    \n    cout<<si(ans)<<endl;\n    for(int a:ans) cout<<a+1<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef int Weight;\n\nconst Weight INF=10000;\nstruct Edge{\n  \tint src, dest;\n  \tint cap, rev;\n  \tWeight weight;\n    bool flag;\n    int id;\n  \tbool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, int cap, int id) {\n  g[src].push_back((Edge){src, dest, cap, int(g[dest].size()), 0, false, id});\n  g[dest].push_back((Edge){dest, src, cap, int(g[src].size()) - 1, 0, true, id});\n}\n\nbool visited[400];\nint dfs(Graph &g, int v, int t, int f) {\n\tif (v == t) return f;\n\tvisited[v] = true;\n\tREP(i, g[v].size()) {\n\t\tEdge& e = g[v][i];\n\t\tif (!visited[e.dest] && e.cap > 0) {\n\t\t\tint d = dfs(g, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(Graph &g, int s, int t) {\n\tint flow = 0;\n\tfor(;;) {\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tint f = dfs(g, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  Graph g(n);\n  REP(i,m){\n    int x,y;\n    cin>>x>>y;\n    --x;--y;\n    add_edge(g,x,y,1,i);\n    //add_edge(g,y,x,1,true);\n  }\n  int s,t;\n  cin>>s>>t;\n  --s;--t;\n  int f = max_flow(g,s,t);\n  cout<<f<<endl;\n  vector<int> revs;\n  REP(i,n)for(Edge e:g[i])\n    if(e.flag && e.cap==0){\n      revs.push_back(e.id+1);\n    }\n  cout<<revs.size()<<endl;\n  for(int id:revs)cout<<id<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// UVa11248 Frequency Hopping：使用Dinic算法\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 300 + 10;\nconst int INF = 1000000000;\n\nstruct Edge {\n  int from, to, cap, flow;\n};\n\nbool operator < (const Edge& a, const Edge& b) {\n  return a.from < b.from || (a.from == b.from && a.to < b.to);\n}\n\nstruct Dinic {\n  int n, m, s, t;\n  vector<Edge> edges;    // ?数的?倍\n  vector<int> G[maxn];   // ?接表，G[i][j]表示?点i的第j条?在e数?中的序号\n  bool vis[maxn];         // BFS使用\n  int d[maxn];           // 从起点到i的距?\n  int cur[maxn];        // 当前弧指?\n\n  void ClearAll(int n) {\n    for(int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void ClearFlow() {\n    for(int i = 0; i < edges.size(); i++) edges[i].flow = 0;    \n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back((Edge){from, to, cap, 0});\n    edges.push_back((Edge){to, from, cap, 0});\n    m = edges.size();\n    G[from].push_back(m-2);\n    G[to].push_back(m-1);\n  }\n\n  bool BFS() {\n    memset(vis, 0, sizeof(vis));\n    queue<int> Q;\n    Q.push(s);\n    vis[s] = 1;\n    d[s] = 0;\n    while(!Q.empty()) {\n      int x = Q.front(); Q.pop();\n      for(int i = 0; i < G[x].size(); i++) {\n        Edge& e = edges[G[x][i]];\n        if(!vis[e.to] && e.cap > e.flow) {\n          vis[e.to] = 1;\n          d[e.to] = d[x] + 1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return vis[t];\n  }\n\n  int DFS(int x, int a) {\n    if(x == t || a == 0) return a;\n    int flow = 0, f;\n    for(int& i = cur[x]; i < G[x].size(); i++) {\n      Edge& e = edges[G[x][i]];\n      if(d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap-e.flow))) > 0) {\n        e.flow += f;\n        edges[G[x][i]^1].flow -= f;\n        flow += f;\n        a -= f;\n        if(a == 0) break;\n      }\n    }\n    return flow;\n  }\n\n  int Maxflow(int s, int t) {\n    this->s = s; this->t = t;\n    int flow = 0;\n    while(BFS()) {\n      memset(cur, 0, sizeof(cur));\n      flow += DFS(s, INF);\n    }\n    return flow;\n  }\n\n  vector<int> Mincut() { // call this after maxflow\n    vector<int> ans;\n    for(int i = 0; i < edges.size(); i++) {\n      Edge& e = edges[i];\n      if(vis[e.from] && !vis[e.to] && e.cap > 0) ans.push_back(i);\n    }\n    return ans;\n  }\n\n  void Reduce() {\n    for(int i = 0; i < edges.size(); i++) edges[i].cap -= edges[i].flow;\n  }\n};\n\nDinic g;\n\nvector <int>ans;\n\nint main() {\n\tint n, m, u, v;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tg.AddEdge(u,v,1);\n\t}\n\tscanf(\"%d%d\",&u,&v);\n\tprintf(\"%d\\n\",g.Maxflow(u,v));\n\tint tot = 0;\n\tfor(int i = 0; i < m; i++) if(g.edges[i<<1|1].flow > 0) {\n\t\tans.push_back(i+1);\n\t\ttot++;\n\t}\n\tprintf(\"%d\\n\",ans.size());\n\twhile(tot--) printf(\"%d\\n\",ans[tot]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 300\n#define inf 1<<30\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nint n,m;\nvector<edge> G[MAX_N];\nvector<edge> g[MAX_N];\nbool used[MAX_N];\n\nvoid add_edge(int from,int to,int cap){\n  g[from].push_back((edge){to,cap,g[to].size()});\n  g[to].push_back((edge){from,0,g[from].size()-1});\n}\n\nvoid copy(){\n  for(int i=0;i<n;i++)G[i]=g[i];\n}\n\nvoid erase_edge(int from,int to){\n  for(int i=0;i<g[from].size();i++){\n    if(g[from][i].to==to){\n      g[from].erase(g[from].begin()+i);\n      return;\n    }\n  }\n  for(int i=0;i<g[to].size();i++){\n    if(g[to][i].to==from && g[to][i].cap==0){\n      g[to].erase(g[to].begin()+i);\n      return;\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+MAX_N,0);\n    int f=dfs(s,t,inf);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\n\nint main()\n{\n  int x[1001],y[1001],s,t;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>x[i]>>y[i];\n    x[i]--;y[i]--;\n    add_edge(x[i],y[i],1);\n    add_edge(y[i],x[i],1);\n  }\n  cin>>s>>t;\n  s--;t--;\n\n  copy();\n  int f=max_flow(s,t);\n  cout<<f<<endl;\n\n  vector<int> V;\n  for(int i=0;i<m;i++){\n    erase_edge(x[i],y[i]);\n    copy();\n    int a=max_flow(s,t);\n    if(a==f)V.push_back(i);\n    add_edge(x[i],y[i],1);\n  }\n  cout<<V.size()<<endl;\n  for(int i=0;i<V.size();i++)cout<<V[i]+1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef vector<vector<int> > Mat;\nconst int inf = 1e9;\n\nint dfs(int pos, int g, int amount, vector<bool> &used, Mat &adj, Mat &flow){\n    if(pos == g) return amount;\n    if(used[pos]) return -1;\n    used[pos] = true;\n    \n    for(int i=0; i<(int)adj.size(); i++){\n        if(adj[pos][i] > 0){\n            int ret = dfs(i, g, min(amount, adj[pos][i]), used, adj, flow);\n            if(ret > 0){\n                adj[pos][i] -= ret;\n                adj[i][pos] += ret;\n                flow[pos][i] += ret;\n                flow[i][pos] -= ret;\n                return ret;\n            }\n        }\n    }\n    return -1;\n}\n\nMat solve(int s, int g, Mat adj){\n    int n = adj.size();\n    Mat ret(n, vector<int>(n, 0));\n    while(1){\n        vector<bool> used(n, false);\n        if(dfs(s, g, inf, used, adj, ret) == -1) break;\n    }\n    return ret;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> s(m), d(m);\n    Mat adj(n+1, vector<int>(n+1, 0));\n    for(int i=0; i<m; i++){\n        cin >> s[i] >> d[i];\n        adj[s[i]][d[i]]++;\n        adj[d[i]][s[i]]++;\n    }\n    int x,y;\n    cin >> x >> y;\n\n    Mat flow = solve(x, y, adj);\n    int mflow = 0;\n    for(int i=1; i<=n; i++){\n        mflow += flow[i][y];\n    }\n    cout << mflow << endl;\n    \n    vector<int> rev;\n    for(int i=0; i<m; i++){\n        bool f = false;\n        if(flow[s[i]][d[i]] > 0) f = true;\n        if(flow[d[i]][s[i]] > 0 && flow[d[i]][s[i]] == adj[s[i]][d[i]]){\n            f = true;\n            swap(s[i], d[i]);\n            rev.push_back(i+1);\n        }\n        if(f){\n            flow[s[i]][d[i]]--;\n            flow[d[i]][s[i]]++;\n            adj[s[i]][d[i]]--;\n            adj[d[i]][s[i]]--;\n        }\n    }\n    cout << rev.size() << endl;\n    for(int i=0; i<(int)rev.size(); i++){\n        cout << rev[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct Dinic {\n\tusing Flow = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap) :to(to), rev(rev), cap(cap) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<bool> used;\n\tvector<int> level;\n\tvector<int> iter;\n\tDinic(int n) :n(n), g(n), used(n), level(n), iter(n) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0);\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\tg[a].emplace_back(b, (int)g[b].size(), cap);\n\t\tg[b].emplace_back(a, (int)g[a].size() - 1, cap);\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = 0;\n\t\twhile (true) {\n\t\t\tlevelize(s);\n\t\t\tif (level[t] < 0)return total;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tFlow f;\n\t\t\twhile (true) {\n\t\t\t\tf = augment(s, t, INF);\n\t\t\t\tif (f == 0)break;\n\t\t\t\ttotal += f;\n\t\t\t}\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < g[v].size(); i++) {\n\t\t\tEdge &e = g[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tFlow d = augment(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid levelize(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile (q.size()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M; cin >> N >> M;\n\tDinic dnc(N);\n\tvector<vector<int>> g(N, vector<int>(N));\n\tvector<int> X(M), Y(M); rep(i, 0, M) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--, Y[i]--;\n\t\tdnc.addEdge(X[i], Y[i], 1);\n\t\tg[X[i]][Y[i]] = i + 1;\n\t}\n\tint S, T; cin >> S >> T; S--, T--;\n\tcout << dnc.maximumFlow(S, T) << endl;\n\tvector<int> ans;\n\trep(i, 0, N) {\n\t\tfor (auto &e : dnc.g[i]) {\n\t\t\tif (g[i][e.to] && e.cap != 0) {\n\t\t\t\tans.emplace_back(g[i][e.to]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans.size() << endl;\n\trep(i, 0, ans.size()) { cout << ans[i] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//23\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,rev;\n};\n\nvector<edge> G[301];\nint d[301][301];\nbool used[301];\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int r=dfs(e.to,t,min(f,e.cap));\n      if(r>0){\n\te.cap-=r;\n\td[v][G[v][i].to]-=r;\n\tG[e.to][e.rev].cap+=r;\n\td[G[v][i].to][v]+=r;\n\treturn r;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[1000],y[1000];\n  for(int i=0;i<m;i++){\n    cin>>x[i]>>y[i];\n    edge xy={y[i],1,G[y[i]].size()};\n    G[x[i]].push_back(xy);\n    edge yx={x[i],1,G[x[i]].size()-1};\n    G[y[i]].push_back(yx);\n    d[x[i]][y[i]]=d[y[i]][x[i]]=1;\n  }\n  int s,t;\n  cin>>s>>t;\n  int flow=0;\n  for(;;){\n    fill(used,used+301,false);\n    int f=dfs(s,t,1<<30);\n    if(f==0)break;\n    flow+=f;\n  }\n  int nr=0;\n  stringstream ss;\n  for(int i=0;i<m;i++){\n     if(d[y[i]][x[i]]==0){\n      nr++;\n      ss<<i+1<<endl;\n    }\n  }\n  cout<<flow<<endl;\n  cout<<nr<<endl;\n  cout<<ss.str();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, cap, rev, id;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int INF = 1<<28;\nconst int MAXN = 333;\nint N, M, S, T;\nint C[MAXN][MAXN];\nGraph G;\nbool vis[MAXN];\n\nvoid add_edge(int from, int to, bool bi_dir, int id) {\n  G[from].push_back((Edge){to, 1, G[to].size(), 0});\n  G[to].push_back((Edge){from, 1, G[from].size() - 1, bi_dir ? 0 : id});\n}\n\nint dfs(int v, int dst, int f) {\n  vis[v] = true;\n  if (v == dst) return f;\n  for (int i = 0; i < G[v].size(); ++i) {\n    Edge &e = G[v][i];\n    if (vis[e.v]) continue;\n    if (e.cap == 0) continue;\n    int d = dfs(e.v, dst, min(f, e.cap));\n    if (d) {\n      e.cap -= d;\n      G[e.v][e.rev].cap += d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int f = 0;\n  while (1) {\n    memset(vis, 0, sizeof(vis));\n    int d = dfs(s, t, INF);\n    if (d == 0) return f;\n    f += d;\n  }\n}\n\nint main() {\n  while (cin >> N >> M) {\n    memset(C, 0, sizeof(C));\n    for (int i = 0; i < M; ++i) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      C[x][y] = i + 1;\n    }\n    cin >> S >> T;\n    --S; --T;\n\n    G = Graph(N);\n    for (int i = 0; i < N; ++i) {\n      for (int j = 0; j < N; ++j) {\n        if (C[i][j]) {\n          add_edge(i, j, C[j][i], C[i][j]);\n        }\n      }\n    }\n\n    int res = max_flow(S, T);\n    cout << res << endl;\n    vector<int> ids;\n    for (int v = 0; v < N; ++v) {\n      for (int i = 0; i < G[v].size(); ++i) {\n        const Edge &e = G[v][i];\n        if (e.id > 0 && e.cap == 0) {\n          ids.push_back(e.id);\n        }\n      }\n    }\n    cout << ids.size() << endl;\n    for (int i = 0; i < ids.size(); ++i) {\n      cout << ids[i] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int to, cap, rev; bool is_rev; };\nint V, E, S, T, c[309][309]; vector<int> used; vector<vector<edge> > G;\nvoid add_edge(int v1, int v2, int cap) {\n\tG[v1].push_back(edge{ v2, cap, (int)G[v2].size(), false });\n\tG[v2].push_back(edge{ v1, 0, (int)G[v1].size() - 1, true });\n}\nint rec(int p, int t, int f) {\n\tif (p == t) return f;\n\tused[p] = 1;\n\tfor (auto &e : G[p]) {\n\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\tint res = rec(e.to, t, min(e.cap, f));\n\t\tif (res) {\n\t\t\tif(!e.is_rev) c[p][e.to] += res;\n\t\t\te.cap -= res, G[e.to][e.rev].cap += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint ret = 0;\n\twhile (true) {\n\t\tused = vector<int>(V, 0);\n\t\tint res = rec(s, t, 2147483647);\n\t\tif (!res) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> V >> E; G.resize(V);\n\tvector<int> x1(E), x2(E);\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x1[i] >> x2[i]; x1[i]--, x2[i]--;\n\t\tadd_edge(x1[i], x2[i], 1);\n\t\tadd_edge(x2[i], x1[i], 1);\n\t}\n\tcin >> S >> T; S--, T--;\n\tcout << max_flow(S, T) << endl;\n\tint ret = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) ret++;\n\t}\n\tcout << ret << endl;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct FordFulkerson{\n    struct Edge {\n        int to,cap,rev;\n        Edge(int to=0,int cap=0,int rev=0) :\n            to(to),cap(cap),rev(rev){}\n    };\n\n    int V;\n    vector<vector<Edge> > G;\n    vector<bool> used;\n\n    FordFulkerson(int V) : V(V) {\n        G.resize(V);\n        used.assign(V,false);\n    }\n\n    void add_edge(int from,int to,int cap) {\n        G[from].pb(Edge(to,cap,G[to].size()));\n        G[to].pb(Edge(from,0,G[from].size()-1));\n    }\n\n    int dfs(int v,int t,int f) {\n        if(v==t) return f;\n        used[v]=true;\n        for(int i=0;i<G[v].size();i++) {\n            Edge &e=G[v][i];\n\n            if(!used[e.to] && e.cap>0) {\n                int d=dfs(e.to,t,min(f,e.cap));\n                if(d>0) {\n                    e.cap-=d;\n                    G[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s,int t) {\n        int flow=0;\n        while(1) {\n            used.assign(V,false);\n            int f=dfs(s,t,INF);\n            if(f==0) break;\n            flow+=f;\n        }\n\n        return flow;\n    }\n    void dump() {\n        rep(i,V) {\n            printf(\"%d size=%d\\n\",i,G[i].size());\n            rep(j,G[i].size()) {\n                Edge e=G[i][j];\n                printf(\" %d->%d cap:%d rev=%d\\n\",i,e.to,e.cap,e.rev);\n            }\n        }\n    }\n    int get_cap(int v,int u) {\n        rep(i,G[v].size()) if(G[v][i].to==u) return G[v][i].cap;\n        return -INF;\n    }\n};\nint n,m;\nint s,t;\nint main() {\n    cin>>n>>m;\n    FordFulkerson ff(n);\n    map<P,int> in;\n    rep(i,m) {\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        ff.add_edge(x,y,1);\n        ff.add_edge(y,x,1);\n        in[P(x,y)]=i+1;\n    }\n    cin>>s>>t;\n    s--,t--;\n    cout<<ff.max_flow(s,t)<<endl;\n    vector<int> ans;\n\n    for(auto e : in) {\n        if(ff.get_cap(e.fr.fr,e.fr.sc)>0) ans.pb(e.sc);\n    }\n\n    cout<<ans.size()<<endl;\n    rep(i,ans.size()) cout<<ans[i]<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      //bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> struct edge\n{\n  int to;\n  T cap;\n  int reverse;\n  int id;\n  edge(int to, T cap, int reverse, int id) : to(to), cap(cap), reverse(reverse), id(id) {}\n};\n\ntemplate <typename T> class Dinic\n{\nprivate:\n  static const T INF = (T)1000000000;\n  vector<edge<T> >* G;\n  int N;\n  int* level;\n  int* iter;\n\n  void bfs(int s);\n  T dfs(int v, int t, T f);\n\npublic:\n  Dinic(int N) : N(N) { this->init(); }\n  void init();\n  void addEdge(int from, int to, T cap, int id);\n  T MaximumFlow(int s, int t);\n  pair<T, vector<int> > solve(int s, int t);\n};\n\ntemplate<typename T> void Dinic<T>::init()\n{\n  G = new vector<edge<T> >[N];\n  level = new int[N];\n  iter = new int[N];\n  rep(i, N) G[i].clear();\n}\n\ntemplate<typename T> void Dinic<T>::addEdge(int from, int to, T cap, int id)\n{\n  G[from].pb(edge<T>(to, cap, G[to].size(), id));\n  G[to].pb(edge<T>(from, cap, G[from].size()-1, -id));\n}\n\ntemplate<typename T> void Dinic<T>::bfs(int s)\n{\n  rep(i, N) level[i] = -1;\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();  que.pop();\n    vrep(w, G[v]){\n      edge<T>& e = *w;\n      if(e.cap > (T)0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\ntemplate<typename T> T Dinic<T>::dfs(int v, int t, T f)\n{\n  if(v == t) return f;\n  for(int& i = iter[v]; i<G[v].size(); i++){\n    edge<T>& e = G[v][i];\n    if(e.cap > (T)0 && level[v] < level[e.to]){\n      T d = dfs(e.to, t, min(f, e.cap));\n      if(d > (T)0){\n        e.cap -= d;\n        G[e.to][e.reverse].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\ntemplate<typename T> T Dinic<T>::MaximumFlow(int s, int t)\n{\n  T flow = (T)0;\n  while(true){\n    bfs(s);\n    if(level[t] < (T)0) return flow;\n    rep(i, N) iter[i] = 0;\n    T f;\n    while((f = dfs(s, t, Dinic::INF)) > (T)0){\n      flow += f;\n    }\n  }\n}\n\ntemplate<typename T> pair<T, vector<int> > Dinic<T>::solve(int s, int t)\n{\n  T mx = this->MaximumFlow(s, t);\n  vi ret;\n  rep(i, N) vrep(v, G[i]) if(v->cap == 0 && v->id < 0) ret.pb(-v->id);\n  sort(ALL(ret));\n  return mp(mx, ret);\n}\n\nint N, M;\nint S, T;\nint x, y;\nint mx;\n\nint main(int argc, char *argv[])\n{\n  cin >> N >> M;\n  Dinic<int> dinic(N);\n\n  rep(i, M){\n    cin >> x >> y;\n    dinic.addEdge(x - 1, y - 1, 1, i + 1);\n  }\n  cin >> S >> T;\n  \n  pair<int, vi> res = dinic.solve(S - 1, T - 1);\n  cout << res.first << endl;\n  cout << res.second.size() << endl;\n  vrep(v, res.second) cout << *v << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int V, E;\n    int S, T;\n\n    struct Edge {\n        int from, to, cap, rev, index;\n        Edge() {}\n        Edge(int from, int to, int index, int cap, int rev) : from(from), to(to), index(index), cap(cap), rev(rev) {}\n    };\n    vector< vector<Edge> > G;\n    vector<bool> used;\n    void init() {\n        G.clear(); G.resize(V);\n        used.clear(); used.resize(V);\n    }\n    void addEdge(int from, int to, int index) {\n        G[from].push_back(Edge(from, to, index, 1, G[to].size()));\n        G[to].push_back(Edge(to, from, index, 1, int(G[from].size()) - 1));\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge& e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int maxflow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            fill(used.begin(), used.end(), false);\n            int f = dfs(s, t, 1e9);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    vector< vector<bool> > U;\n    void input() {\n        cin >> V >> E;\n        init();\n        U.clear(); U.resize(V, vector<bool>(V, false));\n        for (int i = 0; i < E; i++) {\n            int x, y; cin >> x >> y;\n            x--; y--;\n            U[x][y] = true;\n            addEdge(x, y, i);\n        }\n        cin >> S >> T;\n        S--; T--;\n    }\n\n    void solve() {\n        cout << maxflow(S, T) << endl;\n        vector<int> ans;\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < G[i].size(); j++) {\n                Edge& e = G[i][j];\n                if (e.cap == 0 && U[e.to][e.from]) {\n                    ans.push_back(e.index);\n                }\n            }\n        }\n        cout << ans.size() << endl;\n        for (int i = 0; i < ans.size(); i++) cout << ans[i] + 1 << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 300;\nconst int inf = (1<<20);\nint cap[N][N];\nint flow[N][N];\nbool vis[N];\n\nint fordFulkerson(int n,int s,int t,int now,int fl){\n  if (now == t)return fl;\n  if (vis[now])return 0;\n  vis[now]=true;\n  int tmp=0;\n  rep(i,n){\n    int &next=i;\n    if (cap[now][i] - flow[now][i] > 0){\n      tmp=fordFulkerson(n,s,t,next,min(fl,cap[now][i]-flow[now][i]));\n      if (tmp != 0){\n\tflow[now][next]+=tmp;\n\tflow[next][now]=-flow[now][next];\n\treturn tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int n,int s,int t){\n  int tmp=0,ret=0;\n  rep(i,n)vis[i]=false;\n  while((tmp = fordFulkerson(n,s,t,s,inf)) != 0){\n    ret+=tmp;\n    rep(i,n)vis[i]=false;\n  }\n  return ret;\n}\n\nbool edge[N][N];\nint num[N][N];\nmain(){\n  int n,m;\n  while(cin>>n>>m){\n    rep(i,n)rep(j,n)flow[i][j]=0,cap[i][j]=0,edge[i][j]=false,num[i][j]=-1;\n    rep(i,m){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      edge[a][b]=true;\n      num[a][b]=num[b][a]=i+1;\n      cap[a][b]=cap[b][a]=1;\n    }\n    int s,t;\n    cin>>s>>t;\n    s--;t--;\n    int ans=maxFlow(n,s,t);\n    cout << ans << endl;\n    int cnt=0;\n    rep(i,n)rep(j,n)if (flow[i][j] > 0 && !edge[i][j])cnt++;\n    cout << cnt << endl;\n    rep(i,n)rep(j,n)if (flow[i][j] > 0 && !edge[i][j])cout << num[i][j] << endl;\n#ifdef DEBUG\n    cout <<\"end\" << endl;\n#endif    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<ctime>\nusing namespace std;\nconst int MAX=1005;\nconst int inf=1<<30;\nstruct node\n{\n    int v,c,next,id;\n}g[MAX*100];\nint adj[MAX],cur[MAX],dis[MAX],pre[MAX],num[MAX],res[MAX],flag[MAX];\nint n,m,e,s,t,vn,f,cnt;\nvoid add(int u,int v,int c,int id)\n{\n    g[e].v=v; g[e].c=c; g[e].id=id; g[e].next=adj[u]; adj[u]=e++;\n    g[e].v=u; g[e].c=0; g[e].id=id; g[e].next=adj[v]; adj[v]=e++;\n}\nint sap()\n{\n    int i,u,v,flag,aug=inf,flow=0;\n    for(i=0;i<=vn;i++)\n    {\n        cur[i]=adj[i];\n        num[i]=dis[i]=0;\n    }\n    num[0]=vn;\n    pre[s]=u=s;\n    while(dis[s]<vn)\n    {\n        flag=0;\n        for(i=cur[u];i!=-1;i=g[i].next)\n        {\n            v=g[i].v;\n            if(g[i].c&&dis[u]==dis[v]+1)\n            {\n                flag=1;\n                aug=min(aug,g[i].c);\n                pre[v]=u;\n                cur[u]=i;\n                u=v;\n                if(u==t)\n                {\n                    flow+=aug;\n                    while(u!=s)\n                    {\n                        u=pre[u];\n                        g[cur[u]].c-=aug;\n                        g[cur[u]^1].c+=aug;\n                    }\n                    aug=inf;\n                }\n                break;\n            }\n        }\n        if(flag)\n            continue;\n        if(--num[dis[u]]==0)\n            break;\n        for(dis[u]=vn,i=adj[u];i!=-1;i=g[i].next)\n        {\n            v=g[i].v;\n            if(g[i].c&&dis[v]<dis[u])\n            {\n                dis[u]=dis[v];\n                cur[u]=i;\n            }\n        }\n        dis[u]++;\n        num[dis[u]]++;\n        u=pre[u];\n    }\n    return flow;\n}\nint main()\n{\n    int i,j,k;\n    while(scanf(\"%d%d\",&vn,&m)!=EOF)\n    {\n        memset(adj,-1,sizeof(adj));\n        e=0;\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&j,&k);\n            add(j,k,1,i+1); add(k,j,1,i+1);\n        }\n        scanf(\"%d%d\",&s,&t);\n        int max_flow=sap();\n        k=0;\n        memset(flag,false,sizeof(flag));\n        for(i=0;i<e;i+=4)\n        {\n            if(g[i].c==1&&g[i+2].c==0)\n                flag[g[i].id]=true;\n        }\n        for(i=1;i<=m;i++)\n            if(flag[i])\n                res[k++]=i;\n        printf(\"%d\\n%d\\n\",max_flow,k);\n        for(i=0;i<k;i++)\n            printf(\"%d\\n\",res[i]);\n    }\n    return 0;\n}\n/*\n2 1\n2 1\n2 1\n\n2 1\n1 2\n2 1\n\n3 3\n3 2\n1 2\n3 1\n1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[505];\nbool used[505];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\n\n\nint n,m;\nint S,T;\nint aa[300005],bb[300005];\nbool bad[305][305];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tadd_edge(a,b,1);\n\t\tadd_edge(b,a,1);\n\t\taa[i] = a; bb[i] = b;\n\t}\n\tscanf(\"%d%d\",&S,&T);\n\tint x = max_flow(S,T);\n\tcout << x << endl;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tif(G[i][j].cap == 1){\n\t\t\t\tbad[i][G[i][j].to] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>ans;\n\tfor(int i=1;i<=m;i++){\n\t\tif(bad[aa[i]][bb[i]]) ans.pb(i);\n\t}\n\tcout << ans.size() << endl;\n\trep(i,ans.size()) cout<<ans[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<ctime>\nusing namespace std;\nconst int MAX=1005;\nconst int inf=1<<30;\nstruct node\n{\n    int v,c,next,id;\n}g[MAX*100];\nint adj[MAX],cur[MAX],dis[MAX],pre[MAX],num[MAX],res[MAX];\nint n,m,e,s,t,vn,f,cnt;\nvoid add(int u,int v,int c,int id)\n{\n    g[e].v=v; g[e].c=c; g[e].id=id; g[e].next=adj[u]; adj[u]=e++;\n    g[e].v=u; g[e].c=0; g[e].id=id; g[e].next=adj[v]; adj[v]=e++;\n}\nint sap()\n{\n    int i,u,v,flag,aug=inf,flow=0;\n    for(i=0;i<=vn;i++)\n    {\n        cur[i]=adj[i];\n        num[i]=dis[i]=0;\n    }\n    num[0]=vn;\n    pre[s]=u=s;\n    while(dis[s]<vn)\n    {\n        flag=0;\n        for(i=cur[u];i!=-1;i=g[i].next)\n        {\n            v=g[i].v;\n            if(g[i].c&&dis[u]==dis[v]+1)\n            {\n                flag=1;\n                aug=min(aug,g[i].c);\n                pre[v]=u;\n                cur[u]=i;\n                u=v;\n                if(u==t)\n                {\n                    flow+=aug;\n                    while(u!=s)\n                    {\n                        u=pre[u];\n                        g[cur[u]].c-=aug;\n                        g[cur[u]^1].c+=aug;\n                    }\n                    aug=inf;\n                }\n                break;\n            }\n        }\n        if(flag)\n            continue;\n        if(--num[dis[u]]==0)\n            break;\n        for(dis[u]=vn,i=adj[u];i!=-1;i=g[i].next)\n        {\n            v=g[i].v;\n            if(g[i].c&&dis[v]<dis[u])\n            {\n                dis[u]=dis[v];\n                cur[u]=i;\n            }\n        }\n        dis[u]++;\n        num[dis[u]]++;\n        u=pre[u];\n    }\n    return flow;\n}\nint main()\n{\n    int i,j,k;\n    while(scanf(\"%d%d\",&vn,&m)!=EOF)\n    {\n        memset(adj,-1,sizeof(adj));\n        e=0;\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&j,&k);\n            add(j,k,1,i+1); add(k,j,1,i+1);\n        }\n        scanf(\"%d%d\",&s,&t);\n        int max_flow=sap();\n        k=0;\n        for(i=0;i<e;i+=4)\n        {\n            if(g[i+2].c==0)\n                res[k++]=g[i].id;\n        }\n        printf(\"%d\\n%d\\n\",max_flow,k);\n        for(i=0;i<k;i++)\n            printf(\"%d\\n\",res[i]);\n    }\n    return 0;\n}\n/*\n2 1\n2 1\n2 1\n\n2 1\n1 2\n2 1\n\n3 3\n3 2\n1 2\n3 1\n1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef int Weight;\ntypedef int Capacity;\nstruct Edge {\n\tint src, dst; Capacity cap;\n\tEdge(int s, int d, Capacity c) : src(s), dst(d), cap(c) {}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<Capacity> > cap, flow;\n\tvector<vector<int> > g;\n\tCapacity inf;\n\tDinic() {}\n\tDinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf((int)1e9) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < graph[i].size(); j++) {\n\t\t\t\tconst Edge& e = graph[i][j];\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tCapacity c = e.cap;\n\t\t\t\tadd_edge(u, v, c);\n\t\t\t}\n\t\t}\n\t}\n\tDinic(int n_) : n(n_), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n\t\tg(n, vector<int>()), inf((int)1e9) {\n\t}\n\tvoid add_edge(int u, int v, Capacity c) {\n\t\tcap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tvoid reset() {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcap[i][j] = flow[i][j] = 0;\n\t\t\t}\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\tinline Capacity residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tCapacity solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tCapacity res = 0;\n\t\twhile(levelize()) { prog.assign(n, 0); res += augment(s, inf); }\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1); level[s] = 0; que[r++] = s;\n\t\twhile(l != r) {\n\t\t\tint v = que[l++]; if(v == t) break;\n\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\tconst int& d = g[v][i];\n\t\t\t\tif(level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1; que[r++] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tCapacity augment(int v, Capacity lim) {\n\t\tCapacity res = 0;\n\t\tif(v == t) return lim;\n\t\tfor(int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif(residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst Capacity aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug; flow[d][v] -= aug;\n\t\t\tres += aug; lim -= aug;\n\t\t\tif(lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint u[1000];\nint v[1000];\n\nint G[300][300];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\tcin >> N >> M;\n\n\tDinic d(N);\n\tfor(int i = 0; i < M; i++) {\n\t\tcin >> u[i] >> v[i];\n\t\tu[i]--, v[i]--;\n\t\td.add_edge(u[i], v[i], 1);\n\t\td.add_edge(v[i], u[i], 1);\n\t}\n\n\tint s, t;\n\tcin >> s >> t;\n\ts--, t--;\n\tint flow = d.solve(s, t);\n\n\tvector<int> ans;\n\tfor(int i = 0; i < M; i++) {\n\t\tif(d.residue(v[i], u[i]) == 0) {\n\t\t\tans.push_back(i + 1);\n\t\t}\n\t}\n\n\tcout << flow << endl;\n\tcout << ans.size() << endl;\n\tfor(auto a : ans) {\n\t\tcout << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass Edge\n{\npublic:\n  int to, cap, rev, idx;\n  bool isRev;\n  Edge(int _to = 0, int _cap = 0, int _rev = 0, int _idx = 0, bool _isRev = false)\n    :to(_to), cap(_cap), rev(_rev), idx(_idx), isRev(_isRev) {} \n};\n\nvoid add_edge(vector<vector<Edge> >& g, int from, int to, int cap, int idx, bool isRev)\n{\n  g[from].push_back(Edge(to, cap, g[to].size(), idx, isRev));\n  g[to].push_back(Edge(from, 0, g[from].size()-1, idx, isRev));\n}\n\nint ff(vector<vector<Edge> >& g, vector<int>& used, int s, int t, int f, vector<int>& rev)\n{\n  if (s == t)\n    return f;\n  used[s] = 1;\n  \n  for (unsigned int i = 0; i < g[s].size(); ++i) {\n    Edge& e = g[s][i];\n    if (!used[e.to] && e.cap > 0) {\n      int d = ff(g, used, e.to, t, min(f, e.cap), rev);\n      if (d > 0) {\n\tif (e.isRev)\n\t  rev.push_back(e.idx);\n\te.cap -= d;\n\tg[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint solve(vector<vector<Edge> >& g, int s, int t, vector<int>& rev)\n{\n  int flow = 0;\n  for ( ; ; ) {\n    vector<int> used(g.size(), 0);\n    int f = ff(g, used, s, t, INF, rev);\n    if (f == 0)\n      return flow;\n    flow += f;\n  }\n}\n\nint main()\n{\n  int N, M;\n  while (~scanf(\"%d %d\", &N, &M)) {\n    vector<vector<Edge> > g(N);\n    for (int i = 0; i < M; ++i) {\n      int X, Y;\n      scanf(\"%d %d\", &X, &Y);\n      --X;\n      --Y;\n      add_edge(g, X, Y, 1, i+1, false);\n      add_edge(g, Y, X, 1, i+1, true);\n    }\n    int S, T;\n    scanf(\"%d %d\", &S, &T);\n    --S;\n    --T;\n\n    vector<int> rev;\n    printf(\"%d\\n\", solve(g, S, T, rev));\n    printf(\"%d\\n\", rev.size());\n    sort(rev.begin(), rev.end());\n    for (unsigned int i = 0; i < rev.size(); ++i)\n      printf(\"%d\\n\", rev[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<class T, bool directed>\nclass Dinic {\n    void bfs(int s){\n        fill(level.begin(),level.end(), -1);\n        queue<int> Q;\n        level[s] = 0;\n        Q.emplace(s);\n        while(!Q.empty()){\n            int v = Q.front(); Q.pop();\n            for (auto &&e : G[v]){\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    Q.emplace(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, int t, T f){\n        if(v == t) return f;\n        for(int &i = iter[v]; i < G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                T d = dfs(e.to, t, min(f,  e.cap));\n                if(d == 0) continue;\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\npublic:\n    struct edge {\n        int to{}; T cap; int rev{};\n        edge() = default;\n        edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n    Dinic() = default;\n    explicit Dinic(int n) : G(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, int cap){\n        G[from].emplace_back(to, cap, G[to].size());\n        G[to].emplace_back(from, directed ? 0 : cap,  G[from].size()-1);\n    }\n\n\n    T flow(int s, int t, T lim = INF<T>){\n        T ret = 0;\n        while(true) {\n            bfs(s);\n            if(level[t] < 0 || lim == 0) break;\n            fill(iter.begin(),iter.end(), 0);\n            while(true){\n                T f = dfs(s, t, lim);\n                if(f == 0) break;\n                ret += f;\n                lim -= f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m;\n    Dinic<int, false> f(n);\n    map<pair<int, int>, int> e;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        f.add_edge(a-1, b-1, 1);\n        e[{a-1, b-1}] = i+1;\n    }\n    cin >> s >> t;\n    s--; t--;\n    vector<int> ans;\n    cout << f.flow(s, t) << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        for (auto &&j : f.G[i]) {\n            if(j.cap != 0 && e.count({i, j.to})) ans.emplace_back(e[{i, j.to}]);\n        }\n    }\n    cout << ans.size() << \"\\n\";\n    for (auto &&k : ans) {\n        cout << k << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 301;\nint cap[N][N], flow[N][N], edge[N][N];\nint level[N];\nbool finished[N];\nconst int inf = 1<<29;\nint n,m;\n\ninline int residue(int s,int t) { return cap[s][t] - flow[s][t]; }\n\nvoid makeLevel(int s) {\n    memset(level, -1, sizeof(level));\n    level[s] = 0;\n    queue<int> Q; Q.push(s);\n    while(!Q.empty()) {\n        int here = Q.front(); Q.pop();\n        for(int there=0; there<n; ++there) {\n            if(level[there] < 0 && residue(here,there) > 0) {\n                level[there] = level[here] + 1;\n                Q.push(there);\n            }\n        }\n    }\n}\n\nint augment(int here,int curf,int t) {\n    if(here == t || curf == 0) return curf;\n    if(finished[here] != 0) return 0;\n    finished[here] = 1;\n\n    for(int there=0; there<n; ++there) {\n        if(level[there] > level[here]) {\n            int f = augment(there, min(curf, residue(here, there)), t);\n            if(f > 0) {\n                flow[here][there] += f;\n                flow[there][here] -= f;\n                finished[here] = false;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint Dinic(int s,int t) {\n    memset(flow, 0, sizeof(flow));\n    int ret = 0;\n    for(bool cont = true; cont; ) {\n        cont = false;\n        makeLevel(s);\n        memset(finished, 0, sizeof(finished));\n        for(int f; (f = augment(s, inf, t)) > 0; cont = true)\n            ret += f;\n    }\n    return ret;\n}\n\nint main() {\n    int a,b;\n    cin>>n>>m;\n    memset(cap, 0, sizeof(cap));\n    memset(edge, 0, sizeof(edge));\n    for(int i=0; i<m; ++i) {\n        cin>>a>>b;\n        a--,b--;\n        cap[a][b] = cap[b][a] = 1;\n        edge[a][b] = i+1;\n    }\n\n    cin>>a>>b;\n    a--,b--;\n\n    cout<<Dinic(a,b)<<endl;\n\n    int ans = 0;\n    vector<int> av;\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            if(i == j) continue;\n            if(flow[i][j] > 0 && edge[j][i] > 0)\n                av.push_back(edge[j][i]);\n        }\n    }\n\n    sort(av.begin(), av.end());\n    cout<<av.size()<<endl;\n    for(int i=0; i<av.size(); ++i)\n        cout<<av[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\nint N,M;\nstruct edge{\n  int to,cap,rev;\n};\nvector<edge> G[333];\nint E[333][333];\n\nvoid add_edge(int to,int from,int cap){\n  G[from].push_back( (edge){to,cap,G[to].size()} );\n  G[to].push_back( (edge){from,0,G[from].size()-1} );\n\n  G[from].push_back( (edge){to,0,G[to].size()} );\n  G[to].push_back( (edge){from,cap ,G[from].size()-1} );\n}\n\nbool used[333];\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap) );\n      if( d > 0 ){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INF);\n    if( f == 0 ) return flow;\n    flow+=f;\n  }\n}\n\nvector<int> ans;\n\nvoid redfs(int v,int t){\n  if( v == t ) return;\n  if( used[v] ) return;\n  used[v] = true;\n  bool tof[333]={};\n  for(int i=0;i<(int)G[v].size();i++){\n    edge e = G[v][i];\n    if( e.cap > 0 ) tof[e.to] = true;\n  }\n  for(int i=0;i<(int)G[v].size();i++){\n    edge e = G[v][i];\n    if( !tof[e.to] ) {\n      // printf(\" %d -> %d == %d \\n\",e.to,v,E[e.to][v]); \n      if( E[v][e.to] > 0 ) ans.push_back( E[v][e.to] );\n      redfs(e.to,t);\n    }\n  }\n  return ;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int x,y;\n    cin >> x >> y;\n    E[y][x] = i+1;\n    add_edge(y,x,1);\n  }\n  int s,t;\n  cin >> s >> t;\n  int res = max_flow(s,t);\n  cout << res << endl;\n  memset(used,0,sizeof(used));\n  redfs(s,t);\n  sort(ans.begin(),ans.end());\n  ans.erase(unique(ans.begin(),ans.end()),ans.end());\n  cout << ans.size() << endl;\n  for(int i=0;i<(int)ans.size();i++) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct edge\n{\n  int to, cap, rev, id;\n  bool isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, bool isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V, -1), iter(V, 0){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, G[t].size(), id, false));\n    G[t].push_back(edge(f, 1, G[f].size()-1, id, true));\n  }\n  void bfs(int s)\n  {\n    level.clear(); level.resize(G.size(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    for(;;) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.clear(); iter.resize(G.size(), 0);\n      int f;\n      while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  rep(i, M) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  rep(v, dinic.G.size()) {\n    rep(i, dinic.G[v].size()) {\n      edge& e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev) used_rev.push_back(e.id);\n    }\n  }\n  sort(all(used_rev));\n  cout << ans << endl;\n  cout << used_rev.size() << endl;\n  rep(i, used_rev.size()) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nconst int NMAX = 310;\nconst int MMAX = 1010;\nconst int INF = MMAX * 6;\n\nstruct edge { \n  int to, cap, rev, id;\n  bool reversal;\n};\n\nvector<edge> G[NMAX];\nbool used[NMAX];\n\nvoid add_edge(int from, int to, int cap, int id, bool reversal) {\n  G[from].push_back((edge){to, cap, G[to].size(), id, reversal});\n  G[to].push_back((edge){from, 0, G[from].size() - 1, 0, false});\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] and e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  while (true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main() {\n  int n, m, s, t;\n  cin >> n >> m;\n  REP(i, m) {\n    int x, y;\n    cin >> x >> y;\n    add_edge(x, y, 1, i + 1, false);\n    add_edge(y, x, 1, i + 1, true);\n  }\n  cin >> s >> t;\n  cout << max_flow(s, t) << endl;\n\n  vector<int> reverse_roads;\n/*  REP(v, n + 1) {\n    REP(i, G[v].size()) {\n      edge e = G[v][i];\n      cout << \"G[\" << v << \"][\" << i << \"]\";\n      cout << \"to=\" << e.to;\n      cout << \"cap=\" << e.cap;\n      cout << \"rev=\" << e.rev;\n      cout << \"id=\" << e.id;\n      cout << \"reversal=\" << e.reversal << endl;\n    }\n  }*/\n  REP(v, n + 1) {\n    REP(e, G[v].size()) {\n      if (G[v][e].reversal and G[v][e].cap == 0) {\n        reverse_roads.push_back(G[v][e].id);\n      }\n    }\n  }\n  sort(reverse_roads.begin(), reverse_roads.end());\n  int len = reverse_roads.size();\n  cout << len << endl;\n  REP(i, len) {\n    cout << reverse_roads[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nint n,m,begin,end,index;\nint list[301],num[301][301],visit[301][301],road[301][301];\n\nint dfs(int x)\n{\n    //printf(\"begin:%d->%d\\n\",x,end);\n    int ans=0,flag=0,temp=0;\n    if(x==end)return 0;\n    else\n    {\n        for(int i=1; i<=n; i++)\n        {\n            if((road[x][i]||road[i][x])&&!visit[x][i])\n            {\n                visit[x][i]++;\n                visit[i][x]++;\n                temp=dfs(i);\n                if(temp>-1)\n                {\n                    flag++;\n                    ans+=temp;\n                    if(road[x][i])ans++;\n                    if(road[i][x])\n                    {   //printf(\"reserved:%d %d\\n\",i,x);\n                        ans++;\n                        list[index++]=num[i][x];\n                    }\n                }\n            }\n        }\n        if(flag)\n        {\n            //printf(\"[%d->%d:%d]\\n\",x,end,ans);\n            return ans;\n        }\n        else return -1;\n    }\n}\n\nint main()\n{\n    int i;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1; i<=m; i++)\n    {\n        scanf(\"%d%d\",&begin,&end);\n        num[begin][end]=i;\n        road[begin][end]=1;\n    }\n    scanf(\"%d%d\",&begin,&end);\n    int ans=dfs(begin);\n    printf(\"%d\\n%d\\n\",ans,index);\n    for(i=0; i<index; i++)\n    {\n        printf(\"%d\\n\",list[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V), iter(V){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    fill(level.begin(), level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(edge& e : G[v]) {\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G[v].size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(iter.begin(), iter.end(), 0);\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      //int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n      level[t] = -1, flow+=1;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nconst int inf=1000000000;\nconst int N=305;\nint n,a[N][N],pre[N],l[N],ans,e[N*N][2],c[N*N];\nqueue <int> Q;\n\nint min(int x,int y)\n{\n    if (x<y) return x; else return y;\n}\n\nvoid addflow(int s,int t,int d)\n{\n     int i=t;\n     int j=pre[t];\n     while (i!=s)\n     {\n           a[i][j]+=d;\n           a[j][i]-=d;\n           i=j;\n           j=pre[i];\n     }\n     ans+=d;\n}\n\nvoid flow(int s,int t)\n{\n    int i,x;\n    while (1)\n    {\n\n          memset(pre,-1,sizeof(pre));\n          while (!Q.empty()) Q.pop();\n          Q.push(s);\n          l[s]=inf;\n          while (!Q.empty())\n          {\n                x=Q.front(); Q.pop();\n                for (i=1; i<=n; i++)\n                    if ((a[x][i]>0)&& (pre[i]==-1))\n                     {\n                                  l[i]=min(l[x],a[x][i]);\n                                  pre[i]=x;\n                                  Q.push(i);\n                                  if (i==t) break;\n                     }\n                if (pre[t]!=-1) break;\n          }\n          if (pre[t]!=-1) addflow(s,t,l[t]); else return ;\n    }\n}\nint main()\n{\n    int m,i,x,y,l,s,t,res;\n    scanf(\"%d%d\",&n,&m);\n    memset(a,0,sizeof(a));\n    for (i=1; i<=m; i++)\n    {\n            scanf(\"%d%d\",&x,&y);\n            a[x][y]++; a[y][x]++;\n            e[i][0]=x; e[i][1]=y;\n    }\n    ans=0; res=0;\n    scanf(\"%d%d\",&s,&t);\n    flow(s,t);\n    cout<<ans<<endl;\n    for (i=1; i<=m; i++)\n    {\n        x=e[i][0]; y=e[i][1];\n        if (a[x][y]>0 && a[y][x]==0)\n        {\n            res++;\n            c[i]=1;\n        }\n    }\n    cout<<res<<endl;\n    for (i=1; i<=m; i++) if (c[i]) printf(\"%d\\n\",i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAXV = 300;\nconst int MAXE = MAXV * MAXV;\nconst int MAXF = (1<<29);\ntypedef int F;\n\nstruct MaxFlow {\n    F cap[MAXE], flow[MAXE];\n    int V, E, level[MAXV], prev[MAXE], edge[MAXV], to[MAXE];\n    MaxFlow(int n) : E(0) {\n        V = n;\n        memset(flow, 0, sizeof(flow));\n    }\n    void add_edge(int s, int t, F f, F g = 0) {\n        cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // make level graph (bfs)\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    int augment(int s, int t, F f) { // find augment path (dfs)\n        if (s == t || f == 0) return f;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f, cap[e] - flow[e]));\n                if (g > 0) {\n                    flow[e] += g, flow[e^1] -= g;\n                    return g;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int f, ret = 0;\n        for (bool cont = true; cont; ) {\n            cont = false;\n            make_level(s);\n            while ((f = augment(s, t, MAXF)) > 0) {\n                cont = true;\n                ret += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int x[MAXE], y[MAXE];\n    int N,M,a,b;\n    cin>>N>>M;\n    MaxFlow mf(N);\n    for (int i=0; i<M; ++i) {\n        cin>>a>>b; a--, b--;\n        mf.add_edge(a, b, 1, 1);\n        x[i] = a, y[i] = b;\n    }\n    cin>>a>>b; a--, b--;\n    cout<<mf.max_flow(a, b)<<endl;\n    vector<int> rev;\n    for (int i=0; i<M; ++i) {\n        int e = mf.edge[y[i]];\n        while(e != -1) {\n            if (mf.to[e] == x[i] && mf.flow[e] > 0) rev.push_back(i);\n            e = mf.prev[e];\n        }\n    }\n    cout<<rev.size()<<endl;\n    for (int i=0; i<rev.size(); ++i) cout<<rev[i]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 301\n#define inf 1<<30\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nint n,m;\nvector<edge> G[MAX_N];\nint level[MAX_N],iter[MAX_N];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,cap,G[from].size()-1});\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> q;\n  q.push(s);\n  level[s]=0;\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(level[e.to]<0 and e.cap>0){\n\tlevel[e.to]=level[v]+1;\n\tq.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0 && level[e.to]>level[v]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,inf))>0)flow+=f;\n  }\n}\n\nint main()\n{\n  int x[1001],y[1001],s,t;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>x[i]>>y[i];\n    x[i]--;y[i]--;\n    add_edge(x[i],y[i],1);\n  }\n  cin>>s>>t;\n  s--;t--;\n  int f=max_flow(s,t);\n  cout<<f<<endl;\n\n  vector<int> V;\n  \n  for(int i=0;i<m;i++){\n    for(int j=0;j<G[y[i]].size();j++){\n      edge e=G[y[i]][j];\n      if(e.to==x[i]){\n\tif(e.cap<1)V.push_back(i+1);\n      }\n    }\n  }\n  cout<<V.size()<<endl;\n  for(int i=0;i<V.size();i++)cout<<V[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define PB push_back\n#define INF (1000000000)\nusing namespace std;\ntypedef long long LL;\nconst int N=550,M=5+1e6,MOD=7+1e9;\nstruct Node\n{\n    int from,to,next;\n    int cap,id,fg;\n}edge[M];\nint tol;\n\nint dep[N];//dep?点的?次\nint head[N];\nvector<int> G;\nvoid init()\n{\n    tol=0;\n    memset(head,-1,sizeof(head));\n    G.clear();\n}\nvoid addedge(int u,int v,int w,int id,int fg)//第一条?下?必??偶数\n{\n    edge[tol].from=u;\n    edge[tol].to=v;\n    edge[tol].cap=w,edge[tol].id=id,edge[tol].fg=fg;//注意正向?流量?\n    edge[tol].next=head[u];\n    head[u]=tol++;\n}\n\nint BFS(int start,int en)\n{\n    int que[N];\n    int ft,rear;\n    ft=rear=0;\n    memset(dep,-1,sizeof(dep));\n    que[rear++]=start;\n    dep[start]=0;\n    while(ft!=rear)\n    {\n        int u=que[ft++];\n        if(ft==N)ft=0;\n        for(int i=head[u];i!=-1;i=edge[i].next)\n        {\n            int v=edge[i].to;\n            if(edge[i].cap>0&&dep[v]==-1)\n            {\n                dep[v]=dep[u]+1;\n                que[rear++]=v;\n                if(rear>=N)rear=0;\n                if(v==en)return 1;\n            }\n        }\n    }\n    return 0;\n}\nint dinic(int start,int en)\n{\n    int res=0;\n    int top;\n    int sk[N];//stack??，存?当前?广路\n    int cur[N];//存?当前点的后?\n    while(BFS(start,en))\n    {\n        memcpy(cur,head,sizeof(head));\n        int u=start;\n        top=0;\n        while(1)\n        {\n            if(u==en)\n            {\n                int _min=INF;\n                int loc;\n                for(int i=0;i<top;i++)\n                  if(_min>edge[sk[i]].cap)\n                  {\n                      _min=edge[sk[i]].cap;\n                      loc=i;\n                  }\n                for(int i=0;i<top;i++)\n                {\n                    edge[sk[i]].cap-=_min;\n                    edge[sk[i]^1].cap+=_min;\n                }\n                res+=_min;\n                top=loc;\n                u=edge[sk[top]].from;\n            }\n            for(int i=cur[u];i!=-1;cur[u]=i=edge[i].next)\n              if(edge[i].cap!=0&&dep[u]+1==dep[edge[i].to])\n                 break;\n            if(cur[u]!=-1)\n            {\n                sk[top++]=cur[u];\n                u=edge[cur[u]].to;\n            }\n            else\n            {\n                if(top==0)break;\n                dep[u]=-1;\n                u=edge[sk[--top]].from;\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\nusing namespace std;\nconst int maxn=800;\nconst int INF=199999999;\nstruct Edge\n{\n    int from,to,cap,flow;\n    int flag;\n};\nstruct Dinic\n{\n    int n, m, s, t;\n    vector<Edge> edges;    // ?数的?倍\n    vector<int> G[maxn];   // ?接表，G[i][j]表示?点i的第j条?在e数?中的序号\n    bool vis[maxn];         // BFS使用\n    int d[maxn];           // 从起点到i的距?\n    int cur[maxn];        // 当前弧指?\n    void ClearAll(int n)\n    {\n        for(int i = 0; i < n; i++) G[i].clear();\n        edges.clear();\n    }\n    void ClearFlow()\n    {\n        for(int i = 0; i < edges.size(); i++) edges[i].flow = 0;\n    }\n\n    void AddEdge(int from, int to, int cap,int sign)\n    {\n        edges.push_back((Edge){from, to, cap, 0,sign});\n        edges.push_back((Edge){to, from, cap, 0,-sign});\n        m = edges.size();\n        G[from].push_back(m-2);\n        G[to].push_back(m-1);\n    }\n    bool BFS()\n    {\n        memset(vis, 0, sizeof(vis));\n        queue<int> Q;\n        Q.push(s);\n        vis[s] = 1;\n        d[s] = 0;\n        while(!Q.empty())\n        {\n            int x = Q.front();\n            Q.pop();\n            for(int i = 0; i < G[x].size(); i++)\n            {\n                Edge& e = edges[G[x][i]];\n                if(!vis[e.to] && e.cap > e.flow)\n                {\n                    vis[e.to] = 1;\n                    d[e.to] = d[x] + 1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return vis[t];\n    }\n\n    int DFS(int x, int a)\n    {\n        if(x == t || a == 0) return a;\n        int flow = 0, f;\n        for(int& i = cur[x]; i < G[x].size(); i++)\n        {\n            Edge& e = edges[G[x][i]];\n            if(d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap-e.flow))) > 0)\n            {\n                e.flow += f;\n                edges[G[x][i]^1].flow -= f;\n                flow += f;\n                a -= f;\n                if(a == 0) break;\n            }\n        }\n        return flow;\n    }\n\n    int Maxflow(int s, int t)\n    {\n        this->s = s;\n        this->t = t;\n        int flow = 0;\n        while(BFS())\n        {\n            memset(cur, 0, sizeof(cur));\n            flow += DFS(s, INF);\n        }\n        return flow;\n    }\n    vector<int> Mincut()   // call this after maxflow\n    {\n        vector<int> ans;\n        for(int i = 0; i < edges.size(); i++)\n        {\n            Edge& e = edges[i];\n            if(vis[e.from] && !vis[e.to] && e.cap > 0) ans.push_back(i);\n        }\n        return ans;\n    }\n    void Reduce()\n    {\n        for(int i = 0; i < edges.size(); i++) edges[i].cap -= edges[i].flow;\n    }\n};\nDinic g;\n\nvector<int>q;\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    g.n=n;\n    g.ClearAll(n+m+2);\n    for(int i=0;i<m;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        g.AddEdge(a,b,1,i+1);\n    }\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    int fin=g.Maxflow(x,y);\n    printf(\"%d\\n\",fin);\n    for(int i=0;i<g.edges.size();i++)\n    {\n        //cout<<g.edges[i].flow<<endl;\n        if(g.edges[i].flow==1)\n        {\n            if(g.edges[i].flag>0)  continue;\n            else q.push_back(-g.edges[i].flag);\n        }\n    }\n    printf(\"%d\\n\",q.size());\n    sort(q.begin(),q.end());\n    for(int i=0;i<q.size();i++) printf(\"%d\\n\",q[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long long INF64 = 1e18;\n\nusing Weight = long long;\n\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int cost;\n  Edge(int src, int dst, Weight weight, int cost = 0)\n      : src(src), dst(dst), weight(weight), cost(cost) {}\n};\n\nauto operator<(const Edge &e, const Edge &f) {\n  if (e.weight != f.weight)\n    return e.weight > f.weight;\n  else if (e.src != f.src)\n    return e.src < f.src;\n  else\n    return e.dst < f.dst;\n}\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nint main() {\n  int n, m, c;\n  while (cin >> n >> m >> c, n) {\n    vector<vector<int>> flag(n, vector<int>(m, 1e9));\n    Graph g(n);\n    for (int i = 0; i < m; ++i) {\n      int f, t, cc;\n      cin >> f >> t >> cc;\n      g[f - 1].emplace_back(f - 1, t - 1, cc);\n    }\n    deque<Edge> q;\n    for (q.emplace_back(-2, 0, 0, 0); !q.empty();) {\n      Edge e = q.front();\n      // cout << e.src << endl;\n      if (e.dst == n - 1) {\n        cout << e.cost << endl;\n        goto BREAK;\n      }\n      q.pop_front();\n      for (auto ge : g[e.dst]) {\n        if (flag[ge.dst][e.cost + 1] > e.weight)\n          q.emplace_back(ge.src, ge.dst, e.weight, e.cost + 1);\n        if (ge.weight + e.weight > c) continue;\n        if (flag[ge.dst][e.cost] > ge.weight + e.weight)\n          q.emplace_front(ge.src, ge.dst, ge.weight + e.weight, e.cost);\n      }\n    }\n    cout << \"impossible\" << endl;\n  BREAK:;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int inf=40000500;\n\nint n,m,tot,s;\nint first[1000];\nint p[1000],a[1000],num[1000],di[1000],d[1000];\nvector<int> po;\n\nstruct edge\n{\n   int from;\n   int to;\n   int w;\n   int next;\n   int r;\n   bool flag;\n} e[60000];\nint cnt;\n\nvoid add(int x,int y,int w)\n{\n     e[cnt].from=x;\n     e[cnt].to=y;\n     e[cnt].w=w;\n     e[cnt].flag=0;\n     e[cnt].next=first[x];\n     first[x]=cnt;\n     e[cnt].r=cnt+1;\n     cnt++;\n\n     e[cnt].from=y;\n     e[cnt].to=x;\n     e[cnt].w=w;\n     e[cnt].flag=1;\n     e[cnt].next=first[y];\n     first[y]=cnt;\n     e[cnt].r=cnt-1;\n     cnt++;\n}\n\nint sap()\n{\n\n    int all=n;\n\n    int maxflow=0;\n    memset(d,0,sizeof(d));\n    memset(num,0,sizeof(num));\n    memset(a,0,sizeof(a));\n    for(int i=1;i<=all;i++)\n       di[i]=first[i];\n\n    num[0]=all;\n    int cur=s;\n    while(d[s]<all)\n    {\n        int next;\n        bool flag=false;\n        for(int i=di[cur];i!=-1;i=e[i].next)\n          if(e[i].w>0&&d[cur]==d[e[i].to]+1)\n          {\n              next=i;\n              flag=true;\n              break;\n          }\n\n        if(flag)\n        {\n            int tnode=e[next].to;\n            a[tnode]=e[next].w;\n            if(cur!=s&&a[cur]<a[tnode]) a[tnode]=a[cur];\n            p[tnode]=next;\n            cur=tnode;\n\n            if(cur==tot)\n            {\n               maxflow+=a[cur];\n               for(int u=cur;u!=s;u=e[p[u]].from)\n               {\n                  e[p[u]].w-=a[cur];\n                  e[e[p[u]].r].w+=a[cur];\n               }\n               memset(a,0,sizeof(a));\n               cur=s;\n            }\n        }\n        else\n        {\n            int up=all+2,pos=first[cur];\n            for(int i=first[cur];i!=-1;i=e[i].next)\n               if(e[i].w>0&&d[e[i].to]+1<up)\n               {\n                  up=d[e[i].to]+1;\n                  pos=i;\n               }\n\n            num[d[cur]]--;\n            if(num[d[cur]]==0) break;\n            d[cur]=up;\n            num[d[cur]]++;\n            di[cur]=pos;\n\n            if(cur!=s) cur=e[p[cur]].from;\n        }\n    }\n\n    return maxflow;\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n\t\t\t  memset(first,-1,sizeof(first));\n\t\t\t  cnt=0;\n\t\t\t  \n\t\t\t  for(int i=0;i<m;i++)\n\t\t\t  {\n \t\t\t\t   int x,y;\n \t\t\t\t   scanf(\"%d%d\",&x,&y);\n \t\t\t\t   add(x,y,1);\n\t\t\t  }\n\t\t\t  \n\t\t\t  scanf(\"%d%d\",&s,&tot);\n\t\t\t\t\n\t\t\t\tint ans=sap();\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t\t\n\t\t\t\tpo.clear();\n\t\t\t\tfor(int i=0;i<cnt;i++)\n\t               if(e[i].w==2) {po.push_back(i/2+1);}\n        printf(\"%d\\n\",po.size());\n        for(int i=0;i<po.size();i++)\n          printf(\"%d\\n\",po[i]);\n\t\t\t\t\t \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 305\nusing namespace std;\ntypedef pair<int,int> P;\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,cap,G[from].size()-1});\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nmap<P,int> A;\n\nint main(){\n  int n,m,a,b,s,t;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    add_edge(a,b,1);\n    A[P(a,b)]=i;\n  }\n  cin>>s>>t;\n  s--,t--;\n  int ans=max_flow(s,t);\n  vector<int> ans2;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++){\n      int from=i,to=G[i][j].to;\n      if(A.count(P(from,to))&&G[i][j].cap==2)\n\tans2.push_back(A[P(from,to)]);\n    }\n  cout<<ans<<endl;\n  sort(ans2.begin(),ans2.end());\n  cout<<ans2.size()<<endl;\n  for(int i=0;i<ans2.size();i++)cout<<ans2[i]+1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nstruct EdgeEx{\n  int to, cap, rev;\n  EdgeEx(int to_=0, int cap_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), rev(rev_){}\n};\n\n\n// Ford-Fulkerson\n// O(FE) where F := max flow of graph\nvector< vector<EdgeEx> > G; // (V, E)\nvector<bool> used; // sizeof V\n\n// add edge with (from -> to, capacity)\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back(EdgeEx(to, cap, G[to].size()));\n  G[to].push_back(EdgeEx(from, 0, G[from].size()-1));\n}\n\n// find increase path\nint max_flow_dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();++i){\n\tEdgeEx& e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t  int d = max_flow_dfs(e.to, t, min(f, e.cap));\n\t  if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t  }\n\t}\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  const int V = G.size();\n  int flow = 0;\n  used.assign(V, false);\n  while(true){\n\tfill(used.begin(), used.end(), false);\n\tint f = max_flow_dfs(s, t, INF);\n\tif(f == 0) return flow;\n\tflow += f;\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  G.assign(N, vector<EdgeEx>());\n  vector<PII> es(M);\n  int tab[310][310];\n  fill((int*)tab, (int*)tab+310*310, 0);\n  REP(i,M){\n\tint a, b; cin >> a >> b;\n\t--a, --b;\n\tes[i].first = a, es[i].second = b;\n\tadd_edge(a, b, 1);\n\ttab[a][b] = i+1;\n\tadd_edge(b, a, 1);\n\ttab[b][a] = -i-1;\n  }\n  int S, T; cin >> S >> T;\n  --S, --T;\n  int ans = max_flow(S,T);\n  VI xs;\n  REP(i,N){\n\tREP(j, SZ(G[i])){\n\t  int to = G[i][j].to;\n\t  if(G[i][j].cap == 0 && tab[i][to] < 0)\n\t\txs.PB(-tab[i][to]);\n\t}\n  }\n\n  SORT(xs);\n  xs.erase(unique(ALL(xs)), xs.end());\n  cout << ans << endl << SZ(xs) << endl;\n  for(int x: xs) cout << x << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  xioumu\n * Created Time:  2012/10/8 14:10:09\n * File Name: E.cpp\n * solve: E.cpp\n */\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define sz(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr(x) memset(x,0,sizeof(x))\n#define clrs( x , y ) memset(x,y,sizeof(x))\n#define out(x) printf(#x\" %d\\n\", x)\ntypedef long long lint;\nconst int maxint = -1u>>1;\nconst double esp = 1e-8;\n#define inf 1000000 \n#define maxn 400 \n#define maxm 2000000\nint e[maxn][maxn] ;\nint n , m , ans , S , T ;\nint dui[maxm] ;\nint d[maxn] ;\nbool bj[maxn] ;\nint x[2000],y[2000];\nvector<int> ret ;\nint dfs( int t , int v ) {\n    if ( t == T || v == 0 ) return v ;\n    int ans = 0 , flow ;\n    for ( int i = 1 ; i <= n ; i ++ ) {\n        if ( e[t][i] > 0 && d[i] == d[t] + 1 ) {\n            flow = dfs( i , min( v , e[t][i] ) ) ;\n            e[t][i] -= flow ; e[i][t] += flow ;\n            v -= flow ; ans += flow ;\n            if ( v == 0 ) break ;\n        }\n    }\n    return ans ;\n}\nbool bfs( int s ) {\n    int head , last , x ;\n    clr(d) ; clr(bj) ;\n    d[s] = 1 ; head = 0 ; last = 1 ; dui[last] = s ; bj[s] = true ;\n    while ( head < last ) {\n         x = dui[++head] ; \n         for ( int i = 1 ; i <= n ; i ++ ) \n             if ( ! bj[i] && e[x][i] > 0 ) {\n                bj[i] = true ;\n                d[i] = d[x] + 1 ;\n                dui[++last] = i ;\n             }\n    }\n    return bj[T] ;\n}\nvoid clrr(){\n    ans = 0 ; clr(e) ; ret.clear() ;\n}\nint main(){\n    while ( scanf(\"%d%d\" , &n , &m ) == 2 ) {\n        clrr() ;\n        //cout<<n<<m<<endl;\n        repf( i , 1 , m ) {\n            scanf(\"%d%d\" , &x[i] , &y[i] ) ;\n            if ( e[x[i]][y[i]] == 1 ) while ( 1 ) ;\n            e[x[i]][y[i]] = e[y[i]][x[i]] = 1 ;\n        }\n        //repf( i , 1 , n ) {\n            //repf( j , 1 , n ) \n                //cout<<e[i][j]<<\" \";\n            //cout<<endl;\n        //}\n        scanf(\"%d%d\" , &S , &T ) ;\n        while ( bfs( S ) ) \n            ans += dfs( S , inf ) ;\n        //cout<<\"------------------------------------------------\"<<endl;\n        printf(\"%d\\n\" , ans ) ;\n        repf( i , 1 , m ) \n            if ( e[y[i]][x[i]] == 0 && e[x[i]][y[i]] == 2 ) \n                ret.push_back(i) ;\n        printf(\"%d\\n\" , ret.size() ) ;\n        if ( ret.size() != 0 ) {\n            rep( i , ret.size() - 1 ) \n                printf(\"%d\\n\" , ret[i] ) ;\n            printf(\"%d\\n\" , ret[ret.size()-1]);\n        }\n        //cout<<\"-------------------------------------------------\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n// @author Navi\n// Maxflow Sap algorithm\n\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 305;\nconst int MAXM = 2005;\nconst int INF = 0x3f3f3f3f;\n\nstruct Sap {\n#define RE(i) ((((i) - P) ^ 1) + P)\n\tstruct Edge {\n\t\tint v, c, i;\n\t\tEdge* next;\n\t\tEdge(int v = 0, int c = 0, int i = 0, Edge* next = NULL) : v(v), c(c), i(i), next(next) {}\n\t};\n\n\tint n, S, T, maxflow, psize, len;\n\tint c[MAXN];\n\tint d[MAXN];\n\tint path[MAXN];\n\tEdge* curr[MAXN];\n\tEdge P[MAXM * 2];\n\tEdge* e[MAXN];\n\n\tvoid bfs() {\n\t\tqueue <int> q;\n\t\tfill(d, d + n, n);\n\t\tfill(c, c + n, 0);\n\t\tq.push(T);\n\t\td[T] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tint top = q.front();\n\t\t\tq.pop();\n\t\t\t++c[d[top]];\n\t\t\tfor (Edge* i = e[top]; i != NULL; i = i->next) {\n\t\t\t\tif (d[i->v] == n) {\n\t\t\t\t\td[i->v] = d[top] + 1;\n\t\t\t\t\tq.push(i->v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow(int _S, int _T) {\n\t\tn = max(n, max(S = _S, T = _T)) + 1;\n\t\tbfs();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcurr[i] = e[i];\n\t\t}\n\t\tpath[maxflow = len = 0] = S;\n\t\twhile (d[S] != n) {\n\t\t\tint u = path[len];\n\t\t\tif (u == T) {\n\t\t\t\tint minf = INF;\n\t\t\t\tint last = -1;\n\t\t\t\tfor (int i = 0; i < len; ++i) {\n\t\t\t\t\tif (curr[path[i]]->c < minf) {\n\t\t\t\t\t\tminf = curr[path[i]]->c;\n\t\t\t\t\t\tlast = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < len; ++i) {\n\t\t\t\t\tcurr[path[i]]->c -= minf;\n\t\t\t\t\tRE(curr[path[i]])->c += minf;\n\t\t\t\t}\n\t\t\t\tlen = last;\n\t\t\t\tmaxflow += minf;\n\t\t\t} else {\n\t\t\t\tfor (; curr[u] != NULL && (d[curr[u]->v] != d[u] - 1 || curr[u]->c == 0); curr[u] = curr[u]->next);\n\t\t\t\tif (curr[u] == NULL) {\n\t\t\t\t\tif (--c[d[u]] == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\td[u] = n;\n\t\t\t\t\t\tfor (Edge* i = e[u]; i != NULL; i = i->next) {\n\t\t\t\t\t\t\tif (d[i->v] + 1 < d[u] && i->c != 0) {\n\t\t\t\t\t\t\t\td[u] = d[i->v] + 1;\n\t\t\t\t\t\t\t\tcurr[u] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++c[d[u]];\n\t\t\t\t\t\t(u != S) && (len--);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpath[++len] = curr[u]->v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxflow;\n\t}\n\n\tvoid init() {\n\t\tn = psize = 0;\n\t\tmemset(e, 0, sizeof(e));\n\t}\n\n\tvoid addUEdge(int u, int v, int i) {\n\t\tP[psize] = Edge(v, 1, i, e[u]);\n\t\te[u] = &P[psize++];\n\t\tP[psize] = Edge(u, 1, i, e[v]);\n\t\te[v] = &P[psize++];\n\t\tn = max(n, max(u, v));\n\t}\n\n\tvoid gao() {\n\t\tvector <int> ans;\n\t\tfor (int i = 0; i < psize; i += 2) {\n\t\t\tif (P[i].c == 2) {\n\t\t\t\tans.push_back(P[i].i);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", (int)ans.size());\n\t\tfor (vector <int>::const_iterator i = ans.begin(); i != ans.end(); ++i) {\n\t\t\tprintf(\"%d\\n\", *i);\n\t\t}\n\t}\n} sap;\n\nint main() {\n\tint n, m, u, v, S, T;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tsap.addUEdge(u, v, i + 1);\n\t}\n\tscanf(\"%d%d\", &S, &T);\n\tprintf(\"%d\\n\", sap.flow(S, T));\n\tsap.gao();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nclass Flow {\npublic:\n    struct edge {\n        int to, cap, rev;\n    };\n    vector<vector<edge>> G;\n    vector<bool> used;\n\n    //0 ~ maxSize-1 のフローを構築できるようにする\n    explicit Flow(unsigned maxSize) {\n        G.resize(maxSize, vector<edge>());\n        used.resize(maxSize, false);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n//        G[to].push_back((edge) {from, 0, (int) G[from].size() - 1});\n        G[to].push_back((edge) {from, cap, (int) G[from].size() - 1});\n    }\n\n    //増加パスを探す\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t) {\n        int flow = 0;\n        for (;;) {\n            rep(i, 0, used.size())used[i] = false;\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n};\n\nclass Solve {\npublic:\n    void solve() {\n        Int N, M;\n        Int S, T;\n        cin >> N >> M;\n        struct edge {\n            int to, id;\n        };\n//        vector<vector<edge>> G(N);\n        map<pair<int, int>, int> mp;\n        Flow flow(N);\n\n        for (int i = 0; i < M; ++i) {\n            int a, b;\n            cin >> a >> b;\n            a--, b--;\n            mp[make_pair(a, b)] = i;\n//            G[a].push_back(edge({b, i});\n            flow.add_edge(a, b, 1);\n        }\n\n        cin >> S >> T;\n        S--, T--;\n\n        Int max_flow = flow.max_flow(S, T);\n        vector<pair<int, int>> flowed_edge;\n        for (int i = 0; i < flow.G.size(); ++i) {\n            for (auto e : flow.G[i]) {\n                if (e.cap == 0) {\n                    flowed_edge.emplace_back(i, e.to);\n                }\n            }\n        }\n\n        set<int> reversed_edge;\n        for (auto e : flowed_edge) {\n            if (mp.count(e)) {\n            } else {\n                auto re = make_pair(e.second, e.first);\n                int tmp = mp[re];\n                reversed_edge.insert(tmp);\n            }\n        }\n\n        cout << max_flow << endl;\n        cout << reversed_edge.size() << endl;\n        for (auto e : reversed_edge) {\n            cout << e + 1 << endl;\n        }\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nclass Flow{\n\tstruct edge{\n\t\tint to, rev, cap;\n\t\tedge(){}\n\t\tedge(int to, int rev, int cap) :to(to), rev(rev), cap(cap){}\n\t};\n\tvector<int> used, level, iter;\n\tint V;\n\tstatic const int INF = 1 << 30;\npublic:\n\tvector<vector<edge> > Graph;\n\tFlow(int size) :V(size){\n\t\tGraph.resize(V);\n\t\titer.resize(V, 0);\n\t\tlevel.resize(V);\n\t\tused.resize(V, 0);\n\t}\n\tint add(int from, int to, int cap){\n\t\tGraph[from].push_back(edge(to, Graph[to].size(), cap));\n\t\tGraph[to].push_back(edge(from, Graph[from].size() - 1, 0));\n\t\treturn Graph[from].size() - 1;\n\t}\n\n\t/* ford_fulkerson */\n\tint dfs(int s, int t, int f){\n\t\tif (s == t) return f;\n\t\tused[s] = 1;\n\t\tfor (int i = 0; i < Graph[s].size(); i++){\n\t\t\tedge &e = Graph[s][i];\n\t\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\t\tint res = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (res > 0){\n\t\t\t\te.cap -= res;\n\t\t\t\tGraph[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint ford_fulkerson(int s, int t){\n\t\tint res = 0;\n\t\twhile (1){\n\t\t\tfill(used.begin(), used.end(), 0);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (!f) break;\n\t\t\tres += f;\n\t\t}\n\t\treturn res;\n\t}\n\n\t/* Dinic */\n\tvoid dinic_bfs(int s){\n\t\tfill(level.begin(), level.end(), -1);\n\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tlevel[s] = 0;\n\t\twhile (!q.empty()){\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < Graph[v].size(); i++){\n\t\t\t\tedge &e = Graph[v][i];\n\t\t\t\tif (e.cap <= 0 || level[e.to] >= 0) continue;\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\tint dinic_dfs(int s, int t, int f){\n\t\tif (s == t) return f;\n\t\tfor (int &i = iter[s]; i < Graph[s].size(); i++){\n\t\t\tedge &e = Graph[s][i];\n\t\t\tif (e.cap <= 0 || level[e.to] <= level[s]) continue;\n\t\t\tint res = dinic_dfs(e.to, t, min(f, e.cap));\n\t\t\tif (res > 0){\n\t\t\t\te.cap -= res;\n\t\t\t\tGraph[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dinic(int s, int t){\n\t\tint res = 0;\n\t\twhile (1){\n\t\t\tdinic_bfs(s);\n\t\t\tif (level[t] < 0) break;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile (f = dinic_dfs(s, t, INF)){\n\t\t\t\tres += f;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint max_flow(int s, int t, bool DINIC = true){\n\t\tif (DINIC) return dinic(s, t);\n\t\treturn ford_fulkerson(s, t);\n\t}\n};\n\nconst int M = 1010;\nint from[M], idx[M];\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tFlow f(n);\n\n\trep(i, m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tf.add(a, b, 1);\n\t\tfrom[i] = b;\n\t\tidx[i] = f.add(b, a, 1);\n\t}\n\n\tint s, t;\n\tcin >> s >> t;\n\n\tint ans = f.max_flow(s - 1, t - 1);\n\n\tvector<int> rev;\n\trep(i, m){\n\t\tif (f.Graph[from[i]][idx[i]].cap == 0) rev.push_back(i + 1);\n\t}\n\tcout << ans << endl;\n\tcout << rev.size() << endl;\n\tif (rev.size()){\n\t\tfor (auto e : rev){\n\t\t\tcout << e << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev, ID;\n\tbool is_rev;\n\tedge(int t, int c, int r, int id, bool i):to(t), cap(c), rev(r), ID(id), is_rev(i){}\n};\n\nconstexpr int INF = (1 << 29);\nvector<vector<edge>> G;\nvector<int> level;\nvector<int> iter;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n\tlevel.resize(V);\n\titer.resize(V);\n}\n\nvoid add_edge(int from, int to, int ID) {\n\tG[from].emplace_back(to, 1, G[to].size(), ID, false);\n\tG[to].emplace_back(from, 1, G[from].size() - 1, ID, true);\n}\n\nvoid bfs(int s) {\n\tfill(level.begin(), level.end(), -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t) return f;\n\tfor(int &i = iter[v]; i < static_cast<int>(G[v].size()); ++i) {\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tconst int d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile(true) {\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tfill(iter.begin(), iter.end(), 0);\n\t\tfor(int f; (f = dfs(s, t, INF)) > 0; flow += f) ;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tinit(n);\n\tfor(int i = 1; i <= m; ++i) {\n\t\tint from, to;\n\t\tcin >> from >> to;\n\t\t--from; --to;\n\t\tadd_edge(from, to, i);\n\t}\n\n\tint S, T;\n\tcin >> S >> T;\n\tconst int ans = max_flow(S - 1, T - 1);\n\n\tset<int> reverse_edges;\n\tfor(const auto &edges : G) {\n\t\tfor(const auto &e : edges) {\n\t\t\tif(e.cap == 0 && e.is_rev) reverse_edges.insert(e.ID);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\tcout << reverse_edges.size() << endl;\n\tfor(const auto &ID : reverse_edges) {\n\t\tcout << ID << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 300;\nconst int inf = (1<<20);\nint cap[N][N];\nbool vis[N];\nint parent[N];\nint flow[N][N];\nint layer[N];\n\nbool edge[N][N];\nint num[N][N];\n\nvoid make_layer(int n,int s,int t){\n  queue<int> Q;\n  Q.push(s);\n  layer[s]=0;\n  while(!Q.empty()){\n    int now = Q.front();Q.pop();\n    rep(i,n){\n      if (cap[now][i]-flow[now][i] > 0 && layer[i] == -1){\n        layer[i]=layer[now]+1;\n        Q.push(i);\n      }\n    }\n  }\n}\n\n\nint augment(int now,int t,int n,int f){\n  if (now == t || f == 0)return f;\n  if (vis[now])return 0;\n  vis[now]=true;\n  rep(i,n){\n    if (layer[now] < layer[i]){\n      int tmp = augment(i,t,n,min(f,cap[now][i]-flow[now][i]));\n      if (tmp > 0){\n        flow[now][i]+=tmp;\n        flow[i][now]=-flow[now][i];\n        vis[now]=true;\n        return tmp;\n      }\n    }\n  }\n  return 0;\n}\n\nint dinic(int n,int s,int t){\n  int ansflow=0;\n  bool flag=true;\n  rep(i,n)rep(j,n)flow[i][j]=0;\n  while(flag){\n    fill(layer,layer+n,-1);\n    fill(vis,vis+n,false);\n    flag=false;\n    //make layer\n    make_layer(n,s,t);\n    if (layer[t] == -1)break;\n    for(int f=1;f;flag=true){\n      f=augment(s,t,n,inf);\n      if (f==0)break;\n      ansflow+=f;\n    }\n  }\n  return ansflow;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m){\n    rep(i,n)rep(j,n)edge[i][j]=false,cap[i][j]=0;\n    rep(i,m){\n      int f,t;\n      cin>>f>>t;\n      f--;t--;\n      cap[f][t]=1;\n      cap[t][f]=1;\n      edge[f][t]=1;\n      num[f][t]=i+1;\n      num[t][f]=i+1;\n    }\n    int s,t;\n    cin>>s>>t;s--;t--;\n    int ans=dinic(n,s,t);\n    /*\n    rep(i,n){\n      rep(j,n)cout << flow[i][j] << \" \";\n      cout << endl;\n    }\n    */\n    cout << ans << endl;\n    int cnt=0;\n    rep(i,n)rep(j,n)if (!edge[i][j] && flow[i][j] > 0)cnt++;\n    cout << cnt << endl;\n    rep(i,n)rep(j,n)if (!edge[i][j] && flow[i][j] > 0)cout << num[i][j] << endl;\n#ifdef DEBUG\n    cout << \"end \" << endl;\n#endif\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n#define N 310\n#define M 1010\nstruct E\n{\n\tint x,y;\n}tt[M];\nint pre[N];\nvector<int> edge[N];\nint ans=0,st,en,vis[N],t[N][N];\nvoid dfs(int x)\n{\n\tif(x==en)\n\t{\n\t\tans++;\n\t\tfor(int i=en;i!=st;i=pre[i])\n\t\t{\n\t\t\tt[pre[i]][i]=1;\n\t\t}\n\t\treturn ;\n\t}\t\n\tfor(int i=0;i<edge[x].size();i++)\n\t{\n\t\tint u=edge[x][i];\t\t\n\t\tif(!vis[u])\n\t\t{\n\t\t\tvis[u]=1;\n\t\t\tpre[u]=x;\n\t\t\tdfs(u);\n\t\t\tvis[u]=0;\n\t\t}\n\t}\n}\nint main(void)\n{\n\tint n,m,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ttt[i].x=x;\n\t\ttt[i].y=y;\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tscanf(\"%d%d\",&st,&en);\n\tvis[st]=1;\n\tmemset(t,0,sizeof(t));\n\tdfs(st);\n\tint sum=0;\n\tprintf(\"%d\\n\",ans);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(t[tt[i].x][tt[i].y]==0)\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\t\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(t[tt[i].x][tt[i].y]==0)\n\t\t{\n\t\t\tprintf(\"%d\\n\",i);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct FordFulkerson{\n    struct Edge {\n        int to,cap,rev;\n        Edge(int to=0,int cap=0,int rev=0) :\n            to(to),cap(cap),rev(rev){}\n    };\n\n    int V;\n    vector<vector<Edge> > G;\n    vector<bool> used;\n\n    FordFulkerson(int V) : V(V) {\n        G.resize(V);\n        used.assign(V,false);\n    }\n\n    void add_edge(int from,int to,int cap) {\n        G[from].pb(Edge(to,cap,G[to].size()));\n        G[to].pb(Edge(from,0,G[from].size()-1));\n    }\n\n    int dfs(int v,int t,int f) {\n        if(v==t) return f;\n        used[v]=true;\n        for(int i=0;i<G[v].size();i++) {\n            Edge &e=G[v][i];\n\n            if(!used[e.to] && e.cap>0) {\n                int d=dfs(e.to,t,min(f,e.cap));\n                if(d>0) {\n                    e.cap-=d;\n                    G[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s,int t) {\n        int flow=0;\n        while(1) {\n            used.assign(V,false);\n            int f=dfs(s,t,INF);\n            if(f==0) break;\n            flow+=f;\n        }\n\n        return flow;\n    }\n    void dump() {\n        rep(i,V) {\n            printf(\"%d size=%d\\n\",i,G[i].size());\n            rep(j,G[i].size()) {\n                Edge e=G[i][j];\n                printf(\" %d->%d cap:%d rev=%d\\n\",i,e.to,e.cap,e.rev);\n            }\n        }\n    }\n    int get_cap(int v,int u) {\n        rep(i,G[v].size()) if(G[v][i].to==u) return G[v][i].cap;\n        return -INF;\n    }\n};\nint n,m;\nint s,t;\nint main() {\n    cin>>n>>m;\n    FordFulkerson ff(n);\n    map<P,int> in;\n    rep(i,m) {\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        ff.add_edge(x,y,1);\n        ff.add_edge(y,x,1);\n        in[P(x,y)]=i+1;\n    }\n    cin>>s>>t;\n    s--,t--;\n    cout<<ff.max_flow(s,t)<<endl;\n    vector<int> ans;\n\n    for(auto e : in) {\n        if(ff.get_cap(e.fr.fr,e.fr.sc)>0) ans.pb(e.sc);\n    }\n\n    cout<<ans.size()<<endl;\n    rep(i,ans.size()) cout<<ans[i]<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int to, cap, rev; };\nint V, E, S, T, c[309][309]; vector<int> used; vector<vector<edge> > G;\nvoid add_edge(int v1, int v2, int cap) {\n\tG[v1].push_back(edge{ v2, cap, (int)G[v2].size() });\n\tG[v2].push_back(edge{ v1, 0, (int)G[v1].size() - 1 });\n}\nint rec(int p, int t, int f) {\n\tif (p == t) return f;\n\tused[p] = 1;\n\tfor (auto &e : G[p]) {\n\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\tint res = rec(e.to, t, min(e.cap, f));\n\t\tif (res) {\n\t\t\tc[p][e.to] += res;\n\t\t\te.cap -= res, G[e.to][e.rev].cap += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint ret = 0;\n\twhile (true) {\n\t\tused = vector<int>(V, 0);\n\t\tint res = rec(s, t, 2147483647);\n\t\tif (!res) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> V >> E; G.resize(V);\n\tvector<int> x1(E), x2(E);\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x1[i] >> x2[i]; x1[i]--, x2[i]--;\n\t\tadd_edge(x1[i], x2[i], 1);\n\t\tadd_edge(x2[i], x1[i], 1);\n\t}\n\tcin >> S >> T; S--, T--;\n\tcout << max_flow(S, T) << endl;\n\tint ret = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) ret++;\n\t}\n\tcout << ret << endl;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!c[x1[i]][x2[i]]) cout << i + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Edge{\npublic:\n\tint to, cap, rev, num;\n\tEdge(){};\n\tEdge(int to0, int cap0, int num0){to = to0; cap = cap0; num = num0;}\n\tEdge(int to0, int cap0, int rev0, int num0){to = to0; cap = cap0; rev = rev0; num = num0;}\n};\n\nint main()\n{\n\tstatic vector<vector<Edge> > edges;\n\tstatic vector<bool> used;\n\n\tclass Func{\n\tpublic:\n\t\tstatic int dfs(int s, int t, int f){\n\t\t\tif(s == t)\n\t\t\t\treturn f;\n\t\t\tused[s] = true;\n\t\t\tfor(unsigned i=0; i<edges[s].size(); ++i){\n\t\t\t\tEdge& e = edges[s][i];\n\t\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\t\tint g = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(g > 0){\n\t\t\t\t\t\te.cap -= g;\n\t\t\t\t\t\tedges[e.to][e.rev].cap += g;\n\t\t\t\t\t\treturn g;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t};\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tedges.assign(n, vector<Edge>());\n\tfor(int i=0; i<m; ++i){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a;\n\t\t--b;\n\t\tedges[a].push_back(Edge(b, 1, edges[b].size(), -1));\n\t\tedges[b].push_back(Edge(a, 1, edges[a].size()-1, i+1));\n\t}\n\n\tint s, t;\n\tcin >> s >> t;\n\t--s;\n\t--t;\n\n\tint flow = 0;\n\tfor(;;){\n\t\tused.assign(n ,false);\n\t\tint f= Func::dfs(s, t, INT_MAX);\n\t\tif(f == 0)\n\t\t\tbreak;\n\t\tflow += f;\n\t}\n\n\tvector<int> a;\n\tfor(int i=0; i<n; ++i){\n\t\tfor(unsigned j=0; j<edges[i].size(); ++j){\n\t\t\tif(edges[i][j].num != -1 && edges[i][j].cap == 0)\n\t\t\t\ta.push_back(edges[i][j].num);\n\t\t}\n\t}\n\tint num = a.size();\n\n\tcout << flow << endl;\n\tcout << num << endl;\n\tfor(int i=0; i<num; ++i)\n\t\tcout << a[i] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n    int rIdx;\n};\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ツ督ケツつェツつキツづづ可個按津ィツつウツづェツづつ「ツづゥツつゥツづつ、ツつゥ\nbool decided[10001];\nbool isRevEdge[10001];\n\nvoid add_edge(int from,int to,int cap,int idx){\n\tedge e;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n    e.rIdx=idx;\n\tG[from].push_back(e);\n\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n// ツ堕敖嘉パツスツづーツ探ツ催オ\nint dfs(int v,int t,int f){\n\tif(v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n        // ツ新ツつオツつ「ツ督ケツつゥツづつ、ツつゥ\n        bool ok=false;\n        if(!decided[e.rIdx]){\n            ok=true;\n            decided[e.rIdx]=true;\n            // ツ逆ツ古シツつォツづ可猟ャツつオツづつィツつュ\n            if(e.cap==0){\n                isRevEdge[e.rIdx]=true;\n                G[e.to][e.rev].cap=0;\n                e.cap=1;\n            }\n        }\n        if(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n            else{\n                if(ok){\n                    decided[e.rIdx]=false;\n                    if(isRevEdge[e.rIdx]){\n                        G[e.to][e.rev].cap=1;\n                        e.cap=0;\n                    }\n                }\n            }\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n    fill(isRevEdge,isRevEdge+10001,false);\n    fill(decided,decided+10001,false);\n\twhile(1){\n\t\tfill(used,used+MAX_V,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++){\n        int from,to;\n        cin>>from>>to;\n        add_edge(from,to,1,i);\n    }\n    int s,t;\n    cin>>s>>t;\n    int res=max_flow(s,t);\n    cout<<res<<endl;\n    set<int> ss;\n    for(int i = 0; i < m; i++)\n        if(isRevEdge[i])\n            ss.insert(i);\n    cout<<ss.size()<<endl;\n    for(set<int>::iterator it = ss.begin();it!=ss.end();it++)\n        cout<<(*it+1)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstruct edge{\n\tint s,f,c,r;\n} e[2000];\nint n,m,top,sp,fp,vis[1000];\nvector <int> g[300];\nint DFS(int v){\n\tif (v==fp) return 1;\n\tint sz=g[v].size();\n\tvis[v]=1;\n\tfor (int i=0;i<sz;i++){\n\t\tedge ed=e[g[v][i]];\n\t\tif (ed.s==v){\n\t\t\tint u=ed.f;\n                \tif (vis[u]||ed.c==0) continue;\n\t\t\tif (DFS(u)){\n\t\t\t\te[g[v][i]].c=0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint u=ed.s;\n                \tif (vis[u]||ed.c==1) continue;\t\t\t\n\t\t\tif (DFS(u)){\n\t\t\t\te[g[v][i]].c=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tvis[v]=0;\n\treturn 0;\n}\nint solve(){\n\tint ans=0;\n\tmemset(vis,0,sizeof(vis));\n\twhile (DFS(sp)){\n\t\tans++;\n\t\tmemset(vis,0,sizeof(vis));\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[top].s=a-1;\n\t\te[top].f=b-1;\n\t\te[top].c=1;\n\t\tg[a-1].push_back(top);\n\t\tg[b-1].push_back(top++);\n\t\te[top].s=b-1;\n\t\te[top].f=a-1;\n\t\te[top].c=1;\n\t\tg[a-1].push_back(top);\n\t\tg[b-1].push_back(top++);\n\t}\n\tscanf(\"%d%d\",&sp,&fp);\n\tsp--;\n\tfp--;\n\tint ans=solve(),tot=0;\n\tfor (int i=0;i<m;i++) if (e[i*2+1].c==0) tot++;\n\tprintf(\"%d\\n%d\\n\",ans,tot);\n\tfor (int i=0;i<m;i++) if (e[i*2+1].c==0) printf(\"%d\\n\",i+1);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\n\nclass Flow{\n\tstruct edge{\n\t\tint to, rev, cap;\n\t\tedge(){}\n\t\tedge(int to, int rev, int cap) :to(to), rev(rev), cap(cap){}\n\t};\n\tvector<int> used, level, iter;\n\tint V;\n\tstatic const int INF = 1 << 30;\npublic:\n\tvector<vector<edge> > Graph;\n\tFlow(int size) :V(size){\n\t\tGraph.resize(V);\n\t\titer.resize(V, 0);\n\t\tlevel.resize(V);\n\t\tused.resize(V, 0);\n\t}\n\tint add(int from, int to, int cap){\n\t\tGraph[from].push_back(edge(to, Graph[to].size(), cap));\n\t\tGraph[to].push_back(edge(from, Graph[from].size() - 1, 0));\n\t\treturn Graph[from].size() - 1;\n\t}\n\n\t/* ford_fulkerson */\n\tint dfs(int s, int t, int f){\n\t\tif (s == t) return f;\n\t\tused[s] = 1;\n\t\tfor (int i = 0; i < Graph[s].size(); i++){\n\t\t\tedge &e = Graph[s][i];\n\t\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\t\tint res = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (res > 0){\n\t\t\t\te.cap -= res;\n\t\t\t\tGraph[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint ford_fulkerson(int s, int t){\n\t\tint res = 0;\n\t\twhile (1){\n\t\t\tfill(used.begin(), used.end(), 0);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (!f) break;\n\t\t\tres += f;\n\t\t}\n\t\treturn res;\n\t}\n\n\t/* Dinic */\n\tvoid dinic_bfs(int s){\n\t\tfill(level.begin(), level.end(), -1);\n\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tlevel[s] = 0;\n\t\twhile (!q.empty()){\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < Graph[v].size(); i++){\n\t\t\t\tedge &e = Graph[v][i];\n\t\t\t\tif (e.cap <= 0 || level[e.to] >= 0) continue;\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\tint dinic_dfs(int s, int t, int f){\n\t\tif (s == t) return f;\n\t\tfor (int &i = iter[s]; i < Graph[s].size(); i++){\n\t\t\tedge &e = Graph[s][i];\n\t\t\tif (e.cap <= 0 || level[e.to] <= level[s]) continue;\n\t\t\tint res = dinic_dfs(e.to, t, min(f, e.cap));\n\t\t\tif (res > 0){\n\t\t\t\te.cap -= res;\n\t\t\t\tGraph[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dinic(int s, int t){\n\t\tint res = 0;\n\t\twhile (1){\n\t\t\tdinic_bfs(s);\n\t\t\tif (level[t] < 0) break;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile (f = dinic_dfs(s, t, INF)){\n\t\t\t\tres += f;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint max_flow(int s, int t, bool DINIC = true){\n\t\tif (DINIC) return dinic(s, t);\n\t\treturn ford_fulkerson(s, t);\n\t}\n};\n\nconst int M = 1010;\nint from[M], idx[M];\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tFlow f(n);\n\n\trep(i, m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tf.add(a, b, 1);\n\t\tfrom[i] = b;\n\t\tidx[i] = f.add(b, a, 1);\n\t}\n\n\tint s, t;\n\tcin >> s >> t;\n\n\tint ans = f.max_flow(s - 1, t - 1);\n\n\tvector<int> rev;\n\trep(i, m){\n\t\tif (f.Graph[from[i]][idx[i]].cap == 0) rev.push_back(i + 1);\n\t}\n\tcout << ans << endl;\n\tcout << rev.size() << endl;\n\tif (rev.size()){\n\t\tfor (auto e : rev){\n\t\t\tcout << e << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cap,rev,num,add;\n\tEdge(){}\n\tEdge(int s, int d, int cp, int r, int n, int a)\n\t\t:src(s),dst(d),cap(cp),rev(r),num(n), add(a)\n\t{}\n};\n\nconst int INF = (1<<28);\n\ntypedef vector<vector<Edge> > Graph;\nGraph graph(300);\n\nint dfs(int p, int T, int mf, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=e.cap;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tgraph[p][i].cap -= f;\n\t\t\tgraph[next][e.rev].cap += f;\n\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\t\t\t\tif(level[e.dst]!=-1) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.dst]=level[n]+1;\n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int d, int c, int n, int a)\n{\n\tgraph[s].push_back(Edge(s,d,c,graph[d].size()  , n, a));\n\tgraph[d].push_back(Edge(d,s,0,graph[s].size()-1, n, 0)); \n}\n\nint main()\n{\n\tint N,M,S,T;\n\tcin >> N >> M;\n\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tadd_edge(s-1, t-1, 1, i, 0);\n\t\tadd_edge(t-1, s-1, 1, i, 1);\n\t}\n\n\tcin >> S >> T;\n\tcout << dinic(S-1,T-1) << endl;\n\n\tvector<int> res;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<graph[i].size(); j++)\n\t{\n\t\tif(graph[i][j].add == 1 && graph[i][j].cap == 0)\n\t\t\tres.push_back(graph[i][j].num);\n\t}\n\n\tcout << res.size() << endl;\n\t//sort(res.begin(), res.end());\n\tfor(int i=0; i<res.size(); i++)\n\t\tcout << res[i] + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nconst int MAX_V = 310;\nconst int INF = 1000000000;\n\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nint add_edge(int f, int t, int c){\n\tint r = G[t].size();\n\tG[f].push_back((edge){t, c, r});\n\tG[t].push_back((edge){f, 0, G[f].size() - 1});\n\treturn r;\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t){ return f; }\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); ++i){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tfill(used, used + MAX_V, false);\n\t\tint f = dfs(s, t, INF);\n\t\tif(f == 0){ return flow; }\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint n, m, s, t;\n\tscanf(\"%d%d\", &n, &m);\n\tvector<int> x(m + 1), y(m + 1), r(m + 1);\n\tfor(int i = 1; i <= m; ++i){\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tadd_edge(x[i], y[i], 1);\n\t\tr[i] = add_edge(y[i], x[i], 1);\n\t}\n\tscanf(\"%d%d\", &s, &t);\n\tint f = max_flow(s, t);\n\tvector<int> ans;\n\tfor(int i = 1; i <= m; ++i){\n\t\tif(G[x[i]][r[i]].cap > 0){\n\t\t\tans.push_back(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, ans.size());\n\tfor(int i = 0; i < ans.size(); ++i){\n\t\tprintf(\"%d\\n\", ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAXV = 300;\nconst int MAXE = MAXV * MAXV;\nconst int MAXF = (1<<29);\ntypedef int F;\n\nstruct MaxFlow {\n    F cap[MAXE], flow[MAXE];\n    int V, E, level[MAXV], prev[MAXE], edge[MAXV], to[MAXE];\n    MaxFlow(int n) : E(0), V(n) {}\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) {\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e])\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n        }\n    }\n    int augment(int s, int t, F f) {\n        if (s == t || f == 0) return f;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f, cap[e] - flow[e]));\n                if (g > 0) {\n                    flow[e] += g, flow[e^1] -= g;\n                    return g;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int f, ret = 0;\n        for (bool cont = true; cont; ) {\n            cont = false;\n            make_level(s);\n            while ((f = augment(s, t, MAXF)) > 0) {\n                cont = true;\n                ret += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int x[MAXE], y[MAXE];\n    int N,M,a,b;\n    cin>>N>>M;\n    MaxFlow mf(N);\n    for (int i=0; i<M; ++i) {\n        cin>>a>>b; a--, b--;\n        mf.add_edge(a, b, 1, 1);\n        x[i] = a, y[i] = b;\n    }\n    cin>>a>>b; a--, b--;\n    cout<<mf.max_flow(a, b)<<endl;\n    vector<int> rev;\n    for (int i=0; i<M; ++i) {\n        int e = mf.edge[y[i]];\n        while(e != -1) {\n            if (mf.to[e] == x[i] && mf.flow[e] > 0) rev.push_back(i);\n            e = mf.prev[e];\n        }\n    }\n    cout<<rev.size()<<endl;\n    for (int i=0; i<rev.size(); ++i) cout<<rev[i]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src,dst,cap,rev,num,add;\n\tEdge(){}\n\tEdge(int s, int d, int cp, int r, int n, int a)\n\t\t:src(s),dst(d),cap(cp),rev(r),num(n), add(a)\n\t{}\n};\n\nconst int INF = (1<<28);\n\ntypedef vector<vector<Edge> > Graph;\n\nint dfs(int p, int T, int mf, Graph& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return mf;\n\tif(finished[p]) return 0;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].size(); i++)\n\t{\n\t\tEdge &e = graph[p][i];\n\t\tint next=e.dst, fw=e.cap;\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(fw <=0 ) continue;\n\t\n\t\tint f=dfs(next, T, min(mf, fw), graph, level, finished);\n\t\tif(f>0)\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tgraph[p][i].cap -= f;\n\t\t\tgraph[next][e.rev].cap += f;\n\n\t\t\treturn f;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint dinic(int S, int T, Graph& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].size(); i++)\n\t\t\t{\n\t\t\t\tEdge &e = graph[n][i];\n\t\t\t\tif(level[e.dst]!=-1) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.dst]=level[n]+1;\n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(1)\n\t\t{\n\t\t\tint fw=dfs(S, T, INF, graph, level, finished);\n\t\t\tif(fw<=0) break;\n\t\t\t\n\t\t\ttotal+=fw;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nvoid add_edge(int s, int d, int c, int f, int n, int a, Graph& g)\n{\n\tg[s].push_back(Edge(s,d,f,g[d].size()  , n, a));\n\tg[d].push_back(Edge(d,s,0,g[s].size()-1, n, 0)); \n}\n\nvoid solve()\n{\n\tint N,M,S,T;\n\tcin >> N >> M;\n\n\tGraph g(N);\n\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tadd_edge(s-1, t-1, 0, 1, i, 0, g);\n\t\tadd_edge(t-1, s-1, 1, 1, i, 1, g);\n\t}\n\n\tcin >> S >> T;\n\tcout << dinic(S-1,T-1,g) << endl;\n\n\tvector<int> res;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<g[i].size(); j++)\n\t{\n\t\tif(g[i][j].add == 1 && g[i][j].cap == 0)\n\t\t\tres.push_back(g[i][j].num);\n\t}\n\n\tcout << res.size() << endl;\n\tsort(res.begin(), res.end());\n\tfor(int i=0; i<res.size(); i++)\n\t\tcout << res[i] + 1 << endl;\n\n}\n\nint main()\n{\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int N = 320; //max size of vertex\nconst int inf = 1<<29;\n\nint cap[N][N],flow[N][N];\nint level[N];\nbool finished[N];\nint n;\n\ninline int residue(int s,int t) { return cap[s][t] - flow[s][t]; }\n\nvoid makeLevel(int s) {\n    memset(level, -1, sizeof(level));\n    level[s] = 0;\n    queue<int> Q; Q.push(s);\n    while(!Q.empty()) {\n        int here = Q.front(); Q.pop();\n        for(int there=0; there<n; ++there) {\n            if(level[there] < 0 && residue(here,there) > 0) {\n                level[there] = level[here]+1;\n                Q.push(there);\n            }\n        }\n    }\n}\n\nint augment(int here,int curf,int t) {\n    if(here == t || curf == 0) return curf;\n    if(finished[here] != 0) return 0;\n    finished[here] = 1;\n    for(int there=0; there<n; ++there) {\n        if(level[there] > level[here]) {\n            int f = augment(there, min(curf, residue(here, there)), t);\n            if(f > 0) {\n                flow[here][there] += f;\n                flow[there][here] -= f;\n                finished[here] = false;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint Dinic(int s,int t) {\n    memset(flow, 0, sizeof(flow));\n    int ret = 0;\n    for(bool cont = true; cont; ) {\n        cont = false;\n        makeLevel(s);\n        memset(finished, 0, sizeof(finished));\n        for(int f; (f = augment(s, inf, t)) > 0; cont = true)\n            ret += f;\n    }\n    return ret;\n}\n\nint main() {\n    int m,a,b,s,t;\n    cin>>n>>m;\n    vector<pair<int,int> > e;\n\n    for(int i=0; i<m; ++i) {\n        cin>>a>>b;\n        a--,b--;\n        cap[a][b] = cap[b][a] = 1;\n        e.push_back(make_pair(a,b));\n    }\n    cin>>s>>t;\n    s--,t--;\n\n    int f = Dinic(s,t);\n    cout<<f<<endl;\n    vector<int> reversed;\n    for(int i=0; i<m; ++i)\n        if(flow[e[i].second][e[i].first] > 0) \n            reversed.push_back(i+1);\n\n    cout<<reversed.size()<<endl;\n    for(int i=0; i<reversed.size(); ++i)\n        cout<<reversed[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <set>\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev;\n    int rIdx;\n};\n\nconst int MAX_V = 500;\nconst int INF = 100000000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n// ツ督ケツつェツつキツづづ可個按津ィツつウツづェツづつ「ツづゥツつゥツづつ、ツつゥ\nbool decided[10001];\nbool isRevEdge[10001];\n\nvoid add_edge(int from,int to,int cap,int idx){\n\tedge e;\n\te.to = to;\n\te.cap = cap;\n\te.rev = G[to].size();\n    e.rIdx=idx;\n\tG[from].push_back(e);\n\n\te.to = from;\n\te.cap = 0;\n\te.rev = G[from].size()-1;\n\tG[to].push_back(e);\n}\n// ツ堕敖嘉パツスツづーツ探ツ催オ\nint dfs(int v,int t,int f){\n\tif(v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n        // ツ新ツつオツつ「ツ督ケツつゥツづつ、ツつゥ\n        if(!decided[e.rIdx]){\n            decided[e.rIdx]=true;\n            // ツ逆ツ古シツつォツづ可猟ャツつオツづつィツつュ\n            if(e.cap==0){\n                isRevEdge[e.rIdx]=true;\n                G[e.to][e.rev].cap=0;\n                e.cap=1;\n            }\n        }\n        if(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n            else{\n                decided[e.rIdx]=false;\n                if(isRevEdge[e.rIdx]){\n                    G[e.to][e.rev].cap=1;\n                    e.cap=0;\n                }\n            }\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n    fill(isRevEdge,isRevEdge+10001,false);\n    fill(decided,decided+10001,false);\n\twhile(1){\n\t\tfill(used,used+MAX_V,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f==0)\n\t\t\treturn flow;\n\t\telse\n\t\t\tflow+=f;\n\t}\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++){\n        int from,to;\n        cin>>from>>to;\n        add_edge(from,to,1,i);\n    }\n    int s,t;\n    cin>>s>>t;\n    int res=max_flow(s,t);\n    cout<<res<<endl;\n    set<int> ss;\n    for(int i = 0; i < m; i++)\n        if(isRevEdge[i])\n            ss.insert(i);\n    cout<<ss.size()<<endl;\n    for(set<int>::iterator it = ss.begin();it!=ss.end();it++)\n        cout<<(*it+1)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].emplace_back(t, 1, (int)G[t].size(), id, 0);\n    G[t].emplace_back(f, 1, (int)G[f].size()-1, id, 1);\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G.size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nclass Edge{\npublic:\n    int to, cap, rev;\n    Edge(int _to, int _cap, int _rev): to(_to), cap(_cap), rev(_rev){};\n};\n\nclass FordFulkerson{\npublic:\n    vector<vector<Edge>> G;\n    vector<bool> used;\n    \n    FordFulkerson(int n){\n        G.resize(n);\n        used.resize(n);\n    }\n    \n    void add_edge(int from, int to, int cap){\n        G[from].push_back(Edge(to, cap, G[to].size()));\n        G[to].push_back(Edge(from, 0, G[from].size()-1));\n    }\n    \n    int dfs(int v, int t, int f){\n        if(v == t)\n            return f;\n        used[v] = true;\n        for(int i=0; i<G[v].size(); i++){\n            Edge& e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    int max_flow(int s, int t){\n        int res = 0;\n        while(true){\n            fill(used.begin(), used.end(), false);\n            int f = dfs(s, t, INF);\n            if(f == 0)\n                return res;\n            res += f;\n        }\n        return res;\n    }\n};\n\n\nint N, M, S, T;\n\nint main(){\n    cin >> N >> M;\n    FordFulkerson ff(N);\n    set<pair<int, int>> revs;\n    map<pair<int, int>, int> rtoi;\n    \n    for(int i=0; i<M; i++){\n        int x, y;\n        cin >> x >> y; x--; y--;\n        ff.add_edge(x, y, 1);\n        ff.add_edge(y, x, 1);\n        \n        revs.insert(make_pair(y, x));\n        rtoi[make_pair(y, x)] = i+1;\n    }\n    cin >> S >> T;\n    S--; T--;\n    \n    cout << ff.max_flow(S, T) << endl;\n    \n    set<pair<int, int>> edges;\n    for(int u=0; u<N; u++){\n        for(Edge edge: ff.G[u]){\n            if(edge.cap == 0 && revs.find(make_pair(u, edge.to)) != revs.end()){\n                edges.insert(make_pair(u, edge.to));\n            }\n        }\n    }\n    \n    cout << edges.size() << endl;\n    for(auto p: edges)\n        cout << rtoi[p] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\n#define MAX_V 302\n \nclass Dinic{\npublic:\n  struct edge{ // (行き先, 容量, 逆辺のindex) \n    int to, cap, rev;\n    edge(int to, int cap, int rev):to(to), cap(cap), rev(rev){};\n  };\n  vector< edge > info[MAX_V];\n  int level[MAX_V]; //sからの距離\n  int iter[MAX_V]; //どこまで調べ終わったか\npublic:\n  Dinic(){}\n  int add_edge(int from, int to, int cap){\n    info[from].push_back( edge( to, cap, info[to].size()));\n    info[to].push_back( edge( from, 0, info[from].size() - 1));\n    return info[to].size() - 1;\n  }\n  void bfs(int s){\n    memset( level, -1, sizeof level);\n    queue< int > que;\n    level[s] = 0;\n    que.push( s);\n    while(!que.empty()){\n      int v = que.front(); que.pop();\n      for(int i = 0; i < info[v].size(); i++){\n        edge& e = info[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int& i = iter[v]; i < info[v].size(); i++){\n      edge& e = info[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to, t, min( f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          info[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t){\n    int flow = 0;\n    while(true){\n      bfs(s);\n      if(level[t] < 0) return flow;\n      memset( iter, 0, sizeof iter);\n      int f;\n      while((f = dfs( s, t, INF)) > 0){\n        flow += f;\n      }\n    }\n  }\n};\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  Dinic max_flow;\n  vector< int > mine(M), index(M);\n  for(int i = 0; i < M; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    max_flow.add_edge( u, v, 1);\n\n    mine[i] = u;\n    index[i] = max_flow.add_edge( v, u, 1); //逆辺のやつ\n  }\n  int S, T;\n  cin >> S >> T;\n  --S, --T;\n  int flow = max_flow.max_flow( S, T);\n  vector< int > edge;\n  for(int i = 0; i < M; i++){\n    if(max_flow.info[mine[i]][index[i]].cap > 0){\n      edge.push_back(i + 1);\n    }\n  }\n  cout << flow << endl;\n  cout << edge.size() << endl;\n  cout << edge;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<utility>\n#include<random>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nstruct edge { int to, cap, rev, id; };\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, int cap, int id) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),id });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1,id + 1000 });\n\tswap(from, to);\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),id });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1,id + 1000 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\nint par[1000];\nint c[1000];\nint main() {\n\tint n, m; cin >> n >> m;\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tadd_edge(a, b, 1, i);\n\t\tpar[i] = a;\n\t}\n\tint s, t; cin >> s >> t; s--; t--;\n\tint ans = max_flow(s, t);\n\trep(i, n) {\n\t\trep(j, G[i].size()) {\n\t\t\tint id = G[i][j].id;\n\t\t\tif (G[i][j].id >= 1000)continue;\n\t\t\telse {\n\t\t\t\tif (G[i][j].cap == 1)continue;\n\t\t\t\tif (G[i][j].to == par[id])c[id]++;\n\t\t\t\telse c[id]--;\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tvector<int> v;\n\trep(i, m) {\n\t\tif (c[i] > 0) {\n\t\t\tcnt++; v.push_back(i);\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << cnt << endl;\n\trep(i, cnt) {\n\t\tcout << v[i] + 1 << endl;\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  Teletubbies\n * Created Time:  2012年08月29日 星期三 12&#26102;39分28秒\n * File Name: e.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <time.h>\n#include <cctype>\n#include <functional>\n#include <deque>\n#include <iomanip>\n#include <bitset>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#include <utility>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORD(i,a,b) for (int i=(a); i>=(b); i--)\n#define REP(i,b) FOR(i,0,b)\n#define sf scanf\n#define pf printf\nusing namespace std;\nconst int maxint = -1u>>1;\nconst double pi = 3.14159265358979323;\nconst double eps = 1e-8;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<int>::iterator vit;\n#define maxn 310\n#define maxm 500000\nint eh[maxn], tot, cur[maxn];\nconst int inf = 1 << 30;\nint dist[maxn];\nint s, t;\nint n, m;\n\nstruct Edge {\n    int u, v, cap, flow, next;\n}et[maxm];\n\nvoid init() {\n    tot = 0;\n    memset(eh, -1, sizeof(eh));\n}\n\nvoid add(int u, int v, int cap, int flow) {\n    Edge e = {u, v, cap, flow, eh[u]};\n    et[tot] = e;\n    eh[u] = tot++;\n}\n\nvoid addedge(int u, int v, int cap) {\n    add(u, v, cap, 0), add(v, u, cap, 0);\n}\n    \nbool bfs() {\n    int que[maxn];\n    int head = 0, tail = 0;\n    memset(dist, -1, sizeof(dist));\n    dist[t] = 0;\n    que[tail++] = t;\n    while(head < tail && dist[s] == -1) {\n        int u = que[head++];\n        for(int i = eh[u]; i != -1; i = et[i].next) {\n            int v = et[i].v;\n            if(et[i^1].cap > et[i^1].flow && dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                que[tail++] = v;\n            }\n        }\n    }\n    return dist[s] != -1;\n}\n\nint dfs(int u, int d) {\n    if(u == t) return d;\n    int l = d;\n    //cout << u << \"********\" <<  endl;\n    for(int &i = cur[u]; i != -1; i = et[i].next) {\n        int v = et[i].v;\n        if(et[i].cap > et[i].flow && dist[u] == dist[v] + 1) {\n            //cout << v << \" \" << d << endl;\n            int tmp = dfs(v, min(l, et[i].cap - et[i].flow));\n            //cout << v << \"tmp = \" << tmp << endl;\n            et[i].flow += tmp;\n            et[i^1].flow -= tmp;\n            l -= tmp;\n            if(l == 0) break;\n        }\n    }\n    //cout << d -  l << \"asdfads\" << endl;\n    return d - l;\n}\n\nint Dinic() {\n    int flow = 0;\n    while(bfs()) {\n        //cout << \"dist\" << endl;\n        //for(int i = 1; i <= n; i++) {\n            //cout << dist[i] << endl;\n        //}\n        for(int i = 1; i <= n; i++) cur[i] = eh[i];\n        flow += dfs(s, inf);\n    }\n    return flow;\n}\n\nint main() \n{\n    //freopen(\"in1.txt\", \"r\", stdin);\n    //freopen(\"E.out3\", \"w\", stdout);\n    \n    while(~scanf(\"%d%d\", &n, &m)) {\n        init();\n        int u, v;\n        for(int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &u, &v);\n            addedge(u, v, 1);\n            //cout << u << \" \" << v << endl;\n        }\n        scanf(\"%d%d\", &s, &t);\n        int ans = Dinic();\n        printf(\"%d\\n\", ans);\n        vector<int> vec;\n        vec.clear();\n        //cout << tot << endl;\n        for(int i = 0; i < tot; i += 2) {\n            //cout << et[i].u << \" \" << et[i].v << \" \" << et[i].flow << endl;\n            if(et[i].flow < 0) {\n                vec.pb(i / 2 + 1);\n            }\n        }\n        printf(\"%d\\n\", vec.size());\n        for(int i = 0; i < vec.size(); i++) {\n            printf(\"%d\\n\", vec[i]);\n        }\n        break;\n    }\n    \n    //while(1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_V = 333;\nconst int inf=1<<25;\n\nstruct edge { int id,to,cap,rev; };\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int i,int f,int t,int cap)\n{\n  G[f].push_back((edge){i,t,cap,(int)G[t].size()});\n  G[t].push_back((edge){0,f,0,(int)G[f].size()-1});\n}\n\n void bfs(int s)\n{\n  memset(level,-1,sizeof(level));\n  queue<int> q;\n  level[s] = 0;\n  q.push(s);\n  while( !q.empty() ) {\n    int v = q.front(); q.pop();\n    for( int i = 0; i < int(G[v].size()); i++ ) {\n      edge& e = G[v][i];\n      if( e.cap > 0 && level[e.to] < 0 ) {\n        level[e.to] = level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f)\n{\n  if( v == t ) return f;\n  for( int &i = iter[v]; i < int(G[v].size()); i++ ) {\n    edge& e = G[v][i];\n    if( e.cap > 0 && level[v] < level[e.to] ) {\n      int d  = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;) {\n    bfs(s);\n    if( level[t] < 0 ) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while( (f = dfs(s,t,inf)) > 0 ) {\n      flow += f;\n    }\n  }\n}\n\nint main(void)\n{\n  int n,m,s,t;\n  scanf(\"%d%d\",&n,&m);\n  for( int i = 0; i < m; i++ ) {\n    int a,b; scanf(\"%d%d\",&a,&b); --a; --b;\n    add_edge(0,a,b,1);\n    add_edge(i+1,b,a,1);\n  }\n  scanf(\"%d%d\",&s,&t); --s; --t;\n  int res = max_flow(s,t);\n  printf(\"%d\\n\",res);\n  vector<int> v;\n  for( int i = 0; i < n; i++ ) {\n    for( int j = 0; j < int(G[i].size()); j++ ) {\n      edge& e = G[i][j];\n      if( e.id != 0 ) {\n        if( e.cap == 0 ) v.push_back(e.id);\n      }\n    }\n  }\n  sort(v.begin(),v.end());\n  printf(\"%d\\n\",int(v.size()));\n  for( int i = 0; i < int(v.size()); i++ ) printf(\"%d\\n\",v[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* E.cpp\n*\n*  Created on: Oct 9, 2012\n*      Author: carber\n*/\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int NV = 305;\nconst int NE = 45000;\n\nstruct ISAP {\n    int n, size;\n    int head[NV];\n    int dis[NV], gap[NV], pre[NV], cur[NV];\n    int maxflow;\n\n    struct Edge {\n        int v, w, next;\n        Edge () {}\n        Edge (int V, int NEXT, int W = 0) : v(V), next(NEXT), w(W) { }\n    }E[NE];\n\n    void init(int x) {\n        n = x, size = 0;\n        for (int i = 0; i <= n; i++) {\n            head[i] = -1;\n        }\n    }\n\n    inline void insert(int u, int v, int w = 0) {\n        E[size] = Edge(v, head[u], w);\n        head[u] = size++;\n        E[size] = Edge(u, head[v], w); //豬??蜿榊髄蟒コ霎ケ\n        head[v] = size++;\n    }\n\n    int MaxFlow(int src, int des) {\n        maxflow = 0;\n        gap[0] = n;\n        for (int i = 0; i <= n; i++) {\n            dis[i] = gap[i] = 0;\n        }\n        for (int i = 0; i <= n; i++) {\n            cur[i] = head[i];\n        }\n        int u = pre[src] = src;\n        int aug = -1;\n        while (dis[src] < n) {//扈捺據譚。莉カ1\nloop:\n            for (int &i = cur[u]; i != -1; i = E[i].next) {\n                int v = E[i].v;\n                if (E[i].w && dis[u] == dis[v] + 1) {\n                    aug = min(aug, E[i].w);\n                    pre[v] = u;\n                    u = v;\n                    if (v == des) {//謇セ蛻ー荳?擅蠅槫ケソ霍ッ?梧峩譁ー\n                        maxflow += aug;\n                        // //菫ョ謾ケ谿倶ス咏ス醍サ?                        for (u = pre[u]; v != src; v = u, u = pre[u]) {\n                            E[cur[u]].w -= aug;//豁」蜷題セケ\n                            E[cur[u]^1].w += aug;//蜿榊髄霎ケ\n                        }\n                        aug = INT_MAX;\n                    }//if\n                    goto loop;\n                }//for\n            }//for\n            //蟇サ謇セ譛?ー冗噪霍晉ヲサ譬?捷?悟ケカ菫ョ謾ケ蠖灘燕轤ケ    荳コ譛?ー冗噪譬?捷+1\n            int mdis = n;\n            for (int i = head[u]; i != -1; i = E[i].next) {\n                int v = E[i].v;\n                if (E[i].w && mdis > dis[v]) {\n                    cur[u] = i;\n                    mdis = dis[v];\n                }\n            }//for\n\n            //GAP 莨伜喧 譁ュ螻ょ?霍ウ蜃コ 扈捺據譚。莉カ2\n            if ((--gap[dis[u]]) == 0) {\n                break;\n            }\n            gap[dis[u] = mdis + 1]++;//蟆?凶譛芽ッ・譬?捷逧?焚驥丞刈1\n            u = pre[u];//蠖灘燕闃らせ 霑∫ァサ荳?クェ\n        }//while\n        return maxflow;\n    }//ISAP\n}G;\n\n#include <vector>\nvoid solved(int nT) {\n    int n, m, u, v;\n    while (EOF != scanf(\"%d %d\", &n, &m)) {\n        G.init(n);\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", &u, &v);\n            --u, --v;\n            if (u == v) while (true);\n            G.insert(u, v, 1);\n        }\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        --s, --t;\n        int result = G.MaxFlow(s, t);\n        vector<int> ret;\n        for (int se = 0; se < G.size; se += 2) {\n            if (G.E[se].w == 2) ret.push_back(se >> 1);\n        }\n        printf(\"%d\\n\", result);\n        printf(\"%d\\n\", (int)ret.size());\n        for (int i = 0; i < (int)ret.size(); ++i) {\n            printf(\"%d\\n\", ret[i] + 1);\n        }\n    }\n}\n\nint main() {\n    int T = 1;\n    for (int nT = 1; nT <= T; ++nT) {\n        solved(nT);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  int level[333], iter[333];\n  //vector<int> level, iter;\n  //Dinic(int V):G(V), level(V), iter(V){};\n  Dinic(int V)\n  {\n    G.clear(); G.resize(V);\n  }\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    //fill(level.begin(), level.end(), -1);\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G[i].size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      //fill(iter.begin(), iter.end(), 0);\n      memset(iter, 0, sizeof(iter));\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define DEBUG(a) \"(\" << #a << \": \" << (a) << \")\"\n\ntemplate<typename T>\nvoid chmin(T &x, T y) { x = min(x, y); }\n\ntemplate<typename T>\nvoid chmax(T &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef tuple<int,int,int> P;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[4] = {0, 1, 0, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\ntypedef int Weight;\ntypedef int Flow;\nstruct Edge {\n  int src, dest, rev;\n  Flow cap;\n  Weight cost;\n  bool operator < (const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n  Edge(int s, int d) : src(s), dest(d) { ; }\n  Edge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n  Edge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, Flow cap){\n  g[src].push_back((Edge){src, dest, (int)g[dest].size(), cap, 0});\n  g[dest].push_back((Edge){dest, src, (int)g[src].size()-1, 0, 0});\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f){\n  if(v == t) return f;\n  used[v] = true;\n  for(Edge& e: g[v]){\n    if(!used[e.dest] && e.cap > 0){\n      Flow d = dfs(g, used, e.dest, t, min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        g[e.dest][e.rev].cap += d;\n      return d;\n      }\n    }\n  }\n  return 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t){\n  Flow flow = 0;\n  for(;;){\n    vector<bool> used(g.size(),false);\n    Flow f = dfs(g,used,s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  vector<P> ways;\n  REP(i, M) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    add_edge(G, x, y, 1);\n    add_edge(G, y, x, 1);\n    ways.emplace_back(x, i + 1, G[x].size() - 1);\n  }\n  int S, T;\n  cin >> S >> T;\n  S--, T--;\n  cout << ford_fulkerson(G, S, T) << endl;\n  set<int> ans;\n  for (P way : ways) {\n    int x = get<0>(way), r = get<1>(way),\n        idx = get<2>(way);\n    if (G[x][idx].cap == 1) {\n      ans.insert(r);\n    }\n  }\n  cout << ans.size() << endl;\n  for (int a : ans) {\n    cout << a << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\nconst int INFLL=1001001001001001001ll;\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\n\nstruct Dinic{\n    struct edge{\n        int to,cap,rev,id;\n        edge(int to,int cap,int rev,int id):to(to),cap(cap),rev(rev),id(id){}\n    };\n\n    const int INF=1001001001;\n    vector<vector<edge>>G;\n    vector<int>level,iter;\n    Dinic(int v):G(v),level(v),iter(v){}\n\n    void addEdge(int from,int to,int id){\n        G[from].push_back(edge(to,1,G[to].size(),id));\n        G[to].push_back(edge(from,1,G[from].size()-1,id));\n    }\n\n    void bfs(int s){\n        fill(level.begin(),level.end(),-1);\n        queue<int>que;\n        level[s]=0;\n        que.push(s);\n        while(que.size()){\n            int v=que.front();\n            que.pop();\n            for(auto &e:G[v]){\n                if(e.cap&&level[e.to]==-1){\n                    level[e.to]=level[v]+1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v,int t,int f){\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            edge &e=G[v][i];\n            if(e.cap>0&&level[v]<level[e.to]){\n                int d=dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    G[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int maxFlow(int s,int t){\n        int flow=0;\n        while(true){\n            bfs(s);\n            if(level[t]<0)return flow;\n            fill(iter.begin(),iter.end(),0);\n            int f;\n            while((f=dfs(s,t,INF))>0)flow+=f;\n        }\n    }\n};\n\nsigned main(){\n    int N,M;\n    cin>>N>>M;\n\n    Dinic d(N);\n    vint A(M),B(M);\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        d.addEdge(a,b,i);\n        A[i]=a;B[i]=b;\n    }\n\n\n    int src,snk;\n    cin>>src>>snk;\n    src--;snk--;\n\n    int tmp=d.maxFlow(src,snk);\n    vint lis;\n    rep(i,N){\n        for(auto &e:d.G[i]){\n            if(e.cap==0&&A[e.id]!=i){\n                lis.pb(e.id);\n            }\n        }\n    }\n\n    printf(\"%lld\\n\",tmp);\n    printf(\"%lld\\n\",(int)lis.size());\n    rep(i,lis.size())printf(\"%lld\\n\",lis[i]+1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nstruct MaxFlow {\n    static const int N = 512;\n    int n, flow[N][N], capa[N][N], prev[N];\n    void init(int _n) {\n        n = _n;\n        memset(flow, 0, sizeof(flow));\n        memset(capa, 0, sizeof(capa));\n    }\n    void add_edge(int u, int v, int ca) { capa[u][v] = ca; }\n    int max(int s, int t, int F=1<<30) {\n        int total = 0;\n        while(total < F) {\n            memset(prev, -1, sizeof(prev));\n            queue<int> q;\n            prev[s] = s;\n            q.push(s);\n            while(!q.empty() && prev[t]<0) {\n                const int u = q.front();\n                q.pop();\n                rep(i, n) if(prev[i]<0 && flow[u][i]<capa[u][i]) {\n                    prev[i] = u;\n                    q.push(i);\n                }\n            }\n            if(prev[t]<0) return total;\n            int inc = F-total;\n            for(int j=t; prev[j]!=j; j=prev[j]) {\n                inc = min(inc, capa[prev[j]][j]-flow[prev[j]][j]);\n            }\n            for(int j=t; prev[j]!=j; j=prev[j]) {\n                flow[prev[j]][j] += inc;\n                flow[j][prev[j]] -= inc;\n            }\n            total += inc;\n        }\n    return total;\n    }\n} mf;\n\nint N, M, X[2000], Y[2000], S, T;\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    rep(i, M) scanf(\"%d%d\", X+i, Y+i);\n    rep(i, M) X[i]--, Y[i]--;\n    scanf(\"%d%d\", &S, &T);\n    S--, T--;\n    mf.init(N);\n    rep(i, M) {\n        mf.add_edge(X[i], Y[i], 1);\n        mf.add_edge(Y[i], X[i], 1);\n    }\n    printf(\"%d\\n\", mf.max(S, T));\n    vector<int> ans;\n    rep(i, M) if(mf.flow[X[i]][Y[i]]<0) ans.push_back(i+1);\n    printf(\"%d\\n\", (int)ans.size());\n    rep(i, ans.size()) printf(\"%d\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 310;\n\n// 辺を表す構造体（行き先、容量、逆辺の場所(id)）\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<vector<edge>> G(MAX_V); \nint level[MAX_V]; // sからの距離\nint iter[MAX_V];  // どこまで調べ終わったか\n\n// fromからtoへ向かう容量capの辺をグラフに追加する\nvoid add_edge(int from, int to, int cap){\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)(G[from].size()-1)});\n}\n\n// sからの最短距離を計算する\nvoid bfs(int s){\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n\n    while(que.size()){\n        int v = que.front(); que.pop();\n        for(int i=0; i<G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// 増加パスを探す\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i=iter[v]; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n\n    return 0;\n}\n\n// sからtへの最大流を求める\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        bfs(s);\n        if(level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f = dfs(s, t, 1e9)) > 0){\n            flow += f;\n        }\n    }\n}\n\nint main(){\n    int n, m; cin>>n>>m;\n    vector<vector<int>> allEdge(n, vector<int>(n, -1));\n    for(int i=0; i<m; i++){\n        int x, y; cin>>x>>y;\n        x--, y--;\n        allEdge[x][y] = i + 1;\n        add_edge(x, y, 1);\n        add_edge(y, x, 1);\n    }\n\n    int s, t; cin>>s>>t;\n    s--, t--;\n\n    cout << max_flow(s, t) << endl;\n\n    vector<int> ansEdgeId;\n    for(int i=0; i<n; i++){\n        for(auto j:G[i]){\n            //cout << \"from \" << i << \" to \" << j.to << \" cap \" << j.cap << \" rev \" << j.rev << endl;\n            if(j.cap == 0 && G[j.to][j.rev].cap == 1){\n                if(0 < allEdge[j.to][i]){\n                    ansEdgeId.emplace_back(allEdge[j.to][i]);\n                }\n            }\n        }\n    }\n\n    sort(ansEdgeId.begin(), ansEdgeId.end());\n    ansEdgeId.erase(unique(ansEdgeId.begin(), ansEdgeId.end()), ansEdgeId.end());\n\n    cout << ansEdgeId.size() << endl;\n    for(auto i:ansEdgeId){\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Nmax 1003\nusing namespace std;\n\nint n,s,t,nr,m,x,y,lg;\nint E[2*Nmax],uz[2*Nmax];\nvector<int> rev;\nvector<int> v[Nmax];\n\nint dfs(int nod)\n{\n    if (nod==t)\n    {\n        nr++;\n        return 1;\n    }\n    for (auto it : v[nod])\n    {\n        if (uz[it])\n            continue;\n        if (it%2==1)\n            rev.push_back(it/2+1);\n        uz[it] = uz[it^1] = 1;\n        if (dfs(E[it]))\n            return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n    cin>>n>>m;\n    for (int i=1;i<=m;i++)\n    {\n        cin>>x>>y;\n        E[lg++] = y;\n        v[x].push_back(lg-1);\n        E[lg++] = x;\n        v[y].push_back(lg-1);\n    }\n    cin>>s>>t;\n\n    while(dfs(s));\n\n    cout<<nr<<'\\n';\n    cout<<rev.size()<<'\\n';\n    for (auto it : rev)\n        cout<<it<<'\\n';\n\n    return 0;\n}\n/*\n5 5\n1 2\n2 3\n2 4\n3 4\n3 5\n1 4\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, cap, rev, id;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int INF = 1<<28;\nconst int MAXN = 333;\nint N, M, S, T;\nint C[MAXN][MAXN];\nGraph G;\nbool vis[MAXN];\n\nvoid add_edge(int from, int to, bool bi_dir, int id) {\n  G[from].push_back((Edge){to, 1, G[to].size(), 0});\n  G[to].push_back((Edge){from, 1, G[from].size() - 1, bi_dir ? 0 : id});\n}\n\nint dfs(int v, int dst, int f) {\n  vis[v] = true;\n  if (v == dst) return f;\n  for (int i = 0; i < G[v].size(); ++i) {\n    Edge &e = G[v][i];\n    if (vis[e.v]) continue;\n    if (e.cap == 0) continue;\n    int d = dfs(e.v, dst, min(f, e.cap));\n    if (d) {\n      e.cap -= d;\n      G[e.v][e.rev].cap += d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int f = 0;\n  while (1) {\n    memset(vis, 0, sizeof(vis));\n    int d = dfs(s, t, INF);\n    if (d == 0) return f;\n    f += d;\n  }\n}\n\nint main() {\n  while (cin >> N >> M) {\n    memset(C, 0, sizeof(C));\n    for (int i = 0; i < M; ++i) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      C[x][y] = i + 1;\n    }\n    cin >> S >> T;\n    --S; --T;\n\n    G = Graph(N);\n    for (int i = 0; i < N; ++i) {\n      for (int j = 0; j < N; ++j) {\n        if (C[i][j]) {\n          add_edge(i, j, C[j][i], C[i][j]);\n        }\n      }\n    }\n\n    int res = max_flow(S, T);\n    cout << res << endl;\n    vector<int> ids;\n    for (int v = 0; v < N; ++v) {\n      for (int i = 0; i < G[v].size(); ++i) {\n        const Edge &e = G[v][i];\n        if (e.id > 0 && e.cap == 0) {\n          ids.push_back(e.id);\n        }\n      }\n    }\n    cout << ids.size() << endl;\n    for (int i = 0; i < ids.size(); ++i) {\n      cout << ids[i] << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass Edge{\npublic:\n  int _to;\n  int _capacity;\n  int _reverse;\n  Edge(int to,int capacity,int reverse) :\n    _to(to), _capacity(capacity), _reverse(reverse) {}\n};\n\nclass FordFulkerson {\nprivate:\n  int _n;\n  bool* _used;\n  vector<Edge>* _edges;\n  map<P,int> _id;\npublic:\n  FordFulkerson(int n){\n    _n = n;\n    _used = new bool[n+1]();\n    _edges = new vector<Edge>[n+1];\n  }\n  void set_id(map<P,int> id){\n    _id = id;\n  }\n  \n  void add_edge(int from,int to,int capacity = 1){\n    _edges[from].push_back(Edge(to,capacity,_edges[to].size()));\n    _edges[to].push_back(Edge(from,capacity,_edges[from].size()-1));\n  }\n\n  int dfs(int current,int sink,int flow){\n    if(current == sink) return flow;\n    _used[current] = true;\n    for(int i=0;i<_edges[current].size();i++){\n      int to = _edges[current][i]._to;\n      if(_used[to]) continue;\n\n      int d = dfs(to,sink,min(flow,_edges[current][i]._capacity));\n      if(d <= 0) continue;\n      \n      _edges[current][i]._capacity -= d;\n      _edges[to][_edges[current][i]._reverse]._capacity += d;\n      return d;\n    }\n    \n    return 0;\n  }\n\n  int compute_max_flow(int source,int sink){\n    int res = 0;\n    while(true){\n      int tmp = dfs(source,sink,INF);\n      if(tmp == 0) break;\n      res += tmp;\n    }\n    return res;\n  }\n\n  set<int> compute_reverse(){\n    set<int> res;\n    for(map<P,int>::iterator it = _id.begin(); it != _id.end(); it++){\n      int from = it->first.first;\n      int to = it->first.second;\n      for(int i = 0; i < _edges[from].size();i++){\n              if(to == _edges[from][i]._to){\n          if(_edges[from][i]._capacity > 0){\n            res.insert(it->second);\n          }\n              }\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int num_of_crossings;\n  int num_of_roads;\n  while(~scanf(\"%d %d\",\n               &num_of_crossings,\n               &num_of_roads)){\n    \n    FordFulkerson fordfulkerson(num_of_crossings);\n    map<P,int> id;\n    for(int road_i = 0; road_i < num_of_roads; road_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      fordfulkerson.add_edge(from,to);\n      // fordfulkerson.add_edge(to,from);\n      id[P(from,to)] = id.size();\n    }\n    int source,sink;\n    scanf(\"%d %d\",&source,&sink);\n    cout << fordfulkerson.compute_max_flow(source,sink) << endl;\n    \n    fordfulkerson.set_id(id);\n    set<int> res = fordfulkerson.compute_reverse();\n    cout << res.size() << endl;\n    for(set<int>::iterator it = res.begin(); it != res.end(); it++){\n      cout << *it << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int INF = 1<<30;\n\nstruct EDGE\n{\n    int v,c,next;\n}E[3000];\n\nbool vise[3000];\nint cur[400],pre[400],cnt[400],dis[400];\nint head[400];\nint n,m,S,T,tot,low;\n\nvoid add(int u,int v,int c)\n{\n    E[tot].v=v;\n    E[tot].c=c;\n    E[tot].next=head[u];\n    head[u]=tot++;\n}\n\nvoid addedge(int u,int v,int c)\n{\n    add(u,v,c);\n    add(v,u,c);\n}\n\nvoid rebfs()\n{\n    for(int i=0;i<n;i++)\n        cnt[i]=0,dis[i]=n;\n    queue<int> q;\n    dis[T]=0;\n    cnt[0]=1;\n    q.push(T);\n    while(!q.empty())\n    {\n        int u=q.front();\n        q.pop();\n        for(int e=head[u];e!=-1;e=E[e].next)\n        {\n            if(E[e^1].c==0||dis[E[e].v]<n) continue;\n            dis[E[e].v]=dis[u]+1;\n            cnt[dis[E[e].v]]++;\n            q.push(E[e].v);\n        }\n    }\n}\n\nint ISAP()\n{\n    rebfs();\n    for(int i=0;i<n;i++) cur[i]=head[i];\n    int flow=0,u=S,v,e;\n    low=INF;\n    while(dis[S]<n)\n    {\n        for(e=cur[u];e!=-1;e=E[e].next)\n            if(E[e].c&&dis[u]==dis[v=E[e].v]+1) break;\n        if(e!=-1)\n        {\n            cur[u]=e;\n            pre[v]=e;\n            low=min(low,E[e].c);\n            u=v;\n            if(u==T)\n            {\n                for(;u!=S;u=E[pre[u]^1].v)\n                {\n                    E[pre[u]].c-=low;\n                    E[pre[u]^1].c+=low;\n                }\n                flow+=low;\n                low=INF;\n            }\n        }\n        else\n        {\n            if(--cnt[dis[u]]==0) break;\n            dis[u]=n;\n            cur[u]=head[u];\n            for(e=head[u];e!=-1;e=E[e].next)\n                if(E[e].c>0&&dis[u]>dis[E[e].v]+1)\n                    dis[u]=dis[E[e].v]+1;\n            cnt[dis[u]]++;\n            if(u!=S) u=E[pre[u]^1].v;\n        }\n    }\n    return flow;\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        tot=0;\n        memset(head,-1,sizeof(head));\n        memset(vise,0,sizeof(vise));\n        int u,v;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            addedge(--u,--v,1);\n        }\n        scanf(\"%d%d\",&S,&T);\n        S--;\n        T--;\n        printf(\"%d\\n\",ISAP());\n        int ans=0;\n        for(int i=0;i<tot;i++)\n            if(E[i].c==0&&(i&1)==1)\n                ans++;\n        printf(\"%d\\n\",ans);\n        for(int i=0;i<tot;i++)\n            if(E[i].c==0&&(i&1)==1)\n                printf(\"%d\\n\",i/2+1);\n    }\n    return 0;\n}\n\n/*\n2 1\n2 1\n2 1\n\n2 1\n1 2\n2 1\n\n3 3\n3 2\n1 2\n3 1\n1 3\n\n*/"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <string>\nusing namespace std;\nconst int N = 310;\nint ans[N*N],x[N*N],y[N*N],data[N][N];\nint n,m,map[N][N],path[N],flow[N],s,t,vis[N][N];\nqueue<int> q;\nint bfs()\n{\n\tint u,i;\n\twhile(!q.empty())\tq.pop();\n\tmemset(path,-1,sizeof(path));\n\tq.push(s);\n\tflow[s]=100000;path[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tu=q.front();\n\t\tq.pop();\n\t\tif(u==t) break;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tif(path[i]==-1&&map[u][i]==1)\n\t\t\t{\n\t\t\t\tflow[i]=flow[u]<map[u][i]?flow[u]:map[u][i];\n\t\t\t\tpath[i]=u;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n\tif(path[t]==-1)//\n\t\treturn -1;\n\telse\n\t\treturn flow[t];\n}\nint EK()\n{\n\tint step,max_flow=0,now,pre;\n\twhile((step=bfs())!=-1)\n\t{\n\t\tmax_flow+=step;\n\t\tnow=t;\n\t\twhile(now!=s)\n\t\t{\n\t\t\tpre=path[now];\n\t\t\tmap[pre][now]-=step;\n\t\t\tmap[now][pre]+=step;\n\t\t\tnow=pre;\n\t\t}\n\t}\n\treturn max_flow;\n}\nint main()\n{\n\tint i,u,v;\n\twhile(scanf(\"%d%d\",&n,&m)==2)\n\t{\n\t\tmemset(map,-1,sizeof(map));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(data,0,sizeof(data));\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tx[i]=u;\n\t\t\ty[i]=v;\n\t\t\tdata[u][v]=1;\n\t\t\tmap[u][v]=map[v][u]=1;\n\t\t}\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tprintf(\"%d\\n\",EK());\n\t\tint r=0;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tu=x[i];v=y[i];\n\t\t\tif(map[v][u]==0)\n\t\t\t\tif(data[v][u]^data[u][v])\n\t\t\t\tans[r++]=i;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t\tfor(i=0;i<r;i++)\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define MAX_V 303\n\nstruct edge{ int to, cap, rev, idx; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nint n,m;\n\nvoid add_edge(int from, int to, int cap,int idx){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),idx});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  int s,t;\n  cin>>n>>m;\n  rep(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--; y--;\n    add_edge(x,y,1,i);\n    add_edge(y,x,1,i+m);\n  }\n  cin>>s>>t;\n  s--; t--;\n  cout<<max_flow(s,t)<<endl;\n  vector<int> res;\n  rep(i,n){\n    for(edge e : G[i]){\n      if(e.cap==0&&e.idx>=m){\n        res.push_back(m);\n      }\n    }\n  }\n  sort(all(res));\n  uni(res);\n  cout<<res.size()<<endl;\n  rep(i,res.size())cout<<res[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 300;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    map<Pii, int> mp;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        mp[Pii(a, b)] = i;\n        add_edge(a, b, 1);\n        add_edge(b, a, 1);\n    }\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n\n    int F = max_flow(s, t);\n    int R = 0;\n    set<int> st;\n    rep(i, n) {\n        for (auto e : G[i]) {\n            if (mp.count(Pii(i, e.to)) && e.cap != 0 && G[e.to][e.rev].cap == 0 && !st.count(mp[Pii(i, e.to)])) {\n                R++;\n                st.insert(mp[Pii(i, e.to)]);\n            }\n        }\n    }\n\n    cout << F << endl;\n    cout << R << endl;\n    for (auto i : st) {\n        cout << i + 1 << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<numeric>\n#include<vector>\n#include<ctime>\n#include<queue>\n#include<list>\n#include<map>\n#define pi acos(-1)\n#define INF 0x7fffffff\n#define clr(x)  memset(x,0,sizeof(x));\n#define clrto(x,siz,y)  for(int xx=0;xx<=siz;xx++)  x[xx]=y;\n#define clrset(x,siz)  for(int xx=0;xx<=siz;xx++)  x[xx]=xx;\n#define clrvec(x,siz) for(int xx=0;x<=siz;xx++)  x[xx].clear();\n#define fop   freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n#define myprogram By_135678942570\n#define clrcpy(x,siz,y)  for(int xx=0;xx<siz;xx++)  x[xx]=y[xx];\nusing namespace std;\nint road[303][303]={0};\nint dist[303][303]={0};\nint last[303]={0};\nint n,m;\nint in[303]={0};\nint s,t;\nvoid spfa(int now)\n{\n    int q[76543]={0};\n    int front=0;\n    int rear=0;\n    int vis[303]={0};\n    q[++front]=now;\n    in[now]++;\n    while(front>rear)\n    {\n        int nn=q[++rear];\n        vis[nn]=0;\n        if(nn==t)\n           return;\n        for(int i=1;i<=n;i++)\n        {\n          if(i!=s)\n            if(road[nn][i]||road[i][nn])\n            {\n                if(dist[now][i]<=dist[now][nn]+1)\n                {\n                   dist[now][i]=dist[i][now]=dist[now][nn]+1;\n                   last[i]=nn;\n                   if(!vis[i])\n                   {\n                      vis[i]=1;\n                      q[++front]=i;\n                   }\n                }\n            }\n        }\n    }\n}\n        \nmain()\n{\n   //  fop;\n     scanf(\"%d%d\",&n,&m);\n     memset(last,-1,sizeof(last));\n     for(int i=0;i<m;i++)\n     {\n         int a,b;\n         scanf(\"%d%d\",&a,&b);\n         road[a][b]=i+1;\n     }\n     scanf(\"%d%d\",&s,&t);\n     spfa(s);\n     printf(\"%d\\n\",dist[s][t]);\n     int count=0;\n     int l[100000]={0};\n     while(last[t]!=-1)\n     {\n        int la=last[t];\n        if(!road[la][t])\n           l[count++]=road[t][la];\n        t=la;\n     }\n     printf(\"%d\\n\",count);\n     for(int i=0;i<count;i++)\n        printf(\"%d\\n\",l[i]);\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n #include<cstring>\n #include<queue>\n #include<cmath>\n using namespace std;\n const int Ni = 300;\n const int MAX = 1<<26;\n struct Edge{\n     int u,v,c;\n     int next;\n }edge[4000];\n int n,m;\n int edn;//\\u8fb9\\u6570\n int p[Ni];//\\u7236\\u4eb2\n int d[Ni];\n int sp,tp;//\\u539f\\u70b9\\uff0c\\u6c47\\u70b9\n\n void addedge(int u,int v,int c)\n {\n     edge[edn].u=u; edge[edn].v=v; edge[edn].c=c;\n     edge[edn].next=p[u]; p[u]=edn++;\n\n     edge[edn].u=v; edge[edn].v=u; edge[edn].c=0;\n     edge[edn].next=p[v]; p[v]=edn++;\n }\n int bfs()\n {\n     queue <int> q;\n     memset(d,-1,sizeof(d));\n     d[sp]=0;\n     q.push(sp);\n     while(!q.empty())\n     {\n         int cur=q.front();\n         q.pop();\n         for(int i=p[cur];i!=-1;i=edge[i].next)\n         {\n             int u=edge[i].v;\n             if(d[u]==-1 && edge[i].c>0)\n             {\n                 d[u]=d[cur]+1;\n                 q.push(u);\n             }\n         }\n     }\n     return d[tp] != -1;\n }\n int dfs(int a,int b)\n {\n     int r=0;\n     if(a==tp)return b;\n     for(int i=p[a];i!=-1 && r<b;i=edge[i].next)\n     {\n         int u=edge[i].v;\n         if(edge[i].c>0 && d[u]==d[a]+1)\n         {\n             int x=min(edge[i].c,b-r);\n             x=dfs(u,x);\n             r+=x;\n             edge[i].c-=x;\n             edge[i^1].c+=x;\n         }\n     }\n     if(!r)d[a]=-2;\n     return r;\n }\n\n int dinic(int sp,int tp)\n {\n     int total=0,t;\n     while(bfs())\n     {\n         while(t=dfs(sp,MAX))\n         total+=t;\n     }\n     return total;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tedn=0;\n\tmemset(p,-1,sizeof(p));\n\tfor (int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\taddedge(a-1,b-1,1);\n\t\taddedge(b-1,a-1,1);\n\t}\n\tscanf(\"%d%d\",&sp,&tp);\n\tsp--;\n\ttp--;\n\tint ans=dinic(sp,tp),tot=0;\n\tfor (int i=0;i<m;i++) if (edge[i*4+2].c==0) tot++;\n\tprintf(\"%d\\n%d\\n\",ans,tot);\n\tfor (int i=0;i<m;i++) if (edge[i*4+2].c==0) printf(\"%d\\n\",i+1);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 305;\nconst int inf = 0x3f3f3f3f;\n\nint g[MAXN][MAXN];\nint mat[MAXN][MAXN], flow[MAXN][MAXN];\n\nint max_flow(int n, int source, int sink)\n{\n    int pre[MAXN], que[MAXN], d[MAXN], p, q, t, i, j;\n    if (source == sink)\n        return inf;\n    for (i = 0; i < n; i++)\n        for (j = 0; j < n; flow[i][j++] = 0);\n    for (;;) {\n        for(i = 0; i < n; pre[i++] = 0);\n        pre[t=source] = source + 1, d[t] = inf;\n        for (p = q = 0; p <= q && !pre[sink]; t = que[p++])\n            for (i = 0; i < n; i++)\n                if (!pre[i] && (j = mat[t][i] - flow[t][i]))\n                    pre[que[q++]=i] = t + 1, d[i] = d[t] < j ? d[t] : j;\n                else if (!pre[i] && (j = flow[i][t]))\n                    pre[que[q++]=i] = -t-1, d[i] = d[t] < j ? d[t] : j;\n        if (!pre[sink]) break;\n        for (i = sink; i != source;)\n            if (pre[i] > 0)\n                flow[pre[i]-1][i] += d[sink], i = pre[i] - 1;\n            else\n                flow[i][-pre[i]-1] -= d[sink], i = -pre[i] - 1;\n    }\n    for (j = i = 0; i < n; j += flow[source][i++]);\n    return j;\n}\n\nint main()\n{\n    int n, m, x, y;\n    scanf (\"%d %d\", &n, &m);\n    for (int i = 1; i <= m; i++)\n    {\n        scanf (\"%d %d\", &x, &y);\n        x--, y--;\n        mat[x][y] = mat[y][x] = 1;\n        g[x][y] = i;\n    }\n    scanf (\"%d %d\", &x, &y);\n    x--, y--;\n    printf (\"%d\\n\", max_flow(n, x, y));\n    vector<int> ans;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if(flow[i][j] && !g[i][j])\n                ans.push_back(g[j][i]);\n    printf (\"%d\\n\", ans.size());\n    sort(ans.begin(), ans.end());\n    for (int i = 0; i < ans.size(); i++)\n        printf (\"%d\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1 << 25;\n\nstruct edge\n{\n  int to, cap, rev, id, isrev;\n  edge(){}\n  edge(int to, int cap, int rev, int id, int isrev):to(to), cap(cap), rev(rev), id(id), isrev(isrev){}\n};\n\nstruct Dinic\n{\n  vector< vector<edge> > G;\n  vector<int> level, iter;\n  Dinic(int V):G(V), level(V), iter(V){};\n  void add_edge(int f, int t, int id)\n  {\n    G[f].push_back(edge(t, 1, (int)G[t].size(), id, 0));\n    G[t].push_back(edge(f, 1, (int)G[f].size()-1, id, 1));\n  }\n  void bfs(int s)\n  {\n    fill(level.begin(), level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i = 0; i < (int)G[v].size(); i++) {\n\tedge& e = G[v][i];\n\tif(e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  int dfs(int v, int t, int f)\n  {\n    if(v == t) return f;\n    for(int &i = iter[v]; i < (int)G[v].size(); i++) {\n      edge& e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t)\n  {\n    int flow = 0;\n    while(1) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(iter.begin(), iter.end(), 0);\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n};\n\nint main()\n{\n  int N, M; cin >> N >> M;\n  Dinic dinic(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y; cin >> X >> Y; X--, Y--;\n    dinic.add_edge(X, Y, i);\n  }\n  int S, T; cin >> S >> T; S--, T--;\n  int ans = dinic.max_flow(S, T);\n  vector<int> used_rev;\n  for(int v = 0; v < (int)dinic.G.size(); v++) {\n    for(int i = 0; i < (int)dinic.G[v].size(); i++) {\n      edge e = dinic.G[v][i];\n      if(e.cap < 1 && e.isrev == 1) used_rev.push_back(e.id);\n    }\n  }\n  sort(used_rev.begin(), used_rev.end());\n  cout << ans << endl;\n  cout << (int)used_rev.size() << endl;\n  for(int i = 0; i < (int)used_rev.size(); i++) cout << used_rev[i]+1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define MAX_V 303\n\nstruct edge{ int to, cap, rev, idx; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nint n,m;\n\nvoid add_edge(int from, int to, int cap,int idx){\n  G[from].push_back((edge){to,cap,(int)G[to].size(),idx});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1,-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0; i < G[v].size(); i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  int s,t;\n  cin>>n>>m;\n  rep(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--; y--;\n    add_edge(x,y,1,i);\n    add_edge(y,x,1,i+m);\n  }\n  cin>>s>>t;\n  s--; t--;\n  cout<<max_flow(s,t)<<endl;\n  vector<int> res;\n  rep(i,n){\n    for(edge e : G[i]){\n      if(e.cap==0&&e.idx>=m){\n        res.push_back(e.idx-m+1);\n      }\n    }\n  }\n  sort(all(res));\n  uni(res);\n  cout<<res.size()<<endl;\n  rep(i,res.size())cout<<res[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n// clang-format off\n#pragma GCC optimize \"O3,omit-frame-pointer,inline\"\n#pragma GCC target \"tune=native\"\n#define ARG4(_1, _2, _3, _4, ...) _4\n#define rep(...) ARG4(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define REP(i, a) FOR(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(...) ARG4(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define RREP(i, a) RFOR(i, 0, a)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= (int)(a); --i)\n#define ALL(c) (c).begin(), (c).end()\n#define TEN(n) ((ll)(1e##n))\n#define pb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define USE1(T) template<typename T>inline\n#define USE2(T, U) template<typename T,typename U>inline\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T>using duo=std::pair<T,T>;\ntemplate<typename T>using vec=std::vector<T>;\nusing ll=long long;\nusing pii=duo<int>;\nUSE2(T,U)bool chmax(T&x,U a){return x<a&&(x=a,1);}\nUSE2(T,U)bool chmin(T&x,U a){return a<x&&(x=a,1);}\nUSE1(T=int)T in(){T x;std::cin>>x;return x;}\nUSE1(T=int)vec<T>in(int n){vec<T>v;v.reserve(n);rep(i,n)v.pb(in<T>());return v;}\nUSE1(T=int)vec<T>in(int n,T a){vec<T>v;v.reserve(n);rep(i,n)v.pb(in<T>()+a);return v;}\nUSE1(T)vec<std::pair<T,int>>enume(const vec<T>&x,int s=0){int N=x.size();vec<std::pair<T,int>>v;v.reserve(N);rep(i,N)v.pb(x[i],s+i);return v;}\nUSE1(T)vec<T>ndvec(T v,int n){return vec<T>(n,v);}\nUSE2(T,...Ts)auto ndvec(T v,int n,Ts...ns)->vec<decltype(ndvec(v,ns...))>{return ndvec(ndvec(v,ns...),n);}\nUSE1(T)void pr(T x){std::cout<<x<<'\\n';}\nUSE2(T,...Ts)void pr(T x,Ts...xs){std::cout<<x<<' ';pr(xs...);}\nUSE1(T=int)T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\nUSE1(T=int)void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n// }}}\nstruct IoSetup { // {{{\n  IoSetup() {\n    std::ios::sync_with_stdio(0);\n    std::cin.tie(0);\n    std::cout.precision(10);\n    std::cerr.precision(10);\n  }\n} iosetup; //}}}\n#include <vector>\nnamespace copr {\ntemplate <typename GraphType>\nstruct graph_traits {\n  using value_type = typename GraphType::value_type;\n  using vertex_type = typename value_type::value_type;\n  using edge_type = typename vertex_type::value_type;\n  using path_type = vertex_type;\n};\n} // namespace copr\nnamespace copr {\ntemplate <typename CapacityType>\nstruct ResidualGraph {\n  struct REdge;\n  using REdges = std::vector<REdge>;\n  using RGraph = std::vector<REdges>;\n  using value_type = RGraph;\n  struct REdge {\n    using value_type = CapacityType;\n    value_type cap;\n    int to, rev;\n    const bool is_rev;\n    REdge(int to, value_type cap, int rev, bool is_rev)\n        : to(to), cap(cap), rev(rev), is_rev(is_rev) {}\n  };\n  const int V;\n  RGraph G;\n\n  ResidualGraph(int V) : V(V), G(V) {}\n  inline REdge& rev(const REdge& e) { return G[e.to][e.rev]; }\n  void add_edge(int from, int to, CapacityType cap) {\n    G[from].emplace_back(to, cap, G[to].size(), false);\n    G[to].emplace_back(from, 0, G[from].size() - 1, true);\n  }\n};\n} // namespace copr\n\n#include <algorithm>\n#include <limits>\n#include <queue>\n\nnamespace copr {\ntemplate <typename T>\nstruct Dinic {\n  using graph_type = ResidualGraph<T>;\n  using edge_type = typename graph_traits<graph_type>::edge_type;\n  using capacity_type = typename edge_type::value_type;\n\n  static constexpr auto inf = std::numeric_limits<capacity_type>::max();\n  const int UNREACHABLE = -1;\n\n  graph_type& Gf;\n  std::vector<int> level, iter;\n  Dinic(graph_type& Gf) : Gf(Gf), level(Gf.V), iter(Gf.V) {}\n\n  capacity_type max_flow_value(int s, int t) {\n    capacity_type value = 0;\n    while (labeling(s), level[t] != UNREACHABLE) {\n      std::fill(iter.begin(), iter.end(), 0);\n      capacity_type bf;\n      while (bf = blocking_flow(s, t, inf), bf > 0) {\n        value += bf;\n      }\n    }\n    return value;\n  }\n  bool labeling(int s) {\n    std::fill(level.begin(), level.end(), UNREACHABLE);\n    level[s] = 0;\n    static std::queue<int> Q;\n    Q.push(s);\n    for (; not Q.empty(); Q.pop()) {\n      auto v = Q.front();\n      for (auto& e : Gf.G[v]) {\n        if (level[e.to] != UNREACHABLE) continue;\n        if (e.cap == 0) continue;\n        level[e.to] = level[v] + 1;\n        Q.push(e.to);\n      }\n    }\n    return true;\n  }\n  capacity_type blocking_flow(int v, int t, capacity_type f) {\n    if (v == t) return f;\n    auto& V = Gf.G[v];\n    for (int& i = iter[v]; i < V.size(); ++i) {\n      auto& e = V[i];\n      if (e.cap == 0) continue;\n      if (level[v] >= level[e.to]) continue;\n      auto bf = blocking_flow(e.to, t, std::min(f, e.cap));\n      if (bf > 0) {\n        e.cap -= bf;\n        Gf.rev(e).cap += bf;\n        return bf;\n      }\n    }\n    return 0;\n  }\n};\ntemplate <typename T>\nDinic<T> dinic(ResidualGraph<T>& Gf) {\n  return Dinic<T>(Gf);\n}\n} // namespace copr\nusing namespace std;\nconst int inf = 1001001001;\nconst ll infl = 1001001001001001001ll;\nconst int dd[] = {0, 1, 0, -1, 0};\n\nsigned main() { //\n  int V = in(), E = in();\n  copr::ResidualGraph<int> G(V);\n  int s[1010], t[1010];\n  int r[1010];\n  rep(i, E) {\n    s[i] = in() - 1, t[i] = in() - 1;\n    G.add_edge(s[i], t[i], 1);\n    G.add_edge(t[i], s[i], 1);\n    r[i] = G.G[t[i]].size() - 1;\n  }\n  int src = in() - 1, sink = in() - 1;\n  pr(copr::dinic(G).max_flow_value(src, sink));\n  vec<int> ans;\n  rep(i, E) {\n    if (G.G[t[i]][r[i]].cap == 0) { ans.emplace_back(i + 1); }\n  }\n  pr(ans.size());\n  for (int x : ans)\n    pr(x);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e7;\n\nstruct Edge {\n  int src, dst, cap, flow, id;\n  bool reversed;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint augment(Graph& graph, vector<vector<Edge*>>& rev,\n            vector<int>& level, vector<bool>& finish, int u, int t, int cur) {\n  if (u == t || cur == 0) return cur;\n  if (finish[u]) return 0;\n  finish[u] = true;\n\n  for (Edge& e : graph[u]) {\n    if (level[e.dst] > level[u]) {\n      int f = augment(graph, rev, level, finish, e.dst, t, min(cur, e.cap - e.flow));\n      if (f > 0) {\n        e.flow += f;\n        finish[u] = false;\n        return f;\n      }\n    }\n  }\n\n  for (Edge* e : rev[u]) {\n    if (level[e->dst] > level[u]) {\n      int f = augment(graph, rev, level, finish, e->dst, t, min(cur, e->flow));\n      if (f > 0) {\n        e->flow -= f;\n        finish[u] = false;\n        return f;\n      }\n    }\n  }\n\n  return 0;\n}\n\n// Dinic\nint maxFlow(Graph& graph, int s, int t) {\n  int n = graph.size(), total = 0;\n\n  vector<vector<Edge*>> rev(n);\n  for (int u = 0; u < n; ++u)\n    for (Edge& e : graph[u])\n      rev[e.dst].push_back(&e);\n\n  for (bool cont = true; cont; ) {\n    cont = false;\n\n    vector<int> level(n, -1);\n    level[s] = 0;\n\n    queue<int> Q;\n    Q.push(s);\n\n    for (int d = n; !Q.empty() && level[Q.front()] < d; ) {\n      int u = Q.front(); Q.pop();\n      if (u == t) d = level[u];\n      for (const Edge& e : graph[u]) {\n        if (e.cap - e.flow > 0 && level[e.dst] == -1) {\n          Q.push(e.dst);\n          level[e.dst] = level[u] + 1;\n        }\n      }\n      for (const Edge* e : rev[u]) {\n        if (e->flow > 0 && level[e->dst] == -1) {\n          Q.push(e->dst);\n          level[e->dst] = level[u] + 1;\n        }\n      }\n    }\n\n    vector<bool> finish(n, false);\n    for (;;) {\n      int f = augment(graph, rev, level, finish, s, t, INF);\n      if (f == 0) break;\n      total += f;\n      cont = true;\n    }\n  }\n\n  return total;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while (cin >> N >> M) {\n    Graph graph(N);\n    for (int i = 0; i < M; ++i) {\n      int X, Y; cin >> X >> Y; --X; --Y;\n      graph[X].push_back({X, Y, 1, 0, i, false});\n      graph[Y].push_back({Y, X, 1, 0, i, true});\n    }\n    int S, T; cin >> S >> T; --S; --T;\n    int value = maxFlow(graph, S, T);\n\n    vector<int> answer;\n    for (int u = 0; u < N; ++u)\n      for (const Edge& e : graph[u])\n        if (e.flow > 0 && e.reversed)\n          answer.push_back(e.id + 1);\n    sort(answer.begin(), answer.end());\n\n    cout << value << endl << answer.size() << endl;\n    for (int id : answer)\n      cout << id << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<map<int, pair<int, int>>> E(N);\n  for (int i = 0; i < M; i++){\n    int X, Y;\n    cin >> X >> Y;\n    X--;\n    Y--;\n    E[X][Y] = make_pair(1, i + 1);\n    E[Y][X] = make_pair(1, - (i + 1));\n  }\n  int S, T;\n  cin >> S >> T;\n  S--;\n  T--;\n  int F = 0;\n  while (1){\n    vector<int> prev(N, -1);\n    vector<bool> used(N, false);\n    used[S] = true;\n    queue<int> Q;\n    Q.push(S);\n    while (!Q.empty()){\n      int v = Q.front();\n      Q.pop();\n      for (auto P : E[v]){\n        if (P.second.first > 0){\n          int w = P.first;\n          if (!used[w]){\n            used[w] = true;\n            prev[w] = v;\n            Q.push(w);\n          }\n        }\n      }\n    }\n    if (!used[T]){\n      break;\n    }\n    int v = T;\n    while (v != S){\n      E[prev[v]][v].first--;\n      E[v][prev[v]].first++;\n      v = prev[v];\n    }\n    F++;\n  }\n  set<int> st;\n  for (int i = 0; i < N; i++){\n    for (auto P : E[i]){\n      if (P.second.first == 2 && P.second.second > 0){\n        st.insert(P.second.second);\n      }\n    }\n  }\n  cout << F << endl;\n  int R = st.size();\n  cout << R << endl;\n  for (int id : st){\n    cout << id << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAXV = 300;\nconst int MAXE = MAXV * MAXV;\nconst int MAXF = (1<<29);\ntypedef int F;\n\nstruct MaxFlow {\n    F cap[MAXE], flow[MAXE];\n    int V, E, level[MAXV], edge[MAXV];\n    int prev[MAXE], to[MAXE];\n    MaxFlow(int n) : E(0), V(n) {\n        memset(edge, -1, sizeof(edge));\n    }\n    void add_edge(int s, int t, F f, F g = 0) {\n        flow[E] = 0; cap[E] = f; to[E] = t; prev[E] = edge[s]; edge[s] = E; E++;\n        flow[E] = 0; cap[E] = g; to[E] = s; prev[E] = edge[t]; edge[t] = E; E++;\n    }\n    void make_level(int s) { // make level graph (bfs)\n        memset(level, -1, sizeof(level));\n        queue<int> q; q.push(s); level[s] = 0;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = edge[v]; e != -1; e = prev[e]) {\n                if (cap[e] - flow[e] > 0 && level[to[e]] == -1)\n                    q.push(to[e]), level[to[e]] = level[v]+1;\n            }\n        }\n    }\n    int augment(int s, int t, F f) { // find augment path (dfs)\n        if (s == t || f == 0) return f;\n        for (int e = edge[s]; e != -1; e = prev[e]) {\n            if (level[to[e]] > level[s] && cap[e] - flow[e] > 0) {\n                F g = augment(to[e], t, min(f, cap[e] - flow[e]));\n                if (g > 0) {\n                    flow[e] += g, flow[e^1] -= g;\n                    return g;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int f, ret = 0;\n        for (bool cont = true; cont; ) {\n            cont = false;\n            make_level(s);\n            while ((f = augment(s, t, MAXF)) > 0) {\n                cont = true;\n                ret += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int x[MAXE], y[MAXE];\n    int N,M,a,b;\n    cin>>N>>M;\n    MaxFlow mf(N);\n    for (int i=0; i<M; ++i) {\n        cin>>a>>b; a--, b--;\n        mf.add_edge(a, b, 1, 1);\n        x[i] = a, y[i] = b;\n    }\n    cin>>a>>b; a--, b--;\n    cout<<mf.max_flow(a, b)<<endl;\n    vector<int> rev;\n    for (int i=0; i<M; ++i) {\n        int e = mf.edge[y[i]];\n        while(e != -1) {\n            if (mf.to[e] == x[i] && mf.flow[e] > 0) rev.push_back(i);\n            e = mf.prev[e];\n        }\n    }\n    cout<<rev.size()<<endl;\n    for (int i=0; i<rev.size(); ++i) cout<<rev[i]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nconst int D_MAX_V=400;\nconst int D_v_size=400;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,cap,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nmap<pair<int,int>,int>m;\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tadd_edge(p,q,1);\n\t//\tadd_edge(q,p,1);\n\t\tm[make_pair(q,p)]=i;\n\t}\n\tint s,t;scanf(\"%d%d\",&s,&t);s--;t--;\n\tprintf(\"%d\\n\",max_flow(s,t));\n\tint ret=0;\n\tvector<int>v;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tif(m.count(make_pair(i,D_G[i][j].t))){\n\t\t\t\tif(D_G[i][j].c==0)v.push_back(m[make_pair(i,D_G[i][j].t)]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",v.size());\n\tfor(int i=0;i<v.size();i++){\n\t\tprintf(\"%d\\n\",v[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <cstdlib>\n#include <map>\n#include <memory.h>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst double EPS = 1e-12;\nconst int INF = 1 << 29;\n\nstruct edge{\n  int to;\n  int cap;\n  int rev;\n  int id;\n  edge(){};\n  edge(int to, int cap, int rev, int id){\n    this->to = to;\n    this->cap = cap;\n    this->rev = rev;\n    this->id = id;\n  }\n};\n\nvector<edge> G[400];\nbool used[400];\n\nvoid add_edge(int from, int to, int cap, int id){\n  G[from].push_back(edge(to, cap, G[to].size(), id));\n  G[to].push_back(edge(from, 0, G[from].size() - 1, -1));\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < (int)G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap +=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int res = 0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0) return res;\n    res += f;\n  }\n}\n\nint N, M, x, y;\n\nint main(){\n  int S, T;\n  cin >> N >> M;\n  rep(i, M){\n    cin >> x >> y;\n    add_edge(x, y, 1, i + 1);\n    add_edge(y, x, 1, i + 1 + M);\n  }\n  cin >> S >> T;\n  int cost = max_flow(S, T);\n  vector<int> R;\n  cout << cost << endl;\n  for(int i = 1; i <= N; i++){\n    for(int j = 0; j < (int)G[i].size(); j++){\n      if(G[i][j].id > M && G[i][j].cap == 0) R.push_back(G[i][j].id - M);\n    }\n  }\n  sort(R.begin(), R.end());\n  cout << R.size() << endl;\n  rep(i, (int)R.size()){\n    cout << R[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(i=1;i<=n;i++)\nusing namespace std;\nconst int maxn=400;\nconst int maxm=100000;\nint n,m,size=1,S,T,R;\nint fir[maxn],Next[maxm],End[maxm],dis[maxn],tag[maxm],w[maxm],ot[maxm];\nint mp[400][400];\nqueue<int>que;\nclass zz\n{\npublic:\n \tint x,y;  \n\tzz(int a,int b){x=a,y=b;}   \n};\n\nbool operator <(const zz &one, const zz &other)\n{\n\t\tif(one.x<other.x || (one.x == other.x && one.y<other.y))return 1;\n        return false;\n}\nmap<zz,int>ed;\nvoid addedge(int x,int y,int z)\n{\n\tsize++;\n\tNext[size]=fir[x];\tfir[x]=size;\tEnd[size]=y;\tw[size]=1;\n\tNext[size^1]=fir[y];\tfir[y]=size^1;\tEnd[size^1]=x;\tw[size^1]=0;\n\tsize++;\n}\nbool bfs()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tdis[S]=1;\n\twhile(!que.empty())que.pop();\n\tque.push(S);\n\twhile(!que.empty())\n\t{\n\t\tint top=que.front();\n\t\tque.pop();\n\t\tif(top == T)return 1;\n\t\tfor(int u=fir[top];u;u=Next[u])\n\t\t{\n\t\t\tint en=End[u];\n\t\t\tif(w[u] && dis[en] == -1)\n\t\t\t{\n\t\t\t\tdis[en]=dis[top]+1;\n\t\t\t\tque.push(en);\n\t\t\t}\n\t\t\tif(!w[u] && !tag[u] && dis[en] == -1 && mp[top][en]==-1)\n\t\t\t{\n\t\t\t\tdis[en]=dis[top]+1;\n\t\t\t\tque.push(en);\n\t\t\t\tswap(w[u],w[u^1]);\n\t\t\t\tzz p(en,top);\n\t\t\t\tot[++R]=ed[p];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int now,int maxf)\n{\n\tif(now == T || !maxf)return maxf;\n\n\tint ret=0,f;\n\tfor(int u=fir[now];u;u=Next[u])\n\t{\n\t\tint en=End[u];\n\n\t\tif(!tag[u] && dis[en] ==dis[now]+1 && w[u])\n\t\t{\n\t\t\tf=dfs(en,min(maxf-ret,1));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tw[u]-=1;\n\t\t\t\tw[u^1]+=1;\n\t\t\t\ttag[u]=tag[u^1]=1;\n\t\t\t\tret+=f;\n\t\t\t}\n\t\t}\n\t}\n\tif(!ret) dis[now]=-1;\n\treturn ret;\n}\nint main()\n{\n\tint i,j;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y,1);\n\t\tmp[x][y]=1;\n\t\tmp[y][x]=-1;\n\t\tzz p(x,y);\n\t\ted[p]=i;\n\t}\n\tscanf(\"%d%d\",&S,&T);\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tans+=dfs(S,(1<<30));\n\t}\n\tcout<<ans<<endl<<R<<endl;\n\tsort(ot+1,ot+R+1);\n\trep(i,R)\n\t\tprintf(\"%d\\n\",ot[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef int Flow;\nconst Flow INF = 1<<27;\nstruct Edge {\n    int src,dst;\n    Flow cap;\n    Edge(int s,int d,int c) : src(s), dst(d), cap(c) {}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nFlow edmonds_karp(const Graph &g,int s,int t, vector<vector<Flow> > &flow) {\n    const int n = g.size();\n    vector<vector<Flow> > cap(n, vector<Flow>(n, (Flow)0));\n    for(int i=0; i<n; ++i) for(int j=0; j<n; ++j) flow[i][j] = (Flow)0;\n\n    for(int i=0; i<n; ++i)\n        for(int j=0; j<g[i].size(); ++j)\n            cap[i][g[i][j].dst] = g[i][j].cap;\n\n    queue<int> q;\n    Flow fret = (Flow)0;\n    while(true) {\n        vector<int> prev(n,-1);\n        prev[s] = s;\n        q.push(s);\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for(int i=0; i<g[v].size(); ++i) {\n                int w = g[v][i].dst;\n                if(prev[w] == -1 && cap[v][w]-flow[v][w] > 0) {\n                    q.push(w);\n                    prev[w] = v;\n                }\n            }\n        }\n\n        if(prev[t] == -1) break;\n        Flow fm = INF;\n        for(int j=t; j != prev[j]; j = prev[j])\n            fm = min(fm, cap[prev[j]][j] - flow[prev[j]][j]);\n        fret += fm;\n        for(int j=t; j != prev[j]; j = prev[j])\n            flow[prev[j]][j] += fm, flow[j][prev[j]] -= fm;\n    }\n    return fret;\n}\n\nint main() {\n    int n,m,a,b,s,t;\n    cin>>n>>m;\n    Graph g(n);\n    vector<pair<int,int> > e;\n\n    for(int i=0; i<m; ++i) {\n        cin>>a>>b;\n        a--,b--;\n        g[a].push_back(Edge(a,b,1));\n        g[b].push_back(Edge(b,a,1));\n        e.push_back(make_pair(a,b));\n    }\n    cin>>s>>t;\n    s--,t--;\n    vector<vector<Flow> > flow(n,vector<Flow>(n,0));\n\n    int f = edmonds_karp(g,s,t,flow);\n    cout<<f<<endl;\n    vector<int> reversed;\n    for(int i=0; i<m; ++i)\n        if(flow[e[i].second][e[i].first] > 0) \n            reversed.push_back(i+1);\n\n    cout<<reversed.size()<<endl;\n    for(int i=0; i<reversed.size(); ++i)\n        cout<<reversed[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\ntypedef int Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > 0)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tGraph g(n);\n\tvector<pii> v;\n\tREP(i, m)\n\t{\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tadd_edge(g, s, t, 1);\n\t\tadd_edge(g, t, s, 1);\n\t\tv.emplace_back(s, t);\n\t}\n\tint s, t; cin >> s >> t;\n\ts--; t--;\n\tint ans = ford_fulkerson(g, s, t);\n\tcout << ans << endl;\n\tvi ansv;\n\tREP(i, m)\n\t{\n\t\tint from = v[i].second;\n\t\tREP(j, g[from].size())\n\t\t{\n\t\t\tif (g[from][j].dest != v[i].first) continue;\n\t\t\tif (g[from][j].cap == 0)\n\t\t\t{\n\t\t\t\tansv.push_back(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ansv.size() << endl;\n\tREP(i, ansv.size()) cout << ansv[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<29;\nstruct edge{int to,cap,rev,id;};\nvector<edge> graph[vmax];\nint level[vmax],iter[vmax];\n\nvoid add_edge(int from,int to,int cap,int id){\n\tgraph[from].push_back({to,cap,int(graph[to].size()),id});\n\tgraph[to].push_back({from,0,int(graph[from].size())-1,-id});\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<graph[v].size();i++){\n\t\tedge &e=graph[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d==0) continue;\n\t\t\te.cap-=d;graph[e.to][e.rev].cap+=d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int s,int t){\n\trep(i,vmax) level[i]=-1;\n\tqueue<int> q;\n\tlevel[s]=0,q.push(s);\n\twhile(!q.empty()){\n\t\tint v=q.front();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn level[t]>=0;\n}\n\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(bfs(s,t)){\n\t\trep(i,vmax) iter[i]=0;\n\t\twhile(1){\n\t\t\tint f=dfs(s,t,inf);\n\t\t\tif(f==0) break;\n\t\t\tflow+=f;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint a[1010],b[1010];\nvector<int> ans;\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--,b[i]--;\n\t\tadd_edge(a[i],b[i],1,i+1);\n\t\tadd_edge(b[i],a[i],1,i+1+m);\n\t}\n\tint s,t;\n\tcin >> s >> t;\n\tcout << max_flow(s-1,t-1) << endl;\n\t\n\trep(i,n)for(auto &e:graph[i]){\n\t\tif(e.id<=m) continue;\n\t\tif(e.cap==0) ans.push_back(e.id-m);\n\t}\n\tcout << ans.size() << endl;\n\tsort(begin(ans),end(ans));\n\tfor(auto &it:ans) cout << it << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define maxn 400\n#define inf 1000000000\n\nusing namespace std;\n\nstruct node\n{\n    int st,en;\n}old[maxn*maxn];\n\nint t,n,m,source,sink,ans;\nint c[maxn][maxn];\nint pre[maxn];\nbool vs[maxn];\n\nvoid init()\n{\n    scanf(\"%d%d\",&n,&m);\n    memset(c,0,sizeof(c));\n    memset(old,0,sizeof(old));\n    for(int i=1;i<=m;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        c[a][b]=c[b][a]=1;\n        old[i].st=a;\n        old[i].en=b;\n    }\n    scanf(\"%d%d\",&source,&sink);\n}\n\nint find()\n{\n    memset(vs,0,sizeof(vs));\n    memset(pre,0,sizeof(pre));\n    int zhan[maxn];\n    int head=0,tail=1;\n    zhan[tail]=source; vs[zhan[1]]=true;\n    while(head!=tail)\n    {\n        int now=zhan[++head];\n        for(int i=1;i<=n;i++)\n          if(!vs[i] && c[now][i]>0)\n          {\n              zhan[++tail]=i;\n              vs[i]=true;\n              pre[i]=now;\n              if(i==sink) return 1;\n          }\n    }\n    return 0;\n}\n\nvoid sug()\n{\n    int now=sink , minflow=inf;\n    while(now!=source)\n    {\n        if(c[pre[now]][now]<minflow) minflow=c[pre[now]][now];\n        now=pre[now];\n    }\n    ans+=minflow;\n    now=sink;\n    while(now!=source)\n    {\n        c[pre[now]][now]-=minflow;\n        c[now][pre[now]]+=minflow;\n        now=pre[now];\n    }\n}\n\nint main()\n{\n        init();\n        ans=0;\n        while(find())\n        {\n            sug();\n        }\n        printf(\"%d\\n\",ans);\n        int tot=0;\n        int change[maxn];\n        memset(change,0,sizeof(change));\n        for(int i=1;i<=m;i++)\n        {\n            int st=old[i].st,en=old[i].en;\n            if(c[en][st]==0) change[++tot]=i;\n        }\n        printf(\"%d\\n\",tot);\n        for(int i=1;i<=tot;i++)\n            printf(\"%d\\n\",change[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string.h>\n#include <cmath>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\n\nvector< vector<edge> > G(100);\nint level[100];\nint iter[100];\nint INF = 100000000;\n\nvoid bfs(int s){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  int a, b;\n  map<pair<int,int>,int> mp;\n  for(int i = 0; i < M; ++i){\n    cin >> a >> b;\n    --a;--b;\n    mp[make_pair(a,b)] = i+1;\n    mp[make_pair(b,a)] = -i-1;\n    G[a].push_back((edge){b,1,G[b].size()});\n    G[b].push_back((edge){a,0,G[a].size()-1});\n    G[b].push_back((edge){a,1,G[a].size()});\n    G[a].push_back((edge){b,0,G[b].size()-1});\n  }\n  int s, t;\n  cin >> s >> t;\n  --s;--t;\n  cout <<  max_flow(s,t) << endl;\n  set<int> V;\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < G[i].size(); ++j){\n      edge e = G[i][j];\n      if(e.cap == 0 && mp[make_pair(i,e.to)] < 0){\n        V.insert(abs(mp[make_pair(i,e.to)]));\n      }\n    }\n  }\n  cout << V.size() << endl;\n  for(set<int>::iterator itr = V.begin(); itr != V.end(); ++itr) cout << *itr << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\n\n\nstruct tumiki {\n\tlong long int x;\n\tlong long int y;\n\tlong long int id;\n};\n\nclass Compare {\npublic:\n\tbool operator()(const pair<int,long long  int>&l, const pair<int, long long int >&r) {\n\t\treturn l.second > r.second;\n\t}\n};\n\nstruct island {\n\tint id;\n\tint sink;\n\tvector<pair<int,int> >edges;\n\tisland(int N):edges(N) {\n\n\t}\n};\n\n\n\n\n#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = INT_MAX;\n\ntypedef int Weight;\nstruct Edge {\n\tint id;\n\tbool real;\n\tint src, dst;\n\tWeight weight;\n\tEdge(bool real,int id,int src, int dst, Weight weight) :\n\t\tid(id),real(real),src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\nvector<pair<int, int>>uses;\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &g, int s, int t) {\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tint now = t;\n\t\twhile (prev[now]!=now&&prev[now]!=-1) {\n\t\t\tuses.push_back({ prev[now], now });\n\t\t\tnow = prev[now];\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tGraph g(N);\n\t\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tg[x].push_back(Edge(true,i,x, y, 1));\n\t\tg[y].push_back(Edge(false, i,y, x, 1));\n\t}\n\tint S, T; cin >> S >> T;\n\tS--; T--;\n\tint ans=maximumFlow(g, S, T);\n\n\tvector<int>changes(N, 1);\n\tfor (int i = 0; i < uses.size(); ++i) {\n\t\tfor (int j = 0; j < g[uses[i].first].size(); ++j) {\n\t\t\tif (g[uses[i].first][j].dst == uses[i].second){\n\t\t\t\tif (g[uses[i].first][j].real) {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchanges[g[uses[i].first][j].id]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvector<int>cs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (changes[i] == 0) {\n\t\t\tcs.push_back(i + 1);\n\t\t}\n\t}\n\tcout << ans << endl << cs.size() << endl;\n\tfor (int i = 0; i < cs.size(); ++i) {\n\t\tcout << cs[i] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef int Weight;\nstruct Edge {\n\tint s, d;\n\tWeight w;\n\tEdge(int s, int d, Weight w) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &o)const {\n\t\treturn w != o.w ? w > o.w : s != o.s ? s < o.s : d < o.d;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n#define EACH(it,c) for(auto it=(c).begin();it!=(c).end();it++)\nWeight augment(const Graph &g, const Matrix &capacity, Matrix &flow, const vi &level, vector<bool> &finished, int u, int t, Weight cur) {\n\tif(u == t || cur == 0) {\n\t\treturn cur;\n\t}\n\tif(finished[u]) {\n\t\treturn 0;\n\t}\n\tfinished[u] = true;\n\tEACH(e, g[u]) {\n\t\tif(level[e->d] > level[u]) {\n\t\t\tWeight f = augment(g, capacity, flow, level, finished, e->d, t, min(cur, RESIDUE(u, e->d)));\n\t\t\tif(f > 0) {\n\t\t\t\tflow[u][e->d] += f;\n\t\t\t\tflow[e->d][u] -= f;\n\t\t\t\tfinished[u];\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nWeight maximumFlow(const Graph &g, int s, int t, Matrix &flow) {\n\tint n = g.size();\n\tMatrix capacity(n, Array(n));\n\tREP(u, n) {\n\t\tEACH(e, g[u]) {\n\t\t\tcapacity[e->s][e->d] += e->w;\n\t\t}\n\t}\n\tWeight total = 0;\n\tbool cont = true;\n\twhile(cont) {\n\t\tcont = false;\n\t\tvi level(n, -1);\n\t\tlevel[s] = 0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\tfor(int d = n; !Q.empty() && level[Q.front()] < d; ) {\n\t\t\tint u = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(u == t) {\n\t\t\t\td = level[u];\n\t\t\t}\n\t\t\tEACH(e, g[u]) {\n\t\t\t\tif(RESIDUE(u, e->d) > 0 && level[e->d] == -1) {\n\t\t\t\t\tQ.push(e->d);\n\t\t\t\t\tlevel[e->d] = level[u] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> finished(n);\n\t\tfor(Weight f = 1; f > 0; ) {\n\t\t\tf = augment(g, capacity, flow, level, finished, s, t, INF);\n\t\t\tif(f == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal += f;\n\t\t\tcont = true;\n\t\t}\n\t}\n\treturn total;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvi X(M), Y(M);\n\tGraph o(N, Edges()), c(N, Edges());\n\tREP(i, M) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--;\n\t\tY[i]--;\n\t\to[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[X[i]].push_back(Edge(X[i], Y[i], 1));\n\t\tc[Y[i]].push_back(Edge(Y[i], X[i], 1));\n\t}\n\n\tint S, T;\n\tcin >> S >> T;\n\tS--;\n\tT--;\n\tMatrix flow(N, Array(N, 0));\n\tWeight maxFlow = maximumFlow(c, S, T, flow);\n\tcout << maxFlow << endl;\n\tvi reversedRoads;\n\tREP(i, M) {\n\t\tif(flow[Y[i]][X[i]] > 0) {\n\t\t\treversedRoads.push_back(i+1);\n\t\t}\n\t}\n\tint size = reversedRoads.size();\n\tcout << size << endl;\n\tREP(i, size) {\n\t\tcout << reversedRoads[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2304 Reverse Roads\n// 2018.3.10 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*******************************************/\n/* Dinic's Max Flow Algorithm \n/*******************************************/\n\n#define INF 0x01010101\n#define VMAX 303\ntypedef struct { int to; int cap; int rev; } EDGE;\nEDGE edge[VMAX][VMAX]; int hi[VMAX];\nint V;\t\t\t\t// 頂点数\nint level[VMAX], iter[VMAX];\nint queue[VMAX], qtop;\n\nvoid add_edge(int from, int to, int cap)\n{\n\tint f, t;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = cap, e->rev = t;\n//\te = &edge[to][t], e->to = from, e->cap = 0,   e->rev = f;\n\te = &edge[to][t], e->to = from, e->cap = cap, e->rev = f;\n}\n\nvoid bfs(int s)\n{\n\tint i, v;\n\tEDGE *e;\n\t\n\tmemset(level, -1, V << 2);\n\tlevel[s] = 0;\n\tqueue[0] = s, qtop = 1;\n\twhile (qtop) {\n\t\tv = queue[--qtop];\n\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\te = &edge[v][i];\n\t\t\tif (e->cap > 0 && level[e->to] < 0) {\n\t\t\t\tlevel[e->to] = level[v] + 1;\n\t\t\t\tqueue[qtop++] = e->to;\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dfs(int v, int t, int f)\n{\n\tint *i, d;\n\tEDGE *e;\n\t\n\tif (v == t) return f;\n\tfor (i = &iter[v]; *i < hi[v]; (*i)++) {\n\t\te = &edge[v][*i];\n\t\tif (e->cap > 0 && level[v] < level[e->to]) {\n\t\t\td = dfs(e->to, t, f <= e->cap? f: e->cap);\n\t\t\tif (d > 0) {\n\t\t\t\te->cap -= d;\n\t\t\t\tedge[e->to][e->rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nint maxFlow(int s, int t)\n{\n\tint f, flow = 0;\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) break;\n\t\tmemset(iter, 0, V << 2);\n\t\twhile ((f = dfs(s, t, INF)) > 0) flow += f;\n\t}\n\treturn flow;\n}\n\n/**********************************************/\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c;\n\tc = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nchar dir[303][303]; int id[303][303];\nint  ans[1002], sz;\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint N, M, S, T, i, j;\n\tEDGE *e;\n\n\tN = in(), M = in();\n\t\n\tfor (i = 1; i <= M; i++) {\n\t\tint x = in()-1, y = in()-1;\n\t\tdir[y][x] = 1, id[y][x] = i;\n\t\tadd_edge(x, y, 1);\n\t}\n\tS = in()-1, T = in()-1,\tV = N;\n\n\tprintf(\"%d\\n\", maxFlow(S, T));\n\n\tsz = 0;\n\tfor (i = 0; i < V; i++) for (j = 0; j < hi[i]; j++) {\n\t\te = &edge[i][j];\n\t\tif (e->cap < 1 && dir[i][e->to]) ans[sz++] = id[i][e->to];\n\t}\n\tqsort(ans, sz, sizeof(int), cmp);\n\tprintf(\"%d\\n\", sz);\n\tfor (i = 0; i < sz; i++) printf(\"%d\\n\", ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Reverse Roads\npublic class Main{\n\n\tint[][] cap;\n\tboolean[] used;\n\t\n\tint augumentPath(int v, int t, int f){\n\t\tif(v==t)return f;\n\t\tused[v] = true;\n\t\tfor(int i=0;i<cap[v].length;i++){\n\t\t\tif(cap[v][i]>0 && !used[i]){\n\t\t\t\tint d = augumentPath(i, t, Math.min(f, cap[v][i]));\n\t\t\t\tif(d>0){\n\t\t\t\t\tcap[v][i] -= d;\n\t\t\t\t\tcap[i][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint maxFlow(int s, int t){\n\t\tint flow = 0;\n\t\tint n = cap.length;\n\t\tused = new boolean[n];\n\t\twhile(true){\n\t\t\tArrays.fill(used, false);\n\t\t\tint f = augumentPath(s, t, Integer.MAX_VALUE);\n\t\t\tif(f==0)return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[][] e = new int[m][2];\n\t\tcap = new int[n][n];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from = sc.nextInt()-1;\n\t\t\tint to = sc.nextInt()-1;\n\t\t\te[i][0] = from;\n\t\t\te[i][1] = to;\n\t\t\tcap[from][to] = 1;\n\t\t\tcap[to][from] = 1;\n\t\t}\n\t\tint s = sc.nextInt()-1;\n\t\tint t = sc.nextInt()-1;\n\t\tSystem.out.println(maxFlow(s, t));\n\t\tint r = 0;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(cap[e[i][1]][e[i][0]]==0){\n\t\t\t\tr++;\n\t\t\t\tl.add(i+1);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\tfor(int i:l)System.out.println(i);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \npublic class Main {\n \n        Scanner sc = new Scanner(System.in);\n \n        class E {\n                int from;\n                int to;\n                int flow = 0;\n \n                E(int a, int b) {\n                        from = a;\n                        to = b;\n                }\n        }\n \n        boolean dfs(int s, int t, boolean[] used, LinkedList<E> e) {\n//              int n = used.length;\n//              System.out.println(s);\n                if(s==t){\n                        return true;\n                }\n                        \n                for (E v : e) {\n                        if (v.from == s) {\n                                if (!used[v.to]) {\n                                        if (v.flow == 0) {\n                                                v.flow = 1;\n                                                used[v.to] = true;\n \n                                                if (dfs(v.to, t, used, e)) {\n                                                        return true;\n                                                } else {\n                                                        v.flow = 0;\n                                                }\n                                        }\n                                }\n                        }\n \n                        if (v.to == s) {\n                                if (!used[v.from]) {\n                                        if (v.flow == 1) {\n                                                v.flow = 0;\n                                                used[v.from] = true;\n \n                                                if (dfs(v.from, t, used, e)) {\n                                                        return true;\n                                                } else {\n                                                        v.flow = 1;\n                                                }\n                                        }\n                                }\n                        }\n                }\n                return false;\n        }\n \n        void run() {\n                int n = sc.nextInt();\n                int m = sc.nextInt();\n \n                LinkedList<E> e = new LinkedList<E>();\n \n                for (int i = 0; i < m; i++) {\n                        int u = sc.nextInt() - 1;\n                        int v = sc.nextInt() - 1;\n \n                        e.add(new E(u, v));\n                        e.add(new E(v, u));\n                }\n \n                int s = sc.nextInt() - 1;\n                int t = sc.nextInt() - 1;\n \n                long ans1 = 0;\n \n                for (;;) {\n                        boolean used[] = new boolean[n];\n \n                        if (!dfs(s, t, used, e)) {\n                                break;\n                        }\n                        ;\n                        ans1++;\n                }\n \n                System.out.println(ans1);\n                \n                LinkedList<Integer> as = new LinkedList<Integer>();\n                \n                for(int i =0 ; i < m; i++){\n                        E a = e.poll();\n                        E b = e.poll();\n                        \n                        if(a.flow < b.flow){\n                                as.add(i+1);\n                        }\n                }\n                System.out.println(as.size()\n                                );\n                for(int k : as){\n                        System.out.println(k);\n \n                }\n \n        }\n \n        public static void main(String[] args) {\n                Main m = new Main();\n                m.run();\n        }\n \n}\n "
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\t/*------------Dinic(Max Flow)------------*/\n\tclass Dinic {\n\t\tclass Edge {\n\t\t\tint to, cap;\n\t\t\tint flow = 0;\n\t\t\tEdge rev;\n\t\t\t\n\t\t\tEdge(int to, int cap) {\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cap = cap;\n\t\t\t}\n\t\t\t\n\t\t\tvoid setRevEdge(Edge rev) {\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\t\t\t\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"Edge : \" + to + \" \" + cap + \" \" + flow;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N;\n\t\tint tank;\n\t\tint[] ptr, Q, dist;\n\t\t\n\t\tArrayList<Edge>[] g;\n\t\tArrayList<Edge> revEdgeList;\n\t\t\n\t\tpublic Dinic(int N) {\n\t\t\tthis.N = N;\n\t\t\tg = new ArrayList[N + 2];\n\t\t\tfor (int i = 0; i < N + 2; i++)\n\t\t\t\tg[i] = new ArrayList<Edge>();\n\t\t\t\n\t\t\tptr = new int[N + 2];\n\t\t\tQ = new int[N + 2];\n\t\t\tdist = new int[N + 2];\n\t\t\trevEdgeList = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to, int cap) {\n\t\t\tEdge e1 = new Edge(to, cap);\n\t\t\tEdge e2 = new Edge(from, 0);\n\t\t\te1.setRevEdge(e2);\n\t\t\te2.setRevEdge(e1);\n\t\t\tg[from].add(e1);\n\t\t\tg[to].add(e2);\n\t\t\trevEdgeList.add(e1);\n\t\t}\n\t\t\n\t\tArrayList<Integer> calcNecessaryRevEdges() {\n\t\t\tArrayList<Integer> res = new ArrayList<Integer>();\n\t\t\tfor (int i = 1; i < revEdgeList.size(); i += 2) {\n\t\t\t\tif (revEdgeList.get(i).flow == 1) res.add(i/2 + 1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tboolean dinic_bfs(int src)\t{\n\t\t\tArrays.fill(dist, -1);\n\t\t\tdist[src] = 0;\n\t\t\tint sizeQ = 0;\n\t\t\tQ[sizeQ++] = src;\n\t\t\tfor (int i = 0; i < sizeQ; i++) {\n\t\t\t\tint u = Q[i];\n\t\t\t\tfor (Edge e : g[u]) {\n\t\t\t\t\tif (dist[e.to] < 0 && e.flow < e.cap) {\n\t\t\t\t\t\tdist[e.to] = dist[u] + 1;\n\t\t\t\t\t\tQ[sizeQ++] = e.to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dist[tank] >= 0;\n\t\t}\n\t\t\n\t\tint dinic_dfs(int u, int f) {\n\t\t\tif (u == tank) return f;\n\t\t\tfor ( ; ptr[u] < g[u].size(); ptr[u]++) {\n\t\t\t\tEdge e = g[u].get(ptr[u]);\n\t\t\t\tif (dist[e.to] == dist[u] + 1 && e.flow < e.cap) {\n\t\t\t\t\tint df = dinic_dfs(e.to, Math.min(f, e.cap - e.flow));\n\t\t\t\t\tif (df > 0) {\n\t\t\t\t\t\te.flow += df;\n\t\t\t\t\t\te.rev.flow -= df;\n\t\t\t\t\t\treturn df;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic int getMaxFlow(int src, int tank) {\n\t\t\tthis.tank = tank;\n\t\t\t\n\t\t\tint res = 0;\n\t\t\twhile (dinic_bfs(src)) {\n\t\t\t\tArrays.fill(ptr, 0);\n\t\t\t\twhile (true) {\n\t\t\t\t\tint df = dinic_dfs(src, Integer.MAX_VALUE);\n\t\t\t\t\tif (df == 0) break;\n\t\t\t\t\tres += df;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\t/*-----------------end---------------------*/\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\n\t\tDinic din = new Dinic(n - 2);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdin.addEdge(from, to, 1);\n\t\t\tdin.addEdge(to, from, 1);\n\t\t}\n\t\t\n\t\tint src = in.nextInt() - 1, tank = in.nextInt() - 1;\n\t\tSystem.out.println(din.getMaxFlow(src, tank));\n\t\t\n\t\tArrayList<Integer> list = din.calcNecessaryRevEdges();\n\t\tSystem.out.println(list.size());\n\t\tfor (int id : list)\n\t\t\tSystem.out.println(id);\n\t}\t\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\t/*------------Dinic(Max Flow)------------*/\n\tclass Dinic {\n\t\tclass Edge {\n\t\t\tint to, cap;\n\t\t\tint flow = 0;\n\t\t\tEdge rev;\n\t\t\t\n\t\t\tEdge(int to, int cap) {\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cap = cap;\n\t\t\t}\n\t\t\t\n\t\t\tvoid setRevEdge(Edge rev) {\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\t\t\t\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"Edge : \" + to + \" \" + cap + \" \" + flow;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N;\n\t\tint tank;\n\t\tint[] ptr, Q, dist;\n\t\t\n\t\tArrayList<Edge>[] g;\n\t\tArrayList<Edge> revEdgeList;\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Dinic(int N) {\n\t\t\tthis.N = N;\n\t\t\tg = new ArrayList[N + 2];\n\t\t\tfor (int i = 0; i < N + 2; i++)\n\t\t\t\tg[i] = new ArrayList<Edge>();\n\t\t\t\n\t\t\tptr = new int[N + 2];\n\t\t\tQ = new int[N + 2];\n\t\t\tdist = new int[N + 2];\n\t\t\trevEdgeList = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tpublic void addEdge(int from, int to, int cap) {\n\t\t\tEdge e1 = new Edge(to, cap);\n\t\t\tEdge e2 = new Edge(from, 0);\n\t\t\te1.setRevEdge(e2);\n\t\t\te2.setRevEdge(e1);\n\t\t\tg[from].add(e1);\n\t\t\tg[to].add(e2);\n\t\t\trevEdgeList.add(e1);\n\t\t}\n\t\t\n\t\tArrayList<Integer> calcNecessaryRevEdges() {\n\t\t\tArrayList<Integer> res = new ArrayList<Integer>();\n\t\t\tfor (int i = 1; i < revEdgeList.size(); i += 2) {\n\t\t\t\tif (revEdgeList.get(i).flow == 1) res.add(i/2 + 1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tboolean dinic_bfs(int src)\t{\n\t\t\tArrays.fill(dist, -1);\n\t\t\tdist[src] = 0;\n\t\t\tint sizeQ = 0;\n\t\t\tQ[sizeQ++] = src;\n\t\t\tfor (int i = 0; i < sizeQ; i++) {\n\t\t\t\tint u = Q[i];\n\t\t\t\tfor (Edge e : g[u]) {\n\t\t\t\t\tif (dist[e.to] < 0 && e.flow < e.cap) {\n\t\t\t\t\t\tdist[e.to] = dist[u] + 1;\n\t\t\t\t\t\tQ[sizeQ++] = e.to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dist[tank] >= 0;\n\t\t}\n\t\t\n\t\tint dinic_dfs(int u, int f) {\n\t\t\tif (u == tank) return f;\n\t\t\tfor ( ; ptr[u] < g[u].size(); ptr[u]++) {\n\t\t\t\tEdge e = g[u].get(ptr[u]);\n\t\t\t\tif (dist[e.to] == dist[u] + 1 && e.flow < e.cap) {\n\t\t\t\t\tint df = dinic_dfs(e.to, Math.min(f, e.cap - e.flow));\n\t\t\t\t\tif (df > 0) {\n\t\t\t\t\t\te.flow += df;\n\t\t\t\t\t\te.rev.flow -= df;\n\t\t\t\t\t\treturn df;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic int getMaxFlow(int src, int tank) {\n\t\t\tthis.tank = tank;\n\t\t\t\n\t\t\tint res = 0;\n\t\t\twhile (dinic_bfs(src)) {\n\t\t\t\tArrays.fill(ptr, 0);\n\t\t\t\twhile (true) {\n\t\t\t\t\tint df = dinic_dfs(src, Integer.MAX_VALUE);\n\t\t\t\t\tif (df == 0) break;\n\t\t\t\t\tres += df;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t}\n\t/*-----------------end---------------------*/\n\t\n\tpublic void solve() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\n\t\tDinic din = new Dinic(n - 2);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdin.addEdge(from, to, 1);\n\t\t\tdin.addEdge(to, from, 1);\n\t\t}\n\t\t\n\t\tint src = in.nextInt() - 1, tank = in.nextInt() - 1;\n\t\tSystem.out.println(din.getMaxFlow(src, tank));\n\t\t\n\t\tArrayList<Integer> list = din.calcNecessaryRevEdges();\n\t\tSystem.out.println(list.size());\n\t\tfor (int id : list)\n\t\t\tSystem.out.println(id);\n\t}\t\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tint[] u = new int[m];\n\t\tint[] v = new int[m];\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tu[i] = io.nextInt() - 1;\n\t\t\tv[i] = io.nextInt() - 1;\n\t\t}\n\t\tint s = io.nextInt() - 1;\n\t\tint t = io.nextInt() - 1;\n\t\tDinic g1 = new Dinic(n);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tg1.addBidirectionalEdge(u[i], v[i], 1);\n\t\t}\n\t\tint f = g1.maximumFlow(s, t);\n\t\tMincostFlow g2 = new MincostFlow(n);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tg2.addEdge(u[i], v[i], 1, 0, i+1);\n\t\t\tg2.addEdge(v[i], u[i], 1, 1, -(i+1));\n\t\t}\n\t\tint cost = g2.minCostFlow(s, t, f);\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor(ArrayList<MincostFlow.Edge> es: g2.g) {\n\t\t\tfor(MincostFlow.Edge e: es) {\n\t\t\t\tif (e.cap0 != e.cap && e.id < 0) {\n\t\t\t\t\tans.add(-e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(f);\n\t\tSystem.out.println(ans.size());\n\t\tfor(int x: ans) {\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n\n}\nclass Dinic {\n\tpublic static final int INF = 1 << 29;\n\tprivate ArrayList<Edge>[] g;\n\tprivate int[] it;\n\tprivate int[] level;\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Dinic(int n) {\n\t\tg = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tit = new int[n];\n\t\tlevel = new int[n];\n\t}\n\tpublic void addEdge(int from,int to,int cap) {\n\t\tg[from].add(new Edge(to,cap,g[to].size()));\n\t\tg[to].add(new Edge(from,0,g[from].size()-1));\n\t}\n\tpublic void addBidirectionalEdge(int from,int to,int cap) {\n\t\taddEdge(from,to,cap);\n\t\taddEdge(to,from,cap);\n\t}\n\tprivate void bfs(int s) {\n\t\tArrays.fill(level, -1);\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tlevel[s] = 0;\n\t\tq.offer(s);\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.poll();\n\t\t\tfor(Edge e: g[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.offer(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate int dfs(int v,int t,int f) {\n\t\tif (v == t) {\n\t\t\treturn f;\n\t\t}\n\t\tfor(;it[v]<g[v].size();it[v]++) {\n\t\t\tEdge e = g[v].get(it[v]);\n\t\t\tif (e.cap <= 0 || level[v] >= level[e.to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint d = dfs(e.to,t,Math.min(f,e.cap));\n\t\t\tif (d <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te.cap -= d;\n\t\t\tg[e.to].get(e.rev).cap += d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic int maximumFlow(int s,int t) {\n\t\tint flow = 0;\n\t\twhile(true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) {\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t\tArrays.fill(it, 0);\n\t\t\tint f;\n\t\t\twhile((f = dfs(s,t,INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\tclass Edge {\n\t\tint to,cap,rev;\n\t\tpublic Edge(int to,int cap,int rev) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.rev = rev;\n\t\t}\n\t}\n}\nclass MincostFlow {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] g;\n\tint[] h;\n\tint[] dist;\n\tint[] prevv;\n\tint[] preve;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic MincostFlow(int n) {\n\t\tthis.n = n;\n\t\tg = new ArrayList[n];\n\t\tdist = new int[n];\n\t\tprevv = new int[n];\n\t\tpreve = new int[n];\n\t\th = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tg[i] = new ArrayList<MincostFlow.Edge>();\n\t\t}\n\t}\n\n\tpublic void addEdge(int from,int to,int cap,int cost,int id) {\n\t\tg[from].add(new Edge(to,cap,cost,g[to].size(),id));\n\t\tg[to].add(new Edge(from,0,-cost,g[from].size()-1,0));\n\t}\n\n\t/* F E log V */\n\tpublic int minCostFlow(int s,int t,int f) {\n\t\tint res = 0;\n\t\tArrays.fill(h, 0);\n\t\twhile(f > 0) {\n\t\t\tPriorityQueue<Pair> q = new PriorityQueue<Pair>();\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[s] = 0;\n\t\t\tq.offer(new Pair(0,s));\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tPair p = q.poll();\n\t\t\t\tint v = p.v;\n\t\t\t\tif (dist[v] < p.dist) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<g[v].size();i++) {\n\t\t\t\t\tEdge e = g[v].get(i);\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tq.offer(new Pair(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = Math.min(d, g[prevv[v]].get(preve[v]).cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s;v = prevv[v]) {\n\t\t\t\tEdge e = g[prevv[v]].get(preve[v]);\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v].get(e.rev).cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic class Edge {\n\t\tint to,cap,cost,rev;\n\t\tint cap0,id;\n\t\tpublic Edge(int to,int cap,int cost,int rev,int id) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cap0 = cap;\n\t\t\tthis.cost = cost;\n\t\t\tthis.rev = rev;\n\t\t\tthis.id = id;\n\t\t}\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint dist,v;\n\t\tpublic Pair(int dist,int v) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.v = v;\n\t\t}\n\t\tpublic int compareTo(Pair p) {\n\t\t\treturn Integer.compare(this.dist, p.dist);\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tint[] u = new int[m];\n\t\tint[] v = new int[m];\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tu[i] = io.nextInt() - 1;\n\t\t\tv[i] = io.nextInt() - 1;\n\t\t}\n\t\tint s = io.nextInt() - 1;\n\t\tint t = io.nextInt() - 1;\n\t\tDinic g1 = new Dinic(n);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tg1.addEdge(u[i], v[i], 1, (i+1));\n\t\t\tg1.addEdge(v[i], u[i], 1, -(i+1));\n\t\t}\n\t\tint f = g1.maximumFlow(s, t);\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor(ArrayList<Dinic.Edge> es: g1.g) {\n\t\t\tfor(Dinic.Edge e: es) {\n\t\t\t\tif (e.cap0 != e.cap && e.id < 0) {\n\t\t\t\t\tans.add(-e.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(f);\n\t\tSystem.out.println(ans.size());\n\t\tfor(int x: ans) {\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n\n}\nclass Dinic {\n\tpublic static final int INF = 1 << 29;\n\tpublic ArrayList<Edge>[] g;\n\tprivate int[] it;\n\tprivate int[] level;\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Dinic(int n) {\n\t\tg = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tit = new int[n];\n\t\tlevel = new int[n];\n\t}\n\tpublic void addEdge(int from,int to,int cap,int id) {\n\t\tg[from].add(new Edge(to,cap,g[to].size(),id));\n\t\tg[to].add(new Edge(from,0,g[from].size()-1,0));\n\t}\n\tprivate void bfs(int s) {\n\t\tArrays.fill(level, -1);\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tlevel[s] = 0;\n\t\tq.offer(s);\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.poll();\n\t\t\tfor(Edge e: g[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.offer(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate int dfs(int v,int t,int f) {\n\t\tif (v == t) {\n\t\t\treturn f;\n\t\t}\n\t\tfor(;it[v]<g[v].size();it[v]++) {\n\t\t\tEdge e = g[v].get(it[v]);\n\t\t\tif (e.cap <= 0 || level[v] >= level[e.to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint d = dfs(e.to,t,Math.min(f,e.cap));\n\t\t\tif (d <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te.cap -= d;\n\t\t\tg[e.to].get(e.rev).cap += d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic int maximumFlow(int s,int t) {\n\t\tint flow = 0;\n\t\twhile(true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) {\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t\tArrays.fill(it, 0);\n\t\t\tint f;\n\t\t\twhile((f = dfs(s,t,INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\tclass Edge {\n\t\tint to,cap,rev;\n\t\tint cap0,id;\n\t\tpublic Edge(int to,int cap,int rev,int id) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.cap0 = cap;\n\t\t\tthis.rev = rev;\n\t\t\tthis.id = id;\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\n//using static System.Math;\nusing C = System.Int32;\nnamespace Program {\n    public class Solver {\n        //Random rnd = new Random();\n        public void Solve() {\n            var n = ri; var m = ri;\n            var G = new MaxFlow(n);\n            var f = new int[m];\n            var t = new int[m];\n            for (int i = 0; i < m; i++)\n            {\n                f[i] = ri - 1;\n                t[i] = ri - 1;\n                G.AddUndirectedEdge(f[i], t[i], 1);\n            }\n            var src = ri - 1; var sink = ri - 1;\n            var mf = G.Execute(src, sink);\n            var ok = new bool[m];\n            for (int i = 0; i < n; i++)\n                foreach (var e in G.G[i])\n                    if (e.Cap == 0)\n                    {\n                        var u = i;\n                        var v = e.To;\n                        for (int j = 0; j < m; j++)\n                            if (f[j] == u && t[j] == v) ok[j] = true;\n                    }\n            Console.WriteLine(mf);\n            Console.WriteLine(ok.Count(x => !x));\n            for (int i = 0; i < m; i++)\n                if (!ok[i]) Console.WriteLine(i + 1);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    /*\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }*/\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n#region MaxFlow\npublic partial class MaxFlow {\n    public readonly List<Edge>[] G;\n    readonly int[] lv, iter;\n    public MaxFlow(int V) {\n        G = new List<Edge>[V];\n        lv = new int[V];\n        iter = new int[V];\n        for (int i = 0; i < G.Length; i++)\n            G[i] = new List<Edge>();\n    }\n\n    public void AddDirectedEdge(int from, int to, C cap) {\n        addEdge(from, to, cap, 0);\n    }\n\n    public void AddUndirectedEdge(int from, int to, C cap) {\n        addEdge(from, to, cap, cap);\n    }\n    void addEdge(int f, int t, C c1, C c2) {\n        var a = new Edge(t, c1);\n        var b = new Edge(f, c2);\n        Edge.Link(a, b);\n        G[f].Add(a);\n        G[t].Add(b);\n    }\n\n\n    public C Execute(int src, int sink, C f = -1) {\n        C flow = 0;\n        if (f < 0) f = C.MaxValue;\n        while (f > 0)\n        {\n            bfs(src);\n            if (lv[sink] == 0) return flow;\n            Array.Clear(iter, 0, iter.Length);\n            C df;\n            while ((df = dfs(src, sink, f)) > 0) { flow += df; f -= df; }\n        }\n        return flow;\n    }\n\n    void bfs(int s) {\n        Array.Clear(lv, 0, lv.Length);\n        var q = new Queue<int>();\n        lv[s] = 1;\n        q.Enqueue(s);\n        while (q.Count > 0)\n        {\n            var v = q.Dequeue();\n            foreach (var e in G[v])\n                if (e.Cap > 0 && lv[e.To] == 0)\n                {\n                    lv[e.To] = lv[v] + 1;\n                    q.Enqueue(e.To);\n                }\n        }\n\n    }\n    C dfs(int v, int t, C f) {\n        if (v == t) return f;\n        C ret = 0;\n        for (; iter[v] < G[v].Count; iter[v]++)\n        {\n            var e = G[v][iter[v]];\n            if (e.Cap <= 0 || lv[v] >= lv[e.To]) continue;\n            C df = dfs(e.To, t, Math.Min(f, e.Cap));\n            if (df <= 0) continue;\n            e.Cap -= df;\n            e.Rev.Cap += df;\n            ret += df; f -= df;\n            if (f == 0) break;\n        }\n        return ret;\n\n    }\n}\npublic class Edge {\n    public static void Link(Edge e1, Edge e2) {\n        e1.Rev = e2; e2.Rev = e1;\n    }\n    public int To { get; private set; }\n    public Edge Rev { get; private set; }\n    public C Cap { get; set; }\n    public Edge(int t, C c) {\n        To = t;\n        Cap = c;\n    }\n    public override string ToString() {\n        return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "def dfs(v)\n  return true if v == $goal\n  $used[v] = true\n  $g[v].each do |u, c|\n    if !$used[u] && c > 0\n      if dfs(u)\n        $g[v][u] -= 1\n        $g[u][v] += 1\n        return true\n      end\n    end\n  end\n  false\nend\n\ndef max_flow(size)\n  flow = 0\n  loop do\n    $used =  [false] * size\n    if dfs($start)\n      flow += 1\n    else\n      return flow\n    end\n  end\nend\n\nv, e = gets.split.map(&:to_i)\n$g = (v + 1).times.map { {} }\nr = e.times.map{ [] }\ne.times do |i|\n  s, t = gets.split.map(&:to_i)\n  r[i] = [s, t]\n  $g[s][t] = $g[t][s] = 1\nend\n$start, $goal = gets.split.map(&:to_i)\n\np max_flow(v)\n\nret = r.map.with_index{ |(s, t), i| i if $g[t][s] == 0 }.compact\np ret.size\nret.each{ |i| p i + 1 }"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_path_by_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.each_edge{|e|\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.opposite[v]\n\t\t\t\t\tend\n\t\t\t\t\tpath.unshift s\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{|i| g.add_node({:name => i})}\nedges = []\n\norig_dest = {}\n(1..m).each{|k|\n\ti, j = gets.split.map &:to_i\n\te = g.add_edge(nodes[i], nodes[j] , {:name => k})\n\tedges << e\n\torig_dest[e] = nodes[j]\n}\n\n\ns, t = gets.split.map &:to_i\n\ndef augment_path(s, t)\n\tpath_edge = {}\n\treached = Set[s]\n\tqueue = [s]\n\twhile !queue.empty? \n\t\tu = queue.shift\n\t\tu.each_edge{|e|\n\t\t\tv = e.opposite[u]\n\t\t\tnext if reached.include?(v)\t\n\n\t\t\tflow = (e.property[:flow] ||= {:destination => v, :amount => 0})\n\t\t\tnext if flow[:destination] == v && flow[:amount] == 1\n\n\t\t\treached << v\n\t\t\tqueue << v\n\t\t\tpath_edge[v] = e\n\n\t\t\tif v == t\n\t\t\t\tpath = []\n\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\tpath.unshift e\n\t\t\t\t\tv = e.opposite[v]\n\t\t\t\tend\n\t\t\t\tpath.unshift s\n\t\t\t\treturn path\n\t\t\tend\n\t\t}\n\tend\t\n\treturn nil\nend\n\n\ndef send_flow_along(path)\n\tu, *edges = path\n\tedges.each{|e|\n\t\tv = e.opposite[u]\n\t\tflow = (e.property[:flow] ||= {:destination => v, :amount => 0})\n\t\tif flow[:destination] == v\n\t\t\tflow[:amount] += 1\n\t\telsif flow[:amount] == 0\n\t\t\tflow[:destination] = v\n\t\t\tflow[:amount] = 1\n\t\telse\n\t\t\tflow[:amount] -= 1\n\t\tend\n\t\tu = v\n\t}\nend\n\nc = 0\nwhile path = augment_path(nodes[s], nodes[t])\n\tsend_flow_along(path)\n\tc += 1\nend\n\nreversed = []\nedges.each{|e|\n\tflow = e.property[:flow]\n\tif flow && flow[:destination] != orig_dest[e]\n\t\treversed << e.property[:name]\n\tend\n}\n\nputs c\nputs reversed.size\nputs reversed"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef to\n\t\t\t@opposite.keys[1]\n\t\tend\n\n\t\tdef from\n\t\t\t@opposite.keys[0]\n\t\tend\n\n\t\tdef flow\n\t\t\t@property[:flow] ||= {:to => to, :amount => 0}\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_path_by_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.each_edge{|e|\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.opposite[v]\n\t\t\t\t\tend\n\t\t\t\t\tpath.unshift s\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_augment_path(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.each_edge{|e|\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\t\n\t\n\t\t\t\tnext if e.flow[:to] == v && e.flow[:amount] == 1\n\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\t\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.opposite[v]\n\t\t\t\t\tend\n\t\t\t\t\tpath.unshift s\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\t\n\tdef send_flow_along(path)\n\t\tu, *edges = path\n\t\tedges.each{|e|\n\t\t\tv = e.opposite[u]\n\t\t\tf = e.flow\n\t\t\tif f[:to] == v\n\t\t\t\tf[:amount] += 1\n\t\t\telsif f[:amount] == 0\n\t\t\t\tf[:to] = v\n\t\t\t\tf[:amount] = 1\n\t\t\telse\n\t\t\t\tf[:amount] -= 1\n\t\t\tend\n\t\t\tu = v\n\t\t}\n\tend\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{|i| g.add_node({:name => i})}\nedges = []\n\norig_dest = {}\n(1..m).each{|k|\n\ti, j = gets.split.map &:to_i\n\te = g.add_edge(nodes[i], nodes[j] , {:name => k})\n\tedges << e\n\torig_dest[e] = nodes[j]\n}\n\n\ns, t = gets.split.map &:to_i\n\n\n\n\nc = 0\nwhile path = g.get_augment_path(nodes[s], nodes[t])\n\tg.send_flow_along(path)\n\tc += 1\nend\n\nreversed = []\nedges.each{|e|\n\tif e.flow && e.flow[:to] != orig_dest[e]\n\t\treversed << e.property[:name]\n\tend\n}\n\nputs c\nputs reversed.size\nputs reversed"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    auto E = M.iota.map!(_ => readln.split.map!(x => x.to!int-1).array).array;\n    s = readln.split.map!(to!int);\n    auto S = s[0]-1;\n    auto T = s[1]-1;\n\n    auto FF = new FordFulkerson(N, S, T);\n    foreach (e; E) FF.add_edge(e[0], e[1], 1), FF.add_edge(e[1], e[0], 1);\n\n    FF.run.writeln;\n\n    int[] ans;\n    foreach (i; 0..M) {\n        int u = E[i][0];\n        int v = E[i][1];\n        if (FF.flow[u][v]) ans ~= i + 1;\n    }\n\n    ans.length.writeln;\n    ans.each!writeln;\n}\n\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    int[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new int[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    int dfs(int v, int min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    int run() {\n        int ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            int f = dfs(source, int.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 2304 Reverse Roads\n# Python3 2018.7.21 bal4u\n\n# *******************************************\n# Dinic's Max Flow Algorithm\n# *******************************************\nclass MaxFlow:\n    def __init__(self, V):\n        self.V = V\n        self.level = [0] * V\n        self.iter = [0] * V\n        self.edge = [[] for i in range(V)]\n\n    def add_edge(self, fr, to, cap):\n        f, t = len(self.edge[fr]), len(self.edge[to])\n        self.edge[fr].append([to, cap, t])\n        self.edge[to].append([fr, cap, f])\n\n    def bfs(self, s):\n        self.level = [-1] * self.V\n        self.level[s] = 0\n        Q = []\n        Q.append(s)\n        while Q:\n            v = Q.pop()\n            for to, cap, rev in self.edge[v]:\n                if cap > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[v] + 1\n                    Q.append(to)\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        for i in range(self.iter[v], len(self.edge[v])):\n            to, cap, rev = self.edge[v][i]\n            if cap > 0 and self.level[v] < self.level[to]:\n                d = self.dfs(to, t, min(f, cap))\n                if d > 0:\n                    self.edge[v][i][1] -= d\n                    self.edge[to][rev][1] += d\n                    return d\n            self.iter[v] = i\n        return 0\n\n    def maxFlow(self, s, t, INF=10**8):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0: break\n            self.iter = [0] * self.V\n            while True:\n                f = self.dfs(s, t, INF)\n                if f <= 0: break\n                flow += f\n        return flow\n\nN, M = map(int, input().split())\ndir = [[0 for j in range(N)] for i in range(N)]\nid =  [[0 for j in range(N)] for i in range(N)]\nd = MaxFlow(N)\nfor i in range(M):\n\tx, y = map(int, input().split())\n\tx, y = x-1, y-1\n\tdir[y][x] = 1\n\tid[y][x] = i+1\n\td.add_edge(x, y, 1)\nS, T = map(int, input().split())\nprint(d.maxFlow(S-1, T-1))\n\nans = []\nfor i in range(N):\n\tfor to, cap, rev in d.edge[i]:\n\t\tif cap < 1 and dir[i][to]: ans.append(id[i][to])\nans.sort()\nprint(len(ans))\nif len(ans) > 0: print(*ans, sep='\\n')\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 2304 Reverse Roads\n# Python3 2018.7.21 bal4u\n\n# *******************************************\n# Dinic's Max Flow Algorithm\n# *******************************************\nINF = 0x7fffffff\n\nclass Donic:\n    def __init__(self, V):\n        self.V = V\n        self.level = [0] * V\n        self.iter = [0] * V\n        self.edge = [[] for i in range(V)]\n\n    def add_edge(self, frm, to, cap):\n        f, t = len(self.edge[frm]), len(self.edge[to])\n        self.edge[frm].append([to, cap, t])\n        self.edge[to].append([frm, cap, f])\n\n    def bfs(self, s):\n        self.level = [-1] * self.V\n        self.level[s] = 0\n        Q = []\n        Q.append(s)\n        while Q:\n            v = Q.pop()\n            for to, cap, rev in self.edge[v]:\n                if cap > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[v] + 1\n                    Q.append(to)\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        k = self.iter[v]\n        while k < len(self.edge[v]):\n            to, cap, rev = self.edge[v][k]\n            if cap > 0 and self.level[v] < self.level[to]:\n                d = self.dfs(to, t, f if f <= cap else cap)\n                if d > 0:\n                    self.edge[v][k][1] -= d\n                    self.edge[to][rev][1] += d\n                    return d\n            self.iter[v] += 1\n            k += 1\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0: break\n            self.iter = [0] * self.V\n            while True:\n                f = self.dfs(s, t, INF)\n                if f <= 0: break\n                flow += f\n        return flow\n\nN, M = map(int, input().split())\ndir = [[0 for j in range(N)] for i in range(N)]\nid =  [[0 for j in range(N)] for i in range(N)]\nd = Donic(N)\nfor i in range(M):\n\tx, y = map(int, input().split())\n\tx, y = x-1, y-1\n\tdir[y][x] = 1\n\tid[y][x] = i+1\n\td.add_edge(x, y, 1)\nS, T = map(int, input().split())\nprint(d.maxFlow(S-1, T-1))\n\nans = []\nfor i in range(N):\n\tfor to, cap, rev in d.edge[i]:\n\t\tif cap < 1 and dir[i][to]: ans.append(id[i][to])\nans.sort()\nprint(len(ans))\nif len(ans) > 0: print(*ans, sep='\\n')\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 2304 Reverse Roads\n# Python3 2018.7.21 bal4u\n\n# *******************************************\n# Dinic's Max Flow Algorithm\n# *******************************************\nINF = 0x7fffffff\n\nclass Donic:\n    def __init__(self, V):\n        self.V = V\n        self.level = [0] * V\n        self.iter = [0] * V\n        self.edge = [[] for i in range(V)]\n\n    def add_edge(self, frm, to, cap):\n        f, t = len(self.edge[frm]), len(self.edge[to])\n        self.edge[frm].append([to, cap, t])\n        self.edge[to].append([frm, cap, f])\n\n    def bfs(self, s):\n        self.level = [-1] * self.V\n        self.level[s] = 0\n        Q = []\n        Q.append(s)\n        while Q:\n            v = Q.pop()\n            for to, cap, rev in self.edge[v]:\n                if cap > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[v] + 1\n                    Q.append(to)\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        k = self.iter[v]\n        while k < len(self.edge[v]):\n            to, cap, rev = self.edge[v][k]\n            if cap > 0 and self.level[v] < self.level[to]:\n                d = self.dfs(to, t, f if f <= cap else cap)\n                if d > 0:\n                    self.edge[v][k][1] -= d\n                    self.edge[to][rev][1] += d\n                    return d\n            self.iter[v] += 1\n            k += 1\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0: break\n            self.iter = [0] * self.V\n            while True:\n                f = self.dfs(s, t, INF)\n                if f <= 0: break\n                flow += f\n        return flow\n\nN, M = map(int, input().split())\ndir = [[0 for j in range(N)] for i in range(N)]\nid =  [[0 for j in range(N)] for i in range(N)]\nd = Donic(N)\nfor i in range(M):\n\tx, y = map(int, input().split())\n\tx, y = x-1, y-1\n\tdir[y][x] = 1\n\tid[y][x] = i+1\n\td.add_edge(x, y, 1)\nS, T = map(int, input().split())\nprint(d.maxFlow(S-1, T-1))\n\nans = []\nfor i in range(N):\n\tfor to, cap, rev in d.edge[i]:\n\t\tif cap < 1 and dir[i][to]: ans.append(id[i][to])\nans.sort()\nprint(len(ans))\nprint(*ans, sep='\\n')\n\n"
  },
  {
    "language": "Python",
    "code": "import collections\nclass Dinic:\n    refs = {}\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for i in xrange(n)]\n    def add_edge(self, fr, to, cap):\n        self.g[fr].append([to, cap, len(self.g[to])])\n        self.g[to].append([fr, 0, len(self.g[fr])-1])\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        ref = [v2, cap1, len(self.g[v2])]\n        self.g[v1].append(ref)\n        self.g[v2].append([v1, cap2, len(self.g[v1])-1])\n        self.refs[v1, v2] = ref\n    def bfs(self, s):\n        level = [-1]*self.n\n        deq = collections.deque()\n        level[s] = 0\n        deq.append(s)\n        while deq:\n            v = deq.popleft()\n            for e in self.g[v]:\n                if e[1]>0 and level[e[0]]<0:\n                    level[e[0]] = level[v] + 1\n                    deq.append(e[0])\n        self.level = level\n    def dfs(self, v, t, f):\n        if v==t: return f\n        es = self.g[v]\n        level = self.level\n        for i in xrange(self.it[v], len(self.g[v])):\n            e = es[i]\n            if e[1]>0 and level[v]<level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d\n                    self.g[e[0]][e[2]][1] += d\n                    self.it[v] = i\n                    return d\n        self.it[v] = len(self.g[v])\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0: break\n            self.it = [0]*self.n\n            while True:\n                f = self.dfs(s, t, 10**9+7)\n                if f>0:\n                    flow += f\n                else:\n                    break\n        return flow\nn, m = map(int, raw_input().split())\ndinic = Dinic(n)\nes = []\nfor i in xrange(m):\n    x, y = map(int, raw_input().split())\n    dinic.add_multi_edge(x-1, y-1, 1, 1)\n    es.append((x-1, y-1))\ns, t = map(int, raw_input().split())\nf = dinic.max_flow(s-1, t-1)\nprint f\nans = []\nfor i, e in enumerate(es):\n    if dinic.refs[e][1]>1:\n        ans.append(i+1)\nprint len(ans)\nif ans:\n    print \"\\n\".join(map(str, ans))"
  },
  {
    "language": "Python",
    "code": "import collections\n\n\nclass MaxFlow:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, fr, to, cap):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\n        self.E[to].append(self.Edge(fr, 0, len(self.E[fr])-1))\n\n    def dinic(self, source, sink, INF=10**9):\n        \"\"\"find max-flow\"\"\"\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > 0 and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\nN, M = map(int, input().split())\nmf = MaxFlow(N)\nrev_edge = []\nfor i in range(M):\n    s, t = [int(x)-1 for x in input().split()]\n    mf.add_edge(s, t, 1)\n    mf.add_edge(t, s, 1)\n    rev_edge.append((i+1, t, len(mf.E[t])-1))\nsource, sink = [int(x)-1 for x in input().split()]\nprint(mf.dinic(source, sink))\nans = []\nfor i, t, idx in rev_edge:\n    e = mf.E[t][idx]\n    if mf.E[e.to][e.rev].cap == 1:\n        ans.append(i)\nprint(len(ans))\nif ans:\n    print(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Flow():\n    def __init__(self, e, N):\n        self.E = e\n        self.N = N\n\n    def max_flow(self, s, t):\n        r = 0\n        e = self.E\n\n        def f(c):\n            v = self.v\n            v[c] = 1\n            if c == t:\n                return 1\n            for i in range(self.N):\n                if v[i] == 0 and e[c][i] > 0 and f(i) > 0:\n                    e[c][i] -= 1\n                    e[i][c] += 1\n                    return 1\n            return 0\n\n        while True:\n            self.v = [0] * self.N\n            if f(s) == 0:\n                break\n            r += 1\n\n        return r\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = [LI_() for _ in range(m)]\n        s,t = LI_()\n        e = [[0]*n for _ in range(n)]\n        for x,y in a:\n            e[x][y] = 1\n            e[y][x] = 1\n        fl = Flow(e, n)\n        r = fl.max_flow(s,t)\n        re = []\n        for i in range(m):\n            x,y = a[i]\n            if e[y][x] == 0:\n                re.append(i+1)\n        return [r,len(re)] + re\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.extend(f(n,m))\n        # print('rr', rr[-1])\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]