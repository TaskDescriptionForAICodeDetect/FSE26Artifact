[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 100\n#define MAX_EDGES 1000\n\ntypedef struct {\n    int u, v, capacity, flow, reversed;\n} Edge;\n\nEdge edges[MAX_EDGES * 2];\nint graph[MAX_NODES][MAX_EDGES * 2];\nint edge_count = 0;\nint node_count;\nint parent[MAX_NODES];\nint queue[MAX_NODES];\nint front, rear;\n\nvoid add_edge(int u, int v, int capacity) {\n    edges[edge_count] = (Edge){u, v, capacity, 0, 0};\n    graph[u][graph[u][MAX_EDGES]++] = edge_count++;\n    edges[edge_count] = (Edge){v, u, 0, 0, 1};\n    graph[v][graph[v][MAX_EDGES]++] = edge_count++;\n}\n\nint bfs(int s, int t) {\n    for (int i = 0; i < node_count; i++) {\n        parent[i] = -1;\n    }\n    parent[s] = -2;\n    queue[0] = s;\n    front = 0;\n    rear = 1;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (int i = 0; i < graph[u][MAX_EDGES]; i++) {\n            int idx = graph[u][i];\n            Edge *e = &edges[idx];\n            if (parent[e->v] == -1 && e->capacity > e->flow) {\n                parent[e->v] = idx;\n                if (e->v == t) {\n                    return 1;\n                }\n                queue[rear++] = e->v;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int max_flow = 0;\n    while (bfs(s, t)) {\n        int flow = INT_MAX;\n        for (int v = t; v != s; v = edges[parent[v]].u) {\n            flow = (flow < edges[parent[v]].capacity - edges[parent[v]].flow) ? flow : edges[parent[v]].capacity - edges[parent[v]].flow;\n        }\n        for (int v = t; v != s; v = edges[parent[v]].u) {\n            edges[parent[v]].flow += flow;\n            edges[parent[v] ^ 1].flow -= flow;\n        }\n        max_flow += flow;\n    }\n    return max_flow;\n}\n\nint main() {\n    int m, s, t;\n    scanf(\"%d %d %d %d\", &node_count, &m, &s, &t);\n\n    for (int i = 0; i < node_count; i++) {\n        graph[i][MAX_EDGES] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v, c;\n        scanf(\"%d %d %d\", &u, &v, &c);\n        add_edge(u, v, c);\n    }\n\n    int original_flow = max_flow(s, t);\n\n    for (int i = 0; i < edge_count; i += 2) {\n        if (edges[i].flow < edges[i].capacity) {\n            edges[i].capacity -= edges[i].flow;\n            edges[i].flow = 0;\n            edges[i ^ 1].capacity += edges[i ^ 1].flow;\n            edges[i ^ 1].flow = 0;\n        } else {\n            edges[i ^ 1].capacity += edges[i].flow;\n            edges[i].flow = 0;\n            edges[i].capacity = 0;\n        }\n    }\n\n    int reversed_edges[MAX_EDGES];\n    int reversed_count = 0;\n\n    for (int i = 0; i < edge_count; i += 2) {\n        if (edges[i].reversed) {\n            edges[i].capacity += edges[i ^ 1].capacity;\n            edges[i ^ 1].capacity = 0;\n            reversed_edges[reversed_count++] = i / 2;\n        }\n    }\n\n    int new_flow = max_flow(s, t);\n\n    printf(\"%d\\n\", original_flow + new_flow);\n    printf(\"%d\\n\", reversed_count);\n    for (int i = 0; i < reversed_count; i++) {\n        printf(\"%d\\n\", reversed_edges[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to, rev, flow, cap;\n    bool original;\n};\n\nclass MaxFlow {\n    int N;\n    vector<vector<Edge>> adj;\n    vector<int> level;\n    vector<int> next;\n\n    bool bfs(int s, int t) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> q;\n        q.push(s);\n        level[s] = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (Edge &e : adj[u]) {\n                if (level[e.to] == -1 && e.flow < e.cap) {\n                    level[e.to] = level[u] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    int dfs(int u, int t, int flow) {\n        if (u == t) return flow;\n        for (int &i = next[u]; i < adj[u].size(); ++i) {\n            Edge &e = adj[u][i];\n            if (level[e.to] == level[u] + 1 && e.flow < e.cap) {\n                int f = dfs(e.to, t, min(flow, e.cap - e.flow));\n                if (f > 0) {\n                    e.flow += f;\n                    adj[e.to][e.rev].flow -= f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    MaxFlow(int n) : N(n), adj(n), level(n), next(n) {}\n\n    void addEdge(int u, int v, int cap, bool original) {\n        Edge forward = {v, (int)adj[v].size(), 0, cap, original};\n        Edge backward = {u, (int)adj[u].size(), 0, 0, false};\n        adj[u].push_back(forward);\n        adj[v].push_back(backward);\n    }\n\n    int dinic(int s, int t) {\n        int total = 0;\n        while (bfs(s, t)) {\n            fill(next.begin(), next.end(), 0);\n            while (int f = dfs(s, t, INT_MAX)) {\n                total += f;\n            }\n        }\n        return total;\n    }\n\n    vector<pair<int, int>> getReversedEdges() {\n        vector<pair<int, int>> reversed;\n        for (int u = 0; u < N; ++u) {\n            for (Edge &e : adj[u]) {\n                if (e.original && e.flow < 0) {\n                    reversed.emplace_back(u, e.to);\n                }\n            }\n        }\n        return reversed;\n    }\n};\n\nint main() {\n    int N, M, S, T;\n    cin >> N >> M >> S >> T;\n    MaxFlow mf(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        mf.addEdge(u, v, c, true);\n        mf.addEdge(v, u, c, false);\n    }\n    int maxFlow = mf.dinic(S, T);\n    vector<pair<int, int>> reversed = mf.getReversedEdges();\n    cout << maxFlow << \" \" << reversed.size() << endl;\n    for (auto &p : reversed) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxFlowWithReversals {\n    static class Edge {\n        int to, rev, capacity, originalTo, originalFrom;\n        boolean reversed;\n\n        Edge(int to, int rev, int capacity, int originalFrom, int originalTo, boolean reversed) {\n            this.to = to;\n            this.rev = rev;\n            this.capacity = capacity;\n            this.originalFrom = originalFrom;\n            this.originalTo = originalTo;\n            this.reversed = reversed;\n        }\n    }\n\n    static List<List<Edge>> graph;\n    static int[] level, iter;\n\n    static void addEdge(int from, int to, int capacity, int originalFrom, int originalTo, boolean reversed) {\n        graph.get(from).add(new Edge(to, graph.get(to).size(), capacity, originalFrom, originalTo, reversed));\n        graph.get(to).add(new Edge(from, graph.get(from).size() - 1, 0, originalFrom, originalTo, reversed));\n    }\n\n    static void bfs(int s) {\n        Arrays.fill(level, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        level[s] = 0;\n        queue.add(s);\n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            for (Edge e : graph.get(v)) {\n                if (e.capacity > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    queue.add(e.to);\n                }\n            }\n        }\n    }\n\n    static int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (; iter[v] < graph.get(v).size(); iter[v]++) {\n            Edge e = graph.get(v).get(iter[v]);\n            if (e.capacity > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, Math.min(f, e.capacity));\n                if (d > 0) {\n                    e.capacity -= d;\n                    graph.get(e.to).get(e.rev).capacity += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    static int maxFlow(int s, int t) {\n        int flow = 0;\n        level = new int[graph.size()];\n        iter = new int[graph.size()];\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            Arrays.fill(iter, 0);\n            int f;\n            while ((f = dfs(s, t, Integer.MAX_VALUE)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int S = scanner.nextInt();\n        int T = scanner.nextInt();\n\n        graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int c = scanner.nextInt();\n            addEdge(u, v, c, u, v, false);\n            addEdge(v, u, c, u, v, true);\n        }\n\n        int maxFlow = maxFlow(S, T);\n        System.out.println(maxFlow);\n\n        Set<String> reversedEdges = new HashSet<>();\n        for (int u = 0; u < graph.size(); u++) {\n            for (Edge e : graph.get(u)) {\n                if (e.reversed && e.capacity > 0 && e.originalFrom != 0 && e.originalTo != 0) {\n                    reversedEdges.add(e.originalFrom + \" \" + e.originalTo);\n                }\n            }\n        }\n\n        System.out.println(reversedEdges.size());\n        for (String edge : reversedEdges) {\n            System.out.println(edge);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:23:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass RoadNetwork {\n    private int vertices;\n    private List<List<Edge>> graph;\n    private int source;\n    private int sink;\n\n    class Edge {\n        int to, capacity, flow;\n        Edge reverse;\n        boolean wasReversed;\n\n        Edge(int to, int capacity) {\n            this.to = to;\n            this.capacity = capacity;\n            this.flow = 0;\n            this.wasReversed = false;\n        }\n    }\n\n    public RoadNetwork(int vertices, int source, int sink) {\n        this.vertices = vertices;\n        this.source = source;\n        this.sink = sink;\n        graph = new ArrayList<>(vertices);\n        for (int i = 0; i < vertices; i++) {\n            graph.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int from, int to, int capacity) {\n        Edge forward = new Edge(to, capacity);\n        Edge backward = new Edge(from, 0);\n        forward.reverse = backward;\n        backward.reverse = forward;\n        graph.get(from).add(forward);\n        graph.get(to).add(backward);\n    }\n\n    private boolean bfs(int[][] residualGraph, int[] parent) {\n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(source);\n        visited[source] = true;\n        parent[source] = -1;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                if (!visited[v] && residualGraph[u][v] > 0) {\n                    queue.add(v);\n                    parent[v] = u;\n                    visited[v] = true;\n                }\n            }\n        }\n        return visited[sink];\n    }\n\n    public int maxFlowWithReversal() {\n        int[][] residualGraph = new int[vertices][vertices];\n        for (int u = 0; u < vertices; u++) {\n            for (Edge edge : graph.get(u)) {\n                residualGraph[u][edge.to] = edge.capacity;\n            }\n        }\n\n        int[] parent = new int[vertices];\n        int maxFlow = 0;\n\n        while (bfs(residualGraph, parent)) {\n            int pathFlow = Integer.MAX_VALUE;\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                pathFlow = Math.min(pathFlow, residualGraph[u][v]);\n            }\n\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                residualGraph[u][v] -= pathFlow;\n                residualGraph[v][u] += pathFlow;\n\n                // Track road reversals\n                for (Edge edge : graph.get(u)) {\n                    if (edge.to == v) {\n                        if (edge.capacity == 0) {\n                            edge.wasReversed = true;\n                        }\n                        break;\n                    }\n                }\n            }\n            maxFlow += pathFlow;\n        }\n\n        return maxFlow;\n    }\n\n    public List<int[]> getReversedRoads() {\n        List<int[]> reversedRoads = new ArrayList<>();\n        for (int u = 0; u < vertices; u++) {\n            for (Edge edge : graph.get(u)) {\n                if (edge.wasReversed) {\n                    reversedRoads.add(new int[]{u, edge.to});\n                }\n            }\n        }\n        return reversedRoads;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        RoadNetwork network = new RoadNetwork(6, 0, 5);\n        network.addEdge(0, 1, 10);\n        network.addEdge(0, 2, 10);\n        network.addEdge(1, 3, 4);\n        network.addEdge(1, 4, 8);\n        network.addEdge(2, 4, 9);\n        network.addEdge(3, 5, 10);\n        network.addEdge(4, 5, 10);\n\n        int maxFlow = network.maxFlowWithReversal();\n        List<int[]> reversedRoads = network.getReversedRoads();\n\n        System.out.println(\"Maximum Flow: \" + maxFlow);\n        System.out.println(\"Reversed Roads:\");\n        for (int[] road : reversedRoads) {\n            System.out.println(road[0] + \" -> \" + road[1]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:23:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_NODES 1000\n#define MAX_EDGES 10000\n\ntypedef struct {\n    int from, to, capacity, flow;\n    bool reversed;\n} Edge;\n\nint n, m, s, t;\nEdge edges[MAX_EDGES];\nint graph[MAX_NODES][MAX_NODES];\nint parent[MAX_NODES];\nbool visited[MAX_NODES];\n\nvoid initGraph() {\n    memset(graph, 0, sizeof(graph));\n    memset(edges, 0, sizeof(edges));\n}\n\nbool bfs() {\n    memset(visited, false, sizeof(visited));\n    memset(parent, -1, sizeof(parent));\n\n    int queue[MAX_NODES], front = 0, rear = 0;\n    queue[rear++] = s;\n    visited[s] = true;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && graph[u][v] > 0) {\n                queue[rear++] = v;\n                parent[v] = u;\n                visited[v] = true;\n                if (v == t) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint fordFulkerson() {\n    int max_flow = 0;\n\n    while (bfs()) {\n        int path_flow = INT_MAX;\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            path_flow = (path_flow < graph[u][v]) ? path_flow : graph[u][v];\n        }\n\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            graph[u][v] -= path_flow;\n            graph[v][u] += path_flow;\n        }\n\n        max_flow += path_flow;\n    }\n\n    return max_flow;\n}\n\nvoid reverseEdges() {\n    for (int i = 0; i < m; i++) {\n        if (edges[i].flow < 0) {\n            int temp = edges[i].from;\n            edges[i].from = edges[i].to;\n            edges[i].to = temp;\n            edges[i].reversed = true;\n        }\n    }\n}\n\nvoid printReversedRoads() {\n    printf(\"Reversed Roads:\\n\");\n    for (int i = 0; i < m; i++) {\n        if (edges[i].reversed) {\n            printf(\"%d -> %d\\n\", edges[i].from, edges[i].to);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n    initGraph();\n\n    for (int i = 0; i < m; i++) {\n        int u, v, cap;\n        scanf(\"%d %d %d\", &u, &v, &cap);\n        edges[i].from = u;\n        edges[i].to = v;\n        edges[i].capacity = cap;\n        graph[u][v] = cap;\n    }\n\n    int max_flow = fordFulkerson();\n    printf(\"Maximum Flow: %d\\n\", max_flow);\n\n    reverseEdges();\n    printReversedRoads();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 500;\nconst int INF = numeric_limits<int>::max();\n\nstruct Edge {\n    int to, capacity, flow, original_dir;\n    Edge* reverse;\n};\n\nclass NetworkFlow {\nprivate:\n    int n, source, sink;\n    vector<vector<Edge*>> graph;\n    vector<int> parent;\n    vector<bool> visited;\n\n    bool bfs() {\n        fill(visited.begin(), visited.end(), false);\n        queue<int> q;\n        q.push(source);\n        visited[source] = true;\n        parent[source] = -1;\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            for (Edge* edge : graph[u]) {\n                int v = edge->to;\n                if (!visited[v] && edge->capacity > edge->flow) {\n                    parent[v] = u;\n                    visited[v] = true;\n                    q.push(v);\n\n                    if (v == sink) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    int augmentPath() {\n        int pathFlow = INF;\n        for (int v = sink; parent[v] != -1; v = parent[v]) {\n            Edge* edge = nullptr;\n            for (Edge* e : graph[parent[v]]) {\n                if (e->to == v) {\n                    edge = e;\n                    break;\n                }\n            }\n            pathFlow = min(pathFlow, edge->capacity - edge->flow);\n        }\n\n        for (int v = sink; parent[v] != -1; v = parent[v]) {\n            for (Edge* edge : graph[parent[v]]) {\n                if (edge->to == v) {\n                    edge->flow += pathFlow;\n                    edge->reverse->flow -= pathFlow;\n                }\n            }\n        }\n        return pathFlow;\n    }\n\npublic:\n    NetworkFlow(int nodes, int s, int t) : \n        n(nodes), source(s), sink(t), \n        graph(nodes), parent(nodes), visited(nodes) {}\n\n    void addEdge(int u, int v, int capacity, bool reversible) {\n        Edge* forward = new Edge{v, capacity, 0, reversible ? 1 : 0, nullptr};\n        Edge* backward = new Edge{u, 0, 0, 0, forward};\n        forward->reverse = backward;\n        graph[u].push_back(forward);\n        graph[v].push_back(backward);\n    }\n\n    pair<int, vector<pair<int, int>>> maxFlow() {\n        int totalFlow = 0;\n        vector<pair<int, int>> reversedRoads;\n\n        while (bfs()) {\n            int pathFlow = augmentPath();\n            totalFlow += pathFlow;\n        }\n\n        for (int u = 0; u < n; u++) {\n            for (Edge* edge : graph[u]) {\n                if (edge->original_dir == 1 && edge->flow < 0) {\n                    reversedRoads.push_back({u, edge->to});\n                }\n            }\n        }\n\n        return {totalFlow, reversedRoads};\n    }\n};\n\nint main() {\n    int nodes, edges, source, sink;\n    cin >> nodes >> edges >> source >> sink;\n\n    NetworkFlow network(nodes, source, sink);\n\n    for (int i = 0; i < edges; i++) {\n        int u, v, capacity;\n        cin >> u >> v >> capacity;\n        network.addEdge(u, v, capacity, true);\n    }\n\n    auto result = network.maxFlow();\n    cout << result.first << endl;\n    \n    cout << result.second.size() << endl;\n    for (auto road : result.second) {\n        cout << road.first << \" \" << road.second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\nclass MaxFlowGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n        self.capacity = {}\n        self.residual = defaultdict(dict)\n    \n    def add_edge(self, u, v, cap):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.capacity[(u, v)] = cap\n        self.capacity[(v, u)] = 0\n        self.residual[u][v] = cap\n        self.residual[v][u] = 0\n    \n    def bfs(self, s, t, parent):\n        visited = [False] * (self.V)\n        queue = deque([s])\n        visited[s] = True\n        \n        while queue:\n            u = queue.popleft()\n            \n            for v in self.graph[u]:\n                if not visited[v] and self.residual[u][v] > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t:\n                        return True\n        \n        return False\n    \n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.V\n        max_flow = 0\n        \n        while self.bfs(source, sink, parent):\n            path_flow = float('Inf')\n            s = sink\n            \n            while s != source:\n                path_flow = min(path_flow, self.residual[parent[s]][s])\n                s = parent[s]\n            \n            v = sink\n            while v != source:\n                u = parent[v]\n                self.residual[u][v] -= path_flow\n                self.residual[v][u] += path_flow\n                v = parent[v]\n            \n            max_flow += path_flow\n        \n        return max_flow\n    \ndef maximize_flow_with_reversals(V, edges, source, sink):\n    graph = MaxFlowGraph(V)\n    for u, v, cap in edges:\n        graph.add_edge(u, v, cap)\n\n    forward_max_flow = graph.ford_fulkerson(source, sink)\n    \n    reversed_edges = set()\n    for u, v, cap in edges:\n        if graph.residual[v][u] > 0:\n            reversed_edges.add((u, v))\n    \n    # Reverse the necessary edges\n    reversed_edges_list = []\n    for u, v in reversed_edges:\n        graph.capacity[(v, u)] = graph.capacity.pop((u, v), 0)\n        reversed_edges_list.append((u, v))\n\n    # Recalculate flow with reversed edges\n    max_flow = graph.ford_fulkerson(source, sink)\n    \n    return max_flow, reversed_edges_list\n\n# Example usage:\nV = 4\nedges = [(0, 1, 10), (1, 3, 5), (0, 2, 5), (2, 3, 10), (1, 2, 15)]\nsource = 0\nsink = 3\n\nmax_flow, reversed_edges = maximize_flow_with_reversals(V, edges, source, sink)\nprint(\"Maximized Flow:\", max_flow)\nprint(\"Reversed Edges:\", reversed_edges)",
    "timestamp": "2025-08-13 06:11:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaxFlowWithReverse {\n    static final int INF = Integer.MAX_VALUE;\n    \n    static class Edge {\n        int from, to, capacity, flow;\n        Edge revEdge;\n        \n        Edge(int from, int to, int capacity) {\n            this.from = from;\n            this.to = to;\n            this.capacity = capacity;\n            this.flow = 0;\n        }\n    }\n    \n    static class Graph {\n        List<Edge>[] adjList;\n        int[] level, ptr;\n        int n, s, t;\n        \n        public Graph(int n, int s, int t) {\n            this.n = n;\n            this.s = s;\n            this.t = t;\n            adjList = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adjList[i] = new ArrayList<>();\n            }\n            level = new int[n];\n            ptr = new int[n];\n        }\n        \n        public void addEdge(int from, int to, int capacity) {\n            Edge e1 = new Edge(from, to, capacity);\n            Edge e2 = new Edge(to, from, 0); // reverse edge with 0 capacity initially\n            e1.revEdge = e2;\n            e2.revEdge = e1;\n            adjList[from].add(e1);\n            adjList[to].add(e2);\n        }\n        \n        public boolean bfs() {\n            Arrays.fill(level, -1);\n            level[s] = 0;\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(s);\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n                for (Edge e : adjList[u]) {\n                    if (level[e.to] < 0 && e.flow < e.capacity) {\n                        level[e.to] = level[u] + 1;\n                        queue.add(e.to);\n                    }\n                }\n            }\n            return level[t] >= 0;\n        }\n        \n        public int dfs(int u, int flow) {\n            if (u == t) return flow;\n            for (; ptr[u] < adjList[u].size(); ptr[u]++) {\n                Edge e = adjList[u].get(ptr[u]);\n                if (level[e.to] == level[u] + 1 && e.flow < e.capacity) {\n                    int pushedFlow = dfs(e.to, Math.min(flow, e.capacity - e.flow));\n                    if (pushedFlow > 0) {\n                        e.flow += pushedFlow;\n                        e.revEdge.flow -= pushedFlow;\n                        return pushedFlow;\n                    }\n                }\n            }\n            return 0;\n        }\n        \n        public int maxFlow() {\n            int flow = 0;\n            while (bfs()) {\n                Arrays.fill(ptr, 0);\n                while (true) {\n                    int pushedFlow = dfs(s, INF);\n                    if (pushedFlow == 0) break;\n                    flow += pushedFlow;\n                }\n            }\n            return flow;\n        }\n        \n        public List<Edge> getReversedEdges() {\n            List<Edge> reversed = new ArrayList<>();\n            for (int u = 0; u < n; u++) {\n                for (Edge e : adjList[u]) {\n                    if (e.flow < 0) {\n                        reversed.add(new Edge(e.revEdge.to, e.revEdge.from, -e.flow));\n                    }\n                }\n            }\n            return reversed;\n        }\n    }\n    \n    public static void main(String[] args) {\n        int nodeCount = 6; // example number of nodes\n        int source = 0; // example source node\n        int sink = 5; // example sink node\n        \n        Graph graph = new Graph(nodeCount, source, sink);\n        graph.addEdge(0, 1, 8); // example edges with capacities\n        graph.addEdge(0, 2, 5);\n        graph.addEdge(1, 2, 3);\n        graph.addEdge(1, 3, 6);\n        graph.addEdge(2, 4, 8);\n        graph.addEdge(3, 5, 10);\n        graph.addEdge(4, 5, 3);\n        \n        System.out.println(\"Max Flow: \" + graph.maxFlow());\n        System.out.println(\"Reversed Edges:\");\n        \n        for (Edge edge : graph.getReversedEdges()) {\n            System.out.println(\"Reversed Road: \" + edge.from + \" -> \" + edge.to + \", Flow: \" + edge.capacity);\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:11:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define V 100\n\nbool bfs(int rGraph[V][V], int s, int t, int parent[]) {\n    bool visited[V];\n    memset(visited, 0, sizeof(visited));\n    \n    int queue[V], front = 0, rear = 0;\n    queue[rear++] = s;\n    visited[s] = true;\n    parent[s] = -1;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        \n        for (int v = 0; v < V; v++) {\n            if (!visited[v] && rGraph[u][v] > 0) {\n                if (v == t) {\n                    parent[v] = u;\n                    return true;\n                }\n                queue[rear++] = v;\n                parent[v] = u;\n                visited[v] = true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid dfs(int rGraph[V][V], int s, bool visited[]) {\n    visited[s] = true;\n    for (int i = 0; i < V; i++)\n        if (rGraph[s][i] > 0 && !visited[i])\n            dfs(rGraph, i, visited);\n}\n\nint fordFulkerson(int graph[V][V], int s, int t, int reversedEdges[][2], int *reversedCount) {\n    int u, v;\n    int rGraph[V][V];\n    \n    for (u = 0; u < V; u++)\n        for (v = 0; v < V; v++)\n             rGraph[u][v] = graph[u][v];\n\n    int parent[V];\n    int max_flow = 0;\n\n    while (bfs(rGraph, s, t, parent)) {\n        int path_flow = INT_MAX;\n        for (v = t; v != s; v = parent[v]) {\n            u = parent[v];\n            path_flow = (rGraph[u][v] < path_flow) ? rGraph[u][v] : path_flow;\n        }\n        \n        for (v = t; v != s; v = parent[v]) {\n            u = parent[v];\n            rGraph[u][v] -= path_flow;\n            rGraph[v][u] += path_flow;\n        }\n        max_flow += path_flow;\n    }\n    \n    bool visited[V];\n    memset(visited, false, sizeof(visited));\n    dfs(rGraph, s, visited);\n\n    *reversedCount = 0;\n    for (int i = 0; i < V; i++)\n        for (int j = 0; j < V; j++)\n            if (visited[i] && !visited[j] && graph[i][j] > 0) {\n                reversedEdges[*reversedCount][0] = j;\n                reversedEdges[*reversedCount][1] = i;\n                (*reversedCount)++;\n            }\n\n    return max_flow;\n}\n\nint main() {\n    int graph[V][V] = {0};\n    int reversedEdges[V * V][2];\n    int reversedCount;\n\n    int n, m, u, v, cap;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &u, &v, &cap);\n        graph[u][v] = cap;\n    }\n\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n\n    int maxFlow = fordFulkerson(graph, s, t, reversedEdges, &reversedCount);\n\n    printf(\"Maximum Flow: %d\\n\", maxFlow);\n    printf(\"Reversed Edges:\\n\");\n    for (int i = 0; i < reversedCount; i++)\n        printf(\"%d -> %d\\n\", reversedEdges[i][0], reversedEdges[i][1]);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:11:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\nclass FordFulkerson:\n    def __init__(self, graph, source, sink):\n        self.graph = graph\n        self.source = source\n        self.sink = sink\n        self.reversed_roads = []\n\n    def bfs(self, parent):\n        visited = [False] * len(self.graph)\n        queue = deque([self.source])\n        visited[self.source] = True\n\n        while queue:\n            u = queue.popleft()\n            for v, capacity in enumerate(self.graph[u]):\n                if not visited[v] and capacity > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == self.sink:\n                        return True\n        return False\n\n    def find_max_flow(self):\n        max_flow = 0\n        parent = [-1] * len(self.graph)\n\n        while self.bfs(parent):\n            path_flow = float('inf')\n            s = self.sink\n            while s != self.source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n            v = self.sink\n            while v != self.source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                \n                if self.graph[u][v] == 0:\n                    self.reversed_roads.append((u, v))\n                v = parent[v]\n\n        return max_flow\n\ndef solve_max_flow(n, roads):\n    graph = [[0] * n for _ in range(n)]\n    for u, v, capacity in roads:\n        graph[u][v] += capacity\n\n    max_flow_solver = FordFulkerson(graph, 0, n-1)\n    max_flow = max_flow_solver.find_max_flow()\n    \n    return max_flow, max_flow_solver.reversed_roads\n\n# Example usage\nn = 4\nroads = [(0, 1, 3), (0, 2, 2), (1, 2, 1), (1, 3, 3), (2, 3, 2)]\nmax_flow, reversed_roads = solve_max_flow(n, roads)\nprint(f\"Maximum Flow: {max_flow}\")\nprint(f\"Reversed Roads: {reversed_roads}\")",
    "timestamp": "2025-08-13 06:12:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n\nclass MaxFlow:\n    def __init__(self, N):\n        self.size = N\n        self.graph = [[] for _ in range(N)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1]*self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.capacity > 0 and level[edge.to] < 0:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n    \n    def dfs_flow(self, v, t, upTo, iter_, level):\n        if v == t:\n            return upTo\n        for i in range(iter_[v], len(self.graph[v])):\n            edge = self.graph[v][i]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                d = self.dfs_flow(edge.to, t, min(upTo, edge.capacity), iter_, level)\n                if d > 0:\n                    edge.capacity -= d\n                    self.graph[edge.to][edge.rev].capacity += d\n                    return d\n            iter_[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1]*self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] < 0:\n                return flow\n            iter_ = [0]*self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), iter_, level)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1]*self.size\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    S = int(input[ptr]) - 1\n    ptr += 1\n    T = int(input[ptr]) - 1\n    ptr += 1\n    \n    original_edges = []\n    mf = MaxFlow(N)\n    for _ in range(M):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        original_edges.append((u, v, c))\n        mf.add_edge(u, v, c)\n    \n    max_flow = mf.max_flow(S, T)\n    \n    reversed_edges = []\n    for i in range(M):\n        u, v, c = original_edges[i]\n        for edge in mf.graph[v]:\n            if edge.to == u and edge.capacity > 0:\n                reversed_edges.append(i+1)\n                break\n    \n    print(max_flow, len(reversed_edges))\n    if reversed_edges:\n        print(' '.join(map(str, reversed_edges)))\n\nsolve()",
    "timestamp": "2025-08-13 06:12:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, capacity, flow;\n    int reverse; // index of the reversed edge\n};\n\nclass MaxFlow {\npublic:\n    MaxFlow(int n) : graph(n), level(n), iter(n) { }\n\n    void addEdge(int from, int to, int capacity) {\n        graph[from].push_back({from, to, capacity, 0, (int)graph[to].size()});\n        graph[to].push_back({to, from, 0, 0, (int)graph[from].size() - 1});\n    }\n\n    int maxFlow(int source, int sink) {\n        int flow = 0;\n        while (bfs(source, sink)) {\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(source, sink, INT32_MAX)) > 0) {\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    vector<pair<int, int>> findEdgesToReverse(int source, int sink) {\n        // Use a modified BFS to find a path to sink with reversed edges\n        // This function should be called after obtaining the maximum flow\n        vector<pair<int, int>> reversedEdges;\n        vector<bool> visited(graph.size(), false);\n        queue<int> q;\n        q.push(source);\n        visited[source] = true;\n\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (Edge &e : graph[u]) {\n                if (!visited[e.to] && e.flow > 0) {\n                    visited[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n\n        for (int u = 0; u < graph.size(); ++u) {\n            if (visited[u]) {\n                for (Edge &e : graph[u]) {\n                    if (!visited[e.to] && e.capacity > e.flow) {\n                        reversedEdges.push_back({e.to, e.from});\n                    }\n                }\n            }\n        }\n\n        return reversedEdges;\n    }\n\nprivate:\n    bool bfs(int source, int sink) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> q;\n        level[source] = 0;\n        q.push(source);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (Edge &e : graph[u]) {\n                if (e.capacity > e.flow && level[e.to] < 0) {\n                    level[e.to] = level[u] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n        return level[sink] != -1;\n    }\n\n    int dfs(int u, int sink, int flow) {\n        if (u == sink) return flow;\n        for (int &i = iter[u]; i < graph[u].size(); ++i) {\n            Edge &e = graph[u][i];\n            if (e.capacity > e.flow && level[u] < level[e.to]) {\n                int d = dfs(e.to, sink, min(flow, e.capacity - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph[e.to][e.reverse].flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    vector<vector<Edge>> graph;\n    vector<int> level;\n    vector<int> iter;\n};\n\nint main() {\n    int n, m; // number of nodes and edges\n    cin >> n >> m;\n    MaxFlow maxFlow(n);\n    \n    for (int i = 0; i < m; ++i) {\n        int u, v, capacity;\n        cin >> u >> v >> capacity;\n        maxFlow.addEdge(u, v, capacity);\n    }\n    \n    int source, sink;\n    cin >> source >> sink;\n    \n    int flow = maxFlow.maxFlow(source, sink);\n    cout << \"Maximum Flow: \" << flow << endl;\n    \n    vector<pair<int, int>> reversedEdges = maxFlow.findEdgesToReverse(source, sink);\n    \n    cout << \"Reversed Roads:\" << endl;\n    for (auto &p : reversedEdges) {\n        cout << p.first << \" -> \" << p.second << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:30:31"
  }
]