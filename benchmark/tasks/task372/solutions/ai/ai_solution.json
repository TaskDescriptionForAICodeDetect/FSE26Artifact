[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    char dir;\n} Frog;\n\nchar grid[100][100];\nint rows, cols;\nFrog frog;\nint leaves_left;\n\nvoid initialize() {\n    leaves_left = 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 'L') {\n                leaves_left++;\n            } else if (grid[i][j] == 'F') {\n                frog.pos.x = i;\n                frog.pos.y = j;\n                leaves_left++;\n            }\n        }\n    }\n}\n\nbool can_jump(int dx, int dy) {\n    int nx = frog.pos.x + dx;\n    int ny = frog.pos.y + dy;\n    return nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 'L';\n}\n\nvoid jump(int dx, int dy, char dir) {\n    grid[frog.pos.x][frog.pos.y] = '.';\n    frog.pos.x += dx;\n    frog.pos.y += dy;\n    frog.dir = dir;\n    grid[frog.pos.x][frog.pos.y] = 'F';\n    leaves_left--;\n}\n\nvoid move_forward() {\n    int dx = 0, dy = 0;\n    switch (frog.dir) {\n        case 'U': dx = -1; break;\n        case 'D': dx = 1; break;\n        case 'L': dy = -1; break;\n        case 'R': dy = 1; break;\n    }\n    if (can_jump(dx, dy)) {\n        jump(dx, dy, frog.dir);\n        printf(\"%c\", frog.dir);\n    }\n}\n\nvoid turn_left() {\n    switch (frog.dir) {\n        case 'U': frog.dir = 'L'; break;\n        case 'D': frog.dir = 'R'; break;\n        case 'L': frog.dir = 'D'; break;\n        case 'R': frog.dir = 'U'; break;\n    }\n}\n\nvoid turn_right() {\n    switch (frog.dir) {\n        case 'U': frog.dir = 'R'; break;\n        case 'D': frog.dir = 'L'; break;\n        case 'L': frog.dir = 'U'; break;\n        case 'R': frog.dir = 'D'; break;\n    }\n}\n\nvoid move_left() {\n    turn_left();\n    move_forward();\n}\n\nvoid move_right() {\n    turn_right();\n    move_forward();\n}\n\nvoid solve() {\n    while (leaves_left > 1) {\n        move_forward();\n        if (leaves_left > 1) move_left();\n        if (leaves_left > 1) move_right();\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    initialize();\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int x, y;\n    char dir;\n    vector<vector<bool>> grid;\n    string path;\n};\n\nstring solve(int n, int m, int startX, int startY, char startDir, vector<vector<bool>> grid) {\n    queue<State> q;\n    unordered_set<string> visited;\n\n    State initial;\n    initial.x = startX;\n    initial.y = startY;\n    initial.dir = startDir;\n    initial.grid = grid;\n    initial.path = \"\";\n\n    q.push(initial);\n\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    char dirs[] = {'U', 'D', 'L', 'R'};\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        int leaves = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (current.grid[i][j]) leaves++;\n            }\n        }\n        if (leaves == 1) {\n            return current.path;\n        }\n\n        string stateKey = to_string(current.x) + \",\" + to_string(current.y) + \",\" + current.dir;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                stateKey += current.grid[i][j] ? \"1\" : \"0\";\n            }\n        }\n        if (visited.find(stateKey) != visited.end()) continue;\n        visited.insert(stateKey);\n\n        int dirIndex;\n        if (current.dir == 'U') dirIndex = 0;\n        else if (current.dir == 'D') dirIndex = 1;\n        else if (current.dir == 'L') dirIndex = 2;\n        else if (current.dir == 'R') dirIndex = 3;\n\n        for (int turn : {-1, 0, 1}) {\n            int newDirIndex = (dirIndex + turn + 4) % 4;\n            int nx = current.x + dx[newDirIndex];\n            int ny = current.y + dy[newDirIndex];\n\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && current.grid[nx][ny]) {\n                State next = current;\n                next.x = nx;\n                next.y = ny;\n                next.dir = dirs[newDirIndex];\n                next.grid[nx][ny] = false;\n                next.path += dirs[newDirIndex];\n                q.push(next);\n            }\n        }\n    }\n\n    return \"\";\n}\n\nint main() {\n    int n, m, startX, startY;\n    char startDir;\n    cin >> n >> m >> startX >> startY >> startDir;\n\n    vector<vector<bool>> grid(n, vector<bool>(m, false));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            char c;\n            cin >> c;\n            grid[i][j] = (c == '1');\n        }\n    }\n\n    string result = solve(n, m, startX, startY, startDir, grid);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FrogJumpSolver {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Up, Down, Left, Right\n    private static final char[] DIR_CHARS = {'U', 'D', 'L', 'R'};\n    private int rows, cols;\n    private boolean[][] grid;\n    private List<Character> path;\n\n    public List<Character> solve(int startX, int startY, int startDir, boolean[][] initialGrid) {\n        this.rows = initialGrid.length;\n        this.cols = initialGrid[0].length;\n        this.grid = new boolean[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            System.arraycopy(initialGrid[i], 0, this.grid[i], 0, cols);\n        }\n        this.path = new ArrayList<>();\n        dfs(startX, startY, startDir);\n        return path;\n    }\n\n    private boolean dfs(int x, int y, int dir) {\n        grid[x][y] = false; // Sink the current leaf\n        if (countLeaves() == 0) {\n            return true;\n        }\n\n        int[] forwardDir = DIRECTIONS[dir];\n        int[] leftDir = getLeftDir(dir);\n        int[] rightDir = getRightDir(dir);\n\n        int[][] possibleDirs = {forwardDir, leftDir, rightDir};\n        int[] originalDirOrder = {dir, getLeftDirIndex(dir), getRightDirIndex(dir)};\n\n        for (int i = 0; i < 3; i++) {\n            int[] move = possibleDirs[i];\n            int newX = x + move[0];\n            int newY = y + move[1];\n            if (isValid(newX, newY) && grid[newX][newY]) {\n                int newDir = originalDirOrder[i];\n                path.add(DIR_CHARS[newDir]);\n                if (dfs(newX, newY, newDir)) {\n                    return true;\n                }\n                path.remove(path.size() - 1);\n            }\n        }\n\n        grid[x][y] = true; // Backtrack\n        return false;\n    }\n\n    private int[] getLeftDir(int dir) {\n        if (dir == 0) return DIRECTIONS[2]; // Up -> Left\n        if (dir == 1) return DIRECTIONS[3]; // Down -> Right\n        if (dir == 2) return DIRECTIONS[1]; // Left -> Down\n        return DIRECTIONS[0]; // Right -> Up\n    }\n\n    private int[] getRightDir(int dir) {\n        if (dir == 0) return DIRECTIONS[3]; // Up -> Right\n        if (dir == 1) return DIRECTIONS[2]; // Down -> Left\n        if (dir == 2) return DIRECTIONS[0]; // Left -> Up\n        return DIRECTIONS[1]; // Right -> Down\n    }\n\n    private int getLeftDirIndex(int dir) {\n        if (dir == 0) return 2; // Up -> Left\n        if (dir == 1) return 3; // Down -> Right\n        if (dir == 2) return 1; // Left -> Down\n        return 0; // Right -> Up\n    }\n\n    private int getRightDirIndex(int dir) {\n        if (dir == 0) return 3; // Up -> Right\n        if (dir == 1) return 2; // Down -> Left\n        if (dir == 2) return 0; // Left -> Up\n        return 1; // Right -> Down\n    }\n\n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < rows && y >= 0 && y < cols;\n    }\n\n    private int countLeaves() {\n        int count = 0;\n        for (boolean[] row : grid) {\n            for (boolean cell : row) {\n                if (cell) count++;\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 21:17:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass FrogJumpPuzzle {\n    private static final int[] dx = {0, 0, -1, 1};\n    private static final int[] dy = {-1, 1, 0, 0};\n    private static final char[] dirNames = {'U', 'D', 'L', 'R'};\n\n    public static List<Character> solvePuzzle(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        List<Character> path = new ArrayList<>();\n\n        for (int startY = 0; startY < rows; startY++) {\n            for (int startX = 0; startX < cols; startX++) {\n                for (int startDir = 0; startDir < 4; startDir++) {\n                    int[][] gridCopy = copyGrid(grid);\n                    List<Character> currentPath = new ArrayList<>();\n                    \n                    if (solve(gridCopy, startY, startX, startDir, currentPath)) {\n                        return currentPath;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private static boolean solve(int[][] grid, int y, int x, int dir, List<Character> path) {\n        if (countLeaves(grid) == 1) {\n            return true;\n        }\n\n        for (int newDir = 0; newDir < 4; newDir++) {\n            int newY = y + dy[newDir];\n            int newX = x + dx[newDir];\n\n            if (isValidJump(grid, y, x, newY, newX)) {\n                int[][] gridCopy = copyGrid(grid);\n                gridCopy[y][x] = 0;\n                gridCopy[newY][newX] = 1;\n                \n                List<Character> newPath = new ArrayList<>(path);\n                newPath.add(dirNames[newDir]);\n\n                if (solve(gridCopy, newY, newX, newDir, newPath)) {\n                    path.addAll(newPath.subList(path.size(), newPath.size()));\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean isValidJump(int[][] grid, int fromY, int fromX, int toY, int toX) {\n        return toY >= 0 && toY < grid.length && \n               toX >= 0 && toX < grid[0].length && \n               grid[toY][toX] == 1 && \n               grid[fromY][fromX] == 1;\n    }\n\n    private static int countLeaves(int[][] grid) {\n        int count = 0;\n        for (int[] row : grid) {\n            for (int cell : row) {\n                if (cell == 1) count++;\n            }\n        }\n        return count;\n    }\n\n    private static int[][] copyGrid(int[][] grid) {\n        int[][] copy = new int[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            copy[i] = grid[i].clone();\n        }\n        return copy;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 1, 1},\n            {1, 1, 1},\n            {1, 1, 1}\n        };\n        List<Character> solution = solvePuzzle(grid);\n        System.out.println(solution);\n    }\n}",
    "timestamp": "2025-08-05 21:17:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_GRID 10\n#define MAX_MOVES 100\n\ntypedef struct {\n    int x, y;\n} Position;\n\ntypedef enum {\n    UP, DOWN, LEFT, RIGHT\n} Direction;\n\nint grid[MAX_GRID][MAX_GRID];\nint rows, cols;\nchar solution[MAX_MOVES];\nint solution_length;\n\nbool is_valid_pos(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == 1;\n}\n\nbool jump(int* x, int* y, Direction dir) {\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    int nx = *x + dx[dir];\n    int ny = *y + dy[dir];\n    int jx = nx + dx[dir];\n    int jy = ny + dy[dir];\n\n    if (is_valid_pos(nx, ny) && is_valid_pos(jx, jy)) {\n        grid[*x][*y] = 0;\n        grid[nx][ny] = 0;\n        *x = jx;\n        *y = jy;\n        grid[*x][*y] = 1;\n        return true;\n    }\n    return false;\n}\n\nchar dir_to_char(Direction dir) {\n    switch(dir) {\n        case UP: return 'U';\n        case DOWN: return 'D';\n        case LEFT: return 'L';\n        case RIGHT: return 'R';\n    }\n    return '?';\n}\n\nbool solve(int remaining_leaves, int x, int y, Direction current_dir) {\n    if (remaining_leaves == 1) return true;\n\n    for (Direction dir = UP; dir <= RIGHT; dir++) {\n        int temp_x = x, temp_y = y;\n        int old_x = x, old_y = y;\n        \n        if (jump(&temp_x, &temp_y, dir)) {\n            solution[solution_length++] = dir_to_char(dir);\n            \n            if (solve(remaining_leaves - 1, temp_x, temp_y, dir)) \n                return true;\n            \n            // Backtrack\n            solution_length--;\n            grid[temp_x][temp_y] = 0;\n            grid[old_x][old_y] = 1;\n            grid[(old_x + temp_x)/2][(old_y + temp_y)/2] = 1;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Input grid and initial position\n    scanf(\"%d %d\", &rows, &cols);\n    int start_x, start_y, leaves = 0;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n            if (grid[i][j] == 1) {\n                leaves++;\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    solution_length = 0;\n    for (Direction dir = UP; dir <= RIGHT; dir++) {\n        memcpy(grid_copy, grid, sizeof(grid));\n        if (solve(leaves, start_x, start_y, dir)) {\n            for (int i = 0; i < solution_length; i++)\n                printf(\"%c\", solution[i]);\n            printf(\"\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"No solution\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst char dirs[] = {'U', 'D', 'L', 'R'};\n\nstruct State {\n    vector<vector<int>> grid;\n    int x, y, dir;\n    string path;\n    int leafCount;\n};\n\nbool isValidMove(vector<vector<int>>& grid, int x, int y) {\n    return x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == 1;\n}\n\nbool solve(vector<vector<int>>& initialGrid) {\n    queue<State> q;\n    int rows = initialGrid.size();\n    int cols = initialGrid[0].size();\n    int totalLeaves = 0;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (initialGrid[i][j] == 1) {\n                for (int d = 0; d < 4; d++) {\n                    State start;\n                    start.grid = initialGrid;\n                    start.x = i;\n                    start.y = j;\n                    start.dir = d;\n                    start.leafCount = 0;\n                    start.path = \"\";\n\n                    for (int r = 0; r < rows; r++) {\n                        for (int c = 0; c < cols; c++) {\n                            if (start.grid[r][c] == 1) start.leafCount++;\n                        }\n                    }\n\n                    q.push(start);\n                }\n            }\n        }\n    }\n\n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n\n        if (curr.leafCount == 1) {\n            cout << curr.path << endl;\n            return true;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int newX = curr.x + dx[curr.dir] * (i == 0 ? 1 : (i == 1 ? 2 : 1));\n            int newY = curr.y + dy[curr.dir] * (i == 0 ? 1 : (i == 1 ? 2 : 1));\n            int midX = curr.x + dx[curr.dir] * (i == 0 ? 1 : (i == 1 ? 1 : 0));\n            int midY = curr.y + dy[curr.dir] * (i == 0 ? 1 : (i == 1 ? 1 : 0));\n\n            if (isValidMove(curr.grid, newX, newY) && isValidMove(curr.grid, midX, midY)) {\n                State next = curr;\n                next.grid[curr.x][curr.y] = 0;\n                next.grid[midX][midY] = 0;\n                next.grid[newX][newY] = 1;\n                next.x = newX;\n                next.y = newY;\n                next.dir = curr.dir;\n                next.leafCount--;\n                next.path += dirs[i];\n\n                q.push(next);\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n    vector<vector<int>> grid(R, vector<int>(C));\n\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    if (!solve(grid)) {\n        cout << \"No solution\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class FrogJumpSolver:\n    def __init__(self, grid, start, direction):\n        self.grid = grid\n        self.start = start\n        self.direction = direction\n        self.directions = ['U', 'D', 'L', 'R']\n        self.deltas = {\n            'U': (-1, 0),\n            'D': (1, 0),\n            'L': (0, -1),\n            'R': (0, 1)\n        }\n\n    def can_jump(self, position, direction):\n        x, y = position\n        dx, dy = self.deltas[direction]\n        nx, ny = x + dx, y + dy\n        return (0 <= nx < len(self.grid) and 0 <= ny < len(self.grid[0]) \n                and self.grid[nx][ny] == 'L')\n\n    def jump(self, position, direction):\n        x, y = position\n        dx, dy = self.deltas[direction]\n        nx, ny = x + dx, y + dy\n        self.grid[x][y] = '.'\n        self.grid[nx][ny] = 'F'\n        return (nx, ny)\n\n    def backtrack(self, position, direction, path):\n        if sum(row.count('L') for row in self.grid) == 0:\n            return path\n        \n        for turn in [-1, 0, 1]:\n            new_direction = self.directions[(self.directions.index(direction) + turn) % 4]\n            if self.can_jump(position, new_direction):\n                new_pos = self.jump(position, new_direction)\n                result = self.backtrack(new_pos, new_direction, path + new_direction)\n                if result:\n                    return result\n                # backtrack\n                nx, ny = new_pos\n                self.grid[nx][ny] = 'L'\n                self.grid[position[0]][position[1]] = 'F'\n\n        return None\n\n    def solve(self):\n        x, y = self.start\n        self.grid[x][y] = 'F'\n        return self.backtrack(self.start, self.direction, '')\n\n# Initialize grid, start position, and initial direction\ngrid = [\n    ['L', 'L', 'L'],\n    ['L', 'L', 'L'],\n    ['L', 'L', 'L'],\n]\n\nstart = (1, 1)  # Starting position of the frog\ninitial_direction = 'U'  # Initial facing direction\n\nsolver = FrogJumpSolver(grid, start, initial_direction)\nsolution = solver.solve()\n\nprint(solution)",
    "timestamp": "2025-08-13 05:44:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FrogJumpSolver {\n    private static final char[] DIRECTIONS = {'U', 'D', 'L', 'R'};\n    private static final int[][] MOVES = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    private static int startX, startY, startDir;\n    \n    public static void main(String[] args) {\n        char[][] pond = {\n            {'L', 'L', 'L'},\n            {'L', '.', 'L'},\n            {'.', 'L', 'F'}\n        };\n        \n        findFrog(pond);\n        \n        List<Character> solution = new ArrayList<>();\n        if (solve(pond, startX, startY, startDir, solution)) {\n            for (char move : solution) {\n                System.out.print(move);\n            }\n        } else {\n            System.out.println(\"No solution found.\");\n        }\n    }\n    \n    private static void findFrog(char[][] pond) {\n        for (int i = 0; i < pond.length; i++) {\n            for (int j = 0; j < pond[i].length; j++) {\n                if (pond[i][j] == 'F') {\n                    startX = i;\n                    startY = j;\n                    startDir = 0;  // Assuming frog starts facing 'up'\n                    pond[i][j] = 'L';  // Treat the 'F' as 'L' for uniformity\n                    return;\n                }\n            }\n        }\n    }\n    \n    private static boolean solve(char[][] pond, int x, int y, int dir, List<Character> path) {\n        pond[x][y] = '.';\n        \n        if (remainingLeaves(pond) == 1) {\n            return true;\n        }\n        \n        for (int i = 0; i < DIRECTIONS.length; i++) {\n            int newDir = (dir + i) % 4;\n            int newX = x + MOVES[newDir][0];\n            int newY = y + MOVES[newDir][1];\n            \n            if (canJump(pond, newX, newY)) {\n                path.add(DIRECTIONS[newDir]);\n                if (solve(pond, newX, newY, newDir, path)) {\n                    return true;\n                }\n                path.remove(path.size() - 1);\n            }\n        }\n        \n        pond[x][y] = 'L';\n        return false;\n    }\n    \n    private static boolean canJump(char[][] pond, int x, int y) {\n        return x >= 0 && x < pond.length && y >= 0 && y < pond[0].length && pond[x][y] == 'L';\n    }\n    \n    private static int remainingLeaves(char[][] pond) {\n        int count = 0;\n        for (int i = 0; i < pond.length; i++) {\n            for (int j = 0; j < pond[i].length; j++) {\n                if (pond[i][j] == 'L') count++;\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-13 05:45:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int x, y;\n} Position;\n\ntypedef struct {\n    Position pos;\n    char direction;\n} Frog;\n\ntypedef struct {\n    int width, height;\n    bool leaves[MAX_N][MAX_N];\n} Pond;\n\nvoid initPond(Pond *pond, int width, int height, char grid[MAX_N][MAX_N]) {\n    pond->width = width;\n    pond->height = height;\n    for (int y = 0; y < height; ++y) {\n        for (int x = 0; x < width; ++x) {\n            pond->leaves[y][x] = grid[y][x] == 'L';\n        }\n    }\n}\n\nbool isValidJump(Pond *pond, int x, int y) {\n    return x >= 0 && x < pond->width && y >= 0 && y < pond->height && pond->leaves[y][x];\n}\n\nvoid makeJump(Frog *frog, Pond *pond, char jump) {\n    int dx = 0, dy = 0;\n    switch (jump) {\n        case 'U':\n            dx = 0; dy = -1; break;\n        case 'D':\n            dx = 0; dy = 1; break;\n        case 'L':\n            dx = -1; dy = 0; break;\n        case 'R':\n            dx = 1; dy = 0; break;\n    }\n    pond->leaves[frog->pos.y][frog->pos.x] = false;\n    frog->pos.x += dx;\n    frog->pos.y += dy;\n    frog->direction = jump;\n}\n\nvoid findPath(Frog *frog, Pond *pond, char *path, int *pathIndex) {\n    while (true) {\n        if (isValidJump(pond, frog->pos.x, frog->pos.y - 1) && frog->direction != 'D') {\n            path[(*pathIndex)++] = 'U';\n            makeJump(frog, pond, 'U');\n        } else if (isValidJump(pond, frog->pos.x, frog->pos.y + 1) && frog->direction != 'U') {\n            path[(*pathIndex)++] = 'D';\n            makeJump(frog, pond, 'D');\n        } else if (isValidJump(pond, frog->pos.x - 1, frog->pos.y) && frog->direction != 'R') {\n            path[(*pathIndex)++] = 'L';\n            makeJump(frog, pond, 'L');\n        } else if (isValidJump(pond, frog->pos.x + 1, frog->pos.y) && frog->direction != 'L') {\n            path[(*pathIndex)++] = 'R';\n            makeJump(frog, pond, 'R');\n        } else {\n            break;\n        }\n    }\n}\n\nint main() {\n    int width = 5, height = 5;\n    char grid[MAX_N][MAX_N] = {\n        {'.', 'L', '.', 'L', '.'},\n        {'.', '.', '.', 'L', '.'},\n        {'L', 'L', 'L', 'L', 'L'},\n        {'.', '.', '.', '.', '.'},\n        {'L', '.', '.', '.', 'L'}\n    };\n\n    Pond pond;\n    initPond(&pond, width, height, grid);\n\n    Frog frog = {{2, 2}, 'R'};\n    char path[100];\n    int pathIndex = 0;\n\n    findPath(&frog, &pond, path, &pathIndex);\n\n    path[pathIndex] = '\\0';\n    printf(\"Path: %s\\n\", path);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:45:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_lotus_pond(grid):\n    def is_valid_move(x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1\n\n    def count_leaves():\n        return sum(sum(row) for row in grid)\n\n    def dfs(x, y, direction, path):\n        if count_leaves() == 1:\n            return path\n\n        directions = {\n            'U': [(-1, 0), (-1, -1), (-1, 1)],\n            'D': [(1, 0), (1, -1), (1, 1)],\n            'L': [(0, -1), (-1, -1), (1, -1)],\n            'R': [(0, 1), (-1, 1), (1, 1)]\n        }\n\n        for dx, dy in directions[direction]:\n            nx, ny = x + dx, y + dy\n            mx, my = x + 2*dx, y + 2*dy\n\n            if is_valid_move(nx, ny) and is_valid_move(mx, my):\n                grid[x][y] = 0\n                grid[nx][ny] = 0\n                grid[mx][my] = 1\n                \n                result = dfs(mx, my, ['U', 'D', 'L', 'R'][['D', 'U', 'R', 'L'].index(direction)], \n                             path + [['U', 'D', 'L', 'R'][['D', 'U', 'R', 'L'].index(direction)]])\n                \n                if result:\n                    return result\n                \n                grid[x][y] = 1\n                grid[nx][ny] = 1\n                grid[mx][my] = 0\n\n        return None\n\n    for x in range(len(grid)):\n        for y in range(len(grid[0])):\n            if grid[x][y] == 1:\n                for direction in ['U', 'D', 'L', 'R']:\n                    result = dfs(x, y, direction, [])\n                    if result:\n                        return result\n\n    return None\n\n# Example usage\ngrid = [\n    [1, 1, 0, 1],\n    [0, 1, 1, 0],\n    [1, 0, 1, 1]\n]\nprint(solve_lotus_pond(grid))",
    "timestamp": "2025-08-13 05:45:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_frog_jump(grid, start_pos, start_dir):\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    dir_order = ['U', 'R', 'D', 'L']\n    \n    def get_new_dir(current_dir, turn):\n        idx = dir_order.index(current_dir)\n        if turn == 'L':\n            return dir_order[(idx - 1) % 4]\n        elif turn == 'R':\n            return dir_order[(idx + 1) % 4]\n        else:\n            return current_dir\n    \n    def is_valid(pos, grid):\n        return 0 <= pos[0] < len(grid) and 0 <= pos[1] < len(grid[0]) and grid[pos[0]][pos[1]] == 1\n    \n    def count_leaves(grid):\n        return sum(sum(row) for row in grid)\n    \n    path = []\n    current_pos = start_pos\n    current_dir = start_dir\n    grid_copy = [row.copy() for row in grid]\n    \n    while count_leaves(grid_copy) > 1:\n        for move in ['F', 'L', 'R']:\n            new_dir = get_new_dir(current_dir, move)\n            dx, dy = directions[new_dir]\n            new_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            \n            if is_valid(new_pos, grid_copy):\n                grid_copy[current_pos[0]][current_pos[1]] = 0\n                current_pos = new_pos\n                current_dir = new_dir\n                path.append(new_dir)\n                break\n    \n    return ''.join(path)\n\n# Example usage:\n# grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n# start_pos = (1, 1)\n# start_dir = 'U'\n# print(solve_frog_jump(grid, start_pos, start_dir))",
    "timestamp": "2025-08-13 05:46:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nstruct State {\n    int x, y;\n    char direction;\n    string moves;\n};\n\nbool isValidMove(int x, int y, int rows, int cols, vector<vector<bool>>& grid) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y];\n}\n\nstring solve(vector<vector<bool>>& grid, int startX, int startY, char startDirection) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    stack<State> dfsStack;\n    dfsStack.push({startX, startY, startDirection, \"\"});\n\n    vector<vector<pair<int, int>>> directions = {\n        {{-1, 0}, {-1, -1}, {-1, 1}}, // U\n        {{1, 0}, {1, -1}, {1, 1}},    // D\n        {{0, -1}, {1, -1}, {-1, -1}}, // L\n        {{0, 1}, {1, 1}, {-1, 1}}     // R\n    };\n\n    string possibleMoves = \"UDLR\";\n\n    while (!dfsStack.empty()) {\n        State current = dfsStack.top();\n        dfsStack.pop();\n\n        grid[current.x][current.y] = false;\n        bool found = false;\n        for (int i = 0; i < 3; ++i) {\n            int ndx, directionIndex;\n            switch (current.direction) {\n                case 'U': directionIndex = 0; break;\n                case 'D': directionIndex = 1; break;\n                case 'L': directionIndex = 2; break;\n                case 'R': directionIndex = 3; break;\n            }\n            ndx = directionIndex;\n            \n            int newX = current.x + directions[directionIndex][i].first;\n            int newY = current.y + directions[directionIndex][i].second;\n\n            if (isValidMove(newX, newY, rows, cols, grid)) {\n                found = true;\n                char newDir = possibleMoves[ndx];\n                string newMoves = current.moves + newDir;\n                dfsStack.push({newX, newY, newDir, newMoves});\n            }\n        }\n        \n        if (!found) {\n            int count = 0;\n            for (auto& row : grid) {\n                for (bool leaf : row) {\n                    if (leaf) count++;\n                }\n            }\n            if (count == 1) {\n                return current.moves;\n            }\n        }\n\n        grid[current.x][current.y] = true;\n    }\n\n    return \"No solution\";\n}\n\nint main() {\n    int rows, cols, startX, startY;\n    char startDirection;\n    cin >> rows >> cols >> startX >> startY >> startDirection;\n    vector<vector<bool>> grid(rows, vector<bool>(cols));\n\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            int val;\n            cin >> val;\n            grid[i][j] = val == 1;\n        }\n    }\n\n    string result = solve(grid, startX, startY, startDirection);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:27:52"
  }
]