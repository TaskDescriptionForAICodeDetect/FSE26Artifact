[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\ntemplate<typename T>\nvector<vector<T>> keisann(const vector<vector<T>>l, const vector<vector<T>>r) {\n\tvector<vector<T>>ans(l.size(), vector<T>(r[0].size()));\n\tassert(l[0].size() == r.size());\n\tfor (unsigned int h = 0; h < l.size(); ++h) {\n\t\tfor (unsigned int i = 0; i < r.size(); ++i) {\n\t\t\tfor (unsigned int w = 0; w < r[0].size(); ++w) {\n\t\t\t\n\t\t\t\tans[h][w] +=l[h][i] * r[i][w];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\ntemplate<typename T>\nvector<vector<T>>powgyou(vector<vector<T>>a, const long long int n) {\n\tassert(a.size() == a[0].size());\n\tif (!n) {\n\t\tvector<vector<T>>e(a.size(), vector<T>(a[0].size()));\n\t\tfor (unsigned int i = 0; i < a.size(); ++i) {\n\t\t\te[i][i] = 1;\n\t\t}\n\t\treturn e;\n\t}\n\tif (n == 1)return a;\n\telse {\n\t\tvector<vector<T>>ans(a.size(), vector<T>(a[0].size(), 0));\n\t\tans = powgyou(a, n / 2);\n\t\tans = keisann(ans, ans);\n\t\tif (n % 2) {\n\t\t\tans = keisann(ans, a);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\n\n\nlong long int powint(long long int a, int b) {\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\telse {\n\t\tlong long int ans = 1;\n\t\tlong long int c = powint(a, b / 2);\n\t\tans *= c*c;\n\t\tans *= (b % 2) ? a : 1;\n\t\treturn ans;\n\t}\n\t\n}\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\n\nvector<vector<int>>fd(10, vector<int>(10,0));\nvector<int>ans;\n\nint aok(vector<vector<int>>a, const int ax,const int ay,const int away,int count) {\n\tif (count == 0)return 1;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tif ((i + 2) % 4 == away) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint nx(ax), ny(ay);\n\n\t\twhile (1) {\n\t\t\tnx += dx[i]; ny += dy[i];\n\t\t\tif (nx >= 10 || nx < 0 || ny>=10 || ny < 0)break;\n\t\t\tif (a[ny][nx]) {\n\t\t\t\ta[ny][nx] = 0;\n\t\t\t\tif (aok(a, nx, ny, i,count-1) != -1) {\n\t\t\t\t\tans.push_back(i);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[ny][nx] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ta[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void) {\n\tint H, W; cin >> H >> W;\n\tint way;\n\tint count = 0;\n\tint ax, ay;\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '.') {\n\t\t\t\tfd[i][j] = 0;\n\t\t\t}\n\t\t\telse if (st[j] == 'o') {\n\t\t\t\tfd[i][j] = 1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tax = j; ay = i;\n\t\t\t\tfd[i][j] = 0;\n\t\t\t\tif (st[j] == 'U') {\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'D') {\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'L') {\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taok(fd, ax, ay, way, count);\n\treverse(ans.begin(), ans.end());\n\tfor (int i = 0; i < ans.size(); ++i) {\n\t\tif (ans[i] == 0) {\n\t\t\tcout << 'L';\n\t\t}\n\t\telse if (ans[i] == 1) {\n\t\t\tcout << 'D';\n\t\t}\n\t\telse if (ans[i] == 2) {\n\t\t\tcout << 'R';\n\t\t}\n\t\telse {\n\t\t\tcout << 'U';\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}\n\n/*\n4\n0 4\n7 12\n6 8\n4 6\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 10;\nstatic const int di[4] = {0, -1, 0, 1};\nstatic const int dj[4] = {1, 0, -1, 0};\nstatic const string D = \"RULD\";\n\nint H, W, sum;\nchar G[MAX][MAX];\n\nbool hasLeaf(int pi, int pj, int r, int &ni, int &nj){\n  do{\n      pi += di[r];\n      pj += dj[r];\n      if ( pi < 0 || pj < 0 || pi >= H ||  pj >= W ) break;\n      if ( G[pi][pj] == 'o' ) {\n\t  ni = pi;\n\t  nj = pj;\n\t  return true;\n      }\n  } while(1);\n  return false;\n}\n\nbool dfs(int pi, int pj, int dir, vector<int> path, int rem){\n  if ( rem == 1 ){\n      cout << path.size() << endl;\n      rep(i, path.size()) cout << D[path[i]];    \n      cout << endl;\n      return true;\n  }\n\n  rep(r, 4){\n    if ( (r+2)%4 == dir ) continue;\n    int ni, nj;\n    if ( hasLeaf(pi, pj, r, ni, nj) ){\n\tvector<int> np = path;\n\tG[pi][pj] = '.';\n\tnp.push_back(r);\n\tif (dfs(ni, nj, r, np, rem-1)) return true;\n\tG[pi][pj] = 'o';\n    }\n  }\n  return false;\n}\n\nint getDir(char c){\n    rep(i, D.size()) if ( c == D[i] ) return i;\n}\n\nmain(){\n  int si, sj, dir;\n  cin >> H >> W;\n  sum = 0;\n  rep(i, H) rep(j, W) {\n    cin >> G[i][j];\n    if ( G[i][j] != 'o' && G[i][j] != '.' ){\n      dir = getDir(G[i][j]);\n      si = i; sj = j;\n      G[i][j] = 'o';\n    }\n    if ( G[i][j] == 'o' ) sum++;\n  }\n  vector<int> P;\n  dfs(si, sj, dir, P, sum);\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct S {\n  int x, y, d;\n  S() {}\n  S(int x, int y, int d) : x(x), y(y), d(d) {}\n};\n\nconst int MAX_H = 11;\nconst int MAX_W = MAX_H;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nmap<char,int> conv1;\nmap<int,char> conv2;\nint path[300];\n\nint H, W;\nchar G[MAX_H][MAX_W];\n\nvoid make() {\n  conv1['R'] = 0;\n  conv1['D'] = 1;\n  conv1['L'] = 2;\n  conv1['U'] = 3;\n  conv2[0] = 'R';\n  conv2[1] = 'D';\n  conv2[2] = 'L';\n  conv2[3] = 'U';\n}\n\nint canJump(int x, int y, int d) {\n  for(int l = 1; ; ++l) {\n    int nx = x + l*dx[d];\n    int ny = y + l*dy[d];\n    if(nx < 0 || nx >= W) return -1;\n    if(ny < 0 || ny >= H) return -1;\n    if(G[ny][nx] == '.') continue;\n    if(G[ny][nx] == 'o') return l;\n  }\n  return -1;\n}\n\nbool rec(int x, int y, int d, int max_step, int step) {\n  if(step == max_step) {\n/*\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) cout << G[i][j];\n      cout << endl;\n    }\n*/\n    return true;\n  }\n  for(int k = -1; k <= 1; ++k) {\n    int nd = (d+k+4)%4;\n    int l = canJump(x,y,nd);\n    if(l == -1) continue;\n    int nx = x + l*dx[nd];\n    int ny = y + l*dy[nd];\n    G[y][x] = '.';\n    path[step] = nd;\n    if(rec(nx,ny,nd,max_step, step+1)) return true;\n    G[y][x] = 'o';\n  }\n  return false;\n}\n\nint count() {\n  int cnt = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(G[i][j] == 'o') ++cnt;\n    }\n  }\n  return cnt;\n}\n\nvoid solve(int sx, int sy, int sd) {\n  int step = count() - 1;\n  rec(sx,sy,sd,step,0);\n  for(int i = 0; i < step; ++i)\n    cout << conv2[path[i]];\n  cout << endl;\n}\n\n\nint main() {\n  make();\n  while(cin >> H >> W && (H | W)) {\n    int sx, sy, sd;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] != '.' && G[i][j] != 'o') {\n          sx = j;\n          sy = i;\n          sd = conv1[G[i][j]];\n          G[i][j] = 'o';\n        }\n      }\n    }\n    solve(sx,sy,sd);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint h, w, sx, sy, cnt, arrow;\nchar s[12][12];\nbool flag[12][12];\nchar ans[105];\nint ok[4][4];\n\nbool ava(int x, int y) {\n\treturn (x >= 1 && y >= 1 && x <= h && y <= w);\n}\n\nbool dfs(int x, int y, int arrow, int remain) {\n\tif (remain == 0) return 1;\n\tflag[x][y] = 0;\n\tfor (int k = 0; k < 4; k ++) if (ok[arrow][k]) {\n\t\tint tx = x;\n\t\tint ty = y;\n\t\twhile (ava(tx + dx[k], ty + dy[k])) {\n\t\t\tif (flag[tx + dx[k]][ty + dy[k]]) {\n\t\t\t\tans[cnt - remain + 1] = k;\n\t\t\t\tif (dfs(tx + dx[k], ty + dy[k], k, remain - 1)) {\n//\t\t\t\t\tprintf(\"%d %d %d\\n\", tx + dx[k], ty + dy[k], remain - 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += dx[k];\n\t\t\tty += dy[k];\n\t\t}\n\t}\n\tflag[x][y] = 1;\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 1; i <= h; i ++) scanf(\"%s\", s[i] + 1);\n\tok[0][0] = ok[0][1] = ok[0][3] = 1;\n\tok[1][0] = ok[1][1] = ok[1][2] = 1;\n\tok[2][1] = ok[2][2] = ok[2][3] = 1;\n\tok[3][0] = ok[3][2] = ok[3][3] = 1;\n\tfor (int i = 1; i <= h; i ++)\n\t\tfor (int j = 1; j <= w; j ++) {\n\t\t\tif (s[i][j] == 'o') {\n\t\t\t\tflag[i][j] = true;\n\t\t\t\tcnt ++;\n\t\t\t} else if (s[i][j] != '.') {\n\t\t\t\t\tif (s[i][j] == 'U') arrow = 3;\n\t\t\t\t\tif (s[i][j] == 'D') arrow = 1;\n\t\t\t\t\tif (s[i][j] == 'L') arrow = 2;\n\t\t\t\t\tif (s[i][j] == 'R') arrow = 0;\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t}\n\tdfs(sx, sy, arrow, cnt);\n\tfor (int i = 1; i <= cnt; i ++) {\n\t\tif (ans[i] == 0) ans[i] = 'R';\n\t\tif (ans[i] == 1) ans[i] = 'D';\n\t\tif (ans[i] == 2) ans[i] = 'L';\n\t\tif (ans[i] == 3) ans[i] = 'U';\n\t}\n\tprintf(\"%s\\n\", ans + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\nvector<char> ans;\nchar field[100][100];\n\nchar dir2char[4] = {'U', 'R', 'D', 'L'};\nint char2dir[256];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint h, w;\n\nbool dfs(int x, int y, int dir, int rem) {\n  if (rem == 0) return true;\n\n  field[y][x] = '.';\n  rep(ndir, 4) {\n    if ((dir - ndir + 4) % 4 == 2) continue;\n    int ny = y + dy[ndir];\n    int nx = x + dx[ndir];\n    while (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != 'o') {\n      ny += dy[ndir];\n      nx += dx[ndir];\n    }\n\n    if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n      ans.push_back(dir2char[ndir]);\n      if (dfs(nx, ny, ndir, rem-1)) return true;\n      ans.pop_back();\n    }\n  }\n  field[y][x] = 'o';\n  return false;\n}\n\n\nint main() {\n  cin >> h >> w;\n  int initX, initY, initDir;\n  int numLeaf = 0;\n  rep (di, 4) char2dir[dir2char[di]] = di;\n  rep(i,h) rep(j,w) {\n    cin >> field[i][j];\n    if (field[i][j] == 'o') numLeaf++;\n    else if (field[i][j] != '.') {\n      initY = i;\n      initX = j;\n      initDir = char2dir[field[i][j]];\n    }\n  }\n  dfs(initX, initY, initDir, numLeaf);\n  cout << string(ans.begin(), ans.end()) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define int long long\n\nchar direction[4] = {'U', 'R', 'D', 'L'};\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\nchar A[11][11];\nbool B[11][11];\nint H, W;\nstring ans;\nint sum = 0;\nbool dfs(int x, int y, int cnt, int dir) {\n    // cout << x << \" \" << y << \" \" << direction[dir] << endl;\n    B[x][y] = false;\n    if (cnt == sum) {\n        ans += direction[dir];\n        return true;\n    } else {\n        REP(i, 3) {\n            int nd = (dir - 1 + i + 4) % 4;\n            int nx = x;\n            int ny = y;\n            while (true) {\n                nx += dx[nd];\n                ny += dy[nd];\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) break;\n                if (B[nx][ny]) {\n                    if (dfs(nx, ny, cnt + 1, nd)) {\n                        ans += direction[dir];\n                        return true;\n                    };\n                    break;\n                }\n            }\n        }\n    }\n    B[x][y] = true;\n    return false;\n}\nbool solve() {\n    cin >> H >> W;\n    int sx = 0, sy = 0;\n    int sd = 0;\n    REP(i, H) {\n        REP(j, W) {\n            cin >> A[i][j];\n            if (A[i][j] == 'o') {\n                B[i][j] = true;\n                sum++;\n            } else\n                B[i][j] = false;\n            REP(k, 4) {\n                if (A[i][j] == direction[k]) {\n                    sd = k;\n                    sx = i, sy = j;\n                }\n            }\n        }\n    }\n    dfs(sx, sy, 0, sd);\n    reverse(ans.begin(), ans.end());\n    FOR(i, 1, ans.size()) cout << ans[i];\n    cout << endl;\n}\nsigned main() {\n    // while (solve())\n    //     ;\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/* 2012-12-07T15:16:10 */\n#define DEBUG_ON_\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#define dump(x)\n#define dumpf()\n#define dumpv(x)\n#define where()\n#define show_bits(b, s)\n#endif\n\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { IFC(s[i] == ' '); if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n/*}}}*/\n\nint dx[] = {1, 0, -1, 0}; int dy[] = {0, -1, 0, 1};\nenum dir {\n\tRIGHT, UP, LEFT, DOWN\n};\n\nstruct frog {\n\tint x, y;\n\tdir d;\n};\n\n#define VC vector<char>\n#define VVC vector< vector<char> >\n\nint H, W;\nVVC field;\nfrog frg;\nint n_leaves = 1;\nVC path;\n\nvoid print_field() {\n\tREP (i, H) {\n\t\tREP (j, W) {\n\t\t\tcerr << field[i][j];\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nvoid clear ()\n{\n\tREP (i, path.size()) {\n\t\tcout << path[i];\n\t}\n\tcout << endl;\n\texit(0);\n}\n\nPII find_leaf(dir d)\n{\n\tint j = frg.x, i = frg.y;\n\ti += dy[d], j += dx[d];\n\twhile (RANGE(0, i, H-1) && RANGE(0, j, W-1)) {\n\t\tdprt(\"(dir %d)search: [%d][%d] -> %c\\n\", d, i, j, field[i][j]);\n\t\tif (field[i][j] == 'o') {\n\t\t\treturn MP(i, j);\n\t\t}\n\t\ti += dy[d], j += dx[d];\n\t}\n\treturn MP(-1, -1);\n}\n\nvoid jump ()\n{\n\t--n_leaves;\n\tprint_field();\n\tWAIT();\n\tif (n_leaves == 0) {\n\t\tcerr << \"CLEAR!\" << endl;\n\t\tclear();\n\t}\n\tint savex = frg.x, savey = frg.y;\n\tdir saved = frg.d;\n\tif (frg.d != DOWN) {\n\t\tPII p = find_leaf(UP);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = UP;\n\t\t\tpath.PB('U');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO UP\" << \" \" << p.F << \", \" << p.S << endl;\n\t\t\tjump();\n\t\t\t++n_leaves;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for up\" << endl;\n\t\t}\n\t}\n\tif (frg.d != UP) {\n\t\tPII p = find_leaf(DOWN);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = DOWN;\n\t\t\tpath.PB('D');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO DOWN\" << \" \" << p.F << \", \" << p.S << endl;\n\t\t\tjump();\n\t\t\t++n_leaves;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for down\" << endl;\n\t\t}\n\t}\n\tif (frg.d != LEFT) {\n\t\tPII p = find_leaf(RIGHT);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = RIGHT;\n\t\t\tpath.PB('R');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO RIGHT\" << \" \" << p.F << \", \" << p.S << endl;\n\t\t\tjump();\n\t\t\t++n_leaves;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for right\" << endl;\n\t\t}\n\t}\n\tif (frg.d != RIGHT) {\n\t\tPII p = find_leaf(LEFT);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = LEFT;\n\t\t\tpath.PB('L');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO LEFT\" << \" \" << p.F << \", \" << p.S << endl;\n\t\t\tjump();\n\t\t\t++n_leaves;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for left\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tcin >> H >> W;\n\tfield = VVC(H, VC(W));\n\tREP (i, H) {\n\t\tREP (j, W) {\n\t\t\tcin >> field[i][j];\n\t\t\tswitch (field[i][j]) {/*{{{*/\n\t\t\t\tcase 'U':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = UP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = DOWN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = RIGHT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = LEFT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\t++n_leaves;\n\t\t\t\t\tbreak;\n\t\t\t}/*}}}*/\n\t\t}\n\t}\n\tdprt(\"Start: [%d][%d]\\n\", frg.y, frg.x);\n\tjump();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n\n\nint H,W;\nchar c[10][10];\nint gr[10][10];\n\nstring dir = \"LURD\";\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\nint usd[32];\n\nint getIndex(int x,int y,int dx,int dy){\n\tx += dx;\n\ty += dy;\n\twhile( !(x < 0 || y < 0 || x >= W || y >= H) ){\n\t\tif( gr[y][x] != -1 && usd[gr[y][x]] == 0 ){\n\t\t\treturn gr[y][x];\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\t//cout << x << \" \" << y << \"(\" << dx << \" \" << dy << \")\" << endl;\n\treturn -1;\n}\nint kx[32];\nint ky[32];\nint done2[32];\nint test(int g,int d){\n\tif( done2[g]++ ) return 0;\n\tint ans = 1;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( i == 2 ) continue;\n\t\tint p = getIndex(kx[g],ky[g],dx[(d+i)&3],dy[(d+i)&3]);\n\t\t//cout << g << \" \" << dir[(d+i)&3] << \" \" << p << endl;\n\t\tif( p == -1 ) continue;\n\t\tans += test(p,(d+i)&3);\n\t}\n\treturn ans;\n}\nchar doit[32];\nint cnt = 0;\n\nint dfs(int g,int d,int r){\n\tif( r == 1 ){\n\t\tcout << doit << endl;\n\t\texit(0);\n\t}\n\tmemset(done2,0,sizeof(done2));\n\tint w = test(g,d);\n\tif( w != r ){\n\t\treturn 0;\n\t}\n\tusd[g] = 1;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tdoit[cnt-r] = dir[(d+i)&3];\n\t\tif( i == 2 ) continue;\n\t\tint p = getIndex(kx[g],ky[g],dx[(d+i)&3],dy[(d+i)&3]);\n\t\tif( p == -1 ) continue;\n\t\tdfs(p,(d+i)&3,r-1);\n\t}\n\tusd[g] = 0;\n}\nint main(){\n\tmemset(gr,-1,sizeof(gr));\n\tcin >> H >> W;\n\tint sd,sp;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] != '.' ){\n\t\t\t\tkx[cnt] = j;\n\t\t\t\tky[cnt] = i;\t\t\t\t\n\t\t\t\tgr[i][j] = cnt++;\n\t\t\t\t\n\t\t\t\tif( c[i][j] != 'o' ){\n\t\t\t\t\tsd = dir.find(c[i][j]);\n\t\t\t\t\tsp = cnt-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sp,sd,cnt);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint h,w;\nchar field[11][11];\nint sang;\nint sx,sy;\nint leaf;\nint rec[1001];\nbool fin;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\nchar chs[1001];\nint rev[1001];\n\nvoid dfs(int cx,int cy,int cang,int cnt){\n\tif(fin)return;\n\tif(leaf==cnt){\n\t\tfin=true;\n\t\tfor(int i=0;i<leaf;i++)cout<<chs[rec[i]];\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tif(i!=(cang+2)%4){\n\t\t\tfor(int j=1;;j++){\n\t\t\t\tint ny=cy+dy[i]*j;\n\t\t\t\tint nx=cx+dx[i]*j;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='o'){\n\t\t\t\t\t\tfield[ny][nx]='.';\n\t\t\t\t\t\trec[cnt]=i;\n\t\t\t\t\t\tdfs(nx,ny,i,cnt+1);\n\t\t\t\t\t\tif(fin)return;\n\t\t\t\t\t\tfield[ny][nx]='o';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tchs[0]='U';\n\tchs[1]='R';\n\tchs[2]='D';\n\tchs[3]='L';\n\trev['U']=0;\n\trev['R']=1;\n\trev['D']=2;\n\trev['L']=3;\n\n\tcin>>h>>w;\n\tfin=false;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='o')leaf++;\n\t\t\telse if(field[i][j]!='.'&&field[i][j]!='o'){\n\t\t\t\tsang=rev[field[i][j]];\n\t\t\t\tfield[i][j]='.';\n\t\t\t\tsx=j;sy=i;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sx,sy,sang,0);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nchar g[10][11];\nint nl;\nstring ans;\nint H,W;\n\nbool dfs(int py,int px,int dir){\n  if(ans.size()==nl-1)return true;\n  g[py][px]='.';\n  for(int k=0;k<4;k++){\n    if(k==(dir^2))continue;\n    int y=py,x=px;\n    for(;;){\n      static const int dy[]={-1,0,1,0};\n      static const int dx[]={0,1,0,-1};\n      y+=dy[k];\n      x+=dx[k];\n      if(y<0||H<=y||x<0||W<=x){\n\tbreak;\n      }else if(g[y][x]!='.'){\n\tans+=\"URDL\"[k];\n\tif(dfs(y,x,k))return true;\n\tans.resize(ans.size()-1);\n\tbreak;\n      }\n    }\n  }\n  g[py][px]='o';\n  return false;\n}\n\n\nint main(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    cin>>g[i];\n  }\n  int x,y,dir;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(g[i][j]!='.'){\n\tnl++;\n\tif(g[i][j]!='o'){\n\t  y=i;\n\t  x=j;\n\t  string D=\"URDL\";\n\t  dir=find(begin(D),end(D),g[i][j])-begin(D);\n\t}\n      }\n    }\n  }\n  dfs(y,x,dir);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 10;\nstatic const int di[4] = {0, -1, 0, 1};\nstatic const int dj[4] = {1, 0, -1, 0};\nstatic const string D = \"RULD\";\n\nint H, W, sum;\nchar G[MAX][MAX];\n\nbool hasLeaf(int pi, int pj, int r, int &ni, int &nj){\n  do{\n      pi += di[r];\n      pj += dj[r];\n      if ( pi < 0 || pj < 0 || pi >= H ||  pj >= W ) break;\n      if ( G[pi][pj] == 'o' ) {\n\t  ni = pi;\n\t  nj = pj;\n\t  return true;\n      }\n  } while(1);\n  return false;\n}\n\nbool dfs(int pi, int pj, int dir, vector<int> path, int rem){\n  if ( rem == 1 ){\n      rep(i, path.size()) cout << D[path[i]];    \n      cout << endl;\n      return true;\n  }\n\n  rep(r, 4){\n    if ( (r+2)%4 == dir ) continue;\n    int ni, nj;\n    if ( hasLeaf(pi, pj, r, ni, nj) ){\n\tvector<int> np = path;\n\tG[pi][pj] = '.';\n\tnp.push_back(r);\n\tif (dfs(ni, nj, r, np, rem-1)) return true;\n\tG[pi][pj] = 'o';\n    }\n  }\n  return false;\n}\n\nint getDir(char c){\n    rep(i, D.size()) if ( c == D[i] ) return i;\n}\n\nmain(){\n  int si, sj, dir;\n  cin >> H >> W;\n  sum = 0;\n  rep(i, H) rep(j, W) {\n    cin >> G[i][j];\n    if ( G[i][j] != 'o' && G[i][j] != '.' ){\n      dir = getDir(G[i][j]);\n      si = i; sj = j;\n      G[i][j] = 'o';\n    }\n    if ( G[i][j] == 'o' ) sum++;\n  }\n  vector<int> P;\n  dfs(si, sj, dir, P, sum);\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\n\nint init_dic(int x,int y,\n\t    map<P,int>& dic){\n  if(dic.find(P(x,y)) == dic.end()){\n    int idx = dic.size();\n    dic[P(x,y)] = idx;\n  }\n  return dic[P(x,y)];\n}\n\nvoid fill_dic(int W,int H,map<P,int>& dic){\n  for(int x=0;x<=W;x++){\n    for(int y=0;y<=H;y++){\n      if(dic.find(P(x,y)) == dic.end()){\n\tdic[P(x,y)] = -1;\n      }\n    }\n  }\n}\n\nclass State{\npublic:\n  int x;\n  int y;\n  int dir;\n  int remaining;\n  int cost;\n  vector<char> route;\n  State(int _x,int _y,int _dir,int _remaining,int _cost,const vector<char>& _r)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost),route(_r) {}\n  State(int _x,int _y,int _dir,int _remaining,int _cost)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[101][101];\n    int sx,sy;\n    int dir;\n    int init_state=0;\n    map<P,int> dic;\n\n    for(int y=0;y<H;y++){\n      char buf[101];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = buf[x];\n\tif(buf[x] == 'U' || buf[x] == 'R'\n\t   || buf[x] == 'D' || buf[x] == 'L'){\n\t  sx = x;\n\t  sy = y;\n\t  const char dirs[4] = {'U','R','D','L'};\n\t  for(int i=0;i<4;i++){\n\t    if(dirs[i] == buf[x]){\n\t      dir = i;\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(buf[x] == 'o'){\n\t  init_state |= (1<<init_dic(x,y,dic));\n\t}\n      }\n    }\n    \n    fill_dic(W,H,dic);\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,dir,init_state,0));\n\n    set<int> visited[101][101][4];\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(visited[s.x][s.y][s.dir].count(s.remaining) > 0) continue;\n      visited[s.x][s.y][s.dir].insert(s.remaining);\n\n      // cout << __builtin_popcount(s.remaining) << endl;\n      if(__builtin_popcount(s.remaining) == 1){\n\tconst char dirs[4] = {'U','R','D','L'};\n\tfor(int i=0; i<s.route.size(); i++){\n\t  printf(\"%c\",dirs[s.route[i]]);\n\t}\n\tprintf(\"\\n\");\n      }\n\n      for(int i=0;i<4;i++){\n\tif(i == (s.dir + 2) % 4) continue;\n\n\tint dx,dy;\n\tfor(int j=1;j<=max(H,W);j++){\n\t  dx = s.x + tx[i] * j;\n\t  dy = s.y + ty[i] * j;\n\t  if(dx < 0 || dy < 0 || dx >= W || dy >= H ) continue;\n\t  if(dic[P(dx,dy)] == -1) continue;\n\t  \n\t  if(s.remaining & (1<<dic[P(dx,dy)])){\n\t    int next = s.remaining & ~(1<<dic[P(s.x,s.y)]);\n\t    vector<char> next_route = s.route;\n\t    next_route.push_back(i);\n\t    que.push(State(dx,dy,i,next,s.cost+1,next_route));\n\t    break;\n\t  }\n\t}\n\t// else if(i != s.dir){\n\t//   dx = s.x + tx[i];\n\t//   dy = s.y + ty[i];\n\t//   if(dx < 0 || dy < 0 || dx >= W || dy >= H ) continue;\n\t//   if(dic[P(dx,dy)] == -1) continue;\n\t//   if(s.remaining & (1<<dic[P(dx,dy)])){\n\t//     int next = s.remaining & ~(1<<dic[P(s.x,s.y)]);\n\t//     que.push(State(dx,dy,i,next,s.cost+1));\n\t//   }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstruct data{\n\tint next[4],cnt;\n\tdata(int prx=-1,int nex=-1,int pry=-1,int ney=-1){\n\t\tnext[0]=prx;\n\t\tnext[2]=nex;\n\t\tnext[1]=pry;\n\t\tnext[3]=ney;\n\t\tcnt=0;\n\t}\n};\nint h,w;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstring dirchar=\"RDLU\";\nint fie[11][11];\nint s,sdir;\nint cnt;\nstring res;\nvoid dfs(int v,int dir,vector<data> dat,string str){\n\tif(str.size()==cnt-1){\n\t\tres=str;\n\t\treturn;\n\t}\n\tfor(int i=-1;i<=1;i++){\n\t\tint ndir=(dir+4+i)%4;\n\t\tif(dat[v].next[ndir]!=-1){\n\t\t\tvector<data> nex;\n\t\t\tnex=dat;\n\t\t\tint f=nex[v].next[ndir];\n\t\t\tint t=nex[v].next[(ndir+2)%4];\n\t\t\tif(t!=-1){\n\t\t\t\tnex[t].next[ndir]=f;\n\t\t\t\tif(f==-1)nex[t].cnt--;\n\t\t\t\tif(nex[t].cnt==0)continue;\n\t\t\t}\n\t\t\tif(f!=-1){\n\t\t\t\tnex[f].next[(ndir+2)%4]=t;\n\t\t\t\tif(t==-1)nex[f].cnt--;\n\t\t\t}\n\t\t\tint k=nex[v].next[(ndir+1)%4];\n\t\t\tint l=nex[v].next[(ndir+3)%4];\n\t\t\tif(k!=-1){\n\t\t\t\tnex[k].next[(ndir+3)%4]=l;\n\t\t\t\tif(l==-1)nex[k].cnt--;\n\t\t\t\tif(nex[k].cnt==0)continue;\n\t\t\t}\n\t\t\tif(l!=-1){\n\t\t\t\tnex[l].next[(ndir+1)%4]=k;\n\t\t\t\tif(k==-1)nex[l].cnt--;\n\t\t\t\tif(nex[l].cnt==0)continue;\n\t\t\t}\n\t\t\tdfs(f,ndir,nex,str+dirchar[ndir]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&h,&w);\n\tvector<data> dat;\n\tfor(int i=0;i<h;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=-1;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(str[j]==dirchar[k]){\n\t\t\t\t\ts=cnt;\n\t\t\t\t\tsdir=k;\n\t\t\t\t\tdat.push_back(data());\n\t\t\t\t\tfie[j][i]=cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[j]=='o'){\n\t\t\t\tdat.push_back(data());\n\t\t\t\tfie[j][i]=cnt++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[j][i]==-1)continue;\n\t\t\tint k=j+1;\n\t\t\twhile(k<w){\n\t\t\t\tif(fie[k][i]>=0){\n\t\t\t\t\tdat[fie[j][i]].next[0]=fie[k][i];\n\t\t\t\t\tdat[fie[j][i]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tk=j-1;\n\t\t\twhile(k>=0){\n\t\t\t\tif(fie[k][i]>=0){\n\t\t\t\t\tdat[fie[j][i]].next[2]=fie[k][i];\n\t\t\t\t\tdat[fie[j][i]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tif(fie[i][j]==-1)continue;\n\t\t\tint k=j+1;\n\t\t\twhile(k<h){\n\t\t\t\tif(fie[i][k]>=0){\n\t\t\t\t\tdat[fie[i][j]].next[1]=fie[i][k];\n\t\t\t\t\tdat[fie[i][j]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tk=j-1;\n\t\t\twhile(k>=0){\n\t\t\t\tif(fie[i][k]>=0){\n\t\t\t\t\tdat[fie[i][j]].next[3]=fie[i][k];\n\t\t\t\t\tdat[fie[i][j]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(s,sdir,dat,\"\");\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nchar dir[] = {'U', 'L', 'D', 'R'};\n\nint W,H;\nstring field[10];\n\nstring solve(int x, int y, int d, int c, string str)\n{\n\tif(c == 0)\treturn str;\n\t\n\n\tstring res;\n\tfor(int i=-1; i<2; i++) {\n\t\tbool ok = false;\n\t\tint nx=x, ny=y, nd=(d+i+4)%4;\n\t\twhile(1) {\n\t\t\tnx += dx[nd]; ny+=dy[nd];\n\t\t\tif(nx<0||ny<0||nx>=W||ny>=H) break;\n\t\t\tif(field[ny][nx]=='o') {\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(ok) {\n\t\t\tfield[ny][nx] = '.';\n\t\t\tres = max(res, solve(nx,ny,nd,c-1,str+dir[nd]));\n\t\t\tfield[ny][nx] = 'o';\n\t\t}\n\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin >> H >> W;\n\tfor(int i=0; i<H; i++)\n\t\tcin >> field[i];\n\n\tint sx,sy,sd,cnt=0;\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\tif(field[i][j] == 'o') cnt++;\n\n\t\tif(field[i][j]=='U') sd = 0;\n\t\tif(field[i][j]=='L') sd = 1;\n\t\tif(field[i][j]=='D') sd = 2;\n\t\tif(field[i][j]=='R') sd = 3;\n\n\t\tif(isupper(field[i][j])) {\n\t\t\tsx=j; sy=i;\n\t\t}\n\t}\n\n\tcout << solve(sx,sy,sd,cnt,\"\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint h,w;\nchar c[11][11];\n\nstring urdl=\"URDL\";\n// URDL\nint dx[4]={0,1,0,-1}, dy[4]={-1,0,1,0};\n\nint o_ct=0;\n\n#define IN(x,y) (0<=x && x<w && 0<=y && y<h)\nstring ans;\nvoid dfs(string now, int x, int y, int d)\n{\n    if(now.size()==o_ct)\n    {\n        ans=now;\n        return;\n    }\n\n    for(int i=-1; i<=1; ++i)\n    {\n        int nd = (d+i+4)%4;\n        for(int k=1; k<10; ++k)\n        {\n            int nx = x+k*dx[nd], ny = y+k*dy[nd];\n            if(IN(nx,ny) && c[ny][nx]=='o')\n            {\n                c[y][x]='.';\n                dfs(now+urdl[nd], nx, ny, nd);\n                c[y][x]='o';\n                break;\n            }\n        }\n    }\n}\n\nint main()\n{\n    scanf(\" %d %d\", &h, &w);\n    rep(i,h) scanf(\" %s\", c[i]);\n\n    int sx,sy,dir;\n    rep(i,h)rep(j,w)\n    {\n        if(c[i][j]!='.' && c[i][j]!='o')\n        {\n            sx=j;\n            sy=i;\n\n            if(c[i][j]=='U') dir=0;\n            else if(c[i][j]=='R') dir=1;\n            else if(c[i][j]=='D') dir=2;\n            else if(c[i][j]=='L') dir=3;\n        }\n        else if(c[i][j]=='o') ++o_ct;\n    }\n\n    dfs(\"\",sx,sy,dir);\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nstring ch=\"URDL\";\n\nint h,w;\nint si,sj,dir;\nchar t[10][10];\nint cnt=0;\nvector<char> ans;\n\nbool inField(int y,int x){\n  if(y<0||x<0)return false;\n  if(y>=h||x>=w)return false;\n  return true;\n}\n\nbool solve(int y,int x,int dir,int depth=0){\n  if(depth==cnt)return true;\n  \n  for(int i=0;i<4;i++){\n    if((i+2)%4==dir)continue;\n    int k,ny,nx;\n    for(k=0;;k++){\n      ny=y+dy[i]*k;\n      nx=x+dx[i]*k;\n      if(!inField(ny,nx))break;\n      if(t[ny][nx]=='o')break;\n    }\n    if(!inField(ny,nx))continue;\n    t[ny][nx]='.';\n    if(solve(ny,nx,i,depth+1)){\n      ans.push_back(ch[i]);\n      return true;\n    }\n    t[ny][nx]='o';\n  }\n  return false;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='o'){\n        cnt++;\n      }else if(t[i][j]=='U'){\n        si=i,sj=j,dir=0;\n      }else if(t[i][j]=='R'){\n        si=i,sj=j,dir=1;\n      }else if(t[i][j]=='D'){\n        si=i,sj=j,dir=2;\n      }else if(t[i][j]=='L'){\n        si=i,sj=j,dir=3;\n      }\n    }\n  }\n  solve(si,sj,dir);\n  reverse(ans.begin(),ans.end());\n  for(int i=0;i<(int)ans.size();i++)cout<<ans[i];\n  cout<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nchar s[15][15];\nint wayx[10]={-1,0,1,0};\nint wayy[10]={0,1,0,-1};\nchar ss[10]=\"URDL\";\nint ck(char c)\n{\n    for (int i=0;i<4;i++)\n        if (ss[i]==c) return i;\n    return -1;\n}\nchar p[100];\nint n,m;\nbool dfs(int x,int y,int id,int now,int ee)\n{\n    if (now==ee)\n    {\n        p[ee]=0;\n        puts(p);\n        return true;\n    }\n    for (int i=0;i<4;i++)\n    {\n        if (abs(i-id)==2) continue;\n        int xx=x+wayx[i],yy=y+wayy[i];\n        bool sol=false;\n        while (xx>=0&&xx<n&&yy>=0&&yy<m)\n        {\n            if (s[xx][yy]=='o')\n            {\n                p[now]=ss[i];\n                sol=true;\n                s[x][y]='.';\n                if (dfs(xx,yy,i,now+1,ee)) return true;\n                s[x][y]='o';\n                break;\n            }\n            xx+=wayx[i];\n            yy+=wayy[i];\n        }\n    }\n    return false;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=0;i<n;i++)\n        scanf(\"%s\",s[i]);\n    int num=0,sx,sy,id;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<m;j++)\n        {\n            if (s[i][j]=='o') num++;\n            else if (s[i][j]!='.')\n            {\n                id=ck(s[i][j]);\n                s[i][j]='o';\n                sx=i;\n                sy=j;\n            }\n        }\n    dfs(sx,sy,id,0,num);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint H,W;\nvector<string> s;\nstring ans;\nstring ddr=\"URDL\";\nint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\t//URDL\nbool on(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W;\n}\nbool dfs(int x,int y,int di,int cnt,vector<string> s){\n/*\trep(i,H) cout<<s[i]<<endl;\n\tshow(cnt);\n\tputs(\"\");*/\n\tif(cnt==0) return true;\n\tfor(int nd=(di+3)%4;nd!=(di+2)%4;nd=(nd+1)%4){\n\t\tint nx=x,ny=y;\n\t\twhile(on(nx,ny)){\n\t\t\tif(s[nx][ny]=='o'){\n\t\t\t\ts[nx][ny]='.';\n\t\t\t\tif(dfs(nx,ny,nd,cnt-1,s)){\n\t\t\t\t\tans=ddr[nd]+ans;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ts[nx][ny]='o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx+=dx[nd],ny+=dy[nd];\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tcin>>H>>W;\n\trep(i,H){\n\t\tstring st;\n\t\tcin>>st;\n\t\ts.pb(st);\n\t}\n\tint sx,sy,di,cnt=0;\n\trep(i,H) rep(j,W){\n\t\tif(s[i][j]=='o') cnt++;\n\t\tif(s[i][j]=='U') sx=i,sy=j,di=0,s[i][j]='.';\n\t\tif(s[i][j]=='R') sx=i,sy=j,di=1,s[i][j]='.';\n\t\tif(s[i][j]=='D') sx=i,sy=j,di=2,s[i][j]='.';\n\t\tif(s[i][j]=='L') sx=i,sy=j,di=3,s[i][j]='.';\n\t}\n\tdfs(sx,sy,di,cnt,s);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,x,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nint h, w;\n\nusing State = tuple<int, int, int>;\n\n// R U L D\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\nint total;\nstring res;\n\nstring i2c = \"RULD\";\nmap<char, int> c2i;\n\nvector<string> field;\n\nbool dfs(State cur, int cnt, string op){\n    int y, x, dir_i;\n    tie(y, x, dir_i) = cur;\n\n    if(cnt == total){\n        res = op;\n        return true;\n    }\n\n    vi ndirs_i = { (dir_i + 1) % 4, dir_i, (dir_i + 3) % 4 };\n    for(auto & ndir_i : ndirs_i){\n        int ny = -1, nx = -1;\n        rep(k, 100){\n            int yy = y + k * dy[ndir_i], xx = x + k * dx[ndir_i];\n\n            if(yy < 0 or h <= yy or\n               xx < 0 or w <= xx){\n                break;\n            }\n\n            if(field[yy][xx] == 'o'){\n                ny = yy, nx = xx;\n                break;\n            }\n        }\n\n        if(ny == -1) continue;\n\n        field[ny][nx] = '.';\n        if(dfs(tie(ny, nx, ndir_i), cnt + 1, op + i2c[ndir_i])){\n            return true;\n        }\n        field[ny][nx] = 'o';\n    }\n\n    return false;\n}\n\nint main(void){\n    rep(i, 4) c2i[i2c[i]] = i;\n\n    cin >> h >> w;\n    \n    field = vector<string>(h);\n    State start;\n    rep(y, h){\n        cin >> field[y];\n\n        rep(x, w){\n            if(field[y][x] != 'o' and field[y][x] != '.'){\n                int dir = c2i[field[y][x]];\n                start = tie(y, x, dir);\n\n                field[y][x] = '.';\n            }\n            if(field[y][x] == 'o'){\n                total++;\n            }\n        }\n    }\n\n    dfs(start, 0, \"\");\n    \n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint h, w, leaves;\nvector<char> path;\nchar mapData[10][10];\nbool visited[10][10];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nconst string str = \"URDL\";\n\n\nbool dfs(int y, int x, int d){\n  if(leaves == 0){\n    path.push_back(d);\n    return true;\n  }\n  for(int i=0;i<4;i++){\n    if(abs(i-d) == 2) continue;\n    int ny = y;\n    int nx = x;\n    while(1){\n      ny += dy[i];\n      nx += dx[i];\n      if(ny<0 || ny>= h) break;\n      if(nx<0 || nx>= w) break;\n      if(mapData[ny][nx] == 'o' && !visited[ny][nx]){\n        visited[y][x] = true;\n        --leaves;\n        if(dfs(ny, nx, i)){\n          path.push_back(i);\n          return true;\n        }\n        visited[y][x] = false;\n        ++leaves;\n        break;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  while(cin >> h >> w && h|w){\n    path.clear();\n    fill(visited[0], visited[10], false);\n    int sy, sx, sd;\n    for(int i=0;i<h;++i){\n      for(int j=0;j<w;++j){\n        cin >> mapData[i][j];\n        if(mapData[i][j] == 'o') ++leaves;\n        if(mapData[i][j] != 'o' && mapData[i][j] != '.'){\n          sy = i;\n          sx = j;\n          if(mapData[i][j] == 'U') sd = 0;\n          if(mapData[i][j] == 'R') sd = 1;\n          if(mapData[i][j] == 'D') sd = 2;\n          if(mapData[i][j] == 'L') sd = 3;\n        }\n      }\n    }\n    dfs(sy, sx, sd);\n    reverse(path.begin(), path.end());\n    for(int i=0;i<(int)path.size()-1;++i){\n      cout << str[path[i]];\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\nusing namespace std;\nint n,m;\nchar a[15][15];\nbool bo[15][15];\nint dx[]={-1,0,1,0},dy[]={0,1,0,-1};\nchar UNdir(int x)\n{\n    if (x==0) return 'U';\n    if (x==1) return 'R';\n    if (x==2) return 'D';\n    if (x==3) return 'L';\n}\nint dir(char x)\n{\n    if (x=='U') return 3;\n    if (x=='R') return 0;\n    if (x=='D') return 1;\n    if (x=='L') return 2;\n}\nstruct node\n{\n    int d;\n    int x[105];\n    int y[105];\n    int num;\n    char fa;\n    string ans;\n};\nbool in(int x,int y)\n{\n    return (x>=0 && x<n && y>=0 && y<m);\n}\nvoid out(node x)\n{\n    char xx[15][15];\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < m; ++j)\n        {\n                xx[i][j]='.';\n        }\n    }\n    xx[x.d/m][x.d%m]=x.fa;\n    for (int i = 0; i < x.num; ++i)\n    {\n        xx[x.x[i]][x.y[i]]='o';\n    }\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < m; ++j)\n        {\n            cout<<xx[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\nint ans=0,ansd=0;\nint main(int argc, char *argv[])\n{\n    int T;\n    cin>>n>>m;\n    node xx;xx.num=0;\n    xx.ans=\"\";\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0 ; j < m; ++j)\n        {\n            cin>>a[i][j];\n            if (a[i][j]=='o')\n            {\n                xx.x[xx.num]=i;\n                xx.y[xx.num++]=j;\n            }\n            else if (a[i][j]=='U'||a[i][j]=='L'||a[i][j]=='R'||a[i][j]=='D')\n            {\n                xx.d=i*m+j;\n                xx.fa=a[i][j];\n            }\n        }\n    }\n    queue<node> q;\n    q.push(xx);\n    bool gan=0;\n    while (!q.empty())\n    {\n        node now=q.front();\n    \n        if (now.num==0)\n        {\n            cout<<now.ans<<endl;\n            break;\n        }\n        q.pop();\n        int x=now.d/m,y=now.d%m;\n        memset(bo,0,sizeof(bo));\n        bo[x][y]=1;\n        for (int i = 0; i < now.num; ++i)\n        {\n           bo[now.x[i]][now.y[i]]=1;\n        }\n        int face=dir(now.fa);\n        for (int i = face; i < face+3; ++i)\n        {\n            int ii=i%4;\n            int l=1;\n            int xx=x+dx[ii],yy=y+dy[ii];\n            while (1)\n            {\n                if (!in(xx,yy)) break;\n                if (bo[xx][yy])\n                {\n                    node go;\n                    go.d=xx*m+yy;\n                    go.ans=now.ans+UNdir(ii);\n                    go.fa=UNdir(ii);\n                    go.num=0;\n                                        for (int j = 0; j < now.num; ++j)\n                    {\n                        int xxx=now.x[j],yyy=now.y[j];\n                        if (!(xxx==xx&&yyy==yy))\n                        {\n                            go.x[go.num]=xxx;\n                            go.y[go.num++]=yyy;\n                        }\n                    }\n                    q.push(go); \n                    break;\n                }\n                xx+=dx[ii];\n                yy+=dy[ii];\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nchar s[15][15];\nint wayx[10]={-1,0,1,0};\nint wayy[10]={0,1,0,-1};\nchar ss[10]=\"URDL\";\nint ck(char c)\n{\n    for (int i=0;i<4;i++)\n        if (ss[i]==c) return i;\n    return -1;\n}\nchar p[100];\nint n,m;\nbool dfs(int x,int y,int id,int now,int ee)\n{\n    if (now==ee)\n    {\n        p[ee]=0;\n        puts(p);\n        return true;\n    }\n    for (int i=0;i<4;i++)\n    {\n        if (abs(i-id)==2) continue;\n        int xx=x+wayx[i],yy=y+wayy[i];\n        bool sol=false;\n        while (xx>=0&&xx<n&&yy>=0&&yy<m)\n        {\n            if (s[xx][yy]=='o')\n            {\n                p[now]=ss[i];\n                sol=true;\n                s[x][y]='.';\n                if (dfs(xx,yy,i,now+1,ee)) return true;\n                s[x][y]='o';\n                break;\n            }\n            xx+=wayx[i];\n            yy+=wayy[i];\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=0;i<n;i++)\n        scanf(\"%s\",s[i]);\n    int num=0,sx,sy,id;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<m;j++)\n        {\n            if (s[i][j]=='o') num++;\n            else if (s[i][j]!='.')\n            {\n                id=ck(s[i][j]);\n                s[i][j]='o';\n                sx=i;\n                sy=j;\n            }\n        }\n    dfs(sx,sy,id,0,num);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nconst char *ds = \"ULDR\";\nint h, w, sz, goal;\nchar in[10][11], ans[40];\n\nvoid rec(int y, int x, int dir){\n\tif(sz == goal){\n\t\tcout << ans << endl;\n\t\texit(0);\n\t}\n\trep(d, 4) if((d ^ 2) != dir){\n\t\tint ny = y, nx = x;\n\t\twhile(0 <= ny && ny < h && 0 <= nx && nx < w && in[ny][nx] == '.')\n\t\tny += dy[d], nx += dx[d];\n\t\t\n\t\tif(0 <= ny && ny < h && 0 <= nx && nx < w){\n\t\t\tans[sz++] = ds[d];\n\t\t\tin[ny][nx] = '.';\n\t\t\trec(ny, nx, d);\n\t\t\tin[ny][nx] = 'o';\n\t\t\tsz--;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w;\n\tint y, x, dir;\n\trep(i, h){\n\t\tcin >> in[i];\n\t\trep(j, w){\n\t\t\trep(k, 4) if(in[i][j] == ds[k]){\n\t\t\t\ty = i, x = j, dir = k;\n\t\t\t\tin[y][x] = '.';\n\t\t\t}\n\t\t\tif(in[i][j] == 'o') goal++;\n\t\t}\n\t}\n\trec(y, x, dir);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int V_MAX = 30;\nconst int INF = 10000000;\n\nint h, w;\nint n;\nchar c[10][11];\n\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\nconst char D[] = {'R', 'D', 'L', 'U'};\n\nstack<int> ans;\n\nint dfs(int x, int y, int d)\n{\n    c[x][y] = '.';\n\n    bool ko = true;\n    for (int i = 0; ko && i < h; ++i) {\n        for (int j = 0; ko && j < w; ++j) {\n            if (c[i][j] == 'o')\n                ko = false;\n        }\n    }\n    if (ko)\n        return 4;\n\n    //printf(\"  dfs(%2d, %2d, %c)\\n\", x, y, D[d]);\n    for (int i = 0; i < 4; ++i) {\n        if ((d + 2) % 4 == i)\n            continue;\n\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        for (;;) {\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny)\n                break;\n            if (c[nx][ny] == 'o') {\n                int ret = dfs(nx, ny, i);\n                if (ret != -1) {\n                    ans.push(i);\n                    return i;\n                }\n                break;\n            }\n            nx += dx[i];\n            ny += dy[i];\n        }\n    }\n\n    c[x][y] = 'o';\n\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &h, &w);\n    for (int i = 0; i < h; ++i)\n        scanf(\" %s\", c[i]);\n\n    int sx, sy, sd;\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (c[i][j] == 'U' || c[i][j] == 'D' || c[i][j] == 'L' || c[i][j] == 'R') {\n                sx = i;\n                sy = j;\n                if (c[i][j] == 'U')\n                    sd = 3;\n                else if (c[i][j] == 'D')\n                    sd = 1;\n                else if (c[i][j] == 'L')\n                    sd = 2;\n                else if (c[i][j] == 'R')\n                    sd = 0;\n            }\n        }\n    }\n\n    dfs(sx, sy, sd);\n    while (!ans.empty()) {\n        printf(\"%c\", D[ans.top()]);\n        ans.pop();\n    }\n    puts(\"\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst string dc[4]={\"R\",\"D\",\"L\",\"U\"};\n\nstring board[15];\n\nint h,w,tar=0;\n\nstring dfs(int ci,int cj,int cd,string cur){\n\tif(int(cur.size())==tar) return cur;\n\n\trep(d,4){\n\t\tif(d==(cd+2)%4) continue;\n\t\tboard[ci][cj]='.';\n\t\tint ni=ci,nj=cj;\n\t\t\n\t\tbool ok=false;\n\t\twhile(1){\n\t\t\tif(ni<0||h<=ni||nj<0||w<=nj) break;\n\t\t\tif(board[ni][nj]=='o'){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tni+=dy[d],nj+=dx[d];\n\t\t}\n\n\t\tif(ok){\n\t\t\tstring res=dfs(ni,nj,d,cur+dc[d]);\n\t\t\tif(res!=\"\") return res;\n\t\t}\n\n\t\tboard[ci][cj]='o';\n\n\t}\n\treturn \"\";\n}\n\nint main(void){\n\tmap<char,int> conv;\n\tconv['R']=0,conv['D']=1,conv['L']=2,conv['U']=3;\n\n\tcin >> h >> w;\n\trep(i,h) cin >> board[i];\n\n\tint si=-1,sj=-1,sd=-1;\n\trep(i,h)rep(j,w) if(board[i][j]=='o') tar++;\n\trep(i,h)rep(j,w) if(board[i][j]!='.'&&board[i][j]!='o') si=i,sj=j;\n\tsd=conv[board[si][sj]];\n\tboard[si][sj]='o';\n\n\tcout << dfs(si,sj,sd,\"\") << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nint H, W;\nstring pat = \"URDL\";\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nchar board[15][15];\n\nvoid solve(int x, int y, int dir, string command, int rest) {\n    // printf(\"x = %d, y = %d, dir = %c, rest = %d\\n\", x, y, pat[dir], rest);\n    if(rest == 0) {\n        cout << command << endl;\n        exit(0);\n    }\n\n    for(int k=0; k<4; k++) {\n        if(abs(k-dir) == 2) continue;\n        int nx = x, ny = y;\n        while(1) {\n            nx += dx[k], ny += dy[k];\n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) break;\n            // printf(\"k = %d, nx = %d, ny = %d, char = %c\\n\", k, nx, ny, board[nx][ny]);\n            if(board[nx][ny] == 'o') {\n                // printf(\"ok %d, %d\\n\", nx, ny);\n                board[nx][ny] = '.';\n                solve(nx, ny, k, command + pat[k], rest-1);\n                board[nx][ny] = 'o';\n                break;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &H, &W);\n    int sx = -1, sy = -1, dir = -1, rest = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            scanf(\" %c\", &board[i][j]);\n            if(pat.find(board[i][j]) != string::npos) {\n                sx = i, sy = j;\n                dir = pat.find(board[i][j]);\n            }\n            rest += (board[i][j] == 'o');\n        }\n    }\n\n    board[sx][sy] = '.';\n    solve(sx, sy, dir, \"\", rest);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nint H, W;\nstring C[10];\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\nstring ds = \"URDL\";\n\nstring dfs(int cnt, int x, int y, int dir)\n{\n\tif (cnt == 0) return \"\";\n\n\trep(i, 0, 4) if((dir - i + 4) % 4 != 2)\n\t{\n\t\tint xx = x, yy = y;\n\t\tint tx = -1, ty = -1;\n\n\t\twhile ((0 <= xx && xx < W) && (0 <= yy && yy < H))\n\t\t{\n\t\t\tif (C[yy][xx] == 'o')\n\t\t\t{\n\t\t\t\ttx = xx;\n\t\t\t\tty = yy;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\txx += dx[i];\n\t\t\tyy += dy[i];\n\t\t}\n\n\t\tif (tx < 0) continue;\n\n\t\tC[ty][tx] = 'x';\n\n\t\tstring ret = dfs(cnt - 1, tx, ty, i);\n\t\tif (ret != \"CANT\") return ds[i] + ret;\n\t\tC[ty][tx] = 'o';\n\t}\n\n\treturn \"CANT\";\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> W)\n\t{\n\t\trep(y, 0, H) cin >> C[y];\n\n\t\tint N = 0;\n\t\trep(y, 0, H) rep(x, 0, W) if (C[y][x] == 'o') N++;\n\t\trep(y, 0, H) rep(x, 0, W) if (C[y][x] != 'o' && C[y][x] != '.')\n\t\t{\n\t\t\tswitch (C[y][x])\n\t\t\t{\n\t\t\tcase 'U': cout << dfs(N, x, y, 0) << endl; break;\n\t\t\tcase 'R': cout << dfs(N, x, y, 1) << endl; break;\n\t\t\tcase 'D': cout << dfs(N, x, y, 2) << endl; break;\n\t\t\tcase 'L': cout << dfs(N, x, y, 3) << endl; break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nconst int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\nint h, w;\nstring dir = \"DRUL\";\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\npair<int,int> find(vector<string> &C, int x, int y, int d){\n  while(in_range(x+dx[d],h) && in_range(y+dy[d],w)){\n    x += dx[d];\n    y += dy[d];\n    if(C[x][y] == 'o') return {x,y};\n  }\n  return {-1,-1};\n}\n\nstring solve(vector<string> &C, int x, int y, int d, int c){\n  if(!c) return \"\";\n  for(int i = 0; i < 4; ++i){\n    int d_ = (d+i)%4;\n    if(d_ == d) continue;\n    pair<int,int> next = find(C,x,y,d_);\n    if(next.first < 0) continue;\n    C[next.first][next.second] = '.';\n    string ret = solve(C,next.first,next.second,(d_+2)%4,c-1);\n    C[next.first][next.second] = 'o';\n    if(ret == \"!\") continue;\n    return dir[d_] + ret;\n  }\n  return \"!\";\n}\n\nint main(){\n  cin >> h >> w;\n  vector<string> C(h);\n  for(int i = 0; i < h; ++i) cin >> C[i];\n  int x = -1, y = -1, d = -1, l = 0;\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      char c = C[i][j];\n      if(c == 'o') ++l;\n      if(c != 'o' && c != '.'){\n        x = i;\n        y = j;\n        C[i][j] = '.';\n        for(int k = 0; k < 4; ++k){\n          if(dir[k] == c){\n            d = (k+2)%4;\n          }\n        }\n      }\n    }\n  }\n  cout << solve(C,x,y,d,l) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y, dir;\n\tvs field;\n\tstring command;\n\tstate(int x, int y, int dir, vs field, string command) : x(x), y(y), dir(dir), field(field), command(command) {};\n};\n\nint getDir(char c) {\n\tswitch(c) {\n\tcase 'U':\n\t\treturn 3;\n\tcase 'D':\n\t\treturn 1;\n\tcase 'L':\n\t\treturn 2;\n\tcase 'R':\n\t\treturn 0;\n\t}\n}\n\nchar getDirChar(int dir) {\n\tswitch(dir) {\n\tcase 0:\n\t\treturn 'R';\n\tcase 1:\n\t\treturn 'D';\n\tcase 2:\n\t\treturn 'L';\n\tcase 3:\n\t\treturn 'U';\n\t}\n}\n\nbool isProperXY(int x, int y, int H, int W) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool isEmptyField(vs field) {\n\tREP(i, field.size()) {\n\t\tREP(j, field[i].size()) {\n\t\t\tif(field[i][j] != '.') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvs field(H);\n\n\tint x, y, dir;\n\tREP(i, H) {\n\t\tcin >> field[i];\n\t\tREP(j, field[i].size()) {\n\t\t\tif(field[i][j] != '.' && field[i][j] != 'o') {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\tdir = getDir(field[i][j]);\n\t\t\t\tfield[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tstring ans;\n\tstack<state> S;\n\tS.push(state(x, y, dir, field, \"\"));\n\twhile(!S.empty()) {\n\t\tstate st = S.top();\n\t\tS.pop();\n\n\t\tif(isEmptyField(st.field)) {\n\t\t\tans = st.command;\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(d, -1, 1) {\n\t\t\tint nx = st.x, ny = st.y, ndir = (st.dir+d+4)%4;\n\t\t\tbool update = true;\n\t\t\twhile(st.field[ny][nx] != 'o') {\n\t\t\t\tnx += dx[ndir], ny += dy[ndir];\n\t\t\t\tif(!isProperXY(nx, ny, H, W)) {\n\t\t\t\t\tupdate = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(update) {\n\t\t\t\tvs nfield = st.field;\n\t\t\t\tnfield[ny][nx] = '.';\n\t\t\t\tstring ncommand = st.command;\n\t\t\t\tncommand.push_back(getDirChar(ndir));\n\t\t\t\tS.push(state(nx, ny, ndir, nfield, ncommand));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nconst int MAX_S = 11;\nint H, W;\nchar G[MAX_S][MAX_S];\n\nint ctod[128];\nchar dtoc[4];\n\nconst static int dx[] = {1,0,-1,0};\nconst static int dy[] = {0,1,0,-1};\n\nvoid init() {\n  dtoc[0] = 'R';\n  dtoc[1] = 'D';\n  dtoc[2] = 'L';\n  dtoc[3] = 'U';\n  for(int i = 0; i < 4; ++i)\n    ctod[dtoc[i]] = i;\n}\n\nint countStep() {\n  int cnt = 0;\n  for(int i = 0; i < H; ++i)\n    for(int j = 0; j < W; ++j)\n      cnt += G[i][j] == 'o';\n  return cnt-1;\n}\n\npair<int,int> getNextP(int x, int y, int dir) {\n  const static pair<int,int> FAILD = make_pair(-1,-1);\n  while(1) {\n    x += dx[dir];\n    y += dy[dir];\n    if(x < 0 || x >= W) return FAILD;\n    if(y < 0 || y >= H) return FAILD;\n    if(G[y][x] == 'o') return make_pair(x,y);\n  }\n  return FAILD;\n}\n\nbool rec(int x, int y, int dir, int step, int maxStep, string &s) {\n  if(step == maxStep) return true;\n  for(int k = -1; k <= 1; ++k) {\n    int ndir = ( dir + k + 4 ) % 4;\n    pair<int,int> p = getNextP(x,y,ndir);\n    if(p.first == -1 && p.second == -1) continue;\n    int nx = p.first;\n    int ny = p.second;\n\n    G[y][x] = '.';\n    s += dtoc[ndir];\n\n    if(rec(nx,ny,ndir,step+1,maxStep,s)) return true;\n\n    G[y][x] = 'o';\n    int tmp = (int)s.size()-1;\n    s.resize(tmp);\n  }\n\n  return false;\n}\n\nstring solve(int sx, int sy, int sdir) {\n  int step = countStep();\n  string res = \"\";\n  rec(sx,sy,sdir,0,step,res);\n  return res;\n}\n\nint main() {\n  init();\n  while(cin >> H >> W && (H | W)) {\n    int sx, sy, sdir;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n\tif(G[i][j] != '.' && G[i][j] != 'o') {\n\t  sx = j;\n\t  sy = i;\n\t  sdir = ctod[G[i][j]];\n\t  G[i][j] = 'o';\n\t}\n      }\n    }\n    cout << solve(sx,sy,sdir) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"stdlib.h\"\nint n,m;\nint map[15][15];\nchar str[100];\nchar dir[]={' ','U','D','R','L'};\nint sx,sy;\nint c;\nint ans[100];\nbool dfs(int x,int y,int step)\n{\n\tif(step==c) return true;\n\tif(map[x][y]!=2)\n\tfor(int i=x-1;i>=0;i--)\n\t\tif(!map[i][y])\n\t\t{\n\t\t\tans[step]=1;\n\t\t\tmap[i][y]=1;\n\t\t\tif(dfs(i,y,step+1))return true;\n\t\t\tmap[i][y]=0;\n\t\t\tbreak;\n\t\t}\n\tif(map[x][y]!=1)\n\tfor(int i=x+1;i<n;i++)\n\t\tif(!map[i][y])\n\t\t{\n\t\t\tans[step]=2;\n\t\t\tmap[i][y]=2;\n\t\t\tif(dfs(i,y,step+1))return true;\n\t\t\tmap[i][y]=0;\n\t\t\tbreak;\n\t\t}\n\tif(map[x][y]!=4)\n\tfor(int i=y+1;i<m;i++)\n\t\tif(!map[x][i])\n\t\t{\n\t\t\tans[step]=3;\n\t\t\tmap[x][i]=3;\n\t\t\tif(dfs(x,i,step+1))return true;\n\t\t\tmap[x][i]=0;\n\t\t\tbreak;\n\t\t}\n\tif(map[x][y]!=3)\n\tfor(int i=y-1;i>=0;i--)\n\t\tif(!map[x][i])\n\t\t{\n\t\t\tans[step]=4;\n\t\t\tmap[x][i]=4;\n\t\t\tif(dfs(x,i,step+1))return true;\n\t\t\tmap[x][i]=0;\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n}\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d %d\",&n,&m);\n\tc=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%s\",str);\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(str[j]=='.') map[i][j]=-1;\n\t\telse if(str[j]=='o') {map[i][j]=0;c++;}\n\t\telse{\n\t\t\tsx=i;\n\t\t\tsy=j;\n\t\t\tif(str[j]=='U')map[i][j]=1;\n\t\t\telse if(str[j]=='D')map[i][j]=2;\n\t\t\telse if(str[j]=='R')map[i][j]=3;\n\t\t\telse if(str[j]=='L')map[i][j]=4;\n\t\t}\n\t}\n\t//while(1){}\n\tdfs(sx,sy,0);\n\tfor(int i=0;i<c;i++)\n\t\tprintf(\"%c\",dir[ans[i]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\nusing State = string::const_iterator;\n\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    int H, W; cin >> H >> W;\n    vector<string> S(H);\n    map<char,int> dir;\n    dir['R'] = 0;\n    dir['U'] = 1;\n    dir['L'] = 2;\n    dir['D'] = 3;\n    string dirs = \"RULD\";\n    int sd, si, sj;\n    int leaves = 0;\n    REP(i, H) {\n        cin >> S[i];\n        REP(j, W) {\n            if (dir.count(S[i][j])) {\n                sd = dir[S[i][j]], si = i, sj = j;\n                S[i][j] = '.';\n            }\n            if (S[i][j] == 'o') ++leaves;\n        }\n    }\n\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {1, 0, -1, 0};\n\n    function<string(int,int,int,int,vector<string>&)> dfs = [&](int i, int j, int d, int res, vector<string>& s) {\n        if (res == 0) return string();\n        REP(k, 4) {\n            if (k == (d + 2) % 4) continue;\n            int ny = i, nx = j;\n            while (0 <= ny and ny < H and\n                   0 <= nx and nx < W and\n                   s[ny][nx] == '.') {\n                ny += dy[k], nx += dx[k];\n            }\n            if (ny < 0 or nx < 0 or H <= ny or W <= nx or s[ny][nx] != 'o') continue;\n            s[ny][nx] = '.';\n            string ret = dfs(ny, nx, k, res - 1, s);\n            s[ny][nx] = 'o';\n            if (ret != \"#\") return dirs[k] + ret;\n        }\n        return string(\"#\");\n    };\n\n    cout << dfs(si, sj, sd, leaves, S) << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nint n, m;\nchar g[12][12];\nchar ans[35];\nint LeafNum;\nint endFlag;\n\nvoid BFS(int x, int y, int leaf_num, int dir)\n{\n    //printf(\"BFS : %d %d %d %d\\n\", x,y,leaf_num,dir);\n    if(endFlag)\n        return;\n\n    if(leaf_num == 0)\n    {\n        endFlag = true;\n        return;\n    }\n\n    //Up\n    if(dir != 2)\n        for(int i = x - 1; i >= 0; i--)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                ans[LeafNum - leaf_num] = 'U';\n                BFS(i, y, leaf_num - 1, 0);\n\n                g[i][y] = 'o';\n            }\n\n    //Down\n    if(dir != 0)\n        for(int i = x + 1; i < n; i++)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                ans[LeafNum - leaf_num] = 'D';\n                BFS(i, y, leaf_num - 1, 2);\n\n                g[i][y] = 'o';\n            }\n\n    //Left\n    if(dir != 3)\n        for(int i = y - 1; i >= 0; i--)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                ans[LeafNum - leaf_num] = 'L';\n                BFS(x, i, leaf_num - 1, 1);\n\n                g[x][i] = 'o';\n            }\n\n    //Right\n    if(dir != 1)\n        for(int i = y + 1; i < m; i++)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                ans[LeafNum - leaf_num] = 'R';\n                BFS(x, i, leaf_num - 1, 3);\n\n                g[x][i] = 'o';\n            }\n\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n\n    int x, y;\n    int leaf_num = 0;\n    int dir = 0;// 0 is up, 1 is left, 2 is down, 3 is right\n\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", g[i]);\n        for(int j = 0; j < m; j++)\n        {\n            if(g[i][j] == 'U' || g[i][j] == 'R' || g[i][j] == 'L' || g[i][j] == 'D')\n            {\n                x = i;\n                y = j;\n                if(g[i][j] == 'U'){ dir = 0; }\n                if(g[i][j] == 'L'){ dir = 1; }\n                if(g[i][j] == 'D'){ dir = 2; }\n                if(g[i][j] == 'R'){ dir = 3; }\n            }\n            if(g[i][j] == 'o')\n                leaf_num++;\n        }\n    }\n    leaf_num --;\n\n\n    g[x][y] = '.';\n    LeafNum = leaf_num;\n    endFlag = 0;\n\n    BFS(x, y, leaf_num, dir);\n\n    //printf(\"Leaf : %d\\n\", LeafNum);\n    for (int i = 0; i < LeafNum; ++i)\n    {\n        printf(\"%c\", ans[i]);\n    }\n    printf(\"\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint init_dic(int x,int y,\n\t    map<P,int>& dic){\n  if(dic.find(P(x,y)) == dic.end()){\n    int idx = dic.size();\n    dic[P(x,y)] = idx;\n  }\n  return dic[P(x,y)];\n}\n\nvoid fill_dic(int W,int H,map<P,int>& dic){\n  for(int x=0;x<=W;x++){\n    for(int y=0;y<=H;y++){\n      if(dic.find(P(x,y)) == dic.end()){\n\tdic[P(x,y)] = -1;\n      }\n    }\n  }\n}\n\nclass State{\npublic:\n  int x;\n  int y;\n  int dir;\n  int remaining;\n  int cost;\n  vector<char> route;\n  State(int _x,int _y,int _dir,int _remaining,int _cost,const vector<char>& _r)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost),route(_r) {}\n  State(int _x,int _y,int _dir,int _remaining,int _cost)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[101][101];\n    int sx,sy;\n    int dir;\n    int init_state=0;\n    map<P,int> dic;\n\n    for(int y=0;y<H;y++){\n      char buf[101];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = buf[x];\n\tif(buf[x] == 'U' || buf[x] == 'R'\n\t   || buf[x] == 'D' || buf[x] == 'L'){\n\t  sx = x;\n\t  sy = y;\n\t  const char dirs[4] = {'U','R','D','L'};\n\t  for(int i=0;i<4;i++){\n\t    if(dirs[i] == buf[x]){\n\t      dir = i;\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(buf[x] == 'o'){\n\t  init_state |= (1<<init_dic(x,y,dic));\n\t}\n      }\n    }\n    \n    fill_dic(W,H,dic);\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,dir,init_state,0));\n\n    set<int> visited[101][101][4];\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(visited[s.x][s.y][s.dir].count(s.remaining) > 0) continue;\n      visited[s.x][s.y][s.dir].insert(s.remaining);\n\n      if(__builtin_popcount(s.remaining) == 1){\n\tconst char dirs[4] = {'U','R','D','L'};\n\tfor(int i=0; i<s.route.size(); i++){\n\t  printf(\"%c\",dirs[s.route[i]]);\n\t}\n      }\n\n      for(int i=0;i<4;i++){\n\tif(i == (s.dir + 2) % 4) continue;\n\n\tint dx,dy;\n\tfor(int j=1;j<=max(H,W);j++){\n\t  dx = s.x + tx[i] * j;\n\t  dy = s.y + ty[i] * j;\n\t  if(dx < 0 || dy < 0 || dx >= W || dy >= H ) continue;\n\t  if(dic[P(dx,dy)] == -1) continue;\n\t  \n\t  if(s.remaining & (1<<dic[P(dx,dy)])){\n\t    int next = s.remaining & ~(1<<dic[P(s.x,s.y)]);\n\t    vector<char> next_route = s.route;\n\t    next_route.push_back(i);\n\t    que.push(State(dx,dy,i,next,s.cost+1,next_route));\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint line,row;\nchar map[11][11];\nbool vis[11][11];\n\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,1,0,-1};\n\nint total;\nint finalans[1100];\nint recordans;\nbool dfs(int x,int y,int now,int step)\n{\n\tint ind=(now+4-1)%4;\n\tint nowx=x+dx[ind],nowy=y+dy[ind];\n\twhile(nowx>=0&&nowx<line&&nowy>=0&&nowy<row)\n\t{\n\t\tif(map[nowx][nowy]=='o'&&!vis[nowx][nowy])break;\n\t\tnowx=nowx+dx[ind],nowy=nowy+dy[ind];\n\t}\n\t\n\tif(nowx>=0&&nowx<line&&nowy>=0&&nowy<row)\n\t{\n\t\tvis[nowx][nowy]=true;\n\t\tif(dfs(nowx,nowy,ind,step+1))\n\t\t{\n\t\t\tfinalans[recordans++]=ind;\n\t\t\treturn true;\n\t\t}\n\t\tvis[nowx][nowy]=false;\n\t}\n\t\n\tind=now;\n\tnowx=x+dx[ind],nowy=y+dy[ind];\n\twhile(nowx>=0&&nowx<line&&nowy>=0&&nowy<row)\n\t{\n\t\tif(map[nowx][nowy]=='o'&&!vis[nowx][nowy])break;\n\t\tnowx=nowx+dx[ind],nowy=nowy+dy[ind];\n\t}\n\tif(nowx>=0&&nowx<line&&nowy>=0&&nowy<row)\n\t{\n\t\tvis[nowx][nowy]=true;\n\t\tif(dfs(nowx,nowy,ind,step+1))\n\t\t{\n\t\t\tfinalans[recordans++]=ind;\n\t\t\treturn true;\n\t\t}\n\t\tvis[nowx][nowy]=false;\n\t\t\n\t\t\n\t}\n\t\n\tind=(now+1)%4;\n\tnowx=x+dx[ind],nowy=y+dy[ind];\n\twhile(nowx>=0&&nowx<line&&nowy>=0&&nowy<row)\n\t{\n\t\tif(map[nowx][nowy]=='o'&&!vis[nowx][nowy])break;\n\t\tnowx=nowx+dx[ind],nowy=nowy+dy[ind];\n\t}\n\tif(nowx>=0&&nowx<line&&nowy>=0&&nowy<row)\n\t{\n\t\tvis[nowx][nowy]=true;\n\t\tif(dfs(nowx,nowy,ind,step+1))\n\t\t{\n\t\t\tfinalans[recordans++]=ind;\n\t\t\treturn true;\n\t\t}\n\t\tvis[nowx][nowy]=false;\n\t}\n\t\n\tif(step==total)return true;\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&line,&row);\n\t\n\tint i,j;\n\tint startx,starty;\n\ttotal=0;\n\tfor(i=0;i<line;i++)\n\t{\n\t\tscanf(\"%s\",map[i]);\n\t\t\n\t\tfor(j=0;j<row;j++)\n\t\t{\n\t\t\tif(map[i][j]=='o')total++;\n\t\t\telse if(map[i][j]=='.')continue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tstartx=i;\n\t\t\t\tstarty=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvis[startx][starty]=true;\n\tif(map[startx][starty]=='U')dfs(startx,starty,0,0);\n\telse if(map[startx][starty]=='R')dfs(startx,starty,1,0);\n\telse if(map[startx][starty]=='D')dfs(startx,starty,2,0);\n\telse if(map[startx][starty]=='L')dfs(startx,starty,3,0);\n\tfinalans[recordans++]=map[startx][starty];\n\t\n\tfor(i=total-1;i>=0;i--)\n\t{\n\t\tif(finalans[i]==0)printf(\"U\");\n\t\telse if(finalans[i]==1)printf(\"R\");\n\t\telse if(finalans[i]==2)printf(\"D\");\n\t\telse printf(\"L\");\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,sx,sy,m;\nint d[256],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nchar c[10][10],sc,nc[4]={'U','R','D','L'};\nstring ans;\n\nbool check(int x,int y){\n  int res=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(c[i][j]=='o'&&x!=j&&y!=j){\n\tint f=0;\n\tfor(int k=j+1;k<w;k++)\n\t  if(c[k][j]=='o'){f++;break;}\n\tfor(int k=j-1;k>=0;k--)\n\t  if(c[k][j]=='o'){f++;break;}\n\tfor(int k=i+1;k<h;k++)\n\t  if(c[i][k]=='o'){f++;break;}\n\tfor(int k=j-1;k>=0;k--)\n\t  if(c[i][k]=='o'){f++;break;}\n\tif(f<2)res++;\n      }\n  return res>1;\n}\n\nbool dfs(int x,int y,char r,int cnt){\n  if(cnt==m){return 1;}\n  //if(check(x,y))return 0;\n  bool res=0;\n  c[y][x]='.';\n  for(int i=0;i<3;i++){\n    int p=(d[r]+i)%4,nx=x,ny=y;\n    while(0<=nx&&nx<w&&0<=ny&&ny<h&&c[ny][nx]!='o')\n      nx+=dx[p],ny+=dy[p];\n    cout<<nx<<\" \"<<ny<<endl;\n    if(0<=nx&&nx<w&&0<=ny&&ny<h)\n      if(dfs(nx,ny,nc[p],cnt+1))ans=nc[p]+ans,res=1;\n  }\n  c[y][x]='o';\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  d['U']=3,d['R']=0,d['D']=1,d['L']=2;\n  for(int i=h-1;i>=0;i--)\n    for(int j=0;j<w;j++){\n      cin>>c[i][j];\n      if(c[i][j]=='o')m++;\n      else if(c[i][j]!='.')sx=j,sy=i,sc=c[i][j];\n    }\n  dfs(sx,sy,sc,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nstring q=\"RDLU\";\nint n,m,to,co;\nvs in;\nvoid dfs(int x,int y,int to,string out){\n\tif(!co){\n\t\tcout<<out<<endl;\n\t\treturn;\n\t}\n\trep(k,4)if(k!=to){\n\t\tint nx=x,ny=y;\n\t\twhile(nx>=0&&ny>=0&&nx<n&&ny<m&&in[nx][ny]!='o')nx+=dx[k],ny+=dy[k];\n\t\tif(nx>=0&&ny>=0&&nx<n&&ny<m);else continue;\n\t\tin[nx][ny]='.';co--;\n\t\tdfs(nx,ny,(k+2)%4,out+q[k]);\n\t\tin[nx][ny]='o';co++;\n\t}\n}\nsigned main(){\n\tint x,y;\n\tcin>>n>>m;\n\tin=vs(n);\n\trep(i,n)cin>>in[i];\n\trep(i,n)rep(j,m)co+=in[i][j]=='o';\n\trep(i,n)rep(j,m)rep(k,4)if(in[i][j]==q[k])\n\t\tx=i,y=j,to=(k+2)%4;\n\t\n\tdfs(x,y,to,\"\");\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint cv[256];\nint cv2[256];\n\nint h, w;\nint g[10][10];\nint sx, sy, sdir;\nint cnt;\nstring res;\n\nbool dfs(int x, int y, int d)\n{\n\tg[x][y] = 0;\n\tcnt--;\n\tif (cnt == 0) return true;\n\trep(dir, 4){\n\t\tif (abs(dir - d) == 2) continue;\n\t\tfor (int i = 1;; i++){\n\t\t\tint nx = x + dx[dir] * i;\n\t\t\tint ny = y + dy[dir] * i;\n\t\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w) break;\n\t\t\tif (g[nx][ny]){\n\t\t\t\tres += cv2[dir];\n\t\t\t\tif (dfs(nx, ny, dir)) return true;\n\t\t\t\tres.pb();\n\t\t\t}\n\t\t}\n\t}\n\tg[x][y] = 1;\n\tcnt++;\n\treturn false;\n}\n\nint main()\n{\n\trep(i, 4) cv[\"ULDR\"[i]] = i;\n\trep(i, 4) cv2[i] = \"ULDR\"[i];\n\n\tcin >> h >> w;\n\trep(i, h) rep(j, w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == 'o'){\n\t\t\tg[i][j] = 1;\n\t\t\tcnt++;\n\t\t}\n\t\telse if (c != '.'){\n\t\t\tsx = i;\n\t\t\tsy = j;\n\t\t\tsdir = cv[c];\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\tif (dfs(sx, sy, sdir)) cout << res << endl;\n\telse assert(false);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};\nint H, W;\nmap<char, int> dir;\nmap<int, char> dir2;\nstring ans;\nbool range_out(int x, int y){\n    return x < 0 || y < 0 || W <= x || H <= y;\n}\nbool dfs(const vector<string>& pond, int cx, int cy, int cd, int leaves, string score){\n    if(leaves == 0){\n        ans = score;\n        return true;\n    }\n    rep(i, 4){\n        if(i == 3 - cd) continue;\n        int nx = cx, ny = cy;\n        bool end = false;\n        while(true){\n            nx += dx[i]; ny += dy[i];\n            if(range_out(nx, ny)){\n                end = true;\n                break;\n            }\n            if(pond[ny][nx] == 'o') break;\n        }\n        if(end) continue;\n        vector<string> temp = pond;\n        temp[ny][nx] = '.';\n        string st = score + dir2[i];\n        if(dfs(temp, nx, ny, i, leaves - 1, st)) return true;\n    }\n    return false;;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> H >> W;\n    vector<string> pond(H);\n    rep(i, H) cin >> pond[i];\n    int sx, sy, sd;\n    int leafnum = 0;\n    dir['U'] = 2; dir['D'] = 1; dir['L'] = 3; dir['R'] = 0;\n    for(const auto& k : dir) dir2[k.second] = k.first;\n    rep(i, H) rep(j, W){\n        if(pond[i][j] == 'o')\n          leafnum++;\n        if('A' <= pond[i][j] && pond[i][j] <= 'Z'){\n            sx = j; sy = i;\n            sd = dir[pond[j][i]];\n            pond[j][i] = '.';\n        }\n    }\n    string hoge = \"\";\n    dfs(pond, sx, sy, sd, leafnum, hoge);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nint h,w;\nint cnt;\nint a[15][15]={0};\nstring ans;\nvoid dfs(int x,int y,string muki,int nokori){\n\t//cout<<x<<\" \"<<y<<\" \"<<nokori<<endl;\n\tif(nokori==0){\n\t\tcout<<ans<<endl;\n\t\texit(0);\n\t}\n\tif(muki!=\"D\"){\n\t\tint dx=x-1,dy=y;\n\t\twhile(a[dx][dy]==0)dx--;\n\t\tif(a[dx][dy]!=2){\n\t\t\ta[x][y]=0;\n\t\t\tstring ans2=ans;\n\t\t\tans+=\"U\";\n\t\t\tdfs(dx,dy,\"U\",nokori-1);\n\t\t\tans=ans2;\n\t\t\ta[x][y]=1;\n\t\t}\n\t}\n\tif(muki!=\"U\"){\n\t\tint dx=x+1,dy=y;\n\t\twhile(a[dx][dy]==0)dx++;\n\t\tif(a[dx][dy]!=2){\n\t\t\ta[x][y]=0;\n\t\t\tstring ans2=ans;\n\t\t\tans+=\"D\";\n\t\t\tdfs(dx,dy,\"D\",nokori-1);\n\t\t\tans=ans2;\n\t\t\ta[x][y]=1;\n\t\t}\n\t}\n\t\n\tif(muki!=\"L\"){\n\t\tint dx=x,dy=y+1;\n\t\twhile(a[dx][dy]==0)dy++;\n\t\tif(a[dx][dy]!=2){\n\t\t\ta[x][y]=0;\n\t\t\tstring ans2=ans;\n\t\t\tans+=\"R\";\n\t\t\tdfs(dx,dy,\"R\",nokori-1);\n\t\t\tans=ans2;\n\t\t\ta[x][y]=1;\n\t\t}\n\t}\n\tif(muki!=\"R\"){\n\t\tint dx=x,dy=y-1;\n\t\twhile(a[dx][dy]==0)dy--;\n\t\tif(a[dx][dy]!=2){\n\t\t\ta[x][y]=0;\n\t\t\tstring ans2=ans;\n\t\t\tans+=\"L\";\n\t\t\tdfs(dx,dy,\"L\",nokori-1);\n\t\t\tans=ans2;\n\t\t\ta[x][y]=1;\n\t\t}\n\t}\n}\n\n\n\n\n   signed main(){\n\n   \tfor(int i=0;i<15;i++)a[i][0]=2,a[0][i]=2,a[14][i]=2,a[i][14]=2;\n   \tint x,y;\n   \tstring st;\n   \tcin>>h>>w;\n   \tcnt=0;\n   \tfor(int i=1;i<=h;i++){\n   \t\tstring s;\n   \t\tcin>>s;\n   \t\ts=\"d\"+s;\n   \t\tfor(int j=1;j<=w;j++){\n   \t\t\tif(s[j]=='o')cnt++, a[i][j]=1;\n   \t\t\tif(s[j]=='U'){\n   \t\t\t\tst=\"U\";\n   \t\t\t\tx=i,y=j;\n   \t\t\t}\n   \t\t\tif(s[j]=='D'){\n   \t\t\t\tst=\"D\";\n   \t\t\t\tx=i,y=j;\n   \t\t\t}\n   \t\t\tif(s[j]=='L'){\n   \t\t\t\tst=\"L\";\n   \t\t\t\tx=i,y=j;\n   \t\t\t}\n   \t\t\tif(s[j]=='R'){\n   \t\t\t\tst=\"R\";\n   \t\t\t\tx=i,y=j;\n   \t\t\t}\n   \t\t}\n   \t}\n  // cout<<x<<\" \"<<y<<endl;\n   \ta[x][y]=1;\n   \tans=\"\";\n   \tdfs(x,y,st,cnt);\n   \t\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 11\nusing namespace std;\nint h,w;\nstring mp[N];\nint dx[4]={0,1,0,-1};//^>V<\nint dy[4]={-1,0,1,0};//^>V<\nchar ch[]={'U','R','D','L'};\n\nbool check(int &y,int &x,int i){\n  while(1){\n    x+=dx[i],y+=dy[i];\n    if(x<0||y<0||x>=w||y>=h) return 0;\n    if(mp[y][x]=='o') return 1;\n  }\n}\n\nstring ans;\nbool dfs(int y,int x,int dir,int cnt){\n  if(cnt==0)return 1;\n  \n  for(int i=0;i<4;i++){\n    int nx=x,ny=y;\n    if((dir+2)%4==i||!check(ny,nx,i)) continue;\n    mp[ny][nx]='.';\n    if(dfs(ny,nx,i,cnt-1)){ans+=ch[i];return 1;}\n    mp[ny][nx]='o';\n  }\n  return 0;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  int cnt=0,sx,sy,dir;  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      char t=mp[i][j];\n      if(t=='o')cnt++;\n      if(t=='o'||t=='.')continue;\n      sx=j,sy=i;\n      if(t=='U')dir=0;\n      if(t=='R')dir=1;\n      if(t=='D')dir=2;\n      if(t=='L')dir=3;\n    }\n  dfs(sy,sx,dir,cnt);\n  reverse(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstring ba;\n\nstruct P {\n  string s;\n  int x, y;\n  P(const string &s, int y, int x) : s(s),y(y),x(x) {}\n};\n\nint main() {\n  int h,w;\n  while(cin >> h >> w) {\n    ba = \"\";\n    REP(i,h) {\n      string s; cin >> s;\n      ba += s;\n    }\n    const string strdir = \"URDL\";\n    map<char, int> mp;\n    REP(i,4) mp[strdir[i]] = i;\n    const int dx[] = {0,1,0,-1};\n    const int dy[] = {-1,0,1,0};\n    queue<P> Q;\n    REP(i,h) REP(j,w) \n      REP(k,4) if (ba[i*w+j] == strdir[k]) Q.push(P(ba,i,j));\n    map<string, pair<string, int> > pre;\n    pre[ba] = make_pair(\"\",0);\n    string last;\n    while(!Q.empty()) {\n      P p = Q.front(); Q.pop();\n\n      bool f = 0;\n      REP(i,w*h) if (p.s[i] == 'o') f = 1;\n      if (!f) {\n        last = p.s;\n        break;\n      }\n\n      // REP(i,h) {\n      //   REP(j,w) cout << p.s[i*w+j];cout << endl;\n      // }\n      \n      int y=p.y, x = p.x;\n      int sd = mp[p.s[y*w+x]];\n      //p.s[y*w+x] = '.';\n      for (int dd=sd-1; dd<=sd+1; ++dd) {\n        int d = (dd+4)%4;\n        int yy=y, xx=x;\n        while(1) {\n          yy+=dy[d];\n          xx+=dx[d];\n          if (yy<0||yy>=h||xx<0||xx>=w) break;\n          if (p.s[yy*w+xx] == 'o') {\n            string next = p.s;\n            next[y*w+x] = '.';\n            next[yy*w+xx] = strdir[d];\n            if (pre.count(next) == 0) {\n              pre[next] = make_pair(p.s,d);\n              Q.push(P(next,yy,xx));\n            }\n            break;\n          }\n        }\n      }\n    }\n    vector<char> ans;\n    for(string now=last; now!=\"\"; now=pre[now].first) {\n      //REP(i,h){REP(j,w)cout<<now[i*w+j];cout<<endl;}\n      ans.push_back(strdir[pre[now].second]);\n    }\n    ans.pop_back();\n    reverse(ALL(ans));\n    FOR(it,ans) cout << *it; cout << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<bitset>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 12\n \nusing namespace std;\n \nint h,w,sp,sdir;\nchar G[MAX][MAX];\nint dx[] = {+0,+1,+0,-1};\nint dy[] = {-1,+0,+1,+0};\nint leaf[MAX*MAX];\nint lpos[31],lindex;\nvector<int> move[31][4];\nint bitlist[31];\n \ninline int getDir(char c){\n  if(c == 'U')return 0;\n  if(c == 'R')return 1;\n  if(c == 'D')return 2;\n  return 3;\n}\n \ninline char getCDir(int i){\n  if(i == 0)return 'U';\n  if(i == 1)return 'R';\n  if(i == 2)return 'D';\n  return 'L';\n}\n \nvoid INIT(){\n \n  rep(y,h){\n    rep(x,w){\n      if(G[y][x] == '.')continue;\n \n      rep(k,4){\n      int nx = x, ny = y;\n    while(true){\n      nx += dx[k], ny += dy[k];\n      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))break;\n      if(G[ny][nx] != '.'){\n        move[leaf[x+y*w]][k].push_back(leaf[nx+ny*w]); \n        bitlist[leaf[x+y*w]] |= (1<<leaf[nx+ny*w]);\n      }\n    }\n      }\n    }\n  }\n \n}\n \nbool dfs(int cur,int dir,int used,deque<char>& deq){\n  //bitset<10> bt(used);\n  //cout << \"cur = \" << cur << \" \" << getCDir(dir) << \" \" << bt << endl;\n  if(used == (1<<lindex)-1){\n    rep(i,deq.size()){\n      cout << getCDir(deq[i]);\n    }\n    cout << endl;\n    return true;\n  }\n \n  for(int k = -1; k <= 1; k++){\n \n    int ndir = ( dir + 4 + k ) % 4;\n \n    rep(i,move[cur][ndir].size()){\n      int next = move[cur][ndir][i];\n      if( (used>>next) & 1 )continue;\n      deq.push_back(ndir);\n      if(dfs(next,ndir,used|(1<<next),deq)){\n    return true;\n      }\n      deq.pop_back();\n      break;\n    }\n \n  }\n  return false;\n}\n \nvoid compute(){\n  deque<char> deq;\n  dfs(leaf[sp],getDir(G[sp/w][sp%w]),(1<<leaf[sp]),deq);\n}\n \nint main(){\n  cin >> h >> w;\n  lindex = 0;\n  rep(y,h){\n    rep(x,w){\n      cin >> G[y][x];\n      if(G[y][x] != '.' && G[y][x] != 'o'){\n    sp = x + y * w;\n    lpos[lindex] = x + y * w;\n    leaf[x+y*w] = lindex++;\n      }\n      else if(G[y][x] != '.'){\n    lpos[lindex] = x + y * w;\n    leaf[x+y*w] = lindex++;\n      }\n    }\n  }\n \n  INIT();\n\n  compute();\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\nchar out[4] ={'R','D','L','U'};\nint H, W;\nchar brd[10][10];\nint x[10][10];\nint cnt;\nvector<int> ans;\n\nint dfs(int hh, int ww, int dir, int counter){\n\tif(counter == cnt){\n\t\treturn 0;\n\t}\n\tint ret = INF;\n\tbool end = false;\n\trep(i,4){\n\t\tif(i == (dir+2)%4) continue;\n\t\tint h = hh, w = ww;\n\t\twhile(true){\n\t\t\th += dh[i]; w += dw[i];\n\t\t\tif(h >= H || h < 0 || w >= W || w < 0) break;\n\t\t\tif(brd[h][w] == 'o'){\n\t\t\t\tbrd[h][w] = '.';\n\t\t\t\tret = min(dfs(h,w,i,counter+1),ret);\n\t\t\t\tbrd[h][w] = 'o';\n\t\t\t\tif(ret < INF){\n\t\t\t\t\tans.push_back(i);\n\t\t\t\t\tend = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(end) break;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint sh, sw, sdir;\n\tcin >> H >> W;\n\trep(i,H) rep(j,W){\n\t\tcin >> brd[i][j];\n\t\tif(brd[i][j] == 'o') cnt++;\n\t\tif(brd[i][j] == 'U'){ sh = i; sw = j; sdir = 3;}\n\t\tif(brd[i][j] == 'D'){ sh = i; sw = j; sdir = 1;}\n\t\tif(brd[i][j] == 'R'){ sh = i; sw = j; sdir = 0;}\n\t\tif(brd[i][j] == 'L'){ sh = i; sw = j; sdir = 2;}\n\t}\n\trep(i,H) rep(j,W){\n\t\tif(brd[i][j] == 'o'){\n\t\t\trep(k,H){\n\t\t\t\tif(k == i) continue;\n\t\t\t\tif(brd[k][j] == 'o'){\n\t\t\t\t\tx[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,W){\n\t\t\t\tif(k == j) continue;\n\t\t\t\tif(brd[i][k] == 'o'){\n\t\t\t\t\tx[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tmp = dfs(sh,sw,sdir,0);\n\tfor(int i = ans.size()-1; i >= 0; i--){\n\t\tcout << out[ans[i]];\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define rrepf(i,a,b) for (int i=(a)-1;i>=(b);--i)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n#else\n#define prt(x) cerr<<\"\"<<__LINE__<<\"\\t: \"<<#x\"\\t=\"<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n#define input(in)\n#define output(out)\n#endif\n\ntypedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\ntypedef vec<pii> vpii;\ntypedef vec<pdd> vpdd;\n\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<\" \"<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?\"\":\" \");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));fdt(i,y-1,0){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\nstruct Initializer\n{\n#ifndef DEBUG\n\tInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n\t~Initializer(){runtime();}\n#endif\n}initializer;\n\n#define feach(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing __gnu_cxx::rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nbool dfs(int x,int y,int dir,int rest,vec<si>& xs,vec<si>& ys,vec<char>& path);\nbool go(int x,int y,int dir,int rest,vec<si>& xs,vec<si>& ys,vec<char>& path)\n{\n\tpath[rest]=\"DRUL\"[dir];\n\tint nx,ny;\n\tsi::itr it;\n\tif (dir==0)\n\t{\n\t\tit=ys[y].upper_bound(x);\n\t\tif (it==ys[y].end()) rtn false;\n\t\tnx=*it;\n\t\tny=y;\n\t}\n\tif (dir==1)\n\t{\n\t\tit=xs[x].upper_bound(y);\n\t\tif (it==xs[x].end()) rtn false;\n\t\tnx=x;\n\t\tny=*it;\n\t}\n\tif (dir==2)\n\t{\n\t\tit=ys[y].upper_bound(x);\n\t\tif (it==ys[y].begin()) rtn false;\n\t\t--it;\n\t\tnx=*it;\n\t\tny=y;\n\t}\n\tif (dir==3)\n\t{\n\t\tit=xs[x].upper_bound(y);\n\t\tif (it==xs[x].begin()) rtn false;\n\t\t--it;\n\t\tnx=x;\n\t\tny=*it;\n\t}\n\txs[nx].ers(ny);\n\tys[ny].ers(nx);\n\tbool get=dfs(nx,ny,dir,rest,xs,ys,path);\n\txs[nx].ins(ny);\n\tys[ny].ins(nx);\n\trtn get;\n}\nbool dfs(int x,int y,int dir,int rest,vec<si>& xs,vec<si>& ys,vec<char>& path)\n{\n\tif (rest)\n\t{\n\t\trest--;\n\t\tif (go(x,y,dir?dir-1:3,rest,xs,ys,path)) rtn true;\n\t\tif (go(x,y,dir,rest,xs,ys,path)) rtn true;\n\t\tif (go(x,y,dir+1==4?0:dir+1,rest,xs,ys,path)) rtn true;\n\t\trtn false;\n\t}\n\telse\n\t{\n\t\trev(path);\n\t\tcout<<str(all(path))<<endl;\n\t\trev(path);\n\t\trtn true;\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tvec<vec<char> > g(n,vec<char>(m));\n\tcin>>g;\n\tvpii lst;\n\tint x,y;\n\trep(i,n) rep(j,m)\n\t{\n\t\tif (g[i][j]=='o') lst.pb(mp(i,j));\n\t\telse if (g[i][j]!='.') x=i,y=j;\n\t}\n\tvec<si> xs(n),ys(m);\n\tvec<char> path(sz(lst));\n\trep(i,sz(lst)) xs[lst[i].x].ins(lst[i].y),ys[lst[i].y].ins(lst[i].x);\n\tif (g[x][y]=='D') dfs(x,y,0,sz(lst),xs,ys,path);\n\tif (g[x][y]=='R') dfs(x,y,1,sz(lst),xs,ys,path);\n\tif (g[x][y]=='U') dfs(x,y,2,sz(lst),xs,ys,path);\n\tif (g[x][y]=='L') dfs(x,y,3,sz(lst),xs,ys,path);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint H, W;\nint grid[11][11];\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {-1, 1, 0, 0};\nstring state = \"UDLR\";\nint lim[4] = {1,0,3,2};\nbool used[11][11];\nstring dfs(int x, int y, int s, int rem, string res){\n  //printf(\"dfs:%d %d %d %d %s\\n\", x, y, s, rem, res.c_str());\n  if(rem == 0){\n    return res;\n  }\n  REP(r, 4)if(r != lim[s]){\n    REP(p, 10){\n      int nx = x + p * dx[r];\n      int ny = y + p * dy[r];\n      if(0 <= nx && 0 <= ny && nx < W && ny < H && !used[ny][nx] && grid[ny][nx]){\n        used[ny][nx] = true;\n        //printf(\"call %d %d %d %d %s\\n\", nx, ny, r, rem -1, (res+state[r]).c_str());\n        string response = dfs(nx, ny, r, rem-1, res+state[r]);\n        used[ny][nx] = false;\n        if(response != \"\") return response;\n        break;\n      }\n    }\n  }\n  return \"\";\n}\n\nint main(){\n  while(cin>>H>>W && H){\n    int nx, ny, s;\n    int cnt = 0;\n    REP(y, H){\n      string t; cin>>t;\n      REP(x, W){\n        if(t[x] == 'o'){\n          grid[y][x] = 1;\n          cnt += 1;\n        }else if(t[x] == '.'){\n          grid[y][x] = 0;\n        }else{\n          grid[y][x] = 0;\n          nx = x;\n          ny = y;\n          REP(i, 4)if(state[i] == t[x])s = i;\n        }\n      }\n    }\n    memset(used, 0, sizeof(used));\n    string ans = dfs(nx, ny, s, cnt, \"\");\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint h,w;\nint si,sj,sd;\nchar s[11][11];\n\nint di[]={0,1,0,-1};\nint dj[]={1,0,-1,0};\n\nstring ds[]={\"R\",\"U\",\"L\",\"D\"};\n\nbool valid(int i,int j){ return i>=0&&i<h&&j>=0&&j<w; }\n\nstring dfs(int i,int j,int dir){\n  bool ok=true;\n  rep(i,h)rep(j,w){\n    if(s[i][j]=='o')ok=false;\n  }\n  if(ok)return \"\";\n  repl(d,-1,2){\n    int nd=(dir+d+4)%4;\n    int ni=i,nj=j;\n    while(valid(ni,nj)&&s[ni][nj]!='o'){\n      ni+=di[nd]; nj+=dj[nd];\n    }\n    if(valid(ni,nj)){\n      s[ni][nj]='.';\n      string nxt=dfs(nj,nj,nd);\n      if(nxt!=\"X\")return ds[nd]+nxt;\n      s[ni][nj]='o';\n    }\n  }\n  return \"X\";\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>h>>w;\n  rep(i,h)cin>>s[i];\n  rep(i,h)rep(j,w){\n    if(s[i][j]=='R'){\n      si=i; sj=j;\n      sd=0;\n    }\n    if(s[i][j]=='U'){\n      si=i; sj=j;\n      sd=1;\n    }\n    if(s[i][j]=='L'){\n      si=i; sj=j;\n      sd=2;\n    }\n    if(s[i][j]=='D'){\n      si=i; sj=j;\n      sd=3;\n    }\n  }\n  //dbg(si); dbg(sj); dbg(sd);\n  s[si][sj]='.';\n  cout<<dfs(si,sj,sd)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  VS vs(H); REP(i,H) cin >> vs[i];\n\n  queue<VS> q;\n  map<VS,pair<VS,char>> memo;\n  q.push(vs);\n  memo[vs] = MP(VS(), '!');\n  VS goal;\n  while(!q.empty()){\n\tVS vs = q.front(); q.pop();\n\tint sx = -1, sy = -1, d = -1, cnt = 0;\n\tREP(y,H) REP(x,W){\n\t  if(vs[y][x] == '.') continue;\n\t  else if(vs[y][x] == 'o')\n\t\t++cnt;\n\t  else{\n\t\tsx = x; sy = y;\n\t\tif(vs[y][x] == 'U') d = 0;\n\t\tif(vs[y][x] == 'D') d = 1;\n\t\tif(vs[y][x] == 'L') d = 2;\n\t\tif(vs[y][x] == 'R') d = 3;\n\t  }\n\t}\n\tif(cnt == 0){\n\t  goal = vs;\n\t  break;\n\t}\n\n\tREP(i,4){\n\t  if(i == d) continue;\n\t  int tx = sx, ty = sy;\n\t  while(0<=tx&&tx<W&&0<=ty&&ty<H){\n\t\tif(vs[ty][tx] == 'o') break;\n\t\ttx += dx[i];\n\t\tty += dy[i];\n\t  }\n\n\t  if(0<=tx&&tx<W&&0<=ty&&ty<H){\n\t\tVS vs_ = vs;\n\t\tvs_[sy][sx] = '.';\n\t\tchar ch;\n\t\tswitch(i){\n\t\tcase 0: ch = 'D'; break;\n\t\tcase 1: ch = 'U'; break;\n\t\tcase 2: ch = 'R'; break;\n\t\tcase 3: ch = 'L'; break;\n\t\t}\n\t\tvs_[ty][tx] = ch;\n\t\tif(!memo.count(vs_)){\n\t\t  memo[vs_] = MP(vs,ch);\n\t\t  q.push(vs_);\n\t\t}\n\t  }\n\t}\n  }\n\n  string ans;\n  while(!goal.empty()){\n\tif(memo[goal].second == '!') break;\n\tans += string(1, memo[goal].second);\n\tgoal = memo[goal].first;\n  }\n  reverse(ALL(ans));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int MAX_N = 15;\nint h, w, N;\nstring dir = \"RDLU\";\nchar field[MAX_N][MAX_N];\nchar route[50];\nbool range_check(int y, int x) { return (y < 0 || x < 0 || y >= h || x >= w) ? true : false; }\nvoid dfs(int y, int x, int pos, int cnt)\n{\n    if(cnt == N) \n    {\n        for(int i = 0; i < N; i++) cout << route[i];\n        cout << endl;\n        return;\n    }\n    for(int i = 0; i < 4; i++)\n    {\n        if(i == (pos + 2) % 4) continue;\n        int ty = y, tx = x;\n        while(!range_check(ty, tx))\n        {\n            if(field[ty][tx] == 'o')\n            {\n                //cout << ty << \" \" << tx << \" \" << cnt << endl;\n                field[ty][tx] = '.';\n                route[cnt] = dir[i];\n                dfs(ty, tx, i, cnt + 1);\n                field[ty][tx] = 'o';\n                break;\n            }\n            ty += dy[i];\n            tx += dx[i];\n        }\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    int sy, sx, spos;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w; j++)\n        {\n            char ch;\n            cin >> ch;\n            field[i][j] = ch;\n            if(ch == 'o') N++;\n            if(ch != '.' && ch != 'o')\n            {\n                sy = i, sx = j;\n                for(int k = 0; k < dir.size(); k++) if(dir[k] == ch) spos = k;\n            }\n        }\n    }\n    dfs(sy, sx, spos, 0);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nchar fie[11][11];\nint num[11][11];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nchar dc[]=\"URDL\";\nint N;\ntypedef pair<int,int> P;\n\nset<P> used;\nvector<char> ans;\n\nint check(int st,int &x,int &y,int d){\n  while( 0 <= x && x < W && 0 <= y && y < H ){\n    if( 0 <= num[x][y] && num[x][y] < N &&\n        ( st & (1<<num[x][y]) ) == 0 ){\n      return num[x][y];\n    }\n    x += dx[d]; y += dy[d];\n  }\n  return -1;\n}\n\nbool solve(int st,int x,int y,int d){\n\n  //cout << bitset<30>(st)<< \" \" << x << \" \"<< y << \" \" << d << endl;\n  if( st == (1<<N)-1 ) {\n    for(int i=0;i<(int)ans.size();i++) cout << ans[i];\n    cout << endl;\n    return true;\n  }\n\n  for(int i=3;i<6;i++){\n    int nd = (i+d)%4;\n    int id;\n    int nx = x, ny = y;\n    if( (id = check( st, nx, ny, nd )) != -1 ){\n      int nst = st | (1<<id);\n      ans.push_back( dc[nd] );      \n      if( solve( nst, nx, ny, nd ) ) return true;\n      ans.pop_back();\n    }\n  }\n  return false;\n\n}\n\nint main(){\n  cin >> H >> W;\n  N =0;\n  memset(num,-1,sizeof(num));\n  int sx,sy,sd;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> fie[j][i];\n      if( fie[j][i] == 'o' ) num[j][i] = N++;\n      if( fie[j][i] == 'U' ){ sx = j; sy = i; sd = 0; }\n      if( fie[j][i] == 'R' ){ sx = j; sy = i; sd = 1; }\n      if( fie[j][i] == 'D' ){ sx = j; sy = i; sd = 2; }\n      if( fie[j][i] == 'L' ){ sx = j; sy = i; sd = 3; }\n    }\n  }\n  assert( solve( 0, sx, sy, sd ) );\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum DIR{\n\tU,\n\tD,\n\tL,\n\tR,\n};\n\nint H,W;\nchar ans[31];\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col,leaf_num,jump_num;\n\tchar log[31],ike_map[10][11];\n\tDIR dir;\n};\n\nvoid find_next(int row,int col,DIR dir,char map[10][11],int& next_row,int& next_col){\n\tint calc_row = -1,calc_col = -1;\n\n\tswitch(dir){\n\tcase U:\n\t\tfor(int tmp_row = row-1; tmp_row >= 0; tmp_row--){\n\t\t\tif(map[tmp_row][col] == 'o'){\n\t\t\t\tcalc_row = tmp_row;\n\t\t\t\tcalc_col = col;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase D:\n\t\tfor(int tmp_row = row+1; tmp_row <= H-1; tmp_row++){\n\t\t\tif(map[tmp_row][col] == 'o'){\n\t\t\t\tcalc_row = tmp_row;\n\t\t\t\tcalc_col = col;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase L:\n\t\tfor(int tmp_col = col-1; tmp_col >= 0; tmp_col--){\n\t\t\tif(map[row][tmp_col] == 'o'){\n\t\t\t\tcalc_row = row;\n\t\t\t\tcalc_col = tmp_col;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase R:\n\t\tfor(int tmp_col = col+1; tmp_col <= W-1; tmp_col++){\n\t\t\tif(map[row][tmp_col] == 'o'){\n\t\t\t\tcalc_row = row;\n\t\t\t\tcalc_col = tmp_col;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tnext_row = calc_row;\n\tnext_col = calc_col;\n}\n\nvoid func(Info& next,Info info,DIR dir,int next_row,int next_col){\n\n\tnext.set(next_row,next_col);\n\n\tnext.leaf_num = info.leaf_num-1;\n\tfor(int i = 0; i < info.jump_num; i++){\n\t\tnext.log[i] = info.log[i];\n\t}\n\n\tchar ch;\n\n\tswitch(dir){\n\tcase U:\n\t\tch = 'U';\n\t\tbreak;\n\tcase D:\n\t\tch = 'D';\n\t\tbreak;\n\tcase L:\n\t\tch = 'L';\n\t\tbreak;\n\tcase R:\n\t\tch = 'R';\n\t\tbreak;\n\t}\n\tnext.log[info.jump_num] = ch;\n\n\tnext.jump_num = info.jump_num+1;\n\tnext.dir = dir;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tnext.ike_map[i][k] = info.ike_map[i][k];\n\t\t}\n\t}\n\n\tnext.ike_map[info.row][info.col] = '.';\n\n}\n\nint debug = 0;\n\nvoid recursive(Info info){\n\n\tif(info.leaf_num == 1){\n\t\tfor(int i = 0; i < info.jump_num; i++){\n\t\t\tans[i] = info.log[i];\n\t\t}\n\t\tans[info.jump_num] = '\\0';\n\t\treturn;\n\t}\n\n\tint next_row = -1,next_col = -1;\n\n\tswitch(info.dir){\n\tcase U:\n\t\tfind_next(info.row,info.col,U,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,U,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,L,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,L,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,R,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,R,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\t\tbreak;\n\tcase D:\n\t\tfind_next(info.row,info.col,D,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,D,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,L,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,L,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,R,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,R,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tbreak;\n\tcase L:\n\t\tfind_next(info.row,info.col,U,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,U,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,L,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,L,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,D,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,D,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tbreak;\n\tcase R:\n\n\t\tfind_next(info.row,info.col,U,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,U,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,R,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,R,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tfind_next(info.row,info.col,D,info.ike_map,next_row,next_col);\n\t\tif(next_row != -1){\n\t\t\tInfo next;\n\t\t\tfunc(next,info,D,next_row,next_col);\n\t\t\trecursive(next);\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tInfo first;\n\tfirst.leaf_num = 0;\n\tfirst.jump_num = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",first.ike_map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\n\t\t\tswitch(first.ike_map[i][k]){\n\t\t\tcase '.':break;\n\t\t\tcase 'o':\n\t\t\t\tfirst.leaf_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tfirst.leaf_num++;\n\t\t\t\tfirst.ike_map[i][k] = 'o';\n\t\t\t\tfirst.set(i,k);\n\t\t\t\tfirst.dir = U;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tfirst.leaf_num++;\n\t\t\t\tfirst.ike_map[i][k] = 'o';\n\t\t\t\tfirst.set(i,k);\n\t\t\t\tfirst.dir = D;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tfirst.leaf_num++;\n\t\t\t\tfirst.ike_map[i][k] = 'o';\n\t\t\t\tfirst.set(i,k);\n\t\t\t\tfirst.dir = L;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tfirst.leaf_num++;\n\t\t\t\tfirst.ike_map[i][k] = 'o';\n\t\t\t\tfirst.set(i,k);\n\t\t\t\tfirst.dir = R;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trecursive(first);\n\n\tprintf(\"%s\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\nstruct Kaeru { char b[10][10]; int px, py, dir; string F; };\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nqueue<Kaeru>Q; int H, W; char x[10][10]; int cx, cy, cd = 0;\nchar CC[5] = \"URDL\";\nint main() {\n\tcin >> H >> W;\n\twhile (!Q.empty())Q.pop(); int CNT = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j]; if (x[i][j] == 'o')CNT++;\n\t\t\tif (x[i][j] == 'U') { cx = i; cy = j; cd = 0; x[i][j] = '.'; }\n\t\t\tif (x[i][j] == 'R') { cx = i; cy = j; cd = 1; x[i][j] = '.'; }\n\t\t\tif (x[i][j] == 'D') { cx = i; cy = j; cd = 2; x[i][j] = '.'; }\n\t\t\tif (x[i][j] == 'L') { cx = i; cy = j; cd = 3; x[i][j] = '.'; }\n\t\t}\n\t}\n\tKaeru D; for (int i = 0; i < 100; i++)D.b[i / 10][i % 10] = x[i / 10][i % 10];\n\tD.px = cx; D.py = cy; D.dir = cd; D.F = \"\"; Q.push(D);\n\twhile (!Q.empty()) {\n\t\tKaeru a1 = Q.front(); Q.pop();\n\t\tKaeru a2 = a1;\n\t\tif (a2.F.size() == CNT) { cout << a2.F << endl; break; }\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\ta2 = a1; char y[10][10]; for (int j = 0; j < 100; j++)y[j / 10][j % 10] = a1.b[j / 10][j % 10];\n\t\t\tif (i == (a1.dir + 2) % 4)continue;\n\t\t\tint ex = a1.px, ey = a1.py;\n\t\t\twhile (true) {\n\t\t\t\tex += dx[i]; ey += dy[i];\n\t\t\t\tif (ex < 0 || ey < 0 || ex >= H || ey >= W)break;\n\t\t\t\tif (y[ex][ey] == 'o') {\n\t\t\t\t\ty[ex][ey] = '.'; for (int j = 0; j < 100; j++)a2.b[j / 10][j % 10] = y[j / 10][j % 10];\n\t\t\t\t\ta2.px = ex; a2.py = ey; a2.dir = i; a2.F += CC[i];\n\t\t\t\t\tQ.push(a2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint H, W;\nset<ll> memo[20][20][4];\nint id[20][20];\nchar field[20][20];\nconst string dirs = \"ULDR\";\n\nint dr[] = {-1, 0, 1, 0};\nint dc[] = {0, -1, 0, 1};\n\ninline bool inside(int r, int c){\n  return 0 <= r && r < H && 0 <= c && c < W;\n}\n\nbool calc(string &res, ll mask, int r, int c, int dir,int pos){\n  if(__builtin_popcountll(mask) == 0) return true;\n  assert(pos < (int)res.size());\n  \n  for(int i = -1; i <= 1; i++){\n    int ndir = (dir + i + 4) % 4;\n    int nr = r;\n    int nc = c;\n    while(inside(nr, nc)){\n      if(id[nr][nc] >= 0 && PARITY(mask >> id[nr][nc]) == 1){\n\tbreak;\n      }\n      nr += dr[ndir];\n      nc += dc[ndir];\n    }\n    \n    \n    if(inside(nr, nc)){\n      ll nmask = mask ^ (1LL << id[nr][nc]);\n      if(memo[nr][nc][ndir].count(nmask)) continue;\n\n      res[pos] = dirs[ndir];\n      if(calc(res, nmask, nr, nc, ndir, pos + 1)) return true;\n      memo[nr][nc][ndir].insert(nmask);\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin >> H >> W;\n  REP(i, H)REP(j, W) cin >> field[i][j];\n  int r, c, dir, count = 0;\n  memset(id, -1, sizeof(id));  \n  \n  REP(i, H)REP(j, W){\n    if(field[i][j] == 'o'){\n      id[i][j] = count++;\n    }\n    if(isupper(field[i][j])){\n      r = i;\n      c = j;\n      dir = find(ALL(dirs), field[i][j]) - dirs.begin();\n    }\n  }\n  string res(count, ' ');\n  assert(calc(res, (1LL << count) - 1, r, c, dir, 0));\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nint dx[] = { -1, 0, 1, 0 }; int dy[] = { 0, 1, 0, -1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n/*--------------------template--------------------*/\n\nint n, m;\nstring ans;\nvs fld;\nvoid solve(int x, int y, int d)\n{\n\tbool f = true;\n\tREP(i, n)REP(j, m) if (fld[i][j] == 'o') f = false;\n\tif (f)\n\t{\n\t\tcout << ans << endl;\n\t\treturn;\n\t}\n\tfor (int i = -1; i <= 1; i++)\n\t{\n\t\tint dir = (i+d+4)%4;\n\t\tint dirx = dx[dir], diry = dy[dir];\n\t\tint tx = x, ty = y;\n\t\tint nx, ny;\n\t\twhile (1)\n\t\t{\n\t\t\ttx += dirx, ty += diry;\n\t\t\tif (!valid(tx, ty, n, m)) goto next;\n\t\t\tif (fld[tx][ty] == 'o')\n\t\t\t{\n\t\t\t\tnx = tx, ny = ty;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfld[nx][ny] = '.';\n\t\tif (dir == 0) ans += 'U';\n\t\tif (dir == 1) ans += 'R';\n\t\tif (dir == 2) ans += 'D';\n\t\tif (dir == 3) ans += 'L';\n\t\tsolve(nx, ny, dir);\n\t\tfld[nx][ny] = 'o';\n\t\tans.pop_back();\n\tnext:;\n\t}\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tfld.resize(n);\n\tREP(i, n) cin >> fld[i];\n\tint sx, sy, d;\n\tREP(i, n)REP(j, m)\n\t{\n\t\tif (fld[i][j] == 'U') d = 0;\n\t\telse if (fld[i][j] == 'R') d = 1;\n\t\telse if (fld[i][j] == 'D') d = 2;\n\t\telse if (fld[i][j] == 'L') d = 3;\n\t\telse continue;\n\t\tsx = i, sy = j;\n\t\tfld[sx][sy] = '.';\n\t}\n\tsolve(sx, sy, d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\nstruct Kaeru { char b[10][10]; int px, py, dir; string F; };\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nqueue<Kaeru>Q; int H, W; char x[10][10]; int cx, cy, cd = 0;\nchar CC[5] = \"URDL\";\nint main() {\n\tcin >> H >> W;\n\twhile (!Q.empty())Q.pop(); int CNT = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j]; if (x[i][j] == 'o')CNT++;\n\t\t\tif (x[i][j] == 'U') { cx = i; cy = j; cd = 0; x[i][j] = '.'; }\n\t\t\tif (x[i][j] == 'R') { cx = i; cy = j; cd = 1; x[i][j] = '.'; }\n\t\t\tif (x[i][j] == 'D') { cx = i; cy = j; cd = 2; x[i][j] = '.'; }\n\t\t\tif (x[i][j] == 'L') { cx = i; cy = j; cd = 3; x[i][j] = '.'; }\n\t\t}\n\t}\n\tKaeru D; for (int i = 0; i < 100; i++)D.b[i / 10][i % 10] = x[i / 10][i % 10];\n\tD.px = cx; D.py = cy; D.dir = cd; D.F = \"\"; Q.push(D);\n\twhile (!Q.empty()) {\n\t\tKaeru a1 = Q.front(); Q.pop();\n\t\tKaeru a2 = a1;\n\t\tif (a2.F.size() == CNT) { cout << a2.F << endl; break; }\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\ta2 = a1; char y[10][10]; for (int j = 0; j < 100; j++)y[j / 10][j % 10] = a2.b[j / 10][j % 10];\n\t\t\tif (i == (a1.dir + 2) % 4)continue;\n\t\t\tint ex = a2.px, ey = a2.py;\n\t\t\twhile (true) {\n\t\t\t\tex += dx[i]; ey += dy[i];\n\t\t\t\tif (ex < 0 || ey < 0 || ex >= H || ey >= W)break;\n\t\t\t\tif (y[ex][ey] == 'o') {\n\t\t\t\t\ty[ex][ey] = '.';\n\t\t\t\t\tfor (int j = 0; j < 100; j++)a2.b[j / 10][j % 10] = y[j / 10][j % 10];\n\t\t\t\t\ta2.px = ex; a2.py = ey; a2.dir = i; a2.F += CC[i];\n\t\t\t\t\tQ.push(a2); break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nint n, m;\nchar g[12][12];\nchar ans[35];\nint LeafNum;\nint endFlag;\n\nvoid BFS(int x, int y, int leaf_num, int dir)\n{\n    //printf(\"BFS : %d %d %d %d\\n\", x,y,leaf_num,dir);\n    if(endFlag == 1)\n        return;\n\n    if(leaf_num == 0)\n    {\n        endFlag = true;\n        return;\n    }\n\n    //Up\n    if(dir != 2)\n        for(int i = x - 1; i >= 0 && endFlag == 0; i--)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                ans[LeafNum - leaf_num] = 'U';\n                BFS(i, y, leaf_num - 1, 0);\n\n                g[i][y] = 'o';\n            }\n\n    //Down\n    if(dir != 0)\n        for(int i = x + 1; i < n && endFlag == 0; i++)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                ans[LeafNum - leaf_num] = 'D';\n                BFS(i, y, leaf_num - 1, 2);\n\n                g[i][y] = 'o';\n            }\n\n    //Left\n    if(dir != 3)\n        for(int i = y - 1; i >= 0 && endFlag == 0; i--)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                ans[LeafNum - leaf_num] = 'L';\n                BFS(x, i, leaf_num - 1, 1);\n\n                g[x][i] = 'o';\n            }\n\n    //Right\n    if(dir != 1)\n        for(int i = y + 1; i < m && endFlag == 0; i++)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                ans[LeafNum - leaf_num] = 'R';\n                BFS(x, i, leaf_num - 1, 3);\n\n                g[x][i] = 'o';\n            }\n\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n\n    int x, y;\n    int leaf_num = 0;\n    int dir = 0;// 0 is up, 1 is left, 2 is down, 3 is right\n\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", g[i]);\n        for(int j = 0; j < m; j++)\n        {\n            if(g[i][j] == 'U' || g[i][j] == 'R' || g[i][j] == 'L' || g[i][j] == 'D')\n            {\n                x = i;\n                y = j;\n                if(g[i][j] == 'U'){ dir = 0; }\n                if(g[i][j] == 'L'){ dir = 1; }\n                if(g[i][j] == 'D'){ dir = 2; }\n                if(g[i][j] == 'R'){ dir = 3; }\n            }\n            if(g[i][j] == 'o')\n                leaf_num++;\n        }\n    }\n\n    g[x][y] = '.';\n    LeafNum = leaf_num;\n    endFlag = 0;\n\n    BFS(x, y, leaf_num, dir);\n\n    //printf(\"Leaf : %d\\n\", LeafNum);\n    for (int i = 0; i < LeafNum; ++i)\n    {\n        printf(\"%c\", ans[i]);\n    }\n    printf(\"\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#pragma warning(disable: 4996)\nint H, W, r, cnt,  dir[4] = { 1, 0, -1, 0 }; char c[12][12], f[31], g[] = \"RDLU\";\nvoid solve(int x, int y, int d, int e) {\n\tif (d == r) {\n\t\tif (cnt++ == 0) {\n\t\t\tfor (int i = 0; i < r; i++) printf(\"%c\", f[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tif ((i + 2) % 4 == e) continue;\n\t\tint tx = x, ty = y;\n\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\tif (c[ty][tx] == 'o') {\n\t\t\t\tc[ty][tx] = '.'; f[d] = g[i];\n\t\t\t\tsolve(tx, ty, d + 1, i);\n\t\t\t\tc[ty][tx] = 'o'; f[d] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += dir[i];\n\t\t\tty += dir[i ^ 1];\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) scanf(\"%s\", c[i]);\n\tint sy, sx, se;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif (c[i][j] == g[k]) {\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t\tse = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c[i][j] == 'o') r++;\n\t\t}\n\t}\n\tsolve(sx, sy, 0, se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*By pigeatshit*/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <cmath>\n#include <vector>\n#include <map>\n#define LL long long\n#define reset(c,x) memset (c, x, sizeof (c))\n#define PN printf(\"\\n\")\n#define NN int n;scanf(\"%d\", &n)\n#define NM int n,m;scanf(\"%d%d\", &n, &m)\n#define NMK int n,m,k;scanf(\"%d%d%d\", &n, &m, &k)\n\nusing namespace std;\n\nint h, w;\n\nchar pos[20][20];\n\nint path[50];\nint p;\n\nint banx[] = {0,0,1,-1};\nint bany[] = {1,-1,0,0};\n\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\n\nint getdir(char c)\n{\n    if(c == 'U') return 0;\n    if(c == 'D') return 1;\n    if(c == 'L') return 2;\n    if(c == 'R') return 3;\n    return -1;\n}\n\nint dfs(int x, int y, int dir, int num)\n{\n    if(num == 0) return 1;\n    for(int i = 0; i < 4; i++)\n    {\n        if(dx[i] == banx [dir] && dy[i] == bany[dir]) continue;\n        int xx = x+dx[i], yy = y+dy[i];\n        while(xx >= 0 && yy >= 0 && xx < w && yy < h)\n        {\n            if(pos[yy][xx] == 'o')\n            {\n                pos[y][x] = '.';\n                path[p++] = i;\n                int res = dfs(xx, yy, i, num-1);\n                if(res) return 1;\n                p--;\n                pos[y][x] = 'o';\n                break;\n            }\n            else\n            {\n                xx += dx[i];\n                yy += dy[i];\n            }\n        }\n    }\n    return 0;\n}\n\n\nint main()\n{\n    reset(path, 0);\n    p = 0;\n    scanf(\"%d%d\",&h,&w);\n    for(int i = 0; i < h; i++)\n        scanf(\"%s\",pos[i]);\n\n    int dir = -1;\n    int x,y;\n    int num = 0;\n    for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++)\n    {\n        if(pos[i][j] == 'o') num++;\n        if(pos[i][j] != '.' && pos[i][j] != 'o')\n        {\n            dir = getdir(pos[i][j]);\n            x = j; y = i;\n        }\n    }\n\n    int flag = dfs(x,y,dir,num);\n\n    for(int i = 0; i < p; i++)\n    {\n        if(path[i] == 0) printf(\"U\");\n        if(path[i] == 1) printf(\"D\");\n        if(path[i] == 2) printf(\"L\");\n        if(path[i] == 3) printf(\"R\");\n    }\n    PN;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int MAX_N = 15;\nint h, w, N;\nstring dir = \"RDLU\";\nchar field[MAX_N][MAX_N];\nchar route[50];\nbool range_check(int y, int x) { return (y < 0 || x < 0 || y >= h || x >= w) ? true : false; }\nvoid dfs(int y, int x, int pos, int cnt)\n{\n    if(cnt == N) \n    {\n        for(int i = 0; i < N; i++) cout << route[i];\n        cout << endl;\n        return;\n    }\n    for(int i = 0; i < 4; i++)\n    {\n        if(i == (pos + 2) % 4) continue;\n        int ty = y, tx = x;\n        while(!range_check(ty, tx))\n        {\n            if(field[ty][tx] == 'o')\n            {\n                //cout << ty << \" \" << tx << \" \" << cnt << endl;\n                field[ty][tx] = '.';\n                route[cnt] = dir[i];\n                dfs(ty, tx, i, cnt + 1);\n                field[ty][tx] = 'o';\n                break;\n            }\n            ty += dy[i];\n            tx += dx[i];\n        }\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    int sy, sx, spos;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w; j++)\n        {\n            char ch;\n            cin >> ch;\n            field[i][j] = ch;\n            if(ch == 'o') N++;\n            if(ch != '.' && ch != 'o')\n            {\n                sy = i, sx = j;\n                for(int k = 0; k < dir.size(); k++) if(dir[k] == ch) spos = k;\n            }\n        }\n    }\n    dfs(sy, sx, spos, 0);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H, W, N;\nconstexpr char D[4] = {'U', 'R', 'D', 'L'};\nconstexpr int dx[4] = {0, 1, 0, -1},\n              dy[4] = {-1, 0, 1, 0};\n\nstring dfs(int y, int x, int d, string res, vector<string>& v) {\n    if(res.size() == N) {\n        return res;\n    }\n\n    v[y][x] = '.';\n    for(int i=0; i<4; ++i) {\n        if(i == (d + 2) % 4) {\n            continue;\n        }\n\n        int ny = y, nx = x;\n        while(0 <= ny && ny < H && 0 <= nx && nx < W) {\n            if(v[ny][nx] == 'o') {\n                break;\n            }\n            ny += dy[i];\n            nx += dx[i];\n        }\n        if(0 <= ny && ny < H && 0 <= nx && nx < W) {\n            string r = dfs(ny, nx, i, res + D[i], v);\n            if(r != \"\") {\n                return r;\n            }\n        }\n    }\n    v[y][x] = 'o';\n\n    return \"\";\n}\n\nint main() {\n    cin >> H >> W;\n    vector<string> v(H);\n    int sx, sy, sd;\n    for(int i=0; i<H; ++i) {\n        cin >> v[i];\n        for(int j=0; j<W; ++j) {\n            N += v[i][j] == 'o';\n            if(v[i][j] == 'U' || v[i][j] == 'D' || v[i][j] == 'L' || v[i][j] == 'R') {\n                sy = i;\n                sx = j;\n                sd = find(D, D+4, v[i][j]) - D;\n            }\n        }\n    }\n    cout << dfs(sy, sx, sd, \"\", v) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint H, W;\nchar c[11][11];\n\nstring ans;\nstring dir = \"RULD\";\nint dy[] = {0, -1, 0, 1}, dx[] = {1, 0, -1, 0};\n\nbool inrange(int y, int x)\n{\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nbool solve(int y, int x, int d, int cnt)\n{\n  c[y][x] = '.';\n  if(cnt == 0) return true;\n  rep(i, 3) {\n    int nd = (d+i+3) % 4, ny = y, nx = x;\n    while(inrange(ny, nx) && c[ny][nx] == '.') {\n      ny += dy[nd], nx += dx[nd];\n    }\n    ans += dir[nd];\n    if(inrange(ny, nx) && solve(ny, nx, nd, cnt-1)) return true;\n    ans.pop_back();\n  }\n  c[y][x] = 'o';\n  return false;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n\n  int sy, sx, cnt = 0;\n\n  cin >> H >> W;\n  rep(i, H) rep(j, W) {\n    cin >> c[i][j];\n    if(dir.find(c[i][j]) != -1) sy = i, sx = j;\n    if(c[i][j] == 'o') cnt++;\n  }\n\n  ans = \"\";\n  solve(sy, sx, dir.find(c[sy][sx]), cnt);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n#define abs(x) ((x)>=0?(x):-(x))\n#define i64 long long\n#define u32 unsigned int\n#define u64 unsigned long long\n#define clr(x,y) memset(x,y,sizeof(x))\n#define PI acos(-1.0)\n#define sqr(x) ((x)*(x))\n#define maxn 20\n\nchar mp1[maxn][maxn];\nint mp[maxn][maxn];\nint dx[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nint t[5] ;\nint hash[256];\nchar str[10] = \"DRUL\";\nint n,m;\nint sx , sy;\nint sdir;\nint st[1000005];\nint num ;\nint ans ;\nvoid init()\n{\n  memset(hash,-1,sizeof(hash));\n  hash['U'] = 2;\n  hash['D'] = 0;\n  hash['R'] = 1;\n  hash['L'] = 3;\n  t[0] = 2;\n  t[1] = 3;\n  t[2] = 0;\n  t[3] = 1;\n}\nint check(int x ,int y ,int dir )\n{\n  int res;\n  res = 0 ;\n  x += dx[dir][0];\n  y += dx[dir][1];\n  res ++ ;\n  while(mp[x][y] == 0 && x <= n && y <= m && x > 0 && y > 0  )\n  {\n    res ++ ;\n    x += dx[dir][0];\n    y += dx[dir][1];\n  }\n  //printf(\"%d\\n\",res);\n  if(mp[x][y] == 0 ) return -1;\n  else return res;\n}\nbool flag;\nint sd;\nvoid print(int nn )\n{\n  sd = sdir;\n  int cnt = sd;\n  for(int i = 0 ; i < nn ; i ++ )\n  {\n    if(st[i] == 0 && sd == 3 ) cnt = (cnt + 1 )% 4 ;\n    else if(st[i] == 3 && sd == 0 )  cnt = (cnt - 1 + 4 ) % 4;\n    else if(st[i] > sd ) cnt = (cnt + 1 ) % 4;\n    else if(st[i] < sd  ) cnt = (cnt - 1 + 4) % 4 ;\n    sd = st[i];\n    printf(\"%c\",str[cnt]);\n  }\n  printf(\"\\n\");\n}\nvoid dfs(int x ,int y ,int dir, int dep )\n{\n  //printf(\"dfs: %d %d\\n\",x,y);\n  if(flag ) return ;\n  if(num == 1)\n  {\n    print(dep);\n    flag = true ;\n    return ;\n  }\n  int kk , xx , yy , ndir ;\n  ndir = t[dir];\n  for(int k = 0; k < 4; k ++ )\n    if(flag == false && k != ndir  )\n    {\n      kk = check(x,y,k);\n      if(kk == -1 ) continue;\n      xx = x + kk * dx[k][0];\n      yy = y + kk * dx[k][1];\n      num = num - 1 ;\n      mp[x][y] = 0 ;\n      st[dep] = k ;\n      dfs(xx , yy , k , dep + 1 );\n      num = num + 1 ;\n      mp[x][y] = 1;\n    }\n}\nint main()\n{\n  init();\n  while(scanf(\"%d%d\",&n,&m)!=EOF)\n  {\n    memset(mp,0,sizeof(mp));\n    num = 0 ;\n    sx = -1;\n    sy = -1;\n    for(int i = 1 ; i <= n ; i++ )\n    {\n      scanf(\"%s\",mp1[i]);\n      // printf(\"%s|\\n\",mp1[i]);\n      for(int j = 0 ; j < m ; j ++ )\n      {\n        // printf(\"%c\",mp1[i][j]);\n        if(mp1[i][j] == 'o')\n        {\n          num ++ ;\n          mp[i][j + 1 ] = 1 ;\n        }\n        else if(mp1[i][j] == '.' )\n        {\n          mp[i][j+1] = 0 ;\n        }\n        else// if(mp1[i][j] == 'U' ||mp1[i][j] == 'D' ||mp1[i][j] == 'L'||mp1[i][j] =='R' )\n        {\n          // printf(\"aasdmaklsd\");\n          num ++ ;\n          mp[i][j+1] = 1;\n          sx = i;\n          sy = j + 1 ;\n         // printf(\"sx sy %d %d\\n\",sx,sy);\n          sdir = hash[mp1[i][j]];\n        }\n      }\n    }\n   // printf(\"%d %d\\n\",sx,sy);\n    int tmp ;\n    tmp = num;\n    flag = false;\n    dfs(sx,sy,sdir,0);\n  }\n  return 0;\n}\n\n\n/*\n\nURRULULDDLUURDLLLURRDLDDDRRDR\nURRULULDDLUURDLLLURRDLDDDRRDR\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <fstream>\n\nusing namespace std;\n\n#define MAXN 11\n\nint n, m, s, e, d, total;\nint c[MAXN][MAXN];\nint dir[4][2] = {0, -1, -1, 0, 0, 1, 1, 0};\nint ans[MAXN * MAXN];\nbool ok;\n\nint change(char ch)\n{\n    switch(ch)\n    {\n        case 'L': return 0;\n        case 'U': return 1;\n        case 'R': return 2;\n        case 'D': return 3;\n    }\n}\n\nchar changetwo(int x)\n{\n    switch(x)\n    {\n        case 0: return 'L';\n        case 1: return 'U';\n        case 2: return 'R';\n        case 3: return 'D';\n    }\n}\n\nvoid dfs(int x, int y, int len, int di)\n{\n    if (len == total)\n    {\n        ok = true;\n        return ;\n    }\n\n    if (ok)\n    {\n        return ;\n    }\n\n    for (int i = 3; i < 6; i++)\n    {\n        for (int k = 1; k <= 10; k++)\n        {\n            int xt = x + dir[(i + di) % 4][0] * k, yt = y + dir[(i + di) % 4][1] * k;\n\n            if (xt >= 0 && xt < n && yt >= 0 && yt < m && !ok)\n            {\n                if (c[xt][yt] == 1)\n                {\n                    ans[len] = (i + di) % 4;\n                    len++;\n                    c[xt][yt] = 0;\n                    dfs(xt, yt, len, (i + di) % 4);\n\n                    len--;\n                    c[xt][yt] = 1;\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid solve()\n{\n    dfs(s, e, 0, d);\n\n    for (int i = 0; i < total; i++)\n    {\n        cout << changetwo(ans[i]);\n    }\n    cout << endl;\n}\n\nvoid input()\n{\n    char ch;\n\n    while (cin >> n >> m)\n    {\n        total = 0;\n        ok = false;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m; j++)\n            {\n                cin >> ch;\n                if (ch == '.')\n                {\n                    c[i][j] = 0;\n                }\n                else if (ch == 'o')\n                {\n                    total++;\n                    c[i][j] = 1;\n                }\n                else\n                {\n                    d = change(ch);\n                    s = i, e = j;\n                    c[i][j] = 0;\n                }\n            }\n        }\n\n        solve();\n    }\n}\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    input();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint n,h,w,f=0;\nstring st[20];\nmap<P,int> m;\nmap<int,P> r;\nchar c[5]=\"RDLU\";\nint ai[]={0,1,0,-1};\nint aj[]={1,0,-1,0};\nbool in(int i,int j){\n  return (0<=i&&i<h&&0<=j&&j<w);\n}\nvoid dfs(int b,int p,int d,string s){\n  //cout<<b<<p<<\"/\"<<d<<s<<endl;\n  if(f) return;\n  if(b==(1<<n)-1){\n    f=1;\n    cout<<s<<endl;\n    return;\n  }\n  for(int k=0;k<4;k++){\n    //cout<<k<<endl;\n    if((d+2)%4==k) continue;\n    int i=r[p].first,j=r[p].second;\n    while(1){\n      while(in(i,j)&&st[i][j]=='.') i+=ai[k],j+=aj[k];//,cout<<i<<j<<endl;\n      if(!in(i,j)) break;\n      if((b>>m[P(i,j)])&1){\n\ti+=ai[k],j+=aj[k];\n\tcontinue;\n      }\n      break;\n    }\n    if(!in(i,j)) continue;\n    if(m.find(P(i,j))==m.end()) continue;\n    int x=m[P(i,j)];\n    dfs(b+(1<<x),x,k,s+c[k]);\n  }\n}\nsigned main(){\n  int d;\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>st[i];\n  n=1;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(st[i][j]=='o'){\n\tm[P(i,j)]=n;\n\tr[n]=P(i,j);\n\tn++;\n      }\n      for(int k=0;k<4;k++){\n\tif(st[i][j]==c[k]){\n\t  m[P(i,j)]=0;\n\t  r[0]=P(i,j);\n\t  d=k;\n\t  st[i][j]='.';\n\t}\n      }\n    }\n  }\n  dfs(1,0,d,\"\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,h,sum,dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nstring s[11],t;\nmap<int,char>m;\nvoid dfs(int y,int x,int d,char p){\n  if(d==sum){\n    cout<<t<<endl;\n    exit(0);\n  }\n  else{\n    char a=p;\n    s[y][x]='.';\n    r(i,4){\n      int yy=y,xx=x;\n      if(a=='U'&&i==2||a=='D'&&i==0||a=='R'&&i==3||a=='L'&&i==1)continue;\n      r(j,50){\n        yy+=dy[i],xx+=dx[i];\n        if(yy>=h||xx>=w||xx<0||yy<0)break;\n        if(s[yy][xx]=='o'){\n          t+=m[i];\n          dfs(yy,xx,d+1,m[i]);\n          t.erase(t.end()-1);\n          break;\n        }\n      }\n    }\n    s[y][x]='o';\n  }\n}\nint main(){\n  m[0]='U';m[1]='R';m[2]='D';m[3]='L';\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='o')sum++;\n  r(i,h)r(j,w)if(s[i][j]!='.'&&s[i][j]!='o')dfs(i,j,0,s[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint H, W;\nint num;\nchar c[15][15];\nchar ans[40];\nconst int vecj[] = {1, 0, -1, 0}, veci[] = {0, -1, 0, 1};\nconst char dirc[] = {'R', 'U', 'L', 'D'};\n\nbool dfs(int fi, int fj, int dir, int idx)\n{\n\tint ni, nj, nd;\n\tif(idx == num) return true;\n\t\n\tfor(int d = -1; d <= 1; d++){\n\t\tni = fi, nj = fj, nd = (dir+d+4)%4;\n\t\twhile(1){\n\t\t\tni += veci[nd], nj += vecj[nd];\n\t\t\tif(ni < 0 || ni >= H || nj < 0 || nj >= W) break;\n\t\t\tif(c[ni][nj] == 'o'){\n\t\t\t\tc[ni][nj] = '.';\n\t\t\t\tans[idx] = dirc[nd];\n\t\t\t\tif(dfs(ni, nj, nd, idx+1)) return true;;\n\t\t\t\tc[ni][nj] = 'o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\tint fi, fj, dir;\n\tnum = 0;\n\t\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> c[i][j];\n\t\t\tif(c[i][j] != 'o' && c[i][j] != '.') fi = i, fj = j;\n\t\t\telse if(c[i][j] == 'o') num++;\n\t\t}\n\t}\n\t\n\tswitch(c[fi][fj]){\n\tcase 'U':\n\t\tdir = 1;\n\t\tbreak;\n\tcase 'D':\n\t\tdir = 3;\n\t\tbreak;\n\tcase 'L':\n\t\tdir = 2;\n\t\tbreak;\n\tcase 'R':\n\t\tdir = 0;\n\t\tbreak;\n\t}\n\t\n\tdfs(fi, fj, dir, 0);\n\tfor(int i = 0; i < num; i++) cout << ans[i];\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10\n#define M 30\nusing namespace std;\nint h,w,sy,sx,sd,ocnt;\nstring s[N],ans;\nchar c[M];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nchar itoc[4]={'U','R','D','L'};\n\nvoid dfs(int y,int x,int d,int cnt){\n  if(cnt==ocnt){\n    for(int i=0;i<cnt;i++)ans+=c[i];\n    return;\n  }\n  for(int i=-1;i<=1;i++){\n    int nd=(d+i+4)%4;\n    int ny=y+dy[nd],nx=x+dx[nd];\n    while(1){\n      if(ny<0||nx<0||h<=ny||w<=nx)break;\n      if(s[ny][nx]=='o'){\n\ts[ny][nx]='.';\n\tc[cnt]=itoc[nd];\n\tdfs(ny,nx,nd,cnt+1);\n\ts[ny][nx]='o';\n\tbreak;\n      }\n      ny+=dy[nd];\n      nx+=dx[nd];\n    }\n  }\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='o')ocnt++;\n      else if(s[i][j]!='.'){\n\tsy=i,sx=j;\n\tif(s[i][j]=='U')sd=0;\n\tif(s[i][j]=='R')sd=1;\n\tif(s[i][j]=='D')sd=2;\n\tif(s[i][j]=='L')sd=3;\n      }\n    }\n  }\n  dfs(sy,sx,sd,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint init_dic(int x,int y,\n\t    map<P,int>& dic){\n  if(dic.find(P(x,y)) == dic.end()){\n    int idx = dic.size();\n    dic[P(x,y)] = idx;\n  }\n  return dic[P(x,y)];\n}\n\nvoid fill_dic(int W,int H,map<P,int>& dic){\n  for(int x=0;x<=W;x++){\n    for(int y=0;y<=H;y++){\n      if(dic.find(P(x,y)) == dic.end()){\n\tdic[P(x,y)] = -1;\n      }\n    }\n  }\n}\n\nclass State{\npublic:\n  int x;\n  int y;\n  int dir;\n  int remaining;\n  int cost;\n  vector<char> route;\n  State(int _x,int _y,int _dir,int _remaining,int _cost,const vector<char>& _r)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost),route(_r) {}\n  State(int _x,int _y,int _dir,int _remaining,int _cost)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[101][101];\n    int sx,sy;\n    int dir;\n    int init_state=0;\n    map<P,int> dic;\n\n    for(int y=0;y<H;y++){\n      char buf[101];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = buf[x];\n\tif(buf[x] == 'U' || buf[x] == 'R'\n\t   || buf[x] == 'D' || buf[x] == 'L'){\n\t  sx = x;\n\t  sy = y;\n\t  init_state |= (1<<init_dic(x,y,dic));\n\n\t  const char dirs[4] = {'U','R','D','L'};\n\t  for(int i=0;i<4;i++){\n\t    if(dirs[i] == buf[x]){\n\t      dir = i;\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(buf[x] == 'o'){\n\t  init_state |= (1<<init_dic(x,y,dic));\n\t}\n      }\n    }\n    \n    fill_dic(W,H,dic);\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,dir,init_state,0));\n\n    set<int> visited[101][101][4];\n    bool flag = false;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(visited[s.x][s.y][s.dir].count(s.remaining) > 0) continue;\n      visited[s.x][s.y][s.dir].insert(s.remaining);\n\n      if(__builtin_popcount(s.remaining) == 1){\n\tconst char dirs[4] = {'U','R','D','L'};\n\tstring ans = \"\";\n\tfor(int i=0; i<s.route.size(); i++){\n\t  ans += dirs[s.route[i]];\n\t}\n\tcout << ans << endl;\n      }\n\n      for(int i=0;i<4;i++){\n\tif(i == (s.dir + 2) % 4) continue;\n\n\tint dx,dy;\n\tfor(int j=1;j<=max(H,W);j++){\n\t  dx = s.x + tx[i] * j;\n\t  dy = s.y + ty[i] * j;\n\t  if(dx < 0 || dy < 0 || dx >= W || dy >= H ) continue;\n\t  if(dic[P(dx,dy)] == -1) continue;\n\t  \n\t  if(s.remaining & (1<<dic[P(dx,dy)])){\n\t    int next = s.remaining & ~(1<<dic[P(s.x,s.y)]);\n\t    vector<char> next_route = s.route;\n\t    next_route.push_back(i);\n\t    que.push(State(dx,dy,i,next,s.cost+1,next_route));\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nconst char dir[] = {'L', 'D', 'R', 'U'};\n\nstruct P {\n    int x, y;\n    int d;\n    int cnt;\n    vvb G;\n    string moves;\n};\n\nint H, W;\n\nint main() {\n    cin >> H >> W;\n\n    vvb G(H, vb(W, false));\n    int sx, sy, d;\n    int cnt = 0;\n    REP(y, H) REP(x, W) {\n        char c;\n        cin >> c;\n        if (c == 'o') {\n            cnt++;\n            G[y][x] = true;\n        } else if (c != '.') {\n            sx = x;\n            sy = y;\n            d = find(dir, dir+4, c) - dir;\n        }\n    }\n\n    queue<P> que;\n    string moves;\n    que.push({sx, sy, d, 0, G, moves});\n\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        if (p.cnt >= 30) continue;\n        if (p.cnt == cnt) {\n            cout << p.moves << endl;\n            break;\n        }\n        int x = p.x, y = p.y;\n        if (p.d != 0) for (int x = p.x; x < W; x++) {\n            if (p.G[y][x]) {\n                vvb g = p.G;\n                g[y][x] = false;\n                que.push({x, y, 2, p.cnt+1, g, p.moves + \"R\"});\n                break;\n            }\n        }\n        if (p.d != 2) for (int x = p.x; x >= 0; x--) {\n            if (p.G[y][x]) {\n                vvb g = p.G;\n                g[y][x] = false;\n                que.push({x, y, 0, p.cnt+1, g, p.moves + \"L\"});\n                break;\n            }\n        }\n        if (p.d != 3) for (int y = p.y; y < H; y++) {\n            if (p.G[y][x]) {\n                vvb g = p.G;\n                g[y][x] = false;\n                que.push({x, y, 1, p.cnt+1, g, p.moves + \"D\"});\n                break;\n            }\n        }\n        if (p.d != 1) for (int y = p.y; y >= 0; y--) {\n            if (p.G[y][x]) {\n                vvb g = p.G;\n                g[y][x] = false;\n                que.push({x, y, 3, p.cnt+1, g, p.moves + \"U\"});\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nstring ans;\nconst int dx[4] = { 1,-1,0,0 };\nconst int dy[4] = { 0,0,1,-1 };\nstring bo = \"DURL\";\nint n, m;\nint grid[10][10];\nint cnt = -1;\nvoid dfs(tuple<int, int, int> now) {\n    if (cnt == 0) {\n        cout << ans << endl;\n        exit(0);\n    }\n    grid[get<0>(now)][get<1>(now)] = 0;\n    cnt--;\n    REP(i, 4) {\n        if ((i ^ 1) == get<2>(now)) continue;\n        for (int j = 1;; ++j) {\n            int x = get<0>(now) + dx[i] * j;\n            int y = get<1>(now) + dy[i] * j;\n            if (x >= 0 && x < n && y >= 0 && y < m) {\n                if (grid[x][y] == 1) {\n                    ans.push_back(bo[i]);\n                    dfs(make_tuple(x, y, i));\n                    ans.pop_back();\n                    break;\n                }\n            }\n            else break;\n        }\n    }\n    cnt++;\n    grid[get<0>(now)][get<1>(now)] = 1;\n}\n\nvoid solve() {\n    cin >> n >> m;\n    tuple<int, int, int> now;\n    REP(i, n) {\n        string s;\n        cin >> s;\n        REP(q, m) {\n            if (s[q] == 'o') grid[i][q] = 1;\n            REP(j, bo.size()) {\n                if (bo[j] == s[q]) {\n                    now = make_tuple(i, q, j);\n                    grid[i][q] = 1;\n                }\n            }\n            cnt += grid[i][q];\n        }\n    }\n    dfs(now);\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nstring ans,dir = \"URDL\";\nvector<string> g;\n\nbool dfs(int y,int x,int d,int rem){\n  if(rem==0)return true;\n  char tmp = g[y][x];\n  g[y][x] = '.';\n\n  for(int i=3;i<=5;i++){\n    int nd = (d+i)%4, ny = y + dy[nd], nx = x + dx[nd];\n    while(ny>=0 && nx>=0 && ny<h && nx<w){\n      if(g[ny][nx] == 'o'){\n\tans += dir[nd];\n\tif(dfs(ny,nx,nd,rem-1))return true;\n\tans.pop_back();\n\tbreak;\n      }\n      ny += dy[nd]; nx += dx[nd];\n    }\n  }\n\n  g[y][x] = tmp;\n  return false;\n}\n\nint main(){\n  int y,x,d,cnt = 0;\n  cin >> h >> w;\n  g.resize(h);\n  for(int i=0;i<h;i++){\n    cin >> g[i];\n    for(int j=0;j<w;j++){\n      if(isupper(g[i][j])){\n\ty = i; x = j;\n\tfor(int k=0;k<4;k++){\n\t  if(dir[k] == g[i][j])d = k;\n\t}\n      }else if(g[i][j] == 'o')cnt++;\n    }\n  }\n  ans = \"\";\n  dfs(y,x,d,cnt);\n  cout << ans << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y, dir;\n\tvs field;\n\tstring command;\n\tstate(int x, int y, int dir, vs field, string command) : x(x), y(y), dir(dir), field(field), command(command) {};\n};\n\nint getDir(char c) {\n\tswitch(c) {\n\tcase 'U':\n\t\treturn 3;\n\tcase 'D':\n\t\treturn 1;\n\tcase 'L':\n\t\treturn 0;\n\tcase 'R':\n\t\treturn 2;\n\t}\n}\n\nchar getDirChar(int dir) {\n\tswitch(dir) {\n\tcase 0:\n\t\treturn 'R';\n\tcase 1:\n\t\treturn 'D';\n\tcase 2:\n\t\treturn 'L';\n\tcase 3:\n\t\treturn 'U';\n\t}\n}\n\nbool isProperXY(int x, int y, int H, int W) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool isEmptyField(vs field) {\n\tREP(i, field.size()) {\n\t\tREP(j, field[i].size()) {\n\t\t\tif(field[i][j] != '.') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvs field(H);\n\n\tint x, y, dir;\n\tREP(i, H) {\n\t\tcin >> field[i];\n\t\tREP(j, field[i].size()) {\n\t\t\tif(field[i][j] != '.' && field[i][j] != 'o') {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\tdir = getDir(field[i][j]);\n\t\t\t\tfield[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tstring ans;\n\tstack<state> S;\n\tS.push(state(x, y, dir, field, \"\"));\n\twhile(!S.empty()) {\n\t\tstate st = S.top();\n\t\tS.pop();\n\n\t\tif(isEmptyField(st.field)) {\n\t\t\tans = st.command;\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(d, -1, 1) {\n\t\t\tint nx = st.x, ny = st.y, ndir = (st.dir+d+4)%4;\n\t\t\tbool update = true;\n\t\t\twhile(st.field[ny][nx] != 'o') {\n\t\t\t\tnx += dx[ndir], ny += dy[ndir];\n\t\t\t\tif(!isProperXY(nx, ny, H, W)) {\n\t\t\t\t\tupdate = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(update) {\n\t\t\t\tvs nfield = st.field;\n\t\t\t\tnfield[ny][nx] = '.';\n\t\t\t\tstring ncommand = st.command;\n\t\t\t\tncommand.push_back(getDirChar(ndir));\n\t\t\t\tS.push(state(nx, ny, ndir, nfield, ncommand));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2012-12-07T15:16:10 */\n#define DEBUG_ON_\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#define dump(x)\n#define dumpf()\n#define dumpv(x)\n#define where()\n#define show_bits(b, s)\n#endif\n\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { IFC(s[i] == ' '); if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n/*}}}*/\n\nint dx[] = {1, 0, -1, 0}; int dy[] = {0, -1, 0, 1};\nenum dir {\n\tRIGHT, UP, LEFT, DOWN\n};\n\nstruct frog {\n\tint x, y;\n\tdir d;\n};\n\n#define VC vector<char>\n#define VVC vector< vector<char> >\n\nint H, W;\nVVC field;\nfrog frg;\nint n_leaves = 1;\nVC path;\n\nvoid clear ()\n{\n\tREP (i, path.size()) {\n\t\tcout << path[i];\n\t}\n\tcout << endl;\n\texit(0);\n}\n\nPII find_leaf(dir d)\n{\n\tint j = frg.x, i = frg.y;\n\ti += dy[d], j += dx[d];\n\twhile (RANGE(0, i, H-1) && RANGE(0, j, W-1)) {\n\t\tdprt(\"(dir %d)search: [%d][%d] -> %c\\n\", d, i, j, field[i][j]);\n\t\tif (field[i][j] == 'o') {\n\t\t\treturn MP(i, j);\n\t\t}\n\t\ti += dy[d], j += dx[d];\n\t}\n\treturn MP(-1, -1);\n}\n\nvoid jump ()\n{\n\t--n_leaves;\n\tif (n_leaves == 0) {\n\t\tcerr << \"CLEAR!\" << endl;\n\t\tclear();\n\t}\n\tint savex = frg.x, savey = frg.y;\n\tdir saved = frg.d;\n\tif (frg.d != DOWN) {\n\t\tPII p = find_leaf(UP);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = UP;\n\t\t\tpath.PB('U');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO UP\" << endl;\n\t\t\tjump();\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for up\" << endl;\n\t\t}\n\t}\n\tif (frg.d != UP) {\n\t\tPII p = find_leaf(DOWN);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = DOWN;\n\t\t\tpath.PB('D');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO DOWN\" << endl;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tjump();\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for down\" << endl;\n\t\t}\n\t}\n\tif (frg.d != LEFT) {\n\t\tPII p = find_leaf(RIGHT);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = RIGHT;\n\t\t\tpath.PB('R');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO RIGHT\" << endl;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tjump();\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for right\" << endl;\n\t\t}\n\t}\n\tif (frg.d != RIGHT) {\n\t\tPII p = find_leaf(LEFT);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = LEFT;\n\t\t\tpath.PB('L');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO LEFT\" << endl;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tjump();\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for left\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tcin >> H >> W;\n\tfield = VVC(H, VC(W));\n\tREP (i, H) {\n\t\tREP (j, W) {\n\t\t\tcin >> field[i][j];\n\t\t\tswitch (field[i][j]) {/*{{{*/\n\t\t\t\tcase 'U':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = UP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = DOWN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = RIGHT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = LEFT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\t++n_leaves;\n\t\t\t\t\tbreak;\n\t\t\t}/*}}}*/\n\t\t}\n\t}\n\tdprt(\"Start: [%d][%d]\\n\", frg.y, frg.x);\n\tjump();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10\n#define M 30\nusing namespace std;\nint h,w,sy,sx,sd,ocnt;\nstring s[N],ans;\nchar c[M];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nchar itoc[4]={'U','R','D','L'};\n\nvoid dfs(int y,int x,int d,int cnt){\n  if(cnt==ocnt){\n    for(int i=0;i<cnt;i++)ans+=c[i];\n    return;\n  }\n  for(int i=-1;i<=1;i++){\n    int nd=(d+i+4)%4;\n    int ny=y+dy[nd],nx=x+dx[nd];\n    while(1){\n      if(ny<0||nx<0||h<=ny||w<=nx)break;\n      if(s[ny][nx]=='o'){\n\ts[ny][nx]='.';\n\tc[cnt]=itoc[nd];\n\tdfs(ny,nx,nd,cnt+1);\n\ts[ny][nx]='o';\n\tbreak;\n      }\n      ny+=dy[nd];\n      nx+=dx[nd];\n    }\n  }\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='o')ocnt++;\n      else if(s[i][j]!='.'){\n\tsy=i,sx=j;\n\tif(s[i][j]=='U')sd=0;\n\tif(s[i][j]=='R')sd=1;\n\tif(s[i][j]=='D')sd=2;\n\tif(s[i][j]=='L')sd=3;\n      }\n    }\n  }\n\n  dfs(sy,sx,sd,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};\nint H, W;\nmap<char, int> dir;\nmap<int, char> dir2;\nstring ans;\nbool range_out(int x, int y){\n    return x < 0 || y < 0 || W <= x || H <= y;\n}\nbool dfs(const vector<string>& pond, int cx, int cy, int cd, int leaves, string score){\n    if(leaves == 0){\n        ans = score;\n        return true;\n    }\n    rep(i, 4){\n        if(i == 3 - cd) continue;\n        int nx = cx, ny = cy;\n        bool end = false;\n        while(true){\n            nx += dx[i]; ny += dy[i];\n            if(range_out(nx, ny)){\n                end = true;\n                break;\n            }\n            if(pond[ny][nx] == 'o') break;\n        }\n        if(end) continue;\n        vector<string> temp = pond;\n        temp[ny][nx] = '.';\n        string st = score + dir2[i];\n        if(dfs(temp, nx, ny, i, leaves - 1, st)) return true;\n    }\n    return false;;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> H >> W;\n    vector<string> pond(H);\n    rep(i, H) cin >> pond[i];\n    int sx, sy, sd;\n    int leafnum = 0;\n    dir['U'] = 2; dir['D'] = 1; dir['L'] = 3; dir['R'] = 0;\n    for(const auto& k : dir) dir2[k.second] = k.first;\n    rep(i, H) rep(j, W){\n        if(pond[i][j] == 'o')\n          leafnum++;\n        if('A' <= pond[i][j] && pond[i][j] <= 'Z'){\n            sx = j; sy = i;\n            sd = dir[pond[j][i]];\n            pond[j][i] = '.';\n        }\n    }\n    string hoge = \"\";\n    dfs(pond, sx, sy, sd, leafnum, hoge);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\n// U,R,D,L\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};\nstring Q;\nbool rec(pii n,int d,int cnt,vector<vector<char>>& masu){\n    if(cnt == 0){\n        return true;\n    }\n    for(int k = -1; k <= 1; k++){\n        int nk = (d+k+4)%4;\n        \n        int nx,ny; tie(nx,ny) = n;\n        bool find = false;\n        while(true){\n            nx += dx[nk];\n            ny += dy[nk];\n            if(masu[nx][ny] == '#') break;\n            if(masu[nx][ny] == 'o'){\n                find = true;\n                break;\n            }\n        }\n        if(find){\n            masu[nx][ny] = '.';\n            Q.push_back(nk==0?'U':nk==1?'R':nk==2?'D':'L');\n            if(rec(pii(nx,ny),nk,cnt-1,masu)) return true;\n            Q.pop_back();\n            masu[nx][ny] = 'o';\n        }\n    }\n    return false;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll H,W; cin >> H >> W;\n    vector<vector<char>> masu(H+2,vector<char>(W+2,'#'));\n    pii S;\n    int dir = 0;\n    int cnt = 0;\n    for(int i = 1; i <= H;i++) for(int j = 1; j <= W;j++){\n        cin >> masu[i][j];\n        if(masu[i][j] == 'U'){\n            S = {i,j};\n            dir = 0;\n            masu[i][j] = '.';\n        }\n        if(masu[i][j] == 'R'){\n            S = {i,j};\n            dir = 1;\n            masu[i][j] = '.';\n        }\n        if(masu[i][j] == 'D'){\n            S = {i,j};\n            dir = 2;\n            masu[i][j] = '.';\n        }\n        if(masu[i][j] == 'L'){\n            S = {i,j};\n            dir = 3;\n            masu[i][j] = '.';\n        }\n        cnt += masu[i][j] == 'o';\n    }\n    rec(S,dir,cnt,masu);\n    cout << Q << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint h, w;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\nconst char C[4] = {'R', 'U', 'L', 'D'};\n\nstruct Data{\n\tvector<vector<char>> c;\n\tint leves;\n\tint y, x, d;\n\tstring s;\n\tData(vector<vector<char>>& c, int leves, int y, int x, int d, string s) : c(c), leves(leves), y(y), x(x), d(d), s(s) {}\n};\n\nstring bfs(Data& start){\n\tqueue<Data> q;\n\tq.emplace(start);\n\n\twhile(not q.empty()){\n\t\tData p = q.front(); q.pop();\n\t\t//cout << p.y << ' ' << p.x <<' ' << p.d << endl;\n\t\t//for(auto i : p.c){ for(auto j : i){ cout << j << ' '; } cout << endl; } cout << endl;\n\n\n\t\tif(p.leves == 1) return p.s;\n\t\tif(p.s.size() >= 30) continue;\n\n\t\trep(dir,4){\n\t\t\tif((p.d + 2) % 4 == dir) continue;\n\t\t\tint ny = p.y + dy[dir];\n\t\t\tint nx = p.x + dx[dir];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\n\t\t\tbool f = true;\n\t\t\twhile(p.c[ny][nx] == '.'){\n\t\t\t\tny += dy[dir];\n\t\t\t\tnx += dx[dir];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(not f) continue;\n\n\t\t\tp.c[p.y][p.x] = '.';\n\t\t\tq.emplace(p.c, p.leves - 1, ny, nx, dir, p.s + C[dir]);\n\t\t\tp.c[p.y][p.x] = 'o';\n\t\t}\n\t}\n\tassert(false);\n\treturn \"null\";\n}\n\nint main(){\n\tcin >> h >> w;\n\n\tvector<vector<char>> c(h, vector<char>(w));\n\tint y, x, leves = 0;\n\tchar dir;\n\trep(i,h) rep(j,w){\n\t\tcin >> c[i][j];\n\t\tif(isupper(c[i][j])){\n\t\t\ty = i;\n\t\t\tx = j;\n\t\t\tdir = c[i][j];\n\t\t\tc[i][j] = 'o';\n\t\t}\n\t\tif(c[i][j] == 'o') leves++;\n\t}\n\n\trep(i,4) if(C[i] == dir){\n\t\tData data(c, leves, y, x, i, \"\");\n\t\tcout << bfs(data) << endl;\n\t\treturn 0;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nstring u = \"RDLU\";\n\nint h,w;\nint k;\nvector<string> s;\nbool visited[20][20];\nchar ans[100];\n\nbool dfs(int x,int y,int c,int d){\n    if(c==k) return true;\n    for (int i = 0; i < 4; i++) {\n        if(d == (i + 2)%4) continue;\n        int nx = x, ny = y;\n        bool f = false;\n        while(0 <= nx && nx < w && 0 <= ny && ny < h){\n            if(!visited[ny][nx]&&s[ny][nx] == 'o'){\n                f = true;\n                break;\n            }\n            ny += dy[i];\n            nx += dx[i];\n        }\n        if(!f) continue;\n        visited[ny][nx] = true;\n        if(dfs(nx,ny,c+1,i)){\n            ans[c] = u[i];\n            return true;\n        }\n        visited[ny][nx] = false;\n    }\n    return false;\n}\n\n\nint main(){\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        string t;cin >> t;\n        s.pb(t);\n    }\n    int d = 0;\n    int sx,sy;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if(s[i][j] == '.') continue;\n            if(s[i][j] == 'o') k++;\n            else{\n                if(s[i][j] == 'R') d = 0;\n                else if(s[i][j] == 'L') d = 2;\n                else if(s[i][j] == 'D') d = 1;\n                else if(s[i][j] == 'U') d = 3;\n                sx = j,sy = i;\n            }\n        }\n    }\n    dfs(sx,sy,0,d);\n    for (int i = 0; i < k; i++) {\n        cout << ans[i];\n    }\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[10][11];\n\nint num;\nchar ans[31];\nbool dfs(int i,int x,int y,int dir){\n\tif(i==num) return true;\n\n\tB[y][x]='.';\n\trep(k,4) if(k!=((dir+2)&3)) {\n\t\tbool ok=false;\n\t\tint xx=x,yy=y;\n\t\twhile(0<=xx && xx<w && 0<=yy && yy<h){\n\t\t\tif(B[yy][xx]=='o'){ ok=true; break; }\n\t\t\txx+=dx[k];\n\t\t\tyy+=dy[k];\n\t\t}\n\t\tif(ok){\n\t\t\tans[i]=\"RULD\"[k];\n\t\t\tif(dfs(i+1,xx,yy,k)) return true;\n\t\t}\n\t}\n\tB[y][x]='o';\n\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&h,&w);\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tint sx,sy;\n\trep(i,h) rep(j,w) {\n\t\tif(B[i][j]=='o') num++;\n\t\tif(B[i][j]!='o' && B[i][j]!='.') sx=j, sy=i;\n\t}\n\n\tint f[128];\n\tf['R']=0;\n\tf['U']=1;\n\tf['L']=2;\n\tf['D']=3;\n\tdfs(0,sx,sy,f[B[sy][sx]]);\n\n\tputs(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint h,w;\nint si,sj,sd;\nchar s[22][22];\nint sum=0;\n\nint di[]={0,-1,0,1};\nint dj[]={1,0,-1,0};\n\nstring ds[]={\"R\",\"U\",\"L\",\"D\"};\n\nbool valid(int i,int j){ return i>=0&&i<h&&j>=0&&j<w; }\n\nstring dfs(int i,int j,int dir,int cnt){\n  if(cnt==sum)return \"\";\n  repl(d,-1,2){\n    int nd=(dir+d+4)%4;\n    int ni=i,nj=j;\n    while(valid(ni,nj)&&s[ni][nj]!='o'){\n      ni+=di[nd]; nj+=dj[nd];\n    }\n    if(valid(ni,nj)){\n      s[ni][nj]='.';\n      string nxt=dfs(ni,nj,nd,cnt+1);\n      s[ni][nj]='o';\n      if(nxt!=\"X\")return ds[nd]+nxt;\n    }\n  }\n  return \"X\";\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>h>>w;\n  rep(i,h)cin>>s[i];\n  rep(i,h)rep(j,w){\n    if(s[i][j]=='R'){\n      si=i; sj=j;\n      sd=0;\n    }\n    if(s[i][j]=='U'){\n      si=i; sj=j;\n      sd=1;\n    }\n    if(s[i][j]=='L'){\n      si=i; sj=j;\n      sd=2;\n    }\n    if(s[i][j]=='D'){\n      si=i; sj=j;\n      sd=3;\n    }\n    if(s[i][j]=='o')sum++;\n  }\n  //dbg(si); dbg(sj); dbg(sd);\n  s[si][sj]='.';\n  cout<<dfs(si,sj,sd,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[12][12];\nchar ret[100];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar dir[10]=\"DRUL\";\nint rem;\nint H,W;\nint dfs(int a,int b,int c,int d){\n\tif(c==rem)return 1;\n\tchar ch=str[a][b];\n\tstr[a][b]='.';\n\tfor(int i=0;i<4;i++){\n\t\tif((i^2)==d)continue;\n\t\tint row=a;int col=b;\n\t\twhile(1){\n\t\t\trow+=dx[i];\n\t\t\tcol+=dy[i];\n\t\t\tif(row<0||col<0||row>=H||col>=W)break;\n\t\t\tif(str[row][col]=='o'){\n\t\t\t\tret[c]=dir[i];\n\t\t\t\tint tmp=dfs(row,col,c+1,i);\n\t\t\t\tif(tmp){\n\t\t\t\t\tstr[a][b]=ch;return 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tstr[a][b]=ch;\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tH=a;W=b;\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sx,sy;\n\tint dir;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='o')rem++;\n\t\telse if(str[i][j]!='.'){\n\t\t\tsx=i;\n\t\t\tsy=j;\n\t\t\tif(str[i][j]=='U')dir=2;\n\t\t\tif(str[i][j]=='D')dir=0;\n\t\t\tif(str[i][j]=='L')dir=3;\n\t\t\tif(str[i][j]=='R')dir=1;\n\t\t}\n\t}\n\tdfs(sx,sy,0,dir);\n\tprintf(\"%s\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,h,sum,dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nstring s[11],t;\nmap<int,char>m;\nvoid dfs(int y,int x,int d,char p){\n  if(d==sum){\n    cout<<t<<endl;\n    exit(0);\n  }\n  else{\n    char a=p;\n    s[y][x]='.';\n    r(i,4){\n      int yy=y,xx=x;\n      if(a=='U'&&i==2||a=='D'&&i==0||a=='R'&&i==3||a=='L'&&i==1)continue;\n      r(j,50){\n        yy+=dy[i],xx+=dx[i];\n        if(yy>=h||xx>=w||xx<0||yy<0)break;\n        if(s[yy][xx]=='o'){\n          t+=m[i];\n          dfs(yy,xx,d+1,m[i]);\n          t.erase(t.size()-1);\n        }\n      }\n    }\n    s[y][x]='o';\n  }\n}\nint main(){\n  m[0]='U';m[1]='R';m[2]='D';m[3]='L';\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='o')sum++;\n  r(i,h)r(j,w)if(s[i][j]!='.'&&s[i][j]!='o')dfs(i,j,0,s[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,cnt,dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nstring ans,dir = \"URDL\";\nvector<string> g;\n\nbool dfs(int y,int x,int d,int rem){\n  if(rem==cnt)return true;\n  char tmp = g[y][x];\n  g[y][x] = '.';\n\n  for(int i=3;i<=5;i++){\n    int nd = (d+i)%4, ny = y + dy[nd], nx = x + dx[nd];\n    while(ny>=0 && nx>=0 && ny<h && nx<w){\n      if(g[ny][nx] == 'o'){\n\tans[rem] = dir[nd];\n\tif(dfs(ny,nx,nd,rem+1))return true;\n\tbreak;\n      }\n      ny += dy[nd]; nx += dx[nd];\n    }\n  }\n\n  g[y][x] = tmp;\n  return false;\n}\n\nint main(){\n  int y,x,d;\n  cin >> h >> w;\n  g.resize(h);\n  for(int i=0;i<h;i++){\n    cin >> g[i];\n    for(int j=0;j<w;j++){\n      if(isupper(g[i][j])){\n\ty = i; x = j;\n\tfor(int k=0;k<4;k++){\n\t  if(dir[k] == g[i][j])d = k;\n\t}\n      }else if(g[i][j] == 'o')cnt++;\n    }\n  }\n  ans.resize(cnt);\n  dfs(y,x,d,0);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 10;\nconst int MAX_W = 10;\nconst int MAX_N = 30;\n\nconst char dcs[] = {'R', 'U', 'L', 'D'};\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\ntypedef vector<int> vi;\n\n/* global variables */\n\nint h, w, n;\nint flds[MAX_H][MAX_W];\nint jps[MAX_N];\nvi nbrs[MAX_N][4];\nbool used[MAX_N];\n\n/* subroutines */\n\nbool rec(int k, int id, int di0) {\n  if (k == n - 1) return true;\n\n  int dis[] = { di0, (di0 + 3) % 4, (di0 + 1) % 4 };\n\n  for (int i = 0; i < 3; i++) {\n    vi& nbr = nbrs[id][dis[i]];\n\n    for (vi::iterator vit = nbr.begin(); vit != nbr.end(); vit++) {\n      int v = *vit;\n      if (! used[v]) {\n\tused[v] = true;\n\tjps[k] = dis[i];\n\tif (rec(k + 1, v, dis[i])) return true;\n\tused[v] = false;\n\tbreak;\n      }\n    }\n  }\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  cin >> h >> w;\n\n  n = 0;\n  int st, di;\n\n  for (int y = 0; y < h; y++) {\n    string line;\n    cin >> line;\n\n    for (int x = 0; x < w; x++)\n      switch (line[x]) {\n      case '.': flds[y][x] = -1; break;\n      case 'o': flds[y][x] = n++; break;\n      case 'R': flds[y][x] = st = n++; di = 0; break;\n      case 'U': flds[y][x] = st = n++; di = 1; break;\n      case 'L': flds[y][x] = st = n++; di = 2; break;\n      case 'D': flds[y][x] = st = n++; di = 3; break;\n      }\n  }\n  \n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++) {\n      int id = flds[y][x];\n      if (id >= 0)\n\tfor (int di = 0; di < 4; di++) {\n\t  int x0 = x + dxs[di], y0 = y + dys[di];\n\t  while (x0 >= 0 && x0 < w && y0 >= 0 && y0 < h) {\n\t    if (flds[y0][x0] >= 0)\n\t      nbrs[id][di].push_back(flds[y0][x0]);\n\t    x0 += dxs[di];\n\t    y0 += dys[di];\n\t  }\n\t}\n    }\n\n  memset(used, false, sizeof(used));\n  used[st] = true;\n  rec(0, st, di);\n\n  for (int i = 0; i < n - 1; i++) cout << dcs[jps[i]];\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nstring latte=\"URDL\";\n\nint H,W;\nchar fld[11][11];\n\nstring ans;\nbool used[11][11];\nvoid dfs(int y,int x,int d,int c,string s){\n    c--;\n    used[y][x]=true;\n    if(c==0){\n        ans=s;\n        return;\n    }\n\n    for(int malta=-1;malta<=1;malta++){\n        int nd=(d+malta+4)%4;\n        int ny=y,nx=x;\n        while(true){\n            ny+=dy[nd],nx+=dx[nd];\n            if(ny<0||ny>=H||nx<0||nx>=W)break;\n            if(fld[ny][nx]=='.'||used[ny][nx])continue;\n            used[ny][nx]=true;\n            dfs(ny,nx,nd,c,s+string(1,latte[nd]));\n            used[ny][nx]=false;\n            break;\n        }\n    }\n}\n\nsigned main(){\n    cin>>H>>W;\n    rep(i,H)cin>>fld[i];\n\n    int sy,sx,sd;\n    int cnt=0;\n    rep(i,H)rep(j,W){\n        int tmp=find(all(latte),fld[i][j])-latte.begin();\n        if(tmp<4){\n            sy=i;sx=j;sd=tmp;\n        }\n        if(fld[i][j]!='.')cnt++;\n    }\n\n    dfs(sy,sx,sd,cnt,\"\");\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n#define N 12\nint dx[]={1,0,0,-1};\nint dy[]={0,-1,1,0};\nchar str[]=\"DLRU\";\nint num;\nchar ch[N*N];\nint map[N][N];\nint h,w;\nbool dfs(int dep,int tx,int ty,int td){\n    if (dep==num){\n        return 1;\n    }\n    for (int i=0;i<4;i++){\n        if (td+i==3) continue;\n        for (int j=1;;j++){\n            int nx=dx[i]*j+tx;\n            int ny=dy[i]*j+ty;\n            if (nx<0||ny<0||nx>h||ny>w) break;\n            if (map[nx][ny]==1){\n                map[nx][ny]=0;\n                ch[dep]=str[i];\n                if (dfs(dep+1,nx,ny,i)==1) return 1;\n                map[nx][ny]=1;\n                break;\n            }\n        }\n    }\n    return 0;\n}\nint main(){\n    while (scanf(\"%d%d\",&h,&w)==2){\n        num=0;\n        int sx,sy,sd;\n        for (int i=0;i<h;i++){\n            scanf(\"%s\",ch);\n            for (int j=0;j<w;j++){\n                if (ch[j]=='o') {map[i][j]=1;num++;}\n                else map[i][j]=0;\n                if (ch[j]=='U') {sx=i,sy=j,sd=3;};\n                if (ch[j]=='D') {sx=i,sy=j,sd=0;};\n                if (ch[j]=='L') {sx=i,sy=j,sd=1;};\n                if (ch[j]=='R') {sx=i,sy=j,sd=2;};\n            }\n        }\n        //printf(\"%d\\n\",num);\n        int flag=0;\n        dfs(0,sx,sy,sd);\n        for (int i=0;i<num;i++)\n            printf(\"%c\",ch[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#pragma warning(disable: 4996)\nint H, W, r, cnt,  dir[4] = { 1, 0, -1, 0 }; char c[12][12], f[31], g[] = \"RDLU\";\nvoid solve(int x, int y, int d) {\n\tif (d == r) {\n\t\tif (cnt++ == 0) {\n\t\t\tfor (int i = 0; i < r; i++) printf(\"%c\", f[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x, ty = y;\n\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\tif (c[ty][tx] == 'o') {\n\t\t\t\tc[ty][tx] = '.'; f[d] = g[i];\n\t\t\t\tsolve(tx, ty, d + 1);\n\t\t\t\tc[ty][tx] = 'o'; f[d] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += dir[i];\n\t\t\tty += dir[i ^ 1];\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) scanf(\"%s\", c[i]);\n\tint sy, sx;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (c[i][j] != '.' && c[i][j] != 'o') {\n\t\t\t\tsx = j, sy = i;\n\t\t\t\tc[i][j] = '.';\n\t\t\t}\n\t\t\tif (c[i][j] == 'o') r++;\n\t\t}\n\t}\n\tsolve(sx, sy, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,sx,sy,m;\nint d[256],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nchar c[10][10],sc,nc[4]={'U','R','D','L'};\nstring ans;\n\nbool dfs(int x,int y,char r,int cnt){\n  if(cnt==m){return 1;}\n  bool res=0;\n  c[y][x]='.';\n  for(int i=0;i<3;i++){\n    int p=(d[r]+i)%4,nx=x,ny=y;\n    while(0<=nx&&nx<w&&0<=ny&&ny<h&&c[ny][nx]!='o')\n      nx+=dx[p],ny+=dy[p];\n    if(0<=nx&&nx<w&&0<=ny&&ny<h)\n      if(dfs(nx,ny,nc[p],cnt+1))ans=nc[p]+ans,res=1;\n  }\n  c[y][x]='o';\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  d['U']=3,d['R']=0,d['D']=1,d['L']=2;\n  for(int i=h-1;i>=0;i--)\n    for(int j=0;j<w;j++){\n      cin>>c[i][j];\n      if(c[i][j]=='o')m++;\n      else if(c[i][j]!='.')sx=j,sy=i,sc=c[i][j];\n    }\n  dfs(sx,sy,sc,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2012-12-07T15:16:10 */\n#define DEBUG_ON_\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#define dump(x)\n#define dumpf()\n#define dumpv(x)\n#define where()\n#define show_bits(b, s)\n#endif\n\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { IFC(s[i] == ' '); if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n/*}}}*/\n\nint dx[] = {1, 0, -1, 0}; int dy[] = {0, -1, 0, 1};\nenum dir {\n\tRIGHT, UP, LEFT, DOWN\n};\n\nstruct frog {\n\tint x, y;\n\tdir d;\n};\n\n#define VC vector<char>\n#define VVC vector< vector<char> >\n\nint H, W;\nVVC field;\nfrog frg;\nint n_leaves = 1;\nVC path;\n\nvoid clear ()\n{\n\tREP (i, path.size()) {\n\t\tcout << path[i];\n\t}\n\tcout << endl;\n\texit(0);\n}\n\nPII find_leaf(dir d)\n{\n\tint j = frg.x, i = frg.y;\n\ti += dy[d], j += dx[d];\n\twhile (RANGE(0, i, H-1) && RANGE(0, j, W-1)) {\n\t\tdprt(\"(dir %d)search: [%d][%d] -> %c\\n\", d, i, j, field[i][j]);\n\t\tif (field[i][j] == 'o') {\n\t\t\treturn MP(i, j);\n\t\t}\n\t\ti += dy[d], j += dx[d];\n\t}\n\treturn MP(-1, -1);\n}\n\nvoid jump ()\n{\n\t--n_leaves;\n\tif (n_leaves == 0) {\n\t\tcerr << \"CLEAR!\" << endl;\n\t\tclear();\n\t}\n\tint savex = frg.x, savey = frg.y;\n\tdir saved = frg.d;\n\tif (frg.d != DOWN) {\n\t\tPII p = find_leaf(UP);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = UP;\n\t\t\tpath.PB('U');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO UP\" << endl;\n\t\t\tjump();\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for up\" << endl;\n\t\t}\n\t}\n\tif (frg.d != UP) {\n\t\tPII p = find_leaf(DOWN);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = DOWN;\n\t\t\tpath.PB('D');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO DOWN\" << endl;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tjump();\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for down\" << endl;\n\t\t}\n\t}\n\tif (frg.d != LEFT) {\n\t\tPII p = find_leaf(RIGHT);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = RIGHT;\n\t\t\tpath.PB('R');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO RIGHT\" << endl;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tjump();\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for right\" << endl;\n\t\t}\n\t}\n\tif (frg.d != RIGHT) {\n\t\tPII p = find_leaf(LEFT);\n\t\tif (p.F >= 0) {\n\t\t\tfrg.y = p.F, frg.x = p.S;\n\t\t\tfrg.d = LEFT;\n\t\t\tpath.PB('L');\n\t\t\tfield[p.F][p.S] = '.';\n\t\t\tcerr << \"GO LEFT\" << endl;\n\t\t\tfield[p.F][p.S] = 'o';\n\t\t\tjump();\n\t\t\tpath.pop_back();\n\t\t\tfrg.x = savex, frg.y = savey, frg.d = saved;\n\t\t}\n\t\telse {\n\t\t\tcerr << \"No leaf for left\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tcin >> H >> W;\n\tfield = VVC(H, VC(W));\n\tREP (i, H) {\n\t\tREP (j, W) {\n\t\t\tcin >> field[i][j];\n\t\t\tswitch (field[i][j]) {/*{{{*/\n\t\t\t\tcase 'U':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = UP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = DOWN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = RIGHT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tfrg.y = i, frg.x = j;\n\t\t\t\t\tfrg.d = LEFT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\t++n_leaves;\n\t\t\t\t\tbreak;\n\t\t\t}/*}}}*/\n\t\t}\n\t}\n\tdprt(\"Start: [%d][%d]\\n\", frg.y, frg.x);\n\tjump();\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\n\nint h,w;\nbool f[10][10];\nvector<int> ans;\n\nvoid dfs(int x, int y, int d, set<pair<int,int> > s, vector<int> v){\n\ts.insert(pair<int,int>(y,x));\n\tbool f2 = false;\n\tfor(int i=0;i<4;i++){\n\t\tif(i == (d+2)%4) continue;\n\t\tint ay = y;\n\t\tint ax = x;\n\t\twhile(1){\n\t\t\tay += dy[i];\n\t\t\tax += dx[i];\n\t\t\tif(ay < 0 || ay >= h || ax < 0 || ax >= w) break;\n\t\t\tif(!f[ay][ax]) continue;\n\t\t\tif(s.find(pair<int,int>(ay,ax)) == s.end()){\n\t\t\t\tvector<int> v2 = v;\n\t\t\t\tv2.push_back(i);\n\t\t\t\tf2 = true;\n\t\t\t\tdfs(ax,ay,i,s,v2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!f2 && ans.size() < v.size()) ans = v; \n}\n\nint main(){\n\twhile(cin >> h >> w){\n\t\tint x,y,d;\n\t\tans.clear();\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tf[i][j] = true;\n\t\t\t\tif(c == '.') f[i][j] = false;\n\t\t\t\telse if(c == 'U'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\td = 0;\n\t\t\t\t}\n\t\t\t\telse if(c == 'R'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\td = 1;\n\t\t\t\t}\n\t\t\t\telse if(c == 'D'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\td = 2;\n\t\t\t\t}\n\t\t\t\telse if(c == 'L'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\td = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<pair<int,int> > s;\n\t\tvector<int> v;\n\t\tdfs(x,y,d,s,v);\n\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tif(ans[i] == 0) cout << 'U';\n\t\t\telse if(ans[i] == 1) cout << 'R';\n\t\t\telse if(ans[i] == 2) cout << 'D';\n\t\t\telse if(ans[i] == 3) cout << 'L';\n\t\t}\n\t\tcout << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool dfs(vs& grid,int i,int j,int d,int rest,string& res)\n{\n\tif(rest==1) return true;\n\tgrid[i][j]='.';\n\t\n\tint h=grid.size(),w=grid[0].size();\n\trep(k,4) if(k!=(d^1)){\n\t\tconst int di[]={-1,1,0,0},dj[]={0,0,-1,1};\n\t\tfor(int ni=i,nj=j;0<=ni && ni<h && 0<=nj && nj<w;ni+=di[k],nj+=dj[k])\n\t\t\tif(grid[ni][nj]=='o'){\n\t\t\t\tres.push_back(\"UDLR\"[k]);\n\t\t\t\tif(dfs(grid,ni,nj,k,rest-1,res))\n\t\t\t\t\treturn true;\n\t\t\t\tres.pop_back();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\t\n\tgrid[i][j]='o';\n\treturn false;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tint cnt=0;\n\t\trep(i,h) rep(j,w) cnt+=grid[i][j]!='.';\n\t\trep(i,h) rep(j,w) if(isupper(grid[i][j])){\n\t\t\tint d=string(\"UDLR\").find(grid[i][j]);\n\t\t\tgrid[i][j]='o';\n\t\t\tstring res;\n\t\t\tassert(dfs(grid,i,j,d,cnt,res));\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nvector<char> D = {'D', 'R', 'U',  'L'};\nvoid dfs(vector<vector<char>> &c, int y, int x, int d, int cnt, string &S, string &ans){\n  if (cnt == 1){\n    ans = S;\n  }\n  for (int i = 0; i < 4; i++){\n    if (abs(d - i) != 2){\n      int y2 = y;\n      int x2 = x;\n      while (1){\n        y2 += dy[i];\n        x2 += dx[i];\n        if (c[y2][x2] != '.'){\n          break;\n        }\n      }\n      if (c[y2][x2] == 'o'){\n        c[y2][x2] = '.';\n        S.push_back(D[i]);\n        dfs(c, y2, x2, i, cnt - 1, S, ans);\n        S.pop_back();\n        c[y2][x2] = 'o';\n      }\n    }\n  }\n}\nint main(){\n  int H, W;\n  cin >> H >> W;\n  vector<vector<char>> c(H + 2, vector<char>(W + 2, '#'));\n  for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      cin >> c[i][j];\n    }\n  }\n  int cnt = 0;\n  for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      if (c[i][j] != '.'){\n        cnt++;\n      }\n    }\n  }\n  int y, x, d;\n  for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      if (c[i][j] != '.' && c[i][j] != 'o'){\n        y = i;\n        x = j;\n        if (c[i][j] == 'D'){\n          d = 0;\n        }\n        if (c[i][j] == 'R'){\n          d = 1;\n        }\n        if (c[i][j] == 'U'){\n          d = 2;\n        }\n        if (c[i][j] == 'L'){\n          d = 3;\n        }\n      }\n    }\n  }\n  c[y][x] = '.';\n  string S, ans;\n  dfs(c, y, x, d, cnt, S, ans);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define int long long\n#define lint long long\n#define pii pair<int, int>\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n#define SZ(v) ((int)v.size())\n#define ZERO(a) memset(a, 0, sizeof(a))\n#define MINUS(a) memset(a, 0xff, sizeof(a))\n#define MINF(a) memset(a, 0x3f, sizeof(a))\n#define POW(n) (1LL << (n))\n#define POPCNT(n) (__builtin_popcount(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e, v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-10;\n\nint H, W;\nstring s[11];\n// U = 0, D = 1, L = 2, R = 3\nvector<vector<int>> dy = {{0, -1, 0}, {0, 1, 0}, {-1, 0, 1}, {-1, 0, 1}};\nvector<vector<int>> dx = {{-1, 0, 1}, {-1, 0, 1}, {0, -1, 0}, {0, 1, 0}};\nvector<vector<int>> ndir = {{2, 0, 3}, {2, 1, 3}, {0, 2, 1}, {0, 3, 1}};\nconst string ord = \"UDLR\";\nbool used[11][11];\nint cnt = 0;\n\nvoid dfs(int y, int x, int dir, string& t) {\n    if (SZ(t) == cnt) {\n        cout << t << endl;\n        exit(0);\n    }\n    REP(i, 3) {\n        int ny = y, nx = x;\n        while (IN(ny, 0, H - 1) && IN(nx, 0, W - 1) && (s[ny][nx] != 'o' || (s[ny][nx] == 'o' && used[ny][nx]))) ny += dy[dir][i], nx += dx[dir][i];\n        if (!IN(ny, 0, H - 1) || !IN(nx, 0, W - 1)) continue;\n        used[ny][nx] = true;\n        t.push_back(ord[ndir[dir][i]]);\n        dfs(ny, nx, ndir[dir][i], t);\n        t.pop_back();\n        used[ny][nx] = false;\n    }\n}\n\nvoid _main() {\n    cin >> H >> W;\n    int sy, sx, dir;\n    REP(i, H) {\n        cin >> s[i];\n        REP(j, W) {\n            if (s[i][j] == 'o') ++cnt;\n            if (s[i][j] != '.' && s[i][j] != 'o') {\n                sy = i;\n                sx = j;\n                dir = ord.find(s[i][j]);\n                s[i][j] = 'o';\n                used[i][j] = true;\n            }\n        }\n    }\n    string t;\n    dfs(sy, sx, dir, t);\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        if (strchr(argv[1], 'i')) freopen(\"input.txt\", \"r\", stdin);\n        if (strchr(argv[1], 'o')) freopen(\"output.txt\", \"w\", stdout);\n    }\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nstring dir = \"RDLU\";\n\nbool solve(int curr, int d, vector<vector<int> >& neighbor, int n, string& ret)\n{\n    if(n == 1)\n        return true;\n\n    for(int i=0; i<4; ++i){\n        if((i ^ 2) == d)\n            continue;\n\n        int next = neighbor[curr][i];\n        if(next == -1)\n            continue;\n\n        for(int j=0; j<4; ++j){\n            if(neighbor[curr][j] != -1)\n                neighbor[neighbor[curr][j]][j^2] = neighbor[curr][j^2];\n        }\n        ret += dir[i];\n\n        if(solve(next, i, neighbor, n-1, ret))\n            return true;\n\n        ret.resize(ret.size() - 1);\n        for(int j=0; j<4; ++j){\n            if(neighbor[curr][j] != -1)\n                neighbor[neighbor[curr][j]][j^2] = curr;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n\n    vector<string> s(h, string(w, ' '));\n    vector<vector<int> > index(h, vector<int>(w, -1));\n    int n = 0;\n    int start, sd;\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            cin >> s[y][x];\n            if(s[y][x] == 'o'){\n                index[y][x] = n;\n                ++ n;\n            }else if(isalpha(s[y][x])){\n                index[y][x] = n;\n                start = n;\n                ++ n;\n                if(s[y][x] == 'R')\n                    sd = 0;\n                else if(s[y][x] == 'D')\n                    sd = 1;\n                else if(s[y][x] == 'L')\n                    sd = 2;\n                else\n                    sd = 3;\n            }\n        }\n    }\n\n    vector<vector<int> > neighbor(n, vector<int>(4, -1));\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            if(index[y][x] == -1)\n                continue;\n\n            for(int i=0; i<4; ++i){\n                int y2 = y;\n                int x2 = x;\n                do{\n                    y2 += dy[i];\n                    x2 += dx[i];\n                }while(0 <= y2 && y2 < h && 0 <= x2 && x2 < w && index[y2][x2] == -1);\n\n                if(0 <= y2 && y2 < h && 0 <= x2 && x2 < w)\n                    neighbor[index[y][x]][i] = index[y2][x2];\n            }\n        }\n    }\n\n    string ret;\n    solve(start, sd, neighbor, n, ret);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring s,m[10];\nint h,w,cnt;\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nbool f(int x,int y,int r,int now)\n{\n\tif(now==cnt)\n\t{\n\t\tcout<<s<<endl;\n\t\treturn true;\n\t}\n\tfor(int dr=0;dr<4;dr++)\n\t{\n\t\tif(dr==2)continue;\n\t\tint nr=(r+dr)%4;\n\t\tint tx=x,ty=y;\n\t\twhile(tx>=0&&ty>=0&&tx<h&&ty<w&&m[tx][ty]!='o')tx+=dx[nr],ty+=dy[nr];\n\t\tif(tx>=0&&ty>=0&&tx<h&&ty<w&&m[tx][ty]=='o')\n\t\t{\n\t\t\tm[tx][ty]='.';\n\t\t\ts[now]=\"RDLU\"[nr];\n\t\t\tif(f(tx,ty,nr,now+1))return true;\n\t\t\tm[tx][ty]='o';\n\t\t}\n\t}\n\treturn false;\n}\nmain()\n{\n\tcin>>h>>w;\n\tint x,y,r;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tcin>>m[i];\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tcnt+=m[i][j]=='o';\n\t\t\tif(m[i][j]!='.'&&m[i][j]!='o')\n\t\t\t{\n\t\t\t\tx=i;\n\t\t\t\ty=j;\n\t\t\t\tr=m[i][j]=='R'?0:m[i][j]=='D'?1:m[i][j]=='L'?2:3;\n\t\t\t}\n\t\t}\n\t}\n\tm[x][y]='.';\n\ts=string(cnt,'A');\n\tf(x,y,r,0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef complex<double> P;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 2233\nchar g[11][11];\nchar cc[256];\nchar *cx=\"URDL\";\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint h,w;\nint cnt;\n\nstring DFS(int x, int y, int d){\n\tstring tmp;\n\tstring ret;\n\tint nx, ny;\n\tREP(i,4){\n\t\tif(i==(d+2)%4)continue;\n\t\tnx = x+dx[i];\n\t\tny = y+dy[i];\n\t\twhile(nx>=0&&nx<w&&ny>=0&&ny<h){\n\t\t\tif(g[ny][nx]=='o'){\n\t\t\t\tg[ny][nx]='.';\n\t\t\t\tcnt--;\n\t\t\t\tif(cnt==0){\n\t\t\t\t\tret=cx[i];\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\ttmp=DFS(nx,ny,i);\n\t\t\t\tif(tmp!=\"\"){\n\t\t\t\t\tret = cx[i];\n\t\t\t\t\tret += tmp;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tg[ny][nx]='o';\n\t\t\t\tcnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\t\t\t\n\t\t}\n\t}\n\treturn \"\";\t\n}\n\nint main(){\n\tint d,x,y;\n\tcin>>h>>w;\n\tcc['U']=0;\n\tcc['R']=1;\n\tcc['D']=2;\n\tcc['L']=3;\n\tcnt=0;\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tcin>>g[i][j];\n\t\t\tif(g[i][j]=='o')cnt++;\n\t\t\tif(g[i][j]=='U'||g[i][j]=='R'||g[i][j]=='D'|g[i][j]=='L'){\n\t\t\t\ty=i;\n\t\t\t\tx=j;\n\t\t\t\td=cc[g[i][j]];\n\t\t\t\tg[i][j]='.';\n\t\t\t}\n\t\t}\n\t}\n\tcout << DFS(x,y,d)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nint INF = INT_MAX / 2;\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dy[4] = {0, -1, 0, 1};\nint dx[4] = {-1, 0, 1, 0};\n\nint H, W, k = 0;\nbool a[10][10];\nstring s;\n\nbool f(int y, int x, int z) {\n\tif (!k) return true;\n\tfor (int dz = -1; dz <= 1; dz++) {\n\t\tint _z = (z + dz + 4) % 4;\n\t\tfor (int _y = y, _x = x; 0<=_y && _y<H && 0<=_x && _x<W; _y += dy[_z], _x += dx[_z])\n\t\t\tif (a[_y][_x]) {\n\t\t\t\tk--;\n\t\t\t\ta[_y][_x] = false;\n\t\t\t\tif (f(_y, _x, _z)) {\n\t\t\t\t\ts = \"LURD\"[_z] + s;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t\ta[_y][_x] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> H >> W;\n\tint ys, xs, zs;\n\tfor (int y = 0; y < H; y++) {\n\t\tstring s; cin >> s;\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tchar c = s[x];\n\t\t\tif (c == 'o') {\n\t\t\t\tk++;\n\t\t\t\ta[y][x] = true;\n\t\t\t}\n\t\t\telse if (c != '.') {\n\t\t\t\tys = y; xs = x;\n\t\t\t\tzs = string(\"LURD\").find(c);\n\t\t\t}\n\t\t}\n\t}\n\tf(ys, xs, zs);\n\tcout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint h,w;\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nchar map[10][10];\nstring ans;\n\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=h || x>=w)return false;\n  return true;\n}\n\nchar M(int muki){\n  if(muki==0)return 'U';\n  if(muki==1)return 'R';\n  if(muki==2)return 'D';\n  if(muki==3)return 'L';\n}\nvoid dfs(int y,int x,string s,int muki)\n{\n  int si=-1,sj=-1;\n  for(int i=1;i<10;i++){\n    int a=y+i*Y[muki],b=x+i*X[muki];\n    if(!in(a,b))return;\n    if(map[a][b]=='o'){\n      si=a;\n      sj=b;\n      map[a][b]='.';\n      s+=M(muki);\n      if(s.length()>ans.length())ans=s;\n      break;\n    }\n  }\n  if(si!=-1 && sj!=-1){\n    dfs(si,sj,s,muki);\n    dfs(si,sj,s,(muki+1)%4);\n    dfs(si,sj,s,(muki+3)%4);\n    map[si][sj]='o';\n  }\n}\nint main()\n{\n  int si,sj,muki;\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>map[i][j];\n      if(map[i][j]!='.' && map[i][j]!='o'){\n\tsi=i;\n\tsj=j;\n\tif(map[i][j]=='U')muki=0;\n\tif(map[i][j]=='R')muki=1;\n\tif(map[i][j]=='D')muki=2;\n\tif(map[i][j]=='L')muki=3;\n\tmap[i][j]='.';\n      }\n    }\n  }\n  ans=\"\";\n  dfs(si,sj,\"\",muki);\n  dfs(si,sj,\"\",(muki+1)%4);\n  dfs(si,sj,\"\",(muki+3)%4);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};\nint H, W;\nmap<char, int> dir;\nmap<int, char> dir2;\nstring ans;\nbool range_out(int x, int y){\n    return x < 0 || y < 0 || W <= x || H <= y;\n}\nbool dfs(const vector<string>& pond, int cx, int cy, int cd, int leaves, string score){\n    if(leaves == 0){\n        ans = score;\n        return true;\n    }\n    \n    rep(i, 4){\n        if(i == 3 - cd) continue;\n        int nx = cx, ny = cy;\n        bool end = false;\n        while(true){\n            nx += dx[i]; ny += dy[i];\n            if(range_out(nx, ny)){\n                end = true;\n                break;\n            }\n            if(pond[ny][nx] == 'o') break;\n        }\n        if(end) continue;\n        vector<string> temp = pond;\n        temp[ny][nx] = '.';\n        string st = score + dir2[i];\n        if(dfs(temp, nx, ny, i, leaves - 1, st)) return true;\n    }\n    return false;;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> H >> W;\n    vector<string> pond(H);\n    rep(i, H) cin >> pond[i];\n    int sx, sy, sd;\n    int leafnum = 0;\n    dir['U'] = 2; dir['D'] = 1; dir['L'] = 3; dir['R'] = 0;\n    for(const auto& k : dir) dir2[k.second] = k.first;\n    rep(i, H) rep(j, W){\n        if(pond[i][j] == 'o')\n          leafnum++;\n        if('A' <= pond[i][j] && pond[i][j] <= 'Z'){\n            sx = j; sy = i;\n            sd = dir[pond[i][j]];\n            pond[i][j] = '.';\n        }\n    }\n    string hoge = \"\";\n    dfs(pond, sx, sy, sd, leafnum, hoge);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nint n, m;\nchar g[12][12];\nchar ans[35];\nint LeafNum;\nint endFlag;\nchar final_ans[35];\n\nvoid BFS(int x, int y, int leaf_num, char dir)\n{\n    //printf(\"BFS : %d %d %d %d\\n\", x,y,leaf_num,dir);\n    if(endFlag == 1)\n        return;\n\n    ans[LeafNum - leaf_num] = dir;\n\n    if(leaf_num == 0)\n    {\n        endFlag = true;\n        return;\n    }\n\n    //Up\n    if(dir != 'D')\n        for(int i = x - 1; i >= 0; i--)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                BFS(i, y, leaf_num - 1, 'U');\n                g[i][y] = 'o';\n                break;\n            }\n\n    //Down\n    if(dir != 'U')\n        for(int i = x + 1; i < n; i++)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                BFS(i, y, leaf_num - 1, 'D');\n                g[i][y] = 'o';\n                break;\n            }\n\n    //Left\n    if(dir != 'R')\n        for(int i = y - 1; i >= 0; i--)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                BFS(x, i, leaf_num - 1, 'L');\n                g[x][i] = 'o';\n                break;\n            }\n\n    //Right\n    if(dir != 'L')\n        for(int i = y + 1; i < m; i++)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                BFS(x, i, leaf_num - 1, 'R');\n                g[x][i] = 'o';\n                break;\n            }\n\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n\n    int x, y;\n    int leaf_num = 0;\n    char dir;// 0 is up, 1 is left, 2 is down, 3 is right\n\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", g[i]);\n        for(int j = 0; j < m; j++)\n        {\n            if(g[i][j] == 'U' || g[i][j] == 'R' || g[i][j] == 'L' || g[i][j] == 'D')\n            {\n                x = i;\n                y = j;\n\n                dir = g[i][j];\n            }\n            if(g[i][j] == 'o')\n                leaf_num++;\n        }\n    }\n\n    LeafNum = leaf_num;\n    endFlag = 0;\n\n    BFS(x, y, leaf_num, dir);\n\n    //printf(\"Leaf : %d\\n\", LeafNum);\n    for (int i = 1; i <= LeafNum; ++i)\n        printf(\"%c\", ans[i]);\n    printf(\"\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 11\nusing namespace std;\nint h,w;\nstring mp[N];\nint dx[4]={0,1,0,-1};//^>V<\nint dy[4]={-1,0,1,0};//^>V<\nchar ch[]={'U','R','D','L'};\n\nbool check(int &y,int &x,int i){\n  while(1){\n    x+=dx[i],y+=dy[i];\n    if(x<0||y<0||x>=w||y>=h) return 0;\n    if(mp[y][x]=='o') return 1;\n  }\n}\n\nstring ans;\nbool dfs(int y,int x,int dir,int cnt){\n  if(cnt==0)return 1;\n  \n  for(int i=0;i<4;i++){\n    int nx=x,ny=y;\n    if((dir+2)%4==i||!check(ny,nx,i)) continue;\n    mp[ny][nx]='.';\n    if(dfs(ny,nx,i,cnt-1)){ans+=ch[i];return 1;}\n    mp[ny][nx]='o';\n  }\n  return 0;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  int cnt=0,sx,sy,dir;  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      char t=mp[i][j];\n      if(t=='o')cnt++;\n      if(t=='o'||t=='.')continue;\n      sx=j,sy=i;\n      if(t=='U')dir=0;\n      if(t=='R')dir=1;\n      if(t=='D')dir=2;\n      if(t=='L')dir=3;\n    }\n  dfs(sy,sx,dir,cnt);\n  reverse(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nchar m[12][12];\nint cnt = 0;\nchar dir;\ntypedef pair<int,int> pii;\npii begin;\nvector<char>ans;\npii cur;\nint h,w;\nbool dfs(pii x,char d);\nbool go(pii cur, char d)\n{\n\tint xx = cur.first;\n\tint yy = cur.second;\n\tif(d == 'U'){\n\t\tint x = xx,y = yy;\n\t\twhile(x > 0 && m[x][y] != 'o')--x;\n\t\tif (x == 0)return 0;\n\t\tcnt--;\n\t\tm[x][y] = '.';\t\t\n\t\tif (dfs(make_pair(x,y),'U'))return 1;\n\t\t++cnt;\n\t\tm[x][y] = 'o';\n\t}\n\tif(d == 'D'){\n\t\tint x = xx,y = yy;\n\t\twhile(x <= h && m[x][y] != 'o')++x;\n\t\tif (x == h + 1)return 0;\n\t\tcnt--;\n\t\tm[x][y] = '.';\t\t\n\t\tif (dfs(make_pair(x,y),'D'))return 1;\n\t\t++cnt;\n\t\tm[x][y] = 'o';\n\t}\n\tif(d == 'R'){\n\t\tint x = xx,y = yy;\n\t\twhile(y < w + 1 && m[x][y] != 'o')++y;\n\t\tif (y == w + 1)return 0;\n\t\tcnt--;\n\t\tm[x][y] = '.';\t\t\n\t\tif (dfs(make_pair(x,y),'R'))return 1;\n\t\t++cnt;\n\t\tm[x][y] = 'o';\n\t}\t\n\tif(d == 'L'){\n\t\tint x = xx,y = yy;\n\t\twhile(y > 0 && m[x][y] != 'o')--y;\n\t\tif (y == 0)return 0;\n\t\tcnt--;\n\t\tm[x][y] = '.';\t\t\n\t\tif (dfs(make_pair(x,y),'L'))return 1;\n\t\t++cnt;\n\t\tm[x][y] = 'o';\n\t}\n\treturn 0;\n}\n\nbool dfs(pii x,char d)\n{\n\tif (cnt == 0){\n\t\treturn 1;\n\t}//\n\tif (d == 'U'){\n\t\tif (go(x,'U')){\n\t\t\tans.push_back('U');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'R')){\n\t\t\tans.push_back('R');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'L')){\n\t\t\tans.push_back('L');\n\t\t\treturn 1;\n\t\t}\n\t}//\n\tif (d == 'D'){\n\t\tif (go(x,'D')){\n\t\t\tans.push_back('D');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'R')){\n\t\t\tans.push_back('R');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'L')){\n\t\t\tans.push_back('L');\n\t\t\treturn 1;\n\t\t}\n\t}\t\n\tif (d == 'L'){\n\t\tif (go(x,'D')){\n\t\t\tans.push_back('D');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'U')){\n\t\t\tans.push_back('U');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'L')){\n\t\t\tans.push_back('L');\n\t\t\treturn 1;\n\t\t}\n\t}\t\t\n\tif (d == 'R'){\n\t\tif (go(x,'D')){\n\t\t\tans.push_back('D');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'U')){\n\t\t\tans.push_back('U');\n\t\t\treturn 1;\n\t\t}\n\t\tif (go(x,'R')){\n\t\t\tans.push_back('R');\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main()\n{\n\tscanf(\"%d%d\",&h,&w);\n\tfor (int i = 1; i <= h; ++i)\n\tscanf(\"%s\",m[i]+1);\n\t\n\tfor (int i = 1; i <= h; ++i)\n\tfor (int j = 1; j <= w; ++j)\n\t{\n\t\tif (m[i][j] == 'o')++cnt;\n\t\tif (m[i][j]!='o' && m[i][j]!='.'){\n\t\t\tbegin = make_pair(i,j);\n\t\t\tdir = m[i][j];\n\t\t\tm[i][j] = '.';\n\t\t}\n\t}\n\tcur = begin;\n\tdfs(begin,dir);\n\tfor (int i = ans.size(); i >= 0; --i)\n\tputchar(ans[i]);\n\t//cout<<ans.size()<<endl;\n\tputs(\"\");\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nchar d[4] = {'D', 'R', 'U', 'L'};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    cin >> H >> W;\n    vector<string> s(H);\n    vector<P> ls;\n    int sx, sy, dir;\n    map<P, int> rev;\n    for (int i = 0; i < H; i++)\n    {\n        cin >> s[i];\n        for (int j = 0; j < W; j++)\n        {\n            if (s[i][j] == '.')\n                continue;\n            if (s[i][j] == 'o')\n            {\n                rev[P(i, j)] = ls.size();\n                ls.push_back(P(i, j));\n                continue;\n            }\n            sx = i;\n            sy = j;\n            if (s[i][j] == 'D')\n                dir = 0;\n            else if (s[i][j] == 'R')\n                dir = 1;\n            else if (s[i][j] == 'U')\n                dir = 2;\n            else\n                dir = 3;\n            s[i][j] = '.';\n        }\n    }\n    // pos, dir, mask\n    map<T, string> mp;\n    int sz = ls.size();\n    ll mask = (1LL << sz) - 1;\n    ls.push_back(P(sx, sy));\n    queue<T> q;\n    q.push(T(sz, dir, mask));\n    mp[T(sz, dir, mask)] = \"\";\n    while (!q.empty())\n    {\n        T t = q.front();\n        q.pop();\n        int pos = get<0>(t);\n        int dir = get<1>(t);\n        mask = get<2>(t);\n        for (int i = 0; i < 4; i++)\n        {\n            if (abs(dir - i) == 2)\n                continue;\n            for (int j = 1; j < 10; j++)\n            {\n                int nx = ls[pos].first + j * dx[i], ny = ls[pos].second + j * dy[i];\n                if (nx < 0 || H <= nx || ny < 0 || W <= ny)\n                    continue;\n                if (s[nx][ny] != 'o')\n                    continue;\n                int idx = rev[P(nx, ny)];\n                // \n                if (((mask >> idx) & 1) == 0)\n                    continue;\n                ll mask2 = mask ^ (1LL << idx);\n                T nt = T(idx, i, mask2);\n                if (mp.find(nt) != mp.end())\n                    break;\n                q.push(nt);\n                string ns = mp[t];\n                ns += d[i];\n                mp[nt] = ns;\n                break;\n            }\n        }\n    }\n    for(auto t:mp){\n        if(get<2>(t.first) == 0){\n            cout<<t.second<<endl;\n            return 0;\n        }\n    }\n    assert(false);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstruct data{\n\tint next[4],cnt;\n\tdata(int prx=-1,int nex=-1,int pry=-1,int ney=-1){\n\t\tnext[0]=prx;\n\t\tnext[2]=nex;\n\t\tnext[1]=pry;\n\t\tnext[3]=ney;\n\t\tcnt=0;\n\t}\n};\nint h,w;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstring dirchar=\"RDLU\";\nint fie[11][11];\nint s,sdir;\nint cnt;\nstring res;\nvoid dfs(int v,int dir,vector<data> dat,string str){\n\tif(str.size()==cnt-1){\n\t\tres=str;\n\t\treturn;\n\t}\n\tfor(int i=-1;i<=1;i++){\n\t\tint ndir=(dir+4+i)%4;\n\t\tif(dat[v].next[ndir]!=-1){\n\t\t\tvector<data> nex;\n\t\t\tnex=dat;\n\t\t\tint f=nex[v].next[ndir];\n\t\t\tint t=nex[v].next[(ndir+2)%4];\n\t\t\tif(t!=-1){\n\t\t\t\tnex[t].next[ndir]=f;\n\t\t\t\tif(f==-1)nex[t].cnt--;\n\t\t\t}\n\t\t\tif(f!=-1){\n\t\t\t\tnex[f].next[(ndir+2)%4]=t;\n\t\t\t\tif(t==-1)nex[f].cnt--;\n\t\t\t}\n\t\t\tif(nex[f].cnt==0 || nex[t].cnt==0)continue;\n\t\t\tdfs(f,ndir,nex,str+dirchar[ndir]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&h,&w);\n\tvector<data> dat;\n\tfor(int i=0;i<h;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=-1;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(str[j]==dirchar[k]){\n\t\t\t\t\ts=cnt;\n\t\t\t\t\tsdir=k;\n\t\t\t\t\tdat.push_back(data());\n\t\t\t\t\tfie[j][i]=cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[j]=='o'){\n\t\t\t\tdat.push_back(data());\n\t\t\t\tfie[j][i]=cnt++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[j][i]==-1)continue;\n\t\t\tint k=j+1;\n\t\t\twhile(k<w){\n\t\t\t\tif(fie[k][i]>=0){\n\t\t\t\t\tdat[fie[j][i]].next[0]=fie[k][i];\n\t\t\t\t\tdat[fie[j][i]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tk=j-1;\n\t\t\twhile(k>=0){\n\t\t\t\tif(fie[k][i]>=0){\n\t\t\t\t\tdat[fie[j][i]].next[2]=fie[k][i];\n\t\t\t\t\tdat[fie[j][i]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tif(fie[i][j]==-1)continue;\n\t\t\tint k=j+1;\n\t\t\twhile(k<h){\n\t\t\t\tif(fie[i][k]>=0){\n\t\t\t\t\tdat[fie[i][j]].next[1]=fie[i][k];\n\t\t\t\t\tdat[fie[i][j]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tk=j-1;\n\t\t\twhile(k>=0){\n\t\t\t\tif(fie[i][k]>=0){\n\t\t\t\t\tdat[fie[i][j]].next[3]=fie[i][k];\n\t\t\t\t\tdat[fie[i][j]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(s,sdir,dat,\"\");\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstruct data{\n\tint next[4],cnt;\n\tdata(int prx=-1,int nex=-1,int pry=-1,int ney=-1){\n\t\tnext[0]=prx;\n\t\tnext[2]=nex;\n\t\tnext[1]=pry;\n\t\tnext[3]=ney;\n\t\tcnt=0;\n\t}\n};\nint h,w;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstring dirchar=\"RDLU\";\nint fie[11][11];\nint s,sdir;\nint cnt;\nstring res;\nvoid dfs(int v,int dir,vector<data> dat,string str){\n\tif(str.size()==cnt-1){\n\t\tres=str;\n\t\treturn;\n\t}\n\tfor(int i=-1;i<=1;i++){\n\t\tint ndir=(dir+4+i)%4;\n\t\tif(dat[v].next[ndir]!=-1){\n\t\t\tvector<data> nex;\n\t\t\tnex=dat;\n\t\t\tint f=nex[v].next[ndir];\n\t\t\tint t=nex[v].next[(ndir+2)%4];\n\t\t\tif(t!=-1)nex[t].next[ndir]=f;\n\t\t\telse nex[t].cnt--;\n\t\t\tif(f!=-1)nex[f].next[(ndir+2)%4]=t;\n\t\t\telse nex[f].cnt--;\n\t\t\tif(nex[f].cnt==0 || nex[t].cnt==0)continue;\n\t\t\tdfs(f,ndir,nex,str+dirchar[ndir]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&h,&w);\n\tvector<data> dat;\n\tfor(int i=0;i<h;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=-1;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(str[j]==dirchar[k]){\n\t\t\t\t\ts=cnt;\n\t\t\t\t\tsdir=k;\n\t\t\t\t\tdat.push_back(data());\n\t\t\t\t\tfie[j][i]=cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[j]=='o'){\n\t\t\t\tdat.push_back(data());\n\t\t\t\tfie[j][i]=cnt++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[j][i]==-1)continue;\n\t\t\tint k=j+1;\n\t\t\twhile(k<w){\n\t\t\t\tif(fie[k][i]>=0){\n\t\t\t\t\tdat[fie[j][i]].next[0]=fie[k][i];\n\t\t\t\t\tdat[fie[j][i]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tk=j-1;\n\t\t\twhile(k>=0){\n\t\t\t\tif(fie[k][i]>=0){\n\t\t\t\t\tdat[fie[j][i]].next[2]=fie[k][i];\n\t\t\t\t\tdat[fie[j][i]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tif(fie[i][j]==-1)continue;\n\t\t\tint k=j+1;\n\t\t\twhile(k<h){\n\t\t\t\tif(fie[i][k]>=0){\n\t\t\t\t\tdat[fie[i][j]].next[1]=fie[i][k];\n\t\t\t\t\tdat[fie[i][j]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tk=j-1;\n\t\t\twhile(k>=0){\n\t\t\t\tif(fie[i][k]>=0){\n\t\t\t\t\tdat[fie[i][j]].next[3]=fie[i][k];\n\t\t\t\t\tdat[fie[i][j]].cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(s,sdir,dat,\"\");\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#pragma warning(disable: 4996)\nint H, W, r, cnt,  dir[4] = { 1, 0, -1, 0 }; char c[12][12], f[31], g[] = \"RDLU\";\nvoid solve(int x, int y, int d, int e) {\n\tif (d == r) {\n\t\tfor (int i = 0; i < r; i++) printf(\"%c\", f[i]);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tif ((i + 2) % 4 == e) continue;\n\t\tint tx = x, ty = y;\n\t\twhile (0 <= tx && tx < W && 0 <= ty && ty < H) {\n\t\t\tif (c[ty][tx] == 'o') {\n\t\t\t\tc[ty][tx] = '.'; f[d] = g[i];\n\t\t\t\tsolve(tx, ty, d + 1, i);\n\t\t\t\tc[ty][tx] = 'o'; f[d] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += dir[i];\n\t\t\tty += dir[i ^ 1];\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) scanf(\"%s\", c[i]);\n\tint sy, sx, se;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif (c[i][j] == g[k]) {\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t\tsy = i, sx = j, se = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c[i][j] == 'o') r++;\n\t\t}\n\t}\n\tsolve(sx, sy, 0, se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 11\nusing namespace std;\nint h,w;\nstring mp[N];\nint dx[4]={0,1,0,-1};//^>V<\nint dy[4]={-1,0,1,0};//^>V<\nchar ch[]={'U','R','D','L'};\n\nbool check(int &y,int &x,int i){\n  while(x>=0&&y>=0&&x<w&&y<h&&mp[y][x]!='o')x=x+dx[i],y=y+dy[i];\n  return x>=0&&y>=0&&x<w&&y<h&&mp[y][x]=='o';\n}\n\nstring ans;\nbool dfs(int y,int x,int dir,int cnt){\n  if(cnt==0){return 1;}\n  \n  for(int i=0;i<4;i++){\n    int nx=x,ny=y;\n    if((dir+2)%4==i||!check(ny,nx,i)) continue;\n    mp[ny][nx]='.';\n    if(dfs(ny,nx,i,cnt-1)){ans+=ch[i];return 1;}\n    mp[ny][nx]='o';\n  }\n  return 0;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  int cnt=0,sx,sy,dir;  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      char t=mp[i][j];\n      if(t=='o')cnt++;\n      if(t=='o'||t=='.')continue;\n      sx=j,sy=i;\n      if(t=='U')dir=0;\n      if(t=='R')dir=1;\n      if(t=='D')dir=2;\n      if(t=='L')dir=3;\n    }\n\n  dfs(sy,sx,dir,cnt);\n  reverse(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n#define abs(x) ((x)>=0?(x):-(x))\n#define i64 long long\n#define u32 unsigned int\n#define u64 unsigned long long\n#define clr(x,y) memset(x,y,sizeof(x))\n#define PI acos(-1.0)\n#define sqr(x) ((x)*(x))\n#define maxn 20\n\nchar mp1[maxn][maxn];\nint mp[maxn][maxn];\nint dx[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nint hash[256];\nchar str[10] = \"DRUL\";\nint n,m;\nint sx , sy;\nint sdir;\nint st[1000005];\nint num ;\nint ans ;\nvoid init()\n{\n  memset(hash,-1,sizeof(hash));\n  hash['U'] = 2;\n  hash['D'] = 0;\n  hash['R'] = 1;\n  hash['L'] = 3;\n}\nint check(int x ,int y ,int dir )\n{\n  int res;\n  res = 0 ;\n  x += dx[dir][0];\n  y += dx[dir][1];\n  res ++ ;\n  while(mp[x][y] == 0 && x <= n && y <= m && x > 0 && y > 0  )\n  {\n    res ++ ;\n    x += dx[dir][0];\n    y += dx[dir][1];\n  }\n  //printf(\"%d\\n\",res);\n  if(mp[x][y] == 0 ) return -1;\n  else return res;\n}\nbool flag;\nvoid print(int nn )\n{\n  int cnt = sdir;\n  for(int i = 0 ; i < nn ; i ++ )\n  {\n    //printf(\"%d\\n\",cnt);\n    if(st[i] < cnt ) cnt = (cnt - 1 + 4 ) % 4;\n    if(st[i] > cnt ) cnt = (cnt + 1 ) % 4 ;\n    printf(\"%c\",str[cnt]);\n  }\n  printf(\"\\n\");\n}\nvoid dfs(int x ,int y ,int dir, int dep )\n{\n  //printf(\"dfs: %d %d\\n\",x,y);\n  if(flag ) return ;\n  if(num == 1)\n  {\n    print(dep);\n    flag = true ;\n    return ;\n  }\n  int kk,xx,yy;\n  for(int k = 0; k < 4; k ++ )\n    if(flag == false && k != (dir + 2 ) % 4  )\n    {\n      kk = check(x,y,k);\n      if(kk == -1 ) continue;\n      xx = x + kk * dx[k][0];\n      yy = y + kk * dx[k][1];\n      num = num - 1 ;\n      mp[x][y] = 0 ;\n      st[dep] = k ;\n      dfs(xx , yy , k , dep + 1 );\n      num = num + 1 ;\n      mp[x][y] = 1;\n    }\n}\nint main()\n{\n  init();\n  while(scanf(\"%d%d\",&n,&m)!=EOF)\n  {\n    memset(mp,0,sizeof(mp));\n    num = 0 ;\n    sx = -1;\n    sy = -1;\n    for(int i = 1 ; i <= n ; i++ )\n    {\n      scanf(\"%s\",mp1[i]);\n      // printf(\"%s|\\n\",mp1[i]);\n      for(int j = 0 ; j < m ; j ++ )\n      {\n        // printf(\"%c\",mp1[i][j]);\n        if(mp1[i][j] == 'o')\n        {\n          num ++ ;\n          mp[i][j + 1 ] = 1 ;\n        }\n        else if(mp1[i][j] == '.' )\n        {\n          mp[i][j+1] = 0 ;\n        }\n        else// if(mp1[i][j] == 'U' ||mp1[i][j] == 'D' ||mp1[i][j] == 'L'||mp1[i][j] =='R' )\n        {\n          // printf(\"aasdmaklsd\");\n          num ++ ;\n          mp[i][j+1] = 1;\n          sx = i;\n          sy = j + 1 ;\n         // printf(\"sx sy %d %d\\n\",sx,sy);\n          sdir = hash[mp1[i][j]];\n        }\n      }\n    }\n   // printf(\"%d %d\\n\",sx,sy);\n    int tmp ;\n    tmp = num;\n    flag = false;\n    dfs(sx,sy,sdir,0);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=103,INF=1<<30;\nint H,W;\nstring URDL=\"URDL\",ans;\n\nvector<int> dh={-1,0,1,0},dw={0,1,0,-1};\n\nbool DFS(vector<string> S,pair<int,int> u,int dir,int rem){\n    if(rem==0) return true;\n    \n    for(int k=0;k<4;k++){\n        if(abs(dir-k)==2) continue;\n        \n        int h=u.first,w=u.second;\n        \n        while(h>=0&&h<H&&w>=0&&w<W){\n            if(S[h][w]=='o'){\n                S[h][w]='.';\n                if(DFS(S,{h,w},k,rem-1)){\n                    ans.push_back(URDL[k]);\n                    \n                    return true;\n                }\n                S[h][w]='o';\n                break;\n            }\n            \n            h+=dh[k];\n            w+=dw[k];\n        }\n    }\n    \n    return false;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>H>>W;\n    int N=0;\n    vector<string> S(H);\n    pair<int,int> s;\n    int sd;\n    for(int i=0;i<H;i++){\n        cin>>S[i];\n        for(int j=0;j<W;j++){\n            if(S[i][j]=='o') N++;\n            \n            for(int k=0;k<4;k++){\n                if(S[i][j]==URDL[k]){\n                    s={i,j};\n                    sd=k;\n                    S[i][j]='.';\n                }\n            }\n        }\n    }\n    \n    DFS(S,s,sd,N);\n    \n    reverse(all(ans));\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint n,m,x,y,t,flag,sum;\nchar a[12][12],s[66];\nchar h[5]=\"UDLR\";\nvoid get(int x,int y,int t,int num)\n{\n    //printf(\"%d:%d->%d:%d\\n\",x,y,t,num);\n    s[num]=h[t];\n    a[x][y]='.';\n    if(flag)return;\n    if(num==sum-1)\n    {\n        printf(\"%s\\n\",s+1);\n        flag=1;\n        return;\n    }\n///U\n    if(t!=1)\n    {\n        for(int i=x-1; i>=0; i--)\n        {\n            if(a[i][y]=='o')\n            {\n                get(i,y,0,num+1);\n                if(!flag)a[i][y]='o';\n                else return;\n                break;\n            }\n        }\n    }\n\n///D\n    if(t!=0)\n    {\n        for(int i=x+1; i<n; i++)\n        {\n            if(a[i][y]=='o')\n            {\n                get(i,y,1,num+1);\n                if(!flag) a[i][y]='o';\n                else return;\n                break;\n            }\n        }\n    }\n\n///L\n    if(t!=3)\n    {\n        for(int i=y-1; i>=0; i--)\n        {\n            if(a[x][i]=='o')\n            {\n                get(x,i,2,num+1);\n                if(!flag) a[x][i]='o';\n                else return;\n                break;\n            }\n        }\n    }\n\n///R\n    if(t!=2)\n    {\n        for(int i=y+1; i<m; i++)\n        {\n            if(a[x][i]=='o')\n            {\n                get(x,i,3,num+1);\n                if(!flag) a[x][i]='o';\n                else return;\n                break;\n            }\n        }\n    }\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        sum=0;\n        for(int i=0; i<n; i++)\n        {\n            scanf(\"%s\",a[i]);\n            for(int j=0; j<m; j++)\n            {\n                if(a[i][j]=='U')\n                {\n                    x=i,y=j,t=0;\n                }\n                if(a[i][j]=='D')\n                {\n                    x=i,y=j,t=1;\n                }\n                if(a[i][j]=='L')\n                {\n                    x=i,y=j,t=2;\n                }\n                if(a[i][j]=='R')\n                {\n                    x=i,y=j,t=3;\n                }\n                if(a[i][j]!='.')sum++;\n            }\n        }\n        flag=0;\n        memset(s,0,sizeof(s));\n        get(x,y,t,0);\n        //printf(\"*****\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar dc[5] = \"RDLU\";\n\nbool dfs(int y, int x, int l, string &ans, vector<vector<char> > &field){\n    if(l==0){\n        ans[l] = field[y][x];\n        return true;\n    }\n\n    char dir = field[y][x];\n    for(int i=0; i<4; i++){\n        if(field[y][x] == dc[(i+2)%4]) continue;\n        int ny=y, nx=x;\n        while(field[ny][nx] != 'x'){\n            if(field[ny][nx]=='o'){\n                field[y][x] = '.';\n                field[ny][nx] = dc[i];\n                if(dfs(ny, nx, l-1, ans, field)){\n                    ans[l] = dir;\n                    return true;\n                }\n                field[ny][nx] = 'o';\n                field[y][x] = dir;\n                break;\n            }\n            ny += dy[i];\n            nx += dx[i];\n        }\n    }\n    return false;\n}\n\nint main(){\n    int h,w;\n    cin >> h >> w;\n    vector<vector<char> > field(h+2, vector<char>(w+2, 'x'));\n    int sx,sy, leaf=0;\n    for(int i=1; i<=h; i++){\n        for(int j=1; j<=w; j++){\n            cin >> field[i][j];\n            if(field[i][j] == 'o'){\n                leaf++;\n            }else if(field[i][j] != '.'){\n                sy = i;\n                sx = j;\n            }\n        }\n    }\n    string ans(leaf, '.');\n    dfs(sy, sx, leaf, ans, field);\n    reverse(ans.begin(), ans.end());\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 15\n \nint H,W;\nchar field[MAX][MAX];\nstring ans;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nconst char mark[] = {'U','R','D','L'};\n \nbool inField(int y,int x){\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nint getDir(char ch){\n    if(ch == 'U') return 0;\n    if(ch == 'R') return 1;\n    if(ch == 'D') return 2;\n    if(ch == 'L') return 3;\n    return -1;\n}\n \nvoid solve(int y,int x,int dir,int cnt,string s){\n    if(cnt == 0){\n\tans = s;\n\treturn;\n    }\n \n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x, ny = y;\n\tif(dir == 0 && i == 2) continue;\n\tif(dir == 1 && i == 3) continue;\n\tif(dir == 2 && i == 0) continue;\n\tif(dir == 3 && i == 1) continue;\n \n\twhile(inField(ny,nx)){\n\t    nx += dx[i];\n\t    ny += dy[i];\n\t    if(field[ny][nx] == 'o'){\n\t\tfield[ny][nx] = '.';\n\t\tsolve(ny,nx,i,cnt-1,s+mark[i]);\n\t\tfield[ny][nx] = 'o';\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n \nint main(){\n    int x,y,dir,cnt = 0;\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    cin >> field[i][j];\n\t    int num = getDir(field[i][j]);\n\t    if(num != -1){\n\t\tx = j, y = i; dir = num;\n\t    }else if(field[i][j] == 'o'){\n\t\tcnt++;\n\t    }\n\t}\n    }\n    field[y][x] = '.';\n    solve(y,x,dir,cnt,\"\");\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint h, w;\nint pass[32];\nchar t[12][12];\nstring str = \"URDL\";\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool solve(int idx, int x, int y, int d, int rem){\n  if(rem == 0){\n    return true;\n  }\n\n  t[y][x] = '.';\n\n  for(int i = -1; i <= 1; i++){\n    int nd = (d + i + 4) % 4;\n    int nx = x;\n    int ny = y;\n\n    while(true){\n      nx += dx[nd];\n      ny += dy[nd];\n      if(0 > nx || nx >= w || 0 > ny || ny >= h) break;\n      if(t[ny][nx] == 'o'){\n        pass[idx] = nd;\n        if(solve(idx + 1, nx, ny, nd, rem - 1)) return true;\n        break;\n      }\n    }\n  }\n\n  t[y][x] = 'o';\n\n  return false;\n}\n\nint main(){\n  while(cin >> h >> w){\n    int sum = 0;\n    int sx, sy, sd;\n\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n\n      for(int j = 0; j < w; j++){\n        if(t[i][j] == 'o'){\n          sum++;\n        }\n        else if(t[i][j] != '.'){\n          sx = j;\n          sy = i;\n\n          if(t[i][j] == 'U') sd = 0;\n          else if(t[i][j] == 'R') sd = 1;\n          else if(t[i][j] == 'D') sd = 2;\n          else if(t[i][j] == 'L') sd = 3;\n\n          t[i][j] = '.';\n        }\n      }\n    }\n\n    solve(0, sx, sy, sd, sum);\n\n    for(int i = 0; i < sum; i++){\n      cout << str[pass[i]];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint h,w;\nchar field[11][11];\nint sang;\nint sx,sy;\nint leaf;\nchar rec[1001];\nbool fin;\nconst string ss=\"UUULLDDRRR\";\n\nvoid dfs(int cx,int cy,int cang,int cnt){\n\tif(fin)return;\n\tif(leaf==cnt){\n\t\tfin=true;\n\t\tfor(int i=0;i<leaf;i++)cout<<rec[i];\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\tstring s;\n\tfor(int i=0;i<cnt;i++)s+=rec[i];\n\tif(ss==s){\n\t//\tcout<<endl;\n\t}\n\tif(cang!=2){\n\t\tfor(int i=-1;i+cy>=0;i--){\n\t\t\tint nx=cx;\n\t\t\tint ny=i+cy;\n\t\t\tif(field[ny][nx]=='o'){\n\t\t\t\tfield[ny][nx]='.';\n\t\t\t\trec[cnt]='U';\n\t\t\t\tdfs(nx,ny,0,cnt+1);\n\t\t\t\tfield[ny][nx]='o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(cang!=0){\n\t\tfor(int i=1;i+cy<h;i++){\n\t\t\tint nx=cx;\n\t\t\tint ny=i+cy;\n\t\t\tif(field[ny][nx]=='o'){\n\t\t\t\tfield[ny][nx]='.';\n\t\t\t\trec[cnt]='D';\n\t\t\t\tdfs(nx,ny,2,cnt+1);\n\t\t\t\tfield[ny][nx]='o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(cang!=3){\n\t\tfor(int i=1;i+cx<w;i++){\n\t\t\tint nx=cx+i;\n\t\t\tint ny=cy;\n\t\t\tif(field[ny][nx]=='o'){\n\t\t\t\tfield[ny][nx]='.';\n\t\t\t\trec[cnt]='R';\n\t\t\t\tdfs(nx,ny,1,cnt+1);\n\t\t\t\tfield[ny][nx]='o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(cang!=1){\n\t\tfor(int i=-1;i+cx>=0;i--){\n\t\t\tint nx=cx+i;\n\t\t\tint ny=cy;\n\t\t\tif(field[ny][nx]=='o'){\n\t\t\t\tfield[ny][nx]='.';\n\t\t\t\trec[cnt]='L';\n\t\t\t\tdfs(nx,ny,3,cnt+1);\n\t\t\t\tfield[ny][nx]='o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tcin>>h>>w;\n\tfin=false;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='o')leaf++;\n\t\t\telse if(field[i][j]!='.'&&field[i][j]!='o'){\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\tcase 'U':\n\t\t\t\t\tsang=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tsang=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tsang=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tsang=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfield[i][j]='.';\n\t\t\t\tsx=j;sy=i;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sx,sy,sang,0);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h;\nint cnt;\nchar dirtoc[200];\nint mapto[40][40];\nchar field[40][40];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nchar ans[100];\n\nstruct State {\n  int used;\n  int x;\n  int y;\n  int dir;\n  State() {;}\n  State(int used, int x, int y, int dir) : used(used), x(x), y(y), dir(dir) {;}\n  bool operator<(const State &rhs) const {\n    if (used != rhs.used) { return used < rhs.used; }\n    if (x != rhs.x) { return x < rhs.x; }\n    if (y != rhs.y) { return y < rhs.y; }\n    return dir < rhs.dir;\n  }\n};\n\nset<State> visit;\nbool calc(State state) {\n  if (visit.count(state)) { return false; }\n  int depth = __builtin_popcount(state.used);\n  if (depth == cnt - 1) { return true; }\n  visit.insert(state);\n  field[state.y][state.x] = '.';\n  int nused = state.used | (1 << mapto[state.y][state.x]);\n  REP(i, 4) {\n    if (i == 2) { continue; }\n    int ndir = (state.dir + i) % 4;\n    int nx = state.x;\n    int ny = state.y;\n    ans[depth] = dirtoc[ndir];\n    while (field[ny][nx] != 'o') {\n      nx += dx[ndir];\n      ny += dy[ndir];\n      if (nx < 0 || nx >= w || ny < 0 || ny >= h) { goto ng; }\n    }\n    if (calc(State(nused, nx, ny, ndir))) { return true; }\nng:;\n  }\n  field[state.y][state.x] = 'o';\n  return false;\n}\n\nint main() {\n  dirtoc[0] = 'R';\n  dirtoc[1] = 'D';\n  dirtoc[2] = 'L';\n  dirtoc[3] = 'U';\n  while (scanf(\"%d %d\", &h, &w) > 0) {\n    int px, py, dir;\n    cnt = 0;\n    MEMSET(mapto, -1);\n    MEMSET(ans, 0);\n    visit.clear();\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 'R') { dir = 0; field[y][x] = 'o'; px = x; py = y; }\n        if (field[y][x] == 'D') { dir = 1; field[y][x] = 'o'; px = x; py = y; }\n        if (field[y][x] == 'L') { dir = 2; field[y][x] = 'o'; px = x; py = y; }\n        if (field[y][x] == 'U') { dir = 3; field[y][x] = 'o'; px = x; py = y; }\n        if (field[y][x] == 'o') {\n          mapto[y][x] = cnt++;\n        }\n      }\n    }\n    bool ok = calc(State(0, px, py, dir));\n    puts(ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 11;\nconst int dx[] = {0,0,-1,1};\nconst int dy[] = {-1,1,0,0};\n\nbool flag;\nvector<int> ans;\n\nvoid dfs(int u,int v,int dir,set<int>* h,set<int>* w,vector<int>& route,int rem)\n{\n    if(flag){\n        return;\n    }\n    if(rem == 0){\n        ans = route;\n        flag = true;\n        return;\n    }\n    int dame = (dir%2 == 0)?dir+1:dir-1;\n    rep(i,4){\n        if(flag){\n            return;\n        }\n        if(i != dame){\n            if(i == 0){\n                auto it = lower_bound(all(h[v]),u);\n                if(it != h[v].begin()){\n                    it--;\n                    int hoge = *it;\n                    h[v].erase(hoge);\n                    route.pb(0);\n                    dfs(hoge,v,0,h,w,route,rem-1);\n                    h[v].insert(hoge);\n                    route.pop_back();\n                }\n            }\n            if(i == 1){\n                auto it = upper_bound(all(h[v]),u);\n                if(it != h[v].end()){\n                    int hoge = *it;\n                    h[v].erase(hoge);\n                    route.pb(1);\n                    dfs(hoge,v,1,h,w,route,rem-1);\n                    h[v].insert(hoge);\n                    route.pop_back();\n                }\n            }\n            if(i == 2){\n                auto it = lower_bound(all(w[u]),v);\n                if(it != w[u].begin()){\n                    it--;\n                    int hoge = *it;\n                    w[u].erase(hoge);\n                    route.pb(2);\n                    dfs(u,hoge,2,h,w,route,rem-1);\n                    w[u].insert(hoge);\n                    route.pop_back();\n                }\n            }\n            if(i == 3){\n                auto it = upper_bound(all(w[u]),v);\n                if(it != w[u].end()){\n                    int hoge = *it;\n                    w[u].erase(hoge);\n                    route.pb(3);\n                    dfs(u,hoge,3,h,w,route,rem-1);\n                    w[u].insert(hoge);\n                    route.pop_back();\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n,m;\n    set<int> h[MAX_N];\n    set<int> w[MAX_N];\n    vector<int> v;\n    cin >> n >> m;\n    int sx,sy,dir;\n    int cnt  = 0;\n    flag = false;\n    rep(i,n){\n        string s;\n        cin >> s;\n        rep(j,s.length()){\n            if(s[j] == 'o'){\n                h[i].insert(j);\n                w[j].insert(i);\n                cnt++;\n            }else if(s[j] == 'U'){\n                sx = i,sy = j,dir = 0;\n            }else if(s[j] == 'D'){\n                sx = i,sy = j,dir = 1;\n            }else if(s[j] == 'L'){\n                sx = i,sy = j,dir = 2;\n            }else if(s[j] == 'R'){\n                sx = i,sy = j,dir = 3;\n            }\n        }\n    }\n    char d[] = {'U','D','L','R'};\n    dfs(sx,sy,dir,w,h,v,cnt);\n    rep(i,ans.size()){\n        cout << d[ans[i]];\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint init_dic(int x,int y,\n\t    map<P,int>& dic){\n  if(dic.find(P(x,y)) == dic.end()){\n    int idx = dic.size();\n    dic[P(x,y)] = idx;\n  }\n  return dic[P(x,y)];\n}\n\nvoid fill_dic(int W,int H,map<P,int>& dic){\n  for(int x=0;x<=W;x++){\n    for(int y=0;y<=H;y++){\n      if(dic.find(P(x,y)) == dic.end()){\n\tdic[P(x,y)] = -1;\n      }\n    }\n  }\n}\n\nclass State{\npublic:\n  int x;\n  int y;\n  int dir;\n  int remaining;\n  int cost;\n  vector<char> route;\n  State(int _x,int _y,int _dir,int _remaining,int _cost,const vector<char>& _r)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost),route(_r) {}\n  State(int _x,int _y,int _dir,int _remaining,int _cost)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[101][101];\n    int sx,sy;\n    int dir;\n    int init_state=0;\n    map<P,int> dic;\n\n    for(int y=0;y<H;y++){\n      char buf[101];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = buf[x];\n\tif(buf[x] == 'U' || buf[x] == 'R'\n\t   || buf[x] == 'D' || buf[x] == 'L'){\n\t  sx = x;\n\t  sy = y;\n\t  const char dirs[4] = {'U','R','D','L'};\n\t  for(int i=0;i<4;i++){\n\t    if(dirs[i] == buf[x]){\n\t      dir = i;\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(buf[x] == 'o'){\n\t  init_state |= (1<<init_dic(x,y,dic));\n\t}\n      }\n    }\n    \n    fill_dic(W,H,dic);\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,dir,init_state,0));\n\n    set<int> visited[101][101][4];\n    bool flag = false;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(visited[s.x][s.y][s.dir].count(s.remaining) > 0) continue;\n      visited[s.x][s.y][s.dir].insert(s.remaining);\n\n      if(__builtin_popcount(s.remaining) == 1){\n\tconst char dirs[4] = {'U','R','D','L'};\n\tstring ans = \"\";\n\tfor(int i=0; i<s.route.size(); i++){\n\t  ans += dirs[s.route[i]];\n\t}\n\tflag = true;\n\tcout << ans << endl;\n      }\n\n      for(int i=0;i<4;i++){\n\tif(i == (s.dir + 2) % 4) continue;\n\n\tint dx,dy;\n\tfor(int j=1;j<=max(H,W);j++){\n\t  dx = s.x + tx[i] * j;\n\t  dy = s.y + ty[i] * j;\n\t  if(dx < 0 || dy < 0 || dx >= W || dy >= H ) continue;\n\t  if(dic[P(dx,dy)] == -1) continue;\n\t  \n\t  if(s.remaining & (1<<dic[P(dx,dy)])){\n\t    int next = s.remaining & ~(1<<dic[P(s.x,s.y)]);\n\t    vector<char> next_route = s.route;\n\t    next_route.push_back(i);\n\t    que.push(State(dx,dy,i,next,s.cost+1,next_route));\n\t    break;\n\t  }\n\t}\n      }\n    }\n\n    if(!flag){\n      cout << \"hogehoge\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int dh[]={-1,1,0,0};\nconst int dw[]={0,0,-1,1};\nconst string com=\"UDLR\";\nconst int rev[]={1,0,3,2};\nint h,w;\n\nbool isRange(int hp,int wp){\n    return 0<=hp && hp<h && 0<=wp && wp<w;\n}\nstring res;\nbool dfs(int hp,int wp,int dir,vector<string>& c,int cnt){\n    if(cnt==0) return true;\n    for(int d=0;d<4;d++){\n        if(dir==rev[d]) continue;\n        int thp=hp,twp=wp;\n        while(isRange(thp,twp)){\n            if(c[thp][twp]=='o'){\n                c[thp][twp]='.';\n                if(dfs(thp,twp,d,c,cnt-1)){\n                    res+=com[d];\n                    return true;\n                }\n                c[thp][twp]='o';\n                break;\n            }\n            thp+=dh[d],twp+=dw[d];\n        }\n    }\n    return false;\n}\nint main(){\n    cin>>h>>w;\n    vector<string> c(h);\n    for(int i=0;i<h;i++) cin>>c[i];\n\n    int cnt=0;\n    int hp=-1,wp=-1,dir=-1;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='o') cnt++;\n            else if(c[i][j]!='.'){\n                for(int k=0;k<4;k++){\n                    if(com[k]==c[i][j]){\n                        hp=i,wp=j;\n                        dir=k;\n                        c[i][j]='.';\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    dfs(hp,wp,dir,c,cnt);\n    reverse(res.begin(),res.end());\n    cout<<res<<endl;    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nchar table[10][11];\nint H,W;\nvector<char> ret;\nint rem;\nvoid search(int x, int y, int state){\n\tif(rem==0){\n\t\tfor(auto item:ret){\n\t\t\tcout << item;\n\t\t}\n\t\tcout << endl;\n\t\texit(0);\n\t}\n\tint dx[]={0,1,0,-1};\n\tint dy[]={1,0,-1,0};\n\tchar ng[]={'L','U','R','D'};\n\tchar dir[]={'R','D','L','U'};\n\ttable[x][y]='.';\n\tfor(int i=0;i<4;i++){\n\t\tif(state==ng[i])continue;\n\t\tint p=x+dx[i];\n\t\tint q=y+dy[i];\n\t\twhile(0<=p&&p<H&&0<=q&&q<W){\n\t\t\tif(table[p][q]=='o'){\n\t\t\t\trem--;\n\t\t\t\tret.push_back(dir[i]);\n\t\t\t\tsearch(p,q,dir[i]);\n\t\t\t\tret.pop_back();\n\t\t\t\trem++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp+=dx[i];\n\t\t\tq+=dy[i];\n\t\t}\n\t}\n\ttable[x][y]='o';\n}\nint main() {\n\tcin >> H >> W;\n\tchar state=0;\n\tint x=0,y=0;\n\tfor(int i=0;i<H;i++){\n\t\tcin >> table[i];\n\t\tfor(int j=0;j<W;j++){\n\t\t\tswitch(table[i][j]){\n\t\t\t\tcase '.':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\trem++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=j;\n\t\t\t\t\tstate=table[i][j];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsearch(x,y,state);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n\n\nint H,W;\nchar c[10][10];\nint gr[10][10];\n\nstring dir = \"LURD\";\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\nint usd[32];\n\nint getIndex(int x,int y,int dx,int dy){\n\tx += dx;\n\ty += dy;\n\twhile( !(x < 0 || y < 0 || x >= W || y >= H) ){\n\t\tif( gr[y][x] != -1 && usd[gr[y][x]] == 0 ){\n\t\t\treturn gr[y][x];\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\t//cout << x << \" \" << y << \"(\" << dx << \" \" << dy << \")\" << endl;\n\treturn -1;\n}\nint kx[32];\nint ky[32];\nint done2[32];\nint test(int g,int d){\n\tif( done2[g]++ ) return 0;\n\tint ans = 1;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( i == 2 ) continue;\n\t\tint p = getIndex(kx[g],ky[g],dx[(d+i)&3],dy[(d+i)&3]);\n\t\t//cout << g << \" \" << dir[(d+i)&3] << \" \" << p << endl;\n\t\tif( p == -1 ) continue;\n\t\tans += test(p,(d+i)&3);\n\t}\n\treturn ans;\n}\nchar doit[32];\nint cnt = 0;\n\nint dfs(int g,int d,int r){\n\tif( r == 1 ){\n\t\tcout << doit << endl;\n\t\texit(0);\n\t}\n\tmemset(done2,0,sizeof(done2));\n\tint w = test(g,d);\n\t/*if( w != r ){\n\t\treturn 0;\n\t}*/\n\tusd[g] = 1;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tdoit[cnt-r] = dir[(d+i)&3];\n\t\tif( i == 2 ) continue;\n\t\tint p = getIndex(kx[g],ky[g],dx[(d+i)&3],dy[(d+i)&3]);\n\t\tif( p == -1 ) continue;\n\t\tdfs(p,(d+i)&3,r-1);\n\t}\n\tusd[g] = 0;\n}\nint main(){\n\tmemset(gr,-1,sizeof(gr));\n\tcin >> H >> W;\n\tint sd,sp;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] != '.' ){\n\t\t\t\tkx[cnt] = j;\n\t\t\t\tky[cnt] = i;\t\t\t\t\n\t\t\t\tgr[i][j] = cnt++;\n\t\t\t\t\n\t\t\t\tif( c[i][j] != 'o' ){\n\t\t\t\t\tsd = dir.find(c[i][j]);\n\t\t\t\t\tsp = cnt-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sp,sd,cnt);\n\twhile(1){}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint w, h;\nbool vis[11][11];\nchar a[11][11];\nstring res;\nmap<char, int> mpp;\nchar cdir[4] = {'U', 'R', 'D', 'L'};\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {-1, 0, 1, 0};\n\nbool dfs(int p, int q, int cnt, char dir, string str)\n{\n  if(cnt == 0){\n    res = str;\n    return true;\n  }\n\n  int t = mpp[dir], dx, dy;\n  bool f;\n  for(int i = 0; i < 4; ++i){\n    if(i == t) continue;\n    f = false;\n    dx = q+xdir[i];\n    dy = p+ydir[i];\n    while(0 <= dx && dx < w && 0 <= dy && dy < h){\n      if(a[dy][dx] == 'o' && vis[dy][dx]){\n\tf = true;\n\tbreak;\n      }\n\n      dx += xdir[i];\n      dy += ydir[i];\n    }\n    if(f){\n      vis[p][q] = false;\n      if(dfs(dy, dx, cnt-1, cdir[i], str+cdir[i])) return true;\n      vis[p][q] = true;\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  int s, t, cnt;\n  char dir;\n\n  mpp['U'] = 2;\n  mpp['R'] = 3;\n  mpp['D'] = 0;\n  mpp['L'] = 1;\n\n  while(cin>>h>>w && h+w){\n    res = \"\";\n    cnt = 0;\n    fill(&vis[0][0], &vis[h][0], true);\n\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j){\n\tcin >> a[i][j];\n\tif(a[i][j] == 'o') ++cnt;\n\telse if(a[i][j] != '.'){\n\t  dir = a[i][j];\n\t  s = i;\n\t  t = j;\n\t}\n      }\n\n    vis[s][t] = false;\n    dfs(s, t, cnt, dir, \"\");\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,sx,sy,m;\nint d[256],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nchar c[10][10],sc,nc[4]={'U','R','D','L'};\nstring ans;\n\nbool check(int x,int y){\n  int res=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(c[i][j]=='o'&&x!=j&&y!=j){\n\tint f=0;\n\tfor(int k=j+1;k<w;k++)\n\t  if(c[k][j]=='o'){f++;break;}\n\tfor(int k=j-1;k>=0;k--)\n\t  if(c[k][j]=='o'){f++;break;}\n\tfor(int k=i+1;k<h;k++)\n\t  if(c[i][k]=='o'){f++;break;}\n\tfor(int k=j-1;k>=0;k--)\n\t  if(c[i][k]=='o'){f++;break;}\n\tif(f<2)res++;\n      }\n  return res>1;\n}\n\nbool dfs(int x,int y,char r,int cnt){\n  if(cnt==m){return 1;}\n  //if(check(x,y))return 0;\n  bool res=0;\n  c[y][x]='.';\n  for(int i=0;i<3;i++){\n    int p=(d[r]+i)%4,nx=x,ny=y;\n    while(0<=nx&&nx<w&&0<=ny&&ny<h&&c[ny][nx]!='o')\n      nx+=dx[p],ny+=dy[p];\n    if(0<=nx&&nx<w&&0<=ny&&ny<h)\n      if(dfs(nx,ny,nc[p],cnt+1))ans=nc[p]+ans,res=1;\n  }\n  c[y][x]='o';\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  d['U']=3,d['R']=0,d['D']=1,d['L']=2;\n  for(int i=h-1;i>=0;i--)\n    for(int j=0;j<w;j++){\n      cin>>c[i][j];\n      if(c[i][j]=='o')m++;\n      else if(c[i][j]!='.')sx=j,sy=i,sc=c[i][j];\n    }\n  dfs(sx,sy,sc,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int H, W;\n    vector<string> F;\n    void input() {\n        cin >> H >> W;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) cin >> F[i];\n    }\n\n    struct Point {\n        int y, x;\n        Point(int y = 0, int x = 0) : y(y), x(x) {}\n        bool operator<(const Point& p) const {\n            if (x == p.x) return y < p.y;\n            return x < p.x;\n        }\n    };\n    ostream& operator<<(ostream& os, const Point& p) {\n        return os << \"Point(\" << p.y << \" \" << p.x << \")\";\n    }\n\n    const string s = \"URDL\";\n    const int dy[] = {-1, 0, 1, 0},\n              dx[] = {0, 1, 0, -1};\n\n    int N;\n    map<int, Point> M;\n    map<Point, int> R;\n    int sindex;\n    void init() {\n        M.clear();\n        R.clear();\n        int c = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == 'o') {\n                    M[c] = Point(i, j);\n                    R[Point(i, j)] = c;\n                    c++;\n                } else if (s.find(F[i][j]) != string::npos) {\n                    sindex = c;\n                    M[c] = Point(i, j);\n                    R[Point(i, j)] = c;\n                    c++;\n                }\n            }\n        }\n        N = c;\n    }\n\n    ostream& operator<<(ostream& os, const vector<char>& s) {\n        for (int i = 0; i < s.size(); i++) {\n            os << s[i];\n        }\n        return os;\n    }\n\n    void dfs(int index, int dir, int used, vector<char>& path) {\n        if (used == (1 << N) - 1) {\n            for (int i = 0; i < path.size(); i++) {\n                cout << path[i];\n            }\n            cout << endl;\n            return;\n        }\n        int cy = M[index].y, cx = M[index].x;\n        for (int i = 0; i < 4; i++) {\n            if (i == (dir + 2) % 4) continue;\n            int ny = cy,\n                nx = cx;\n            int vy = dy[i],\n                vx = dx[i];\n            while (true) {\n                if (ny < 0 || ny >= H) break;\n                if (nx < 0 || nx >= W) break;\n                Point p(ny, nx);\n                if (F[ny][nx] == 'o' && (not (used & (1 << R[p])))) {\n                    int nindex = R[p];\n                    path.push_back(s[i]);\n                    dfs(nindex, i, used | (1 << nindex), path);\n                    path.pop_back();\n                    break;\n                }\n                ny += vy;\n                nx += vx;\n            }\n        }\n    }\n\n    void solve() {\n        init();\n        vector<char> path;\n        dfs(sindex, s.find(F[ M[sindex].y ][ M[sindex].x ]), 1 << sindex, path);\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 11;\nconst int dx[] = {0,0,-1,1};\nconst int dy[] = {-1,1,0,0};\n\nbool flag;\nvector<int> ans;\n\nvoid dfs(int u,int v,int dir,set<int>* h,set<int>* w,vector<int>& route,int rem)\n{\n    if(flag){\n        return;\n    }\n    if(rem == 0){\n        ans = route;\n        flag = true;\n        return;\n    }\n    int dame = (dir%2 == 0)?dir+1:dir-1;\n    rep(i,4){\n        if(flag){\n            return;\n        }\n        if(i != dame){\n            if(i == 0){\n                auto it = lower_bound(all(h[v]),u);\n                if(it != h[v].begin()){\n                    it--;\n                    int hoge = *it;\n                    h[v].erase(hoge);\n                    w[hoge].erase(v);\n                    route.pb(0);\n                    dfs(hoge,v,0,h,w,route,rem-1);\n                    h[v].insert(hoge);\n                    w[hoge].insert(v);\n                    route.pop_back();\n                }\n            }\n            if(i == 1){\n                auto it = upper_bound(all(h[v]),u);\n                if(it != h[v].end()){\n                    int hoge = *it;\n                    h[v].erase(hoge);\n                    w[hoge].erase(v);\n                    route.pb(1);\n                    dfs(hoge,v,1,h,w,route,rem-1);\n                    h[v].insert(hoge);\n                    w[hoge].insert(v);\n                    route.pop_back();\n                }\n            }\n            if(i == 2){\n                auto it = lower_bound(all(w[u]),v);\n                if(it != w[u].begin()){\n                    it--;\n                    int hoge = *it;\n                    w[u].erase(hoge);\n                    h[hoge].erase(u);\n                    route.pb(2);\n                    dfs(u,hoge,2,h,w,route,rem-1);\n                    w[u].insert(hoge);\n                    h[hoge].insert(u);\n                    route.pop_back();\n                }\n            }\n            if(i == 3){\n                auto it = upper_bound(all(w[u]),v);\n                if(it != w[u].end()){\n                    int hoge = *it;\n                    w[u].erase(hoge);\n                    h[hoge].erase(u);\n                    route.pb(3);\n                    dfs(u,hoge,3,h,w,route,rem-1);\n                    w[u].insert(hoge);\n                    h[hoge].insert(u);\n                    route.pop_back();\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n,m;\n    set<int> h[MAX_N];\n    set<int> w[MAX_N];\n    vector<int> v;\n    cin >> n >> m;\n    int sx,sy,dir;\n    int cnt  = 0;\n    flag = false;\n    rep(i,n){\n        string s;\n        cin >> s;\n        rep(j,s.length()){\n            if(s[j] == 'o'){\n                h[i].insert(j);\n                w[j].insert(i);\n                cnt++;\n            }else if(s[j] == 'U'){\n                sx = i,sy = j,dir = 0;\n            }else if(s[j] == 'D'){\n                sx = i,sy = j,dir = 1;\n            }else if(s[j] == 'L'){\n                sx = i,sy = j,dir = 2;\n            }else if(s[j] == 'R'){\n                sx = i,sy = j,dir = 3;\n            }\n        }\n    }\n    char d[] = {'U','D','L','R'};\n    dfs(sx,sy,dir,w,h,v,cnt);\n    rep(i,ans.size()){\n        cout << d[ans[i]];\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nint n, m;\nchar g[12][12];\nchar ans[35];\nint LeafNum;\nint endFlag;\n\nvoid BFS(int x, int y, int leaf_num, char dir)\n{\n    //printf(\"BFS : %d %d %d %d\\n\", x,y,leaf_num,dir);\n    if(endFlag == 1)\n        return;\n\n    ans[LeafNum - leaf_num] = dir;\n\n    if(leaf_num == 0)\n    {\n        endFlag = true;\n        return;\n    }\n\n    //Up\n    if(dir != 'D')\n        for(int i = x - 1; i >= 0; i--)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                BFS(i, y, leaf_num - 1, 'U');\n\n                g[i][y] = 'o';\n            }\n\n    //Down\n    if(dir != 'U')\n        for(int i = x + 1; i < n; i++)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                BFS(i, y, leaf_num - 1, 'D');\n\n                g[i][y] = 'o';\n            }\n\n    //Left\n    if(dir != 'R')\n        for(int i = y - 1; i >= 0; i--)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                BFS(x, i, leaf_num - 1, 'L');\n\n                g[x][i] = 'o';\n            }\n\n    //Right\n    if(dir != 'L')\n        for(int i = y + 1; i < m; i++)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                BFS(x, i, leaf_num - 1, 'R');\n\n                g[x][i] = 'o';\n            }\n\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n\n    int x, y;\n    int leaf_num = 0;\n    char dir;// 0 is up, 1 is left, 2 is down, 3 is right\n\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", g[i]);\n        for(int j = 0; j < m; j++)\n        {\n            if(g[i][j] == 'U' || g[i][j] == 'R' || g[i][j] == 'L' || g[i][j] == 'D')\n            {\n                x = i;\n                y = j;\n\n                dir = g[i][j];\n            }\n            if(g[i][j] == 'o')\n                leaf_num++;\n        }\n    }\n\n    g[x][y] = '.';\n    LeafNum = leaf_num;\n    endFlag = 0;\n\n    BFS(x, y, leaf_num, dir);\n\n    //printf(\"Leaf : %d\\n\", LeafNum);\n    for (int i = 1; i <= LeafNum; ++i)\n    {\n        printf(\"%c\", ans[i]);\n    }\n    printf(\"\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[10][11];\n\nint num;\nchar ans[31];\nbool dfs(int i,int x,int y,int dir){\n\tif(i==num) return true;\n\n\tB[y][x]='.';\n\trep(k,4) if(k!=(dir+2)&3) {\n\t\tbool ok=false;\n\t\tint xx=x,yy=y;\n\t\twhile(0<=xx && xx<w && 0<=yy && yy<h){\n\t\t\tif(B[yy][xx]=='o'){ ok=true; break; }\n\t\t\txx+=dx[k];\n\t\t\tyy+=dy[k];\n\t\t}\n\t\tif(ok){\n\t\t\tans[i]=\"RULD\"[k];\n\t\t\tif(dfs(i+1,xx,yy,k)) return true;\n\t\t}\n\t}\n\tB[y][x]='o';\n\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&h,&w);\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tint sx,sy;\n\trep(i,h) rep(j,w) {\n\t\tif(B[i][j]=='o') num++;\n\t\tif(B[i][j]!='o' && B[i][j]!='.') sx=j, sy=i;\n\t}\n\n\tint f[128];\n\tf['R']=0;\n\tf['U']=1;\n\tf['L']=2;\n\tf['D']=3;\n\tdfs(0,sx,sy,f[B[sy][sx]]);\n\n\tputs(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 11;\nconst int MAXW = 11;\nconst string D = \"RDLU\";\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint H, W, N;\nchar G[MAXH][MAXW];\nstring ans;\n\nbool isin(int i, int j) {\n  return ( 0 <= i && i < H &&\n           0 <= j && j < W );\n}\n\nbool dfs(int i, int j, int d, int depth) {\n  if(depth == N) {\n    ans = \"\";\n    return true;\n  }\n  for(int k = 0; k < 4; ++k) {\n    if((k+2)%4 == d) continue;\n    int pi = i + di[k];\n    int pj = j + dj[k];\n    while(isin(pi, pj) && G[pi][pj] != 'o') {\n      pi += di[k];\n      pj += dj[k];\n    }\n    if(!isin(pi, pj)) continue;\n    G[pi][pj] = '.';\n    if(dfs(pi, pj, k, depth + 1)) {\n      ans = D.substr(k, 1) + ans;\n      return true;\n    }\n    G[pi][pj] = 'o';\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> H >> W) {\n    N = 0;\n    int si, sj, sd;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        int k = D.find(G[i][j]);\n        if(k != string::npos) {\n          G[i][j] = '.';\n          si = i;\n          sj = j;\n          sd = k;\n        }\n        if(G[i][j] == 'o') ++N;\n      }\n    }\n    dfs(si, sj, sd, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nint h, w;\nint g[10][10];\nint cnt;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\nconst char *toS = \"URDL\";\n\nchar ans[50];\nint ansp;\n\nvoid solve(int x, int y, int d){\n  if(ansp == cnt){\n    ans[ansp] = '\\0';\n    throw 0;\n  }else{\n    REP(i,4) if((d - i + 4) % 4 != 2){\n      int xx = x + _dx[i];\n      int yy = y + _dy[i];\n\n      while(ISIN(xx, yy, w, h)){\n        if(g[yy][xx] == 1){\n          ans[ansp++] = toS[i];\n          g[yy][xx] = 0;\n          solve(xx, yy, i);\n          g[yy][xx] = 1;\n          ansp--;\n          break;\n        }\n        xx += _dx[i];\n        yy += _dy[i];\n      }\n    }\n  }\n}\n\nint main(){\n  int sx, sy;\n  int sd;\n\n  scanf(\"%d%d\", &h, &w);\n\n  REP(i,h){\n    char buff[20];\n    scanf(\"%s\", buff);\n    REP(j,w){\n      if(buff[j] == '.' || buff[j] == 'o'){\n        g[i][j] = (buff[j] == '.' ? 0 : 1);\n        if(g[i][j] == 1) cnt++;\n      }else{\n        g[i][j] = 0;\n        sx = j; sy = i;\n        switch(buff[j]){\n        case 'U': sd = 0; break;\n        case 'D': sd = 2; break;\n        case 'R': sd = 1; break;\n        case 'L': sd = 3; break;\n        }\n      }\n    }\n  }\n\n  try{\n    solve(sx, sy, sd);\n  }catch(int e){\n    puts(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[10][11];\n\nint num;\nchar ans[31];\nbool dfs(int i,int x,int y,int dir){\n\tif(i==num) return true;\n\n\tB[y][x]='.';\n\trep(k,4) if(k!=((dir+2)&3)) {\n\t\tbool ok=false;\n\t\tint xx=x,yy=y;\n\t\twhile(0<=xx && xx<w && 0<=yy && yy<h){\n\t\t\tif(B[yy][xx]=='o'){ ok=true; break; }\n\t\t\txx+=dx[k];\n\t\t\tyy+=dy[k];\n\t\t}\n\t\tif(ok){\n\t\t\tans[i]=\"RULD\"[k];\n\t\t\tif(dfs(i+1,xx,yy,k)) return true;\n\t\t}\n\t}\n\tB[y][x]='o';\n\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&h,&w);\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tint sx,sy;\n\trep(i,h) rep(j,w) {\n\t\tif(B[i][j]=='o') num++;\n\t\tif(B[i][j]!='o' && B[i][j]!='.') sx=j, sy=i;\n\t}\n\n\tint f[128];\n\tf['R']=0;\n\tf['U']=1;\n\tf['L']=2;\n\tf['D']=3;\n\tdfs(0,sx,sy,f[B[sy][sx]]);\n\n\tputs(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\nusing namespace std;\nint d[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nint h,w;\nstruct pos\n{\n    int r;\n    int x,y,d,N;\n    char s[50],mp[15][15];\n};\nqueue<pos>q;\nint getdirection(char s)\n{\n    if(s=='U') return 1;\n    if(s=='D') return 0;\n    if(s=='R') return 2;\n    if(s=='L') return 3;\n}\nbool isin(int x,int y)\n{\n    if(x<0||x>=h) return false;\n    if(y<0||y>=w) return false;\n    return true;\n}\nchar getmove(int sx,int sy,int ex,int ey)\n{\n    if(sx==ex)\n    {\n        if(sy<ey) return 'R';\n        if(sy>ey) return 'L';\n\n    }\n    else\n    {\n        if(sx<ex) return 'D';\n        if(sx>ex) return 'U';\n    }\n}\nvoid bfs()\n{\n    bool f=false;\n    while(!q.empty()&&f==false)\n    {\n        struct pos t=q.front();q.pop();\n        for(int i=0;i<4;i++)\n        {\n            if(i==t.d) continue;\n            struct pos tp=t;\n            bool ok=false;\n            int dx=tp.x+d[i][0],dy=tp.y+d[i][1];\n            while(isin(dx,dy))\n            {\n                if(tp.mp[dx][dy]=='o')\n                {\n                    ok=true;\n                    break;\n                }\n                dx+=d[i][0],dy+=d[i][1];\n            }\n            if(ok)\n            {\n                tp.r=t.r-1;\n                tp.mp[dx][dy]='.';\n                tp.s[tp.N++]=getmove(t.x,t.y,dx,dy);\n                tp.x=dx;tp.y=dy;\n                tp.d=getdirection(tp.s[tp.N-1]);\n                q.push(tp);\n            }\n        }\n        if(t.r==0)\n        {\n            f=true;\n            for(int i=0;i<t.N;i++) printf(\"%c\",t.s[i]);\n            printf(\"\\n\");\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&h,&w);getchar();\n    struct pos t;\n    for(int i=0;i<h;i++) gets(t.mp[i]);\n    t.N=t.r=0;\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n        {\n            if(t.mp[i][j]=='o') t.r++;\n            if(t.mp[i][j]!='.'&&t.mp[i][j]!='o')\n            {\n                t.d=getdirection(t.mp[i][j]);\n                t.x=i;t.y=j;\n            }\n        }\n    t.mp[t.x][t.y]='.';\n    while(!q.empty())q.pop();\n    q.push(t);\n    bfs();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For(i, 0, n)\n#define rrep(i, n) rFor(i, n, 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint h, w, num;\nchar c[15][15];\nstring ans;\n\nbool in(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nbool dfs(int x, int y, int dir, int cnt){\n    if(cnt == 1){\n        cout << ans << \"\\n\";\n        return true;\n    }\n    for(int i = -1; i <= 1; ++i){\n        int nd = (dir + i + 4) % 4;\n        int nx = x + dx[nd], ny = y + dy[nd];\n        while(in(nx, ny) && c[nx][ny] == '.'){\n            nx += dx[nd]; ny += dy[nd];\n        }\n        if(in(nx, ny)){\n            c[x][y] = '.';\n            if(nd == 0) ans += 'R';\n            if(nd == 1) ans += 'D';\n            if(nd == 2) ans += 'L';\n            if(nd == 3) ans += 'U';\n            if(dfs(nx, ny, nd, cnt - 1)) return true;\n            c[x][y] = 'o';\n            ans.pop_back();\n        }\n    }\n    return false;\n}\n\nint main(){\n    scanf(\"%d%d\", &h, &w);\n    int sx, sy, dir;\n    rep(i, h)rep(j, w){\n        scanf(\" %c\", &c[i][j]);\n        num += (c[i][j] != '.');\n        if(c[i][j] == 'L') sx = i, sy = j, dir = 2;\n        if(c[i][j] == 'R') sx = i, sy = j, dir = 0;\n        if(c[i][j] == 'U') sx = i, sy = j, dir = 3;\n        if(c[i][j] == 'D') sx = i, sy = j, dir = 1;\n    }\n    dfs(sx, sy, dir, num);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n\n\nint H,W;\nchar c[10][10];\nint gr[10][10];\n\nstring dir = \"LURD\";\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\nint usd[32];\n\nint getIndex(int x,int y,int dx,int dy){\n\tx += dx;\n\ty += dy;\n\twhile( !(x < 0 || y < 0 || x >= W || y >= H) ){\n\t\tif( gr[y][x] != -1 && usd[gr[y][x]] == 0 ){\n\t\t\treturn gr[y][x];\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\t//cout << x << \" \" << y << \"(\" << dx << \" \" << dy << \")\" << endl;\n\treturn -1;\n}\nint kx[32];\nint ky[32];\nint done2[32];\nint test(int g,int d){\n\tif( done2[g]++ ) return 0;\n\tint ans = 1;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( i == 2 ) continue;\n\t\tint p = getIndex(kx[g],ky[g],dx[(d+i)&3],dy[(d+i)&3]);\n\t\t//cout << g << \" \" << dir[(d+i)&3] << \" \" << p << endl;\n\t\tif( p == -1 ) continue;\n\t\tans += test(p,(d+i)&3);\n\t}\n\treturn ans;\n}\nchar doit[32];\nint cnt = 0;\n\nint dfs(int g,int d,int r){\n\tif( r == 1 ){\n\t\tcout << doit << endl;\n\t\texit(0);\n\t}\n\tmemset(done2,0,sizeof(done2));\n\tint w = test(g,d);\n\tif( w != r ){\n\t\treturn 0;\n\t}\n\tusd[g] = 1;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tdoit[cnt-r] = dir[(d+i)&3];\n\t\tif( i == 2 ) continue;\n\t\tint p = getIndex(kx[g],ky[g],dx[(d+i)&3],dy[(d+i)&3]);\n\t\tif( p == -1 ) continue;\n\t\tdfs(p,(d+i)&3,r-1);\n\t}\n\tusd[g] = 0;\n}\nint main(){\n\tmemset(gr,-1,sizeof(gr));\n\tcin >> H >> W;\n\tint sd,sp;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> c[i][j];\n\t\t\tif( c[i][j] != '.' ){\n\t\t\t\tkx[cnt] = j;\n\t\t\t\tky[cnt] = i;\t\t\t\t\n\t\t\t\tgr[i][j] = cnt++;\n\t\t\t\t\n\t\t\t\tif( c[i][j] != 'o' ){\n\t\t\t\t\tsd = dir.find(c[i][j]);\n\t\t\t\t\tsp = cnt-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sp,sd,cnt);\n\twhile(1){}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring temp = \"ULDR\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, -1, 0, 1};\n\nint H, W;\nstring S[10];\n\nbool isin(int x, int y)\n{\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nstring rec(int bit, int x, int y, int curr)\n{\n  string ret = \"\";\n  for(int i = -1; i <= 1; i++) {\n    int dd = (curr + i + 4) % 4;\n    int ny = y + vy[dd], nx = x + vx[dd];\n    while(isin(nx, ny) && (S[ny][nx] > 30 || (bit >> S[ny][nx]) & 1)) ny += vy[dd], nx += vx[dd];\n    if(!isin(nx, ny)) continue;\n    string res = string(1, temp[dd]) + rec(bit | (1 << S[ny][nx]), nx, ny, dd);\n    if(res.size() > ret.size()) ret = res;\n  }\n  return (ret);\n}\n\nint main()\n{\n\n\n  vector< int > g[30];\n  int sx, sy, idx = 0;\n\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == 'o') S[i][j] = idx++;\n      else if(S[i][j] != '.') sx = j, sy = i;\n    }\n  }\n  cout << rec(0, sx, sy, temp.find(S[sy][sx])) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,h,sum,dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nstring s[11],t;\nmap<int,char>m;\nvoid dfs(int y,int x,int d,char p){\n  if(d==sum){\n    cout<<t<<endl;\n    exit(0);\n  }\n  else{\n    char a=p;\n    s[y][y]='.';\n    r(i,4){\n      int yy=y,xx=x;\n      if(a=='U'&&i==2||a=='D'&&i==0||a=='R'&&i==3||a=='L'&&i==1)continue;\n      r(j,50){\n        yy+=dy[i],xx+=dx[i];\n        if(yy>=h||xx>=w||xx<0||yy<0)break;\n        if(s[yy][xx]=='o'){\n          t+=m[i];\n          dfs(yy,xx,d+1,m[i]);\n          t.erase(t.size()-1);\n        }\n      }\n    }\n    s[y][x]='o';\n  }\n}\nint main(){\n  m[0]='U';m[1]='R';m[2]='D';m[3]='L';\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='o')sum++;\n  r(i,h)r(j,w)if(s[i][j]!='.'&&s[i][j]!='o')dfs(i,j,0,s[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst int tx[] = {+0,+1,+0,-1};\nconst int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint init_dic(int x,int y,\n\t    map<P,int>& dic){\n  if(dic.find(P(x,y)) == dic.end()){\n    int idx = dic.size();\n    dic[P(x,y)] = idx;\n  }\n  return dic[P(x,y)];\n}\n\nvoid fill_dic(int W,int H,map<P,int>& dic){\n  for(int x=0;x<=W;x++){\n    for(int y=0;y<=H;y++){\n      if(dic.find(P(x,y)) == dic.end()){\n\tdic[P(x,y)] = -1;\n      }\n    }\n  }\n}\n\nclass State{\npublic:\n  int x;\n  int y;\n  int dir;\n  int remaining;\n  int cost;\n  vector<char> route;\n  State(int _x,int _y,int _dir,int _remaining,int _cost,const vector<char>& _r)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost),route(_r) {}\n  State(int _x,int _y,int _dir,int _remaining,int _cost)\n    : x(_x),y(_y),dir(_dir),remaining(_remaining),cost(_cost) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(~scanf(\"%d %d\",&H,&W)){\n    char stage[101][101];\n    int sx,sy;\n    int dir;\n    int init_state=0;\n    map<P,int> dic;\n\n    for(int y=0;y<H;y++){\n      char buf[101];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = buf[x];\n\tif(buf[x] == 'U' || buf[x] == 'R'\n\t   || buf[x] == 'D' || buf[x] == 'L'){\n\t  sx = x;\n\t  sy = y;\n\t  const char dirs[4] = {'U','R','D','L'};\n\t  for(int i=0;i<4;i++){\n\t    if(dirs[i] == buf[x]){\n\t      dir = i;\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(buf[x] == 'o'){\n\t  init_state |= (1<<init_dic(x,y,dic));\n\t}\n      }\n    }\n    \n    fill_dic(W,H,dic);\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,dir,init_state,0));\n\n    set<int> visited[101][101][4];\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(visited[s.x][s.y][s.dir].count(s.remaining) > 0) continue;\n      visited[s.x][s.y][s.dir].insert(s.remaining);\n\n      if(__builtin_popcount(s.remaining) == 1){\n\tconst char dirs[4] = {'U','R','D','L'};\n\tstring ans = \"\";\n\tfor(int i=0; i<s.route.size(); i++){\n\t  ans += dirs[s.route[i]];\n\t}\n\tcout << ans << endl;\n      }\n\n      for(int i=0;i<4;i++){\n\tif(i == (s.dir + 2) % 4) continue;\n\n\tint dx,dy;\n\tfor(int j=1;j<=max(H,W);j++){\n\t  dx = s.x + tx[i] * j;\n\t  dy = s.y + ty[i] * j;\n\t  if(dx < 0 || dy < 0 || dx >= W || dy >= H ) continue;\n\t  if(dic[P(dx,dy)] == -1) continue;\n\t  \n\t  if(s.remaining & (1<<dic[P(dx,dy)])){\n\t    int next = s.remaining & ~(1<<dic[P(s.x,s.y)]);\n\t    vector<char> next_route = s.route;\n\t    next_route.push_back(i);\n\t    que.push(State(dx,dy,i,next,s.cost+1,next_route));\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nint n, m;\nchar g[12][12];\nchar ans[35];\nint LeafNum;\nint endFlag;\n\nvoid BFS(int x, int y, int leaf_num, int dir)\n{\n    //int now_x = x, now_y = y;\n    //int now_dir = dir;\n    //printf(\"BFS : %d %d %d %d\\n\", x,y,leaf_num,dir);\n    if(endFlag)\n        return;\n\n    if(leaf_num == 0)\n    {\n        endFlag = true;\n        return;\n    }\n\n    //Up\n    if(dir != 2)\n        for(int i = x; i >= 0; i--)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                ans[LeafNum - leaf_num] = 'U';\n                BFS(i, y, leaf_num - 1, 0);\n\n                g[i][y] = 'o';\n            }\n\n    //Down\n    if(dir != 0)\n        for(int i = x; i < n; i++)\n            if(g[i][y] == 'o')\n            {\n                g[i][y] = '.';\n                ans[LeafNum - leaf_num] = 'D';\n                BFS(i, y, leaf_num - 1, 2);\n\n                g[i][y] = 'o';\n            }\n\n    //Left\n    if(dir != 3)\n        for(int i = y; i >= 0; i--)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                ans[LeafNum - leaf_num] = 'L';\n                BFS(x, i, leaf_num - 1, 1);\n\n                g[x][i] = 'o';\n            }\n\n    //Right\n    if(dir != 1)\n        for(int i = y; i < m; i++)\n            if(g[x][i] == 'o')\n            {\n                g[x][i] = '.';\n                ans[LeafNum - leaf_num] = 'R';\n                BFS(x, i, leaf_num - 1, 3);\n\n                g[x][i] = 'o';\n            }\n\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n\n    int x, y;\n    int leaf_num = 0;\n    int dir = 0;// 0 is up, 1 is left, 2 is down, 3 is right\n\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", g[i]);\n        for(int j = 0; j < m; j++)\n        {\n            if(g[i][j] == 'U' || g[i][j] == 'R' || g[i][j] == 'L' || g[i][j] == 'D')\n            {\n                x = i;\n                y = j;\n                if(g[i][j] == 'U'){ dir = 0; }\n                if(g[i][j] == 'L'){ dir = 1; }\n                if(g[i][j] == 'D'){ dir = 2; }\n                if(g[i][j] == 'R'){ dir = 3; }\n            }\n            if(g[i][j] == 'o')\n                leaf_num++;\n        }\n    }\n\n    g[x][y] = '.';\n    LeafNum = leaf_num;\n    endFlag = 0;\n\n    BFS(x, y, leaf_num, dir);\n\n    //printf(\"Leaf : %d\\n\", LeafNum);\n    for (int i = 0; i < LeafNum; ++i)\n    {\n        printf(\"%c\", ans[i]);\n    }\n    printf(\"\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool dfs(vs& grid,int i,int j,int d,int rest,string& res)\n{\n\tif(rest==1) return true;\n\tgrid[i][j]='.';\n\t\n\tint h=grid.size(),w=grid[0].size();\n\trep(k,4) if(k!=(d^1)){\n\t\tconst int di[]={-1,1,0,0},dj[]={0,0,-1,1};\n\t\tfor(int ni=i,nj=j;0<=ni && ni<h && 0<=nj && nj<w;ni+=di[k],nj+=dj[k])\n\t\t\tif(grid[ni][nj]=='o'){\n\t\t\t\tres.push_back(\"UDLR\"[k]);\n\t\t\t\tif(dfs(grid,ni,nj,k,rest-1,res))\n\t\t\t\t\treturn true;\n\t\t\t\t//res.pop_back();\n\t\t\t\tres.erase(res.size()-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\t\n\tgrid[i][j]='o';\n\treturn false;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tint cnt=0;\n\t\trep(i,h) rep(j,w) cnt+=grid[i][j]!='.';\n\t\trep(i,h) rep(j,w) if(isupper(grid[i][j])){\n\t\t\tint d=string(\"UDLR\").find(grid[i][j]);\n\t\t\tgrid[i][j]='o';\n\t\t\tstring res;\n\t\t\tassert(dfs(grid,i,j,d,cnt,res));\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nchar ans[40];\nstring strdir = \"URDL\";\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint h,w;\nstring ba;\nbool solve(int y, int x, int dd, int c) {\n  if (c==0) return 1;\n  for (int i=-1;i<=1;++i) {\n    int d = (dd+i+4)%4;\n    int yy=y, xx=x;\n    while(1) {\n      yy+=dy[d];\n      xx+=dx[d];\n      if (yy<0||yy>=h||xx<0||xx>=w) break;\n      if (ba[yy*w+xx] == 'o') {\n        ba[yy*w+xx] = '.';\n        ans[c]=strdir[d];\n        if (solve(yy,xx,d,c-1)) return 1;\n        ba[yy*w+xx] = 'o';\n        break;\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  cin>>h>>w;\n  ba=\"\";\n  REP(i,h) {string s;cin>>s;ba+=s;}\n  int y,x,d;\n  int c=0;\n  REP(i,h) REP(j,w) {\n    REP(k,4) if (ba[i*w+j]==strdir[k]) y=i,x=j,d=k;\n    if (ba[i*w+j] == 'o') c++;\n  }\n  solve(y,x,d,c);\n  for (int i=c; i>0; --i) cout<<ans[i];cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 11;\n\nint H,W;\nchar m[MAX][MAX];\n\nstring res;\n\nclass P{\npublic:\n  int x,y,d;\n  P(int x,int y,int d):x(x),y(y),d(d){};\n  P(){};\n  bool operator==(const P &p)const{\n    return p.x == x && p.y == y && p.d == d;\n  }\n};\n\nchar conv[4] = {'U','R','D','L'};\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\n\nP no(-1,-1,-1);\nbool f;\n\nP func(P s){\n  \n  while(1){\n    if(m[s.y][s.x] == 'o')return s;\n    if(!(0 <= s.x && s.x < W))return no;\n    if(!(0 <= s.y && s.y < H))return no;\n    \n    s.x = s.x + dx[s.d];\n    s.y = s.y + dy[s.d];\n  }\n}\n\n\nvoid dfs(P s,int cnt){\n  P np;\n\n  if(cnt == 0){\n    f = true;\n    return;\n  }\n  \n  for(int i = 0 ; i < 4 ; i++){\n    if((s.d + 2)%4 == i)continue;\n    np = func(P(s.x + dx[i],s.y + dy[i],i));\n    if(np == no)continue;\n    m[np.y][np.x] = '.';\n    dfs(np,cnt-1);\n    m[np.y][np.x] = 'o';\n    if(f){\n      res += conv[np.d];\n      return;\n    }\n  }\n}\n\nint main(){\n  cin >> H >> W;\n  P s;\n  int cnt = 0;\n  f = false;\n\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> m[i][j];\n      if(m[i][j] == 'U')s = P(j,i,0);\n      else if(m[i][j] == 'R') s = P(j,i,1);\n      else if(m[i][j] == 'D') s = P(j,i,2);\n      else if(m[i][j] == 'L') s = P(j,i,3);\n      else if(m[i][j] == 'o') cnt++;\n    }\n  }\n  dfs(s,cnt);\n  reverse(res.begin(),res.end());\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 15\n\nint H,W;\nchar field[MAX][MAX];\nstring ans;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nconst char mark[] = {'U','R','D','L'};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint getDir(char ch){\n  if(ch == 'U') return 0;\n  if(ch == 'R') return 1;\n  if(ch == 'D') return 2;\n  if(ch == 'L') return 3;\n  return -1;\n}\n\nvoid solve(int y,int x,int dir,int cnt,string s){\n  if(cnt == 0){\n    ans = s;\n    return;\n  }\n\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x, ny = y;\n    if(dir == 0 && i == 2) continue;\n    if(dir == 1 && i == 3) continue;\n    if(dir == 2 && i == 0) continue;\n    if(dir == 3 && i == 1) continue;\n\n    while(inField(ny,nx)){\n      nx += dx[i];\n      ny += dy[i];\n      if(field[ny][nx] == 'o'){\n        field[ny][nx] = '.';\n        solve(ny,nx,i,cnt-1,s+mark[i]);\n        field[ny][nx] = 'o';\n        break;\n      }\n    }\n  }\n}\n\nint main(){\n  int x,y,dir,cnt = 0;\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n      int num = getDir(field[i][j]);\n      if(num != -1){\n        x = j, y = i; dir = num;\n      }else if(field[i][j] == 'o'){\n        cnt++;\n      }\n    }\n  }\n  field[y][x] = '.';\n  solve(y,x,dir,cnt,\"\");\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint h, w, s;\nchar pond[10][10];\nchar d[4] = { 'U','R','D','L' };\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nstring out;\nbool jump(int x,int y,int dir,int k) {\n\tif (k == s) {\n\t\treturn true;\n\t}\n\tfor (int i = -1; i <= 1; i++) {\n\t\tint dd = (dir + i + 4) % 4;\n\t\tint nx = x; int ny = y;\n\t\twhile (nx >= 0 && ny >= 0 && nx < h&&ny < w) {\n\t\t\tif (pond[nx][ny] == 'o') {\n\t\t\t\tpond[nx][ny] = '.';\n\t\t\t\tif (jump(nx, ny, dd, k + 1)) {\n\t\t\t\t\tout.push_back(d[dd]);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpond[nx][ny] = 'o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx += dx[dd]; ny += dy[dd];\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tcin >> h >> w;\n\tint x, y, dd;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> pond[i][j];\n\t\t\tif (pond[i][j] == 'o')s++;\n\t\t\telse if (pond[i][j] != '.') {\n\t\t\t\tx = i; y = j;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (d[k] == pond[i][j])dd = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tjump(x,y,dd,0);\n\treverse(out.begin(), out.end());\n\tcout << out << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<bitset>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 12\n\nusing namespace std;\n\nint h,w,sp,sdir;\nchar G[MAX][MAX];\nint dx[] = {+0,+1,+0,-1};\nint dy[] = {-1,+0,+1,+0};\nint leaf[MAX*MAX];\nint lpos[31],lindex;\nvector<int> move[31][4];\nint bitlist[31];\n\ninline int getDir(char c){\n  if(c == 'U')return 0;\n  if(c == 'R')return 1;\n  if(c == 'D')return 2;\n  return 3;\n}\n\ninline char getCDir(int i){\n  if(i == 0)return 'U';\n  if(i == 1)return 'R';\n  if(i == 2)return 'D';\n  return 'L';\n}\n\nvoid INIT(){\n\n  rep(y,h){\n    rep(x,w){\n      if(G[y][x] == '.')continue;\n\n      rep(k,4){\n      int nx = x, ny = y;\n\twhile(true){\n\t  nx += dx[k], ny += dy[k];\n\t  if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))break;\n\t  if(G[ny][nx] != '.'){\n\t    move[leaf[x+y*w]][k].push_back(leaf[nx+ny*w]); \n\t    bitlist[leaf[x+y*w]] |= (1<<leaf[nx+ny*w]);\n\t  }\n\t}\n      }\n    }\n  }\n\n}\n\nbool dfs(int cur,int dir,int used,deque<char>& deq){\n  //bitset<10> bt(used);\n  //cout << \"cur = \" << cur << \" \" << getCDir(dir) << \" \" << bt << endl;\n  if(used == (1<<lindex)-1){\n    rep(i,deq.size()){\n      cout << getCDir(deq[i]);\n    }\n    cout << endl;\n    return true;\n  }\n\n  for(int k = -1; k <= 1; k++){\n\n    int ndir = ( dir + 4 + k ) % 4;\n\n    rep(i,move[cur][ndir].size()){\n      int next = move[cur][ndir][i];\n      if( (used>>next) & 1 )continue;\n      deq.push_back(ndir);\n      if(dfs(next,ndir,used|(1<<next),deq)){\n\treturn true;\n      }\n      deq.pop_back();\n      break;\n    }\n\n  }\n  return false;\n}\n\nvoid compute(){\n  deque<char> deq;\n  dfs(leaf[sp],getDir(G[sp/w][sp%w]),(1<<leaf[sp]),deq);\n}\n\nint main(){\n  cin >> h >> w;\n  lindex = 0;\n  rep(y,h){\n    rep(x,w){\n      cin >> G[y][x];\n      if(G[y][x] != '.' && G[y][x] != 'o'){\n\tsp = x + y * w;\n\tlpos[lindex] = x + y * w;\n\tleaf[x+y*w] = lindex++;\n      }\n      else if(G[y][x] != '.'){\n\tlpos[lindex] = x + y * w;\n\tleaf[x+y*w] = lindex++;\n      }\n    }\n  }\n\n  //cout << \"sp = \" << (int)(sp%w) << \",\" << (int)(sp/w) << endl;\n  //cout << \"leaf = \" << lindex << endl;\n  INIT();\n  /*\n  cout << \"move --- \" << endl;\n  rep(i,lindex){\n    rep(j,4){\n      cout << \"move[\" << i << \"][\" << getCDir(j) << \"] = \";\n      rep(k,move[i][j].size()){\n\tcout << move[i][j][k] << \" \";\n      }\n      cout << endl;\n    }\n  }\n  */\n  compute();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 10;\nchar g[N][N];\nchar buff[31];\n\nconst string dc = \"UDRL\";\nconst int di[] = {-1, 1, 0, 0};\nconst int dj[] = {0, 0, 1, -1};\n\npair<int, int> tmp[31];\n#include <map>\nmap<pair<char, char>, bool> taboo;\n\nbool rec(int h, int w, int i, int j, int depth, int lim, char last)\n{  \n  if (depth == lim) return true;\n  g[i][j] = '.';\n\n  for (int d = 0; d < 4; ++d) {\n    if (taboo[make_pair(dc[d], last)]) {\n      continue;\n    }\n    for (int len = 0; ; ++len) {\n      int ni = i + di[d] * len;\n      int nj = j + dj[d] * len;\n      if (ni < 0 || nj < 0) break;\n      if (h <= ni || w <= nj) break;\n      if (g[ni][nj] == '.') continue;\n      if (rec(h, w, ni, nj, depth + 1, lim, dc[d])) {\n        buff[depth] = dc[d];\n        tmp[depth] = make_pair(ni, nj);\n        return true;\n      }\n      break;\n    }\n  }\n\n  g[i][j] = 'o';\n  return false;\n}\n\nint main(void)\n{\n  taboo[make_pair('U', 'D')] = true;\n  taboo[make_pair('D', 'U')] = true;\n  taboo[make_pair('R', 'L')] = true;\n  taboo[make_pair('L', 'R')] = true;\n  \n  int h, w;\n  while (cin >> h >> w) {\n    int si, sj;\n    int lim = 0;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> g[i][j];\n        if (g[i][j] == 'o') ++lim;\n        if (g[i][j] != 'o' && g[i][j] != '.') {\n          si = i;\n          sj = j;\n        }\n      }\n    }\n    fill(buff, buff + 31, '\\0');\n    rec(h, w, si, sj, 0, lim, g[si][sj]);\n    puts(buff);\n    \n    continue;\n    cout << si << ' ' << sj << endl;\n    for (int i = 0; i < lim; ++i) {\n      cout << tmp[i].first << ' ' << tmp[i].second << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 11;\nconst int dx[] = {0,0,-1,1};\nconst int dy[] = {-1,1,0,0};\n\nbool flag;\nvector<int> ans;\n\nvoid dfs(int u,int v,int dir,set<int>* h,set<int>* w,vector<int>& route,int rem)\n{\n    if(flag){\n        return;\n    }\n    if(rem == 0){\n        ans = route;\n        flag = true;\n        return;\n    }\n    int dame = (dir%2 == 0)?dir+1:dir-1;\n    rep(i,4){\n        if(flag){\n            return;\n        }\n        if(i != dame){\n            if(i == 0){\n                auto it = lower_bound(all(h[v]),u);\n                if(it != h[v].begin()){\n                    it--;\n                    int hoge = *it;\n                    h[v].erase(hoge);\n                    w[hoge].erase(v);\n                    route.pb(0);\n                    dfs(hoge,v,0,h,w,route,rem-1);\n                    h[v].insert(hoge);\n                    w[hoge].insert(v);\n                    route.pop_back();\n                }\n            }\n            if(i == 1){\n                auto it = upper_bound(all(h[v]),u);\n                if(it != h[v].end()){\n                    int hoge = *it;\n                    h[v].erase(hoge);\n                    w[hoge].erase(v);\n                    route.pb(1);\n                    dfs(hoge,v,1,h,w,route,rem-1);\n                    h[v].insert(hoge);\n                    w[hoge].insert(v);\n                    route.pop_back();\n                }\n            }\n            if(i == 2){\n                auto it = lower_bound(all(w[u]),v);\n                if(it != w[u].begin()){\n                    it--;\n                    int hoge = *it;\n                    w[u].erase(hoge);\n                    h[hoge].erase(u);\n                    route.pb(2);\n                    dfs(u,hoge,2,h,w,route,rem-1);\n                    w[u].insert(hoge);\n                    h[hoge].insert(u);\n                    route.pop_back();\n                }\n            }\n            if(i == 3){\n                auto it = upper_bound(all(w[u]),v);\n                if(it != w[u].end()){\n                    int hoge = *it;\n                    w[u].erase(hoge);\n                    h[hoge].erase(u);\n                    route.pb(3);\n                    dfs(u,hoge,3,h,w,route,rem-1);\n                    w[u].insert(hoge);\n                    h[hoge].insert(u);\n                    route.pop_back();\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n,m;\n    set<int> h[MAX_N];\n    set<int> w[MAX_N];\n    vector<int> v;\n    cin >> n >> m;\n    int sx,sy,dir;\n    int cnt  = 0;\n    flag = false;\n    rep(i,n){\n        string s;\n        cin >> s;\n        rep(j,s.length()){\n            if(s[j] == 'o'){\n                h[i].insert(j);\n                w[j].insert(i);\n                cnt++;\n            }else if(s[j] == 'U'){\n                sx = i,sy = j,dir = 0;\n            }else if(s[j] == 'D'){\n                sx = i,sy = j,dir = 1;\n            }else if(s[j] == 'L'){\n                sx = i,sy = j,dir = 2;\n            }else if(s[j] == 'R'){\n                sx = i,sy = j,dir = 3;\n            }\n        }\n    }\n    char d[] = {'U','D','L','R'};\n    dfs(sx,sy,dir,w,h,v,cnt);\n    rep(i,ans.size()){\n        cout << d[ans[i]];\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint cv[256];\nint cv2[256];\n\nint h, w;\nint g[10][10];\nint sx, sy, sdir;\nint cnt;\nstring res;\n\nbool dfs(int x, int y, int d)\n{\n\tg[x][y] = 0;\n\tcnt--;\n\tif (cnt == 0) return true;\n\trep(dir, 4){\n\t\tif (abs(dir - d) == 2) continue;\n\t\tfor (int i = 1;; i++){\n\t\t\tint nx = x + dx[dir] * i;\n\t\t\tint ny = y + dy[dir] * i;\n\t\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w) break;\n\t\t\tif (g[nx][ny]){\n\t\t\t\tres += cv2[dir];\n\t\t\t\tif (dfs(nx, ny, dir)) return true;\n\t\t\t\tres.pb();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tg[x][y] = 1;\n\tcnt++;\n\treturn false;\n}\n\nint main()\n{\n\trep(i, 4) cv[\"ULDR\"[i]] = i;\n\trep(i, 4) cv2[i] = \"ULDR\"[i];\n\n\tcin >> h >> w;\n\trep(i, h) rep(j, w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == 'o'){\n\t\t\tg[i][j] = 1;\n\t\t\tcnt++;\n\t\t}\n\t\telse if (c != '.'){\n\t\t\tsx = i;\n\t\t\tsy = j;\n\t\t\tsdir = cv[c];\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\tif (dfs(sx, sy, sdir)) cout << res << endl;\n\telse assert(false);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 10;\nstatic const int di[4] = {0, -1, 0, 1};\nstatic const int dj[4] = {1, 0, -1, 0};\nstatic const string D = \"RULD\";\n\nint H, W, sum;\nchar G[MAX][MAX];\n\nbool hasLeaf(int pi, int pj, int r, int &ni, int &nj){\n  do{\n      pi += di[r];\n      pj += dj[r];\n      if ( pi < 0 || pj < 0 || pi >= H ||  pj >= W ) break;\n      if ( G[pi][pj] == 'o' ) {\n\t  ni = pi;\n\t  nj = pj;\n\t  return true;\n      }\n  } while(1);\n  return false;\n}\n\nbool dfs(int pi, int pj, int dir, vector<int> path, int rem){\n  if ( rem == 1 ){\n      rep(i, path.size()) cout << D[path[i]];    \n      cout << endl;\n      return true;\n  }\n\n  rep(r, 4){\n    if ( (r+2)%4 == dir ) continue;\n    int ni, nj;\n    if ( hasLeaf(pi, pj, r, ni, nj) ){\n\tvector<int> np = path;\n\tG[pi][pj] = '.';\n\tnp.push_back(r);\n\tif (dfs(ni, nj, r, np, rem-1)) return true;\n\tG[pi][pj] = 'o';\n    }\n  }\n  return false;\n}\n\nint getDir(char c){\n    rep(i, D.size()) if ( c == D[i] ) return i;\n}\n\nmain(){\n  int si, sj, dir;\n  cin >> H >> W;\n  sum = 0;\n  rep(i, H) rep(j, W) {\n    cin >> G[i][j];\n    if ( G[i][j] != 'o' && G[i][j] != '.' ){\n      dir = getDir(G[i][j]);\n      si = i; sj = j;\n      G[i][j] = 'o';\n    }\n    if ( G[i][j] == 'o' ) sum++;\n  }\n  vector<int> P;\n  dfs(si, sj, dir, P, sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst string dir = \"URDL\";\nvector<string> g;\n\nstring dfs(int y,int x,int d,int rem,string s){\n  if(rem==0)return s;\n  char tmp = g[y][x];\n  g[y][x] = '.';\n\n  for(int i=3;i<=5;i++){\n    int nd = (d+i)%4, ny = y + dy[nd], nx = x + dx[nd];\n    while(ny>=0 && nx>=0 && ny<h && nx<w){\n      if(g[ny][nx] == 'o'){\n\tstring tmp = dfs(ny,nx,nd,rem-1,s+dir[nd]);\n\tif(tmp.size())return tmp;\n\tbreak;\n      }\n      ny += dy[nd]; nx += dx[nd];\n    }\n  }\n\n  g[y][x] = tmp;\n  return \"\";\n}\n\nint main(){\n  int y,x,d,cnt = 0;\n  cin >> h >> w;\n  g.resize(h);\n  for(int i=0;i<h;i++){\n    cin >> g[i];\n    for(int j=0;j<w;j++){\n      if(isupper(g[i][j])){\n\ty = i; x = j;\n\tfor(int k=0;k<4;k++){\n\t  if(dir[k] == g[i][j])d = k;\n\t}\n      }else if(g[i][j] == 'o')cnt++;\n    }\n  }\n  cout << dfs(y,x,d,cnt,\"\") << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint H, W;\nint grid[11][11];\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {-1, 1, 0, 0};\nstring state = \"UDLR\";\nint lim[4] = {1,0,3,2};\nbool used[11][11];\nstring dfs(int x, int y, int s, int rem, string res){\n  //printf(\"dfs:%d %d %d %d %s\\n\", x, y, s, rem, res.c_str());\n  if(rem == 0){\n    return res;\n  }\n  REP(r, 4)if(r != lim[s]){\n    REP(p, 10){\n      int nx = x + p * dx[r];\n      int ny = y + p * dy[r];\n      if(0 <= nx && 0 <= ny && nx < W && ny < H){\n        if(!used[ny][nx] && grid[ny][nx]){\n          used[ny][nx] = true;\n          //printf(\"call %d %d %d %d %s\\n\", nx, ny, r, rem -1, (res+state[r]).c_str());\n          string response = dfs(nx, ny, r, rem-1, res+state[r]);\n          used[ny][nx] = false;\n          if(response != \"\") return response;\n          break;\n        }\n      }else{\n        break;\n      }\n    }\n  }\n  return \"\";\n}\n\nint main(){\n  while(cin>>H>>W && H){\n    int nx, ny, s;\n    int cnt = 0;\n    REP(y, H){\n      string t; cin>>t;\n      REP(x, W){\n        if(t[x] == 'o'){\n          grid[y][x] = 1;\n          cnt += 1;\n        }else if(t[x] == '.'){\n          grid[y][x] = 0;\n        }else{\n          grid[y][x] = 0;\n          nx = x;\n          ny = y;\n          REP(i, 4)if(state[i] == t[x])s = i;\n        }\n      }\n    }\n    memset(used, 0, sizeof(used));\n    string ans = dfs(nx, ny, s, cnt, \"\");\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int dx[4] = {1, -1, 0, 0};\nconstexpr int dy[4] = {0, 0, 1, -1};\nconstexpr char dc[4] = {'R', 'L', 'D', 'U'};\n\nint h, w;\nstring field[MAX_SIZE];\nstring ans = \"\";\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nbool dfs(int rest, int x, int y, int d) {\n\tif(rest == 0) return true;\n\n\tfor(int nd = 0; nd < 4; ++nd) {\n\t\tif(d == (nd ^ 1)) continue;\n\n\t\tint nx = x + dx[nd];\n\t\tint ny = y + dy[nd];\n\n\t\twhile(!out(nx, ny)) {\n\t\t\tif(field[ny][nx] == 'o') {\n\t\t\t\tfield[ny][nx] = '.';\n\t\t\t\tif(dfs(rest - 1, nx, ny, nd)) {\n\t\t\t\t\tans = dc[nd] + ans;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tfield[ny][nx] = 'o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx += dx[nd];\n\t\t\tny += dy[nd];\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> h >> w;\n\tfor(int i = 0; i < h; ++i) {\n\t\tcin >> field[i];\n\t}\n\n\tint sx, sy, sd;\n\tint cnt = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 'o') {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\telse if(field[i][j] != '.') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\t\tif(field[i][j] == dc[d]) {\n\t\t\t\t\t\tsd = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs(cnt, sx, sy, sd);\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2223: Kaeru Jump\n// 2017.12.9\n\n#include <stdio.h>\n#include <string.h>\n\nchar m[12][12]; int h, w;\nint tr['Z'];\nchar sd[4] = {'U','R','D','L'};\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nchar ans[100];\nchar buf[10], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint rec(int r, int c, int dir, int leaf, char *p)\n{\n\tint d, r2, c2;\n\n\tif (leaf == 1) { *p = 0; return 1; }\n\tdir += 2; if (dir >= 4) dir -= 4;\n\tfor (d = 0; d < 4; d++) {\n\t\tif (d == dir) continue;\n\t\tr2 = r, c2 = c;\n\t\twhile (1) {\n\t\t\tr2 += mv[d][0], c2 += mv[d][1];\n\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) break;\n\t\t\tif (m[r2][c2] == 'o') {\n\t\t\t\t*p = sd[d];\n\t\t\t\tm[r][c] = '.';\n\t\t\t\tif (rec(r2, c2, d, leaf-1, p+1)) return 1;\n\t\t\t\tm[r][c] = 'o';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint r, c, sr, sc, leaf, d;\n\n\ttr['U'] = 0, tr['R'] = 1, tr['D'] = 2, tr['L'] = 3;\n\tfgets(p=buf, 10, stdin), h = getint(), w = getint();\n\tleaf = 0;\n\tfor (r = 0; r < h; r++) {\n\t\tfgets(m[r], 12, stdin);\n\t\tfor (c = 0; c < w; c++) {\n\t\t\tif      (m[r][c] == '.');\n\t\t\telse if (m[r][c] == 'o') leaf++;\n\t\t\telse {\n\t\t\t\td = tr[m[r][c]];\n\t\t\t\tsr = r, sc = c;\n\t\t\t\tm[r][c] = 'o', leaf++;\n\t\t\t}\n\t\t}\n\t}\n\trec(sr, sc, d, leaf, ans);\n\tputs(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tchar h;\n\tchar w;\n\tchar direction;\n} Point;\n\nPoint find(Point current, char direction, char** array, int H, int W) {\n\tPoint target;\n\ttarget.h = -1;\n\ttarget.w = -1;\n\ttarget.direction = -1;\n\tif (direction == 'U') {\n\t\tfor (int h = current.h - 1; h >= 0; h--) {\n\t\t\tif (array[h][current.w] == 'o') {\n\t\t\t\ttarget.h = h;\n\t\t\t\ttarget.w = current.w;\n\t\t\t\ttarget.direction = 'U';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'D') {\n\t\tfor (int h = current.h + 1; h < H; h++) {\n\t\t\tif (array[h][current.w] == 'o') {\n\t\t\t\ttarget.h = h;\n\t\t\t\ttarget.w = current.w;\n\t\t\t\ttarget.direction = 'D';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'L') {\n\t\tfor (int w = current.w - 1; w>=0; w--) {\n\t\t\tif (array[current.h][w] == 'o') {\n\t\t\t\ttarget.h = current.h;\n\t\t\t\ttarget.w = w;\n\t\t\t\ttarget.direction = 'L';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'R') {\n\t\tfor (int w = current.w + 1; w < W; w++) {\n\t\t\tif (array[current.h][w] == 'o') {\n\t\t\t\ttarget.h = current.h;\n\t\t\t\ttarget.w = w;\n\t\t\t\ttarget.direction = 'R';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n// N number of all o and frog\nvoid dfs(Point current, char** array, int H, int W, int N, char * result) {\n\tif (N == 1) {\n\t\tresult[0] = '\\0';\n\t\treturn;\n\t}\n\tPoint target;\n\t//jump left\n\tif (current.direction != 'R') {\n\t\ttarget = find(current, 'L', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump right\n\tif (current.direction != 'L') {\n\t\ttarget = find(current, 'R', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump up\n\tif (current.direction != 'D') {\n\t\ttarget = find(current, 'U', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump down\n\tif (current.direction != 'U') {\n\t\ttarget = find(current, 'D', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// avoid returning a pointer to local data\nint main() {\n\tint H, W;\n\tint N = 0;\n\tchar ** array;\n\tchar direction;\n\tPoint current;\n\tscanf(\"%d %d\\n\", &H, &W);\n\tarray = (char **)malloc(H * sizeof(char *));\n\tfor (int h = 0; h < H; h++) {\n\t\tarray[h] = (char *) malloc(W * sizeof(char));\n\t}\n\n\tfor (int h = 0; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tarray[h][w] = getchar();\n\t\t\tif (array[h][w] != 'o' && array[h][w] != '.') {\n\t\t\t\t//frog\n\t\t\t\tcurrent.h = h;\n\t\t\t\tcurrent.w = w;\n\t\t\t\tcurrent.direction = array[h][w];\n\t\t\t\tN++;\n\t\t\t}\n\t\t\tif (array[h][w] == 'o') {\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\tchar result[30];\n\tdfs(current, array, H, W, N, result);\n\tprintf(\"%s\\n\", result);\n\tfor (int h = 0; h < H; h++) {\n\t\tfree(array[h]);\n\t}\n\tfree(array);\n\tgetchar();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tchar h;\n\tchar w;\n\tchar direction;\n} Point;\n\nPoint find(Point current, char direction, char** array, int H, int W) {\n\tPoint target;\n\ttarget.h = -1;\n\ttarget.w = -1;\n\ttarget.direction = -1;\n\tif (direction == 'U') {\n\t\tfor (int h = current.h - 1; h >= 0; h--) {\n\t\t\tif (array[h][current.w] == 'o') {\n\t\t\t\ttarget.h = h;\n\t\t\t\ttarget.w = current.w;\n\t\t\t\ttarget.direction = 'U';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'D') {\n\t\tfor (int h = current.h + 1; h < H; h++) {\n\t\t\tif (array[h][current.w] == 'o') {\n\t\t\t\ttarget.h = h;\n\t\t\t\ttarget.w = current.w;\n\t\t\t\ttarget.direction = 'D';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'L') {\n\t\tfor (int w = current.w - 1; w>=0; w--) {\n\t\t\tif (array[current.h][w] == 'o') {\n\t\t\t\ttarget.h = current.h;\n\t\t\t\ttarget.w = w;\n\t\t\t\ttarget.direction = 'L';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'R') {\n\t\tfor (int w = current.w + 1; w < W; w++) {\n\t\t\tif (array[current.h][w] == 'o') {\n\t\t\t\ttarget.h = current.h;\n\t\t\t\ttarget.w = w;\n\t\t\t\ttarget.direction = 'R';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n// N number of all o and frog\nvoid dfs(Point current, char** array, int H, int W, int N, char * result) {\n\tif (N == 1) {\n\t\tresult[0] = '\\0';\n\t\treturn;\n\t}\n\tPoint target;\n\t//jump left\n\tif (current.direction != 'R') {\n\t\ttarget = find(current, 'L', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump right\n\tif (current.direction != 'L') {\n\t\ttarget = find(current, 'R', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump up\n\tif (current.direction != 'D') {\n\t\ttarget = find(current, 'U', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump down\n\tif (current.direction != 'U') {\n\t\ttarget = find(current, 'D', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// avoid returning a pointer to local data\nint main() {\n\tint H, W;\n\tint N = 0;\n\tchar ** array;\n\tchar direction;\n\tPoint current;\n\tscanf(\"%d %d\\n\", &H, &W);\n\tarray = (char **)malloc(H * sizeof(char *));\n\tfor (int h = 0; h < H; h++) {\n\t\tarray[h] = (char *) malloc(W * sizeof(char));\n\t}\n\n\tfor (int h = 0; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tarray[h][w] = getchar();\n\t\t\tif (array[h][w] != 'o' && array[h][w] != '.') {\n\t\t\t\t//frog\n\t\t\t\tcurrent.h = h;\n\t\t\t\tcurrent.w = w;\n\t\t\t\tcurrent.direction = array[h][w];\n\t\t\t\tN++;\n\t\t\t}\n\t\t\tif (array[h][w] == 'o') {\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\tchar result[30];\n\tdfs(current, array, H, W, N, result);\n\tprintf(\"%s\\n\", result);\n\tfor (int h = 0; h < H; h++) {\n\t\tfree(array[h]);\n\t}\n\tfree(array);\n\t//getchar();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tchar h;\n\tchar w;\n\tchar direction;\n} Point;\n\nPoint find(Point current, char direction, char** array, int H, int W) {\n\tPoint target;\n\ttarget.h = -1;\n\ttarget.w = -1;\n\ttarget.direction = -1;\n\tif (direction == 'U') {\n\t\tfor (int h = current.h - 1; h >= 0; h--) {\n\t\t\tif (array[h][current.w] == 'o') {\n\t\t\t\ttarget.h = h;\n\t\t\t\ttarget.w = current.w;\n\t\t\t\ttarget.direction = 'U';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'D') {\n\t\tfor (int h = current.h + 1; h < H; h++) {\n\t\t\tif (array[h][current.w] == 'o') {\n\t\t\t\ttarget.h = h;\n\t\t\t\ttarget.w = current.w;\n\t\t\t\ttarget.direction = 'D';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'L') {\n\t\tfor (int w = current.w - 1; w>=0; w--) {\n\t\t\tif (array[current.h][w] == 'o') {\n\t\t\t\ttarget.h = current.h;\n\t\t\t\ttarget.w = w;\n\t\t\t\ttarget.direction = 'L';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\tif (direction == 'R') {\n\t\tfor (int w = current.w + 1; w < W; w++) {\n\t\t\tif (array[current.h][w] == 'o') {\n\t\t\t\ttarget.h = current.h;\n\t\t\t\ttarget.w = w;\n\t\t\t\ttarget.direction = 'R';\n\t\t\t\treturn target;\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n// N number of all o and frog\nvoid dfs(Point current, char** array, int H, int W, int N, char * result) {\n\tif (N == 1) {\n\t\tresult[0] = '\\0';\n\t\treturn;\n\t}\n\tPoint target;\n\t//jump left\n\tif (current.direction != 'R') {\n\t\ttarget = find(current, 'L', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump right\n\tif (current.direction != 'L') {\n\t\ttarget = find(current, 'R', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump up\n\tif (current.direction != 'D') {\n\t\ttarget = find(current, 'U', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//jump down\n\tif (current.direction != 'U') {\n\t\ttarget = find(current, 'D', array, H, W);\n\t\t// exist target\n\t\tif (target.h != -1) {\n\t\t\tarray[current.h][current.w] = '.';\n\t\t\tdfs(target, array, H, W, N - 1, result);\n\t\t\t// put back the o\n\t\t\tarray[current.h][current.w] = 'o';\n\t\t\tif (strlen(result) == N - 2) {\n\t\t\t\tchar tmp[30];\n\t\t\t\tsprintf(&tmp, \"%c%s\", target.direction, result);\n\t\t\t\tstrcpy(result, tmp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// avoid returning a pointer to local data\nint main() {\n\tint H, W;\n\tint N = 0;\n\tchar ** array;\n\tchar direction;\n\tPoint current;\n\tscanf(\"%d %d\\n\", &H, &W);\n\tarray = (char **)malloc(H * sizeof(char *));\n\tfor (int h = 0; h < H; h++) {\n\t\tarray[h] = (char *) malloc(W * sizeof(char));\n\t}\n\n\tfor (int h = 0; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tarray[h][w] = getchar();\n\t\t\tif (array[h][w] != 'o' && array[h][w] != '.') {\n\t\t\t\t//frog\n\t\t\t\tcurrent.h = h;\n\t\t\t\tcurrent.w = w;\n\t\t\t\tcurrent.direction = array[h][w];\n\t\t\t\tN++;\n\t\t\t}\n\t\t\tif (array[h][w] == 'o') {\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\tchar result[30];\n\tdfs(current, array, H, W, N, result);\n\tprintf(\"%s\\n\", result);\n\tfor (int h = 0; h < H; h++) {\n\t\tfree(array[h]);\n\t}\n\tfree(array);\n\tgetchar();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <fstream>\n \nusing namespace std;\n \n#define MAXN 11\n \nint n, m, s, e, d, total;\nint c[MAXN][MAXN];\nint dir[4][2] = {0, -1, -1, 0, 0, 1, 1, 0};\nint ans[MAXN * MAXN];\nbool ok;\n \nint change(char ch)\n{\n    switch(ch)\n    {\n        case 'L': return 0;\n        case 'U': return 1;\n        case 'R': return 2;\n        case 'D': return 3;\n    }\n}\n \nchar changetwo(int x)\n{\n    switch(x)\n    {\n        case 0: return 'L';\n        case 1: return 'U';\n        case 2: return 'R';\n        case 3: return 'D';\n    }\n}\n \nvoid dfs(int x, int y, int len, int di)\n{\n    if (len == total)\n    {\n        ok = true;\n        return ;\n    }\n \n    if (ok)\n    {\n        return ;\n    }\n \n    for (int i = 3; i < 6; i++)\n    {\n        for (int k = 1; k <= 10; k++)\n        {\n            int xt = x + dir[(i + di) % 4][0] * k, yt = y + dir[(i + di) % 4][1] * k;\n \n            if (xt >= 0 && xt < n && yt >= 0 && yt < m && !ok) //\n            {\n                if (c[xt][yt] == 1)\n                {\n                    ans[len] = (i + di) % 4;\n                    len++;\n                    c[xt][yt] = 0;\n                    dfs(xt, yt, len, (i + di) % 4);\n \n                    len--;\n                    c[xt][yt] = 1;\n                    break;\n                }\n            }\n        }\n    }\n}\n \nvoid solve()\n{\n    dfs(s, e, 0, d);\n \n    for (int i = 0; i < total; i++)\n    {\n        cout << changetwo(ans[i]);\n    }\n    cout << endl;\n}\n \nvoid input()\n{\n    char ch;\n \n    while (cin >> n >> m)\n    {\n        total = 0;\n        ok = false;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m; j++)\n            {\n                cin >> ch;\n                if (ch == '.')\n                {\n                    c[i][j] = 0;\n                }\n                else if (ch == 'o')\n                {\n                    total++;\n                    c[i][j] = 1;\n                }\n                else\n                {\n                    d = change(ch);\n                    s = i, e = j;\n                    c[i][j] = 0;\n                }\n            }\n        }\n \n        solve();\n    }\n}\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    input();\n    return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Kaeru Jump\npublic class Main{\n\n\tint h, w, n;\n\tchar[][] m;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tchar[] str = {'U','R','D','L'};\n\tchar[] res;\n\n\tint[][] near(int i, int j){\n\t\tint[][] r = new int[4][2];\n\t\tfor(int[]a:r)Arrays.fill(a, -1);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\tif(m[pi][pj]=='o'){\n\t\t\t\t\tr[k][0] = pi; r[k][1] = pj; break;\n\t\t\t\t}\n\t\t\t\tpi += d[k][0]; pj += d[k][1];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tboolean dfs(int i, int j, int D, int c){\n\t\tif(c==n-1)return true;\n\t\tint[][] e = near(i, j);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(e[k][0]==-1||D==(k+2)%4)continue;\n\t\t\tres[c] = str[k];\n\t\t\tm[i][j] = '.';\n\t\t\tboolean ok = true;\n\t\t\tif(c<n-2){\n\t\t\t\tfor(int dir=0;dir<4;dir++){\n\t\t\t\t\tif(e[dir][0]==-1)continue;\n\t\t\t\t\tint[][] adj = near(e[dir][0], e[dir][1]);\n\t\t\t\t\tboolean exist = false;\n\t\t\t\t\tfor(int x=0;x<4;x++)if(adj[x][0]!=-1)exist = true;\n\t\t\t\t\tif(!exist)ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tif(dfs(e[k][0], e[k][1], k, c+1))return true;\n\t\t\t}\n\t\t\tm[i][j] = 'o';\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\th = sc.nextInt(); w = sc.nextInt();\n\t\tn = 0;\n\t\tm = new char[h][];\n\t\tint si = -1, sj = -1, sd = -1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]=='.')continue;\n\t\t\t\tn++;\n\t\t\t\tif(m[i][j]=='o')continue;\n\t\t\t\tsi = i; sj = j;\n\t\t\t\tsd = m[i][j]=='U'?0:m[i][j]=='R'?1:m[i][j]=='D'?2:3;\n\t\t\t\tm[i][j] = 'o';\n\t\t\t}\n\t\t}\n\t\tres = new char[n-1];\n\t\tdfs(si, sj, sd, 0);\n\t\tSystem.out.println(new String(res));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FrogPond {\n\n\tint h, w;\n\tchar[][] board;\n\tchar[] directions = { 'U', 'L', 'D', 'R' };\n\tint[] directionX = { -1, 0, 1, 0 };\n\tint[] directionY = { 0, -1, 0, 1 };\n\tStack<Character> solution = new Stack<Character>();\n\t\n\tint countLeaves() {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<board.length; i++){\n\t\t\tfor (int j=0; j<board[0].length; j++){\n\t\t\t\tif (board[i][j] == 'o'){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tboolean dfs(int x, int y, int d) { // x: height; y: width\n\t\tint i = x, j = y;\n\t\tboard[x][y] = '.';\n\t\tif (countLeaves() == 0){\n\t\t\treturn true;\n\t\t}\n\t\td--;\n\t\tfor (int rep = 0; rep < 4; rep++) {\n\t\t\ti = x;\n\t\t\tj = y;\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tif (rep == 2)\n\t\t\t\tcontinue;\n\t\t\twhile (i < board.length && i >= 0 && j < board[0].length && j >= 0) {\n\t\t\t\ti += directionX[d];\n\t\t\t\tj += directionY[d];\n\t\t\t\tif (!(i < board.length && i >= 0 && j < board[0].length && j >= 0)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (board[i][j] == 'o') {\n\t\t\t\t\tsolution.push(directions[d]);\n\t\t\t\t\tif (dfs(i, j, d))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboard[x][y] = 'o';\n\t\tsolution.pop();\n\t\treturn false;\n\t}\n\n\tpublic void Main() {\n\t\tScanner in = new Scanner(System.in);\n\t\th = in.nextInt();\n\t\tw = in.nextInt();\n\t\tString[] sBoard = new String[h];\n\t\tboard = new char[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tsBoard[i] = in.next();\n\t\t\tboard[i] = sBoard[i].toCharArray();\n\t\t}\n\t\tint d = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (board[i][j] == 'U' || board[i][j] == 'L'\n\t\t\t\t\t\t|| board[i][j] == 'D' || board[i][j] == 'R') {\n\t\t\t\t\tif (board[i][j] == 'U')\n\t\t\t\t\t\td = 0;\n\t\t\t\t\telse if (board[i][j] == 'L')\n\t\t\t\t\t\td = 1;\n\t\t\t\t\telse if (board[i][j] == 'D')\n\t\t\t\t\t\td = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tboard[i][j] = 3;\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t\tdfs(i, j, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tin.close();\n\t\t\n\t\tSystem.out.println(solution);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew FrogPond().Main();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint h, w;\n\tchar[][] board;\n\tchar[] directions = { 'U', 'L', 'D', 'R' };\n\tint[] directionX = { -1, 0, 1, 0 };\n\tint[] directionY = { 0, -1, 0, 1 };\n\tStack<Character> solution = new Stack<Character>();\n\t\n\tint countLeaves() {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<board.length; i++){\n\t\t\tfor (int j=0; j<board[0].length; j++){\n\t\t\t\tif (board[i][j] == 'o'){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tboolean dfs(int x, int y, int d) { // x: height; y: width\n\t\tint i = x, j = y;\n\t\tboard[x][y] = '.';\n\t\tif (countLeaves() == 0){\n\t\t\treturn true;\n\t\t}\n\t\td--;\n\t\tfor (int rep = 0; rep < 4; rep++) {\n\t\t\ti = x;\n\t\t\tj = y;\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tif (rep == 2)\n\t\t\t\tcontinue;\n\t\t\twhile (i < board.length && i >= 0 && j < board[0].length && j >= 0) {\n\t\t\t\ti += directionX[d];\n\t\t\t\tj += directionY[d];\n\t\t\t\tif (!(i < board.length && i >= 0 && j < board[0].length && j >= 0)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (board[i][j] == 'o') {\n\t\t\t\t\tsolution.push(directions[d]);\n\t\t\t\t\tif (dfs(i, j, d))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboard[x][y] = 'o';\n\t\tsolution.pop();\n\t\treturn false;\n\t}\n\n\tpublic void solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\th = in.nextInt();\n\t\tw = in.nextInt();\n\t\tString[] sBoard = new String[h];\n\t\tboard = new char[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tsBoard[i] = in.next();\n\t\t\tboard[i] = sBoard[i].toCharArray();\n\t\t}\n\t\tint d = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (board[i][j] == 'U' || board[i][j] == 'L'\n\t\t\t\t\t\t|| board[i][j] == 'D' || board[i][j] == 'R') {\n\t\t\t\t\tif (board[i][j] == 'U')\n\t\t\t\t\t\td = 0;\n\t\t\t\t\telse if (board[i][j] == 'L')\n\t\t\t\t\t\td = 1;\n\t\t\t\t\telse if (board[i][j] == 'D')\n\t\t\t\t\t\td = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\td = 3;\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t\tdfs(i, j, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tin.close();\n\t\t\n\t\tObject res[] = solution.toArray();\n\t\tfor (Object c : res){\n\t\t\tSystem.out.print(c);\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Kaeru Jump\npublic class Main{\n\n\tint h, w, n;\n\tchar[][] m;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tchar[] str = {'U','R','D','L'};\n\tchar[] res;\n\n\tint[][] near(int i, int j){\n\t\tint[][] r = new int[4][2];\n\t\tfor(int[]a:r)Arrays.fill(a, -1);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\tif(m[pi][pj]=='o'){\n\t\t\t\t\tr[k][0] = pi; r[k][1] = pj; break;\n\t\t\t\t}\n\t\t\t\tpi += d[k][0]; pj += d[k][1];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tboolean dfs(int i, int j, int D, int c){\n\t\tif(c==n-1)return true;\n\t\tint[][] e = near(i, j);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(e[k][0]==-1||D==(k+2)%4)continue;\n\t\t\tres[c] = str[k];\n\t\t\tm[i][j] = '.';\n//\t\t\tboolean ok = true;\n//\t\t\tif(c<n-2){\n//\t\t\t\tfor(int dir=0;dir<4;dir++){\n//\t\t\t\t\tif(e[dir][0]==-1)continue;\n//\t\t\t\t\tint[][] adj = near(e[dir][0], e[dir][1]);\n//\t\t\t\t\tboolean exist = false;\n//\t\t\t\t\tfor(int x=0;x<4;x++)if(adj[x][0]!=-1)exist = true;\n//\t\t\t\t\tif(!exist)ok = false;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(ok){\n\t\t\t\tif(dfs(e[k][0], e[k][1], k, c+1))return true;\n//\t\t\t}\n\t\t\tm[i][j] = 'o';\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\th = sc.nextInt(); w = sc.nextInt();\n\t\tn = 0;\n\t\tm = new char[h][];\n\t\tint si = -1, sj = -1, sd = -1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]=='.')continue;\n\t\t\t\tn++;\n\t\t\t\tif(m[i][j]=='o')continue;\n\t\t\t\tsi = i; sj = j;\n\t\t\t\tsd = m[i][j]=='U'?0:m[i][j]=='R'?1:m[i][j]=='D'?2:3;\n\t\t\t\tm[i][j] = 'o';\n\t\t\t}\n\t\t}\n\t\tres = new char[n-1];\n\t\tdfs(si, sj, sd, 0);\n\t\tSystem.out.println(new String(res));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint h, w;\n\tchar[][] board;\n\tchar[] directions = { 'U', 'L', 'D', 'R' };\n\tint[] directionX = { -1, 0, 1, 0 };\n\tint[] directionY = { 0, -1, 0, 1 };\n\tStack<Character> solution = new Stack<Character>();\n\t\n\tint countLeaves() {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<board.length; i++){\n\t\t\tfor (int j=0; j<board[0].length; j++){\n\t\t\t\tif (board[i][j] == 'o'){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tboolean dfs(int x, int y, int d) { // x: height; y: width\n\t\tint i = x, j = y;\n\t\tboard[x][y] = '.';\n\t\tif (countLeaves() == 0){\n\t\t\treturn true;\n\t\t}\n\t\td--;\n\t\tfor (int rep = 0; rep < 4; rep++) {\n\t\t\ti = x;\n\t\t\tj = y;\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tif (rep == 2)\n\t\t\t\tcontinue;\n\t\t\twhile (i < board.length && i >= 0 && j < board[0].length && j >= 0) {\n\t\t\t\ti += directionX[d];\n\t\t\t\tj += directionY[d];\n\t\t\t\tif (!(i < board.length && i >= 0 && j < board[0].length && j >= 0)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (board[i][j] == 'o') {\n\t\t\t\t\tsolution.push(directions[d]);\n\t\t\t\t\tif (dfs(i, j, d))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboard[x][y] = 'o';\n\t\tsolution.pop();\n\t\treturn false;\n\t}\n\n\tpublic void solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\th = in.nextInt();\n\t\tw = in.nextInt();\n\t\tString[] sBoard = new String[h];\n\t\tboard = new char[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tsBoard[i] = in.next();\n\t\t\tboard[i] = sBoard[i].toCharArray();\n\t\t}\n\t\tint d = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (board[i][j] == 'U' || board[i][j] == 'L'\n\t\t\t\t\t\t|| board[i][j] == 'D' || board[i][j] == 'R') {\n\t\t\t\t\tif (board[i][j] == 'U')\n\t\t\t\t\t\td = 0;\n\t\t\t\t\telse if (board[i][j] == 'L')\n\t\t\t\t\t\td = 1;\n\t\t\t\t\telse if (board[i][j] == 'D')\n\t\t\t\t\t\td = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tboard[i][j] = 3;\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t\tdfs(i, j, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tin.close();\n\t\t\n\t\tObject res[] = solution.toArray();\n\t\tfor (Object c : res){\n\t\t\tSystem.out.print(c);\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Kaeru Jump\npublic class Main{\n\n\tint h, w, n;\n\tchar[][] m;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tchar[] str = {'U','R','D','L'};\n\tchar[] res;\n\n\tint[][] near(int i, int j){\n\t\tint[][] r = new int[4][2];\n\t\tfor(int[]a:r)Arrays.fill(a, -1);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\tif(m[pi][pj]=='o'){\n\t\t\t\t\tr[k][0] = pi; r[k][1] = pj; break;\n\t\t\t\t}\n\t\t\t\tpi += d[k][0]; pj += d[k][1];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tboolean dfs(int i, int j, int D, int c){\n\t\tif(c==n-1)return true;\n\t\tint[][] e = near(i, j);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(e[k][0]==-1||D==(k+2)%4)continue;\n\t\t\tres[c] = str[k];\n\t\t\tm[i][j] = '.';\n\t\t\tif(dfs(e[k][0], e[k][1], k, c+1))return true;\n\t\t\tm[i][j] = 'o';\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\th = sc.nextInt(); w = sc.nextInt();\n\t\tn = 0;\n\t\tm = new char[h][];\n\t\tint si = -1, sj = -1, sd = -1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]=='.')continue;\n\t\t\t\tn++;\n\t\t\t\tif(m[i][j]=='o')continue;\n\t\t\t\tsi = i; sj = j;\n\t\t\t\tsd = m[i][j]=='U'?0:m[i][j]=='R'?1:m[i][j]=='D'?2:3;\n\t\t\t\tm[i][j] = 'o';\n\t\t\t}\n\t\t}\n\t\tres = new char[n-1];\n\t\tdfs(si, sj, sd, 0);\n\t\tSystem.out.println(new String(res));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint h, w;\n\tchar[][] board;\n\tchar[] directions = { 'U', 'L', 'D', 'R' };\n\tint[] directionX = { -1, 0, 1, 0 };\n\tint[] directionY = { 0, -1, 0, 1 };\n\tStack<Character> solution = new Stack<Character>();\n\t\n\tint countLeaves() {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<board.length; i++){\n\t\t\tfor (int j=0; j<board[0].length; j++){\n\t\t\t\tif (board[i][j] == 'o'){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tboolean dfs(int x, int y, int d) { // x: height; y: width\n\t\tint i = x, j = y;\n\t\tboard[x][y] = '.';\n\t\tif (countLeaves() == 0){\n\t\t\treturn true;\n\t\t}\n\t\td--;\n\t\tfor (int rep = 0; rep < 4; rep++) {\n\t\t\ti = x;\n\t\t\tj = y;\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tif (rep == 2)\n\t\t\t\tcontinue;\n\t\t\twhile (i < board.length && i >= 0 && j < board[0].length && j >= 0) {\n\t\t\t\ti += directionX[d];\n\t\t\t\tj += directionY[d];\n\t\t\t\tif (!(i < board.length && i >= 0 && j < board[0].length && j >= 0)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (board[i][j] == 'o') {\n\t\t\t\t\tsolution.push(directions[d]);\n\t\t\t\t\tif (dfs(i, j, d))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboard[x][y] = 'o';\n\t\tsolution.pop();\n\t\treturn false;\n\t}\n\n\tpublic void solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\th = in.nextInt();\n\t\tw = in.nextInt();\n\t\tString[] sBoard = new String[h];\n\t\tboard = new char[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tsBoard[i] = in.next();\n\t\t\tboard[i] = sBoard[i].toCharArray();\n\t\t}\n\t\tint d = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (board[i][j] == 'U' || board[i][j] == 'L'\n\t\t\t\t\t\t|| board[i][j] == 'D' || board[i][j] == 'R') {\n\t\t\t\t\tif (board[i][j] == 'U')\n\t\t\t\t\t\td = 0;\n\t\t\t\t\telse if (board[i][j] == 'L')\n\t\t\t\t\t\td = 1;\n\t\t\t\t\telse if (board[i][j] == 'D')\n\t\t\t\t\t\td = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tboard[i][j] = 3;\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t\tdfs(i, j, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tin.close();\n\t\t\n\t\tObject res[] = solution.toArray();\n\t\tfor (Object c : res){\n\t\t\tSystem.out.print(c);\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public int d { get; set; }\n    public string via { get; set; }\n    public int count { get; set; }\n}\n\npublic class hello\n{\n    public static Dictionary<char, int> d0;\n    public static Dictionary<int, string> d1;\n    public static char[,] map;\n    public static int h, w;\n    public static int[] dx, dy;\n\n    public static void Main()\n    {\n        d0 = new Dictionary<char, int>() { { 'R', 0 }, { 'D', 1 }, { 'L', 2 }, { 'U', 3 } };\n        d1 = new Dictionary<int, string>() { { 0, \"R\" }, { 1, \"D\" }, { 2, \"L\" }, { 3, \"U\" } };\n        dx = new int[] { 0, 1, 0, -1 };\n        dy = new int[] { 1, 0, -1, 0 };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        h = int.Parse(line[0]);\n        w = int.Parse(line[1]);\n        map = new char[h, w];\n        var sx = 0; var sy = 0; var sd = -1;\n        var Lc = 0;\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n            {\n                if (s[j] != 'o' && s[j] != '.')\n                {\n                    sx = i;\n                    sy = j;\n                    sd = d0[s[j]];\n                    map[i, j] = '.';\n                }\n                else\n                {\n                    map[i, j] = s[j];\n                    if (s[j] == 'o') Lc++;\n                }\n            }\n        }\n        goDfs(sx, sy, sd, Lc, \"\");\n    }\n    static void goDfs(int x, int y, int d, int Lc, string via)\n    {\n        if (Lc == 0) { Console.WriteLine(via); return; }\n        var tw = getLeaf(x, y, d);\n        if (tw != -1)\n        {\n            map[x, y] = '.';\n            if (d == 0 | d == 2) goDfs(x, tw, d, Lc - 1, via + d1[d]);\n            else goDfs(tw, y, d, Lc - 1, via + d1[d]);\n            map[x, y] = 'o';\n        }\n        var td2 = d + 1;\n        if (td2 > 3) td2 -= 4;\n        tw = getLeaf(x, y, td2);\n        if (tw != -1)\n        {\n            map[x, y] = '.';\n            if (td2 == 0 | td2 == 2) goDfs(x, tw, td2, Lc - 1, via + d1[td2]);\n            else goDfs(tw, y, td2, Lc - 1, via + d1[td2]);\n            map[x, y] = 'o';\n        }\n        var td3 = d - 1;\n        if (td3 < 0) td3 += 4;\n        tw = getLeaf(x, y, td3);\n        if (tw != -1)\n        {\n            map[x, y] = '.';\n            if (td3 == 0 | td3 == 2) goDfs(x, tw, td3, Lc - 1, via + d1[td3]);\n            else goDfs(tw, y, td3, Lc - 1, via + d1[td3]);\n            map[x, y] = 'o';\n        }\n    }\n    static int getLeaf(int x, int y, int d)\n    {\n        while (true)\n        {\n            var nx = x + dx[d];\n            var ny = y + dy[d];\n            if (nx < 0 | nx >= h | ny < 0 | ny >= w) return -1;\n            if (map[nx, ny] == 'o')\n            {\n                if (d == 0 | d == 2) return ny;\n                else return nx;\n            }\n            x = nx;\n            y = ny;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public int d { get; set; }\n    public string via { get; set; }\n    public int count { get; set; }\n}\n\npublic class hello\n{\n    public static Dictionary<char, int> d0;\n    public static Dictionary<int, string> d1;\n    public static char[,] map;\n    public static int h, w;\n\n    public static void Main()\n    {\n        d0 = new Dictionary<char, int>() { { 'R', 0 }, { 'D', 1 }, { 'L', 2 }, { 'U', 3 } };\n        d1 = new Dictionary<int, string>() { { 0, \"R\" }, { 1, \"D\" }, { 2, \"L\" }, { 3, \"U\" } };\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        h = int.Parse(line[0]);\n        w = int.Parse(line[1]);\n        map = new char[h, w];\n        var sx = 0; var sy = 0; var sd = -1;\n        var Lc = 0;\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++)\n            {\n                if (s[j] != 'o' && s[j] != '.')\n                {\n                    sx = i;\n                    sy = j;\n                    sd = d0[s[j]];\n                    map[i, j] = '.';\n                }\n                else\n                {\n                    map[i, j] = s[j];\n                    if (s[j] == 'o') Lc++;\n                }\n            }\n        }\n        goDfs(sx, sy, sd, Lc, \"\");\n    }\n    static void goDfs(int x, int y, int d, int Lc, string via)\n    {\n        if (Lc == 0) { Console.WriteLine(via); return; }\n        var tw = getLeaf(x, y, d);\n        if (tw != -1)\n        {\n            map[x, y] = '.';\n            if (d == 0 | d == 2) goDfs(x, tw, d, Lc - 1, via + d1[d]);\n            else goDfs(tw, y, d, Lc - 1, via + d1[d]);\n            map[x, y] = 'o';\n        }\n        var td2 = d + 1;\n        if (td2 > 3) td2 -= 4;\n        tw = getLeaf(x, y, td2);\n        if (tw != -1)\n        {\n            map[x, y] = '.';\n            if (td2 == 0 | td2 == 2) goDfs(x, tw, td2, Lc - 1, via + d1[td2]);\n            else goDfs(tw, y, td2, Lc - 1, via + d1[td2]);\n            map[x, y] = 'o';\n        }\n        var td3 = d - 1;\n        if (td3 < 0) td3 += 4;\n        tw = getLeaf(x, y, td3);\n        if (tw != -1)\n        {\n            map[x, y] = '.';\n            if (td3 == 0 | td3 == 2) goDfs(x, tw, td3, Lc - 1, via + d1[td3]);\n            else goDfs(tw, y, td3, Lc - 1, via + d1[td3]);\n            map[x, y] = 'o';\n        }\n    }\n    static int getLeaf(int x, int y, int d)\n    {\n        var nx = x; var ny = y;\n        while (true)\n        {\n            if (d == 0) ny++;\n            else if (d == 1) nx++;\n            else if (d == 2) ny--;\n            else nx--;\n            if (nx < 0 | nx >= h | ny < 0 | ny >= w) return -1;\n            if (map[nx, ny] == 'o')\n            {\n                if (d == 0 | d == 2) return ny;\n                else return nx;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "U = 0\nR = 1\nD = 2\nL = 3\n\ndx = [0, 1, 0, -1]\ndy = [-1, 0, 1, 0]\n\nh, w = gets.split.map(&:to_i)\n\na = (1..h).map { gets.chomp }\ny0 = x0 = nil\n\ndir = nil\n(0..h-1).each do |i|\n    (0..w-1).each do |j|\n        if a[i][j] =~ /[URDL]/\n            dir = eval(a[i][j])\n            y0 = i\n            x0 = j\n            a[i][j] = ?.\n        end\n    end\nend\n\npond = a.reverse.map(&:reverse).join.tr('.o', '01').to_i(2)\n\ndef encode(pond, dir, x, y)\n    (pond << 10) + (dir << 8) + (x << 4) + y\nend\n\ndef decode(state)\n    [(state >> 10), (state >> 8) & 0b11, (state >> 4) & 0b1111, state & 0b1111]\nend\n\nstart_state = encode(pond, dir, x0, y0)\n\nstack = [start_state]\n\nprev_state = {start_state => start_state}\ngoal = nil\n\ncatch(:finish) do\n    loop do\n        state = stack.pop\n        pond, dir, x0, y0 = decode(state)\n\n        dirs = [dir-1, dir, dir+1].map {|x| x % 4}\n        dirs.each do |new_dir|\n            x, y = x0, y0\n            catch(:break) do\n                loop do\n                    x += dx[new_dir]\n                    y += dy[new_dir]\n                    throw(:break) if x < 0 || x >= w\n                    throw(:break) if y < 0 || y >= h\n                    break if pond[y * w + x] == 1\n                end\n                new_pond = pond - (1 << y * w + x)\n                new_state = encode(new_pond, new_dir, x, y)\n                if ! prev_state[new_state]\n                    prev_state[new_state] = state\n                    stack << new_state\n                end\n                if new_pond == 0\n                    goal = new_state\n                    throw(:finish)\n                end\n            end\n        end\n    end\nend\n\nv = goal\na = [?U, ?R, ?D, ?L]\nroute = []\nloop do\n    _, dir, _, _ = decode(v)\n    route << a[dir]\n    u = prev_state[v]\n    break if u == prev_state[u]\n    v = u\nend\nputs route.join.reverse"
  },
  {
    "language": "Ruby",
    "code": "$drc = [[0, 1], [0, -1], [1, 0], [-1, 0]]\ndef dfs(y, x, d, n)\n  return true if n == $max\n  $fld[y][x] = false\n  4.times do |i|\n    next if i == 'UDLR'.index(d)\n    ny, nx = y, x\n    loop do\n      nx += $drc[i][0]; ny += $drc[i][1]\n      break if $fld[ny][nx].nil?\n      if $fld[ny][nx]\n        $ans[n] = 'DURL'[i]\n        return true if dfs(ny, nx, 'DURL'[i], n + 1)\n        break\n      end\n    end\n  end\n  $fld[y][x] = true\n  false\nend\n\n\nsx = sy = 0; d = ''\nr, c = gets.split.map(&:to_i)\n$fld = r.times.map{ [] }\nr.times.each do |y|\n  l = gets.chomp.split('')\n  l.each do |a|\n    if a != '.' && a != 'o'\n      sx = l.index(a) + 1\n      sy = y + 1\n      d = a\n    end\n  end\n  $fld[y] = [nil, *l.map{ |a| a == '.' ? false : true }, nil]\nend\n$fld = [[nil] * (c + 2), *$fld, [nil] * (c + 2)]\n$max = $fld.flatten.count(true) - 1\n$ans = ['x'] * $max\ndfs(sy, sx, d, 0)\nputs $ans.join"
  },
  {
    "language": "Ruby",
    "code": "$drc = [[0, 1], [0, -1], [1, 0], [-1, 0]]\ndef dfs(y, x, d, n)\n  return true if n == $max\n  $fld[y][x] = false\n  4.times do |i|\n    next if i == 'UDLR'.index(d)\n    ny, nx = y, x\n    loop do\n      nx += $drc[i][0]; ny += $drc[i][1]\n      break if $fld[ny][nx].nil?\n      if $fld[ny][nx]\n        $ans[n] = 'DURL'[i]\n        return true if dfs(ny, nx, 'DURL'[i], n + 1)\n        break\n      end\n    end\n  end\n  $fld[y][x] = true\n  false\nend\n\n\nsx = sy = 0; d = ''\nr, c = gets.split.map(&:to_i)\n$fld = []\nr.times do |y|\n  l = gets.chomp.split('')\n  l.each do |a|\n    if a != '.' && a != 'o'\n      sx = l.index(a) + 1\n      sy = y + 1\n      d = a\n    end\n  end\n  $fld << [nil, *l.map{ |a| a == '.' ? false : true }, nil]\nend\n$fld = [[nil] * (c + 2), *$fld, [nil] * (c + 2)]\n$max = $fld.flatten.count(true) - 1\n$ans = ['x'] * $max\ndfs(sy, sx, d, 0)\nputs $ans.join"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    h,w = LI()\n    a = [[c for c in S()] for _ in range(h)]\n    s = None\n    lc = 0\n    for i in range(h):\n        for j in range(w):\n            c = a[i][j]\n            if c == '.':\n                continue\n            if c == 'o':\n                lc += 1\n                continue\n            s = (i,j,c)\n\n    def f(i,j,c,d):\n        if d == lc:\n            return (True, '')\n        a[i][j] = '.'\n        if c != 'U':\n            for k in range(i+1,h):\n                if a[k][j] == 'o':\n                    rf,rs = f(k,j,'D',d+1)\n                    if rf:\n                        return (True, 'D' + rs)\n                    break\n        if c != 'D':\n            for k in range(i-1,-1,-1):\n                if a[k][j] == 'o':\n                    rf,rs = f(k,j,'U',d+1)\n                    if rf:\n                        return (True, 'U' + rs)\n                    break\n        if c != 'L':\n            for k in range(j+1,w):\n                if a[i][k] == 'o':\n                    rf,rs = f(i,k,'R',d+1)\n                    if rf:\n                        return (True, 'R' + rs)\n                    break\n        if c != 'R':\n            for k in range(j-1,-1,-1):\n                if a[i][k] == 'o':\n                    rf,rs = f(i,k,'L',d+1)\n                    if rf:\n                        return (True, 'L' + rs)\n                    break\n\n        a[i][j] = 'o'\n        return (False, None)\n\n    rf,rs = f(s[0],s[1],s[2],0)\n    return rs\n\n\nprint(main())\n\n"
  }
]