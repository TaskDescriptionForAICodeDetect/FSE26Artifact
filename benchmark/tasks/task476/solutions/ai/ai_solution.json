[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_LAIRS 1000\n\ntypedef struct {\n    int x, y, foxes;\n} Lair;\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    Lair lairs[MAX_LAIRS];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &lairs[i].x, &lairs[i].y, &lairs[i].foxes);\n    }\n    \n    int max_numerator = 0, max_denominator = 1;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int x1 = lairs[i].x, y1 = lairs[i].y;\n            int x2 = lairs[j].x, y2 = lairs[j].y;\n            \n            if (x1 == x2 || y1 == y2) continue;\n            \n            int area = abs((x1 - x2) * (y1 - y2));\n            if (area == 0) continue;\n            \n            int fox_count = 0;\n            for (int k = 0; k < N; k++) {\n                int x = lairs[k].x, y = lairs[k].y;\n                if ((x1 <= x && x <= x2 || x2 <= x && x <= x1) &&\n                    (y1 <= y && y <= y2 || y2 <= y && y <= y1)) {\n                    fox_count += lairs[k].foxes;\n                }\n            }\n            \n            int curr_numerator = fox_count;\n            int curr_denominator = area;\n            \n            int g = gcd(curr_numerator, curr_denominator);\n            curr_numerator /= g;\n            curr_denominator /= g;\n            \n            if ((long long)curr_numerator * max_denominator > \n                (long long)max_numerator * curr_denominator) {\n                max_numerator = curr_numerator;\n                max_denominator = curr_denominator;\n            }\n        }\n    }\n    \n    printf(\"%d/%d\\n\", max_numerator, max_denominator);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y, count;\n} Lair;\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nvoid simplify_fraction(int *numerator, int *denominator) {\n    int common_divisor = gcd(abs(*numerator), abs(*denominator));\n    *numerator /= common_divisor;\n    *denominator /= common_divisor;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Lair *lairs = (Lair *)malloc(N * sizeof(Lair));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &lairs[i].x, &lairs[i].y, &lairs[i].count);\n    }\n\n    int max_num = 0, max_den = 1;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int x1 = lairs[i].x, y1 = lairs[i].y;\n            int x2 = lairs[j].x, y2 = lairs[j].y;\n            if (x1 == x2 || y1 == y2) continue;\n\n            int min_x = (x1 < x2) ? x1 : x2;\n            int max_x = (x1 > x2) ? x1 : x2;\n            int min_y = (y1 < y2) ? y1 : y2;\n            int max_y = (y1 > y2) ? y1 : y2;\n\n            int total = 0;\n            for (int k = 0; k < N; k++) {\n                int x = lairs[k].x, y = lairs[k].y;\n                if (x >= min_x && x <= max_x && y >= min_y && y <= max_y) {\n                    total += lairs[k].count;\n                }\n            }\n\n            int area = (max_x - min_x) * (max_y - min_y);\n            int current_num = total;\n            int current_den = area;\n\n            if (current_den == 0) continue;\n\n            simplify_fraction(&current_num, &current_den);\n\n            if ((long long)current_num * max_den > (long long)max_num * current_den) {\n                max_num = current_num;\n                max_den = current_den;\n            }\n        }\n    }\n\n    printf(\"%d/%d\\n\", max_num, max_den);\n    free(lairs);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    int foxes;\n};\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nvoid simplify_fraction(long long &numerator, long long &denominator) {\n    long long common_divisor = gcd(abs(numerator), abs(denominator));\n    numerator /= common_divisor;\n    denominator /= common_divisor;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    map<pair<int, int>, int> point_to_foxes;\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y >> points[i].foxes;\n        point_to_foxes[{points[i].x, points[i].y}] += points[i].foxes;\n    }\n    \n    long long max_numerator = 0;\n    long long max_denominator = 1;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int x1 = min(points[i].x, points[j].x);\n            int x2 = max(points[i].x, points[j].x);\n            int y1 = min(points[i].y, points[j].y);\n            int y2 = max(points[i].y, points[j].y);\n            \n            if (x1 == x2 || y1 == y2) continue;\n            \n            long long area = (long long)(x2 - x1) * (y2 - y1);\n            long long total_foxes = 0;\n            \n            for (const auto &point : points) {\n                if (point.x >= x1 && point.x <= x2 && point.y >= y1 && point.y <= y2) {\n                    total_foxes += point.foxes;\n                }\n            }\n            \n            if (total_foxes * max_denominator > max_numerator * area) {\n                max_numerator = total_foxes;\n                max_denominator = area;\n            }\n        }\n    }\n    \n    if (max_numerator == 0) {\n        cout << \"0/1\" << endl;\n    } else {\n        simplify_fraction(max_numerator, max_denominator);\n        cout << max_numerator << \"/\" << max_denominator << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.BigInteger;\n\npublic class FoxSensors {\n    static class Point {\n        int x, y, count;\n\n        Point(int x, int y, int count) {\n            this.x = x;\n            this.y = y;\n            this.count = count;\n        }\n    }\n\n    static class Fraction {\n        BigInteger numerator, denominator;\n\n        Fraction(BigInteger num, BigInteger den) {\n            BigInteger gcd = num.gcd(den);\n            this.numerator = num.divide(gcd);\n            this.denominator = den.divide(gcd);\n        }\n\n        boolean isGreaterThan(Fraction other) {\n            return this.numerator.multiply(other.denominator).compareTo(other.numerator.multiply(this.denominator)) > 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        Point[] points = new Point[N];\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int count = scanner.nextInt();\n            points[i] = new Point(x, y, count);\n        }\n\n        Fraction maxFraction = new Fraction(BigInteger.ZERO, BigInteger.ONE);\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int x1 = Math.min(points[i].x, points[j].x);\n                int x2 = Math.max(points[i].x, points[j].x);\n                int y1 = Math.min(points[i].y, points[j].y);\n                int y2 = Math.max(points[i].y, points[j].y);\n\n                if (x1 == x2 || y1 == y2) continue;\n\n                BigInteger area = BigInteger.valueOf(x2 - x1).multiply(BigInteger.valueOf(y2 - y1));\n                BigInteger total = BigInteger.ZERO;\n\n                for (Point p : points) {\n                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {\n                        total = total.add(BigInteger.valueOf(p.count));\n                    }\n                }\n\n                Fraction current = new Fraction(total, area);\n                if (current.isGreaterThan(maxFraction)) {\n                    maxFraction = current;\n                }\n            }\n        }\n\n        System.out.println(maxFraction.numerator + \"/\" + maxFraction.denominator);\n    }\n}",
    "timestamp": "2025-08-05 21:51:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FoxSensorPlacement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        List<int[]> lairs = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int foxCount = scanner.nextInt();\n            lairs.add(new int[]{x, y, foxCount});\n        }\n        \n        double maxRatio = 0;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int x1 = lairs.get(i)[0];\n                int y1 = lairs.get(i)[1];\n                int x2 = lairs.get(j)[0];\n                int y2 = lairs.get(j)[1];\n                \n                if (x1 == x2 || y1 == y2) continue;\n                \n                int foxesInRectangle = 0;\n                int minX = Math.min(x1, x2);\n                int maxX = Math.max(x1, x2);\n                int minY = Math.min(y1, y2);\n                int maxY = Math.max(y1, y2);\n                \n                for (int[] lair : lairs) {\n                    if (lair[0] >= minX && lair[0] <= maxX && \n                        lair[1] >= minY && lair[1] <= maxY) {\n                        foxesInRectangle += lair[2];\n                    }\n                }\n                \n                double rectangleArea = Math.abs(x1 - x2) * Math.abs(y1 - y2);\n                double currentRatio = foxesInRectangle / rectangleArea;\n                \n                maxRatio = Math.max(maxRatio, currentRatio);\n            }\n        }\n        \n        int[] simplified = simplifyFraction(maxRatio);\n        System.out.println(simplified[0] + \"/\" + simplified[1]);\n    }\n    \n    private static int[] simplifyFraction(double ratio) {\n        long numerator = (long) (ratio * 1000000);\n        long denominator = 1000000;\n        \n        long gcd = findGCD(numerator, denominator);\n        \n        return new int[]{(int)(numerator / gcd), (int)(denominator / gcd)};\n    }\n    \n    private static long findGCD(long a, long b) {\n        return b == 0 ? a : findGCD(b, a % b);\n    }\n}",
    "timestamp": "2025-08-05 21:51:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\n\nstruct Lair {\n    int x, y, foxes;\n};\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<Lair> lairs(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> lairs[i].x >> lairs[i].y >> lairs[i].foxes;\n    }\n    \n    int maxNumerator = 0, maxDenominator = 1;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                if (k == i || k == j) continue;\n                \n                for (int l = k + 1; l < N; ++l) {\n                    if (l == i || l == j) continue;\n                    \n                    int x1 = lairs[i].x, y1 = lairs[i].y;\n                    int x2 = lairs[j].x, y2 = lairs[j].y;\n                    int x3 = lairs[k].x, y3 = lairs[k].y;\n                    int x4 = lairs[l].x, y4 = lairs[l].y;\n                    \n                    if ((x1 - x2) * (y3 - y4) == (x3 - x4) * (y1 - y2)) continue;\n                    \n                    int minX = min({x1, x2, x3, x4});\n                    int maxX = max({x1, x2, x3, x4});\n                    int minY = min({y1, y2, y3, y4});\n                    int maxY = max({y1, y2, y3, y4});\n                    \n                    int foxCount = 0;\n                    for (const auto& lair : lairs) {\n                        if (lair.x >= minX && lair.x <= maxX && \n                            lair.y >= minY && lair.y <= maxY) {\n                            foxCount += lair.foxes;\n                        }\n                    }\n                    \n                    int area = abs((x1 - x2) * (y1 - y2));\n                    \n                    if (foxCount * maxDenominator > maxNumerator * area) {\n                        maxNumerator = foxCount;\n                        maxDenominator = area;\n                    }\n                }\n            }\n        }\n    }\n    \n    int g = gcd(maxNumerator, maxDenominator);\n    cout << maxNumerator / g << \"/\" << maxDenominator / g << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from fractions import Fraction\nfrom itertools import combinations\n\ndef max_fox_ratio(lair_data):\n    sensors = []\n    for (x, y, _) in lair_data:\n        sensors.append((x, y))\n    sensor_combinations = list(combinations(sensors, 2))\n\n    max_value = Fraction(0, 1)\n    \n    for (x1, y1), (x2, y2) in sensor_combinations:\n        if x1 == x2 or y1 == y2:\n            continue\n            \n        x_min, x_max = min(x1, x2), max(x1, x2)\n        y_min, y_max = min(y1, y2), max(y1, y2)\n\n        fox_count = sum(fox for (x, y, fox) in lair_data if x_min <= x <= x_max and y_min <= y <= y_max)\n        area = abs(x1 - x2) * abs(y1 - y2)\n        \n        ratio = Fraction(fox_count, area)\n\n        if ratio > max_value:\n            max_value = ratio\n\n    return f\"{max_value.numerator}/{max_value.denominator}\"\n\n# Example usage:\nlair_data = [\n    (1, 1, 3),\n    (2, 2, 5),\n    (3, 3, 2),\n    (4, 4, 4)\n]\n\nprint(max_fox_ratio(lair_data))",
    "timestamp": "2025-08-13 07:45:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.math.*;\n\npublic class FoxObservation {\n\n    static class Lair {\n        int x, y, count;\n\n        Lair(int x, int y, int count) {\n            this.x = x;\n            this.y = y;\n            this.count = count;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        List<Lair> lairs = new ArrayList<>();\n        Set<Integer> xCoords = new TreeSet<>();\n        Set<Integer> yCoords = new TreeSet<>();\n\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int count = sc.nextInt();\n            lairs.add(new Lair(x, y, count));\n            xCoords.add(x);\n            yCoords.add(y);\n        }\n\n        Integer[] uniqueX = xCoords.toArray(new Integer[0]);\n        Integer[] uniqueY = yCoords.toArray(new Integer[0]);\n\n        int maxNum = 0;\n        int maxDen = 1;\n\n        for (int i = 0; i < uniqueX.length; i++) {\n            for (int j = i + 1; j < uniqueX.length; j++) {\n                for (int k = 0; k < uniqueY.length; k++) {\n                    for (int l = k + 1; l < uniqueY.length; l++) {\n                        int x1 = uniqueX[i];\n                        int x2 = uniqueX[j];\n                        int y1 = uniqueY[k];\n                        int y2 = uniqueY[l];\n\n                        int num = 0;\n                        int den = Math.abs(x1 - x2) * Math.abs(y1 - y2);\n\n                        for (Lair lair : lairs) {\n                            if (lair.x > x1 && lair.x < x2 && lair.y > y1 && lair.y < y2) {\n                                num += lair.count;\n                            }\n                        }\n\n                        if (num * maxDen > maxNum * den) {\n                            maxNum = num;\n                            maxDen = den;\n                        }\n                    }\n                }\n            }\n        }\n\n        int gcd = gcd(maxNum, maxDen);\n\n        System.out.println((maxNum / gcd) + \"/\" + (maxDen / gcd));\n\n        sc.close();\n    }\n\n    private static int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n}",
    "timestamp": "2025-08-13 07:45:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, count;\n} Lair;\n\nint gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    int n, i, j, k, maxFoxes = 0;\n    Lair *lairs;\n    int x1, y1, x2, y2;\n    int totalFoxes;\n    int denominator;\n    int bestNumerator = 0, bestDenominator = 1;\n\n    scanf(\"%d\", &n);\n    lairs = malloc(n * sizeof(Lair));\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &lairs[i].x, &lairs[i].y, &lairs[i].count);\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            x1 = lairs[i].x;\n            y1 = lairs[i].y;\n            x2 = lairs[j].x;\n            y2 = lairs[j].y;\n\n            if (x1 == x2 || y1 == y2)\n                continue;\n\n            totalFoxes = 0;\n            for (k = 0; k < n; k++) {\n                if ((lairs[k].x > x1 && lairs[k].x < x2) || (lairs[k].x > x2 && lairs[k].x < x1)) {\n                    if ((lairs[k].y > y1 && lairs[k].y < y2) || (lairs[k].y > y2 && lairs[k].y < y1)) {\n                        totalFoxes += lairs[k].count;\n                    }\n                }\n            }\n\n            denominator = abs(x1 - x2) * abs(y1 - y2);\n            if (totalFoxes * bestDenominator > bestNumerator * denominator) {\n                bestNumerator = totalFoxes;\n                bestDenominator = denominator;\n            }\n        }\n    }\n\n    int divisor = gcd(bestNumerator, bestDenominator);\n    bestNumerator /= divisor;\n    bestDenominator /= divisor;\n\n    printf(\"%d/%d\\n\", bestNumerator, bestDenominator);\n\n    free(lairs);\n    return 0;\n}",
    "timestamp": "2025-08-13 07:45:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nfrom math import gcd\n\ndef solve_fox_sensor_placement(fox_lairs):\n    max_ratio_numerator = 0\n    max_ratio_denominator = 1\n\n    for (x1, y1), (x2, y2) in combinations(fox_lairs.keys(), 2):\n        rect_width = abs(x1 - x2)\n        rect_height = abs(y1 - y2)\n        \n        if rect_width == 0 or rect_height == 0:\n            continue\n\n        fox_count = sum(\n            foxes for (x, y), foxes in fox_lairs.items()\n            if min(x1, x2) <= x <= max(x1, x2) and min(y1, y2) <= y <= max(y1, y2)\n        )\n\n        current_numerator = fox_count\n        current_denominator = rect_width * rect_height\n\n        if current_numerator * max_ratio_denominator > max_ratio_numerator * current_denominator:\n            max_ratio_numerator = current_numerator\n            max_ratio_denominator = current_denominator\n\n    divisor = gcd(max_ratio_numerator, max_ratio_denominator)\n    return f\"{max_ratio_numerator // divisor}/{max_ratio_denominator // divisor}\"",
    "timestamp": "2025-08-13 07:46:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nfrom collections import defaultdict\n\ndef solve():\n    N = int(input())\n    points = []\n    x_coords = set()\n    y_coords = set()\n    fox_counts = defaultdict(int)\n    \n    for _ in range(N):\n        x, y, w = map(int, input().split())\n        points.append((x, y, w))\n        x_coords.add(x)\n        y_coords.add(y)\n        fox_counts[(x, y)] += w\n    \n    sorted_x = sorted(x_coords)\n    sorted_y = sorted(y_coords)\n    \n    # Create a prefix sum matrix\n    prefix = [[0] * (len(sorted_y) + 1) for _ in range(len(sorted_x) + 1)]\n    \n    # Map x and y to their indices for the prefix matrix\n    x_to_idx = {x: i for i, x in enumerate(sorted_x, 1)}\n    y_to_idx = {y: i for i, y in enumerate(sorted_y, 1)}\n    \n    # Fill the prefix sum matrix\n    for x, y, w in points:\n        i = x_to_idx[x]\n        j = y_to_idx[y]\n        prefix[i][j] += w\n    \n    # Compute 2D prefix sums\n    for i in range(1, len(sorted_x) + 1):\n        row_sum = 0\n        for j in range(1, len(sorted_y) + 1):\n            row_sum += prefix[i][j]\n            prefix[i][j] = prefix[i-1][j] + row_sum\n    \n    max_numerator = 0\n    min_denominator = 1\n    \n    # Iterate all possible pairs of x and y coordinates\n    for i1 in range(1, len(sorted_x) + 1):\n        for j1 in range(1, sorted_y + 1):\n            for i2 in range(i1, len(sorted_x) + 1):\n                for j2 in range(j1, len(sorted_y) + 1):\n                    x1 = sorted_x[i1 - 1]\n                    x2 = sorted_x[i2 - 1]\n                    y1 = sorted_y[j1 - 1]\n                    y2 = sorted_y[j2 - 1]\n                    dx = x2 - x1\n                    dy = y2 - y1\n                    if dx == 0 or dy == 0:\n                        continue\n                    denominator = dx * dy\n                    # Calculate the sum using the prefix matrix\n                    total = prefix[i2][j2] - prefix[i1-1][j2] - prefix[i2][j1-1] + prefix[i1-1][j1-1]\n                    if total * min_denominator > max_numerator * denominator:\n                        max_numerator = total\n                        min_denominator = denominator\n    \n    if max_numerator == 0:\n        print(\"0/1\")\n    else:\n        g = math.gcd(max_numerator, min_denominator)\n        print(f\"{max_numerator // g}/{min_denominator // g}\")\n\nsolve()",
    "timestamp": "2025-08-13 07:46:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <limits>\n\nusing namespace std;\n\nstruct Lair {\n    int x, y, foxes;\n};\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nvoid simplifyFraction(int &numerator, int &denominator) {\n    int divisor = gcd(numerator, denominator);\n    numerator /= divisor;\n    denominator /= divisor;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Lair> lairs(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> lairs[i].x >> lairs[i].y >> lairs[i].foxes;\n    }\n    \n    int maxNumerator = 0;\n    int minDenominator = 1;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (lairs[i].x == lairs[j].x || lairs[i].y == lairs[j].y) continue;\n            \n            int x1 = min(lairs[i].x, lairs[j].x);\n            int x2 = max(lairs[i].x, lairs[j].x);\n            int y1 = min(lairs[i].y, lairs[j].y);\n            int y2 = max(lairs[i].y, lairs[j].y);\n            \n            int currentDenominator = (x2 - x1) * (y2 - y1);\n            int currentNumerator = 0;\n            \n            for (const auto &lair : lairs) {\n                if (lair.x > x1 && lair.x < x2 && lair.y > y1 && lair.y < y2) {\n                    currentNumerator += lair.foxes;\n                }\n            }\n            \n            if (currentNumerator * minDenominator > maxNumerator * currentDenominator) {\n                maxNumerator = currentNumerator;\n                minDenominator = currentDenominator;\n            }\n        }\n    }\n    \n    simplifyFraction(maxNumerator, minDenominator);\n    cout << maxNumerator << \"/\" << minDenominator << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:43"
  }
]