[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint dy[4] = {0,0,1,1};\nint dx[4] = {0,1,0,1};\n\nint main(){\n    int n;\n    cin >> n;\n\n    map<pair<int, int>,int> m;\n    rep(i,n){\n        int x, y, w;\n        cin >> x >> y >> w;\n        m[make_pair(x,y)] = w;\n    }\n\n    int maxi = 0;\n    for(auto it:m){\n        int sum = 0;\n        rep(i,4){\n            if(m.count(make_pair(it.first.first + dx[i], it.first.second + dy[i]))){\n                sum += m[ make_pair(it.first.first + dx[i], it.first.second + dy[i]) ];\n            }\n        }\n        maxi = max(maxi, sum);\n    }\n    cout << maxi << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<map>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    map<pair<int,int>,int>mp;\n    for(int i=0;i<n;i++){\n        int x,y,w;\n        cin >> x >> y >> w;\n        mp[make_pair(x,y)]=w;\n        mp[make_pair(x-1,y)]=mp[make_pair(x-1,y)];\n        mp[make_pair(x,y-1)]=mp[make_pair(x,y-1)];\n        mp[make_pair(x-1,y-1)]=mp[make_pair(x-1,y-1)];\n    }\n    int ans =0;\n    for(auto x:mp){\n        int a = 0;\n        a += x.second;\n        int s = x.first.first;\n        int t = x.first.second;\n        if(mp.find(make_pair(s,t+1))!=mp.end())a += mp[make_pair(s,t+1)];\n        \n        if(mp.find(make_pair(s+1,t+1))!=mp.end())a += mp[make_pair(s+1,t+1)];\n        \n        if(mp.find(make_pair(s+1,t))!=mp.end())a += mp[make_pair(s+1,t)];\n        ans = max(ans,a);\n    }\n    cout << ans << \" / \" << 1 << endl; \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) inputs(int, __VA_ARGS__)\n#define LL(...) inputs(ll, __VA_ARGS__)\n#define STR(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nvector<vector<PII>> D{\n\t{{0,0},{-1,0},{-1,-1},{0,-1}},\n\t{{0,0},{ 1,0},{ 1,-1},{0,-1}},\n\t{{0,0},{-1,0},{-1, 1},{0, 1}},\n\t{{0,0},{ 1,0},{ 1, 1},{0, 1}},\n};\n\nint main() {\n\tint n = in;\n\tmap<PII, ll> m;\n\trep(i, n) {\n\t\tint x, y; ll w;\n\t\tin(x, y, w);\n\t\tm[make_pair(x, y)] = w;\n\t}\n\n\tll ans = 0;\n\tfor (auto P : m) {\n\t\tfor (const auto& v : D) {\n\t\t\tll sum = 0;\n\t\t\tfor (const auto& d : v) {\n\t\t\t\tPII p(P.first.first + d.first, P.first.second + d.second);\n\t\t\t\tif (m.count(p))sum += m[p];\n\t\t\t}\n\t\t\tchmax(ans, sum);\n\t\t}\n\t}\n\tout(ans, '/', 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        cin >> W[make_pair(x, y)];\n    }\n\n    int ans = 0;\n    for (auto pp : W) {\n        int x, y;\n        tie(x, y) = pp.first;\n\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x + dx, y + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n\n        sum = 0;\n        for (int dx = -1; dx <= 0; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x + dx, y + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n    vector<int> x(n),y(n),w(n);\n    rep(i,n) scanf(\" %d %d %d\", &x[i], &y[i], &w[i]);\n\n    map<pi,int> m;\n    rep(i,n) m[pi(x[i],y[i])] = w[i];\n\n    int ans = 0;\n    rep(i,n)\n    {\n        int dx[3]={0,1,1}, dy[4]={1,1,0};\n        rep(j,4)\n        {\n            int W = w[i];\n            rep(k,3)\n            {\n                int nx = x[i]+dx[k], ny = y[i]+dy[k];\n                pi p(nx,ny);\n                if(m.count(p)) W += m[p];\n            }\n            ans = max(ans,W);\n\n            if(j%2==0) rep(k,3) dx[k] = -dx[k];\n            else rep(k,3) dy[k] = -dy[k];\n        }\n    }\n\n    printf(\"%d / 1\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define f first\n#define s second\nusing namespace std;\n\nint main()\n{\n  int N,x,y,w;\n  map<pair<int,int>,int> M;\n  vector<pair<int,int> > V; \n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x>>y>>w;\n    M[make_pair(x,y)]=w;\n    V.push_back(make_pair(x,y));\n  }\n  int ans=0,sum;\n  for(int i=0;i<N;i++){\n    sum=M[make_pair(V[i].f,V[i].s)];\n    sum+=M[make_pair(V[i].f,V[i].s+1)];\n    sum+=M[make_pair(V[i].f+1,V[i].s)];\n    sum+=M[make_pair(V[i].f+1,V[i].s+1)];\n    ans=max(ans,sum);\n    sum=M[make_pair(V[i].f,V[i].s)];\n    sum+=M[make_pair(V[i].f,V[i].s-1)];\n    sum+=M[make_pair(V[i].f+1,V[i].s)];\n    sum+=M[make_pair(V[i].f+1,V[i].s-1)];\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / 1\"<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<ll,int>ma;\nvvi in;\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[a*1000000001ll+b]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d=1;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)if(ma.count(i*1000000001ll+j))sum+=ma[i*1000000001ll+j];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info1{\n\tInfo1(int arg_x,int arg_y,int arg_w){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info1 &arg) const{\n\t\t\treturn y < arg.y;\n\t};\n\tint x,y,w;\n};\n\nstruct Info2{\n\tInfo2(int arg_x,int arg_w){\n\t\tx = arg_x;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info2 &arg) const{\n\t\t\treturn x > arg.x;\n\t};\n\tint x,w;\n};\n\nint main(){\n\n\tint N,tmp_x,tmp_y,tmp_w,pre_y,pre_x,index = -1,self,ans = 0,right;\n\tscanf(\"%d\",&N);\n\n\tint* Y_VALUE = new int[N];\n\n\tpriority_queue<Info1> Q;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d\",&tmp_x,&tmp_y,&tmp_w);\n\t\tQ.push(Info1(tmp_x,tmp_y,tmp_w));\n\t}\n\n\tvector<Info2> V[N];\n\n\tpre_y = BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().y != pre_y){\n\t\t\tindex++;\n\t\t\tY_VALUE[index] = Q.top().y;\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}else{\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}\n\t\tpre_y = Q.top().y;\n\t\tQ.pop();\n\t}\n\tindex++;\n\n\tfor(int i = 0; i < index; i++)sort(V[i].begin(),V[i].end());\n\n\tpre_y = pre_x = BIG_NUM;\n\n\tint l,r,m,loc;\n\n\tfor(int i = 0; i < index; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\n\t\t\tif(pre_y == i && pre_x == V[i][k].x-1){\n\t\t\t\tself = right;\n\t\t\t}else{\n\t\t\t\tif(i == index - 1 || Y_VALUE[i] - Y_VALUE[i+1] > 1){\n\t\t\t\t\tans = max(ans,V[i][k].w);\n\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t}else{\n\t\t\t\t\tl = 0;\n\t\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\t\twhile(l <= r){\n\t\t\t\t\t\tif(V[i+1][m].x == V[i][k].x || V[i+1][m].x == V[i][k].x-1){\n\t\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(loc == BIG_NUM){\n\t\t\t\t\t\tans = max(ans,V[i][k].w);\n\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][loc].x == V[i][k].x){\n\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc].w;\n\t\t\t\t\t\t\tif(loc > 0 && V[i+1][loc-1].x == V[i][k].w - 1){\n\t\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc-1].w);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tans = max(ans,self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(loc < V[i+1].size()-1 && V[i+1][loc+1].x == V[i][k].x){\n\t\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc+1].w;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc].w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(k < V[i].size()-1 && V[i][k+1].x == V[i][k].x+1){\n\t\t\t\tright = V[i][k+1].w;\n\t\t\t}else{\n\t\t\t\tright = 0;\n\t\t\t}\n\n\t\t\tif(i < index-1 && Y_VALUE[i+1] == Y_VALUE[i]-1){\n\t\t\t\tl = 0;\n\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\tm = (l+r)/2;\n\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\twhile(l <= r){\n\t\t\t\t\tif(V[i+1][m].x == V[i][k].x+1){\n\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(loc != BIG_NUM)right += V[i+1][loc].w;\n\t\t\t}\n\n\t\t\tans = max(ans,self+right);\n\n\t\t\tpre_y = i;\n\t\t\tpre_x = V[i][k].x;\n\t\t}\n\t}\n\n\tprintf(\"%d / 1\\n\",ans);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "n = gets.to_i\nc = Hash.new(0)\nn.times do\n    x, y, w = gets.split.map(&:to_i)\n    c[[x,y]] = w\nend\nmax = 0\nc.each do |k,v|\n    sum = v + c[[k[0]+1, k[1]]] + c[[k[0], k[1]+1]] + c[[k[0]+1, k[1]+1]]\n    max = sum if sum > max\nend\nputs \"#{max} / 1\""
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing pr = pair<int, int>;\n\nint n;\nmap<pr, int> g;\n\nint main()\n{\n\tcin >> n;\n\tvector<pr> ps;\n\trep(i, n){\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tg[pr(x, y)] = w;\n\t\trep(j, 2) rep(k, 2){\n\t\t\tps.eb(x - j, y - k);\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor (pr p : ps){\n\t\tint s = 0;\n\t\trep(i, 2) rep(j, 2){\n\t\t\tif (g.count(pr(p.fi + i, p.se + j))){\n\t\t\t\ts += g[pr(p.fi + i, p.se + j)];\n\t\t\t}\n\t\t}\n\t\tchmax(res, s);\n\t}\n\n\tcout << res << \" / \" << 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Pair = pair<int, int>;\n\nint N;\nvector<Pair> ps;\nmap<Pair, int> mp;\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    int x, y, w;\n    scanf(\"%d%d%d\", &x, &y, &w);\n    mp[Pair(x,y)] = w;\n    ps.emplace_back(Pair(x, y));\n  }\n\n  int ans = 0;\n  for (Pair p : ps) {\n    int x = p.first;\n    int y = p.second;\n    int t = mp[Pair(x, y)] + mp[Pair(x, y-1)] + mp[Pair(x-1, y)] + mp[Pair(x-1, y-1)];\n    int t2 = mp[Pair(x, y)] + mp[Pair(x, y-1)] + mp[Pair(x+1, y)] + mp[Pair(x+1, y-1)];\n    ans = max(ans, t);\n    ans = max(ans, t2);\n  }\n  printf(\"%d / 1\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n  int n;\n  cin>>n;\n\n  map<P,int> M;\n  for(int i=0,x,y,c;i<n;i++)cin>>x>>y>>c,M[P(x,y)] += c;\n\n  map<P,int>::iterator it;\n  int mx=0;\n  int dx[2][3] = {{1,1,0},{-1,-1,0}};\n  int dy[2][3] = {{0,1,1},{0,1,1}};\n  for(it=M.begin();it!=M.end();it++){\n    int x = it->first.first;\n    int y = it->first.second;\n    for(int k=0;k<2;k++){\n      int num = it->second;\n      for(int i=0;i<3;i++){\n\tint nx=x+dx[k][i];\n\tint ny=y+dy[k][i];\n\tif(!M.count(P(nx,ny)))continue;\n\tnum+=M[P(nx,ny)];\n      }\n      mx=max(mx,num);\n    }\n  }\n  cout<<mx<<\" / 1\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nconst int dx8[] = { -1,-1, 0, 1,1,1, 0,-1 }; const int dy8[] = { 0,1,1, 1, 0, -1,-1,-1 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tmap<pii, int> rab;\n\tREP(i, n) {\n\t\tint a, b, w;\n\t\tcin >> a >> b >> w;\n\t\trab[{a, b}] = w;\n\t}\n\tint ans = 0;\n\tfor (auto it = rab.begin();it != rab.end();it++) {\n\t\tint ma = 0;\n\t\tREP(j,4) {\n\t\t\tint sum=0;\n\t\t\tsum += it->second;\n\t\t\tif (rab.find({ it->first.first + dx8[(j * 2 + 1) % 8],it->first.second + dy8[(j * 2 + 1) % 8] }) != rab.end()) {\n\t\t\t\tsum += rab[{ it->first.first + dx8[(j * 2 + 1) % 8], it->first.second + dy8[(j * 2 + 1) % 8] }];\n\t\t\t}\n\t\t\tma = max(sum,ma);\n\t\t}\n\t\tans = max(ans, ma);\n\t}\n\tcout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\n\nusing P = pair<int,int>;\nP operator+(P const& a, P const& b) {\n    return {a.fst+b.fst, a.snd+b.snd};\n}\n\nint32_t main() {\n    int n; cin >> n;\n    vector<int> x(n),y(n),w(n);\n    rep (i,n) cin >> x[i] >> y[i] >> w[i];\n\n    map<pair<int,int>,int> cnt;\n    rep (i,n) cnt[mp(x[i],y[i])] = w[i];\n\n    int ma = 0;\n    rep (i,n) rep (dir,4) {\n        P p0 = {x[i],y[i]};\n        P A = {dx[dir],dy[dir]}, B = {dx[(dir+1)%4],dy[(dir+1)%4]};\n        P p1 = p0 + A, p2 = p0 + B, p3 = p0 + A + B;\n        chmax(ma, cnt[p0] + cnt[p1] + cnt[p2] + cnt[p3]);\n    }\n\n    cout << ma << \" / 1\" << endl;\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c;\nint dx[9] = { 0,1,1,1,0,-1,-1,-1,0 }, dy[9] = { 1,1,0,-1,-1,-1,0,1,0 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<0>(x[i]) + dy[j]) {\n\t\t\t\tmaxn = max(maxn, get<2>(x[i]) + get<2>(x[c]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nmap<int,map<int,int> > data;\nint n;\nint x[100001],y[100001],w[100001];\nint dx[4]={0,-1,0,-1};\nint dy[4]={0,0,-1,-1};\nint main(void){\n\tscanf(\"%d\",&n);\n\tif(n==1){\n\t\tprintf(\"0 / 1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n\t\tdata[x[i]][y[i]]=w[i];\n\t}\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint cnt=0,nx=x[i]+dx[j],ny=y[i]+dx[j];\n\t\t\tfor(int k=0;k<=1;k++){\n\t\t\t\tfor(int l=0;l<=1;l++){\n\t\t\t\t\tcnt+=data[nx+k][ny+l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=max(res,cnt);\n\t\t}\n\t}\n\tprintf(\"%d / 1\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n  int n;\n  cin>>n;\n\n  map<P,int> M;\n  for(int i=0,x,y,c;i<n;i++)cin>>x>>y>>c,M[P(x,y)] = c;\n\n  map<P,int>::iterator it;\n  int mx=0;\n  int dx[] = {1,1,0};\n  int dy[] = {0,1,1};\n  for(it=M.begin();it!=M.end();it++){\n    int x = it->first.first;\n    int y = it->first.second;\n    int num = it->second;\n    for(int i=0;i<3;i++){\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(!M.count(P(nx,ny)))continue;\n      num+=M[P(nx,ny)];\n    }\n    mx=max(mx,num);\n  }\n  cout<<mx<<\" / 1\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n#define rep(i, n) for(ll (i) = 0; (i) < (n); (i)++)\n#define rep1(i, n) for(ll (i) = 1; (i) <= (n); (i)++)\n#define rrep(i, n) for(ll (i) = (n) - 1; (i) >= 0; (i)--)\n#define rrep1(i, n) for(ll (i) = (n); (i) >= 1; (i)--)\nconst ll INF = 1145141919;\nconst ll MOD = 1000000007;\ntemplate<class T> void chmax(T &a, const T &b){if(a < b){a = b;}}\ntemplate<class T> void chmin(T &a, const T &b){if(a > b){a = b;}}\n\nint main(){\n\n    ll N;\n\tcin >> N;\n\t\n\tvector<ll>X(N), Y(N);\n\tmap<P, ll>cnt;\n\trep(i, N){\n\t\tcin >> X[i] >> Y[i];\n\t\tll w;\n\t\tcin >> w;\n\t\tcnt[P(X[i], Y[i])] = w;\t\t\n\t}\n\tll ans = 0;\n\n\trep(i, N){\n\t\tll x = X[i];\n\t\tll y = Y[i];\n\t\tchmax(ans, cnt[P(x, y)] + cnt[P(x + 1, y)] + cnt[P(x, y + 1)] + cnt[P(x + 1, y + 1)]);\n\t\tchmax(ans, cnt[P(x, y)] + cnt[P(x + 1, y)] + cnt[P(x, y - 1)] + cnt[P(x + 1, y - 1)]);\n\t}\n\tcout << ans << \" / 1\" << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntemplate <class T, class U>\ninline bool chmax(T& t, const U& f) { return t < f ? t = f, true : false; }\n\nconst int d[] = {1, -1, -1, 1};\n\nint main() {\n    int N; cin >> N;\n    map<pair<int, int>, int> fox;\n    rep(i, N) {\n        int x, y, w; cin >> x >> y >> w;\n        fox[make_pair(x, y)] = w;\n    }\n    int maxi = 0;\n    for (const auto& e : fox) {\n        pair<int, int> t; int x1, y1, w;\n        tie(t, w) = e; tie(x1, y1) = t;\n        rep(k, 4) {\n            int x2 = x1 + d[k], y2 = y1 + d[(k + 1) % 4];\n            t = make_pair(x2, y2);\n            if (fox.count(t)) chmax(maxi, w + fox[t]);\n        }\n    }\n    cout << maxi << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nconst int dx8[] = { -1,-1, 0, 1,1,1, 0,-1 }; const int dy8[] = { 0,1,1, 1, 0, -1,-1,-1 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tmap<pii, int> rab;\n\tREP(i, n) {\n\t\tint a, b, w;\n\t\tcin >> a >> b >> w;\n\t\trab[{a, b}] = w;\n\t}\n\tint ans = 0;\n\tfor (auto it = rab.begin();it != rab.end();it++) {\n\t\tint ma = 0;\n\t\tREP(j,4) {\n\t\t\tint sum=0;\n\t\t\tsum += it->second;\n\t\t\tREP(k,3)\n\t\t\tif (rab.find({ it->first.first + dx8[(j * 2 + k) % 8],it->first.second + dy8[(j * 2 + k) % 8] }) != rab.end()) {\n\t\t\t\tsum += rab[{ it->first.first + dx8[(j * 2 + k) % 8], it->first.second + dy8[(j * 2 + k) % 8] }];\n\t\t\t}\n\n\t\t\tma = max(sum,ma);\n\t\t}\n\t\tans = max(ans, ma);\n\t}\n\tcout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T>& V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> >& Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T>& mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint dx[16] = {1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1};\nint dy[16] = {0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1};\ntemplate<class Type>\nType solve(Type res = Type()){\n    int N; cin >> N;\n    vector<ll> x(N),y(N),w(N);\n    map<pll,ll> mp;\n    for(int i = 0; i < N;i++){\n        cin >> x[i] >> y[i] >> w[i];\n        mp[pll(x[i],y[i])] += w[i];\n    }\n    for(int i = 0; i < N;i++){\n        for(int k = 0; k < 8;k+=2){\n            ll num = mp[pll(x[i],y[i])];\n            \n            for(int j = 0; j < 3;j++){\n                int nx = x[i] + dx[k+j];\n                int ny = y[i] + dy[k+j];\n                num += mp[pll(nx,ny)];\n            }\n            res = max(res,num);\n        }\n    }\n    \n    cout << res << \" / \" << 1 << endl;\n    return res;\n}\n\n\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve(0LL);\n    // cout << fixed << setprecision(15) << solve<string>() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nll x,y,w;\nmap<P,ll> m;\n\nint dy[4][3] = { {-1,-1,0}, {0,1,1}, {1,1,0}, {0,-1,-1} };\nint dx[4][3] = { {0,1,1}, {1,1,0}, {0,-1,-1}, {-1,-1,0} };\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> x >> y >> w;\n    m[P(x,y)] = w;\n  }\n\n  ll res = 0;\n  for(map<P,ll>::iterator it = m.begin();it!=m.end();it++){\n    ll x = it->first.first, y = it->first.second;\n    for(int i=0;i<4;i++){\n      ll tmp = it->second;\n      //cout << y << \" \" << x << endl;\n      //cout << tmp << endl;\n      for(int j=0;j<3;j++){\n\t//cout << y+dy[i][j] << \" \" <<  x+dx[i][j] << endl;\n\tP p = P(x+dx[i][j], y+dy[i][j]);\n\tif(m.find(p)!=m.end())tmp += m[p];\n      }\n      //cout << tmp << endl;\n      res = max(res,tmp);\n    }\n  }\n\n  cout << res << \" / 1\" << endl;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(pair<pii,int> (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, x, y, w, r;\nmap<pii,int> m;\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) {\n\t\tcin >> x >> y >> w;\n\t\tm[{x,y}] = w;\n\t}\n\teach(i,m) {\n\t\tif (i.se==0) continue;\n\t\tx = i.fi.fi, y = i.fi.se;\n\t\tint t = i.se + m[{x+1,y}];\n\t\tr = max(r, t + m[{x,y+1}] + m[{x+1,y+1}]);\n\t\tr = max(r, t + m[{x,y-1}] + m[{x+1,y-1}]);\n\t}\n\tcout << r << \" / 1\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c;\nint dx[9] = { 0,1,1,1,0,-1,-1,-1,0 }, dy[9] = { 1,1,0,-1,-1,-1,0,1,0 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<0>(x[i]) + dy[j]) {\n\t\t\t\tmaxn = max(maxn, get<2>(x[i]) + get<2>(x[c]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int dy[] = {1, 1, 0, -1, -1, -1, 0, 1, 1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tmap<P, ll> mp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tmp[make_pair(x, y)] = w;\n\t}\n\tll ans = 0;\n\tfor(auto itr = mp.begin(); itr != mp.end(); itr++)\n\t{\n\t\tll cnt = itr->second;\n\t\tqueue<ll> que;\n\t\tfor(int i = 0; i < 9; i++)\n\t\t{\n\t\t\tll nx = itr->first.first + dx[i];\n\t\t\tll ny = itr->first.second + dy[i];\n\t\t\tP tmp = make_pair(nx, ny);\n\t\t\tif(mp.count(tmp) > 0) cnt += mp[tmp];\n\t\t\tif(mp.find(tmp) != mp.end()) que.push(mp[tmp]);\n\t\t\telse que.push(0);\n\t\t\tif(que.size() == 3) \n\t\t\t{\n\t\t\t\tans = max(cnt, ans);\n\t\t\t\tfor(int j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tll q = que.front(); que.pop();\n\t\t\t\t\tcnt -= q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; cin >> N;\n  map<pair<int, int>, int> mp;\n  vector<pair<int, int>> vs;\n  rep(i, N) {\n    int x, y, w; cin >> x >> y >> w;\n    vs.emplace_back(x, y);\n    mp[{x, y}] += w;\n  }\n\n  ll ans = 0;\n\n  rep(i, vs.size()) {\n    int x = vs[i].first, y = vs[i].second;\n    maximize(ans, mp[{x, y}] + mp[{x + 1, y}] + mp[{x, y + 1}] + mp[{x + 1, y + 1}]);\n  }\n\n  cout << ans << \" / 1\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<ll> x(N), y(N), w(N);\n    for (int i = 0; i < N; i++) cin >> x[i] >> y[i] >> w[i];\n\n    ll a = 0, b = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            ll n = w[i] + w[j];\n            ll m = abs(x[i] - x[j]) * abs(y[i] - y[j]);\n\n            if (a * m < b * n) {\n                a = n;\n                b = m;\n            }\n        }\n    }\n\n    cout << a << \" / \" << b << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tmap<pii,int>ma;\n\tvp in(n);\n\trep(i,n){\n\t\tll a,b,c;\n\t\tscanf(\"%lld %lld %lld\",&a,&b,&c);\n\t\tin[i]=pii(a,b);\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tll sum=0;\n\t\t\tint sx=min(in[q].first,in[q].first+x);\n\t\t\tint gx=max(in[q].first,in[q].first+x);\n\t\t\tint sy=min(in[q].second,in[q].second+y);\n\t\t\tint gy=max(in[q].second,in[q].second+y);\t\t\t\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tll area=abs(x*y);\n\t\t\tll gc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, x, y, w, r;\nmap<pii,int> m;\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) {\n\t\tcin >> x >> y >> w;\n\t\tm[{x,y}] = w;\n\t}\n\teach(i,m) {\n\t\tif (i.se==0) continue;\n\t\tx = i.fi.fi, y = i.fi.se;\n\t\tint t = i.se + m[{x+1,y}];\n\t\tr = max(r, t + m[{x,y+1}] + m[{x+1,y+1}]);\n\t\tr = max(r, t + m[{x,y-1}] + m[{x+1,y-1}]);\n\t}\n\tcout << r << \" / 1\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\n#define INF 1e9\n#define dump(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(a) (a).begin(),(a).end()\ntypedef pair<int,int> P;\ntemplate <class T> void chmin(T & a, T const & b) { if (b < a) a = b; }\ntemplate <class T> void chmax(T & a, T const & b) { if (b > a) a = b; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\nusing ll = long long;\nconst ll mod = LLONG_MAX;\n\n#define int long long\nstruct Data{\n  int x,y,w;\n  Data(){};\n  Data(int x,int y,int w):x(x),y(y),w(w){}\n  bool operator < (const Data& s)const{\n    return (x!=s.x) ? (x<s.x):(y<s.y);\n  }\n};\n\nint n,x[112345],y[112345],w[112345];\nData d[112345];\n\n\nint ans=-1;\nsigned main(){\n  cin>>n;\n  rep(i,n){\n    cin>>x[i]>>y[i]>>w[i];\n    d[i].x=x[i],d[i].y=y[i],d[i].w=w[i];\n  }\n  sort(d,d+n);\n  rep(i,n){\n    int temp=0;\n    for(int j=-10;j<=10;j++){\n      if(i+j<0&& i+j>=n)continue;\n      if(abs(d[i+j].x-d[i].x)<=1 && abs(d[i+j].y-d[i].y)<=1){\n        temp+=d[i+j].w;\n      }\n\n    }\n    chmax(ans,temp);\n  }\n  cout<<ans<<\" / \"<<1<<endl;\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nint n, ret, res, ptr; tuple<int, int, int> d[100000];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d\", &get<0>(d[i]), &get<1>(d[i]), &get<2>(d[i]));\n\tsort(d, d + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = get<2>(d[i]);\n\t\tif (i + 1 != n) { if (get<0>(d[i + 1]) == get<0>(d[i]) && get<1>(d[i + 1]) == get<1>(d[i]) + 1) res += get<2>(d[i + 1]); }\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t\tres = get<2>(d[i]);\n\t\tif (i != 0) { if (get<0>(d[i - 1]) == get<0>(d[i]) && get<1>(d[i - 1]) == get<1>(d[i]) - 1) res += get<2>(d[i - 1]); }\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]), 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i]) - 1) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t}\n\tprintf(\"%d / 1\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; scanf(\"%d\", &N);\n  map<pair<int, int>, ll> mp;\n  vector<pair<int, int>> vs;\n  rep(i, N) {\n    int x, y, w; scanf(\"%d%d%d\",&x,&y,&w);\n    vs.emplace_back(x, y);\n    mp[{x, y}] += w;\n  }\n\n  ll ans = 0;\n\n  rep(i, vs.size()) {\n    int x = vs[i].first, y = vs[i].second;\n    REP(dx, -1, 2) REP(dy, -1, 2) {\n      if(!dx || !dy) continue;\n      maximize(ans, mp[{x, y}] + mp[{x + dx, y}] + mp[{x, y + dy}] + mp[{x + dx, y + dy}]);\n    }\n  }\n\n  cout << ans << \" / 1\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nstruct data {\n  ll x, y, w;\n  bool operator<(const data &d) const {\n    return pll(x, y) < pll(d.x, d.y);\n  }\n};\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<data> vec(N);\n  REP(i, 0, N) cin >> vec[i].x >> vec[i].y >> vec[i].w;\n\n  sort(vec.begin(), vec.end());\n\n  vector<pll> p(N);\n  vector<ll> w(N);\n  REP(i, 0, N) {\n    p[i] = pll(vec[i].x, vec[i].y);\n    w[i] = vec[i].w;\n  }\n\n  ll ans = 0;\n  REP(i, 0, N) {\n    ll x = vec[i].x, y = vec[i].y, s = 0;\n    REP(dx, 0, 2) REP(dy, 0, 2) {\n      if(binary_search(p.begin(), p.end(), pll(x + dx, y + dy))) {\n        ll idx = lower_bound(p.begin(), p.end(), pll(x + dx, y + dy)) - p.begin();\n        s += w[idx];\n      }\n    }\n    ans = max(ans, s);\n  }\n  cout << ans << \" / \" << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint dx[4] = { 0,0,1,1 }, dy[4] = { 0,1,0,1 };\nint main()\n{\n\tint n; cin >> n;\n\tmap<pii, ll> mp;\n\tREP(i, n)\n\t{\n\t\tint x, y, w; cin >> x >> y >> w;\n\t\tmp[pii(x, y)] = w;\n\t}\n\tll ans = 0;\n\tfor (auto i:mp)\n\t{\n\t\tint x = i.first.first, y = i.first.second;\n\t\tREP(j, 4) \n\t\t{\n\t\t\tint tx = x - dx[j], ty = y - dy[j];\n\t\t\tll res = 0;\n\t\t\tREP(k, 4)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[k], ny = ty + dy[k];\n\t\t\t\tif (mp.count(pii(nx, ny))) res += mp[pii(nx, ny)];\n\t\t\t}\n\t\t\tchmax(ans, res);\n\t\t}\n\t}\n\tcout << ans << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vector<int> x(n), y(n), w(n);\n    map<int,map<int,int>> s;\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i] >> w[i];\n        s[x[i]][y[i]] = w[i];\n    }\n\n    int dx[4] = {1, 1, -1, -1},\n        dy[4] = {1, -1, 1, -1};\n\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int k = 0; k < 4; ++k) {\n            chmax(ans,\n                    s[x[i]][y[i]] +\n                    s[x[i]+dx[k]][y[i]] +\n                    s[x[i]][y[i]+dy[k]] +\n                    s[x[i]+dx[k]][y[i]+dy[k]]);\n        }\n    }\n\n    printf(\"%d / 1\\n\", ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int N, W;\n    cin >> N;\n    vector<int> X(N), Y(N);\n    map<int, map<int, int>> coor;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i] >> W;\n        coor[X[i]][Y[i]] = W;\n    }\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        res = max(res, coor[X[i]][Y[i]] +\n                       coor[X[i]+1][Y[i]] +\n                       coor[X[i]][Y[i]+1] +\n                       coor[X[i]+1][Y[i]+1]);\n\n        res = max(res, coor[X[i]][Y[i]] +\n                       coor[X[i]+1][Y[i]] +\n                       coor[X[i]][Y[i]-1] +\n                       coor[X[i]+1][Y[i]-1]);\n    }\n    cout << res << \" / \" << 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nstruct data {\n  ll x, y, w;\n  bool operator<(const data &d) const {\n    return pll(x, y) < pll(d.x, d.y);\n  }\n};\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<data> vec(N);\n  REP(i, 0, N) cin >> vec[i].x >> vec[i].y >> vec[i].w;\n\n  sort(vec.begin(), vec.end());\n\n  vector<pll> p(N);\n  vector<ll> w(N);\n  REP(i, 0, N) {\n    p[i] = pll(vec[i].x, vec[i].y);\n    w[i] = vec[i].w;\n  }\n\n  ll ans = 0;\n  REP(i, 0, N) {\n    REP(px, -1, 1) REP(py, -1, 1) {\n      ll x = vec[i].x + px, y = vec[i].y + py, s = 0;\n      REP(dx, 0, 2) REP(dy, 0, 2) {\n        if(binary_search(p.begin(), p.end(), pll(x + dx, y + dy))) {\n          ll idx = lower_bound(p.begin(), p.end(), pll(x + dx, y + dy)) - p.begin();\n          s += w[idx];\n        }\n      }\n      ans = max(ans, s);\n    }\n  }\n  cout << ans << \" / \" << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  map<P,int> mp;\n  int ans=0,n,x,y,w;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>w;\n    for(int j=0;j<2;j++)\n      for(int k=0;k<2;k++)\n\tans=max(ans,mp[P(x+j,y+k)]+=w);\n  }\n  cout<<ans<<\" / 1\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nint main() {\n    int N;\n    cin >> N;\n\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        cin >> W[make_pair(x, y)];\n    }\n\n    int ans = 0;\n    for (auto pp : W) {\n        int x, y;\n        tie(x, y) = pp.first;\n\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x + dx, y + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint dy[4] = {0,1,1};\nint dx[4] = {1,0,1};\nint my[4] = {1, 1, -1, -1};\nint mx[4] = {1, -1, -1, 1};\n\nint main(){\n    int n;\n    cin >> n;\n\n    map<pair<int, int>,int> m;\n    rep(i,n){\n        int x, y, w;\n        cin >> x >> y >> w;\n        m[make_pair(x,y)] = w;\n    }\n\n    int maxi = 0;\n    for(auto it:m){\n        rep(j,4){\n            int sum = m[ make_pair(it.first.first, it.first.second) ];\n            rep(i,3){\n                if(m.count(make_pair(it.first.first + dx[i] * mx[j], it.first.second + dy[i] * my[j]))){\n                    sum += m[ make_pair(it.first.first + dx[i] * mx[j], it.first.second + dy[i] * my[j]) ];\n                }\n            }\n            maxi = max(maxi, sum);\n        }\n    }\n    cout << maxi << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n \nint main(){\n    int n;\n    cin>>n;\n    map<pair<int,int>,int> mp;\n    int x[n],y[n];\n    rep(i,n){\n        int w;\n        cin>>x[i]>>y[i]>>w;\n        mp[{x[i],y[i]}]+=w;\n    }\n    int ans=0;\n    rep(i,n){\n        for(int j=-1;j<=1;j+=2)for(int k=-1;k<=1;k+=2){\n            int ret=mp[{x[i],y[i]}]+mp[{x[i]+j,y[i]}]+mp[{x[i]+j,y[i]+k}]+mp[{x[i],y[i]+k}];\n            ans=max(ans,ret);\n        }\n    }\n    cout<<ans<<\" / 1\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nint main() {\n    int N;\n    cin >> N;\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        cin >> W[make_pair(x, y)];\n    }\n\n    int ans = 0;\n    for (auto pp : W) {\n        pair<int, int> p;\n        int w;\n        tie(p, w) = pp;\n        int x, y;\n        tie(x, y) = p;\n\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x + dx, y + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n  int n;\n  cin>>n;\n\n  map<P,int> M;\n  for(int i=0,x,y,c;i<n;i++)cin>>x>>y>>c,M[P(x,y)] += c;\n\n  map<P,int>::iterator it;\n  int mx=0;\n  int dx[2][3] = {{1,1,0},{-1,-1,0}};\n  int dy[2][3] = {{0,1,1},{0,1,1}};\n  for(it=M.begin();it!=M.end();it++){\n    int x = it->first.first;\n    int y = it->first.second;\n    for(int k=0;k<2;k++){\n      int num = it->second;\n      for(int i=0;i<3;i++){\n\tint nx=x+dx[k][i];\n\tint ny=y+dy[k][i];\n\tif(!M.count(P(nx,ny)))continue;\n\tnum+=M[P(nx,ny)];\n      }\n      mx=max(mx,num);\n    }\n  }\n  cout<<mx<<\" / 1\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;tuple<int,int,int>x[1<<17];int n,m,a,b,c,s,h,i,j,k;int dx[2][3]={{1,1,0},{0,-1,-1}},dy[2][3]={{0,1,1},{1,1,0}};main(){cin>>n;for(i=0;i<n;i++){cin>>a>>b>>c;x[i]=make_tuple(a,b,c);}sort(x,x+n);for(i=0;i<n;i++){for(h=0;h<2;h++){for(j=0;j<8;j++){s=0;for(k=0;k<3;k++){if((j/(1<<k))%2==0){c=lower_bound(x,x+n,make_tuple(get<0>(x[i])+dx[h][k],get<1>(x[i])+dy[h][k],0))-x;if(get<0>(x[c])==get<0>(x[i])+dx[h][k]&&get<1>(x[c])==get<1>(x[i])+dy[h][k]){s+=get<2>(x[c]);}}}m=max(maxn,s+get<2>(x[i]));}}}cout<<m<<\" / 1\"<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n    ll N, W;\n    cin >> N;\n    vector<ll> X(N), Y(N);\n    map<ll, map<ll, ll>> coor;\n    for (ll i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i] >> W;\n        coor[X[i]][Y[i]] = W;\n    }\n    ll res = 0;\n    for (ll i = 0; i < N; i++) {\n        res = max(res, coor[X[i]][Y[i]] +\n                       coor[X[i]+1][Y[i]] +\n                       coor[X[i]][Y[i]+1] +\n                       coor[X[i]+1][Y[i]+1]);\n    }\n    cout << res << \" / \" << 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntemplate <class T, class U>\ninline bool chmax(T& t, const U& f) { return t < f ? t = f, true : false; }\n\nconst int d[] = {1, -1, -1, 1};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int N; cin >> N;\n    map<pair<int, int>, int> fox;\n    rep(i, N) {\n        int x, y, w; cin >> x >> y >> w;\n        fox[make_pair(x, y)] = w;\n    }\n    int maxi = 0;\n    for (const auto& e : fox) {\n        pair<int, int> t; int x1, y1, w;\n        tie(t, w) = e; tie(x1, y1) = t;\n        rep(k, 4) {\n            w = e.second;\n            int x2 = x1 + d[k], y2 = y1 + d[(k + 1) % 4];\n            t = make_pair(x2, y2);\n            if (fox.count(t)) w += fox[t];\n            t = make_pair(x1, y2);\n            if (fox.count(t)) w += fox[t];\n            t = make_pair(x2, y1);\n            if (fox.count(t)) w += fox[t];\n            chmax(maxi, w);\n        }\n    }\n    cout << maxi << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<PP> vec;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tvec.push_back(PP(P(x, y), w));\n\t}\n\tsort(vec.begin(), vec.begin());\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll cnt = vec[i].second;\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tbool ok = false;\n\t\t\tfor(int k = 0; k < 8; k++)\n\t\t\t{\n\t\t\t\tif(vec[i].first.first + dx[k] != vec[j].first.first && vec[i].first.second + dy[k] != vec[j].first.second)\n\t\t\t\t\tok = true;\n\t\t\t}\n\t\t\tif(ok)\n\t\t\t\tcnt += vec[j].second;\n\t\t\telse \n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nint n, ret, res, ptr; tuple<int, int, int> d[100000];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d\", &get<0>(d[i]), &get<1>(d[i]), &get<2>(d[i]));\n\tsort(d, d + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = get<2>(d[i]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]), get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t\tres = get<2>(d[i]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]), get<1>(d[i]), 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) && get<1>(d[ptr]) == get<1>(d[i]) - 1) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]), 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t}\n\tprintf(\"%d / 1\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\tusing tup = tuple<int, int, int>;\n\t\tmap<int, map<int, int>> mp;\n\t\tvector<tup> v(n);\n\t\trep(i, n) {\n\t\t\tint x, y, w;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &w);\n\t\t\tv[i] = tup(x, y, w);\n\t\t\tmp[x][y] = w;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (tup t : v) {\n\t\t\tint x = get<0>(t), y = get<1>(t);\n\t\t\tint sum = mp[x][y] + mp[x + 1][y] + mp[x][y + 1] + mp[x + 1][y + 1];\n\t\t\tmaxup(ans, sum);\n\t\t}\n\t\tcout << ans << \" / \" << 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info1{\n\tInfo1(int arg_x,int arg_y,int arg_w){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info1 &arg) const{ //y?????????\n\t\t\treturn y < arg.y;\n\t};\n\tint x,y,w;\n};\n\nstruct Info2{\n\tInfo2(int arg_x,int arg_w){\n\t\tx = arg_x;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info2 &arg) const{ //x?????????\n\t\t\treturn x < arg.x;\n\t};\n\tint x,w;\n};\n\nint main(){\n\n\tint N,tmp_x,tmp_y,tmp_w,pre_y,pre_x,index = -1,self,ans = 0,right;\n\tscanf(\"%d\",&N);\n\n\tint* Y_VALUE = new int[N]; //?????????vector????????£??????y??§?¨?????¨???????????????????????????????\n\n\t//?????????y??????????????°??????????????????\n\tpriority_queue<Info1> Q;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d\",&tmp_x,&tmp_y,&tmp_w);\n\t\tQ.push(Info1(tmp_x,tmp_y,tmp_w));\n\t}\n\n\tvector<Info2> V[N];\n\n\tpre_y = BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().y != pre_y){ //??°??????y??????????????????\n\t\t\tindex++;\n\t\t\tY_VALUE[index] = Q.top().y; //??°??????y??????????¨????\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}else{\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}\n\t\tpre_y = Q.top().y;\n\t\tQ.pop();\n\t}\n\tindex++;\n\n\tfor(int i = 0; i < index; i++)sort(V[i].begin(),V[i].end()); //?????°???????????????x????????????sort\n\n\tfor(int i = 0; i < index; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tprintf(\"y:%d x:%d\\n\",Y_VALUE[i],V[i][k].x);\n\t\t}\n\t}\n\n\tpre_y = pre_x = BIG_NUM;\n\n\tint l,r,m,loc;\n\n\tfor(int i = 0; i < index; i++){ //y?????????????????????\n\t\tfor(int k = 0; k < V[i].size(); k++){ //x????????????\n\n\t\t\t//????????????????????????????§???¢????¨????\n\t\t\tif(pre_y == i && pre_x == V[i][k].x-1){ //??????????????????1?????????????????????????????????????????????????§???¢????¨??????????\n\t\t\t\tself = right;\n\t\t\t}else{ //????????????????????????????§???¢????¨??????????\n\t\t\t\tif(i == index - 1 || Y_VALUE[i] - Y_VALUE[i+1] > 1){ //?????????1??????????????????????????¨???????????´???\n\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t}else{\n\t\t\t\t\t//2?????¢?´¢??§???V[i][k]????????????????????????????????????????????¢???<?????????????£????????????°?????¢????´¢??§??????>\n\t\t\t\t\tl = 0;\n\t\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\t\twhile(l <= r){\n\t\t\t\t\t\tif(V[i+1][m].x == V[i][k].x || V[i+1][m].x == V[i][k].x-1){ //????????????????????????????????°break\n\t\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(loc == BIG_NUM){ //??????????????????????????????????????????????????¨???????????´???\n\t\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][loc].x == V[i][k].x){ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc].w;\n\t\t\t\t\t\t\tif(loc > 0 && V[i+1][loc-1].x == V[i][k].w - 1){ //????????????????????£?????????????????´???\n\t\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc-1].w);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tans = max(ans,self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tif(loc < V[i+1].size()-1 && V[i+1][loc+1].x == V[i][k].x){ //???????????????????????????????????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc+1].w;\n\t\t\t\t\t\t\t}else{ //?????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc].w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//????????????????????????????§???¢????¨????<self????¨??????????>\n\t\t\tif(k < V[i].size()-1 && V[i][k+1].x == V[i][k].x+1){ //?????????????????????????????´???\n\t\t\t\tright = V[i][k+1].w;\n\t\t\t}else{\n\t\t\t\tright = 0;\n\t\t\t}\n\n\t\t\tif(i < index-1 && Y_VALUE[i+1] == Y_VALUE[i]-1){ //1?????????????????????????????´???\n\t\t\t\t//???????????????????????¢?´¢??§??¢???\n\t\t\t\tl = 0;\n\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\tm = (l+r)/2;\n\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\twhile(l <= r){\n\t\t\t\t\tif(V[i+1][m].x == V[i][k].x+1){ //?????????????????????????????°break\n\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(loc != BIG_NUM)right += V[i+1][loc].w;\n\t\t\t}\n\n\t\t\tans = max(ans,self+right);\n\n\t\t\tpre_y = i;\n\t\t\tpre_x = V[i][k].x;\n\t\t}\n\t}\n\n\tprintf(\"%d / 1\\n\",ans);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define long long long // for codeforces\n\nint main(){\n  int n;\n  cin>>n;\n  map<pair<int,int>, int> m;\n  rep(i,n){\n    int x,y,w;\n    cin>>x>>y>>w;\n    m[mp(x,y)] = w;\n  }\n\n  int ans = 0;\n  for(auto &p : m){\n    int x = p.fi.fi, y = p.fi.se;\n    int dx[] = {0,1,1}, dy[] = {1,0,1};\n    rep(i,4){\n      int crnt = p.se;\n      rep(j,3){\n        int nx = x +  dx[j], ny = y + dy[j];\n        auto q = mp(nx,ny);\n        if(m.count(q)==1) crnt += m[q];\n      }\n      if(i%2==0){\n        dx[1]*=-1;\n        dx[2]*=-1;\n      }\n      else {\n        dy[0]*=-1;\n        dy[2]*=-1;\n      }\n      ans = max(ans, crnt);\n    }\n  }\n\n  cout << ans << \" / 1\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint main(){\n  int N;\n  cin >> N;\n  map<pair<int, int>, int> mp;\n  for (int i = 0; i < N; i++){\n    int x, y, w;\n    cin >> x >> y >> w;\n    mp[make_pair(x, y)] = w;\n  }\n  long long ans = 0;\n  for (auto P : mp){\n    int x = P.first.first;\n    int y = P.first.second;\n    for (int i = -1; i <= 1; i++){\n      for (int j = -1; j <= 1; j++){\n        long long sum = 0;\n        for (int k = 0; k < 2; k++){\n          for (int l = 0; l < 2; l++){\n            if (mp.count(make_pair(x - i + k, y - j + l))){\n              sum += mp[make_pair(x - i + k, y - j + l)];\n            }\n          }\n        }\n        ans = max(ans, sum);\n      }\n    }\n  }\n  cout << ans << \" / \" << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvp g;\n\tpublic:\n\tvi DIJ(int s){\n\t\tpriority_queue<P> q;\n\t\tvi d(n,inf);\n\t\td[s]=0;\n\t\tq.push({0,s});\n\t\twhile(!q.empty()){\n\t\t\tP p=q.top();\n\t\t\tq.pop();\n\t\t\tint v=p.second;\n\t\t\tif(d[v]<-p.first) continue;\n\t\t\tfor(auto i:g[v]){\n\t\t\t\tint u=i.first,D=d[v]+i.second;\n\t\t\t\tif(d[u]>D){\n\t\t\t\t\td[u]=D;\n\t\t\t\t\tq.push({-D,u});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvp(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tg[s].push_back({t,c});\n\t\tg[t].push_back({s,c});\n\t}\n};\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n;\n\tmap<P,int> mp;\n\tvp a;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y,w;\n\t\tcin>>x>>y>>w;\n\t\tmp[{x,y}]=w;\n\t\ta.push_back({x,y});\n\t}\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tint x=a[i].first,y=a[i].second;\n\t\tres=max(res,mp[{x,y}]+mp[{x-1,y}]+mp[{x,y-1}]+mp[{x-1,y-1}]);\n\t\tres=max(res,mp[{x,y}]+mp[{x+1,y}]+mp[{x,y-1}]+mp[{x+1,y-1}]);\n\t\tres=max(res,mp[{x,y}]+mp[{x-1,y}]+mp[{x,y+1}]+mp[{x-1,y+1}]);\n\t\tres=max(res,mp[{x,y}]+mp[{x+1,y}]+mp[{x,y+1}]+mp[{x+1,y+1}]);\n\t}\n\tcout<<res<<\" / 1\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nsigned main(){\n    \n    int n; cin >> n;\n    vector<int> x(n);   \n    vector<int> y(n);   \n    map<pair<int, int>, int> mp;\n    for(int i = 0; i < n; i++){\n        int w;\n        cin >> x[i] >> y[i] >> w;\n        mp[{x[i], y[i]}] += w;\n    }\n    \n    int ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int di = -1; di < 2; di += 2){\n            for(int dj = -1; dj < 2; dj += 2){\n                int t = 0;\n                for(int j = 0; j < 2; j++){\n                    for(int k = 0; k < 2; k++){\n                        \n                        int nx = x[i] + j * di;\n                        int ny = y[i] + k * dj;\n                        t += mp[{nx, ny}];\n                    }\n                }\n                ans = max(ans, t);\n            }\n        }\n    }\n\n    cout << ans << \" / \" << 1 <<  endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n), w(n);\n    map<P, int> mp;\n    rep(i, 0, n){\n        cin >> x[i] >> y[i] >> w[i];\n        mp[{y[i], x[i]}] += w[i];\n    }\n    int ans = 0;\n    rep(i, 0, n){\n        int tmp = 0;\n        rep(j, 0, 2){\n            rep(k, 0, 2){\n                tmp += mp[{y[i] + j, x[i] + k}];\n            }\n        }\n        int tmp2 = 0;\n        rep(j, 0, 2){\n            rep(k, -1, 1){\n                tmp2 += mp[{y[i] + j, x[i] + k}];\n            }\n        }\n        ans = max({ans, tmp, tmp2});\n    }\n    cout << ans << \" / \" << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nmap<int,map<int,int> >pop;\nint x[123456],y[123456];\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int w;\n    cin>>x[i]>>y[i]>>w;\n    pop[y[i]][x[i]]=w;\n  }\n  int ans=0;\n  for(int i=0;i<N;i++){\n    for(int j=-1;j<=0;j++){\n      for(int k=-1;k<=0;k++){\n\tint c=0;\n\tfor(int l=0;l<2;l++){\n\t  for(int m=0;m<2;m++){\n\t    c+=pop[y[i]+j+l][x[i]+k+m];\n\t  }\n\t}\n\tans=max(ans,c);\n      }\n    }\n  }\n  cout<<ans<<\" / 1\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//??°?????????????????????2???????????????????????????????????°????????£?????????\n#include <iostream>\n#include <algorithm>\n#include <tuple>\n#define int long long\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\nint n;\nT t[100000];\t//(x, y, w)\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tif (n == 1) { cout << w << endl; return 0; }\n\t\tt[i] = T(x, y, w);\n\t}\n\tsort(t, t + n);\n\t\n\tint si = 0;\n\tint bo = 1;\n\t\n\tfor (i = 0; i < n - 1; i++) {\n\t\tint id = lower_bound(t, t + n, T(get<0>(t[i]) + 1, get<1>(t[i]), -1)) - t;\n\t\tif (id == n) continue;\n\t\t\n\t\tint dx = get<0>(t[id]) - get<0>(t[i]);\n\t\tint dy = get<1>(t[id]) - get<1>(t[i]);\n\t\tint area = dx * dy;\t\n\t\tint num = get<2>(t[i]) + get<2>(t[id]);\n\t\t\n\t\tif (si * area < num * bo) { si = num; bo = area; }\n\t}\n\t\n\tint g = gcd(si, bo);\n\tsi /= g;\n\tbo /= g;\n\tcout << si << \" / \" << bo << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/stack:16777216\")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <complex>\nusing namespace std;\n \n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,value) memset(A,value,sizeof(A))\n \n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define Pi 3.14159265358979\n#define x0 ikjnrmthklmnt\n#define y0 lkrjhkltr\n#define y1 ewrgrg\n \ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<Int, Int> PLL;\ntypedef pair<double, double> PDD;\ntypedef complex<double> base;\n \nconst int INF = 1000000000;\nconst int MAX = 120000;\nconst int MAX2 = 50007;\nconst int ADD = 1000000;\nconst int MAXD = 256;\nconst int BASE = 1000000000;\nconst int MOD = 1000000007;\n\nint n;\nint x[MAX], y[MAX], w[MAX];\nmap<PII, int> M;\nint q[3][3];\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"distance.in\",  \"r\", stdin);\n\t//freopen(\"distance.out\", \"w\", stdout);\n\t//freopen(\"out.txt\" , \"w\" , stdout);\n\t\n\tcin >> n;\n\tFOR (i,0,n)\n\t{\n\t\tscanf(\"%d%d%d\", x+i, y+i, w+i);\n\t\tM[MP(x[i], y[i])] = w[i];\n\t}\n\tint ans = 0;\n\tFOR (i,0,n)\n\t{\n\t\tFOR (dx,-1,2)\n\t\tFOR (dy,-1,2)\n\t\t{\n\t\t\tq[dx+1][dy+1] = M[MP(x[i]+dx,y[i]+dy)];\n\t\t}\n\t\tFOR(i1,0,2)\n\t\tFOR(i2,0,2)\n\t\tans = max(ans, q[i1][i2] + q[i1][i2+1] + q[i1+1][i2] + q[i1+1][i2+1]);\n\t}\n\tcout << ans << \" / 1\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll, ll> pi;\n\nmap<pi,int>m;\nint N;\n\nint main()\n{\n  cin >> N;\n  rep(i,N){\n    ll x,y,z; cin >> x >> y >> z;\n    m[pi(x,y)] = z;\n  }\n  int res = 0;\n  for(auto z:m){\n    ll x=z.first.first,y=z.first.second;\n    int a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];\n    if(m.count(pi(x+1,y))) a += m[pi(x+1,y)];\n    if(m.count(pi(x,y+1))) a += m[pi(x,y+1)];\n    if(m.count(pi(x+1,y+1))) a += m[pi(x+1,y+1)];    \n    res = max(res, a);\n  }\n  cout << res << \" / 1\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint main(){\n  int N;\n  cin >> N;\n  vector<int> X(N), Y(N);\n  map<pair<int,int>, int> M;\n  int x, y, w;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y >> w;\n    X[i] = x;\n    Y[i] = y;\n    M[make_pair(x,y)] = w;\n  }\n  int ans = 0;\n  for(int i = 0; i < N; ++i){\n    x = X[i];\n    y = Y[i];\n    int t = 0;\n    for(int j = 0; j < 2; ++j){\n      for(int k = 0; k < 2; ++k){\n        int x_ = x + j, y_ = y + k;\n        t += M[make_pair(x_,y_)];\n      }\n    }\n    ans = max(ans, t);\n  }\n  cout << ans << \" / \" << 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<PP> vec;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tvec.push_back(PP(P(x, y), w));\n\t}\n\tsort(vec.begin(), vec.begin());\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll cnt = vec[i].second;\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif(vec[i].first.first + 1 != vec[j].first.first && vec[i].first.first - 1 != vec[j].first.first) break;\n\t\t\tif(vec[i].first.second + 1 != vec[j].first.second && vec[i].first.second - 1 != vec[j].first.second) break;\n\t\t\tcnt += vec[j].second;\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tmap<pii, int> mp;\n\tvi x(n), y(n);\n\tREP(i, n) {\n\t\tint z;\n\t\tcin >> x[i] >> y[i] >> z;\n\t\tmp[{x[i], y[i]}] += z;\n\t}\n\tint ans = -1;\n\tREP(i, n) {\n\t\tREP(j, 4) {\n\t\t\tans = max(ans, mp[{x[i], y[i]}] + mp[{x[i] + dx[i * 2], y[i] + dy[i * 2]}] + mp[{x[i] + dx[i * 2 + 1], y[i] + dy[i * 2 + 1]}] + mp[{x[i] + dx[(i + 1) * 2 % 8], y[i] + dy[(i + 1) * 2 % 8]}]);\n\t\t}\n\t}\n\tcout << ans <<\" / 1\"<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,X[100005],Y[10005],W[10005],mx=0,mv[6]={0,1,0,-1,0,0};\nmap<P,int>M;\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d\",X+i,Y+i,W+i);\n\t\tM[make_pair(X[i],Y[i])]=W[i];\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint tmp1=M[make_pair(X[i],Y[i])]+M[make_pair(X[i]+1,Y[i])]+M[make_pair(X[i],Y[i]+1)]+M[make_pair(X[i]+1,Y[i]+1)];\n\t\tint tmp2=M[make_pair(X[i],Y[i])]+M[make_pair(X[i]-1,Y[i])]+M[make_pair(X[i],Y[i]+1)]+M[make_pair(X[i]-1,Y[i]+1)];\n\t\tmx=max(mx,max(tmp1,tmp2));\n\t}\n\tprintf(\"%d / 1\\n\",mx);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info1{\n\tInfo1(int arg_x,int arg_y,int arg_w){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info1 &arg) const{\n\t\t\treturn y < arg.y;\n\t};\n\tint x,y,w;\n};\n\nstruct Info2{\n\tInfo2(int arg_x,int arg_w){\n\t\tx = arg_x;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info2 &arg) const{\n\t\t\treturn x < arg.x;\n\t};\n\tint x,w;\n};\n\nint main(){\n\n\tint N,tmp_x,tmp_y,tmp_w,pre_y,pre_x,index = -1,self,ans = 0,right;\n\tscanf(\"%d\",&N);\n\n\tint* Y_VALUE = new int[N];\n\n\tpriority_queue<Info1> Q;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d\",&tmp_x,&tmp_y,&tmp_w);\n\t\tQ.push(Info1(tmp_x,tmp_y,tmp_w));\n\t}\n\n\tvector<Info2> V[N];\n\n\tpre_y = BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().y != pre_y){\n\t\t\tindex++;\n\t\t\tY_VALUE[index] = Q.top().y;\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}else{\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}\n\t\tpre_y = Q.top().y;\n\t\tQ.pop();\n\t}\n\tindex++;\n\n\tfor(int i = 0; i < index; i++)sort(V[i].begin(),V[i].end());\n\n\tpre_y = pre_x = BIG_NUM;\n\n\tint l,r,m,loc;\n\n\tfor(int i = 0; i < index; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\n\t\t\tif(pre_y == i && pre_x == V[i][k].x-1){\n\t\t\t\tself = right;\n\t\t\t}else{\n\t\t\t\tif(i == index - 1 || Y_VALUE[i] - Y_VALUE[i+1] > 1){\n\t\t\t\t\tans = max(ans,V[i][k].w);\n\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t}else{\n\t\t\t\t\tl = 0;\n\t\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\t\twhile(l <= r){\n\t\t\t\t\t\tif(V[i+1][m].x == V[i][k].x || V[i+1][m].x == V[i][k].x-1){\n\t\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(loc == BIG_NUM){\n\t\t\t\t\t\tans = max(ans,V[i][k].w);\n\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][loc].x == V[i][k].x){\n\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc].w;\n\t\t\t\t\t\t\tif(loc > 0 && V[i+1][loc-1].x == V[i][k].w - 1){\n\t\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc-1].w);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tans = max(ans,self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(loc < V[i+1].size()-1 && V[i+1][loc+1].x == V[i][k].x){\n\t\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc+1].w;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc].w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(k < V[i].size()-1 && V[i][k+1].x == V[i][k].x+1){\n\t\t\t\tright = V[i][k+1].w;\n\t\t\t}else{\n\t\t\t\tright = 0;\n\t\t\t}\n\n\t\t\tif(i < index-1 && Y_VALUE[i+1] == Y_VALUE[i]-1){\n\t\t\t\tl = 0;\n\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\tm = (l+r)/2;\n\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\twhile(l <= r){\n\t\t\t\t\tif(V[i+1][m].x == V[i][k].x+1){\n\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(loc != BIG_NUM)right += V[i+1][loc].w;\n\t\t\t}\n\n\t\t\tans = max(ans,self+right);\n\n\t\t\tpre_y = i;\n\t\t\tpre_x = V[i][k].x;\n\t\t}\n\t}\n\n\tprintf(\"%d / 1\\n\",ans);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<int, int>;\n    vector<P> po;\n    map<P, int> mp;\n    for (int i = 0, y = 0, x = 0, w = 0; i < N; i++) { cin >> y >> x >> w, po.push_back({y, x}), mp[{y, x}] += w; }\n    int ans = 0;\n    for (const auto& p : po) {\n        const int y = p.first, x = p.second;\n        ans = max(ans, mp[{y, x}] + mp[{y - 1, x}] + mp[{y, x - 1}] + mp[{y - 1, x - 1}]);\n        ans = max(ans, mp[{y, x}] + mp[{y + 1, x}] + mp[{y, x - 1}] + mp[{y + 1, x - 1}]);\n        ans = max(ans, mp[{y, x}] + mp[{y - 1, x}] + mp[{y, x + 1}] + mp[{y - 1, x + 1}]);\n        ans = max(ans, mp[{y, x}] + mp[{y + 1, x}] + mp[{y, x + 1}] + mp[{y + 1, x + 1}]);\n    }\n    cout << ans << \" / \" << 1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nset<pa2> se;\nmap<pa2,int> ma;\n   signed main(){\n   \tint n;\ncin>>n;\n   \tfor(int i=0;i<n;i++){\n   \t\tint y,yy,yyy;\n   \t\tcin>>y>>yy>>yyy;\n   \t\t\tse.insert((pa2){y,yy});\n   \t\t\n   \t\tma[(pa2){y,yy}]=yyy;\n   \t}\n   \tint ans=0;\n   \tfor(auto it=se.begin();it!=se.end();it++){\n   \t\tpa2 q=*it;\n   \t\t//cout<<q.x<<\" \"<<q.y<<endl;\n   \t\tint r=ma[q];\n   \t\t\n   \t\t\tif(ma.find((pa2){q.x+1,q.y})!=ma.end()) r+=ma[(pa2){q.x+1,q.y}];\n   \t\tif(ma.find((pa2){q.x,q.y+1})!=ma.end()) r+=ma[(pa2){q.x,q.y+1}];\n   \t\tif(ma.find((pa2){q.x+1,q.y+1})!=ma.end()) r+=ma[(pa2){q.x+1,q.y+1}];\n   \t\tans=max(ans,r);\n   \t}\n   \tcout<<ans<<\" / \"<<1<<endl;\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[3] = { 1,1,0 }, dy[3] = { 0,1,1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif ((j / (1 << k)) % 2 == 0) {\n\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[k], get<1>(x[i]) + dy[k], 0)) - x;\n\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[k] && get<1>(x[c]) == get<1>(x[i]) + dy[k]) {\n\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??°?????????????????????2???????????????????????????????????°????????£?????????\n#include <iostream>\n#include <algorithm>\n#include <tuple>\n#define int long long\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\nint n;\nT t[100000];\t//(x, y, w)\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tif (n == 1) { cout << w << endl; return 0; }\n\t\tt[i] = T(x, y, w);\n\t}\n\tsort(t, t + n);\n\t\n\tint si = 0;\n\tint bo = 1;\n\t\n\tfor (i = 0; i < n - 1; i++) {\n\t\tint id = lower_bound(t, t + n, T(get<0>(t[i]) + 1, get<1>(t[i]), -1)) - t;\n\t\tif (id == n) continue;\n\t\t\n\t\tint dx = get<0>(t[id]) - get<0>(t[i]);\n\t\tint dy = get<1>(t[id]) - get<1>(t[i]);\n\t\tint area = dx * dy;\t\n\t\tint num = get<2>(t[i]) + get<2>(t[id]);\n\t\t\n\t\tif (si * area < num * bo) { si = num; bo = area; }\n\t}\n\t\n\tint g = gcd(si, bo);\n\tsi /= g;\n\tbo /= g;\n\tcout << si << \" / \" << bo << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n#define size_t long long\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tmap<pair<size_t, size_t>, size_t> foxes;\n\tauto count = [&foxes](size_t x, size_t y) -> size_t {\n\t\tauto it = foxes.find(make_pair(x, y));\n\t\tif (it == foxes.end()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn it->second;\n\t\t}\n\t};\n\n\tfor (int i = 0; i < N; i++) {\n\t\tsize_t x, y, f;\n\t\tcin >> x >> y >> f;\n\t\tfoxes[make_pair(x, y)] = f;\n\t}\n\n\tsize_t max_foxes = 0;\n\tfor (auto v : foxes) {\n\t\tauto x = v.first.first;\n\t\tauto y = v.first.second;\n\t\tauto num = v.second +\n\t\t\tcount(x + 1, y) +\n\t\t\tcount(x, y + 1) +\n\t\t\tcount(x + 1, y + 1);\n\t\tmax_foxes = max(max_foxes, num);\n\t\tnum = v.second +\n\t\t\tcount(x - 1, y) +\n\t\t\tcount(x, y + 1) +\n\t\t\tcount(x - 1, y + 1);\n\t\tmax_foxes = max(max_foxes, num);\n\t}\n\tcout << max_foxes << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nint n;\nvector<Q> s;\n\nint access(const P& p){\n\tvector<Q>::iterator it = lower_bound(s.begin(), s.end(), Q(p, 0));\n\treturn it != s.end() && it->first == p ? it->second : 0;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tint x, y, w;\n\t\tscanf(\"%d%d%d\", &x, &y, &w);\n\t\ts.push_back(Q(P(x, y), w));\n\t}\n\tsort(s.begin(), s.end());\n\tint ans = 0;\n\trep(i, n){\n\t\tint u = s[i].first.first;\n\t\tint v = s[i].first.second;\n\t\tint a = access(P(u - 1, v));\n\t\tint b = access(P(u - 1, v + 1));\n\t\tint c = access(P(u, v));\n\t\tint d = access(P(u, v + 1));\n\t\tint e = access(P(u + 1, v));\n\t\tint f = access(P(u + 1, v + 1));\n\t\tans = max(max(a + b + c + d, c + d + e + f), ans);\n\t}\n\tprintf(\"%d / 1\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nmap<P,int> mp,mpc;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,N){\n\t\tint x,y,w;\n\t\tcin>>x>>y>>w;\n\t\tmp[P(x,y)]=w;\n\t}\n\tint ans=0;\n\tmpc=mp;\n\tfor(auto pp:mpc){\n\t\tP p=pp.fs;\n\t\tint x=p.fs,y=p.sc;\n\t\trep(i,4){\n\t\t\tint tmp=mp[P(x,y)]\n\t\t\t+mp[P(x+dx[i],y+dy[i])]\n\t\t\t+mp[P(x+dx[(i+1)%4],y+dy[(i+1)%4])]\n\t\t\t+mp[P(x+dx[i]+dx[(i+1)%4],y+dy[i]+dy[(i+1)%4])];\n\t\t\tchmax(ans,tmp);\n\t\t}\n\t}\n\tcout<<ans<<\" / 1\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nint n, ret, res, ptr; tuple<int, int, int> d[100000];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d\", &get<0>(d[i]), &get<1>(d[i]), &get<2>(d[i]));\n\tsort(d, d + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = get<2>(d[i]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]), get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t\tres = get<2>(d[i]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]), get<1>(d[i]), 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) && get<1>(d[ptr]) == get<1>(d[i]) - 1) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]), 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i] - 1)) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t}\n\tprintf(\"%d / 1\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define f first\n#define s second\nusing namespace std;\n\nint main()\n{\n  int N,x,y,w;\n  vector<pair<pair<int,int>,int> >V;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x>>y>>w;\n    V.push_back(make_pair(make_pair(x,y),w));\n  }\n  //sort(V.begin(),V.end());\n  int ans=0,sum;\n  for(int i=0;i<N;i++){\n    sum=V[i].s;\n    for(int j=1;j<N;j++){\n      if(V[i].f.f==V[j].f.f && V[i].f.s+1==V[j].f.s){\n\tsum+=V[j].s;\n      }\n      else if(V[i].f.f+1==V[j].f.f && V[i].f.s==V[j].f.s){\n\tsum+=V[j].s;\n      }\n      else if(V[i].f.f+1==V[j].f.f && V[i].f.s+1==V[j].f.s){\n\tsum+=V[j].s;\n      }\n    }\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / 1\"<<endl;\n\n  //for(int i=0;i<N;i++)cout<<V[i].f.f<<\" \"<<V[i].f.s<<\" \"<<V[i].s<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tmap<pii,int>ma;\n\tvvi in(n);\n\trep(i,n){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tin[i]=vi{a,b,c};\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tll sum=0;\n\t\t\tint sx=min(in[q][0],in[q][0]+x);\n\t\t\tint gx=max(in[q][0],in[q][0]+x);\n\t\t\tint sy=min(in[q][1],in[q][1]+y);\n\t\t\tint gy=max(in[q][1],in[q][1]+y);\t\t\t\n\t\t\tloop(i,sx,gy+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tll area=(gx-sx)*(gy-sy);\n\t\t\tll gc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;int main(){int N;cin >> N;map<pair<int, int>, int> mp;for (int i = 0, y, x, w; i < N; i++) cin >> y >> x >> w, mp[{y, x}] += w, mp[{y - 1, x}] += w, mp[{y, x - 1}] += w, mp[{y - 1, x - 1}] += w;int ans = 0;for (const auto& p : mp) ans = max(ans, p.second);cout << ans << \" / \" << 1 << endl;return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\n\nint main(){\n    int n;\n    cin>>n;\n    map<pair<int,int>,int> mp;\n    for(int i=0;i<n;i++){\n        int x,y,w;\n        cin>>x>>y>>w;\n        mp[{x,y}]=w;\n    }\n    ll res=0;\n    for(auto &e:mp){\n        int x=e.first.first,y=e.first.second;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                ll sc=0;\n                for(int ii=0;ii<2;ii++){\n                    for(int jj=0;jj<2;jj++){\n                        if(mp.count({x+i+ii,y+j+jj})) sc+=mp[{x+i+ii,y+j+jj}];\n                    }\n                }        \n                res=max(res,sc);\n            }\n        }\n        \n        \n    }\n    cout<<res<<\" / 1\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(ll i=0,i##_cond=(n);i<i##_cond;i++)\n#define FOR(i,a,b) for(ll i=(a),i##_cond=(b);i<i##_cond;i++)\n#define ROF(i,a,b) for(ll i=(a)-1,i##_cond=(b);i>=i##_cond;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define UNIQUE(v) v.erase(unique(all(v)),v.end())\n#define SUM(a) accumulate(all(a),0)\n#define sz(x) ((ll)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<ll,ll> pii;\n\nconst ll inf = 1ll<<62;\nconst ll mod = 1e9+7;\n\n#define int ll\n\nmain()\n{\n  map<pii,int> mp;\n  int n; cin >> n;\n  rep(i,n){\n    int x,y,w; cin >> x >> y >> w;\n    rep(j,2) rep(k,2)\n      mp[pii(x+j,y+k)] += w;\n  }\n  int maxv = 0;\n  for(auto x : mp)\n    maxv = max(maxv, x.snd);\n  cout << maxv << \" / 1\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nint n, ret, res, ptr; tuple<int, int, int> d[100000];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d\", &get<0>(d[i]), &get<1>(d[i]), &get<2>(d[i]));\n\tsort(d, d + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = get<2>(d[i]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]), get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t}\n\tprintf(\"%d / 1\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        cin >> W[make_pair(x, y)];\n    }\n\n    int ans = 0;\n    for (auto pp : W) {\n        int x, y;\n        tie(x, y) = pp.first;\n\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x + dx, y + dy);\n                sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tmap<pair<int, int>, int> mp;\n\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tint x, y, w;\n\t\tscanf(\"%d %d %d\", &x, &y, &w);\n\t\tmp[make_pair(x, y)] = w;\n\t}\n\n\tint dy[] = {1, 1, 0, 0};\n\tint dx1[] = {0, 1, 1, 0}, dx2[] = {0, -1, -1, 0};\n\n\tint ans = 0;\n\n\tfor (auto pos : mp){\n\t\tint t1 = 0, t2 = 0;\n\t\tpair<int, int> base = pos.first;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tif (mp.count(make_pair(base.first + dy[i], base.second + dx1[i])))\n\t\t\t\tt1 += mp[make_pair(base.first + dy[i], base.second + dx1[i])];\n\t\t\t\n\t\t\tif (mp.count(make_pair(base.first + dy[i], base.second + dx2[i])))\n\t\t\t\tt2 += mp[make_pair(base.first + dy[i], base.second + dx2[i])];\n\t\t}\n\t\tans = max({ans, t1, t2});\n\t}\n\n\tprintf(\"%d / 1\\n\", ans);\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tmap<pii,int>ma;\n\tvvi in(n);\n\trep(i,n){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tin[i]=vi{a,b,c};\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tll sum=0;\n\t\t\tint sx=min(in[q][0],in[q][0]+x);\n\t\t\tint gx=max(in[q][0],in[q][0]+x);\n\t\t\tint sy=min(in[q][1],in[q][1]+y);\n\t\t\tint gy=max(in[q][1],in[q][1]+y);\t\t\t\n\t\t\tloop(i,sx,gy+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tll area=(gx-sx)*(gy-sy);\n\t\t\tll gc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int N;\n  map< pair< int, int >, int > p1, p2;\n  \n  cin >> N;\n  while(N--) {\n    int x, y, w;\n    cin >> x >> y >> w;\n    p1[{x, y}] = p2[{x, y}] = w;\n  }\n  int ret = 0;\n  for(const auto& p : p1) {\n    int weight = 0;\n    for(int i = 0; i <= 1; i++) {\n      for(int j = 0; j <= 1; j++) {\n        weight += p2[{p.first.first + i, p.first.second + j}];\n      }\n    }\n    ret = max(ret, weight);\n  }\n  cout << ret << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    int ans = 0;\n    vector<map<int,int> > t(101010);\n    vector<vector<int> > u(101010);\n    for (int i = 0; i < n; i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        t[x][y] = z;\n        u[x].push_back(y);\n        ans = max(ans, z);\n    }\n    for (int i = 0; i < 100001; i++) {\n        if (!u[i].size()) continue;\n        for (int j = 0; j < u[i].size(); j++) {\n            int a = u[i][j];\n            ans = max(ans, t[i][a]+t[i][a+1]+t[i+1][a]+t[i+1][a+1]);\n            ans = max(ans, t[i][a]+t[i][a-1]+t[i+1][a]+t[i+1][a-1]);\n        }\n    }\n    cout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tmap<pair<int, int>, int> mp;\n\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++){\n\t\tint x, y, w;\n\t\tscanf(\"%d %d %d\", &x, &y, &w);\n\t\tmp[make_pair(x, y)] = w;\n\t}\n\n\tint dy[] = {1, 1, 0, 0};\n\tint dx1[] = {0, 1, 1, 0}, dx2[] = {0, -1, -1, 0};\n\n\tint ans = 0;\n\n\tfor (auto pos : mp){\n\t\tint t1 = 0, t2 = 0;\n\t\tpair<int, int> base = pos.first;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tif (mp.count(make_pair(base.first + dy[i], base.second + dx1[i])))\n\t\t\t\tt1 += mp[make_pair(base.first + dy[i], base.second + dx1[i])];\n\t\t\t\n\t\t\tif (mp.count(make_pair(base.first + dy[i], base.second + dx2[i])))\n\t\t\t\tt2 += mp[make_pair(base.first + dy[i], base.second + dx2[i])];\n\t\t}\n\t\tans = max({ans, t1, t2});\n\t}\n\n\tprintf(\"%d / 1\\n\", ans);\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; cin >> N;\n  map<pair<int, int>, ll> mp;\n  vector<pair<int, int>> vs;\n  rep(i, N) {\n    int x, y, w; cin >> x >> y >> w;\n    vs.emplace_back(x, y);\n    mp[{x, y}] += w;\n  }\n\n  ll ans = 0;\n\n  rep(i, vs.size()) {\n    int x = vs[i].first, y = vs[i].second;\n    maximize(ans, (ll)mp[{x, y}] + mp[{x + 1, y}] + mp[{x, y + 1}] + mp[{x + 1, y + 1}]);\n  }\n\n  cout << ans << \" / 1\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nint n;\nvector<Q> s;\n\nint access(const P& p){\n\tvector<Q>::iterator it = lower_bound(s.begin(), s.end(), Q(p, 0));\n\treturn it != s.end() && it->first == p ? it->second : 0;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tint x, y, w;\n\t\tscanf(\"%d%d%d\", &x, &y, &w);\n\t\ts.push_back(Q(P(x, y), w));\n\t}\n\tsort(s.begin(), s.end());\n\tint ans = 0;\n\trep(i, n){\n\t\tint u = s[i].first.first;\n\t\tint v = s[i].first.second;\n\t\tint a = access(P(u - 1, v));\n\t\tint b = access(P(u - 1, v + 1));\n\t\tint c = access(P(u, v));\n\t\tint d = access(P(u, v + 1));\n\t\tint e = access(P(u + 1, v));\n\t\tint f = access(P(u + 1, v + 1));\n\t\tans = max(max(a + b + c + d, c + d + e + f), ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,-1,-1,1};\nconst int dy[4]={1,1,-1,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<int, map<int, int>> w;\n\nint main(void){\n    int n; cin >> n;\n\n    vector<tuple<int, int, int>> xyw;\n    rep(loop, n){\n        int x, y, ww; cin >> x >> y >> ww;\n        w[x][y] = ww;\n        xyw.push_back(make_tuple(x, y, ww));\n    }\n\n    int res = 0;\n    for(auto & e : xyw){\n        int x, y;\n        tie(x, y, ignore) = e;\n\n        rep(i, 4){\n            vi xs = { x, x + dx[i] };\n            vi ys = { y, y + dy[i] };\n\n            int cur = 0;\n            for(auto & xx : xs){\n                for(auto & yy : ys){\n                    cur += w[xx][yy];\n                }\n            }\n\n            chmax(res, cur);\n        }\n    }\n\n    cout << res << \" / 1\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n// Inserted snippets: io, root\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntemplate<typename H> bool chmin(H& v1, const H v2) { if (v1 > v2) { v1 = v2; return true; } return false; }\ntemplate<typename H> bool chmax(H& v1, const H v2) { if (v1 < v2) { v1 = v2; return true; } return false; }\ntemplate<typename H> void read(H& head) { cin >> head; }\ntemplate<typename H, typename ...T> void read(H& head, T& ...tail) { cin >> head; read(tail...); }\ntemplate<typename H> void write(H head) { cout << head << '\\n'; }\ntemplate<typename H, typename ...T> void write(H head, T ...tail) { cout << head << \" \"; write(tail...); }\ntemplate<typename ...T> void die(T ...tok) { write(tok...); exit(0); }\n// End snippets\n\nint x[100005], y[100005], w[100005];\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(cin.failbit);\n\n\tint n; read(n);\n\tmap<pair<int, int>, int> mp;\n\trep(i, 0, n) {\n\t\tread(x[i], y[i], w[i]);\n\t\tmp[{x[i], y[i]}] = w[i];\n\t}\n\tint ans = 0;\n\trep(i, 0, n) {\n\t\tll x = ::x[i], y = ::y[i];\n\t\tfor (int dx : {-1, 1}) for (int dy : {-1, 1})\n\t\t\tchmax(ans, mp[{x, y}] + mp[{x + dx, y}] + mp[{x, y + dy}] + mp[{x + dx, y + dy}]);\n\t}\n\twrite(ans, \"/\", 1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing P = pair<int, int>;\n\nconst int dx[] = {0, 1, 1, 0};\nconst int dy[] = {0, 0, 1, 1};\n\nint main() {\n  int n;\n  cin >> n;\n  map<P, int> mp;\n  vector<int> x(n), y(n), w(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i] >> w[i];\n    mp[P(x[i], y[i])] = w[i];\n  }\n  int ans = 0;\n  REP(i, n) {\n    REP(j, 4) {\n      P cur = {x[i] + dx[j] - 1, y[i] + dy[j] - 1};\n      int s = 0;\n      REP(k, 4) {\n        P nxt = {cur.first + dx[k], cur.second + dy[k]};\n        s += mp[nxt];\n      }\n      ans = max(ans, s);\n    }\n  }\n  cout << ans << \" / 1\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nusing P = pair<int,int>;\nint main(){\n    int N;\n    cin>>N;\n    map<P,int> M;\n    for(int i=0;i<N;i++){\n        int x,y,w;\n        cin>>x>>y>>w;\n        M[P(x,y)]+=w;\n    }\n    int ans = 0;\n    for(auto p:M){\n        int x,y;\n        tie(x,y)=p.first;\n        int sum = p.second;\n        if(M.find(P(x+1,y))!=M.end()) sum+=M[P(x+1,y)];\n        if(M.find(P(x,y+1))!=M.end()) sum+=M[P(x,y+1)];\n        if(M.find(P(x+1,y+1))!=M.end()) sum+=M[P(x+1,y+1)];\n        ans = max(ans,sum);\n    }\n    cout<<ans<<\" / 1\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[3] = { 1,1,0 }, dy[3] = { 0,1,1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif ((j / (1 << k)) % 2 == 0) {\n\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[k], get<1>(x[i]) + dy[k], 0)) - x;\n\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[k] && get<1>(x[c]) == get<1>(x[i]) + dy[k]) {\n\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\n//constexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tint kkt = 1;\n\twhile (kkt--) {\n\t\tll N; scanf(\"%lld\", &N);\n\t\tmap<pair<ll, ll>, ll> mp;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tll x, y, w; scanf(\"%lld %lld %lld\", &x, &y, &w);\n\t\t\tmp[{x, y}] += w;\n\t\t}\n\t\tll res = 0;\n\t\tfor (auto p : mp) {\n\t\t\t{\n\t\t\t\tll x = p.first.first;\n\t\t\t\tll y = p.first.second;\n\t\t\t\tll sum = 0;\n\t\t\t\tsum += p.second;\n\t\t\t\tif (mp.find({ x + 1, y }) != mp.end()) sum += mp[{x + 1, y}];\n\t\t\t\tif (mp.find({ x + 1, y + 1 }) != mp.end()) sum += mp[{x + 1, y + 1}];\n\t\t\t\tif (mp.find({ x,y + 1 }) != mp.end()) sum += mp[{x, y + 1}];\n\t\t\t\tchmax(res, sum);\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tll x = p.first.first;\n\t\t\t\tll y = p.first.second;\n\t\t\t\tll sum = 0;\n\t\t\t\tsum += p.second;\n\t\t\t\tif (mp.find({ x + 1, y }) != mp.end()) sum += mp[{x + 1, y}];\n\t\t\t\tif (mp.find({ x + 1, y - 1 }) != mp.end()) sum += mp[{x + 1, y - 1}];\n\t\t\t\tif (mp.find({ x,y - 1 }) != mp.end()) sum += mp[{x, y - 1}];\n\t\t\t\tchmax(res, sum);\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tll x = p.first.first;\n\t\t\t\tll y = p.first.second;\n\t\t\t\tll sum = 0;\n\t\t\t\tsum += p.second;\n\t\t\t\tif (mp.find({ x - 1, y }) != mp.end()) sum += mp[{x - 1, y}];\n\t\t\t\tif (mp.find({ x - 1, y - 1 }) != mp.end()) sum += mp[{x - 1, y - 1}];\n\t\t\t\tif (mp.find({ x,y - 1 }) != mp.end()) sum += mp[{x, y - 1}];\n\t\t\t\tchmax(res, sum);\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tll x = p.first.first;\n\t\t\t\tll y = p.first.second;\n\t\t\t\tll sum = 0;\n\t\t\t\tsum += p.second;\n\t\t\t\tif (mp.find({ x - 1, y }) != mp.end()) sum += mp[{x - 1, y}];\n\t\t\t\tif (mp.find({ x - 1, y + 1 }) != mp.end()) sum += mp[{x - 1, y + 1}];\n\t\t\t\tif (mp.find({ x,y + 1 }) != mp.end()) sum += mp[{x, y + 1}];\n\t\t\t\tchmax(res, sum);\n\t\t\t}\n\n\t\t}\n\n\t\tcout << res << \" / 1\" << endl;\n\t}\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tmap<pair<int,int>,int>ma;\n\tvvi in(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%lld %lld %lld\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\t\t\t\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int N; cin >> N;\n  vector<int> x(N), y(N);\n  map<int, map<int, int> > G;\n  for(int i = 0; i < N; ++i) {\n    cin >> x[i] >> y[i];\n    cin >> G[y[i]][x[i]];\n  }\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    res = max(res, G[y[i]][x[i]] + G[y[i]][x[i]+1]\n              + G[y[i]+1][x[i]] + G[y[i]+1][x[i]+1]);\n    res = max(res, G[y[i]][x[i]] + G[y[i]][x[i]-1]\n              + G[y[i]+1][x[i]] + G[y[i]+1][x[i]-1]);\n  }\n  cout << res << \" / \" << 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  map<P,int> mp;\n  int ans=0,n,x,y,w;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y>>w;\n    for(int j=0;j<2;j++)\n      for(int k=0;k<2;k++)\n\tans=max(ans,mp[P(x+j,y+k)]+=w);\n  }\n  cout<<ans<<\" / \"<<1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<ll,int>ma;\nvvi in;\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[a*1000000001ll+b]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d=1;\n\trep(q,n){\n\t\tloop(x,-1,2)loop(y,-1,2)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)if(ma.count(i*1000000001ll+j))sum+=ma[i*1000000001ll+j];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nint n,x[N],y[N],w[N];\nmap<P,int> fox;\nint dy[6]={1,1,0,1,1,0};\nint dx[6]={0,1,1,-1,0,-1};\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i]>>w[i];\n    fox[P(y[i],x[i])]=w[i];\n  }\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int sum=w[i];\n    for(int j=0;j<6;j++){\n      int ny=y[i]+dy[j];\n      int nx=x[i]+dx[j];\n      if(fox.count(P(ny,nx)))\n\tsum+=fox[P(ny,nx)];\n      if(j==2){\n\tans=max(ans,sum);\n\tsum=w[i];\n      }\n    }\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / \"<<1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dx[8] = {\n\t1,\n\t1,\n\t0,\n\t-1,\n\t-1,\n\t-1,\n\t0,\n\t1,\n},\n\tdy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tvector<P> v(n);\n\tmap<P, int> mp;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tv[i] = P(x, y);\n\t\tmp[v[i]] = w;\n\t}\n\tint ma = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x = v[i].first, y = v[i].second;\n\t\tfor (int j = 0; j < 8; j += 2)\n\t\t{\n\t\t\tint sum = mp[P(x, y)] + mp[P(x + dx[j], y + dy[j])] + mp[P(x + dx[(j + 1) % 8], y + dy[(j + 1) % 8])] + mp[P(x + dx[(j + 2) % 8], y + dy[(j + 2) % 8])];\n\t\t\tma = max(ma, sum);\n\t\t}\n\t}\n\tcout << ma << \" / 1\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tmap<pair<int, int>, int>mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W >> H >> K;\n\t\tmp[{W, H}] += K;\n\t}\n\tint ans = 0;\n\tfor (auto i : mp) {\n\t\t{\n\t\t\tint box = 0;\n\t\t\tfor (int j = 0; j <= 1; j++) {\n\t\t\t\tfor (int k = 0; k <= 1; k++) {\n\t\t\t\t\tif (mp.find({ i.first.first + j,i.first.second + k }) != mp.end()) {\n\t\t\t\t\t\tbox += mp[{i.first.first + j, i.first.second + k}];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, box);\n\t\t}\n\t\t{\n\t\t\tint box = 0;\n\t\t\tfor (int j = 0; j <= 1; j++) {\n\t\t\t\tfor (int k = -1; k <= 0; k++) {\n\t\t\t\t\tif (mp.find({ i.first.first + j,i.first.second + k }) != mp.end()) {\n\t\t\t\t\t\tbox += mp[{i.first.first + j, i.first.second + k}];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, box);\n\t\t}\n\t\t{\n\t\t\tint box = 0;\n\t\t\tfor (int j = -1; j <= 0; j++) {\n\t\t\t\tfor (int k = 0; k <= 1; k++) {\n\t\t\t\t\tif (mp.find({ i.first.first + j,i.first.second + k }) != mp.end()) {\n\t\t\t\t\t\tbox += mp[{i.first.first + j, i.first.second + k}];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, box);\n\t\t}\n\t\t{\n\t\t\tint box = 0;\n\t\t\tfor (int j = -1; j <= 0; j++) {\n\t\t\t\tfor (int k = -1; k <= 0; k++) {\n\t\t\t\t\tif (mp.find({ i.first.first + j,i.first.second + k }) != mp.end()) {\n\t\t\t\t\t\tbox += mp[{i.first.first + j, i.first.second + k}];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, box);\n\t\t}\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing pr = pair<int, int>;\n\nint n;\nmap<pr, int> g;\n\nint main()\n{\n\tcin >> n;\n\trep(i, n){\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tg[pr(x, y)] = w;\n\t}\n\n\tint res = 0;\n\tfor (auto v : g){\n\t\tpr p = v.fi;\n\t\tint s = 0;\n\t\trep(i, 2) rep(j, 2){\n\t\t\tif (g.count(pr(p.fi + i, p.se + j))){\n\t\t\t\ts += g[pr(p.fi + i, p.se + j)];\n\t\t\t}\n\t\t}\n\t\tchmax(res, s);\n\t}\n\n\tcout << res << \" / \" << 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int N, W;\n    cin >> N;\n    vector<int> X(N), Y(N);\n    map<int, map<int, int>> coor;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i] >> W;\n        coor[X[i]][Y[i]] = W;\n    }\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        res = max(res, coor[X[i]][Y[i]] +\n                       coor[X[i]+1][Y[i]] +\n                       coor[X[i]][Y[i]+1] +\n                       coor[X[i]+1][Y[i]+1]);\n    }\n    cout << res << \" / \" << 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef pair< int, int > pii;\n\nconst int dx[2][3] = { {0,1,1}, {1,1,0} };\nconst int dy[2][3] = { {-1,-1,0}, {0,1,1} };\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tmap< pii, int > lattice;\n\t\n\tfor_(i,0,N) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tlattice[pii(x,y)] = w;\n\t}\n\t\n\tint ans = 0;\n\t\n\tmap< pii, int >::iterator it = lattice.begin(), eit = lattice.end();\n\t\n\tfor (; it != eit; ++it) {\n\t\tpii p = (*it).first;\n\t\t\n\t\tfor_(di,0,2) {\n\t\t\tint val = (*it).second;\n\t\t\t\n\t\t\tfor_(dj,0,3) {\n\t\t\t\tpii fp(p.first + dx[di][dj], p.second + dy[di][dj]);\n\t\t\t\tif (lattice.count(fp)) val += lattice[fp];\n\t\t\t}\n\t\t\t\n\t\t\tans = max(ans, val);\n\t\t}\n\t}\n\t\n\tcout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll inf=1e12;\nconst double eps=1e-9;\n/*struct Fox\n{\n    ll x,y,w;\n    Fox(ll _x,ll _y,ll _w):x(_x),y(_y),w(_w){}\n    bool operator < (const Fox &a)const\n    {\n        return (abs(a.x-x)<=1 && abs(a.y-y)<=1 );\n    }\n    \n};*/\n\nint main(void)\n{\n    map<pll,ll> Foxmap;\n    int N;\n    cin >> N;\n    ll ans=0;\n    vector<pll> xy(N);\n    for(int i=0;i<N;i++)\n    {\n        ll x,y,w;\n        cin >> x >> y>> w;\n        Foxmap[pll(x,y)]=w;\n        xy[i]=pll(x,y);\n    }\n    for(int i=0;i<N;i++)\n    {\n        ll s1=0,s2=0,s3=0,s4=0;\n        //各点を中心として,4つの1*1の正方形にして考えると...\n        //左上\n        s1=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second-1LL)]+Foxmap[pll(xy[i].first,xy[i].second-1LL)];\n        //左下\n        s2=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second+1LL)]+Foxmap[pll(xy[i].first,xy[i].second+1LL)];\n        //右下\n        s3=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second+1LL)]+Foxmap[pll(xy[i].first,xy[i].second+1LL)];\n        //右上\n        s4=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second-1LL)]+Foxmap[pll(xy[i].first,xy[i].second-1LL)];\n        //cout << s1 << ' ' << s2 << ' ' << s3 << ' ' << s4 << endl;\n        ans=max(ans,s1);\n        ans=max(ans,s2);\n        ans=max(ans,s3);\n        ans=max(ans,s4);\n    }\n    cout << ans << ' ' << '/' << ' ' << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdlib>\n#include <set>\n#include <map>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nmap<P, llint> mp;\nset<P> S;\n\nllint get(llint x, llint y)\n{\n\tif(mp.count(P(x, y))) return mp[P(x, y)];\n\treturn 0;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tllint x, y, w;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> x >> y >> w;\n\t\tmp[P(x, y)] += w;\n\t\tS.insert(P(x, y));\n\t}\n\tfor(auto it = S.begin(); it != S.end(); it++){\n\t\tllint x = it->first, y = it->second;\n\t\tmp[P(x, y)], mp[P(x-1, y)], mp[P(x, y-1)], mp[P(x-1, y-1)];\n\t}\n\t\n\tllint ans = 0;\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tllint x = it->first.first, y = it->first.second;\n\t\tans = max(ans, get(x, y)+get(x+1, y)+get(x, y+1)+get(x+1, y+1));\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll gcd(ll a, ll b) {\n\tif (b == 0)return a;\n\treturn gcd(b, a%b);\n}\n\nll n, lx = INF, ux = -INF, ly = INF, uy = -INF;\nll sum;\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tlx = min(lx, x);\n\t\tux = max(ux, x);\n\t\tly = min(ly, y);\n\t\tuy = max(uy, y);\n\t\tsum += w;\n\t}\n\tll GCD = gcd(sum, (ux - lx)*(uy - ly));\n\tcout << sum / GCD << \" / \" << (ux - lx)*(uy - ly) / GCD << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\nusing namespace std;\nint n;\nint a=0;\npair<pair<int,int>,int>x[1<<17];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>x[i].first.first>>x[i].first.second>>x[i].second;\n\t\ta=max(a,x[i].second);\n\t}\n\tsort(x,x+n,[](pair<pair<int,int>,int>&a,pair<pair<int,int>,int>&b){\n\t\treturn a.first.first+a.first.second<b.first.first+b.first.second;\n\t});\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint now=0;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tif(x[j].first.first+x[j].first.second<\n\t\t\t\tx[i].first.first+x[i].first.second-2)break;\n\t\t\tif(abs(x[i].first.first-x[j].first.first)<=1&&\n\t\t\t\tabs(x[i].first.second-x[j].first.second)<=1)now+=x[j].second;\n\t\t}\n\t\ta=max(a,now);\n\t\tnow=0;\n\t\tfor(int j=i;j<n;j++)\n\t\t{\n\t\t\tif(x[j].first.first+x[j].first.second>\n\t\t\t\tx[i].first.first+x[i].first.second+2)break;\n\t\t\tif(abs(x[i].first.first-x[j].first.first)<=1&&\n\t\t\t\tabs(x[i].first.second-x[j].first.second)<=1)now+=x[j].second;\n\t\t}\n\t\ta=max(a,now);\n\t}\n\tcout<<a<<\" / \"<<1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nset<pa2> se;\nmap<pa2,int> ma;\n   signed main(){\n   \tint n;\ncin>>n;\n   \tfor(int i=0;i<n;i++){\n   \t\tint y,yy,yyy;\n   \t\tcin>>y>>yy>>yyy;\n   \t\t\tse.insert((pa2){y,yy});\n   \t\t\n   \t\tma[(pa2){y,yy}]=yyy;\n   \t}\n   \tint ans=0;\n   \tfor(auto it=se.begin();it!=se.end();it++){\n   \t\tpa2 q=*it;\n   \t\t//cout<<q.x<<\" \"<<q.y<<endl;\n   \t\tint r=ma[q];\n   \t\t\n   \t\t\tif(ma.find((pa2){q.x+1,q.y})!=ma.end()) r+=ma[(pa2){q.x+1,q.y}];\n   \t\tif(ma.find((pa2){q.x,q.y+1})!=ma.end()) r+=ma[(pa2){q.x,q.y+1}];\n   \t\tif(ma.find((pa2){q.x+1,q.y+1})!=ma.end()) r+=ma[(pa2){q.x+1,q.y+1}];\n   \t\t\n   \t\t\n   \t\tans=max(ans,r);\n   \t\t\n   \t\tr=ma[q];\n   \t\t\n   \t\t\tif(ma.find((pa2){q.x-1,q.y})!=ma.end()) r+=ma[(pa2){q.x-1,q.y}];\n   \t\tif(ma.find((pa2){q.x,q.y+1})!=ma.end()) r+=ma[(pa2){q.x,q.y+1}];\n   \t\tif(ma.find((pa2){q.x-1,q.y+1})!=ma.end()) r+=ma[(pa2){q.x-1,q.y+1}];\n   \t\t\n   \t\t\n   \t\tans=max(ans,r);\n   \t\t\n   \t\tr=ma[q];\n   \t\t\n   \t\t\tif(ma.find((pa2){q.x+1,q.y})!=ma.end()) r+=ma[(pa2){q.x+1,q.y}];\n   \t\tif(ma.find((pa2){q.x,q.y-1})!=ma.end()) r+=ma[(pa2){q.x,q.y-1}];\n   \t\tif(ma.find((pa2){q.x+1,q.y-1})!=ma.end()) r+=ma[(pa2){q.x+1,q.y-1}];\n   \t\t\n   \t\t\n   \t\tans=max(ans,r);\n   \t\t\n   \t\tr=ma[q];\n   \t\t\n   \t\t\tif(ma.find((pa2){q.x-1,q.y})!=ma.end()) r+=ma[(pa2){q.x-1,q.y}];\n   \t\tif(ma.find((pa2){q.x,q.y-1})!=ma.end()) r+=ma[(pa2){q.x,q.y-1}];\n   \t\tif(ma.find((pa2){q.x-1,q.y-1})!=ma.end()) r+=ma[(pa2){q.x-1,q.y-1}];\n   \t\t\n   \t\t\n   \t\tans=max(ans,r);\n   \t}\n   \tcout<<ans<<\" / \"<<1<<endl;\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tVI x(n), y(n), w(n);\n\tmap<P, int> mp;\n\tREP(i,n){\n\t\tcin >> x[i] >> y[i] >> w[i];\n\t\tmp[make_pair(x[i], y[i])] = w[i];\n\t}\n\tint ans = 0;\n\tint dx[] = {1,1,-1,-1}, dy[] = {1,-1,1,-1};\n\tREP(p,n) REP(k,4){\n\t\tint i = x[p], j = y[p];\n\t\tint res = mp[make_pair(i, j)] + mp[make_pair(i+dx[k], j)] + mp[make_pair(i, j+dy[k])] + mp[make_pair(i+dx[k], j+dy[k])];\n\t\tans = max(ans, res);\n\t}\n\n\tprintf(\"%d / 1\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    ll res=0;\n    vector<pair<int,int>> v(n);\n    map<pair<int,int>,ll> mp;\n    for(int i=0;i<n;i++){\n        cin >> v[i].first >> v[i].second;\n        ll w; cin >> w;\n        mp[v[i]]+=w;\n    }\n    for(int i=0;i<n;i++){\n        ll sum;\n        sum=mp[v[i]];\n        if(mp.count(make_pair(v[i].first-1,v[i].second))){\n            sum+=mp[make_pair(v[i].first-1,v[i].second)];\n        }\n        if(mp.count(make_pair(v[i].first-1,v[i].second+1))){\n            sum+=mp[make_pair(v[i].first-1,v[i].second+1)];\n        }\n        if(mp.count(make_pair(v[i].first,v[i].second+1))){\n            sum+=mp[make_pair(v[i].first,v[i].second+1)];\n        }\n        res=max(res,sum);\n\n        sum=mp[v[i]];\n        if(mp.count(make_pair(v[i].first+1,v[i].second))){\n            sum+=mp[make_pair(v[i].first+1,v[i].second)];\n        }\n        if(mp.count(make_pair(v[i].first+1,v[i].second+1))){\n            sum+=mp[make_pair(v[i].first+1,v[i].second+1)];\n        }\n        if(mp.count(make_pair(v[i].first,v[i].second+1))){\n            sum+=mp[make_pair(v[i].first,v[i].second+1)];\n        }\n        res=max(res,sum);\n\n        sum=mp[v[i]];\n        if(mp.count(make_pair(v[i].first+1,v[i].second))){\n            sum+=mp[make_pair(v[i].first+1,v[i].second)];\n        }\n        if(mp.count(make_pair(v[i].first+1,v[i].second-1))){\n            sum+=mp[make_pair(v[i].first+1,v[i].second-1)];\n        }\n        if(mp.count(make_pair(v[i].first,v[i].second-1))){\n            sum+=mp[make_pair(v[i].first,v[i].second-1)];\n        }\n        res=max(res,sum);\n\n        sum=mp[v[i]];\n        if(mp.count(make_pair(v[i].first-1,v[i].second))){\n            sum+=mp[make_pair(v[i].first-1,v[i].second)];\n        }\n        if(mp.count(make_pair(v[i].first-1,v[i].second-1))){\n            sum+=mp[make_pair(v[i].first-1,v[i].second-1)];\n        }\n        if(mp.count(make_pair(v[i].first,v[i].second-1))){\n            sum+=mp[make_pair(v[i].first,v[i].second-1)];\n        }\n        res=max(res,sum);\n    }\n    printf(\"%lld / 1\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\n\nint main(void) {\n    int n;\n    cin >> n;\n    map<pii,int> ma;\n    vi x(n),y(n);\n    rep(i,n){\n        int a,b,c;\n        cin >> a >> b >> c;\n        ma[pii(a,b)] = c;\n        x[i] = a;\n        y[i] = b;\n    }\n    int ans = 0;\n    int dx[] = {0,1,0,1};\n    int dy[] = {0,0,1,1};\n    rep(i,n)rep(j,4){\n        int t = 0;\n        int p = x[i] - dx[j];\n        int q = y[i] - dy[j];\n        //cout << p << \" \" << q << endl;\n        rep(k,4){\n            t += ma[pii(p+dx[k],q+dy[k])];\n        }\n        ans = max(ans, t);\n    }\n    cout << ans << \" / 1\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n#define int ll\n\nvoid solve(){\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<tuple<int, int, int>> inputs;\n\t\tmap<pair<int, int>, int> next;\n\t\tREP(i, n) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tnext[mp(a, b)] = c;\n\t\t\tinputs.push_back(make_tuple(c, a, b));\n\t\t}\n\t\tsort(ALL(inputs));\n\t\tint ans = 0;\n\t\tREP(i, inputs.size()) {\n\t\t\tint dx[4] = { 1,-1,-1,1 };\n\t\t\tint dy[4] = { 1,1,-1,-1 };\n\t\t\tREP(t, 4) {\n\t\t\t\tint cnter = 0;\n\t\t\t\tREP(q, 2) {\n\t\t\t\t\tREP(j, 2) {\n\t\t\t\t\t\tint x = get<1>(inputs[i]) + q * dx[t];\n\t\t\t\t\t\tint y = get<2>(inputs[i]) + j * dy[t];\n\t\t\t\t\t\tcnter += next[mp(x, y)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnter);\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" / 1\" << endl;\n\t\treturn;\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dx[8] = {1,1,0,-1,-1,-1,0,1,}, dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n; cin >> n;\n\tvector<P> v(n);\n\tmap<P, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y, w; cin >> x >> y >> w;\n\t\tv[i] = P(x, y);\n\t\tmp[v[i]] = w;\n\t}\n\tint ma = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = v[i].first, y = v[i].second;\n\t\tfor (int j = 0; j < 8; j += 2) {\n\t\t\tint sum = mp[P(x, y)] + mp[P(x + dx[j], y + dy[j])] + mp[P(x + dx[(j + 1)%8], y + dy[(j + 1)%8])] + mp[P(x + dx[(j + 2)%8], y + dy[(j + 2)%8])];\n\t\t\tma = max(ma, sum);\n\t\t}\n\t}\n\tcout << ma <<\" / 1\" <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<ll,int>ma;\nvvi in;\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[a*1000000001ll+b]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d=1;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[i*1000000001ll+j];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dx[8] = {1,1,0,-1,-1,-1,0,1,}, dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n; cin >> n;\n\tvector<P> v(n);\n\tmap<P, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y, w; cin >> x >> y >> w;\n\t\tv[i] = P(x, y);\n\t\tmp[v[i]] = w;\n\t}\n\tint ma = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = v[i].first, y = v[i].second;\n\t\tfor (int j = 0; j < 8; j += 2) {\n\t\t\tint sum = mp[P(x, y)] + mp[P(x + dx[j], y + dy[j])] + mp[P(x + dx[j + 1], y + dy[j + 1])] + mp[P(x + dx[j + 2], y + dy[j + 2])];\n\t\t\tma = max(ma, sum);\n\t\t}\n\t}\n\tcout << ma <<\"/1\"<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[8] = { 1,1,0,-1,-1,-1,0,1 }, dy[8] = { 0,1,1,1,0,-1,-1,-1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 256; j++) {\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\tif ((j / (1 << k)) % 2 == 0) {\n\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[k], get<1>(x[i]) + dy[k], 0)) - x;\n\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[k] && get<1>(x[c]) == get<1>(x[i]) + dy[k]) {\n\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<ll,int>ma;\nvvi in;\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[a*1000000001ll+b]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d=1;\n\trep(q,n){\n\t\tif(q%100==0)cout<<q<<endl;\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[i*1000000001ll+j];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[3] = { 1,1,0 }, dy[3] = { 0,1,1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif ((j / (1 << k)) == 0) {\n\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<1>(x[i]) + dy[j]) {\n\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<PP> vec;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tvec.push_back(PP(P(x, y), w));\n\t}\n\tsort(vec.begin(), vec.begin());\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll cnt = vec[i].second;\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif(vec[i].first.first + 1 != vec[j].first.first && vec[i].first.first - 1 != vec[j].first.first) break;\n\t\t\tif(vec[i].first.second + 1 != vec[j].first.second && vec[i].first.second - 1 != vec[j].first.second) break;\n\t\t\tcnt += vec[j].second;\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nint main(){\n  int n;cin>>n;\n  map<P,int> m;\n  P p;\n  int i,j,k;\n  int w;\n  for(i=0;i<n;i++){\n    cin >> p.X >> p.Y >> w;\n    m[p]+=w;\n  }\n  int o=0;\n  for(map<P,int>::iterator it=m.begin();it!=m.end();++it){\n    p=it->first;\n    w=it->second;\n    //cout << p.X << p.Y << w << endl;\n    k=0;\n    k+=w;\n    p.X++;\n    if(m.find(p)!=m.end())\n       k+=m[p];\n    p.Y++;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    p.X--;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    o=max(o,k);\n  }\n  cout << o << \" / 1\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint W[400010][400010];\n\nint getWeight(int left, int top)\n{\n  return W[left][top]+W[left+1][top]+W[left][top+1]+W[left+1][top+1];\n}\n\nint main()\n{\n  int N; cin >> N;\n  vector<int> x(N), y(N), w(N);\n  vector<int> X, Y;\n  for(int i = 0; i < N; i++) {\n    cin >> x[i] >> y[i] >> w[i];\n    X.push_back(x[i]-1); X.push_back(x[i]); X.push_back(x[i]+1);\n    Y.push_back(y[i]-1); Y.push_back(y[i]); Y.push_back(y[i]+1);\n  }\n\n  sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n  //memset(W, 0, sizeof(W));\n  for(int i = 0; i < N; i++) {\n    x[i] = find(X.begin(), X.end(), x[i]) - X.begin();\n    y[i] = find(Y.begin(), Y.end(), y[i]) - Y.begin();\n    W[x[i]][y[i]] = w[i];\n  }\n\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    ans = max(ans, getWeight(x[i]-1, y[i]-1));\n    ans = max(ans, getWeight(x[i]-1, y[i]));\n    ans = max(ans, getWeight(x[i], y[i]-1));\n    ans = max(ans, getWeight(x[i], y[i]));\n  }\n  cout << ans << \" / 1\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\n// const ll MOD = 1e9 + 7;\nconst ll MOD = 998244353;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint n;\n\nll dx[] = {0,1,0,1};\nll dy[] = {0,0,1,1};\n\nint main(){\n\tcin >> n;\n\tvector<ll> x(n),y(n),w(n);\n\tmap<P,ll> m;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i] >> w[i];\n\t\tm[P(x[i],y[i])] = w[i];\n\t}\n\tll ans = 0;\n\trep(i,n){\n\t\tfor(int j = -1;j <= 0;j++){\n\t\t\tfor(int k = -1;k <= 0;k++){\n\t\t\t\tll nx = x[i] + j;\n\t\t\t\tll ny = y[i] + k;\n\t\t\t\tll cnt = 0;\n\t\t\t\trep(l,4)cnt += m[P(nx+dx[l],ny+dy[l])];\n\t\t\t\tans = max(ans,cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \" / 1\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\nstruct st{int x,y,w;};\nmap<pii,int> mp;\n\n\nint solve(int y,int x){\n\tint sum = 0;\n\trep(i,2){\n\t\trep(j,2){\n\t\t\tif(mp.count(pii(y+i,x+j))!=0){\n\t\t\t\tsum+=mp[pii(y+i,x+j)];\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[pii(a,b)]=c;\n\t}\n\t\n\tint ans = -1;\n\tint dy[]={0,-1,0,-1};\n\tint dx[]={0,-1,-1,0};\n\t\n\tfor(auto &elm:mp){\n\t\tint y,x;\n\t\ttie(y,x) = elm.first;\n\t\trep(j,4){\n\t\t\tint ddy = y+dy[j];\n\t\t\tint ddx = x+dx[j];\n\t\t\tans = max(ans,solve(ddy,ddx));\n\t\t}\n\t}\n\t\n\tcout<<ans<<\" / 1\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nmap<int,map<int,int> > data;\nint n;\nint x[100001],y[100001],w[100001];\nint dx[4]={0,-1,0,-1};\nint dy[4]={0,0,-1,-1};\nint main(void){\n\tscanf(\"%d\",&n);\n\tif(n==1){\n\t\tprintf(\"0 / 1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n\t\tdata[x[i]][y[i]]+=w[i];\n\t}\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint cnt=0,nx=x[i]+dx[j],ny=y[i]+dx[j];\n\t\t\tfor(int k=0;k<=1;k++){\n\t\t\t\tfor(int l=0;l<=1;l++){\n\t\t\t\t\tcnt+=data[nx+k][ny+l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=max(res,cnt);\n\t\t}\n\t}\n\tprintf(\"%d / 1\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 答えとなる領域は必ず面積1(だと思う)\n#include<iostream>\n#include<map>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    map<int,map<int,int>> m;\n    while(n-- > 0){\n        int x, y, w;\n        cin >> x >> y >> w;\n        m[x][y] += w;\n    }\n    auto getter = [&](int x, int y)->int{\n        return m.count(x) && m[x].count(y) ? m[x][y] : 0;\n    };\n    int ans = 0;\n    for(auto p : m){\n        int x = p.first;\n        for(auto q : p.second){\n            int y = q.first, w = q.second;\n            for(int i : {-1, 1}){\n                for(int j : {-1, 1}){\n                    ans = max(ans, w+getter(x+i,y)+getter(x,y+j)+getter(x+i,y+j));\n                }\n            }\n        }\n    }\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tmap<pii,int>ma;\n\tvp in(n);\n\trep(i,n){\n\t\tll a,b,c;\n\t\tscanf(\"%lld %lld %lld\",&a,&b,&c);\n\t\tin[i]=pii(a,b);\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tll sum=0;\n\t\t\tint sx=min(in[q].first,in[q].first+x);\n\t\t\tint gx=max(in[q].first,in[q].first+x);\n\t\t\tint sy=min(in[q].second,in[q].second+y);\n\t\t\tint gy=max(in[q].second,in[q].second+y);\t\t\t\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tll area=x*y;\n\t\t\tll gc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> x(n), y(n), w(n);\n    map<pair<int, int>, int> s;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d\", &x[i], &y[i], &w[i]);\n        s[{x[i], y[i]}] += w[i];\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = -1; j < 1; ++j) {\n            for (int k = -1; k < 1; ++k) {\n                ll q = 0;\n                for (int l = 0; l < 2; ++l) {\n                    for (int m = 0; m < 2; ++m) {\n                        q += s[{x[i]+j+l, y[i]+k+m}];\n                    }\n                }\n                ans = max(ans, q);\n            }\n        }\n    }\n    printf(\"%lld / 1\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nstruct frac {\n    int a, b;\n    bool operator<(const frac &x) const {\n        return a*x.b < x.a*b;\n    }\n};\n\nmap<int, map<int, int> > mp;\n\nsigned main() {\n    int N; cin >> N;\n\n    vector< pair<pii, int> > vs;\n    rep(i,0,N) {\n        int x, y, w; cin >> x >> y >> w;\n        mp[x][y] = w;\n        vs.push_back(make_pair( make_pair(x, y), w) );\n    }\n\n    frac ans;\n    rep(i,0,N) {\n        int x = vs[i].first.first, y = vs[i].first.second;\n        int w = vs[i].second;\n        chmax(ans, frac{w, 1});\n\n        rep(k,0,8) {\n            int nx = x + dx[k], ny = y + dy[k];\n            chmax(ans, frac{w + mp[nx][ny], 1});\n        }\n    }\n    printf(\"%lld / %lld\\n\", ans.a, ans.b);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tcin>>n;\n\tmap<P,ll> fox;\n\tREP(i,n) {\n\t\tll x,y,w;\n\t\tcin>>x>>y>>w;\n\t\tfox[P(x,y)]+=w;\n\t}\n\tll ans=0;\n\tfor(auto el: fox) {\n\t\tll x,y; tie(x,y)=el.first;\n\t\tll w=el.second;\n\t\t{\n\t\t\tll buf=w;\n\t\t\tif(fox.count(P(x+1,y))) buf+=fox[P(x+1,y)];\n\t\t\tif(fox.count(P(x+1,y+1))) buf+=fox[P(x+1,y+1)];\n\t\t\tif(fox.count(P(x,y+1))) buf+=fox[P(x,y+1)];\n\t\t\tans=max(ans,buf);\n\t\t}\n\t\t{\n\t\t\tll buf=w;\n\t\t\tif(fox.count(P(x-1,y))) buf+=fox[P(x-1,y)];\n\t\t\tif(fox.count(P(x-1,y-1))) buf+=fox[P(x-1,y-1)];\n\t\t\tif(fox.count(P(x,y-1))) buf+=fox[P(x,y-1)];\n\t\t\tans=max(ans,buf);\n\t\t}\n\t\t{\n\t\t\tll buf=w;\n\t\t\tif(fox.count(P(x-1,y))) buf+=fox[P(x-1,y)];\n\t\t\tif(fox.count(P(x-1,y+1))) buf+=fox[P(x-1,y+1)];\n\t\t\tif(fox.count(P(x,y+1))) buf+=fox[P(x,y+1)];\n\t\t\tans=max(ans,buf);\n\t\t}\n\t\t{\n\t\t\tll buf=w;\n\t\t\tif(fox.count(P(x+1,y))) buf+=fox[P(x+1,y)];\n\t\t\tif(fox.count(P(x+1,y-1))) buf+=fox[P(x+1,y-1)];\n\t\t\tif(fox.count(P(x,y-1))) buf+=fox[P(x,y-1)];\n\t\t\tans=max(ans,buf);\n\t\t}\n\t}\n\tcout<<ans<<\" / 1\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\nmap<int,int> t[101010];\nvector<int> u[101010];\nint main(void){\n    int n;\n    cin >> n;\n    int ans = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        t[x][y] = z;\n        u[x].push_back(y);\n        ans = max(ans, z);\n    }\n    for (int i = 0; i < 100001; i++) {\n        if (!u[i].size()) continue;\n        for (int j = 0; j < u[i].size(); j++) {\n            int a = u[i][j];\n            for (int k = -1; k < 2; k+=2) {\n                int sum = t[i][a];\n                if (t[i].count(a+k)) sum += t[i][a+k];\n                if (t[i+1].count(a)) sum += t[i+1][a];\n                if (t[i+1].count(a+k)) sum += t[i+1][a+k];\n                ans = max(ans, sum);\n            }\n        }\n    }\n    cout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\ntypedef pair<int,int> P;\nint n;\nint x[MAX_N],y[MAX_N],w;\nmap<P,int> t;\n\nint f(int x,int y){\n  return t[P(x,y)]+t[P(x+1,y)]+t[P(x,y+1)]+t[P(x+1,y+1)];\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i]>>w;\n    t[P(x[i],y[i])]+=w;\n  }\n  int maxm=0;\n  for(int i=0;i<n;i++){\n    maxm=max(maxm,f(x[i]-1,y[i]-1));\n    maxm=max(maxm,f(x[i],y[i]-1));\n    maxm=max(maxm,f(x[i]-1,y[i]));\n    maxm=max(maxm,f(x[i],y[i]));\n  }\n  cout<<maxm<<\" / 1\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint N;\nint x[100010], y[100010], w[100010];\nmap<pii, int> mp;\n\nint calc(pii p) {\n  int res1 = mp[p], res2 = mp[p];\n  res1 += mp[pii(p.first, p.second + 1)];\n  res1 += mp[pii(p.first + 1, p.second)];\n  res1 += mp[pii(p.first + 1, p.second + 1)];\n  res2 += mp[pii(p.first, p.second - 1)];\n  res2 += mp[pii(p.first + 1, p.second)];\n  res2 += mp[pii(p.first + 1, p.second - 1)];\n  return max(res1, res2);\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> x[i] >> y[i] >> w[i];\n    mp[pii(x[i], y[i])] = w[i];\n  }\n\n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    ans = max(ans, calc(pii(x[i], y[i])));\n  }\n  cout << ans << \" / \" << 1 << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nmap<int,map<int,int> > data;\nint n;\nint x[100001],y[100001],w[100001];\nint dx[4]={0,-1,0,-1};\nint dy[4]={0,0,-1,-1};\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n\t\tdata[x[i]][y[i]]+=w[i];\n\t}\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint cnt=0,nx=x[i]+dx[j],ny=y[i]+dy[j];\n\t\t\tfor(int k=0;k<=1;k++){\n\t\t\t\tfor(int l=0;l<=1;l++){\n\t\t\t\t\tcnt+=data[nx+k][ny+l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=max(res,cnt);\n\t\t}\n\t}\n\tprintf(\"%d / 1\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int N;\n    map< pair<int, int>, int > M;\n    void input() {\n        cin >> N;\n        for (int i = 0; i < N; i++) {\n            int x, y, w; cin >> x >> y >> w;\n            M[make_pair(x, y)] += w;\n        }\n    }\n\n    const int dy[] = {-1, 1, 1, -1};\n    const int dx[] = {1, 1, -1, -1};\n\n    void solve() {\n        int ans = 0;\n        for (map< pair<int, int>, int >::iterator it = M.begin(); it != M.end(); it++) {\n            int x = it->first.first;\n            int y = it->first.second;\n            for (int i = 0; i < 4; i++) {\n                int w = 0;\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (M.count(make_pair(x, y))) w += M[make_pair(x, y)];\n                if (M.count(make_pair(nx, y))) w += M[make_pair(nx, y)];\n                if (M.count(make_pair(x, ny))) w += M[make_pair(x, ny)];\n                if (M.count(make_pair(nx, ny))) w += M[make_pair(nx, ny)];\n                ans = max(ans, w);\n            }\n        }\n        cout << ans << \" / \" << 1 << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n;\n  cin >> n;\n  map<pair<int,int>,int> mp;\n  int x,y,w;\n  rep(i,n){\n    cin >> x >> y >> w;\n    mp[{x,y}]+=w;\n    mp[{x+1,y}]+=w;\n    mp[{x,y+1}]+=w;\n    mp[{x+1 ,y+1}]+=w;\n  }\n  int ans=0;\n  for(auto &p:mp) ans=max(ans,p.second);\n  cout << ans << \" / 1\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n  int n;\n  cin>>n;\n\n  map<P,int> M;\n  for(int i=0,x,y,c;i<n;i++)cin>>x>>y>>c,M[P(x,y)] += c;\n\n  map<P,int>::iterator it;\n  int mx=0;\n  int dx[2][3] = {{1,1,0},{-1,-1,0}};\n  int dy[2][3] = {{0,1,1},{0,1,1}};\n  for(it=M.begin();it!=M.end();it++){\n    int x = it->first.first;\n    int y = it->first.second;\n    int num = it->second;\n    for(int k=0;k<2;k++){\n      for(int i=0;i<3;i++){\n\tint nx=x+dx[k][i];\n\tint ny=y+dy[k][i];\n\tif(!M.count(P(nx,ny)))continue;\n\tnum+=M[P(nx,ny)];\n      }\n      mx=max(mx,num);\n    }\n  }\n  cout<<mx<<\" / 1\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll, ll> pi;\n\nmap<pi,ll>m;\nll N;\n\nint main()\n{\n  cin >> N;\n  rep(i,N){\n    ll x,y,z; cin >> x >> y >> z;\n    m[pi(x,y)] = z;\n  }\n  ll res = 0;\n  for(auto z:m){\n    ll x=z.first.first,y=z.first.second;\n    ll a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];\n    if(m.count(pi(x+1,y))) a += m[pi(x+1,y)];\n    if(m.count(pi(x,y+1))) a += m[pi(x,y+1)];\n    if(m.count(pi(x+1,y+1))) a += m[pi(x+1,y+1)];    \n    res = max(res, a);\n  }\n  cout << res << \" / 1\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pp;\n\nint main(void){\n    int n;\n    cin >> n;\n    int ans = 0;\n    vector<pp> a;\n    vector<pii> b;\n    vector<int> c;\n    for (int i = 0; i < n; i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        a.push_back(make_pair(x, make_pair(y,z)));\n    }\n    sort(a.begin(), a.end());\n    \n    for (int i = 0; i < n; i++) {\n        int l = i;\n        map<int,int> t, u;\n        int y = a[i].second.first;\n        int z = a[i].second.second;\n        t[y] = z;\n        while (i+1 < n && a[i].first == a[i+1].first) {\n            i++;\n            y = a[i].second.first;\n            z = a[i].second.second;\n            t[y] = z;\n        }\n        int j = i;\n        if (a[j].first+1 == a[j+1].first) {\n            j++;\n            y = a[j].second.first;\n            z = a[j].second.second;\n            u[y] = z;\n            while (j+1 < n && a[j].first == a[j+1].first) {\n                j++;\n                y = a[j].second.first;\n                z = a[j].second.second;\n                u[y] = z;\n            }\n        }\n        for (int j = l; j < i+1; j++) {\n            y = a[j].second.first;\n            ans = max(ans, t[y]+t[y+1]+u[y]+u[y+1]);\n            ans = max(ans, t[y]+t[y-1]+u[y]+u[y-1]);\n        }\n    }\n    cout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\tusing tup = tuple<int, int, int>;\n\t\tmap<int, map<int, int>> mp;\n\t\tvector<tup> v(n);\n\t\trep(i, n) {\n\t\t\tint x, y, w; cin >> x >> y >> w;\n\t\t\tv[i] = tup(x, y, w);\n\t\t\tmp[x][y] = w;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (tup t : v) {\n\t\t\tint x = get<0>(t), y = get<1>(t);\n\t\t\tint sum = 0;\n\t\t\tmaxup(sum, mp[x][y] + mp[x + 1][y] + mp[x][y + 1] + mp[x + 1][y + 1]);\n\t\t\tmaxup(sum, mp[x][y] + mp[x - 1][y] + mp[x][y + 1] + mp[x - 1][y + 1]);\n\t\t\tmaxup(sum, mp[x][y] + mp[x + 1][y] + mp[x][y - 1] + mp[x + 1][y - 1]);\n\t\t\tmaxup(sum, mp[x][y] + mp[x - 1][y] + mp[x][y - 1] + mp[x - 1][y - 1]);\n\t\t\tmaxup(ans, sum);\n\t\t}\n\t\tcout << ans << \" / \" << 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main() {\n    int N;\n    cin >> N;\n    map<pair<int,int>,ll> m;\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        ll w;\n        cin >> w;\n        m[make_pair(x, y)] = w;\n    }\n\n    ll ans = 0;\n    for (auto p: m) {\n        int x = p.first.first;\n        int y = p.first.second;\n\n        ll w = 0;\n        if (m.find(make_pair(x, y)) != m.end()) w += m[make_pair(x, y)];\n        if (m.find(make_pair(x+1, y)) != m.end()) w += m[make_pair(x+1, y)];\n        if (m.find(make_pair(x, y+1)) != m.end()) w += m[make_pair(x, y+1)];\n        if (m.find(make_pair(x+1, y+1)) != m.end()) w += m[make_pair(x+1, y+1)];\n\n        ll j = 0;\n        if (m.find(make_pair(x, y)) != m.end()) j += m[make_pair(x, y)];\n        if (m.find(make_pair(x-1, y)) != m.end()) j += m[make_pair(x-1, y)];\n        if (m.find(make_pair(x, y+1)) != m.end()) j += m[make_pair(x, y+1)];\n        if (m.find(make_pair(x-1, y+1)) != m.end()) j += m[make_pair(x-1, y+1)];\n\n        ans = max(ans, max(j ,w));\n    }\n\n    cout << ans << \" / 1\" << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tmap<P, int> cnt;\n\tfor (int i = 0; i < N; i++) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tcnt[P(x + j, y + k)] += w;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (auto p : cnt) {\n\t\tres = max(res, p.second);\n\t}\n\tcout << res << \" / \" << 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nmap<int,int> pop[123456];\nint x[123456],y[123456];\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int w;\n    cin>>x[i]>>y[i]>>w;\n    pop[y[i]][x[i]]=w;\n  }\n  int ans=0;\n  for(int i=0;i<N;i++){\n    for(int j=-1;j<=0;j++){\n      for(int k=-1;k<=0;k++){\n\tint c=0;\n\tfor(int l=0;l<2;l++){\n\t  for(int m=0;m<2;m++){\n\t    c+=pop[y[i]+j+l][x[i]+k+m];\n\t  }\n\t}\n\tans=max(ans,c);\n      }\n    }\n  }\n  cout<<ans<<\" / 1\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\nmap<int,int> t[101010];\nvector<int> u[101010];\nint main(void){\n    int n;\n    cin >> n;\n    int ans = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        t[x][y] = z;\n        u[x].push_back(y);\n        ans = max(ans, z);\n    }\n    for (int i = 0; i < 100001; i++) {\n        if (!u[i].size()) continue;\n        for (int j = 0; j < u[i].size(); j++) {\n            int a = u[i][j];\n            ans = max(ans, t[i][a]+t[i][a+1]+t[i+1][a]+t[i+1][a+1]);\n            ans = max(ans, t[i][a]+t[i][a-1]+t[i+1][a]+t[i+1][a-1]);\n        }\n    }\n    cout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<map>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    map<pair<int,int>,int>mp;\n    for(int i=0;i<n;i++){\n        int x,y,w;\n        cin >> x >> y >> w;\n        mp[make_pair(x,y)]=w;\n    }\n    int ans =0;\n    for(auto x:mp){\n        int a = 0;\n        a += x.second;\n        int s = x.first.first;\n        int t = x.first.second;\n        if(mp.find(make_pair(s,t+1))!=mp.end())a += mp[make_pair(s,t+1)];\n        \n        if(mp.find(make_pair(s+1,t+1))!=mp.end())a += mp[make_pair(s+1,t+1)];\n        \n        if(mp.find(make_pair(s+1,t))!=mp.end())a += mp[make_pair(s+1,t)];\n        ans = max(ans,a);\n    }\n    cout << ans << \" / \" << 1 << endl; \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define f first\n#define s second\nusing namespace std;\n\n\nint main()\n{\n  int N,x,y,w;\n  map<pair<int,int>,int> M;\n  vector<pair<pair<int,int>,int> > V; \n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x>>y>>w;\n    M[make_pair(x,y)]=w;\n    V.push_back(make_pair(make_pair(x,y),w));\n  }\n  int ans=0,sum;\n  for(int i=0;i<N;i++){\n    sum=V[i].s;\n    sum+=M[make_pair(V[i].f.f,V[i].f.s+1)];\n    sum+=M[make_pair(V[i].f.f+1,V[i].f.s)];\n    sum+=M[make_pair(V[i].f.f+1,V[i].f.s+1)];\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / 1\"<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint d1[4][4] = { {-1,-1,0,0},{0,0,1,1},{0,0,1,1},{-1,-1,0,0} };\nint d2[4][4] = { {0,1,1,0},{0,1,1,0},{-1,0,0,-1},{-1,0,0,-1} };\nint main() {\n\tint n; map<P, int>mp;\n\tcin >> n;\n\tpair<P,int> p[100000];\n\trep(i, n) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tmp[{x, y}] = w;\n\t\tp[i] = { { x,y },w };\n\t}\n\tint ma = 0;\n\trep(i, n) {\n\t\tint nx = p[i].first.first; int ny = p[i].first.second;\n\t\trep(j, 4) {\n\t\t\tint sum = 0;\n\t\t\trep(k, 4) {\n\t\t\t\tint newx = nx + d1[j][k]; int newy = ny + d2[j][k];\n\t\t\t\tsum += mp[{newx, newy}];\n\t\t\t}\n\t\t\tma = max(ma, sum);\n\t\t}\n\t}\n\tcout << ma << \" / 1\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nstruct frac {\n    int a, b;\n    bool operator<(const frac &x) const {\n        return a*x.b < x.a*b;\n    }\n};\n\nmap<int, map<int, int> > mp;\n\nsigned main() {\n    int N; cin >> N;\n\n    vector< pair<pii, int> > vs;\n    rep(i,0,N) {\n        int x, y, w; cin >> x >> y >> w;\n        mp[x][y] = w;\n        vs.push_back(make_pair( make_pair(x, y), w) );\n    }\n\n    frac ans;\n    rep(i,0,N) {\n        int x = vs[i].first.first, y = vs[i].first.second;\n        int w = vs[i].second;\n        chmax(ans, frac{w, 1});\n\n        int sum = w;\n        rep(k,0,8) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if(!mp.count(nx)) continue;\n            if(!mp[nx].count(ny)) continue;\n            sum += mp[nx][ny];\n            chmax(ans, frac{w + mp[nx][ny], 1});\n        }\n\n        chmax(ans, frac{sum, 4});\n    }\n\n    int g = __gcd(ans.a, ans.b);\n    ans.a /= g, ans.b /= g;\n    printf(\"%lld / %lld\\n\", ans.a, ans.b);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nconst int dx[] = {0, 1, 1, 0};\nconst int dy[] = {0, 0, 1, 1};\n\nclass Solver {\n  public:\n    bool solve() {\n        int N; cin >> N;\n        vector<int> X(N), Y(N), W(N);\n        rep(i, N) cin >> X[i] >> Y[i] >> W[i];\n        \n        map<int, map<int, int>> G;\n        rep(i, N) G[Y[i]][X[i]] = W[i];\n        \n        ll max_a = 0;\n\n        rep(i, N) {\n            int x = X[i], y = Y[i];\n            for(int x_sign: {1, -1}) {\n                for(int y_sign: {1, -1}) {\n                    ll sum = 0;\n                    rep(j, 4) {                        \n                        int xx = x + dx[j] * x_sign;\n                        int yy = y + dy[j] * y_sign;\n                        sum += G[yy][xx];\n                    }\n                    set_max(max_a, sum);\n                }\n            }\n        }\n\n        cout << max_a << \" / \" << 1 << endl;\n        \n        return 0;\n    }\n};\n\nint main() {\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\n\nmap<pll,ll> M;\nvector<pll> W;\n\nll count(ll a){\n  pll &w=W[a];\n  ll mx=0;\n  ll C=0;\n  for(int i=-1;i<1;i++){\n    for(int t=-1;t<1;t++){\n      C=0;\n      for(int x=0;x<=1;x++){\n\tfor(int y=0;y<=1;y++){\n\t  C+=M[{w.first+i+x,w.second+t+y}];\n\t}\n      }\n      mx=max(mx,C);\n    }\n  }\n  return mx;\n}\n\n\nint main(){\n  ll n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    ll x,y,w;\n    cin>>x>>y>>w;\n    W.push_back({x,y});\n    M[{x,y}]+=w;\n  }\n  ll ans=0;\n  for(int i=0;i<n;i++){ans=max(ans,count(i));}\n  cout<<ans<<\" / 1\"<<endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nmap<int,map<int,int> > data;\nint n;\nint x[100001],y[100001],w[100001];\nint dx[4]={0,-1,0,-1};\nint dy[4]={0,0,-1,-1};\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n\t\tdata[x[i]][y[i]]+=w[i];\n\t}\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint cnt=0,nx=x[i]+dx[j],ny=y[i]+dx[j];\n\t\t\tfor(int k=0;k<=1;k++){\n\t\t\t\tfor(int l=0;l<=1;l++){\n\t\t\t\t\tcnt+=data[nx+k][ny+l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=max(res,cnt);\n\t\t}\n\t}\n\tprintf(\"%d / 1\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; cin >> N;\n  map<pair<int, int>, int> mp;\n  vector<pair<int, int>> vs;\n  rep(i, N) {\n    int x, y, w; cin >> x >> y >> w;\n    vs.emplace_back(x, y);\n    mp[{x, y}] += w;\n  }\n\n  ll ans = 0;\n\n  rep(i, vs.size()) {\n    int x = vs[i].first, y = vs[i].second;\n    maximize(ans, (ll)mp[{x, y}] + mp[{x + 1, y}] + mp[{x, y + 1}] + mp[{x + 1, y + 1}]);\n  }\n\n  cout << ans << \" / 1\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint x[MAX_N],y[MAX_N],w[MAX_N];\nint n;\nmap<P,int> mp;\n\nint search(int u,int v)\n{\n    int lt = mp[P(u-1,v+1)] + mp[P(u-1,v)] + mp[P(u,v+1)] + mp[P(u,v)];\n    int rt = mp[P(u+1,v+1)] + mp[P(u+1,v)] + mp[P(u,v+1)] + mp[P(u,v)];\n    int lb = mp[P(u-1,v)] + mp[P(u-1,v-1)] + mp[P(u,v-1)] + mp[P(u,v)];\n    int rb = mp[P(u+1,v-1)] + mp[P(u+1,v)] + mp[P(u,v-1)] + mp[P(u,v)];\n    int mx = max(max(lt,rt),max(lb,rb));\n    return mx;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\",&x[i],&y[i],&w[i]);\n        mp[P(x[i],y[i])] = w[i];\n\t}\n    int mx = 0;\n    rep(i,n){\n        mx = max(mx,search(x[i],y[i]));\n    }\n    cout << mx << \" / 1\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing node = tuple<int,int,int>;\n\nint d[5] = {1,1,-1,-1,1};\nint main(void){\n  int n;\n  cin >> n;\n  vector< P > v;\n  map<P,int> m;\n  for(int i = 0;i < n;++i){\n    int x,y,w;\n    cin >> x >> y >> w;\n    v.push_back(P(x,y));\n    m[P(x,y)] = w;\n  }\n  int res = 0;\n  for(int i = 0;i < n;++i){\n    int x = v[i].first,y = v[i].second;\n    for(int j = 0;j < 4;++j){\n      int dx = d[j],dy = d[j+1];\n      int calc =\n        m[P(x,y)] + m[P(x,y+dy)]\n        + m[P(x+dx,y)] + m[P(x+dx,y+dy)];\n      res = max(res,calc);\n    }\n  }\n  printf(\"%d / 1\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100003,INF=1<<30;\n\nvector<int> dx={-1,0,-1,0},dy={-1,-1,0,0},tox={0,1,0,1},toy={0,0,1,1};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    vector<pair<int,int>> S(N);\n    vector<int> T(N);\n    map<pair<int,int>,int> MA;\n    \n    for(int i=0;i<N;i++){\n        cin>>S[i].first>>S[i].second>>T[i];\n        MA[{S[i].first,S[i].second}]=T[i];\n    }\n    \n    int ans=0;\n    \n    for(int i=0;i<N;i++){\n        for(int from=0;from<4;from++){\n            int sum=0;\n            for(int to=0;to<4;to++){\n                sum+=MA[{S[i].first+dx[from]+tox[to],S[i].second+dy[from]+toy[to]}];\n            }\n            ans=max(ans,sum);\n        }\n    }\n    \n    cout<<ans<<\" / 1\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<PP> vec;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tvec.push_back(PP(P(x, y), w));\n\t}\n\tsort(vec.begin(), vec.begin());\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll cnt = vec[i].second;\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tbool ok = false;\n\t\t\tif(vec[i].first.first + 1 == vec[j].first.first && vec[i].first.second == vec[j].first.second)\n\t\t\t{\n\t\t\t\tok = true;\t\n\t\t\t\tcnt += vec[j].second;\n\t\t\t}\n\t\t\tif(vec[i].first.first == vec[j].first.first && vec[i].first.second + 1 == vec[j].first.second)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tcnt += vec[j].second;\n\t\t\t}\n\t\t\tif(vec[i].first.first + 1 == vec[j].first.first && vec[i].first.second + 1 == vec[j].first.second)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tcnt += vec[j].second;\n\t\t\t}\n\t\t\tif(ok == false) break;\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll inf=1e12;\nconst double eps=1e-9;\n\nint main(void)\n{\n    map<pll,ll> Foxmap;\n    int N;\n    cin >> N;\n    ll ans=0;\n    vector<pll> xy(N);\n    for(int i=0;i<N;i++)\n    {\n        ll x,y,w;\n        cin >> x >> y>> w;\n        Foxmap[pll(x,y)]=w;\n        xy[i]=pll(x,y);\n    }\n    for(int i=0;i<N;i++)\n    {\n        ll s1=0,s2=0,s3=0,s4=0;\n        //各点を中心として,4つの1*1の正方形にして考えると...\n        //左上\n        s1=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second-1LL)]+Foxmap[pll(xy[i].first,xy[i].second-1LL)];\n        //左下\n        s2=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second)]+Foxmap[pll(xy[i].first-1LL,xy[i].second+1LL)]+Foxmap[pll(xy[i].first,xy[i].second+1LL)];\n        //右下\n        s3=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second+1LL)]+Foxmap[pll(xy[i].first,xy[i].second+1LL)];\n        //右上\n        s4=Foxmap[pll(xy[i].first,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second)]+Foxmap[pll(xy[i].first+1LL,xy[i].second-1LL)]+Foxmap[pll(xy[i].first,xy[i].second-1LL)];\n        //cout << s1 << ' ' << s2 << ' ' << s3 << ' ' << s4 << endl;\n        ans=max(ans,s1);\n        ans=max(ans,s2);\n        ans=max(ans,s3);\n        ans=max(ans,s4);\n    }\n    cout << ans << ' ' << '/' << ' ' << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nint n,x[N],y[N],w[N];\nmap<P,int> fox;\nint dy[3]={1,1,0};\nint dx[3]={0,1,1};\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i]>>w[i];\n    fox[P(y[i],x[i])]=w[i];\n  }\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int sum=w[i];\n    for(int j=0;j<3;j++){\n      int ny=y[i]+dy[j];\n      int nx=x[i]+dx[j];\n      if(fox.count(P(ny,nx)))\n\tsum+=fox[P(ny,nx)];\n    }\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / \"<<1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nint main(){\n  int n;cin>>n;\n  map<P,int> m;\n  P p;\n  int i,j,k;\n  int w;\n  for(i=0;i<n;i++){\n    cin >> p.X >> p.Y >> w;\n    m[p]+=w;\n  }\n  int o=0;\n  for(map<P,int>::iterator it=m.begin();it!=m.end();++it){\n    p=it->first;\n    w=it->second;\n    //cout << p.X << p.Y << w << endl;\n    k=0;\n    k+=w;\n    p.X++;\n    if(m.find(p)!=m.end())\n       k+=m[p];\n    p.Y++;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    p.X--;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    o=max(o,k);\n    p=it->first;\n    k=0;\n    k+=w;\n    p.X--;\n    if(m.find(p)!=m.end())\n       k+=m[p];\n    p.Y++;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    p.X++;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    o=max(o,k);\n    p=it->first;\n    k=0;\n    k+=w;\n    p.X++;\n    if(m.find(p)!=m.end())\n       k+=m[p];\n    p.Y--;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    p.X--;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    o=max(o,k);\n  }\n  cout << o << \" / 1\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nsigned main(){\n    \n    int n; cin >> n;\n    vector<int> x(n);   \n    vector<int> y(n);   \n    map<pair<int, int>, int> mp;\n    for(int i = 0; i < n; i++){\n        int w;\n        cin >> x[i] >> y[i] >> w;\n        mp[{x[i], y[i]}] += w;\n    }\n    \n    int ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int di = -1; di < 2; di += 2){\n            for(int dj = -1; dj < 2; dj += 2){\n                int t = 0;\n                for(int j = 0; j < 2; j++){\n                    for(int k = 0; k < 2; k++){\n                        \n                        int nx = x[i] + j * di;\n                        int ny = y[i] + k * dj;\n                        t += mp[{nx, ny}];\n                    }\n                }\n                ans = max(ans, t);\n            }\n        }\n    }\n\n    cout << ans << \" / \" << 1 <<  endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tmap<P, ll> mp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tmp[{x, y}] = w;\n\t}\n\tll ans = 0;\n\tfor(auto itr = mp.begin(); itr != mp.end(); itr++)\n\t{\n\t\tll cnt = itr->second;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tll nx = itr->first.first + dx[i];\n\t\t\tll ny = itr->first.second + dy[i];\n\t\t\tauto tmp = make_pair(nx, ny);\n\t\t\tif(mp.count(tmp) > 0)\n\t\t\t{\n\t\t\t\tcnt += mp[{nx, ny}];\n\t\t\t}\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<ll,int>ma;\nvvi in;\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[a*1000000001ll+b]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d=1;\n\trep(q,n){\n\t\tif(q%100==0)cout<<q<<endl;\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[i*1000000001ll+j];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info1{\n\tInfo1(int arg_x,int arg_y,int arg_w){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info1 &arg) const{ //y?????????\n\t\t\treturn y < arg.y;\n\t};\n\tint x,y,w;\n};\n\nstruct Info2{\n\tInfo2(int arg_x,int arg_w){\n\t\tx = arg_x;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info2 &arg) const{ //x?????????\n\t\t\treturn x < arg.x;\n\t};\n\tint x,w;\n};\n\nint main(){\n\n\tint N,tmp_x,tmp_y,tmp_w,pre_y,pre_x,index = -1,self,ans = 0,right;\n\tscanf(\"%d\",&N);\n\n\tint* Y_VALUE = new int[N]; //?????????vector????????£??????y??§?¨?????¨???????????????????????????????\n\n\t//?????????y??????????????°??????????????????\n\tpriority_queue<Info1> Q;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d\",&tmp_x,&tmp_y,&tmp_w);\n\t\tQ.push(Info1(tmp_x,tmp_y,tmp_w));\n\t}\n\n\tvector<Info2> V[N];\n\n\tpre_y = BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().y != pre_y){ //??°??????y??????????????????\n\t\t\tindex++;\n\t\t\tY_VALUE[index] = Q.top().y; //??°??????y??????????¨????\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}else{\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}\n\t\tpre_y = Q.top().y;\n\t\tQ.pop();\n\t}\n\tindex++;\n\n\tfor(int i = 0; i < index; i++)sort(V[i].begin(),V[i].end()); //?????°???????????????x????????????sort\n\n\t/*for(int i = 0; i < index; i++){\n\t\tfor(int k = 0; k < V[i].size(); k++){\n\t\t\tprintf(\"y:%d x:%d\\n\",Y_VALUE[i],V[i][k].x);\n\t\t}\n\t}\n*/\n\tpre_y = pre_x = BIG_NUM;\n\n\tint l,r,m,loc;\n\n\tfor(int i = 0; i < index; i++){ //y?????????????????????\n\t\tfor(int k = 0; k < V[i].size(); k++){ //x????????????\n\n\t\t\t//????????????????????????????§???¢????¨????\n\t\t\tif(pre_y == i && pre_x == V[i][k].x-1){ //??????????????????1?????????????????????????????????????????????????§???¢????¨??????????\n\t\t\t\tself = right;\n\t\t\t}else{ //????????????????????????????§???¢????¨??????????\n\t\t\t\tif(i == index - 1 || Y_VALUE[i] - Y_VALUE[i+1] > 1){ //?????????1??????????????????????????¨???????????´???\n\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t}else{\n\t\t\t\t\t//2?????¢?´¢??§???V[i][k]????????????????????????????????????????????¢???<?????????????£????????????°?????¢????´¢??§??????>\n\t\t\t\t\tl = 0;\n\t\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\t\twhile(l <= r){\n\t\t\t\t\t\tif(V[i+1][m].x == V[i][k].x || V[i+1][m].x == V[i][k].x-1){ //????????????????????????????????°break\n\t\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(loc == BIG_NUM){ //??????????????????????????????????????????????????¨???????????´???\n\t\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][loc].x == V[i][k].x){ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc].w;\n\t\t\t\t\t\t\tif(loc > 0 && V[i+1][loc-1].x == V[i][k].w - 1){ //????????????????????£?????????????????´???\n\t\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc-1].w);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tans = max(ans,self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tif(loc < V[i+1].size()-1 && V[i+1][loc+1].x == V[i][k].x){ //???????????????????????????????????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc+1].w;\n\t\t\t\t\t\t\t}else{ //?????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc].w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//????????????????????????????§???¢????¨????<self????¨??????????>\n\t\t\tif(k < V[i].size()-1 && V[i][k+1].x == V[i][k].x+1){ //?????????????????????????????´???\n\t\t\t\tright = V[i][k+1].w;\n\t\t\t}else{\n\t\t\t\tright = 0;\n\t\t\t}\n\n\t\t\tif(i < index-1 && Y_VALUE[i+1] == Y_VALUE[i]-1){ //1?????????????????????????????´???\n\t\t\t\t//???????????????????????¢?´¢??§??¢???\n\t\t\t\tl = 0;\n\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\tm = (l+r)/2;\n\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\twhile(l <= r){\n\t\t\t\t\tif(V[i+1][m].x == V[i][k].x+1){ //?????????????????????????????°break\n\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(loc != BIG_NUM)right += V[i+1][loc].w;\n\t\t\t}\n\n\t\t\tans = max(ans,self+right);\n\n\t\t\tpre_y = i;\n\t\t\tpre_x = V[i][k].x;\n\t\t}\n\t}\n\n\tprintf(\"%d / 1\\n\",ans);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\nusing namespace std;\n\nint dx[8] = {1, 1, 0,-1,-1,-1, 0, 1};\nint dy[8] = {0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(){\n    int n;\n    cin >> n;\n\n    map<pair<int,int> ,int> fox;\n    for(int i=0; i<n; i++){\n        int x,y,w;\n        cin >> x >> y >> w;\n        fox[make_pair(x,y)] = w;\n    }\n\n    int ans=0;\n    map<pair<int,int> ,int>::iterator itr;\n    for(itr=fox.begin(); itr!=fox.end(); itr++){\n        int x=itr->first.first;\n        int y=itr->first.second;\n        int w=itr->second;\n        for(int i=0; i<8; i+=2){\n            int sub=w;\n            for(int j=0; j<3; j++){\n                if(fox.count(make_pair(x+dx[(i+j)%8], y+dy[(i+j)%8])) != 0){\n                    sub += fox[make_pair(x+dx[(i+j)%8], y+dy[(i+j)%8])];\n                }\n            }\n            ans = max(ans, sub);\n        }\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    vector<tuple<int,int,int> > t(n);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int a,b,c;\n        cin>>a>>b>>c;\n        t[i] = make_tuple(a,b,c);\n        ans = max(ans, c);\n    }\n    sort(t.begin(), t.end());\n    \n    for (int i = 0; i < n-1; i++) {\n        int a = get<0>(t[i]);\n        int b = get<0>(t[i+1]);\n        if (b > a+1) continue;\n        int c = get<1>(t[i]);\n        int d = get<1>(t[i+1]);\n        if (abs(c-d) > 1) continue;\n        ans = max(ans, get<2>(t[i])+get<2>(t[i+1]));\n    }\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nint main() {\n    int N;\n    cin >> N;\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        cin >> W[make_pair(x, y)];\n    }\n\n    int ans = 0;\n    for (auto pp : W) {\n        pair<int, int> p;\n        int w;\n        tie(p, w) = pp;\n        int x, y;\n        tie(x, y) = p;\n\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto coo = make_pair(x + dx, y + dy);\n                if (W.count(coo)) sum += W[coo];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define f first\n#define s second\nusing namespace std;\n\nint main()\n{\n  int N,x[10000000],y[10000000],w;\n  vector<pair<pair<int,int>,int> >V;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x>>y>>w;\n    V.push_back(make_pair(make_pair(x,y),w));\n  }\n  //sort(V.begin(),V.end());\n  int ans=0,sum;\n  for(int i=0;i<N;i++){\n    sum=V[i].s;\n    for(int j=1;j<N;j++){\n      if(V[i].f.f==V[j].f.f && V[i].f.s+1==V[j].f.s){\n\tsum+=V[j].s;\n      }\n      else if(V[i].f.f+1==V[j].f.f && V[i].f.s==V[j].f.s){\n\tsum+=V[j].s;\n      }\n      else if(V[i].f.f+1==V[j].f.f && V[i].f.s+1==V[j].f.s){\n\tsum+=V[j].s;\n      }\n    }\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / 1\"<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef pair< int, int > pii;\n\nconst int dx[3][2] = { {0,1}, {1,0}, {1,1} };\nconst int dy[3][2] = { {-1,0}, {0,1}, {-1,1} };\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tmap< pii, int > lattice;\n\t\n\tfor_(i,0,N) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tlattice[pii(x,y)] = w;\n\t}\n\t\n\tint ans = 0;\n\t\n\tmap< pii, int >::iterator it = lattice.begin(), eit = lattice.end();\n\t\n\tfor (; it != eit; ++it) {\n\t\tpii p = (*it).first;\n\t\t\n\t\tfor_(di,0,2) {\n\t\t\tpii cp(p.first + dx[2][di], p.second + dy[2][di]);\n\t\t\n\t\t\tif (lattice.count(cp)) {\n\t\t\t\tint val = (*it).second + lattice[cp];\n\t\t\t\t\n\t\t\t\tfor_(dj,0,2) {\n\t\t\t\t\tpii fp(p.first + dx[di][dj], p.second + dy[di][dj]);\n\t\t\t\t\tif (lattice.count(fp)) val += lattice[fp];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans = max(ans, val);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nint main(){\n  int n;cin>>n;\n  map<P,int> m;\n  P p;\n  int i,j,k;\n  int w;\n  for(i=0;i<n;i++){\n    cin >> p.X >> p.Y >> w;\n    m[p]+=w;\n  }\n  int o=0;\n  for(map<P,int>::iterator it=m.begin();it!=m.end();++it){\n    p=it->first;\n    w=it->second;\n    //cout << p.X << p.Y << w << endl;\n    k=0;\n    k+=w;\n    p.X++;\n    if(m.find(p)!=m.end())\n       k+=m[p];\n    p.Y++;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    p.X--;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    o=max(o,k);\n    k=0;\n    k+=w;\n    p.X--;\n    if(m.find(p)!=m.end())\n       k+=m[p];\n    p.Y++;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    p.X++;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    o=max(o,k);\n    k=0;\n    k+=w;\n    p.X++;\n    if(m.find(p)!=m.end())\n       k+=m[p];\n    p.Y--;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    p.X--;\n    if(m.find(p)!=m.end())\n      k+=m[p];\n    o=max(o,k);\n  }\n  cout << o << \" / 1\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\n\nusing ll=long long;\nint main(){\n    int n;\n    cin>>n;\n    map<pair<int,int>,int> mp;\n    for(int i=0;i<n;i++){\n        int x,y,w;\n        cin>>x>>y>>w;\n        mp[{x,y}]=w;\n    }\n    ll res=0;\n    for(auto &e:mp){\n        int x=e.first.first,y=e.first.second;\n        ll sc=0;\n        for(int i=0;i<2;i++){\n            for(int j=0;j<2;j++){\n                if(mp.count({x+i,y+j})) sc+=mp[{x+i,y+j}];\n            }\n        }\n        res=max(res,sc);\n    }\n    cout<<res<<\" / 1\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<ll,int>ma;\nvvi in;\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[a*1000000001ll+b]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d=1;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)if(ma.count(i*1000000001ll+j))sum+=ma[i*1000000001ll+j];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tmap<pii, int> mp;\n\tvi x(n), y(n);\n\tREP(i, n) {\n\t\tint z;\n\t\tcin >> x[i] >> y[i] >> z;\n\t\tmp[{x[i], y[i]}] += z;\n\t}\n\tint ans = -1;\n\tREP(i, n) {\n\t\tREP(j, 4) {\n\t\t\tans = max(ans, mp[{x[i], y[i]}] + mp[{x[i] + dx[j * 2], y[i] + dy[j * 2]}] + mp[{x[i] + dx[j * 2 + 1], y[i] + dy[j * 2 + 1]}] + mp[{x[i] + dx[(j + 1) * 2 % 8], y[i] + dy[(j + 1) * 2 % 8]}]);\n\t\t}\n\t}\n\tcout << ans <<\" / 1\"<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\n\nmap<pll,ll> M;\nvector<pll> W;\n\nll count(ll a){\n  pll &w=W[a];\n  ll mx=0;\n  ll C=0;\n  for(int i=-1;i<1;i++){\n    for(int t=-1;t<1;t++){\n      C=0;\n      for(int x=0;x<=1;x++){\n\tfor(int y=0;y<=1;y++){\n\t  C+=M[{w.first+i+x,w.second+t+y}];\n\t}\n      }\n      mx=max(mx,C);\n    }\n  }\n  return mx;\n}\n\n\nint main(){\n  ll n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    ll x,y,w;\n    cin>>x>>y>>w;\n    W.push_back({x,y});\n    M[{x,y}]+=w;\n  }\n  ll ans=0;\n  for(int i=0;i<n;i++){ans=max(ans,count(i));}\n  cout<<ans<<\" / 1\"<<endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<ll> x(N), y(N);\n    vector<pair<ll, int>> w(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> w[i].first;\n        w[i].second = i;\n    }\n\n    sort(w.begin(), w.end());\n    reverse(w.begin(), w.end());\n\n    ll a = 0, b = 1;\n    for (int i = 0; i < N; i++) {\n        if (a > 2 * w[i].first) continue;\n        for (int j = i + 1; j < N; j++) {\n            ll n = w[i].first + w[j].first;\n            ll m = abs(x[w[i].second] - x[w[j].second]) * abs(y[w[i].second] - y[w[j].second]);\n\n            if (a * m < b * n) {\n                a = n;\n                b = m;\n            }\n        }\n    }\n\n    cout << a << \" / \" << b << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nmap<P,int> m;\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n;\n\trep(i,n){\n\t\tint x,y,w;\n\t\tcin>>x>>y>>w;\n\t\tm[P(x-1,y-1)]+=w;\n\t\tm[P(x,y-1)]+=w;\n\t\tm[P(x-1,y)]+=w;\n\t\tm[P(x,y)]+=w;\n\t}\n\tint res=0;\n\teach(it,m){\n\t\tmaxch(res,it.second);\n\t}\n\tcout<<res<<\" / 1\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<ll,int>ma;\nvvi in;\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[a*1000000001ll+b]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d=1;\n\trep(q,n){\n\t\tloop(x,-1,2)loop(y,-1,2)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[i*1000000001ll+j];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c;\nint dx[4] = { 0,1,1,1 }, dy[4] = { 1,1,0,-1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<0>(x[i]) + dy[j]) {\n\t\t\t\tmaxn = max(maxn, get<2>(x[i]) + get<2>(x[c]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {0,1,1,1,0,-1,-1,-1};\nint dy[] = {-1,-1,0,1,1,1,0,-1};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  map<PII,int> xs;\n  REP(i,N){\n\tPII p;\n\tint w; cin >> p >> w;\n\txs[p] = w;\n  }\n\n  LL ans = 0;\n  for(auto p: xs){\n\tfor(int i=0;i<8;i+=2){\n\t  LL sum = p.SS;\n\t  REP(j,3){\n\t\tPII n(p.FF.FF+dx[(i+j)%8], p.FF.SS+dy[(i+j)%8]);\n\t\tif(xs.count(n))\n\t\t  sum += xs[n];\n\t  }\n\t  ans = max(ans, sum);\n\t}\n  }\n\n  cout << ans << \" / \" << 1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\ttypedef pair<int, int> point;\n\tconstexpr int dx[] = {0, 1, 0, 1};\n\tconstexpr int dy[] = {0, 0, 1, 1};\n\n\tint n;\n\tcin >> n;\n\n\tmap<point, int> foxes;\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tfoxes[point(x, y)] += w;\n\t}\n\n\tint ans = 0;\n\tfor(const auto &e : foxes) {\n\t\tconst int x = e.first.first;\n\t\tconst int y = e.first.second;\n\n\t\tfor(int cx = x - 1; cx <= x; ++cx) {\n\t\t\tint tmp = 0;\n\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\tconst point p(cx + dx[d], y + dy[d]);\n\t\t\t\tif(foxes.count(p)) tmp += foxes[p];\n\t\t\t}\n\t\t\tchmax(ans, tmp);\n\t\t}\n\t}\n\n\tcout << ans << \" / 1\" << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        cin >> W[make_pair(x, y)];\n    }\n\n    int ans = 0;\n    for (auto pp : W) {\n        int x, y;\n        tie(x, y) = pp.first;\n\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x + dx, y + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tmap<pair<int,int>,int>ma;\n\tvvi in(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\t\t\t\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c;\nint dx[8] = { 0,1,1,1,0,-1,-1,-1 }, dy[8] = { 1,1,0,-1,-1,-1,0,1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<1>(x[i]) + dy[j]) {\n\t\t\t\tmaxn = max(maxn, get<2>(x[i]) + get<2>(x[c]));\n\t\t\t}\n\t\t}\n\t\tmaxn = max(maxn, get<2>(x[i]));\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N;\n    cin >> N;\n    map<Pii, int> mp;\n    rep(i, N) {\n        int x, y, w;\n        cin >> x >> y >> w;\n        mp[Pii(x, y)] += w;\n        mp[Pii(x + 1, y)] += w;\n        mp[Pii(x, y + 1)] += w;\n        mp[Pii(x + 1, y + 1)] += w;\n    }\n\n    int a = -1;\n    for (auto p : mp) {\n        a = max(a, p.second);\n    }\n    cout << a << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<pi,int>m;\nint N;\n\nint main()\n{\n  cin >> N;\n  rep(i,N){\n    int x,y,z; cin >> x >> y >> z;\n    m[pi(x,y)] = z;\n  }\n  int res = 0;\n  for(auto z:m){\n    int x=z.first.first,y=z.first.second;\n    cout << x << \" \" << y << endl;\n    int a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];\n    if(m.count(pi(x+1,y))) a += m[pi(x+1,y)];\n    if(m.count(pi(x,y+1))) a += m[pi(x,y+1)];\n    if(m.count(pi(x+1,y+1))) a += m[pi(x+1,y+1)];    \n    res = max(res, a);\n  }\n  cout << res << \" / 1\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\nmap<pair<int,int>,int> m;\nint x[110000];\nint y[110000];\nvector<pair<int,int> >v;\nint dx[]={0,1,0,1};\nint dy[]={0,0,1,1};\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tint z;\n\t\tscanf(\"%d%d%d\",x+i,y+i,&z);\n\t\tm[make_pair(x[i],y[i])]=z;\n\t\tv.push_back(make_pair(x[i],y[i]));\n\t\tv.push_back(make_pair(x[i]-1,y[i]));\n\t\tv.push_back(make_pair(x[i],y[i]-1));\n\t\tv.push_back(make_pair(x[i]-1,y[i]-1));\n\t}\n\tint ret=0;\n\tfor(int i=0;i<v.size();i++){\n\t\tint X=v[i].first;\n\t\tint Y=v[i].second;\n\t\tint val=0;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif(m.count(make_pair(X+dx[j],Y+dy[j])))val+=m[make_pair(X+dx[j],Y+dy[j])];\n\t\t}\n\t\tret=max(ret,val);\n\t}\n\tprintf(\"%d / 1\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nmap<P,int> F;\nint N;\nint X[100001],Y[100001];\nint dx[]={-1,0,-1,0};\nint dy[]={-1,-1,0,0};\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int w; cin >> X[i] >> Y[i] >> w;\n    F[P(X[i],Y[i])]=w;\n  }\n  int res = 0;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<4;j++){\n      int x = X[i] + dx[j], y = Y[i] + dy[j];\n      int sum = 0;\n      for(int k=0;k<4;k++){\n        int nx = x - dx[k], ny = y - dy[k];\n        if( F.count(P(nx,ny))==1 ) sum+=F[P(nx,ny)];\n      }\n      res = max( res, sum );\n    }    \n  }\n  cout << res << \" / \" << 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<PP> vec;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tvec.push_back(PP(P(x, y), w));\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll cnt = vec[i].second;\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif(vec[j].first.first >= vec[i].first.first - 1 && vec[j].first.first <= vec[i].first.first + 1)\n\t\t\t{\n\t\t\t\tif(vec[j].first.second >= vec[i].first.second - 1 && vec[j].first.second <= vec[i].first.second + 1)\n\t\t\t\t\tcnt += vec[j].second;\n\t\t\t}\t\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(pair<pii,int> (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, x[100100], y[100100], w[100100], r;\nmap<pii,int> p;\n\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) {\n\t\tcin >> x[i] >> y[i] >> w[i];\n\t\tp[{x[i],y[i]}] = w[i];\n\t}\n\trep(i,n) {\n\t\tint t = w[i] + p[{x[i]+1,y[i]}];\n\t\tchmax(r, t + p[{x[i],y[i]+1}] + p[{x[i]+1,y[i]+1}]);\n\t\tchmax(r, t + p[{x[i],y[i]-1}] + p[{x[i]+1,y[i]-1}]);\n\t}\n\tcout << r << \" / 1\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dx[8] = {1,1,0,-1,-1,-1,0,1,}, dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n; cin >> n;\n\tvector<P> v(n);\n\tmap<P, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y, w; cin >> x >> y >> w;\n\t\tv[i] = P(x, y);\n\t\tmp[v[i]] = w;\n\t}\n\tint ma = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = v[i].first, y = v[i].second;\n\t\tfor (int j = 0; j < 8; j += 2) {\n\t\t\tint sum = mp[P(x, y)] + mp[P(x + dx[j], y + dy[j])] + mp[P(x + dx[j + 1], y + dy[j + 1])] + mp[P(x + dx[j + 2], y + dy[j + 2])];\n\t\t\tma = max(ma, sum);\n\t\t}\n\t}\n\tcout << ma <<\" / \"<<1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nint X[100100], Y[100100], W[100100];\nmap<int, map<int, int>> foxs;\n\nint dx[] = {0, 1, 0, 1};\nint dy[] = {0, 0, 1, 1};\n\nint hoge(int x, int y){\n    if(foxs.find(x) != foxs.end()){\n        if(foxs[x].find(y) != foxs[y].end()){\n            return foxs[x][y];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N; i++){\n        cin >> X[i] >> Y[i] >> W[i];\n        foxs[X[i]][Y[i]] = W[i];\n    }\n    \n    int ans = 0;\n    for(int i=0; i<N; i++){\n        int &x = X[i], y = Y[i];\n        for(int j=0; j<4; j++){\n            int sum = 0;\n            for(int k=0; k<4; k++){\n                sum += hoge(x + dx[j] - dx[k], y + dy[j] - dy[k]);\n            }\n            ans = max(ans, sum);\n        }\n    }\n    \n    cout << ans << \" / 1\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\tmap<pair<int,int>,int> memo;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tint x,y,w;\n\t\tcin >> x >> y >> w;\n\t\tmemo[{x-1,y-1}] += w;\n\t\tmemo[{x,y}] += w;\n\t\tmemo[{x-1,y}] += w;\n\t\tmemo[{x,y-1}] += w;\n\t}\n\tint ans = 0;\n\tfor( auto i : memo )\n\t\tans = max(ans,i.second);\n\tcout << ans << \" / \" << 1 << endl;\n\t\t\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[3] = { 1,1,0 }, dy[3] = { 0,1,1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif ((j / (1 << k)) == 0) {\n\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<1>(x[i]) + dy[j]) {\n\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<map>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    map<pair<int,int>,int>mp;\n    for(int i=0;i<n;i++){\n        int x,y,w;\n        cin >> x >> y >> w;\n        mp[make_pair(x,y)]=w;\n        mp[make_pair(x-1,y)]=0;\n        mp[make_pair(x,y-1)]=0;\n        mp[make_pair(x-1,y-1)]=0;\n    }\n    int ans =0;\n    for(auto x:mp){\n        int a = 0;\n        a += x.second;\n        int s = x.first.first;\n        int t = x.first.second;\n        if(mp.find(make_pair(s,t+1))!=mp.end())a += mp[make_pair(s,t+1)];\n        \n        if(mp.find(make_pair(s+1,t+1))!=mp.end())a += mp[make_pair(s+1,t+1)];\n        \n        if(mp.find(make_pair(s+1,t))!=mp.end())a += mp[make_pair(s+1,t)];\n        ans = max(ans,a);\n    }\n    cout << ans << \" / \" << 1 << endl; \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nstring solve(){\n    string res;\n    ll N; cin >> N;\n    vector<ll> x(N),y(N),w(N);\n    for(int i = 0; i < N;i++) cin >> x[i] >> y[i] >> w[i];\n    map<pll,ll> mp;\n    int d[5] = {1,0,-1,0,1};\n    ll maxv = 0;\n    for(int i = 0; i < N;i++){\n        mp[pll(x[i],y[i])] += w[i];\n        mp[pll(x[i]+1,y[i]+1)] += w[i];\n        mp[pll(x[i]-1,y[i]+1)] += w[i];\n        mp[pll(x[i]+1,y[i]-1)] += w[i];\n        mp[pll(x[i]-1,y[i]-1)] += w[i];\n    }\n    for(int i = 0; i < N;i++){\n        maxv = max(maxv,mp[pll(x[i],y[i])]);\n    }\n    res = to_string(maxv) + \" / 1\";\n    return res;\n}\nint main(void){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    vector<tuple<int,int,int> > t(n);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int a,b,c;\n        cin>>a>>b>>c;\n        t[i] = make_tuple(a,b,c);\n        ans = max(ans, c);\n    }\n    sort(t.begin(), t.end());\n    \n    for (int i = 0; i < n-1; i++) {\n        int a = get<0>(t[i]);\n        int b = get<0>(t[i+1]);\n        if (b > a+1) continue;\n        int c = get<1>(t[i]);\n        int d = get<1>(t[i+1]);\n        if (abs(c-d) > 1) continue;\n        ans = max(ans, get<2>(t[i])+get<2>(t[i+1]));\n    }\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nmap<l_l, ll> mp;\nll N;\nll x[100000], y[100000], w[100000];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> w[i];\n        mp[{x[i], y[i]}] += w[i];\n    }\n    ll ans = 0;\n    for(int i = 0; i < N; i++) {\n        ll now;\n        now = 0;\n        now += mp[{x[i], y[i]}];\n        now += mp[{x[i]+1, y[i]}];\n        now += mp[{x[i], y[i]+1}];\n        now += mp[{x[i]+1, y[i]+1}];\n        chmax(ans, now);\n        now = 0;\n        now += mp[{x[i], y[i]}];\n        now += mp[{x[i]+1, y[i]}];\n        now += mp[{x[i], y[i]-1}];\n        now += mp[{x[i]+1, y[i]-1}];\n        chmax(ans, now);\n        now = 0;\n        now += mp[{x[i], y[i]}];\n        now += mp[{x[i]-1, y[i]}];\n        now += mp[{x[i], y[i]+1}];\n        now += mp[{x[i]-1, y[i]+1}];\n        chmax(ans, now);\n        now = 0;\n        now += mp[{x[i], y[i]}];\n        now += mp[{x[i]-1, y[i]}];\n        now += mp[{x[i], y[i]-1}];\n        now += mp[{x[i]-1, y[i]-1}];\n        chmax(ans, now);\n    }\n    cout << ans << \" / \" << 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nint n, ret, res, ptr; tuple<int, int, int> d[100000];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d\", &get<0>(d[i]), &get<1>(d[i]), &get<2>(d[i]));\n\tsort(d, d + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = get<2>(d[i]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]), get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 2, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i]) + 1) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t\tres = get<2>(d[i]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]), get<1>(d[i]), 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) && get<1>(d[ptr]) == get<1>(d[i]) - 1) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]) + 1, 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i])) res += get<2>(d[ptr]);\n\t\tptr = lower_bound(d, d + n, make_tuple(get<0>(d[i]) + 1, get<1>(d[i]), 0)) - d - 1;\n\t\tif (get<0>(d[ptr]) == get<0>(d[i]) + 1 && get<1>(d[ptr]) == get<1>(d[i]) - 1) res += get<2>(d[ptr]);\n\t\tret = max(res, ret);\n\t}\n\tprintf(\"%d / 1\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(map<pair<int, int>, int> &mp, int x, int y)\n{\n    return mp[{x, y}] + mp[{x-1, y-1}] + mp[{x-1, y}] + mp[{x, y-1}];\n}\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    int ans = -1;\n    map<pair<int, int>, int> mp;\n    vector<pair<int, int>> p;\n    for (int i = 0; i < n; i++)\n    {\n        int x, y, num;\n        cin >> x >> y >> num;\n        mp[{x, y}] = num;\n        p.push_back({x, y});\n    } \n    for (int i=0;i<n;i++){\n        int x=p[i].first;\n        int y=p[i].second;\n        ans=max(ans,calc(mp,x,y));\n        ans=max(ans,calc(mp,x+1,y));\n        ans=max(ans,calc(mp,x,y+1));\n        ans=max(ans,calc(mp,x+1,y+1));\n    }\n\n    cout << ans << \" / \" << 1 << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(pair<pii,int> (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, x[100100], y[100100], w[100100], r;\nmap<pii,int> p;\n\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) {\n\t\tcin >> x[i] >> y[i] >> w[i];\n\t\tp[{x[i],y[i]}] = w[i];\n\t}\n\trep(i,n) {\n\t\tint t = w[i] + p[{x[i]+1,y[i]}];\n\t\tchmax(r, (t + p[{x[i],y[i]+1}] + p[{x[i]+1,y[i]+1}]));\n\t\tchmax(r, (t + p[{x[i],y[i]-1}] + p[{x[i]+1,y[i]-1}]));\n\t}\n\tcout << r << \" / 1\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define each(it,v) for(auto it=(v).begin();it!=(v).end();it++)\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nsigned main(){\n    int N;cin>>N;\n    map<pint,int>cnt;\n\n    rep(i,N){\n        int x,y,w;\n        cin>>x>>y>>w;\n        rep(dy,2)rep(dx,2)cnt[pint(y+dy,x+dx)]+=w;\n    }\n\n    int ma=0;\n    each(it,cnt)chmax(ma,it->se);\n    cout<<ma<<\" / 1\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint x[100010], y[100010], w[100010];\nmap<PII, int> mp;\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) {\n    cin >> x[i] >> y[i] >> w[i];\n    mp[{x[i], y[i]}] = w[i];\n  }\n\n  int res = 0;\n  REP(i, n) {\n    chmax(res, mp[{x[i], y[i]}] + mp[{x[i]-1, y[i]}] + mp[{x[i]-1, y[i]-1}] + mp[{x[i], y[i]-1}]);\n    chmax(res, mp[{x[i], y[i]}] + mp[{x[i]-1, y[i]}] + mp[{x[i]-1, y[i]+1}] + mp[{x[i], y[i]+1}]);\n    chmax(res, mp[{x[i], y[i]}] + mp[{x[i]+1, y[i]}] + mp[{x[i]+1, y[i]-1}] + mp[{x[i], y[i]-1}]);\n    chmax(res, mp[{x[i], y[i]}] + mp[{x[i]+1, y[i]}] + mp[{x[i]+1, y[i]+1}] + mp[{x[i], y[i]+1}]);\n  }\n  cout << res << \" / 1\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n#include <random>\n#include <time.h>\n#include <unordered_set>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = 1e-10;\nlong long const MOD = 998244353;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for (int i = 0;i < 60; i++) {\n        if (n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint main(void) {\n    map<int, map<int, int>> plane;\n    int N; cin >> N;\n    vector<vector<int>> foxes(N, vector<int>(3));\n    for (int i = 0; i < N; i++) {\n        int x, y, w; cin >> x >> y >> w;\n        foxes[i][0] = x;\n        foxes[i][1] = y;\n        foxes[i][2] = w;\n        plane[x][y] = w;\n    }\n    vector<int> ans;\n    for (int i = 0; i < N; i++) {\n        int v = 0;\n        int x = foxes[i][0];\n        int y = foxes[i][1];\n        \n        int tmp = 0;\n        tmp += plane[x][y];\n        tmp += plane[x][y+1];\n        tmp += plane[x-1][y+1];\n        tmp += plane[x-1][y];\n        v = max(tmp, v);\n        \n        tmp = 0;\n        tmp += plane[x][y];\n        tmp += plane[x][y+1];\n        tmp += plane[x+1][y+1];\n        tmp += plane[x+1][y];\n        v = max(tmp, v);\n\n        tmp = 0;\n        tmp += plane[x][y];\n        tmp += plane[x][y-1];\n        tmp += plane[x-1][y-1];\n        tmp += plane[x-1][y];\n        v = max(tmp, v);\n\n        tmp = 0;\n        tmp += plane[x][y];\n        tmp += plane[x][y-1];\n        tmp += plane[x+1][y-1];\n        tmp += plane[x+1][y];\n        v = max(tmp, v);\n\n        ans.push_back(v);\n    }\n    sort(ans.begin(), ans.end(), greater<int>());\n    cout << ans[0] << \" / 1\" << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tmap<pair<size_t, size_t>, size_t> foxes;\n\tauto count = [&foxes](size_t x, size_t y) -> size_t {\n\t\tauto it = foxes.find(make_pair(x, y));\n\t\tif (it == foxes.end()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn it->second;\n\t\t}\n\t};\n\n\tfor (int i = 0; i < N; i++) {\n\t\tsize_t x, y, f;\n\t\tcin >> x >> y >> f;\n\t\tfoxes[make_pair(x, y)] = f;\n\t}\n\n\tsize_t max_foxes = 0;\n\tfor (auto v : foxes) {\n\t\tauto x = v.first.first;\n\t\tauto y = v.first.second;\n\t\tauto num = v.second +\n\t\t\tcount(x + 1, y) +\n\t\t\tcount(x, y + 1) +\n\t\t\tcount(x + 1, y + 1);\n\t\tmax_foxes = max(max_foxes, num);\n\t}\n\tcout << max_foxes << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<P> v(n);\n    map<P, int> m;\n    for(int i=0; i<n; ++i) {\n        int x, y, w;\n        cin >> x >> y >> w;\n        auto p = make_pair(x, y);\n        v[i] = p;\n        m[p] = w;\n    }\n    int res = 0;\n    sort(v.begin(), v.end());\n    for(int i=0; i<v.size(); ++i) {\n        int dx[4] = {0, 0, 1, 1},\n            dy[4] = {0, 1, 0, 1};\n        int cand = 0, cand2 = 0;\n        for(int j=0; j<4; ++j) {\n            cand += m[make_pair(v[i].first+dx[j], v[i].second+dy[j])];\n            cand2 += m[make_pair(v[i].first+dx[j], v[i].second-dy[j])];\n        }\n        res = max(res, cand);\n        res = max(res, cand2);\n    }\n    cout << res << \" / 1\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tmap<P, ll> mp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tmp[{x, y}] = w;\n\t}\n\tll ans = 0;\n\tfor(auto itr = mp.begin(); itr != mp.end(); itr++)\n\t{\n\t\tll cnt = itr->second;\n\t\tqueue<P> que;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tll nx = itr->first.first + dx[i];\n\t\t\tll ny = itr->first.second + dy[i];\n\t\t\tauto tmp = make_pair(nx, ny);\n\t\t\tif(mp.count(tmp) > 0)\n\t\t\t{\n\t\t\t\tcnt += mp[{nx, ny}];\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t}\n\t\t\tif(que.size() == 4) \n\t\t\t{\n\t\t\t\tP q = que.front(); que.pop();\n\t\t\t\tcnt -= mp[{q.first, q.second}];\n\t\t\t\tans = max(cnt, ans);\n\t\t\t}\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<int> x(N), y(N), w(N);\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> y[i] >> w[i];\n        W[make_pair(x[i], y[i])] = w[i];\n    }\n\n    int ans = 0;\n    for (int i = 0; i < N; ++i) {\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x[i] + dx, y[i] + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n#define size_t long long\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tmap<pair<size_t, size_t>, size_t> foxes;\n\tauto count = [&foxes](size_t x, size_t y) -> size_t {\n\t\tauto it = foxes.find(make_pair(x, y));\n\t\tif (it == foxes.end()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn it->second;\n\t\t}\n\t};\n\n\tfor (int i = 0; i < N; i++) {\n\t\tsize_t x, y, f;\n\t\tcin >> x >> y >> f;\n\t\tfoxes[make_pair(x, y)] = f;\n\t}\n\n\tsize_t max_foxes = 0;\n\tfor (auto v : foxes) {\n\t\tauto x = v.first.first;\n\t\tauto y = v.first.second;\n\t\tauto num = v.second +\n\t\t\tcount(x + 1, y) +\n\t\t\tcount(x, y + 1) +\n\t\t\tcount(x + 1, y + 1);\n\t\tmax_foxes = max(max_foxes, num);\n\t}\n\tcout << max_foxes << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<ll> x(N), y(N);\n    vector<pair<ll, int>> w(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> w[i].first;\n        w[i].second = i;\n    }\n\n    sort(w.begin(), w.end());\n    reverse(w.begin(), w.end());\n\n    ll a = 0, b = 1;\n    for (int i = 0; i < N; i++) {\n        if (a * a > w[i].first * w[i].first) continue;\n        for (int j = i + 1; j < N; j++) {\n            ll n = w[i].first + w[j].first;\n            ll m = abs(x[w[i].second] - x[w[j].second]) * abs(y[w[i].second] - y[w[j].second]);\n\n            if (a * m < b * n) {\n                a = n;\n                b = m;\n            }\n        }\n    }\n\n    cout << a << \" / \" << b << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[4][4] = { {-1, -1, 0, 0}, {0, 0, 1, 1}, {0, 0, 1, 1}, {-1, -1, 0, 0} };\nint dy[4][4] = { {0, 1, 1, 0}, {0, 1, 1, 0}, {-1, 0, 0, -1}, {-1, 0, 0, -1} };\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nstruct frac {\n    int a, b;\n    bool operator<(const frac &x) const {\n        return a*x.b < x.a*b;\n    }\n};\n\nmap<int, map<int, int> > mp;\n\nsigned main() {\n    int N; cin >> N;\n\n    vector< pair<pii, int> > vs;\n    rep(i,0,N) {\n        int x, y, w; cin >> x >> y >> w;\n        mp[x][y] = w;\n        vs.push_back(make_pair( make_pair(x, y), w) );\n    }\n\n    frac ans;\n    rep(i,0,N) {\n        int x = vs[i].first.first, y = vs[i].first.second;\n        int w = vs[i].second;\n        chmax(ans, frac{w, 1});\n\n        rep(j,0,4) {\n            int sum = 0;\n            rep(k,0,4) {\n                int nx = x + dx[j][k], ny = y + dy[j][k];\n                if(!mp.count(nx)) continue;\n                if(!mp[nx].count(ny)) continue;\n                sum += mp[nx][ny];\n            }\n            chmax(ans, frac{sum, 1});\n        }\n    }\n\n    int g = __gcd(ans.a, ans.b);\n    ans.a /= g, ans.b /= g;\n    printf(\"%lld / %lld\\n\", ans.a, ans.b);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nmap<P,int> m;\nint x[100000], y[100000], w[100000];\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\",x+i,y+i,w+i);\n\t\tm[P(x[i],y[i])] = w[i];\n\t}\n\tint ans = 0;\n\trep(i,n){\n\t\tans = max(ans,m[P(x[i],y[i])]+m[P(x[i]+1,y[i])]+m[P(x[i],y[i]+1)]+m[P(x[i]+1,y[i]+1)]);\n\t\tans = max(ans,m[P(x[i],y[i])]+m[P(x[i]-1,y[i])]+m[P(x[i],y[i]+1)]+m[P(x[i]-1,y[i]+1)]);\n\t\tans = max(ans,m[P(x[i],y[i])]+m[P(x[i]+1,y[i])]+m[P(x[i],y[i]-1)]+m[P(x[i]+1,y[i]-1)]);\n\t\tans = max(ans,m[P(x[i],y[i])]+m[P(x[i]-1,y[i])]+m[P(x[i],y[i]-1)]+m[P(x[i]-1,y[i]-1)]);\n\t}\n\tcout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Data {\n  int x,y;\n  bool operator < ( const Data &data ) const {\n    if( x != data.x ) return x < data.x;\n    return y < data.y;\n  }\n};\n\nmap<Data,int> mp;\nconst int MAX = 110000;\nint xs[MAX],ys[MAX],w[MAX];\n\ninline int getScore(int i,int dx,int dy){\n  return w[i] + mp[(Data){xs[i]+dx,ys[i]}] + mp[(Data){xs[i],ys[i]+dy}] + mp[(Data){xs[i]+dx,ys[i]+dy}];\n}\n\nint main(){\n  int N;\n  scanf(\"%d\",&N);\n  rep(i,N){\n    scanf(\"%d %d %d\",xs+i,ys+i,w+i);\n    mp[(Data){xs[i],ys[i]}] = w[i];\n  }\n  int maxi = 0;\n  rep(i,N){\n    maxi = max(maxi,max(getScore(i,-1,-1),max(getScore(i,-1,1),max(getScore(i,1,-1),getScore(i,1,1)))));\n  }\n  printf(\"%d / 1\\n\",maxi);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,X[100005],Y[100005],W[100005],mx=0;\nmap<P,int>M;\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d%d\",X+i,Y+i,W+i);\n\t\tM[make_pair(X[i],Y[i])]=W[i];\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint tmp1=M[make_pair(X[i],Y[i])]+M[make_pair(X[i]+1,Y[i])]+M[make_pair(X[i],Y[i]+1)]+M[make_pair(X[i]+1,Y[i]+1)];\n\t\tint tmp2=M[make_pair(X[i],Y[i])]+M[make_pair(X[i]-1,Y[i])]+M[make_pair(X[i],Y[i]+1)]+M[make_pair(X[i]-1,Y[i]+1)];\n\t\tmx=max(mx,max(tmp1,tmp2));\n\t}\n\tprintf(\"%d / 1\\n\",mx);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint N;\nmap<P,int> points;\nP ary[4][4] = {\n    {P(0,0),P(0,-1),P(-1,0),P(-1,-1)},\n    {P(0,0),P(0,-1),P(1,0),P(1,-1)},\n    {P(0,0),P(0,1),P(1,0),P(1,1)},\n    {P(0,0),P(0,1),P(-1,0),P(-1,1)}\n};\nP operator+(P a,P b) {\n    return P(a.fr+b.fr,a.sc+b.sc);\n}\nint main() {\n    vector<P> vec;\n    cin>>N;\n    rep(i,N) {\n        int x,y,w;\n        cin>>x>>y>>w;\n        vec.pb(P(x,y));\n        points[P(x,y)]=w;\n    }\n    int ans=0;\n    for(auto point : vec) {\n        P p=point;\n        rep(i,4) {\n            int t=0;\n            rep(j,4) {\n                t+=points[p+ary[i][j]];\n            }\n            ans=max(ans,t);\n        }\n    }\n\n    cout<<ans<<\" / 1\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tmap<pair<int,int>,int>ma;\n\tvvi in(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%lld %lld %lld\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\t\t\t\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c;\nint dx[4] = { 0,1,1,1 }, dy[4] = { 1,1,0,-1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<0>(x[i]) + dy[j]) {\n\t\t\t\tmaxn = max(maxn, get<2>(x[i]) + get<2>(x[c]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nint main() {\n    cin.tie(0);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    map<pair<int, int>, int> mp;\n    vector<pair<int, int>> p;\n    for(int i=0;i<n;++i) {\n      int x, y, w;\n      cin >> x >> y >> w;\n      mp[{x, y}] = w;\n      p.push_back({x, y});\n    }\n\n    int ans = 0;\n    for(int i=0;i<n;++i) {\n      int x = p[i].first, y = p[i].second;\n      ans = max(ans, mp[{x, y}] + mp[{x+1, y}] + mp[{x, y+1}] + mp[{x+1, y+1}]);\n      ans = max(ans, mp[{x, y}] + mp[{x+1, y}] + mp[{x, y-1}] + mp[{x+1, y-1}]);\n    }\n    cout << ans << \" / 1\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {1,0,1};\nint dy[] = {0,1,1};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  map<PII,int> xs;\n  REP(i,N){\n\tPII p;\n\tint w; cin >> p >> w;\n\txs[p] = w;\n  }\n\n  LL ans = 0;\n  for(auto p: xs){\n\tLL sum = p.SS;\n\tREP(i,3){\n\t  PII n(p.FF.FF+dx[i], p.FF.SS+dy[i]);\n\t  if(xs.count(n))\n\t\tsum += xs[n];\n\t}\n\tans = max(ans, sum);\n  }\n\n  cout << ans << \" / \" << 1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info1{\n\tInfo1(int arg_x,int arg_y,int arg_w){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info1 &arg) const{ //y?????????\n\t\t\treturn y < arg.y;\n\t};\n\tint x,y,w;\n};\n\nstruct Info2{\n\tInfo2(int arg_x,int arg_w){\n\t\tx = arg_x;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info2 &arg) const{ //x?????????\n\t\t\treturn x > arg.x;\n\t};\n\tint x,w;\n};\n\nint main(){\n\n\tint N,tmp_x,tmp_y,tmp_w,pre_y,pre_x,index = -1,self,ans = 0,right;\n\tscanf(\"%d\",&N);\n\n\tint* Y_VALUE = new int[N]; //?????????vector????????£??????y??§?¨?????¨???????????????????????????????\n\n\t//?????????y??????????????°??????????????????\n\tpriority_queue<Info1> Q;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d\",&tmp_x,&tmp_y,&tmp_w);\n\t\tQ.push(Info1(tmp_x,tmp_y,tmp_w));\n\t}\n\n\tvector<Info2> V[N];\n\n\t//return 0;\n\n\tpre_y = BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().y != pre_y){ //??°??????y??????????????????\n\t\t\tindex++;\n\t\t\tY_VALUE[index] = Q.top().y; //??°??????y??????????¨????\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}else{\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}\n\t\tpre_y = Q.top().y;\n\t\tQ.pop();\n\t}\n\tindex++;\n\n\tfor(int i = 0; i < index; i++)sort(V[i].begin(),V[i].end()); //?????°???????????????x????????????sort\n\n\t/*for(int i = 0; i < index; i++){\n\t\tfor(int k = 0; k < V[i].size();k++){\n\t\t\tprintf(\"y:%d x:%d\\n\",Y_VALUE[i],V[i][k].x);\n\t\t}\n\t}*/\n\n\tpre_y = pre_x = BIG_NUM;\n\n\tint l,r,m,loc;\n\n\tfor(int i = 0; i < index; i++){ //y?????????????????????\n\t\tfor(int k = 0; k < V[i].size(); k++){ //x????????????\n\n\t\t\t//????????????????????????????§???¢????¨????\n\t\t\tif(pre_y == i && pre_x == V[i][k].x-1){ //??????????????????1?????????????????????????????????????????????????§???¢????¨??????????\n\t\t\t\tself = right;\n\t\t\t}else{ //????????????????????????????§???¢????¨??????????\n\t\t\t\tif(i == index - 1 || Y_VALUE[i] - Y_VALUE[i+1] > 1){ //?????????1??????????????????????????¨???????????´???\n\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t}else{\n\t\t\t\t\t//2?????¢?´¢??§???V[i][k]????????????????????????????????????????????¢???<?????????????£????????????°?????¢????´¢??§??????>\n\t\t\t\t\tl = 0;\n\t\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\t\twhile(l <= r){\n\t\t\t\t\t\tif(V[i+1][m].x == V[i][k].x || V[i+1][m].x == V[i][k].x-1){ //????????????????????????????????°break\n\t\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(loc == BIG_NUM){ //??????????????????????????????????????????????????¨???????????´???\n\t\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(loc == V[i][k].x){ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc].w;\n\t\t\t\t\t\t\tif(loc > 0 && V[i+1][loc-1].x == V[i][k].w - 1){ //????????????????????£?????????????????´???\n\t\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc-1].w);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tans = max(ans,self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tif(loc < V[i+1].size()-1 && V[i+1][loc+1].x == V[i][k].x){ //???????????????????????????????????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc+1].w;\n\t\t\t\t\t\t\t}else{ //?????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc].w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//????????????????????????????§???¢????¨????<self????¨??????????>\n\t\t\tif(k < V[i].size()-1 && V[i][k+1].x == V[i][k].x+1){ //?????????????????????????????´???\n\t\t\t\tright = V[i][k+1].w;\n\t\t\t}else{\n\t\t\t\tright = 0;\n\t\t\t}\n\n\t\t\tif(i < index-1 && Y_VALUE[i+1] == Y_VALUE[i]-1){ //1?????????????????????????????´???\n\t\t\t\t//???????????????????????¢?´¢??§??¢???\n\t\t\t\tl = 0;\n\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\tm = (l+r)/2;\n\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\twhile(l <= r){\n\t\t\t\t\tif(V[i+1][m].x == V[i][k].x+1){ //?????????????????????????????°break\n\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(loc != BIG_NUM)right += V[i+1][loc].w;\n\t\t\t}\n\n\n\t\t\tans = max(ans,self+right);\n\n\t\t\tpre_y = i;\n\t\t\tpre_x = V[i][k].x;\n\t\t}\n\t}\n\n\n\tprintf(\"%d / 1\\n\",ans);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<pi,int>m;\nint N;\n\nint main()\n{\n  cin >> N;\n  rep(i,N){\n    int x,y,z; cin >> x >> y >> z;\n    m[pi(x,y)] = z;\n  }\n  int res = 0;\n  for(auto z:m){\n    int x=z.first.first,y=z.first.second;\n\n    int a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];\n    if(m.count(pi(x+1,y))) a += m[pi(x+1,y)];\n    if(m.count(pi(x,y+1))) a += m[pi(x,y+1)];\n    if(m.count(pi(x+1,y+1))) a += m[pi(x+1,y+1)];    \n    res = max(res, a);\n  }\n  cout << res << \" / 1\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nint n,x[N],y[N],w[N];\nmap<P,int> fox;\nint dy[6]={1,1,0,0,-1,-1};\nint dx[6]={0,1,1,1,1,0};\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i]>>w[i];\n    fox[P(y[i],x[i])]=w[i];\n  }\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int sum=w[i];\n    for(int j=0;j<6;j++){\n      int ny=y[i]+dy[j];\n      int nx=x[i]+dx[j];\n      if(fox.count(P(ny,nx)))\n\tsum+=fox[P(ny,nx)];\n      if(j==2){\n\tans=max(ans,sum);\n\tsum=0;\n      }\n    }\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / \"<<1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dx[8] = {1,1,0,-1,-1,-1,0,1,}, dy[8] = {0,1,1,1,0,-1,-1,-1};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n; cin >> n;\n\tvector<P> v(n);\n\tmap<P, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y, w; cin >> x >> y >> w;\n\t\tv[i] = P(x, y);\n\t\tmp[v[i]] = w;\n\t}\n\tint ma = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = v[i].first, y = v[i].second;\n\t\tfor (int j = 0; j < 8; j += 2) {\n\t\t\tint sum = mp[P(x, y)] + mp[P(x + dx[j], y + dy[j])] + mp[P(x + dx[j + 1], y + dy[j + 1])] + mp[P(x + dx[j + 2], y + dy[j + 2])];\n\t\t\tma = max(ma, sum);\n\t\t}\n\t}\n\tcout << ma <<\" / 1\"<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(pair<pii,int> &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, x, y, w, r;\nmap<pii,int> m;\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) {\n\t\tcin >> x >> y >> w;\n\t\tm[{x,y}] = w;\n\t}\n\teach(i,m) {\n\t\tif (i.se==0) continue;\n\t\tx = i.fi.fi, y = i.fi.se;\n\t\tint t = i.se + m[{x+1,y}];\n\t\tr = max(r, t + m[{x,y+1}] + m[{x+1,y+1}]);\n\t\tr = max(r, t + m[{x,y-1}] + m[{x+1,y-1}]);\n\t}\n\tcout << r << \" / 1\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[4] = { 1,1,0,-1 }, dy[4] = { 0,1,1,1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif ((j / (1 << k)) % 2 == 0) {\n\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[k], get<1>(x[i]) + dy[k], 0)) - x;\n\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[k] && get<1>(x[c]) == get<1>(x[i]) + dy[k]) {\n\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main() {\n    int N;\n    cin >> N;\n    map<pair<int,int>,ll> m;\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        ll w;\n        cin >> w;\n        m[make_pair(x, y)] = w;\n    }\n\n    ll ans = 0;\n    for (auto p: m) {\n        int x = p.first.first;\n        int y = p.first.second;\n\n        ll w = 0;\n        if (m.find(make_pair(x, y)) != m.end()) w += m[make_pair(x, y)];\n        if (m.find(make_pair(x+1, y)) != m.end()) w += m[make_pair(x+1, y)];\n        if (m.find(make_pair(x, y+1)) != m.end()) w += m[make_pair(x, y+1)];\n        if (m.find(make_pair(x+1, y+1)) != m.end()) w += m[make_pair(x+1, y+1)];\n\n\n        ans = max(ans, w);\n    }\n\n    cout << ans << \" / 1\" << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\nusing namespace std;\nint n;\nint a=0;\npair<pair<int,int>,int>x[1<<17];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>x[i].first.first>>x[i].first.second>>x[i].second;\n\t}\n\tsort(x,x+n,[](pair<pair<int,int>,int>&a,pair<pair<int,int>,int>&b){\n\t\treturn a.first.first+a.first.second<b.first.first+b.first.second;\n\t});\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint now=0;\n\t\tint f=i,l=i;\n\t\tfor(;f>=0;f--)\n\t\t{\n\t\t\tif(abs(x[f].first.first+x[f].first.second-\n\t\t\t\tx[i].first.first-x[i].first.second)>2)break;\n\t\t}\n\t\tfor(;l<n;l++)\n\t\t{\n\t\t\tif(abs(x[l].first.first+x[l].first.second-\n\t\t\t\tx[i].first.first-x[i].first.second)>2)break;\n\t\t}\n\t\tfor(int j=-1;j<=1;j+=2)for(int k=-1;k<=1;k+=2)\n\t\t{\n\t\t\tnow=0;\n\t\t\tint lx=min(j,0),ux=max(j,0);\n\t\t\tint ly=min(k,0),uy=max(k,0);\n\t\t\tfor(int u=f;u<=l;u++)\n\t\t\t{\n\t\t\t\tint dx=x[i].first.first-x[u].first.first;\n\t\t\t\tint dy=x[i].first.second-x[u].first.second;\n\t\t\t\tif(dx>=lx&&dx<=ux&&dy>=ly&&dy<=uy)now+=x[u].second;\n\t\t\t}\n\t\t\ta=max(a,now);\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntemplate <class T, class U>\ninline bool chmax(T& t, const U& f) { return t < f ? t = f, true : false; }\n\nconst int d[] = {1, -1, -1, 1};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int N; cin >> N;\n    map<pair<int, int>, int> fox;\n    rep(i, N) {\n        int x, y, w; cin >> x >> y >> w;\n        fox[make_pair(x, y)] = w;\n    }\n    int maxi = 0;\n    for (const auto& e : fox) {\n        pair<int, int> t; int x1, y1, w;\n        tie(t, w) = e; tie(x1, y1) = t;\n        chmax(maxi, w);\n        rep(k, 4) {\n            int x2 = x1 + d[k], y2 = y1 + d[(k + 1) % 4];\n            t = make_pair(x2, y2);\n            if (fox.count(t)) chmax(maxi, w + fox[t]);\n        }\n    }\n    cout << maxi << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\tusing tup = tuple<int, int, int>;\n\t\tmap<int, map<int, int>> mp;\n\t\tvector<tup> v(n);\n\t\trep(i, n) {\n\t\t\tint x, y, w; cin >> x >> y >> w;\n\t\t\tv[i] = tup(x, y, w);\n\t\t\tmp[x][y] = w;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (tup t : v) {\n\t\t\tint x = get<0>(t), y = get<1>(t);\n\t\t\tint sum = mp[x][y] + mp[x + 1][y] + mp[x][y + 1] + mp[x + 1][y + 1];\n\t\t\tmaxup(ans, sum);\n\t\t}\n\t\tcout << ans << \" / \" << 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N;\n    cin >> N;\n    map<pair<int, int>, int> mp;\n    for (int i = 0, y = 0, x = 0, w = 0; i < N; i++) { cin >> y >> x >> w, mp[{y, x}] += w, mp[{y - 1, x}] += w, mp[{y, x - 1}] += w, mp[{y - 1, x - 1}] += w; }\n    int ans = 0;\n    for (const auto& p : mp) { ans = max(ans, p.second); }\n    cout << ans << \" / \" << 1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nusing P = pair<int,int>;\nint main(){\n    int N;\n    cin>>N;\n    map<P,int> M;\n    for(int i=0;i<N;i++){\n        int x,y,w;\n        cin>>x>>y>>w;\n        M[P(x,y)]=w;\n    }\n    int ans = 0;\n    for(auto p:M){\n        int x,y;\n        tie(x,y)=p.first;\n        int sum = p.second;\n        if(M.find(P(x+1,y))!=M.end()) sum+=M[P(x+1,y)];\n        if(M.find(P(x,y+1))!=M.end()) sum+=M[P(x,y+1)];\n        if(M.find(P(x+1,y+1))!=M.end()) sum+=M[P(x+1,y+1)];\n        ans = max(ans,sum);\n        sum = p.second;\n        if(M.find(P(x-1,y))!=M.end()) sum+=M[P(x-1,y)];\n        if(M.find(P(x,y-1))!=M.end()) sum+=M[P(x,y-1)];\n        if(M.find(P(x-1,y-1))!=M.end()) sum+=M[P(x-1,y-1)];\n        ans = max(ans,sum);\n        sum = p.second;\n        if(M.find(P(x+1,y))!=M.end()) sum+=M[P(x+1,y)];\n        if(M.find(P(x,y-1))!=M.end()) sum+=M[P(x,y-1)];\n        if(M.find(P(x+1,y-1))!=M.end()) sum+=M[P(x+1,y-1)];\n        ans = max(ans,sum);\n        sum = p.second;\n        if(M.find(P(x-1,y))!=M.end()) sum+=M[P(x-1,y)];\n        if(M.find(P(x,y+1))!=M.end()) sum+=M[P(x,y+1)];\n        if(M.find(P(x-1,y+1))!=M.end()) sum+=M[P(x-1,y+1)];\n        ans = max(ans,sum);\n    }\n    cout<<ans<<\" / 1\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint dx[4] = {0, 1, 0, 1};\nint dy[4] = {0, 0, 1, 1};\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    map<pii, int> mp;\n    rep(_, n){\n        int x, y, w;\n        scanf(\"%d%d%d\", &x, &y, &w);\n        mp[{x, y}] = w;\n        rep(i, 4)if(mp.find({x-dx[i], y-dy[i]}) == mp.end()){\n            mp[{x-dx[i], y-dy[i]}] = 0;\n        }\n    }\n\n    int ans = 0;\n    for(auto p: mp){\n        int x, y, tmp = 0;\n        tie(x, y) = p.fi;\n        rep(i, 4)if(mp.find({x+dx[i], y+dy[i]}) != mp.end()){\n            tmp += mp[{x+dx[i], y+dy[i]}];\n        }\n        chmax(ans, tmp);\n    }\n    printf(\"%d / %d\\n\", ans, 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[2][3] = { { 1,1,0 },{0,-1,-1} }, dy[2][3] = { { 0,1,1 },{1,1,0} };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int h = 0; h < 2; h++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\ts = 0;\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tif ((j / (1 << k)) % 2 == 0) {\n\t\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[h][k], get<1>(x[i]) + dy[h][k], 0)) - x;\n\t\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[h][k] && get<1>(x[c]) == get<1>(x[i]) + dy[h][k]) {\n\t\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef tuple<int,int> point;\nmap<point,int> fox;\n\nconst int nmax=100010;\nint x[nmax],y[nmax];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint w;\n\t\tcin >> x[i] >> y[i] >> w;\n\t\tfox[point{x[i],y[i]}]=w;\n\t}\n\tint ans=0;\n\trep(i,n){\n\t\tans=max(ans,fox[point{x[i],y[i]}]+fox[point{x[i]+1,y[i]}]+fox[point{x[i],y[i]+1}]+fox[point{x[i]+1,y[i]+1}]);\n\t\tans=max(ans,fox[point{x[i],y[i]}]+fox[point{x[i]+1,y[i]}]+fox[point{x[i],y[i]-1}]+fox[point{x[i]+1,y[i]-1}]);\n\t\tans=max(ans,fox[point{x[i],y[i]}]+fox[point{x[i]-1,y[i]}]+fox[point{x[i],y[i]+1}]+fox[point{x[i]-1,y[i]+1}]);\n\t\tans=max(ans,fox[point{x[i],y[i]}]+fox[point{x[i]-1,y[i]}]+fox[point{x[i],y[i]-1}]+fox[point{x[i]-1,y[i]-1}]);\n\t}\n\tcout << ans << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <map>\n#include <utility>\n#include <math.h>\n#include <fstream>\n#include <bitset>\n \nusing namespace std;\n \nvoid solve();\n \nint main( void ) {\n \n\tsolve();\n \n\treturn 0;\n}\n \nvoid solve() {\n \n\tint N;\n \n\tmap<int,map<int,int>> mp;\t//map[x][y] = w\n\tvector<pair<int,int>> v;\n \n\tscanf(\"%d\\n\",&N);\n\tv.resize(N);\n \n\tfor( int i = 0; i < N; i++ ) {\n\t\tint x, y, w;\n\t\tscanf(\"%d %d %d\\n\",&x,&y,&w);\n\t\tmp[x][y] = w;\n\t\tv[i] = pair<int,int>(x,y);\n\t}\n \n\tint d[4][2] = { {0,1}, {1,1}, {1,0}, {0,0} };\n \n\tint wm = 0;\n \n\tfor( int i = 0; i < N; i++ ) {\n\t\tfor( int j = 0; j < 4; j++ ) {\n\t\t\tint w = 0;\n\t\t\tpair<int,int> b(v[i]);\n\t\t\t\tb.first  -= d[j][0];\n\t\t\t\tb.second -= d[j][1];\n\t\t\tfor( int k = 0; k < 4; k++ ) {\n\t\t\t\tpair<int,int> p(b);\n\t\t\t\t\tp.first += d[k][0];\n\t\t\t\t\tp.second += d[k][1];\n\t\t\t\tif( mp.find( p.first ) != mp.end() ) {\n\t\t\t\t\tif( mp[p.first].find( p.second ) != mp[p.first].end() ) {\n\t\t\t\t\t\tw += mp[p.first][p.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twm = max(w,wm);\n\t\t}\n\t}\n \n\tcout << wm << \" / \" << 1 << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint W[300010][300010];\n\nint getWeight(int left, int top)\n{\n  return W[left][top]+W[left+1][top]+W[left][top+1]+W[left+1][top+1];\n}\n\nint main()\n{\n  int N; cin >> N;\n  vector<int> x(N), y(N), w(N);\n  vector<int> X, Y;\n  for(int i = 0; i < N; i++) {\n    cin >> x[i] >> y[i] >> w[i];\n    X.push_back(x[i]-1); X.push_back(x[i]); X.push_back(x[i]+1);\n    Y.push_back(y[i]-1); Y.push_back(y[i]); Y.push_back(y[i]+1);\n  }\n\n  sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n  //memset(W, 0, sizeof(W));\n  for(int i = 0; i < N; i++) {\n    x[i] = find(X.begin(), X.end(), x[i]) - X.begin();\n    y[i] = find(Y.begin(), Y.end(), y[i]) - Y.begin();\n    W[x[i]][y[i]] = w[i];\n  }\n\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    ans = max(ans, getWeight(x[i]-1, y[i]-1));\n    ans = max(ans, getWeight(x[i]-1, y[i]));\n    ans = max(ans, getWeight(x[i], y[i]-1));\n    ans = max(ans, getWeight(x[i], y[i]));\n  }\n  cout << ans << \" / 1\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint N;\nmap<P,int> points;\nP ary[4][4] = {\n    {P(0,0),P(0,-1),P(-1,0),P(-1,-1)},\n    {P(0,0),P(0,-1),P(1,0),P(1,-1)},\n    {P(0,0),P(0,1),P(1,0),P(1,1)},\n    {P(0,0),P(0,1),P(-1,0),P(-1,1)}\n};\nP operator+(P a,P b) {\n    return P(a.fr+b.fr,a.sc+b.sc);\n}\nint main() {\n    vector<P> vec;\n    cin>>N;\n    rep(i,N) {\n        int x,y,w;\n        cin>>x>>y>>w;\n        vec.pb(P(x,y));\n        points[P(x,y)]=w;\n    }\n    int ans=0;\n    for(auto point : vec) {\n        P p=point;\n        rep(i,4) {\n            int t=0;\n            rep(j,4) {\n                t+=points[p+ary[i][j]];\n            }\n            ans=max(ans,t);\n        }\n    }\n\n    cout<<ans<<\" / 1\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconstexpr long long INF = (long long)1e18;\nconstexpr long long MOD = 1'000'000'007; \n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N;\n\tint ans = 0;\n\tmap<pair<int,int>, int> c;\n\t\n\tcin>>N;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tint x, y, w;\n\t\t\n\t\tcin>>x>>y>>w;\n\t\t\n\t\tc[{x, y}] += w;\n\t}\n\tfor(pair<pair<int,int>,int> p : c){\n\t\tint x = p.first.first;\n\t\tint y = p.first.second;\n\t\tint con = 0;\n\t\t\n\t\tif(c.count({x,y})) con += c.find({x,y})->second;\n\t\tif(c.count({x,y+1})) con += c.find({x,y+1})->second;\n\t\tif(c.count({x+1,y})) con += c.find({x+1,y})->second;\n\t\tif(c.count({x+1,y+1})) con += c.find({x+1,y+1})->second;\n\t\t\n\t\tif(con > ans) {\n\t\t\tans = con;\n\t\t}\n\t\tcon = 0;\n\t\t\n\t\tif(c.count({x,y})) con += c.find({x,y})->second;\n\t\tif(c.count({x,y-1})) con += c.find({x,y-1})->second;\n\t\tif(c.count({x+1,y})) con += c.find({x+1,y})->second;\n\t\tif(c.count({x+1,y-1})) con += c.find({x+1,y-1})->second;\n\t\t\n\t\tif(con > ans) {\n\t\t\tans = con;\n\t\t}\n\t\tcon = 0;\n\t\t\n\t\tif(c.count({x,y})) con += c.find({x,y})->second;\n\t\tif(c.count({x,y+1})) con += c.find({x,y+1})->second;\n\t\tif(c.count({x-1,y})) con += c.find({x-1,y})->second;\n\t\tif(c.count({x-1,y+1})) con += c.find({x-1,y+1})->second;\n\t\t\n\t\tif(con > ans) {\n\t\t\tans = con;\n\t\t}\n\t\t// con = 0;\n\t\t\n\t\t// if(c.count({x,y})) con += c.find({x,y})->second;\n\t\t// if(c.count({x,y-1})) con += c.find({x,y-1})->second;\n\t\t// if(c.count({x-1,y})) con += c.find({x-1,y})->second;\n\t\t// if(c.count({x-1,y-1})) con += c.find({x-1,y-1})->second;\n\t\t\n\t\t// if(con > ans) {\n\t\t\t// ans = con;\n\t\t// }\n\t}\n\t\n\tcout<<ans<<\" / \"<<1<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmap<pair<int,int>,int>m;\nint main(){\n  int n,a,b,c,p=0;\n  cin>>n;\n  while(n--){\n    cin>>a>>b>>c;\n    r(i,2)r(j,2)\n      p=max(p,m[make_pair(a+i,b+j)]+=c);\n  }\n  cout<<p<<\" / 1\"<<endl;      \n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint main(){\n    iostream_init();\n    int N;\n    while(cin >> N) {\n        vector<int> v;\n        map< pair<int, int>, int> cnt;\n        REP(i, N) {\n            int x, y, w;\n            cin >> x >> y >> w;\n            cnt[make_pair(x, y)] += w;\n        }\n\n        int max_sum = 0;\n        for(auto p : cnt) {\n            REP(dy, 2) REP(dx, 2) {\n                int bx = p.first.first - dx;\n                int by = p.first.second - dy;\n                int sum = 0;\n                REP(i, 2) REP(j, 2) {\n                    auto p = make_pair(bx+i, by+j);\n                    if(cnt.count(p)) sum += cnt[p];\n                }\n                max_sum = max(max_sum, sum);\n            }\n        }\n        cout << max_sum << \" / 1\" << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Info1{\n\tInfo1(int arg_x,int arg_y,int arg_w){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info1 &arg) const{ //y?????????\n\t\t\treturn y < arg.y;\n\t};\n\tint x,y,w;\n};\n\nstruct Info2{\n\tInfo2(int arg_x,int arg_w){\n\t\tx = arg_x;\n\t\tw = arg_w;\n\t}\n\tbool operator<(const struct Info2 &arg) const{ //x?????????\n\t\t\treturn x > arg.x;\n\t};\n\tint x,w;\n};\n\nint main(){\n\n\tint N,tmp_x,tmp_y,tmp_w,pre_y,pre_x,index = -1,self,ans = 0,right;\n\tscanf(\"%d\",&N);\n\n\tint* Y_VALUE = new int[N]; //?????????vector????????£??????y??§?¨?????¨???????????????????????????????\n\n\t//?????????y??????????????°??????????????????\n\tpriority_queue<Info1> Q;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d\",&tmp_x,&tmp_y,&tmp_w);\n\t\tQ.push(Info1(tmp_x,tmp_y,tmp_w));\n\t}\n\n\tvector<Info2> V[N];\n\n\treturn 0;\n\n\tpre_y = BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().y != pre_y){ //??°??????y??????????????????\n\t\t\tindex++;\n\t\t\tY_VALUE[index] = Q.top().y; //??°??????y??????????¨????\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}else{\n\t\t\tV[index].push_back(Info2(Q.top().x,Q.top().w));\n\t\t}\n\t\tpre_y = Q.top().y;\n\t\tQ.pop();\n\t}\n\tindex++;\n\n\tfor(int i = 0; i < index; i++)sort(V[i].begin(),V[i].end()); //?????°???????????????x????????????sort\n\n\tfor(int i = 0; i < index; i++){\n\t\tfor(int k = 0; k < V[i].size();k++){\n\t\t\tprintf(\"y:%d x:%d\\n\",Y_VALUE[i],V[i][k].x);\n\t\t}\n\t}\n\n\treturn 0;\n\n\tpre_y = pre_x = BIG_NUM;\n\n\tint l,r,m,loc;\n\n\tfor(int i = 0; i < index; i++){ //y?????????????????????\n\t\tfor(int k = 0; k < V[i].size(); k++){ //x????????????\n\n\t\t\t//????????????????????????????§???¢????¨????\n\t\t\tif(pre_y == i && pre_x == V[i][k].x-1){ //??????????????????1?????????????????????????????????????????????????§???¢????¨??????????\n\t\t\t\tself = right;\n\t\t\t}else{ //????????????????????????????§???¢????¨??????????\n\t\t\t\tif(i == index - 1 || Y_VALUE[i] - Y_VALUE[i+1] > 1){ //?????????1??????????????????????????¨???????????´???\n\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t}else{\n\t\t\t\t\t//2?????¢?´¢??§???V[i][k]????????????????????????????????????????????¢???<?????????????£????????????°?????¢????´¢??§??????>\n\t\t\t\t\tl = 0;\n\t\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\t\twhile(l <= r){\n\t\t\t\t\t\tif(V[i+1][m].x == V[i][k].x || V[i+1][m].x == V[i][k].x-1){ //????????????????????????????????°break\n\t\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(loc == BIG_NUM){ //??????????????????????????????????????????????????¨???????????´???\n\t\t\t\t\t\tans = max(ans,V[i][k].w);\t//????????????????¨??????????\n\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(loc == V[i][k].x){ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc].w;\n\t\t\t\t\t\t\tif(loc > 0 && V[i+1][loc-1].x == V[i][k].w - 1){ //????????????????????£?????????????????´???\n\t\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc-1].w);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tans = max(ans,self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{ //??????????????§?????????????????´???\n\t\t\t\t\t\t\tif(loc < V[i+1].size()-1 && V[i+1][loc+1].x == V[i][k].x){ //???????????????????????????????????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w + V[i+1][loc+1].w;\n\t\t\t\t\t\t\t}else{ //?????????????????????????????´???\n\t\t\t\t\t\t\t\tself = V[i][k].w;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans,self+V[i+1][loc].w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//????????????????????????????§???¢????¨????<self????¨??????????>\n\t\t\tif(k < V[i].size()-1 && V[i][k+1].x == V[i][k].x+1){ //?????????????????????????????´???\n\t\t\t\tright = V[i][k+1].w;\n\t\t\t}else{\n\t\t\t\tright = 0;\n\t\t\t}\n\n\t\t\tif(i < index-1 && Y_VALUE[i+1] == Y_VALUE[i]-1){ //1?????????????????????????????´???\n\t\t\t\t//???????????????????????¢?´¢??§??¢???\n\t\t\t\tl = 0;\n\t\t\t\tr = V[i+1].size()-1;\n\t\t\t\tm = (l+r)/2;\n\t\t\t\tloc = BIG_NUM;\n\n\t\t\t\twhile(l <= r){\n\t\t\t\t\tif(V[i+1][m].x == V[i][k].x+1){ //?????????????????????????????°break\n\t\t\t\t\t\tloc = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[i+1][m].x > V[i][k].x){\n\t\t\t\t\t\t\tr = m-1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tl = m+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm = (l+r)/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(loc != BIG_NUM)right += V[i+1][loc].w;\n\t\t\t}\n\n\n\t\t\tans = max(ans,self+right);\n\n\t\t\tpre_y = i;\n\t\t\tpre_x = V[i][k].x;\n\t\t}\n\t}\n\n\n\tprintf(\"%d / 1\\n\",ans);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[3] = { 1,1,0 }, dy[3] = { 0,1,1 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif ((j / (1 << k)) % 2 == 0) {\n\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[j], get<1>(x[i]) + dy[j], 0)) - x;\n\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[j] && get<1>(x[c]) == get<1>(x[i]) + dy[j]) {\n\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmap<pair<int,int>,int>m;\nmain(){\n  int n,a,b,c,p=0;\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d%d%d\",&a,&b,&c);\n    r(i,2)r(j,2)\n      p=max(p,m[make_pair(a+i,b+j)]+=c);\n  }\n  cout<<p<<\" / 1\"<<endl;      \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    vector<tuple<int,int,int> > t(n);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int a,b,c;\n        cin>>a>>b>>c;\n        t[i] = make_tuple(a,b,c);\n        ans = max(ans, c);\n    }\n    sort(t.begin(), t.end());\n    \n    for (int i = 0; i < n-1; i++) {\n        int a = get<0>(t[i]);\n        int b = get<0>(t[i+1]);\n        if (b > a+1) continue;\n        int sum = get<2>(t[i]);\n        for (int j = i+1; j < n && get<0>(t[j])-a <= 1; j++) {\n            int c = get<1>(t[j]);\n            if (abs(c-b) <= 1) sum += get<2>(t[j]);\n        }\n        ans = max(ans, sum);\n    }\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>using namespace std;int main(){int N;cin >> N;map<pair<int, int>, int> mp;for (int i = 0, y, x, w; i < N; i++) cin >> y >> x >> w, mp[{y, x}] += w, mp[{y - 1, x}] += w, mp[{y, x - 1}] += w, mp[{y - 1, x - 1}] += w;int ans = 0;for (const auto& p : mp) ans = max(ans, p.second);cout << ans << \" / \" << 1 << endl;return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmap<int, map<int, int> > W;\n\nint getWeight(int left, int top)\n{\n  return W[left][top]+W[left+1][top]+W[left][top+1]+W[left+1][top+1];\n}\n\nint main()\n{\n  int N; cin >> N;\n  vector<int> x(N), y(N);\n  for(int i = 0; i < N; i++) {\n   cin >> x[i] >> y[i];\n   cin >> W[x[i]][y[i]];\n  }\n  int ans = 0;\n  for(int i = 0; i < N; i++) {\n    ans = max(ans, getWeight(x[i]-1, y[i]-1));\n    ans = max(ans, getWeight(x[i]-1, y[i]));\n    ans = max(ans, getWeight(x[i], y[i]-1));\n    ans = max(ans, getWeight(x[i], y[i]));\n  }\n  cout << ans << \" / 1\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define f first\n#define s second\nusing namespace std;\n \nint main()\n{\n  int N,x,y,w;\n  map<pair<int,int>,int> M;\n  vector<pair<int,int> > V; \n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x>>y>>w;\n    M[make_pair(x,y)]=w;\n    V.push_back(make_pair(x,y));\n  }\n  int ans=0,sum;\n  for(int i=0;i<N;i++){\n    sum=M[make_pair(V[i].f,V[i].s)];\n    sum+=M[make_pair(V[i].f,V[i].s+1)];\n    sum+=M[make_pair(V[i].f+1,V[i].s)];\n    sum+=M[make_pair(V[i].f+1,V[i].s+1)];\n    ans=max(ans,sum);\n    sum=M[make_pair(V[i].f,V[i].s)];\n    sum+=M[make_pair(V[i].f,V[i].s-1)];\n    sum+=M[make_pair(V[i].f+1,V[i].s)];\n    sum+=M[make_pair(V[i].f+1,V[i].s-1)];\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / 1\"<<endl;\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nset<P> S;\nmap<P, llint> mp;\n\nint main(void)\n{\n  cin >> n;\n  llint x, y, w;\n  for(int i = 1; i <= n; i++){\n    cin >> x >> y >> w;\n    mp[P(x, y)] = w;\n    S.insert(P(x, y));\n    S.insert(P(x+1, y));\n    S.insert(P(x, y+1));\n    S.insert(P(x-1, y));\n    S.insert(P(x, y-1));\n\n  }\n\n  llint ans = 0;\n  for(auto it = S.begin(); it != S.end(); it++){\n    tie(x, y) = *it;\n    llint tmp = 0;\n    tmp += mp[P(x, y)];\n    tmp += mp[P(x+1, y)];\n    tmp += mp[P(x, y+1)];\n    tmp += mp[P(x+1, y+1)];\n    ans = max(ans, tmp);\n  }\n  cout << ans << \" / \" << 1 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nmap<pll,ll> mp;\nint dx[5] = {0,1,-1,1,-1};\nint dy[5] = {0,1,1,-1,-1};\nstring solve(){\n    string res;\n    ll N; cin >> N;\n    vector<ll> x(N),y(N),w(N);\n    for(int i = 0; i < N;i++) cin >> x[i] >> y[i] >> w[i];\n    ll maxv = 0;\n    vector<pll> pos;\n    for(int i = 0; i < N;i++){\n        \n        mp[pll(x[i],y[i])] = w[i];\n        for(int k = 0; k < 5;k++){\n          //  mp[pll(x[i]+dx[k],y[i]+dy[k])] += w[i];\n          //  pos.push_back(pll(x[i]+dx[k],y[i]+dy[k]));\n        }\n    }\n    \n    for(int i = 0; i < N;i++){\n        for(int k = 1; k < 5;k++){\n            if(mp.count(pll(x[i]+dx[k],y[i]+dy[k]))){\n                maxv = max(maxv,mp[pll(x[i],y[i])] + mp[pll(x[i]+dx[k],y[i]+dy[k])]);\n            }\n        }\n    }\n//    for(int i = 0; i < N;i++){\n//        for(int k = 0; k < 5;k++){\n//            maxv = max(maxv,mp[pll(x[i]+dx[k],y[i]+dy[k])]);\n//        }\n//    }\n    res = to_string(maxv) + \" / 1\";\n    return res;\n}\nint main(void){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int N;\n  map< pair< int, int >, int > p1, p2;\n  \n  cin >> N;\n  while(N--) {\n    int x, y, w;\n    cin >> x >> y >> w;\n    p1[{x, y}] = p2[{x, y}] = w;\n  }\n  int ret = 0;\n  for(const auto& p : p1) {\n    for(int k = -1; k <= 0; k++) {\n      for(int l = -1; l <= 0; l++) {\n        int weight = 0;\n        for(int i = 0; i <= 1; i++) {\n          for(int j = 0; j <= 1; j++) {\n            weight += p2[{p.first.first + k + i, p.first.second + l + j}];\n          }\n        }\n        ret = max(ret, weight);\n      }\n    }\n  }\n  cout << ret << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing pr = pair<int, int>;\n\nint n;\nmap<pr, int> g;\n\nint main()\n{\n\tcin >> n;\n\trep(i, n){\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tg[pr(x, y)] = w;\n\t}\n\n\tint res = 0;\n\tfor (auto v : g){\n\t\tpr p = v.fi;\n\t\tint s = 0;\n\t\trep(i, 2) rep(j, 2){\n\t\t\tif (g.count(pr(p.fi + i, p.se + j))){\n\t\t\t\ts += g[pr(p.fi + i, p.se + j)];\n\t\t\t}\n\t\t}\n\t\tchmax(res, s);\n\t}\n\n\tcout << res << \" \" << 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\nmap<int,int> t[101010];\nvector<int> u[101010];\nint main(void){\n    int n;\n    cin >> n;\n    int ans = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        t[x][y] = z;\n        u[x].push_back(y);\n        ans = max(ans, z);\n    }\n    for (int i = 0; i < 100001; i++) {\n        if (!u[i].size()) continue;\n        for (int j = 0; j < u[i].size(); j++) {\n            int a = u[i][j];\n            ans = max(ans, t[i][a]+t[i][a+1]+t[i+1][a]+t[i+1][a+1]);\n            ans = max(ans, t[i][a]+t[i][a-1]+t[i+1][a]+t[i+1][a-1]);\n        }\n    }\n    cout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\ntuple<int, int, int>x[1 << 17];\nint n, maxn, a, b, c, s;\nint dx[2][3] = { { 1,1,0 },{-1,-1,-1} }, dy[2][3] = { { 0,1,1 },{1,0,-1} };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> a >> b >> c; x[i] = make_tuple(a, b, c); }\n\tsort(x, x + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int h = 0; h < 2; h++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\ts = 0;\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tif ((j / (1 << k)) % 2 == 0) {\n\t\t\t\t\t\tint c = lower_bound(x, x + n, make_tuple(get<0>(x[i]) + dx[h][k], get<1>(x[i]) + dy[h][k], 0)) - x;\n\t\t\t\t\t\tif (get<0>(x[c]) == get<0>(x[i]) + dx[h][k] && get<1>(x[c]) == get<1>(x[i]) + dy[h][k]) {\n\t\t\t\t\t\t\ts += get<2>(x[c]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxn = max(maxn, s + get<2>(x[i]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/stack:16777216\")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <complex>\nusing namespace std;\n \n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,value) memset(A,value,sizeof(A))\n \n#define ALL(V) V.begin(), V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define Pi 3.14159265358979\n#define x0 ikjnrmthklmnt\n#define y0 lkrjhkltr\n#define y1 ewrgrg\n \ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<Int, Int> PLL;\ntypedef pair<double, double> PDD;\ntypedef complex<double> base;\n \nconst int INF = 1000000000;\nconst int MAX = 120000;\nconst int MAX2 = 50007;\nconst int ADD = 1000000;\nconst int MAXD = 256;\nconst int BASE = 1000000000;\nconst int MOD = 1000000007;\n\nint n;\nint x[MAX], y[MAX], w[MAX];\nmap<PII, int> M;\nint q[3][3];\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"distance.in\",  \"r\", stdin);\n\t//freopen(\"distance.out\", \"w\", stdout);\n\t//freopen(\"out.txt\" , \"w\" , stdout);\n\t\n\tcin >> n;\n\tFOR (i,0,n)\n\t{\n\t\tscanf(\"%d%d%d\", x+i, y+i, w+i);\n\t\tM[MP(x[i], y[i])] = w[i];\n\t}\n\tint ans = 0;\n\tFOR (i,0,n)\n\t{\n\t\tFOR (dx,-1,2)\n\t\tFOR (dy,-1,2)\n\t\t{\n\t\t\tq[dx+1][dy+1] = M[MP(x[i]+dx,y[i]+dy)];\n\t\t}\n\t\tFOR(i1,0,2)\n\t\tFOR(i2,0,2)\n\t\tans = max(ans, q[i1][i2] + q[i1][i2+1] + q[i1+1][i2] + q[i1+1][i2+1]);\n\t}\n\tcout << ans << \" / 1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n  int N; cin >> N;\n  map<pair<int, int>, long long int>ps;\n  for (int i = 0; i < N; ++i) {\n    long long int x, y, w; cin >> x >> y >> w;\n    ps[make_pair(x, y)] += w;\n    ps[make_pair(x - 1, y)] += w;\n    ps[make_pair(x, y - 1)] += w;\n    ps[make_pair(x - 1, y - 1)] += w;\n  }\n  long long int ans = 0;\n  for (auto p : ps) {\n    if (p.second > ans)ans = p.second;\n  }\n  cout << ans <<\" / \"<<1<< endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;tuple<int,int,int>x[1<<17];int n,m,a,b,c,s,h,i,j,k;int dx[2][3]={{1,1,0},{0,-1,-1}},dy[2][3]={{0,1,1},{1,1,0}};main(){cin>>n;for(i=0;i<n;i++){cin>>a>>b>>c;x[i]=make_tuple(a,b,c);}sort(x,x+n);for(i=0;i<n;i++){for(h=0;h<2;h++){for(j=0;j<8;j++){s=0;for(k=0;k<3;k++){if((j/(1<<k))%2==0){c=lower_bound(x,x+n,make_tuple(get<0>(x[i])+dx[h][k],get<1>(x[i])+dy[h][k],0))-x;if(get<0>(x[c])==get<0>(x[i])+dx[h][k]&&get<1>(x[c])==get<1>(x[i])+dy[h][k]){s+=get<2>(x[c]);}}}m=max(m,s+get<2>(x[i]));}}}cout<<m<<\" / 1\"<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int N, W;\n    cin >> N;\n    vector<int> X(N), Y(N);\n    map<int, map<int, int>> coor;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i] >> W;\n        coor[X[i]][Y[i]] = W;\n    }\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        res = max(res, coor[X[i]][Y[i]] +\n                       coor[X[i]+1][Y[i]] +\n                       coor[X[i]][Y[i]+1] +\n                       coor[X[i]+1][Y[i]+1]);\n\n        res = max(res, coor[X[i]][Y[i]] +\n                       coor[X[i]+1][Y[i]] +\n                       coor[X[i]][Y[i]-1] +\n                       coor[X[i]+1][Y[i]-1]);\n    }\n    cout << res << \" / \" << 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define f first\n#define s second\nusing namespace std;\n\nint main()\n{\n  int N,x,y,w;\n  int a[10000000],b[1000000000];\n  vector<pair<pair<int,int>,int> >V;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x>>y>>w;\n    V.push_back(make_pair(make_pair(x,y),w));\n  }\n  //sort(V.begin(),V.end());\n  int ans=0,sum;\n  for(int i=0;i<N;i++){\n    sum=V[i].s;\n    for(int j=1;j<N;j++){\n      if(V[i].f.f==V[j].f.f && V[i].f.s+1==V[j].f.s){\n\tsum+=V[j].s;\n      }\n      else if(V[i].f.f+1==V[j].f.f && V[i].f.s==V[j].f.s){\n\tsum+=V[j].s;\n      }\n      else if(V[i].f.f+1==V[j].f.f && V[i].f.s+1==V[j].f.s){\n\tsum+=V[j].s;\n      }\n    }\n    ans=max(ans,sum);\n  }\n  cout<<ans<<\" / 1\"<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef pair< int, int > pii;\n\nconst int dx[5][4] = { {0,-1}, {0,1}, {1,0}, {0,-1}, {-1,1,1,-1} };\nconst int dy[5][4] = { {-1,0}, {-1,0}, {0,1}, {1,0}, {-1,-1,1,1} };\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tmap< pii, int > lattice;\n\t\n\tfor_(i,0,N) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tlattice[pii(x,y)] = w;\n\t}\n\t\n\tint ans = 0;\n\t\n\tmap< pii, int >::iterator it = lattice.begin(), eit = lattice.end();\n\t\n\tfor (; it != eit; ++it) {\n\t\tpii p = (*it).first;\n\t\t\n\t\tfor_(di,0,4) {\n\t\t\tpii cp(p.first + dx[4][di], p.second + dy[4][di]);\n\t\t\n\t\t\tif (lattice.count(cp)) {\n\t\t\t\tint val = (*it).second + lattice[cp];\n\t\t\t\t\n\t\t\t\tfor_(dj,0,2) {\n\t\t\t\t\tpii fp(p.first + dx[di][dj], p.second + dy[di][dj]);\n\t\t\t\t\tif (lattice.count(fp)) val += lattice[fp];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans = max(ans, val);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll, ll> pi;\n\nmap<pi,ll>m;\nll N;\n\nint main()\n{\n  cin >> N;\n  rep(i,N){\n    ll x,y,z; cin >> x >> y >> z;\n    m[pi(x,y)] = z;\n  }\n  ll res = 0;\n  for(auto z:m){\n    ll x=z.first.first,y=z.first.second;\n    ll a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];\n    if(m.count(pi(x+1,y))) a += m[pi(x+1,y)];\n    if(m.count(pi(x,y+1))) a += m[pi(x,y+1)];\n    if(m.count(pi(x+1,y+1))) a += m[pi(x+1,y+1)];\n    res = max(res, a);\n    a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];        \n    if(m.count(pi(x-1,y))) a += m[pi(x-1,y)];\n    if(m.count(pi(x,y-1))) a += m[pi(x,y-1)];\n    if(m.count(pi(x-1,y-1))) a += m[pi(x-1,y-1)];\n    res = max(res, a);\n    a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];\n    if(m.count(pi(x-1,y))) a += m[pi(x-1,y)];\n    if(m.count(pi(x,y+1))) a += m[pi(x,y+1)];\n    if(m.count(pi(x-1,y+1))) a += m[pi(x-1,y+1)];\n    res = max(res, a);\n    a = 0;\n    if(m.count(pi(x,y))) a += m[pi(x,y)];\n    if(m.count(pi(x,y-1))) a += m[pi(x,y-1)];\n    if(m.count(pi(x+1,y-1))) a += m[pi(x+1,y-1)];\n    if(m.count(pi(x+1,y))) a += m[pi(x+1,y)];        \n  }\n  cout << res << \" / 1\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<int> x(N), y(N), w(N);\n    map<pair<int, int>, int> W;\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> y[i] >> w[i];\n        W[make_pair(x[i], y[i])] = w[i];\n    }\n\n    int ans = 0;\n    for (int i = 0; i < N; ++i) {\n        int sum = 0;\n        for (int dx = 0; dx <= 1; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x[i] + dx, y[i] + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n\n        sum = 0;\n        for (int dx = -1; dx <= 0; ++dx) {\n            for (int dy = 0; dy <= 1; ++dy) {\n                auto p = make_pair(x[i] + dx, y[i] + dy);\n                if (W.count(p)) sum += W[p];\n            }\n        }\n        ans = max(ans, sum);\n    }\n\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    vector<tuple<int,int,int> > t(n);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int a,b,c;\n        cin>>a>>b>>c;\n        t[i] = make_tuple(a,b,c);\n        ans = max(ans, c);\n    }\n    sort(t.begin(), t.end());\n    \n    for (int i = 0; i < n-1; i++) {\n        int a = get<0>(t[i]);\n        int b = get<0>(t[i+1]);\n        if (b > a+1) continue;\n        int sum = get<2>(t[i]);\n        int sum2 = sum;\n        for (int j = i+1; j < n && get<0>(t[j])-a <= 1; j++) {\n            int c = get<1>(t[j]);\n            if (c==b || c==b+1) sum += get<2>(t[j]);\n            if (c==b || c==b-1) sum2 += get<2>(t[j]);\n            sum = max(sum, sum2);\n        }\n        ans = max(ans, sum);\n    }\n    cout << ans << \" / 1\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nmap<pair<int,int>,int>ma;\nint main(){\n\tint n;\n\tcin>>n;\n\tvvi in(n);\n\trep(i,n){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\tin[i]=vi{a,b,c};\n\t\tma[{a,b}]=c;\n\t}\n\tll a=0,b=1,sum,sx,sy,gx,gy,area,gc_d;\n\trep(q,n){\n\t\tloop(x,-4,5)loop(y,-4,5)if(x!=0&&y!=0){\n\t\t\tsum=0;\n\t\t\tsx=min(in[q][0],in[q][0]+x);\n\t\t\tgx=max(in[q][0],in[q][0]+x);\n\t\t\tsy=min(in[q][1],in[q][1]+y);\n\t\t\tgy=max(in[q][1],in[q][1]+y);\t\t\t\n\t\t\tloop(i,sx,gx+1)loop(j,sy,gy+1)sum+=ma[{i,j}];\n\t\t\tarea=abs(x*y);\n\t\t\tgc_d=gcd(sum,area);\n\t\t\tsum/=gc_d;\n\t\t\tarea/=gc_d;\n\t\t\tif(a*area<b*sum){\n\t\t\t\ta=sum;\n\t\t\t\tb=area;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a<<\" / \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int dy[] = {1, 1, 0, -1, -1, -1, 0, 1, 1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tmap<P, ll> mp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tmp[make_pair(x, y)] = w;\n\t}\n\tll ans = 0;\n\tfor(auto itr = mp.begin(); itr != mp.end(); itr++)\n\t{\n\t\tll cnt = itr->second;\n\t\tqueue<ll> que;\n\t\tmap<P,ll> mp_tmp(mp);\n\t\tfor(int i = 0; i < 9; i++)\n\t\t{\n\t\t\tll nx = itr->first.first + dx[i];\n\t\t\tll ny = itr->first.second + dy[i];\n\t\t\tP tmp = make_pair(nx, ny);\n\t\t\tif(mp.count(tmp) > 0) cnt += mp_tmp.at(make_pair(nx, ny));\n\t\t\telse mp_tmp[make_pair(nx, ny)] = 0;\n\t\t\tque.push(mp_tmp.at(make_pair(nx, ny)));\n\t\t\tif(que.size() == 3) \n\t\t\t{\n\t\t\t\tans = max(cnt, ans);\n\t\t\t\tfor(int j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tll q = que.front(); que.pop();\n\t\t\t\t\tcnt -= q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\nconst int INF = 1<<31; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<PP> vec;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll x, y, w;\n\t\tcin >> x >> y >> w;\n\t\tvec.push_back(PP(P(x, y), w));\n\t}\n\tsort(vec.begin(), vec.begin());\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll cnt = vec[i].second;\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tbool ok = false;\n\t\t\tif(vec[i].first.first + 1 == vec[j].first.first && vec[i].first.second == vec[j].first.second)\n\t\t\t{\n\t\t\t\tok = true;\t\n\t\t\t\tcnt += vec[j].second;\n\t\t\t}\n\t\t\tif(vec[i].first.first == vec[j].first.first && vec[i].first.second + 1 == vec[j].first.second)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tcnt += vec[j].second;\n\t\t\t}\n\t\t\tif(vec[i].first.first + 1 == vec[j].first.first && vec[i].first.second + 1 == vec[j].first.second)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tcnt += vec[j].second;\n\t\t\t}\n\t\t\t//if(ok == false) break;\n\t\t}\n\t\tans = max(cnt, ans);\n\t}\n\tcout << ans << \" / \" << 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nint dx[5] = {0,1,-1,1,-1};\nint dy[5] = {0,1,1,-1,-1};\nstring solve(){\n    string res;\n    ll N; cin >> N;\n    vector<ll> x(N),y(N),w(N);\n    for(int i = 0; i < N;i++) cin >> x[i] >> y[i] >> w[i];\n    if(N == 1) return \"0 / 1\";\n    map<pll,ll> mp;\n    int d[5] = {1,0,-1,0,1};\n    ll maxv = 0;\n    for(int i = 0; i < N;i++){\n        for(int k = 0; k < 5;k++){\n            mp[pll(x[i]+dx[k],y[i]+dy[k])] += w[i];\n        }\n    }\n    for(int i = 0; i < N;i++){\n        for(int k = 0; k < 5;k++){\n            maxv = max(maxv,mp[pll(x[i]+dx[k],y[i]+dy[k])]);\n        }\n    }\n    res = to_string(maxv) + \" / 1\";\n    return res;\n}\nint main(void){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint main(){\n  int N;\n  cin >> N;\n  vector<int> X(N), Y(N);\n  map<pair<int,int>, int> M;\n  int x, y, w;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y >> w;\n    X[i] = x;\n    Y[i] = y;\n    M[make_pair(x,y)] = w;\n  }\n  long long int ans = 0;\n  for(int i = 0; i < N; ++i){\n    x = X[i];\n    y = Y[i];\n    for(int dx = -1; dx < 2; dx += 2){\n      for(int dy = -1; dx < 2; dx += 2){\n        long long int t = 0;\n        for(int j = 0; j < 2; ++j){\n          for(int k = 0; k < 2; ++k){\n            int x_ = x + dx*j, y_ = y + dy*k;\n            t += M[make_pair(x_,y_)];\n          }\n        }\n        ans = max(ans, t);\n      }\n    }\n  }\n  cout << ans << \" / \" << 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\nconst int dx[] = {0,1,1,1,0,-1,-1,-1};\nconst int dy[] = {1,1,0,-1,-1,-1,0,1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  VI x(n),y(n),w(n);\n  map<PII,int> mp;\n  rep(i,n){\n    cin >> x[i] >> y[i] >> w[i];\n    mp[{x[i],y[i]}] = w[i];\n  }\n  int ans = 0;\n  rep(i,n){\n    int add[8];\n    rep(dir,8){\n      add[dir] = mp[{dx[dir]+x[i],dy[dir]+y[i]}];\n    }\n    for(int dir = 0; dir < 8; dir+=2){\n      ans = max<int>(ans,w[i] + add[dir] + add[(dir+1)%8] + add[(dir+2)%8]);\n    }\n  }\n  cout << ans << \" / \" << 1<< endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Pair = pair<int, int>;\n\nint N;\nvector<Pair> ps;\nmap<Pair, int> mp;\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    int x, y, w;\n    scanf(\"%d%d%d\", &x, &y, &w);\n    mp[Pair(x,y)] = w;\n    ps.emplace_back(Pair(x, y));\n  }\n\n  int ans = 0;\n  for (Pair p : ps) {\n    int x = p.first;\n    int y = p.second;\n    int t = mp[Pair(x, y)] + mp[Pair(x, y-1)] + mp[Pair(x-1, y)] + mp[Pair(x-1, y-1)];\n    int t2 = mp[Pair(x, y)] + mp[Pair(x, y-1)] + mp[Pair(x+1, y)] + mp[Pair(x+1, y-1)];\n    ans = max(ans, t);\n    ans = max(ans, t2);\n  }\n  printf(\"%d / 1\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    int ans = 0;\n    vector<map<int,int> > t(101010);\n    vector<vector<int> > u(101010);\n    for (int i = 0; i < n; i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        t[x][y] = z;\n        u[x].push_back(y);\n        ans = max(ans, z);\n    }\n    for (int i = 0; i < 100001; i++) {\n        if (!u[i].size()) continue;\n        for (int j = 0; j < u[i].size(); j++) {\n            int a = u[i][j];\n            ans = max(ans, t[i][a]+t[i][a+1]+t[i+1][a]+t[i+1][a+1]);\n            ans = max(ans, t[i][a]+t[i][a-1]+t[i+1][a]+t[i+1][a-1]);\n        }\n    }\n    cout << ans << \" / 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int dy[] = {1, 1, 0, -1, -1, -1, 0, 1, 1};\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    map<P, ll> mp;\n    for(int i = 0; i < n; i++)\n    {\n        ll x, y, w;\n        cin >> x >> y >> w;\n        mp[make_pair(x, y)] = w;\n    }\n    ll ans = 0;\n    for(auto itr = mp.begin(); itr != mp.end(); itr++)\n    {\n        ll cnt = itr->second;\n        queue<ll> que;\n        for(int i = 0; i < 9; i++)\n        {\n            ll nx = itr->first.first + dx[i];\n            ll ny = itr->first.second + dy[i];\n            P tmp = make_pair(nx, ny);\n            if(mp.count(tmp) > 0) cnt += mp[tmp];\n            if(mp.find(tmp) != mp.end()) que.push(mp[tmp]);\n            else que.push(0);\n            if(que.size() == 3) \n            {\n                ans = max(cnt, ans);\n                for(int j = 0; j < 2; j++)\n                {\n                    ll q = que.front(); que.pop();\n                    cnt -= q;\n                }\n            }\n        }\n        ans = max(cnt, ans);\n    }\n    cout << ans << \" / \" << 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nusing P = pair<int,int>;\nint main(){\n    int N;\n    cin>>N;\n    map<P,int> M;\n    for(int i=0;i<N;i++){\n        int x,y,w;\n        cin>>x>>y>>w;\n        M[P(x,y)]=w;\n    }\n    int ans = 0;\n    for(auto p:M){\n        int x,y;\n        tie(x,y)=p.first;\n        int sum = p.second;\n        if(M.find(P(x+1,y))!=M.end()) sum+=M[P(x+1,y)];\n        if(M.find(P(x,y+1))!=M.end()) sum+=M[P(x,y+1)];\n        if(M.find(P(x+1,y+1))!=M.end()) sum+=M[P(x+1,y+1)];\n        ans = max(ans,sum);\n    }\n    cout<<ans<<\" / 1\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2621: Fox Observation\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define HASHSIZ 200017\ntypedef struct { long long n; int w; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint ans;\n\nvoid insert(int x, int y, int w)\n{\n\tlong long xy = ((long long)x << 32) + y;\n\tHASH *p = hash + xy % HASHSIZ;\n\twhile (p->n) {\n\t\tif (p->n == xy) goto next;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->n = xy;\nnext:\n\tp->w += w;\n\tif (p->w > ans) ans = p->w;\n}\n\n#define BASE 1000000000\t\t// 10^9\n\nchar buf[35], *p;\nint getint(void)\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\t\treturn -n;\n\t}\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, x, y, w;\n\n\tfgets(p=buf, 10, stdin), n = getint();\n\tans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 35, stdin);\n\t\tx = BASE + getint(), p++, y = BASE + getint(), p++, w = getint();\n\t\tinsert(x  , y  , w);\n\t\tinsert(x+1, y  , w);\n\t\tinsert(x  , y+1, w);\n\t\tinsert(x+1, y+1, w);\n\t}\n\tprintf(\"%d / 1\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2621: Fox Observation\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define HASHSIZ 999983\ntypedef struct { long long n; int w; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint ans;\n\nvoid insert(int x, int y, int w)\n{\n\tlong long xy = ((long long)x << 32) + y;\n\tHASH *p = hash + xy % HASHSIZ;\n\twhile (p->n) {\n\t\tif (p->n == xy) goto next;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->n = xy;\nnext:\n\tw += p->w;\n\tp->w = w;\n\tif (w > ans) ans = w;\n}\n\n#define BASE 1000000000\t\t// 10^9\n\nchar buf[35], *p;\nint getint(void)\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\t\treturn -n;\n\t}\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, x, y, w;\n\n\tfgets(p=buf, 10, stdin);\n\tn = getint();\n\tans = 0;\n\twhile (n--) {\n\t\tfgets(p=buf, 35, stdin);\n\t\tx = BASE + getint(), p++, y = BASE + getint(), p++, w = getint();\n\t\tinsert(x  , y  , w);\n\t\tinsert(x+1, y  , w);\n\t\tinsert(x  , y+1, w);\n\t\tinsert(x+1, y+1, w);\n\t}\n\tprintf(\"%d / 1\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2621: Fox Observation\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define HASHSIZ 800011\ntypedef struct { long long n; int w; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint ans;\n\nvoid insert(int x, int y, int w)\n{\n\tlong long xy = ((long long)x << 32) + y;\n\tHASH *p = hash + xy % HASHSIZ;\n\twhile (p->n) {\n\t\tif (p->n == xy) goto next;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->n = xy;\nnext:\n\tp->w += w;\n\tif (p->w > ans) ans = p->w;\n}\n\n#define BASE 1000000000\t\t// 10^9\n\nchar buf[35], *p;\nint getint(void)\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\t\treturn -n;\n\t}\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, x, y, w;\n\n\tfgets(p=buf, 10, stdin), n = getint();\n\tans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 35, stdin);\n\t\tx = BASE + getint(), p++, y = BASE + getint(), p++, w = getint();\n\t\tinsert(x  , y  , w);\n\t\tinsert(x+1, y  , w);\n\t\tinsert(x  , y+1, w);\n\t\tinsert(x+1, y+1, w);\n\t}\n\tprintf(\"%d / 1\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.HashMap;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FoxObservation solver = new FoxObservation();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FoxObservation {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int N = in.nextInt();\n            Map<Integer, Map<Integer, Long>> p = new HashMap<>();\n            for (int i = 0; i < N; i++) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                long w = in.nextInt();\n                if (!p.containsKey(x)) {\n                    p.put(x, new HashMap<>());\n                }\n                p.get(x).put(y, w);\n            }\n            int[] dx = new int[]{0, 1, 0, 1};\n            int[] dy = new int[]{0, 0, 1, 1};\n            long ans = 0;\n            for (int x : p.keySet()) {\n                for (int y : p.get(x).keySet()) {\n                    long nowW = 0;\n                    for (int i = 0; i < 4; i++) {\n                        int nx = x + dx[i];\n                        int ny = y + dy[i];\n                        if (p.containsKey(nx) && p.get(nx).containsKey(ny)) {\n                            nowW += p.get(nx).get(ny);\n                        }\n                    }\n                    ans = Math.max(ans, nowW);\n                }\n            }\n            out.println(ans + \" / 1\");\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.HashMap;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FoxObservation solver = new FoxObservation();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FoxObservation {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int N = in.nextInt();\n            Map<Integer, Map<Integer, Long>> p = new HashMap<>();\n            for (int i = 0; i < N; i++) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                long w = in.nextInt();\n                if (!p.containsKey(x)) {\n                    p.put(x, new HashMap<>());\n                }\n                p.get(x).put(y, w);\n            }\n            int[] dx = new int[]{0, 1, 0, 1};\n            int[] dy = new int[]{0, 0, 1, 1};\n            int[] sign = new int[]{1, -1};\n            long ans = 0;\n            for (int x : p.keySet()) {\n                for (int y : p.get(x).keySet()) {\n                    for (int sx : sign) {\n                        for (int sy : sign) {\n                            long nowW = 0;\n                            for (int i = 0; i < 4; i++) {\n                                int nx = x + dx[i] * sx;\n                                int ny = y + dy[i] * sy;\n                                if (p.containsKey(nx) && p.get(nx).containsKey(ny)) {\n                                    nowW += p.get(nx).get(ny);\n                                }\n                            }\n                            ans = Math.max(ans, nowW);\n                        }\n\n                    }\n\n                }\n            }\n            out.println(ans + \" / 1\");\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N;\n    static int[] X, Y, W;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        X = new int[N];\n        Y = new int[N];\n        W = new int[N];\n        for (int i = 0; i < N; i++) {\n            X[i] = sc.nextInt();\n            Y[i] = sc.nextInt();\n            W[i] = sc.nextInt();\n        }\n\n        System.out.println(solve());\n    }\n\n    static String solve() {\n        Map<Long, Integer> cords = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            long c = ((long)X[i] << 32) + Y[i];\n            cords.put(c, i);\n        }\n\n        int max = 0;\n        for (int i = 0; i < N; i++) {\n            int x = X[i];\n            int y = Y[i];\n            int w = W[i];\n            int c1 = getW(cords, x-1, y-1);\n            int c2 = getW(cords, x, y-1);\n            int c3 = getW(cords, x+1, y-1);\n            int c4 = getW(cords, x-1, y);\n            int c5 = w;\n            int c6 = getW(cords, x+1, y);\n            int c7 = getW(cords, x-1, y+1);\n            int c8 = getW(cords, x, y+1);\n            int c9 = getW(cords, x+1, y+1);\n\n//            debug(x, y);\n//            debug(c1, c2, c3, c4, c5 ,c6, c7, c8, c9);\n\n            max = Math.max(max, c1 + c2 + c4 + c5);\n            max = Math.max(max, c2 + c3 + c5 + c6);\n            max = Math.max(max, c4 + c5 + c7 + c8);\n            max = Math.max(max, c5 + c6 + c8 + c9);\n        }\n        return max + \" / 1\";\n    }\n\n    static int getW(Map<Long, Integer> cords, int x, int y) {\n        long c = ((long)x << 32) + y;\n        Integer i = cords.get(c);\n        return i != null ? W[i] : 0;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nc = Hash.new(0)\nn.times do\n    x, y, w = gets.split.map(&:to_i)\n    c[[x,y]] = w\nend\nmax = 0\nc.each do |k,v|\n    sum = v + c[[k[0]+1, k[1]]] + c[[k[0], k[1]+1]] + c[[k[0]+1, k[1]+1]]\n    max = sum if sum > max\n    sum = c[[k[0]-1,k[1]]] + c[[k[0], k[1]]] + c[[k[0]-1, k[1]+1]] + c[[k[0], k[1]+1]]\n    max = sum if sum > max\n    sum = c[[k[0],k[1]-1]] + c[[k[0]+1, k[1]-1]] + c[[k[0], k[1]]] + c[[k[0]+1, k[1]]]\n    max = sum if sum > max\n    sum = c[[k[0]-1,k[1]-1]] + c[[k[0], k[1]-1]] + c[[k[0]-1, k[1]]] + c[[k[0], k[1]]]\n    max = sum if sum > max\nend\nputs \"#{max} / 1\""
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nc = Hash.new(0)\nn.times do\n    x, y, w = gets.split.map(&:to_i)\n    c[[x,y]] = w\nend\nmax = 0\nc.each do |k,v|\n    sum = v + c[[k[0]+1, k[1]]] + c[[k[0], k[1]+1]] + c[[k[0]+1, k[1]+1]]\n    max = sum if sum > max\nend\nputs \"#{max} / 1\""
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nN = input()\n\nlst = []\nm = {}\n\nfor i in range(N):\n    x, y, w = map(int, raw_input().split())\n    m[(x, y)] = w\n    lst.append((x - 1, y - 1))\n    lst.append((x - 1, y))\n    lst.append((x, y - 1))\n    lst.append((x, y))\n\nans = 0\n\nfor p in lst:\n    x = p[0]\n    y = p[1]\n    S = 0\n    if (x, y) in m:\n        S += m[(x, y)]\n    if (x + 1, y) in m:\n        S += m[(x + 1, y)]\n    if (x, y + 1) in m:\n        S += m[(x, y + 1)]\n    if (x + 1, y + 1) in m:\n        S += m[(x + 1, y + 1)]\n    ans = max(ans, S)\n\nprint str(ans) + \" / 1\"\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    n = I()\n    a = [LI() for _ in range(n)]\n    d = collections.defaultdict(int)\n    for x,y,w in a:\n        d[(x,y)] = w\n    r = 0\n    for x,y in list(d.keys()):\n        tr = 0\n        for i in range(2):\n            for j in range(2):\n                tr += d[(x+i,y+j)]\n        if r < tr:\n            r = tr\n\n    return '{} / 1'.format(r)\n\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    n = I()\n    a = [LI() for _ in range(n)]\n    xi = min(map(lambda x: x[0],a))\n    xa = max(map(lambda x: x[0],a))\n    yi = min(map(lambda x: x[1],a))\n    ya = max(map(lambda x: x[1],a))\n    s = sum(map(lambda x: x[2], a))\n    if s == 0:\n        return '0 / 1'\n\n    t = (xa-xi) * (ya-yi)\n    g = fractions.gcd(s,t)\n\n    return '{} / {}'.format(s//g,t//g)\n\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    n = I()\n    a = [LI() for _ in range(n)]\n    d = collections.defaultdict(int)\n    for x,y,w in a:\n        for i in range(2):\n            for j in range(2):\n                d[(x+i,y+j)] += w\n    r = max(d.values())\n\n    return '{} / 1'.format(r)\n\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "a={};b=0\nfor _ in [0]*int(input()):\n    x,y,w=map(int,input().split())\n    for i in range(2):\n        for j in range(2):\n            if (x+i,y+j) not in a:a[(x+i,y+j)]=0\n            a[(x+i,y+j)]+=w\n            b=max(b,a[(x+i,y+j)])\nprint(str(b)+' / 1')"
  }
]