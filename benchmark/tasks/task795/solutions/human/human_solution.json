[
  {
    "language": "Crystal",
    "code": "s = gets.not_nil!.chomp\nn = s.size\nc = 0\ncs = s.chars.map {|x|\n  c += x.to_i\n}\ndp = Array.new(2 * n + 1) { Array.new(2 * n + 1, 0) }\ndp[0][0] = 1\n1.upto(2 * n) do |k|\n  j = [k - 1, n - 1].min\n  0.upto(k) do |i|\n    if i > 0 && cs[j] >= i\n      dp[k][i] += dp[k - 1][i - 1]\n    end\n    if 2 * (1 + j) - cs[j] >= k - i\n      dp[k][i] += dp[k - 1][i]\n    end\n    dp[k][i] %= 998244353\n  end\nend\nputs dp[2 * n][cs[n - 1]]"
  },
  {
    "language": "Crystal",
    "code": "s=gets||\"\"\nn=s.size\nc=0\nd=[1]\n1.upto(2*n){|k|d<<0\nj=k<n ? (c+=s[k-1].to_i;k) : n\nk.downto(0){|i|d[i]=0 if 2*j-c<k-i\nd[i]+=d[i-1] if i>0&&c>=i\nd[i]%=998244353}}\np d[c]"
  },
  {
    "language": "Crystal",
    "code": "s=gets||\"\"\nn=s.size\nc=0\nd=[1]\n1.upto(2*n){|k|d<<0\nj=k>n ? n:(c+=s[k-1].to_i;k)\nk.downto(0){|i|d[i]=0 if 2*j-c<k-i\nd[i]+=d[i-1] if i>0&&c>=i\nd[i]%=998244353}}\np d[c]"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  def main(args: Array[String]): Unit = {\n    val s = new Main()\n    s.solve()\n    s.out.flush()\n  }\n}\n\nclass Main {\n  import java.io._\n  import java.util.StringTokenizer\n\n  import scala.collection.mutable\n  import scala.util.Sorting\n  import math.{abs, max, min}\n  import mutable.{ArrayBuffer, ListBuffer}\n  import scala.reflect.ClassTag\n\n  val MOD = 998244353\n  val out = new PrintWriter(System.out)\n\n  def solve(): Unit = {\n    val S = ns()\n    val N = S.length\n    val A = map(N) { i => S(i) - '0' }\n    val B = Array.ofDim[Int](N)\n    REP(N) { i => B(i) = abs(A(i) - 2) }\n\n    val cumA = cumSum(A)\n    val cumB = cumSum(B)\n\n//    debug(A)\n//    debug(B)\n//    debug(cumA)\n//    debug(cumB)\n\n    val dp = Array.ofDim[Long](2 * N + 1, 2 * N + 1)\n    dp(0)(0) = 1\n    REP(2 * N + 1) { a =>\n      REP(2 * N + 1) { b =>\n        val restrict = min(N, a + b)\n        if (cumA(restrict) >= a && cumB(restrict) >= b) {\n          if (a > 0) dp(a)(b) += dp(a - 1)(b)\n          if (b > 0) dp(a)(b) += dp(a)(b - 1)\n          dp(a)(b) %= MOD\n//        } else {\n//          debug(s\"restricted $a $b\")\n        }\n      }\n    }\n\n//    debug(\"DP\")\n//    REP(N + 1) { i =>\n//      debug(dp(i))\n//    }\n\n    var ans = 0L\n    REP(2 * N + 1) { a =>\n      val b = 2 * N - a\n      ans = (ans + dp(a)(b)) % MOD\n    }\n    out.println(ans)\n  }\n\n\n  def debug(as: Array[Boolean]): Unit = {\n    System.err.println(as.map(x => if(x) \"1\" else \"0\").mkString)\n  }\n\n  def debug(as: Array[Int]): Unit = {\n    System.err.println(as.mkString(\" \"))\n  }\n\n  def debug(as: Array[Long]): Unit = {\n    System.err.println(as.mkString(\" \"))\n  }\n\n  def debug(s: String): Unit = {\n    System.err.println(s)\n  }\n\n  def debug(num: Long): Unit = {\n    System.err.println(num)\n  }\n\n  class InputReader(val stream: InputStream) {\n    private val reader = new BufferedReader(new InputStreamReader(stream), 32768)\n    private var tokenizer: StringTokenizer = _\n\n    def next(): String = {\n      while (tokenizer == null || !tokenizer.hasMoreTokens)\n        tokenizer = new StringTokenizer(reader.readLine)\n      tokenizer.nextToken\n    }\n\n    def nextInt(): Int = next().toInt\n    def nextLong(): Long = next().toLong\n    def nextChar(): Char = next().charAt(0)\n  }\n  val sc = new InputReader(System.in)\n  def ni(): Int = sc.nextInt()\n  def nl(): Long = sc.nextLong()\n  def nc(): Char = sc.nextChar()\n  def ns(): String = sc.next()\n  def ns(n: Int): Array[Char] = ns().toCharArray\n  def na(n: Int, offset: Int = 0): Array[Int] = map(n)(_ => ni() + offset)\n  def na2(n: Int, offset: Int = 0): (Array[Int], Array[Int]) = {\n    val A1, A2 = Array.ofDim[Int](n)\n    REP(n) { i =>\n      A1(i) = ni() + offset\n      A2(i) = ni() + offset\n    }\n    (A1, A2)\n  }\n  def nm(n: Int, m: Int): Array[Array[Int]] = {\n    val A = Array.ofDim[Int](n, m)\n    REP(n) { i =>\n      REP(m) { j =>\n        A(i)(j) = ni()\n      }\n    }\n    A\n  }\n  def nal(n: Int): Array[Long] = map(n)(_ => nl())\n  def nm_c(n: Int, m: Int): Array[Array[Char]] = map(n) (_ => ns(m))\n  def REP(n: Int, offset: Int = 0)(f: Int => Unit): Unit = {\n    var i = offset\n    val N = n + offset\n    while(i < N) { f(i); i += 1 }\n  }\n  def REP_r(n: Int, offset: Int = 0)(f: Int => Unit): Unit = {\n    var i = n - 1 + offset\n    while(i >= offset) { f(i); i -= 1 }\n  }\n\n  def map[@specialized A: ClassTag](n: Int, offset: Int = 0)(f: Int => A): Array[A] = {\n    val res = Array.ofDim[A](n)\n    REP(n)(i => res(i) = f(i + offset))\n    res\n  }\n\n\n  def sumL(as: Array[Int]): Long = {\n    var s = 0L\n    REP(as.length)(i => s += as(i))\n    s\n  }\n\n  def cumSum(as: Array[Int]) = {\n    val cum = Array.ofDim[Long](as.length + 1)\n    REP(as.length) { i =>\n      cum(i + 1) = cum(i) + as(i)\n    }\n    cum\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  def main(args: Array[String]): Unit = {\n    val s = new Main()\n    s.solve()\n    s.out.flush()\n  }\n}\n\nclass Main {\n  import java.io._\n  import java.util.StringTokenizer\n\n  import scala.collection.mutable\n  import scala.util.Sorting\n  import math.{abs, max, min}\n  import mutable.{ArrayBuffer, ListBuffer}\n  import scala.reflect.ClassTag\n\n  val MOD = 998244353\n  val out = new PrintWriter(System.out)\n\n  def solve(): Unit = {\n    val S = ns()\n    val N = S.length\n    val A = map(N) { i => S(i) - '0' }\n    val B = Array.ofDim[Int](N)\n    REP(N) { i => B(i) = abs(A(i) - 2) }\n\n    val cumA = cumSum(A)\n    val cumB = cumSum(B)\n\n//    debug(A)\n//    debug(B)\n//    debug(cumA)\n//    debug(cumB)\n\n    val dp = Array.ofDim[Long](2 * N + 1, 2 * N + 1)\n    dp(0)(0) = 1\n    REP(2 * N + 1) { a =>\n      REP(2 * N + 1) { b =>\n        val restrict = min(N, a + b)\n        if (cumA(restrict) >= a && cumB(restrict) >= b) {\n          if (a > 0) dp(a)(b) += dp(a - 1)(b)\n          if (b > 0) dp(a)(b) += dp(a)(b - 1)\n          dp(a)(b) %= MOD\n//        } else {\n//          debug(s\"restricted $a $b\")\n        }\n      }\n    }\n\n//    debug(\"DP\")\n//    REP(N + 1) { i =>\n//      debug(dp(i))\n//    }\n\n    var ans = 0L\n    REP(N + 1) { a =>\n      val b = 2 * N - a\n      ans = (ans + dp(a)(b)) % MOD\n    }\n    out.println(ans)\n  }\n\n\n  def debug(as: Array[Boolean]): Unit = {\n    System.err.println(as.map(x => if(x) \"1\" else \"0\").mkString)\n  }\n\n  def debug(as: Array[Int]): Unit = {\n    System.err.println(as.mkString(\" \"))\n  }\n\n  def debug(as: Array[Long]): Unit = {\n    System.err.println(as.mkString(\" \"))\n  }\n\n  def debug(s: String): Unit = {\n    System.err.println(s)\n  }\n\n  def debug(num: Long): Unit = {\n    System.err.println(num)\n  }\n\n  class InputReader(val stream: InputStream) {\n    private val reader = new BufferedReader(new InputStreamReader(stream), 32768)\n    private var tokenizer: StringTokenizer = _\n\n    def next(): String = {\n      while (tokenizer == null || !tokenizer.hasMoreTokens)\n        tokenizer = new StringTokenizer(reader.readLine)\n      tokenizer.nextToken\n    }\n\n    def nextInt(): Int = next().toInt\n    def nextLong(): Long = next().toLong\n    def nextChar(): Char = next().charAt(0)\n  }\n  val sc = new InputReader(System.in)\n  def ni(): Int = sc.nextInt()\n  def nl(): Long = sc.nextLong()\n  def nc(): Char = sc.nextChar()\n  def ns(): String = sc.next()\n  def ns(n: Int): Array[Char] = ns().toCharArray\n  def na(n: Int, offset: Int = 0): Array[Int] = map(n)(_ => ni() + offset)\n  def na2(n: Int, offset: Int = 0): (Array[Int], Array[Int]) = {\n    val A1, A2 = Array.ofDim[Int](n)\n    REP(n) { i =>\n      A1(i) = ni() + offset\n      A2(i) = ni() + offset\n    }\n    (A1, A2)\n  }\n  def nm(n: Int, m: Int): Array[Array[Int]] = {\n    val A = Array.ofDim[Int](n, m)\n    REP(n) { i =>\n      REP(m) { j =>\n        A(i)(j) = ni()\n      }\n    }\n    A\n  }\n  def nal(n: Int): Array[Long] = map(n)(_ => nl())\n  def nm_c(n: Int, m: Int): Array[Array[Char]] = map(n) (_ => ns(m))\n  def REP(n: Int, offset: Int = 0)(f: Int => Unit): Unit = {\n    var i = offset\n    val N = n + offset\n    while(i < N) { f(i); i += 1 }\n  }\n  def REP_r(n: Int, offset: Int = 0)(f: Int => Unit): Unit = {\n    var i = n - 1 + offset\n    while(i >= offset) { f(i); i -= 1 }\n  }\n\n  def map[@specialized A: ClassTag](n: Int, offset: Int = 0)(f: Int => A): Array[A] = {\n    val res = Array.ofDim[A](n)\n    REP(n)(i => res(i) = f(i + offset))\n    res\n  }\n\n\n  def sumL(as: Array[Int]): Long = {\n    var s = 0L\n    REP(as.length)(i => s += as(i))\n    s\n  }\n\n  def cumSum(as: Array[Int]) = {\n    val cum = Array.ofDim[Long](as.length + 1)\n    REP(as.length) { i =>\n      cum(i + 1) = cum(i) + as(i)\n    }\n    cum\n  }\n}\n"
  },
  {
    "language": "Fortran",
    "code": "program pass_\n  implicit none\n  integer(8), parameter :: md = 998244353_8\n  character(2000) :: s\n  integer :: n, m, i, j, a, r(0:2000) = 0, b(0:2000) = 0, x, y\n  integer(8) :: dp(0:4000,0:4000) = 0_8\n  dp(0,0) = 1_8\n  read(*,*) s\n  n = len_trim(s)\n  m = 2*n\n  do i = 1, n\n    a = ichar(s(i:i))-48\n    r(i) = r(i-1)+2-a\n    b(i) = b(i-1)+a\n  end do\n  do i = 1, m\n    x = r(min(i,n))\n    y = b(min(i,n))\n    do j = 0, i\n      if (x < j .or. y < i-j) cycle\n      dp(i,j) = dp(i-1,j)\n      if (j /= 0) dp(i,j) = mod(dp(i,j)+dp(i-1,j-1),md)\n    end do\n  end do\n  write(*,'(i0)') dp(m,r(n))\nend program pass_"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int mod = 998244353;\n\nconst int N = 4004;\nint dp[N][N];\n\nint main(){\n    string s;\n    cin >>s;\n    int n = s.size();\n\n    vector<int> r,b;\n    rep(i,n){\n        if(s[i]=='0') rep(j,2) r.pb(i);\n        else if(s[i]=='1'){\n            r.pb(i);\n            b.pb(i);\n        }\n        else rep(j,2) b.pb(i);\n    }\n\n    int R = r.size(), B = b.size();\n\n    rep(i,R-1) r[i+1] = max(r[i+1], r[i]+1);\n    rep(i,B-1) b[i+1] = max(b[i+1], b[i]+1);\n\n    dp[0][0] = 1;\n    rep(i,2*n)rep(rr,R+1)if(dp[i][rr]>0){\n        int bb = i-rr;\n        if(rr<R && r[rr]<=i) (dp[i+1][rr+1] += dp[i][rr]) %= mod;\n        if(bb<B && b[bb]<=i) (dp[i+1][rr] += dp[i][rr]) %= mod;\n    }\n    cout << dp[2*n][R] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nll n,m,T,k,q;\nconst ll big = 1000000007;\nconst ll bigg = 100000000000007;\nconst ll mod = 998244353;\n\nll A[2001][2] = {0};\n\n\nll has(){\n    ll ans = 0;\n    for(int c1 = 0; c1 < n; c1++){\n        ans *= 7;\n        ans += 3*A[c1][0]+A[c1][1];\n        ans %= bigg;\n    }\n    return ans;\n}\n\nvoid mov(ll i){\n    A[0][i]--;\n    for(int c1 = 1; c1 < n; c1++){\n        if(A[c1][0] == 0 && A[c1][1] == 0)break;\n        if((A[c1-1][0] == 0 && A[c1][0] > 0) || (A[c1][1] == 0)){\n            A[c1-1][0]++;\n            A[c1][0]--;\n        }\n        else{\n            A[c1-1][1]++;\n            A[c1][1]--;\n        }\n    }\n}\n\nunordered_map<ll,ll> M;\nll A2[2001][4002][2] = {0};\nll dep = 0;\n\nll dp(){\n    ll h = has();\n    if(M.find(h) != M.end())return M[h];\n    ll ans = 0;\n\n    if(h == 0)return 1;\n\n    for(int c2 = 0; c2 < 2; c2++){\n\n        if(A[0][c2] > 0){\n            for(int c1 = 0; c1 < n; c1++){\n                A2[c1][dep][0] = A[c1][0];\n                A2[c1][dep][1] = A[c1][1];\n            }\n            dep++;\n            mov(c2);\n            ans += dp();\n            dep--;\n            for(int c1 = 0; c1 < n; c1++){\n                A[c1][0] = A2[c1][dep][0];\n                A[c1][1] = A2[c1][dep][1];\n            }\n        }\n    }\n    ans %= mod;\n    M[h] = ans;\n    return ans;\n}\n\nstring s;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"autput.txt\",\"w\",stdout);\n    ll a,b,c;\n\n    cin >> s;\n    n = s.length();\n    for(int c1 = 0; c1 < n; c1++){\n        if(s[c1] == '0'){\n            A[c1][0] = 2;\n        }\n        if(s[c1] == '1'){\n            A[c1][0] = 1;\n            A[c1][1] = 1;\n        }\n        if(s[c1] == '2'){\n            A[c1][1] = 2;\n        }\n    }\n    ll ans = dp();\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#include <vector>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <deque>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\nconst int MAXN = 2345;\nconst LL MOD = 998244353;\nchar s[MAXN];\nLL dp[2 * MAXN][2 * MAXN];\nbool visit[2 * MAXN][2 * MAXN];\nLL inv[2 * MAXN], fac[2 * MAXN];\n\nLL dfs(int x, int y, int N) {\n   if (x + y == N) {\n      LL tmp = (fac[x + y] * inv[x]) % MOD;\n      return (tmp * inv[y]) % MOD;\n   }\n   int cur = (x + y + 1);\n   if (s[cur] == '0') x += 2;\n   else if (s[cur] == '1') x++, y++;\n   else y += 2;\n   if (visit[x][y]) return dp[x][y];\n   visit[x][y] = 1;\n   LL sum = 0;\n   if (x >= 1) sum = dfs(x - 1, y, N);\n   if (y >= 1) sum = (sum + dfs(x, y - 1, N)) % MOD;\n   return dp[x][y] = sum;\n}\n\n\nvoid init() {\n     inv[0] = fac[1] = inv[1] = 1;\n     for (int i = 2; i < MAXN * 2; i++) {\n         LL tmp = (-(MOD / i) * inv[MOD % i]) % MOD;\n         tmp += (tmp / MOD + 1) * MOD;\n         inv[i] = tmp;\n     }\n     for (int i = 2; i < MAXN * 2; i++) inv[i] = (inv[i - 1] * inv[i]) % MOD;\n     for (int i = 2; i < MAXN * 2; i++) fac[i] = (fac[i - 1] * i) % MOD;\n}\n\nint main() {\n    init();\n    scanf(\"%s\", s + 1);\n    int N = strlen(s + 1);\n    printf(\"%lld\\n\", dfs(0, 0, N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n    // 平方剰余のうち一つを返す なければ-1\n    friend modint sqrt(modint a) {\n        if(a == 0) return 0;\n        ll q = MOD-1, s = 0;\n        while((q&1)==0) q>>=1, s++;\n        modint z=2;\n        while(1) {\n            if(z.pow((MOD-1)/2) == MOD-1) break;\n            z++;\n        }\n        modint c = z.pow(q), r = a.pow((q+1)/2), t = a.pow(q);\n        ll m = s;\n        while(t.x>1) {\n            modint tp=t;\n            ll k=-1;\n            FOR(i, 1, m) {\n                tp *= tp;\n                if(tp == 1) { k=i; break; }\n            }\n            if(k==-1) return -1;\n            modint cp=c;\n            REP(i, m-k-1) cp *= cp;\n            c = cp*cp, t = c*t, r = cp*r, m = k;\n        }\n        return r.x;\n    }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { \n        is >> a.x;\n        a.x = ((a.x%MOD)+MOD)%MOD;\n        return is;\n    }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<998244353>;\n\nint main(void) {\n    string s;\n    cin >> s;\n    const ll n = s.size();\n\n    vector<ll> v(2*n);\n    REP(i, n) {\n        if(s[i] == '0') v[i] = 2;\n        else if(s[i] == '1') v[i] = 1;\n        else if(s[i] == '2') v[i] = 0;\n    }\n    FOR(i, 1, 2*n) v[i] += v[i-1];\n    dump(v);\n\n    vector<vector<mint>> dp(2*n, vector<mint>(2*n+1));\n    if(2-v[0] >= 1) dp[0][0] = 1;\n    if(v[0] >= 1) dp[0][1] = 1;\n    FOR(i, 1, 2*n) REP(j, 2*n+1) {\n        ll rnum = v[i]-(j-1);\n        if(j>0 && rnum > 0) dp[i][j] += dp[i-1][j-1];\n        ll bnum = min(2*n, 2*(i+1))-v[i] - (i-j);\n        if(bnum > 0) dp[i][j] += dp[i-1][j];\n        // dump(i, j, rnum, bnum);\n    }\n    \n    // REP(i, 2*n) dump(dp[i]);\n\n    mint ret = 0;\n    REP(i, 2*n+1) ret += dp[2*n-1][i];\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\ntypedef unsigned int uint;\nusing namespace std;\n\nconst ll mod = 998244353LL;\nll red[4005], blue[4005], dp[4005][4005];\n\nint main() {\n    string s;\n    cin >> s;\n    int len = s.size();\n    for (int i = 0; i < len; i++) {\n        red[i+1] = red[i] + 2 - (s[i] - '0');\n        blue[i+1] = blue[i] + (s[i] - '0');\n    }\n\n    dp[0][0] = 1;\n    for (int i = 1; i <= 2 * len; i++) {\n        dp[i][0] = dp[i-1][0] * (blue[min(len, i)] >= i);\n        for (int j = 1; j <= i; j++) {\n            // 合計i個並べたときに、赤をj個を使っている場合の数\n            dp[i][j] = (dp[i-1][j] * (blue[min(len, i)] >= i-j) + dp[i-1][j-1] * (red[min(len, i)] >= j)) % mod;\n        }\n    }\n\n    ll ans = 0LL;\n    for (int i = 0; i <= 2 * len; i++) {\n        ans = (ans + dp[2 * len][i]) % mod;\n    }\n\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nProblem : https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_f\nAlgorithm : dp\nStatus : AC\n*/\n#include <bits/stdc++.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 2005;\nconst int MOD = 998244353;\n\nint n,pre[MAXN * 2],dp[MAXN * 2][MAXN * 2];\nchar s[MAXN];\n\nint main(){\n    scanf(\"%s\",s + 1);\n\tn = strlen(s + 1);\n    for(int i = 1;i <= n;i++) \n\t    pre[i] = pre[i - 1] + (s[i] - '0');\n    for(int i = n + 1;i <= n * 2;i++)\n\t    pre[i] = pre[i - 1];\n    dp[0][0] = 1;\n    for(int i = 1;i <= n * 2;i++){\n    \tint l = max(pre[i] - i,0);\n    \tint r = min(pre[i],i);\n        for(int j = l;j <= r;j++) {\n            if(j != 0) \n\t\t\t    dp[i][j] = dp[i - 1][j - 1];\n            if(i > j)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n        }\n    }\n    printf(\"%d\\n\",dp[n * 2][pre[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define showoff     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define pb          push_back\n#define pii         pair<long long,long long>\n#define FOR(i,a,b)  for(long long i=a;i<b;++i)\n#define RFOR(i,a,b) for(long long i=a;i>b;--i)\n#define f           first\n#define se          second\n#define maxn        400005\n#define all(v)      v.begin(),v.end()\n#define sz(x)       (long long)x.size()\n#define mod         998244353\n#define pqueue      priority_queue<long long>\n#define pdqueue     priority_queue< long long,vector<long long> ,greater< long long >>\n \ntypedef long long ll;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//const long long md = 998244353;\n \n/*const long long mod = 998244353;\nlong long power(long long a,long long n)\n{\n\tif(n == 1)return a%mod;\n\tif(n == 0)return 1;\n\tif(n&1)return ((a%mod)*(power((a*a)%mod,n/2))%mod)%mod;\n\treturn power((a*a)%mod,n/2)%mod;\n}\n*/\n\n\nint main()\n{\n\tll n, ans = 0;\n\tstring s;\n\tcin >> s;\n\n\tn = s.length()*2;\n\n\tll dpA[4001];\n\tll dpB[4001];\n\tll *dp1;\n\tll *dp2;\n\n\tFOR (i,0,n+1) {\n\t\tdpA[0] = 0;\n\t}\n\tif (s[0] != '2') dpA[1] = 1;\n\tif (s[0] != '0') dpA[0] = 1;\n\tdp2 = dpA;\n\t// cerr << dp2[0] << \" \" << dp2[1] << \" \" << dp2[2] << endl;\n\n\tll r = s[0] == '0' ? 2 : (s[0] == '1' ? 1 : 0);\n\tll w = 2;\n\tFOR (i,1,n) {\n\t\tif (i % 2 > 0) {\n\t\t\tdp1 = dpA;\n\t\t\tdp2 = dpB;\n\t\t} else {\n\t\t\tdp1 = dpB;\n\t\t\tdp2 = dpA;\n\t\t}\n\t\tif (i < s.length()) {\n\t\t\tw += 2;\n\t\t\tr += s[i] == '0' ? 2 : (s[i] == '1' ? 1 : 0);\n\t\t}\n\n\t\tif ((w - r) > i) dp2[0] = dp1[0];\n\t\telse dp2[0] = 0;\n\n\t\t// cerr << dp2[0] << \" \";\n\t\tFOR (j,1,n+1) {\n\t\t\tif (r >= j)\n\t\t\t\tdp2[j] = dp1[j-1];\n\t\t\telse\n\t\t\t\tdp2[j] = 0;\n\t\t\tif ((w - r) > (i - j)) {\n\t\t\t\tdp2[j] += dp1[j];\n\t\t\t\tif (dp2[j] > mod)\n\t\t\t\t\tdp2[j] -= mod;\n\t\t\t}\n\t\t\t// cerr << dp2[j] << \" \";\n\t\t}\n\t\t// cerr << endl;\n\t}\n\n\tcout << dp2[r] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 3005\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,k,a[MAXN],fact[2*MAXN],invf[2*MAXN];\nchar str[MAXN+1];\nint dp[MAXN][MAXN],cnt1[MAXN],cnt2[MAXN];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nint pow_mod(int a,int i)\n{\n    int s=1;\n    while(i)\n    {\n        if(i&1) s=1LL*s*a%MOD;\n        a=1LL*a*a%MOD;\n        i>>=1;\n    }\n    return s;\n}\nint comb(int n,int k)\n{\n    if(n<k) return 0;\n    return 1LL*fact[n]*invf[k]%MOD*invf[n-k]%MOD;\n}\nint main()\n{\n    fact[0]=invf[0]=1;\n    for(int i=1;i<=5000;i++) fact[i]=1LL*fact[i-1]*i%MOD;\n    invf[5000]=pow_mod(fact[5000],MOD-2);\n    for(int i=4999;i>=1;i--) invf[i]=1LL*invf[i+1]*(i+1)%MOD;\n    scanf(\"%s\",str+1);\n    n=strlen(str+1);\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        cnt1[i]=cnt1[i-1];cnt2[i]=cnt2[i-1];\n        if(str[i]=='0') cnt1[i]+=2;\n        else if(str[i]=='2') cnt2[i]+=2;\n        else\n        {\n            cnt1[i]++;cnt2[i]++;\n        }   \n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            if(!dp[i][j]) continue;\n            if(j<cnt1[i+1]) add(dp[i+1][j+1],dp[i][j]);\n            if(i-j<cnt2[i+1]) add(dp[i+1][j],dp[i][j]);\n        }\n    }\n    int ans=0;\n    for(int i=0;i<=n;i++) add(ans,1LL*dp[n][i]*comb(n,cnt1[n]-i)%MOD);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\nll dp[4001][4001];\n\nint main() {\n\tstring s; reader(s);\n\tint n = sz(s);\n\n\tconst int MOD = 998244353;\n\n\tdp[0][0] = 1;\n\tint blues = 0;\n\tFOR(i, 2 * n) {\n\t\tif (i < n) blues += s[i] - '0';\n\t\tint reds = 2 * i + 2 - blues;\n\t\tFOR(j, 2 * n + 1) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tint remB = blues - j;\n\t\t\tint remR = reds - (i - j);\n\n\t\t\tFOR(_, 2) {\n\t\t\t\tif (_ == 0 && remR <= 0) continue;\n\t\t\t\tif (_ == 1 && remB <= 0) continue;\n\n\t\t\t\tint nj = j + _;\n\t\t\t\t(dp[i + 1][nj] += dp[i][j]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = dp[2 * n][blues];\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n     \nconst int maxn(4005);\nconst int mod(998244353);\n\ninline void Inc(int &x, int y) {\n    x = x + y >= mod ? x + y - mod : x + y;\n}\n\ninline void Dec(int &x, int y) {\n    x = x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Add(int x, int y) {\n    return x + y >= mod ? x + y - mod : x + y;\n}\n\ninline int Sub(int x, int y) {\n    return x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Pow(ll x, int y) {\n    ll ret = 1;\n    for (; y; y >>= 1, x = x * x % mod)\n        if (y & 1) ret = ret * x % mod;\n    return ret;\n}\n\nint n, cntb, cntr, fac[100000], inv[100000], ans, f[maxn][maxn];\nchar s[maxn];\n\ninline int C(int x, int y) {\n\tif (x < 0 || y < 0 || y > x) return 0;\n\treturn (ll)fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main() {\n\tint i, j, k, cb, cr, mx = 99999, lsr, lsb;\n\tinv[0] = inv[1] = 1;\n    for (i = 2; i <= mx; ++i) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;\n    for (i = 2; i <= mx; ++i) inv[i] = (ll)inv[i - 1] * inv[i] % mod;\n    for (i = fac[0] = 1; i <= mx; ++i) fac[i] = (ll)fac[i - 1] * i % mod;\n\tscanf(\" %s\", s + 1), n = strlen(s + 1);\n\tfor (i = 1; i <= n; ++i)\n\t\tif (s[i] == '0') cntr += 2;\n\t\telse if (s[i] == '1') ++cntr, ++cntb;\n\t\telse cntb += 2;\n\tf[0][0] = 1, cb = cr = lsr = lsb = 0;\n\tfor (i = 1; i <= n; ++i) {\n\t\tif (s[i] == '0') cr += 2;\n\t\telse if (s[i] == '1') ++cr, ++cb;\n\t\telse cb += 2;\n\t\tfor (j = 1; j <= cr; ++j) Inc(f[i][j], f[i - 1][j - 1]), Inc(f[i][j], f[i - 1][j]);\n\t}\n\tfor (j = 0; j <= min(cr, n); ++j) Inc(ans, (ll)f[n][j] * C(n, cr - j) % mod);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef long double ld;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nint main() {\n  //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  string s;\n  cin >> s;\n  int n = s.size();\n  vi sum(n + 1);\n  for (int i = 0; i < n; ++i) {\n    sum[i + 1] = sum[i] + s[i] - '0';\n  }\n  vi d(2 * n + 1);\n  d[0] = 1;\n  for (int t = 0; t < 2 * n; ++t) {\n    int i = min(t, n - 1);\n    vi nd(d.size());\n    for (int j = 0; j < d.size(); ++j) {\n      if (j < sum[i + 1]) {\n        nd[j + 1] = (nd[j + 1] + d[j]) % mod;\n      }\n      if (t - j < 2 * (i + 1) - sum[i + 1]) {\n        nd[j] = (nd[j] + d[j]) % mod;\n      }\n    }\n    d.swap(nd);\n//    cerr << t << endl;\n//    for (int i = 0; i < d.size(); ++i) if (d[i]) cerr << i << ' ' << d[i] << endl;\n  }\n  ll res = 0;\n  for (int x : d) res += x;\n  cout << res % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\n//ll MOD = 1000000007;\nll MOD = 998244353;\n//vector<mint> dp(N, Mint);\n//vector<vector<mint>> dp2(N, vector<mint>(N, Mint));\n//vector<vector<vector<mint>>> dp3(N, vector<vector<mint>>(N, vector<mint>(N, Mint)));\nstruct mint{\n  ll x;\n  mint(ll x=0):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i);\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n//第二種スターリング数\nconst ll MAXStir2 = 3010;\nvector<vector<mint>> Stir2memo(MAXStir2, vector<mint>(MAXStir2, Mint));\nvector<mint> Bellmemo(MAXStir2, Mint);\nvoid Stir2init(){\n  Stir2memo[0][0] = 1;\n  rep(i, MAXStir2-1)rep(j, i+1)Stir2memo[i+1][j+1] = Stir2memo[i][j] + Stir2memo[i][j+1] * (j+1);\n  rep(i, MAXStir2){\n    Bellmemo[i] = 0;\n    rep(j,i+1) Bellmemo[i] += Stir2memo[i][j];\n  }\n}\nmint Stir2(ll i, ll j){//区別できるi個をjグループに分ける場合の数\n  if(i < 0 || j < 0 || i < j) return 0;\n  return Stir2memo[i][j];\n}\nmint Bell(ll x){//区別できるx個をグループ分けする方法全ての場合の数\n  if(x < 0) return 0;\n  return Bellmemo[x];\n}\nmint kai_mod(ll K){\n  if(K < 0) return 0;\n  if(K == 0) return 1;\n  return kai_mod(K-1) * K;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\n\n//Range Sum Query\nconst ll N_ = (1 << 18);\nll seg[2*N_-1];\n//未確認\nvoid add(ll k, ll x){\n  k += N_-1;\n  seg[k] += x;\n  while(k > 0){\n    k = (k-1)/2;\n    seg[k] = seg[2*k+1] + seg[2*k+2];\n  }\n}\n\nll get_sum(ll x, ll y, ll k = 0, ll left = 0, ll right = N_){\n  if(right <= x || y <= left) return 0;\n  if(x <= left && right <= y) return seg[k];\n  ll mid = (left + right) / 2;\n  ll l = get_sum(x, y, 2*k+1, left, mid);\n  ll r = get_sum(x, y, 2*k+2, mid, right);\n  return l + r;\n}\n\nmint dp[2010][2010];\nll N;\nll B;\nvoid solve(){\n  dp[0][0] = 1;//i番目まで見て、青をj個使った\n  for(ll i = 0; i < 2*N; i++){\n    ll can_use_blue = get_sum(0, i+1);\n    ll can_use_red = 2 * (i+1) - can_use_blue;\n    for(ll j = 0; j <= B; j++){\n      if(can_use_blue >= j+1){\n        dp[i+1][j+1] += dp[i][j];\n      }\n      if(can_use_red >= i+1-j ){\n        dp[i+1][j] += dp[i][j];\n      }\n    }\n  }\n  \n  dp[2*N][B].get();\n}\n\nint main(){\n  string S;\n  cin >> S;\n  N = S.size();\n  rep(i, N){\n    if(S[i] == '2') add(i, 2);\n    if(S[i] == '1') add(i, 1);\n  }\n  B = get_sum(0, N_);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (b == 0) return 1; else if (b % 2 == 0) return (pow(a * a, b / 2, m) % m); else return (pow(a * a, b / 2) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\nconst ll MAX_N = 2000;\nstring S;\nbool grid[MAX_N * 2 + 1][MAX_N * 2 + 1];\nll ans[MAX_N * 2 + 1][MAX_N * 2 + 1] = {};\nint main(){\n   cin >> S;\n   ll n = S.size();\n   REP(i, 2 * n + 1) REP(j, 2 * n + 1) grid[i][j] = true;\n   ll red = 0, blue = 0;\n   REP(i, n){\n      if(S[i] == '0') red += 2;\n      if(S[i] == '2') blue += 2;\n      if(S[i] == '1'){red++; blue++;}\n      REP(j, i + 2){\n         if(j > red || (i + 1 - j) > blue) grid[j][i + 1 - j] = false;\n      }\n   }\n   ans[0][0] = 1;\n   REP(i, red + 1){\n      REP(j, blue + 1){\n         if(i > 0 && grid[i - 1][j]) ans[i][j] += ans[i-1][j];\n         if(j > 0 && grid[i][j - 1]) ans[i][j] += ans[i][j-1];\n         ans[i][j] %= MOD;\n      }\n   }\n/*\n   REP(i, red + 1){\n      REP(j, blue + 1){\n         printf(\"ans[%lld][%lld] = %lld \", i, j, ans[i][j]);\n      }\n      cout << endl;\n   }\n*/\n   cout << ans[red][blue] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <cstdio>\n    #include <cstring>\n    #include <iostream>\n    #define MN 4010\n    #define mod 998244353\n     \n    int f[MN][MN];\n    int r[MN], b[MN];\n    char s[MN];\n     \n    int main()\n    {\n    \tscanf(\"%s\", s + 1);\n    \tint n = strlen(s + 1); \n    \tfor(int i = 1; i <= n; i++)\n    \t{\n    \t\tint x = s[i] - '0';\n    \t\tr[i] = r[i - 1]; b[i] = b[i - 1];\n    \t\tif(x == 0) r[i] += 2;\n    \t\tif(x == 1) r[i]++, b[i]++;\n    \t\tif(x == 2) b[i] += 2;\n    \t}\n    \tfor(int i = n + 1; i <= 2 * n; i++) r[i] = r[i - 1], b[i] = b[i - 1];\n    \tf[0][0] = 1;\n    \tfor(int i = 1; i <= 2 * n; i++)\n    \t{\n    \t\tfor(int j = 0; j <= i; j++)\n    \t\t{\n    \t\t\tint k = i - j;\n    \t\t\tif(j > r[i] || k > b[i]) continue;\n    \t\t\tif(j) f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mod;\n    \t\t\tif(k) f[i][j] = (f[i][j] + f[i - 1][j]) % mod;\n    \t\t}\n    \t}\n    \tprintf(\"%d\\n\", f[2 * n][r[n]]);\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int mod=998244353;\n\nlong C[2001][2001];\n\nlong comb(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=mod;\n\t\t}\n\t\tC[i][i]=1;\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n=s.length();\n\tint red[n]={};\n\tred[0]=(s[0]=='0'?2:s[0]=='1'?1:0);\n\tfor(int i=1;i<n;i++) red[i]+=red[i-1]+(s[i]=='0'?2:s[i]=='1'?1:0);\n\t\n\tlong dp[n+1][2*n+1]={};\n\tdp[1][0]=(s[0]!='0'?1:0);\n\tdp[1][1]=(s[0]!='2'?1:0);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=max(0,red[i-1]-i);j<=min(i,red[i-1]);j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(j!=0?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcomb(n);\n\tlong ans=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(i<=red[n-1]) ans+=dp[n][i]*C[n][red[n-1]-i]%mod;\n\t\tans%=mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(4001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(2 * N + 1));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - b;\n                }\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    (dp[i + 1][j] += dp[i][j]) %= MOD;\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i];\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = (left * right) % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//const ull mod = 1e9 + 7;\nconst ll mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n// conversion number to bit\nstring num2bit(ll num, ll len){\n  string bit = \"\";\n  REP(i, len){\n    bit += char('0'+(num>>i & 1));\n  }\n  return bit;\n}\n\nll dp[2020][2020];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string S;\n    cin >> S;\n    ll N = S.size();\n\n    dp[0][0] = 1;\n\n    ll R=0, B=0;\n    REP(i, 2*N){\n    \tif(i<N){\n    \t\tif(S[i] == '0') R += 2;\n    \t\telse if(S[i] == '2') B += 2;\n    \t\telse R++, B++;\n    \t}\n\n    \tREP(j, i+1){\n    \t\tll idx = j;\n    \t\tll jdx = i-j;\n    \t\tif(idx<R) dp[idx+1][jdx] += dp[idx][jdx]; \n    \t\tdp[idx+1][jdx] %= mod;\n    \t\tif(jdx<B) dp[idx][jdx+1] += dp[idx][jdx]; \n    \t\tdp[idx][jdx+1] %= mod;\t\n    \t}\n    }\n\n    ll res = 0;\n    REP(i, 2*N+1){\n    \tres += dp[i][2*N-i];\n    \tres %= mod;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\nusing namespace std;\n\nconst int N=4100,mod=998244353;\nint n,r,b,f[N][N]; char s[N];\n\nvoid upd(int &x,int y){x+=y; x-=x>=mod?mod:0;}\n\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tf[0][0]=1;\n\trep (i,1,2*n){\n\t\tif (s[i]=='0') r+=2; else\n\t\tif (s[i]=='1') r++,b++; else\n\t\tif (s[i]=='2') b+=2;\n\t\trep (j,0,i){\n\t\t\tint k=i-j;\n\t\t\tif (r>=j) upd(f[i][j],f[i-1][j-1]);\n\t\t\tif (b>=k) upd(f[i][j],f[i-1][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[2*n][r]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 40005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nchar s[2005];\nint sum[2005][2],N;\nint dp[4005][4005];\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n\tx = inc(x,y);\n}\nvoid Solve() {\n\tscanf(\"%s\",s + 1);\n\tN = strlen(s + 1);\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tsum[i][0] = sum[i - 1][0];\n\t\tsum[i][1] = sum[i - 1][1];\n\t\tif(s[i] == '0') sum[i][0] += 2;\n\t\tif(s[i] == '1') {sum[i][0]++;sum[i][1]++;}\n\t\tif(s[i] == '2') sum[i][1] += 2;\n\t}\n\tdp[0][0] = 1;\n\tfor(int i = 1 ; i <= 2 * N ; ++i) {\n\t\tint t = min(i,N);\n\t\tfor(int j = 0 ; j <= i ; ++j) {\n\t\t\tint a = j,b = i - j;\n\t\t\tif(a <= sum[t][0] && b <= sum[t][1]) {\n\t\t\t\tif(a) update(dp[a][b],dp[a - 1][b]);\n\t\t\t\tif(b) update(dp[a][b],dp[a][b - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tout(dp[sum[N][0]][sum[N][1]]);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e3+5,mod=998244353;\nint n,f[N][N],a[N],b[N];\nchar str[N];\nint main()\n{\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);\n\tfor(int i=1;i<=n;i++)a[i]=a[i-1]+str[i]-'0',b[i]=b[i-1]+'2'-str[i];\n\tf[0][0]=1;\n\tfor(int i=0;i<=a[n];i++)\n\tfor(int j=0,k;j<=b[n];j++)\n\tif(i||j)\n\t{\n\t\tk=min(n,i+j);\n\t\tif(i<=a[k]&&j<=b[k])f[i][j]=((i?f[i-1][j]:0)+(j?f[i][j-1]:0))%mod;\n\t}\n\tprintf(\"%d\\n\",f[a[n]][b[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int mod=998244353;\n\nlong C[2001][2001];\n\nlong comb(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=mod;\n\t\t}\n\t\tC[i][i]=1;\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n=s.length();\n\tint red[n]={};\n\tred[0]=(s[0]=='0'?2:s[0]=='1'?1:0);\n\tfor(int i=1;i<n;i++) red[i]+=red[i-1]+(s[i]=='0'?2:s[i]=='1'?1:0);\n\t\n\tlong dp[n+1][2*n+1]={};\n\tdp[1][0]=(s[0]!='0'?1:0);\n\tdp[1][1]=(s[0]!='2'?1:0);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=max(0,red[i-1]-i);j<=min(i,red[i-1]);j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(j!=0?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcomb(n);\n\tlong ans=0;\n\tfor(int i=max(0,red[n-1]-n);i<=min(n,red[n-1]);i++){\n\t\tans+=dp[n][i]*C[n][red[n-1]-i]%mod;\n\t\tans%=mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 4010, Mod = 998244353;\n\nint f[N][N], sum[N];\n\nchar str[N];\n\nint main () {\n\n\tFile();\n\n\tscanf (\"%s\", str + 1);\n\n\tint n = strlen(str + 1);\n\n\tFor (i, 1, n) sum[i] = sum[i - 1] + (str[i] - '0');\n\tFor (i, n + 1, 2 * n) sum[i] = sum[i - 1];\n\n\tf[0][0] = 1;\n\tFor (i, 1, 2 * n) {\n\t\tFor (j, 0, i) {\n\t\t\tint k = i - j;\n\t\t\tif (j <= sum[i] && k <= 2 * i - sum[i]) {\n\t\t\t\tif (j) f[i][j] = f[i - 1][j - 1];\n\t\t\t\t(f[i][j] += f[i - 1][j]) %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%d\\n\", f[2 * n][sum[n]]);\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\n\nconst int MOD = 998244353;\n\nint main() {\n    string s; cin >> s;\n    int N = s.length();\n    int M = 0;\n    vector<int> dp(N * 2 + 1);\n    dp[0] = 1;\n    rep(t, N * 2) {\n        if (t < N) {\n            vector<int> _dp(N * 2 + 1);\n            int db = s[t] - '0';\n            rep(b, N * 2 + 1) if (dp[b])\n                _dp[b + db] = dp[b];\n            dp = _dp;\n            M += 2;\n        }\n        {\n            vector<int> _dp(N * 2 + 1);\n            rep(b, N * 2 + 1) if (dp[b]) {\n                int r = M - b;\n                if (r) _dp[b] = (_dp[b] + dp[b]) % MOD;\n                if (b) _dp[b - 1] = (_dp[b - 1] + dp[b]) % MOD;\n            }\n            dp = _dp;\n            M--;\n        }\n    }\n    cout << dp[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nstring s;\nll dp[4010][4010];\nint d[2010][2];\n\nvoid solve(){\n    cin >> s;\n    n=s.length();\n    d[0][0]=0;\n    d[0][1]=0;\n    rep(i,2*n+1){\n        rep(j,2*n+1) dp[i][j]=0;\n    }\n    rep(i,n) {\n        d[i+1][0]=d[i][0]+2-(s[i]-'0');\n        d[i+1][1]=d[i][1]+(s[i]-'0');\n    }\n    Rep(i,n,2*n) {\n        d[i+1][0]=d[i][0];\n        d[i+1][1]=d[i][1];\n    }\n    rep(i,2*n){\n        //cout << d[i][0] << \" \" << d[i][1] << endl;\n    }\n    dp[0][0]=1;\n    rep(i,2*n){\n        rep(j,2*n){\n            if (d[i+1][0]>j){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }\n            if (d[i+1][1]>i-j){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=mod;\n            }\n            //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n\n    ll ans=0;\n    rep(i,2*n+1){\n        ans+=dp[2*n][i];\n        ans%=mod;\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 998244353;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\nmint dp[4010][4010][2];\n\ninline int rest_ball(int i,int n){\n\tconst int total = 2 * min(i,n) - i;\n\treturn total;\n}\n\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\n\tif(s == string(n,'2')){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tdp[0][0][0] = ONE;\n\n\trep(i,2*n)rep(j,2*n+1)rep(k,2){\n\t\tif(dp[i][j][k] == ZERO) continue;\n\t\tconst int all = rest_ball(i, n);\n\t\tint nr = j, nb = all - j;\n\n\t\tif(i < n){\n\t\t\tconst int idx = s[i] - '0';\n\t\t\tnr += 2 - idx;\n\t\t\tnb += idx;\n\t\t}\n\n\t\t// red\n\t\tif(nr > 0){\n\t\t\tint nk = k;\n\t\t\tif(nr - 1 == 0) nk = 1;\n\t\t\tdp[i+1][nr-1][nk] += dp[i][j][k];\n\t\t}\n\n\t\t// blue\n\t\tif(nb > 0){\n\t\t\tint nk = k;\n\t\t\tdp[i+1][nr][nk] += dp[i][j][k];\n\t\t}\n\t}\n\n\tmint ans = dp[2 * n][0][1];\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nstring s;\nllint sumR[2005], sumB[2005];\nllint dp[4005][2005];\n\nint main(void)\n{\n\tcin >> s;\n\tint n = s.size();\n\ts = \"#\" + s;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tsumR[i] = sumR[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tif(s[i] == '0') sumR[i] += 2;\n\t\tif(s[i] == '1') sumR[i]++, sumB[i]++;\n\t\tif(s[i] == '2') sumB[i] += 2;\n\t}\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tfor(int j = 0; j <= 2*n; j++){\n\t\t\tdp[i][j] += dp[i-1][j], dp[i][j] %= mod;\n\t\t\tif(j > 0) dp[i][j] += dp[i-1][j-1], dp[i][j] %= mod;\n\t\t\tif(i <= n && (j > sumR[i] || i-j > sumB[i])) dp[i][j] = 0;\n\t\t}\n\t}\n\tcout << dp[2*n][sumR[n]] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include<algorithm>\n#include<cmath>\n#include<fstream>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<random>\n#include<set>\n#include<sstream>\n#include<sys/time.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\nusing ll = long long;\nint M = 998244353;\n// enum : int { M = (int)1e9 + 7 };\n// enum : ll { MLL = (ll)1e18L + 9 };\nusing namespace std;\n#ifdef LOCAL\n#include\"rprint2.hpp\"\n#else\n#define FUNC(name) template <ostream& out = cout, class... T> void name(T&&...){ }\nFUNC(prints) FUNC(printw) FUNC(printwe) FUNC(printb) FUNC(printbe) FUNC(printd) FUNC(printde) FUNC(printdu);\n#endif\ntemplate <class S, class T>\nistream& operator >> (istream& in, pair<S, T>& p){ return in >> p.first >> p.second; }\ntemplate <class T>\nistream& operator >> (istream& in, vector<T>& v){ for(auto& e : v){ in >> e; } return in; }\n//}}}\n\nll modPow(ll base, ll ex, ll m) {\n\tll ret = 1;\n\twhile(ex){\n\t\tif(ex & 1){\n\t\t\tret = ret * base % m;\n\t\t}\n\t\tex >>= 1;\n\t\tbase = base * base % m;\n\t}\n\treturn ret;\n}\nvector<ll> mFacts, mInvFacts;\nll modFact(int n){ return mFacts[n]; }\nll modInvFact(int n){ return mInvFacts[n]; }\nll modInv(int n, ll m){ return modPow(n, m - 2, m); }\nll modC(int n, int k, ll m){ return modFact(n) * modInvFact(k) % m * modInvFact(n - k) % m; }\nvoid init(int n, ll m){\n    mFacts.resize(n + 1);\n    mInvFacts.resize(n + 1);\n    mFacts[0] = 1;\n    for(int i = 1; i <= n; i++){\n        mFacts[i] = mFacts[i - 1] * i % m;\n    }\n    mInvFacts[n] = modInv(mFacts[n], m);\n    for(int i = n - 1; i >= 0; i--){\n        mInvFacts[i] = mInvFacts[i + 1] * (i + 1) % m;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init(1e6, M);\n    string s; cin >> s;\n    int n = s.size();\n    // blue\n    vector<vector<ll>> dp(n + 1, vector<ll>(2 * n + 10));\n    dp[0][0] = 1;\n    for(int i = 1; i <= n; i++){\n        char c = s[i - 1];\n        auto blue = [&](int i, int j){ return j; };\n        auto red =  [&](int i, int j){ return j != i * 2; };\n        for(int j = 0; j < i; j++){\n            printde(i, j, c, (blue(i - 1, j) && c == '0'), (red(i - 1, j) && c == '2'));\n            if(c == '1' || (blue(i - 1, j) && c == '0') || (red(i - 1, j) && c == '2')){\n                dp[i][j - 1 + (c - '0')] += dp[i - 1][j];\n                dp[i][j - 1 + (c - '0')] %= M;\n                dp[i][j + (c - '0')] += dp[i - 1][j];\n                dp[i][j + (c - '0')] %= M;\n            }else if(c == '0'){\n                dp[i][j + (c - '0')] += dp[i - 1][j];\n                dp[i][j + (c - '0')] %= M;\n            }else{\n                dp[i][j - 1 + (c - '0')] += dp[i - 1][j];\n                dp[i][j - 1 + (c - '0')] %= M;\n            }\n        }\n    }\n    printde(dp);\n    ll ans = 0;\n    for(int i = 0; i <= n; i++){\n        ans += dp[n][i] * modC(n, i, M);\n        ans %= M;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\nstring s;\nll dp[2005][2005];\nint rui[2005];\nll C[2005][2005];\nint main(){\n\trep(i,2003) rep(j,i+1) if(j==0||j==i)C[i][j]=1;else C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\tcin>>s;\n\tint n = s.size();\n\trep(i,n){\n\t\trui[i+1] = rui[i] + s[i]-'0';\n\t}\n\tdp[0][0] = 1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(dp[j][i-j] == 0) continue;\n\t\t\tint cur = i;\n\t\t\tint one = rui[cur+1]-j;\n\t\t\tint zero = 2*(cur+1)-rui[cur+1]-(i-j);\n\t\t\tif(one){\n\t\t\t\tdp[j+1][i-j] += dp[j][i-j];\n\t\t\t\tif(dp[j+1][i-j] >= mod) dp[j+1][i-j] -= mod;\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tdp[j][i-j+1] += dp[j][i-j];\n\t\t\t\tif(dp[j][i-j+1] >= mod) dp[j][i-j+1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(dp[i][n-i]==0) continue;\n\t\tint one = rui[n]-i;\n\t\tans += dp[i][n-i] * C[n][one] % mod;\n\t}\n\tcout << (ans%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n  return res;\n}\n\nstruct Factorial{\n  int n;\n  const int MOD = mod;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nll dp[2001][2001];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  string s;\n  cin >> s;\n  int n = sz(s);\n  vector<int> rc(n, 0), bc(n, 0);\n  Factorial fac(5001);\n  rep(i, n){\n    if(s[i] == '0')rc[i] += 2;\n    else if(s[i] == '1')rc[i]++, bc[i]++;\n    else bc[i] += 2;\n    if(i > 0){\n      rc[i] += rc[i-1];\n      bc[i] += bc[i-1];\n    }\n  }\n  dp[0][0] = 1;\n  rep(i, n){\n    rep(j, min(rc[i], i+1)+1){\n      if(i+1-j > bc[i])continue;\n      dp[i+1][j] = (dp[i][j] + (j > 0 ? dp[i][j-1]: 0)) % mod;\n    }\n  }\n  ll res = 0;\n  rep(i, n + 1){\n    if(rc[n-1]-i<0)break;\n    ll tmp = dp[n][i];\n    tmp = tmp * fac.comb(n, rc[n-1] - i) % mod;\n    res = (res + tmp) % mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 4040, mod = 998244353;\n\nint dp[N][N], C[N][N];\nchar s[N];\n\nvoid add(int & var, int x) {\n  var += x;\n  if (var >= mod)\n    var -= mod;\n}\n\nint main() {\n  for (int i = 0; i < N; ++i) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; ++j)\n      C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;\n  }\n  dp[0][0] = 1;\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  for (int i = 0; i < n; ++i)\n    s[i] -= '0';\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= i; ++j) {\n      if (dp[i][j] == 0) continue;\n      int b = j + s[i], r = 2 * i - j + (2 - s[i]);\n      if (b)\n        add(dp[i+1][b-1], dp[i][j]);\n      if (r)\n        add(dp[i+1][b], dp[i][j]); \n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans = (ans + 1LL * C[n][i] * dp[n][i]) % mod;\n  }\n  if (ans < 0) ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<int mod=998244353>\nclass ModInt {\n  int x;\npublic:\n  ModInt() : x(0) {}\n  ModInt(const ModInt &y): x(y.x) {}\n  ModInt(int64_t y){ x = y % mod; if(x < 0) x += mod; }\n  ModInt &operator += (const ModInt &p){ x += p.x; if(x >= mod) x -= mod; return *this; }\n  ModInt &operator -= (const ModInt &p){ x -= p.x; if(x < 0) x += mod; return *this; }\n  ModInt &operator *= (const ModInt &p){ x = (int) (1LL * x * p.x % mod); return *this; }\n  ModInt &operator /= (const ModInt &p){ *this *= p.inverse(); return *this; }\n  ModInt operator -() const { return ModInt(-x); }\n  ModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n  ModInt operator ^ (const int64_t y) const { return pow(y); }\n  bool operator == (const ModInt &p) const { return x == p.x; }\n  bool operator != (const ModInt &p) const { return x != p.x; }\n  ModInt operator = (const int64_t y) { return *this = ModInt(y); }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0){\n      t = a/b; a -= t*b; swap(a, b);\n      u -= t*v; swap(u, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t y) const {\n    if(x==0) return ModInt(0);\n    int64_t r = 1, t = x;\n    while(y > 0){\n      if(y&1) r = r*t%mod;\n      t = t*t%mod; y >>= 1;\n    }\n    return ModInt(r);\n  }\n  friend ostream &operator << (ostream &os, const ModInt<mod> &p) { return os<<p.x; }\n  friend istream &operator >> (istream &is, ModInt<mod> &a) { int64_t x; is>>x; a = ModInt<mod>(x); return is; }\n};\nusing Int = ModInt<>;\n\n\nint main(){\n  string s;\n  cin>>s;\n  int n = s.size();\n\n  vector<int> red,blue;\n  red.push_back(-1);\n  blue.push_back(-1);\n  rep(i,n){\n    if(s[i]=='0'){red.push_back(i); red.push_back(i);}\n    else if(s[i]=='1'){red.push_back(i); blue.push_back(i);}\n    else {blue.push_back(i); blue.push_back(i);}\n  }\n\n  vector<vector<Int>> dp(2*n+1, vector<Int>(red.size(), 0));\n  // [result-length][num of red]\n  dp[0][0] = 1;\n\n  rep(i,2*n) rep(j,red.size()+1) if(j<=i){\n    int ir = j;\n    int ib = i-j;\n    if(ib+1 < blue.size() && blue[ib+1] <= i) dp[i+1][j] += dp[i][j];\n    if(ir+1 < red.size() && red[ir+1] <= i) dp[i+1][j+1] += dp[i][j];\n  }\n\n  cout << dp[2*n][red.size()-1] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 4010;\nconst long long mod = 998244353;\nlong long dp[maxn][maxn];\nint n;\nint v[maxn] = {0};\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tstring s;\n\tint cnt = 0;\n\tcin >> s;\n\tn = s.size();\n\tfor(int i = 0; i < s.size(); i ++)\n\t\tv[i] = s[i] - '0';\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < 2 * n; i ++)\n\t{\n\t\tif(i < n)\n\t\t\tcnt ++;\n\t\telse\n\t\t\tcnt --;\n\t\tfor(int j = 0; j <= 2 * n; j ++)\n\t\t{\n\t\t\tif(cnt - j - v[i] >= 0)\n\t\t\t(dp[i + 1][j + v[i]] += dp[i][j]) %= mod;\n\t\t\tif(j + v[i] - 1 >= 0)\n\t\t\t\t(dp[i + 1][j + v[i] - 1] += dp[i][j]) %= mod;\n\t\t}\n\t}\n\tcout << dp[2 * n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Pct puts(\"------ Yes ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\n#define fir first\n#define sec second\n#define ls son[u][0]\n#define rs son[u][1]\n#define eps 1e-8\n#define PI acos(-1.0)\nusing namespace std;\ntemplate <class T> void rd(T &x){ x = 0; int f = 1; char ch = getchar(); while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); } while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar(); x *= f; }\n\ntypedef long long ll;\nconst int N = 4e3 + 5;\nconst int mod = 998244353;\nint n;\nll f[N][N], fac[N], fin[N];\nchar s[N];\n\nvoid add(ll &a, ll b){ a = (a + b) % mod; }\n\nll Inv(ll x){ return x <= 1 ? 1 : Inv(mod % x) * (mod - mod / x) % mod; }\n\nll C(ll n, ll m){ return fac[n] * fin[m] % mod * fin[n - m] % mod; }\n\nint main(){\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\n\tfac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;\n\tfin[n] = Inv(fac[n]);\n\tper(i, n, 1) fin[i - 1] = fin[i] * i % mod;\n\t\n\tf[0][0] = 1;\n\trep(i, 1, n){\n\t\trep(j, 0, i - 1){\n\t\t\tint r = j, b = i - 1 - j;\n\t\t\tif(s[i] == '0'){\n\t\t\t\tadd(f[i][r + 1], f[i - 1][r]);\n\t\t\t\tif(b) add(f[i][r + 2], f[i - 1][r]);\n\t\t\t}\n\t\t\telse if(s[i] == '1'){\n\t\t\t\tadd(f[i][r], f[i - 1][r]);\n\t\t\t\tadd(f[i][r + 1], f[i - 1][r]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(r) add(f[i][r - 1], f[i - 1][r]);\n\t\t\t\tadd(f[i][r], f[i - 1][r]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll ans = 0;\n\trep(i, 0, n) add(ans, C(n, i) * f[n][i] % mod);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define repi(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repdi(i,a,b) for(ll i=(a)-1;i>=(b);--i)\n#define repd(i,a) repdi(i,a,0)\n#define itr(it,a) for( auto it = (a).begin(); it != (a).end(); ++it )\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define endl '\\n'\n#define debug(x)  std::cerr << #x << \" = \" << (x) << endl;\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\nconstexpr ll INF = 1ll<<60;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class S, class T>\nstd::ostream& operator<< ( std::ostream& out, const std::pair<S,T>& a )\n{ std::cout << '(' << a.first << \", \" << a.second << ')'; return out; }\n\ntemplate<class T>\nstd::ostream &operator<< ( std::ostream& out, const std::vector<T>& a )\n{ std::cout << '['; rep( i, a.size() ){ std::cout << a[i]; if( i != a.size()-1 ) std::cout << \", \"; } std::cout << ']'; return out; }\n\nconst ll mod = 998244353;\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const {\n    return pow(mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n};\n\nstruct combination {\n  std::vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n\nstd::string S;\nll cntR[2010], cntB[2010];\nmint dp[2010][2010];\ncombination comb( 10000 );\n\nint main()\n{\n  std::cin >> S;\n\n  ll N = S.size();\n\n  rep( i, N ) {\n    if( S[i] == '0' ) {\n      cntR[i+1] = cntR[i]+2;\n      cntB[i+1] = cntB[i];\n    } else if( S[i] == '1' ) {\n      cntR[i+1] = cntR[i]+1;\n      cntB[i+1] = cntB[i]+1;\n    } else {\n      cntR[i+1] = cntR[i];\n      cntB[i+1] = cntB[i]+2;\n    }\n  }\n\n  dp[0][0] = 1;\n\n  rep( i, N ) rep( r, i+1 ) {\n    if( cntR[i+1] >= r+1 )\n      dp[i+1][r+1] += dp[i][r];\n    if( cntB[i+1] >= i-r+1 )\n      dp[i+1][r] += dp[i][r];\n  }\n\n  mint ans = 0;\n\n  rep( r, N+1 ) {\n    ans += comb( N, cntR[N]-r )*dp[N][r];\n  }\n\n  std::cout << ans.x << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 4010;\nconst int mod = 998244353;\n\nint n;\nint dp[MAXN][MAXN];\nchar s[MAXN];\n\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    std::vector<int> red, blue;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i] == '0') {\n            red.push_back(i);\n            red.push_back(i);\n        } else if (s[i] == '1') {\n            red.push_back(i);\n            blue.push_back(i);\n        } else {\n            blue.push_back(i);\n            blue.push_back(i);\n        }\n    }\n    dp[0][0] = 1;\n    n <<= 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (j < red.size() && red[j] <= i) {\n                (dp[i][j + 1] += dp[i - 1][j]) %= mod;\n            }\n            if (i - j - 1 < blue.size() && blue[i - j - 1] <= i) {\n                (dp[i][j] += dp[i - 1][j]) %= mod;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[n][red.size()]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long MOD=998244353;\n\nlong long add_mod(long long x,long long y){\n\treturn (x+y)%MOD;\n}\n\nlong long sub_mod(long long x,long long y){\n\treturn (x-y+MOD)%MOD;\n}\n\nlong long mul_mod(long long x,long long y){\n\treturn x*y%MOD;\n}\n\nint n;\nlong long dp[4001][4001];\n\nvoid solve(){\n    int i,j;\n    string str;\n    cin >> str;\n    n = str.length();\n    vector<int> r(n+1,0),b(n+1,0);\n    for(i = 0;i < n;i++){\n        if(str[i] == '0'){\n            r[i+1] = r[i] + 2;\n            b[i+1] = b[i];\n        }\n        else if(str[i] == '1'){\n            r[i+1] = r[i] + 1;\n            b[i+1] = b[i] + 1;\n        }\n        else{\n            r[i+1] = r[i];\n            b[i+1] = b[i] + 2;\n        }\n    }\n    dp[0][0] = 1;\n    for(i = 1;i <= 2*n;i++){\n        int ch = i;\n        if(ch > n) ch = n;\n        for(j = 0;j <= i;j++){\n            if(r[ch] >= j) dp[i][j] = add_mod(dp[i][j],dp[i-1][j-1]);\n            if(b[ch] >= i-j) dp[i][j] = add_mod(dp[i][j],dp[i-1][j]);\n        }\n    }\n    long long ans = 0;\n    for(i = 0;i <= 2*n;i++) ans = add_mod(dp[2*n][i],ans);\n    cout << ans << endl;\n}\n\nint main(){\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\nusing ll = long long;\nusing II = pair<int, int>; using VII = vector<II>; using VVII = vector<VII>;\nusing VI = vector<int>; using VVI = vector<VI>; using VVVI = vector<VVI>;\ntemplate <class T> using V = vector<T>; template <class T> using VV = V<V<T>>; template <class T> using VVV = V<VV<T>>;\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream &s, const pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 998244353;\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = (unsigned long long)x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = (unsigned long long)x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return pow(*this, MD - 2); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\nusing mint = ModInt<MOD>;\n\n// r, b\nII num(char c) {\n  if (c == '0') return {2, 0};\n  if (c == '1') return {1, 1};\n  return {0, 2};\n}\nsigned main() {\n  string s; cin >> s;\n  int n = s.size();\n  VI rs(2 * n + 1);\n  REP (i, 2 * n) {\n    if (i < n) {\n      rs[i + 1] = rs[i] + ('2' - s[i]);\n    } else {\n      rs[i + 1] = rs[i];\n    }\n  }\n  V<V<mint>> dp(2 * n + 1, V<mint>(2 * n + 1, -1));\n  function<mint(int, int)> dfs = [&](int i, int r) {\n    if (dp[i][r] != -1) return dp[i][r];\n    if (r > rs[i] || i - r > 2 * min(n, i) - rs[i]) return dp[i][r] = 0;\n    if (i == 2 * n) return mint(1);\n    return dp[i][r] = dfs(i + 1, r) + dfs(i + 1, r + 1);\n  };\n  cout << dfs(0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nstring s;\nint r, b;\n//i回目のbの個数\nll dp[4001][4001];\nint numb[2001];\nint numr[2001];\n//i個目のbに要求されるrの個数\nint q[4001];\n//i個目のrに要求されるbの個数\nint p[4001];\nint main() {\n\tcin >> s; int n = s.length();\n\trep(i, n) {\n\t\tif (s[i] == '0')r += 2;\n\t\telse if (s[i] == '2')b += 2;\n\t\telse {\n\t\t\tr++; b++;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (s[i] == '0')numr[i]++;\n\t\telse if (s[i] == '2')numb[i]++;\n\t}\n\tint cnt = 0; int cntb = 0;\n\tint cntr = 0;\n\trep(i, n) {\n\t\tint t = cntb;\n\t\tif (s[i] == '2') {\n\t\t\tt += 2;\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tt++;\n\t\t}\n\t\telse {\n\t\t\tcnt++;\n\t\t}\n\t\tRep1(j, cntb + 1, t) {\n\t\t\tq[j-1] = max(i+1-j,0);\n\t\t}\n\t\tcntb = t;\n\t}\n\tcnt = 0;\n\trep(i, n) {\n\t\tint t = cntr;\n\n\t\tif (s[i] == '2') {\n\t\t\tcnt++;\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tt++;\n\t\t}\n\t\telse {\n\t\t\tt += 2;\n\t\t}\n\t\tRep1(j, cntr + 1, t) {\n\t\t\tp[j-1] = max(i+1-j,0);\n\t\t}\n\t\tcntr = t;\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, i + 1) {\n\t\t\t//次にbを追加\n\t\t\tint nb = j, nr = i - j;\n\t\t\tif (q[nb] <= nr) {\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= mod;\n\t\t\t}\n\t\t\tif (p[nr] <= nb) {\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2 * n][b] << endl;\n\t/*rep(i, b) {\n\t\tcout << q[i] << endl;\n\t}*/\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n\n\nchar S[2020];\nll dp[4040][4040];\nll i,j,k,l,ans,n;\n\nint main(){\n    scanf(\"%s\", S);\n    n = 2;\n    dp[0][S[0]-'0'] = 1;\n    /*\n    fornum(j,0,n+1){\n        printf(\"%lld \", dp[i][j]);\n    }\n    printf(\"\\n\");*/\n    for (i = 1; S[i];i++){\n        ll b = S[i] - '0';\n        dp[i][b] = (dp[i][b]+dp[i-1][0])%MOD;\n        fornum(j,1,n){\n            dp[i][j+b] = (dp[i][j+b]+dp[i-1][j])%MOD;\n            dp[i][j+b-1] = (dp[i][j+b-1]+dp[i-1][j])%MOD;\n        }\n        dp[i][n+b-1] = (dp[i][n+b-1]+dp[i-1][n])%MOD;\n        n++;/*\n        fornum(j,0,n+1){\n            printf(\"%lld \", dp[i][j]);\n        }\n        printf(\"\\n\");\n        */\n    }\n    k = i;\n    for (i; i<=k*2;i++){\n        dp[i][0] = (dp[i][0]+dp[i-1][0])%MOD;\n        fornum(j,1,n){\n            dp[i][j] = (dp[i][j]+dp[i-1][j])%MOD;\n            dp[i][j-1] = (dp[i][j-1]+dp[i-1][j])%MOD;\n        }\n        dp[i][n-1] = (dp[i][n-1]+dp[i-1][n])%MOD;\n        n--;/*\n        fornum(j,0,n+1){\n            printf(\"%lld \", dp[i][j]);\n        }\n        printf(\"\\n\");\n        */\n    }\n    printf(\"%lld\",dp[k*2][0]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <functional>\n#include <unordered_set>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nvoid Add(int& a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nconst int N = 2e3 + 1;\nint dp[2 * N][2 * N];\nint cnt[2 * N][2];\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tint n = s.length();\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tchar ch = s[i - 1];\n\t\tif (ch == '0') {\n\t\t\tcnt[i][0] = 2;\n\t\t} else if (ch == '1') {\n\t\t\tcnt[i][0] = cnt[i][1] = 1;\n\t\t} else {\n\t\t\tcnt[i][1] = 2;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tcnt[i][0] += cnt[i - 1][0];\n\t\tcnt[i][1] += cnt[i - 1][1];\n\t}\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tfor (int red = 0; red <= i; ++red) {\n\t\t\tif (cnt[i + 1][1] >= (i + 1) - red) {\n\t\t\t\tAdd(dp[i + 1][red], dp[i][red]);\n\t\t\t}\n\t\t\tif (cnt[i + 1][0] >= red + 1) {\n\t\t\t\tAdd(dp[i + 1][red + 1], dp[i][red]);\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor (int red = 0; red <= 2 * n; ++red) {\n\t\tAdd(answer, dp[2 * n][red]);\n\t}\n\tcout << answer << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 4005\nusing namespace std;\ntypedef long long LL;\nconst int P=998244353;\nint red[N],blue[N],F[N][N],n,ans;char s[N];\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor (int i=1;i<=2*n;i++){\n\t\tint &t1=red[i],&t2=blue[i];\n\t\tfor (int j=min(i,n);j;j--){\n\t\t\tif (s[j]=='0') t1+=2;\n\t\t\tif (s[j]=='1') t1++,t2++;\n\t\t\tif (s[j]=='2') t2+=2;\n\t\t\tt1=min(t1,i-j+1);\n\t\t\tt2=min(t2,i-j+1);\n\t\t}\n\t}\n\tF[0][0]=1;\n\tfor (int i=1;i<=2*n;i++)\n\t\tfor (int j=max(0,i-blue[i]);j<=red[i];j++){\n\t\t\tF[i][j]=F[i-1][j];\n\t\t\tif (j>0){\n\t\t\t\tif ((F[i][j]+=F[i-1][j-1])>=P)\n\t\t\t\t\tF[i][j]-=P;\n\t\t\t}\n\t\t\tif (i==2*n){\n\t\t\t\tif ((ans+=F[i][j])>=P)\n\t\t\t\t\tans-=P;\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint r[4003], b[4003];\nll dp[2][4003][4003];\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n    for(int i = 0; i < n; i++){\n        if(s[i] == '0') r[i] += 2;\n        if(s[i] == '1'){\n            r[i]++;\n            b[i]++;\n        }\n        if(s[i] == '2') b[i] += 2;\n        r[i + 1] += r[i];\n        b[i + 1] += b[i];\n    }\n    for(int i = n; i < n * 2; i++){\n        r[i + 1] = r[i];\n        b[i + 1] = b[i];\n    }\n    dp[0][0][0] = 1;\n    for(int i = 1; i <= n * 2; i++){\n        for(int j = 1; j <= min(i, r[i - 1]); j++)\n            dp[i % 2][j][i - j] = (dp[i % 2][j][i - j] + dp[(i + 1) % 2][j - 1][i - j]) % MOD;\n        for(int j = 1; j <= min(i, b[i - 1]); j++)\n            dp[i % 2][i - j][j] = (dp[i % 2][i - j][j] + dp[(i + 1) % 2][i - j][j - 1]) % MOD;\n    }\n    cout << dp[0][r[n * 2]][b[n * 2]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define test cout<<\"test\"<<endl;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nvoid chmin(T &a,T b){if(a>b)a=b;}\ntemplate<typename T>\nvoid chmax(T &a,T b){if(a<b)a=b;}\nvoid pmod(ll &a,ll b){a=(a+b)%MOD;}\nvoid pmod(ll &a,ll b,ll c){a=(b+c)%MOD;}\nvoid qmod(ll &a,ll b){a=(a*b)%MOD;}\nvoid qmod(ll &a,ll b,ll c){a=(b*c)%MOD;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\nostream &operator<<(ostream &os, pair<ll, ll>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD >;\nmodint pow2(int64_t n, int64_t x){\n    return modint(n).pow(x);\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  //cout<<fixed<<setprecision(10);\n  ll res=0,buf=0;\n  bool judge = true;\n  string s;cin>>s;\n  ll n=s.size();\n  auto dp=vec(2*n+1,2*n+1,(modint)0);\n  dp[0][0]=1;\n  ll red=0,blue=0;\n  rep(i,0,2*n){\n    if(i<n){\n      if(s[i]=='0')red+=2;\n      if(s[i]=='1')blue++,red++;\n      if(s[i]=='2')blue+=2;\n    }\n    //cout<<i spa red spa blue<<endl;\n    rep(j,0,i+1){\n      if(i-j<blue)dp[i+1][j]+=dp[i][j];\n      if(j<red)dp[i+1][j+1]+=dp[i][j];\n    }\n  }\n  //debug(dp,2*n+1,2*n+1);\n  modint ret=0;\n  rep(i,0,2*n+1)ret+=dp[2*n][i];\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    VI a(n);\n    REP(i,n) a[i] = s[i] - '0';\n\n    int r = 0;\n    REP(i,n) r += a[i];\n    int b = 2 * n - r;\n\n    VI cnt(n);\n    cnt[0] = a[0];\n    REP(i,n-1) cnt[i+1] = cnt[i] + a[i+1];\n\n\n    VVL dp(r + 1, VL(b + 1));\n    dp[0][0] = 1;\n    REP(i,r+1) REP(j,b+1){\n        // cout << i << \" \" << j << endl;\n        int t = i + j, cr = 0;\n        if (t >= n) cr = r;\n        else cr = cnt[t];\n        int cb = 2 * min(n, (t + 1)) - cr;\n        // cout << \" \" << cr << \" \" << cb << endl;\n        if (i < cr) dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n        if (j < cb) dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % mod;\n    }\n\n    cout << dp[r][b] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define int long long\n#define mp make_pair\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[4010][4010];\nint ka[214514],inv[214514];\nvoid setkaijo(int n){\n\tka[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tka[i] = ka[i-1] * i;\n\t\tka[i] %= inf;\n\t}\n}\nint modpow(int x,int k){\n\t// x ^ k mod inf\n\tint p2[55],res=1;\n\tp2[0]=1;p2[1]=x%inf;\n\tfor(int i=2;i<=50;i++){\n\t\tp2[i]=p2[i-1]*p2[i-1];\n\t\tp2[i] %= inf;\n\t}\n\tfor(int i=1;i<=50;i++){\n\t\tif(k%2==1){\n\t\t\tres *= p2[i];\n\t\t\tres %= inf;\n\t\t}\n\t\tk /= 2;\n\t}\n\treturn res;\n}\nvoid setinv(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tinv[i] = modpow(ka[i],(ll)inf-2);\n\t}\n}\nint comb(int n,int k){\n\tif( k<0 || n<0 || k>n)return 0;\n\tif(k==0 || k==n)return 1;\n\tint res = (ka[n] * inv[k]) % inf;\n\tres = (res*inv[n-k]) % inf;\n\treturn res;\n}\nsigned main(){\n\tstring st;\n\tcin>>st;\n\tint n = st.size();\n\tsetkaijo(10000);\n\tsetinv(10000);\n\tdp[0][0] = 1;\n\tint rc = 0, bc = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tchar cur = st[i-1];\n\t\tif( cur == '2'){\n\t\t\trc += 2;\n\t\t}\n\t\telse if( cur == '1' ){\n\t\t\trc++;\n\t\t\tbc++;\n\t\t}\n\t\telse{\n\t\t\tbc += 2;\n\t\t}\n\t\tfor(int j=0;j<=2000;j++){\n\t\t\tif( j < rc ){\n\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t}\n\t\t\tif( (i-1-j) >= 0 && (i-1-j) < bc){\n\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\tdp[i][j] %= inf;\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++){for(int j=0;j<=i;j++){cout<<\"dp\"<<i<<j<<\" \"<<dp[i][j]<<endl;}}\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tans += dp[n][i] * comb(n,rc-i);\n\t\tans %= inf;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 998244353;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\nmint dp[4010][4010][2];\n\ninline int rest_ball(int i,int n){\n\tconst int total = 2 * min(i,n) - i;\n\treturn total;\n}\n\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\tdp[0][0][0] = ONE;\n\n\trep(i,2*n)rep(j,2*n+1)rep(k,2){\n\t\tif(dp[i][j][k] == ZERO) continue;\n\t\tconst int all = rest_ball(i, n);\n\t\tint nr = j, nb = all - j;\n\n\t\tif(i < n){\n\t\t\tconst int idx = s[i] - '0';\n\t\t\tnr += idx;\n\t\t\tnb += 2 - idx;\n\t\t}\n\n\t\t// red\n\t\tif(nr > 0){\n\t\t\tint nk = k;\n\t\t\tif(nr - 1 == 0) nk = 1;\n\t\t\tdp[i+1][nr-1][nk] += dp[i][j][k];\n\t\t}\n\n\t\t// blue\n\t\tif(nb > 0){\n\t\t\tint nk = k;\n\t\t\tdp[i+1][nr][nk] += dp[i][j][k];\n\t\t}\n\t}\n\n\tmint ans = dp[2 * n][0][1];\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef gp_hash_table<long long, long long> umap;\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (long long i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (long long i = (n) - 1; i >= 0; i--)\n#define foreach(it,ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar,val) memset(ar, val, sizeof(ar))\n#define fill0(ar) fill((ar), 0)\n#define fillinf(ar, n) fr(i,0,(n)) ar[i] = INF\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define arr1d(a,n) cout << #a << \" : \"; fr(_,1,n) cout << a[_] << ' '; cout << endl;\n#define arr1d0(a,n) cout << #a << \" : \"; rep(_,n) cout << a[_] << ' '; cout << endl;\n#define arr2d(a,n,m) cout << #a << \" :\" << endl; fr(_,1,n) {fr(__,1,m) cout << a[_][__] << ' '; cout << endl;}\n#define arr2d0(a,n,m) cout << #a << \" :\" << endl; rep(_,n) {rep(__,m) cout << a[_][__] << ' '; cout << endl;}\n/*Author Ritick Goenka || ritick(codechef) ||ritick(codeforces) */\n/*IIT Roorkee = <3 */\n#define ull unsigned long long\n#define ll long long\n#define ld double\n#define ui unsigned int\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define y0 yyyyyy0\n#define y1 yyyyyy1\n#define sot(bello) bello.begin(),bello.end()\n#define BIT(n) (1<<(n))\n#define SQR(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n#define LSOne(S) (S) & (-S)\ninline bool EQ(double a, double b) {return fabs(a - b) < 1e-9;}\n \ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n \n \ntemplate<typename T>inline T gcd(T a, T b){if (b == 0)return a;else return gcd(b, a % b);}\ntemplate<typename T>inline T lcm(T a, T b){return (a * b) / gcd(a, b);}\ntemplate<typename T> string toStr(T x) {stringstream st; st << x; string s; st >> s; return s;}\ntemplate<class T>\nvoid splitStr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n \ninline int two(int n) {return 1 << n;}\ninline int isOnBit(int n, int b) {return (n >> b) & 1;}\ninline void onBit(int & n, int b) {n |= two(b);}\ninline void offBit(int & n, int b) {n &= ~two(b);}\ninline int lastBit(int n) {return n & (-n);}\ninline int cntBit(int n) {int res = 0; while(n && ++res) n -= n &(-n); return res;}\n \nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy8[] = {0, 1, 0, -1, -1, 1, -1, 1};\n \n#define INP \"test.inp\"\n#define OUT \"test.out\"\n \n#define PI 3.1415926535897932385\n#define INF 1000000000000000\n#define EPS 1e-7\n#define MAXN 100000\n#define MOD 998244353\n#define dec decr\n//END OF COMPETITVE PROGRAMMING TEMPLATE\nll gcd(ll a, ll b) \n{ \n    if (a == 0) \n        return b; \n    return gcd(b % a, a); \n} \nll modexp(ll x, ll y, ll p)\n{\n    ll res = 1;   \n    x = x % p;  \n    while (y > 0)\n    {\n        if (y & 1)    \n            res = (res*x) % p;\n        y = y>>1;     \n        x = (x*x) % p; \n    }\n    return res;\n}\nll dp[6005][6005];\nll r[6005];\nll r1[6005];\nll b1[6005];\nll b[6005];\nll n1;\nll fn(ll br,ll bb)\n{\n    // debug(br);\n    // debug(bb);\n    if(br<0||bb<0)\n        return 0;\n    ll n=br+bb;\n    if((br<r[n]||bb<b[n]))\n        return 0;\n    if(br>r1[n]||bb>b1[n])\n        return 0;\n    if(dp[br][bb]!=-1)\n        return dp[br][bb];\n    return dp[br][bb]=(fn(br-1,bb)+fn(br,bb-1))%MOD;\n \n}\n \nint main () \n{\n    ios_base::sync_with_stdio(false);\n            cin.tie(NULL);\n        cout<<setprecision(11);\n            string s;\n            cin>>s;\n            ll x=0;\n            ll rc=0,bc=0;\n            rep(i,3005)\n            {\n                rep(j,3005)\n                    dp[i][j]=-1;\n            }\n            ll n=s.length();\n            // debug(n);\n            n1=n;\n            dp[0][0]=1;\n            rep(i,n)\n            {\n                // debug(i);\n                if(s[i]=='0')\n                {\n                    rc++;\n                    r1[i+1]=r1[i]+2;\n                    b1[i+1]=b1[i];\n\n                }\n                else if(s[i]=='2')\n                {\n                    bc++;\n                    b1[i+1]=b1[i]+2;\n                    r1[i+1]=r1[i];\n\n                }\n                else\n                {\n                    r1[i+1]=r1[i]+1;\n                    b1[i+1]=b1[i]+1;\n                }\n                r[i+1]=max(r[i],rc-bc);\n                b[i+1]=max(b[i],bc-rc);\n                // debug(b1[i+1]);\n                //     debug(r1[i+1]);\n            }\n            rep(i,n)\n            {\n                // debug(r1[i+1]);\n                // debug(b1[i+1]);\n                r1[n+i+1]=r1[n+i];\n                b1[n+i+1]=b1[n+i];\n\n                r[n+i]=r[n+i-1];\n                b[n+i]=b[n+i-1];\n            }\n            // debug(n-bc+rc);\n            // debug(n);\n            cout<<fn(n-bc+rc,n-rc+bc);\n            return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nint read() {\n\tint x; cin >> x; return x;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nclass UnionFind {\nprotected:\n\tint* par, * rank, * size;\npublic:\n\tUnionFind(unsigned int size) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tthis->size = new int[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tthis->size[i] = 1;\n\t\t}\n\t}\n\tint find(int n) {\n\t\tif (par[n] == n)return n;\n\t\treturn par[n] = find(par[n]);\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m)return;\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tsize[m] += size[n];\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tsize[n] += size[m];\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t}\n\tbool same(int n, int m) {\n\t\treturn find(n) == find(m);\n\t}\n\tint getsize(int n) {\n\t\treturn size[find(n)];\n\t}\n};\nclass PerpetualUnionFind :UnionFind {\n\tP* notparent;\n\tvector<P>* sizevec;\n\tint opcount = 0;\npublic:\n\tPerpetualUnionFind(unsigned int size) :UnionFind(size) {\n\t\tthis->sizevec = new vector<P>[size];\n\t\tnotparent = new P[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsizevec[i].push_back(make_pair(-1, 1));\n\t\t\tnotparent[i] = make_pair(INF, i);\n\t\t}\n\t}\n\tint find(int n, int t = INF) {\n\t\tif (opcount <= t) {\n\t\t\tif (par[n] == n)return n;\n\t\t\treturn par[n] = find(par[n]);\n\t\t}\n\t\tif (notparent[n].first <= t)return find(notparent[n].second, t);\n\t\treturn n;\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m) {\n\t\t\topcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tnotparent[n] = make_pair(opcount, m);\n\t\t\tsizevec[m].push_back(make_pair(opcount, sizevec[m].back().second + sizevec[n].back().second));\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tnotparent[m] = make_pair(opcount, n);\n\t\t\tsizevec[n].push_back(make_pair(opcount, sizevec[n].back().second + sizevec[m].back().second));\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t\topcount++;\n\t}\n\tbool same(int n, int m, int t = INF) {\n\t\treturn find(n, t) == find(m, t);\n\t}\n\tint getsize(int n, int t = INF) {\n\t\tn = find(n, t);\n\t\tauto ite = lower_bound(sizevec[n].begin(), sizevec[n].end(), make_pair(t, (int)0));\n\t\tif (ite == sizevec[n].end())ite--;\n\t\tif (t < (*ite).first)ite--;\n\t\treturn (*ite).second;\n\t}\n};\nclass RollingHash {\n\tstring s;\n\tint n, m;\n\tmodInt base;\n\tvector<modInt> has, power;\npublic:\n\tRollingHash(string s, int m, int b) : n(s.size()), m(m), base(b, m) { init(s, m, b); }\n\tvoid init(string s, int m, int b) {\n\t\tn = s.size();\n\t\thas.resize(n);\n\t\tpower.resize(n);\n\t\tbase = modInt(b, m);\n\t\tthis->s = s;\n\t\tthis->m = m;\n\t\trep(i, n) {\n\t\t\thas[i] = modInt(s[i], m);\n\t\t\tif (i) {\n\t\t\t\thas[i] += base * has[i - 1];\n\t\t\t\tpower[i] = power[i - 1] * base;\n\t\t\t}\n\t\t\telse power[i] = 1;\n\t\t}\n\t}\n\toperator int() const {\n\t\treturn has.back();\n\t}\n\tint query(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\treturn has[b - 1] - power[b - a] * (!a ? modInt(0) : has[a - 1]);\n\t}\n\tRollingHash& operator+=(string t) {\n\t\ts += t;\n\t\thas.resize(n + t.size());\n\t\tpower.resize(n + t.size());\n\t\tfor (int i = n; i < n + t.size(); i++) {\n\t\t\thas[i] = modInt(t[i] * base, m);\n\t\t\thas[i] += base * has[i - 1];\n\t\t\tpower[i] = power[i - 1] * base;\n\t\t}\n\t\tn += t.size();\n\t\treturn *this;\n\t}\n};\ntemplate<typename T, typename U>\nclass SegTree {\n\tint n = 1;\n\tT* node = NULL;\n\tU* lazy = NULL;\n\tbool* lazyflag = NULL;\n\tT nodee;\n\tfunction<T(T, T)> nodef;\n\tfunction<U(U, U)> lazyf;\n\tfunction<T(int, T, U)> updf;\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazyflag[k]) {\n\t\t\tnode[k] = updf(r - l, node[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tif (lazyflag[2 * k + 1])lazy[2 * k + 1] = lazyf(lazy[2 * k + 1], lazy[k]);\n\t\t\t\telse lazy[2 * k + 1] = lazy[k];\n\t\t\t\tif (lazyflag[2 * k + 2])lazy[2 * k + 2] = lazyf(lazy[2 * k + 2], lazy[k]);\n\t\t\t\telse lazy[2 * k + 2] = lazy[k];\n\t\t\t\tlazyflag[2 * k + 1] = lazyflag[2 * k + 2] = true;\n\t\t\t}\n\t\t\tlazyflag[k] = false;\n\t\t}\n\t}\npublic:\n\tSegTree(int m, int init, T nodee, function<T(T, T)> nodef, function<U(U, U)> lazyf, function<T(int, T, U)> updf) :nodee(nodee), nodef(nodef), lazyf(lazyf), updf(updf) {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t\twhile (n < m)n *= 2;\n\t\tnode = new T[2 * n], lazy = new U[2 * n], lazyflag = new bool[2 * n];\n\t\trep(i, 2 * n) {\n\t\t\tnode[i] = init;\n\t\t\tlazyflag[i] = false;\n\t\t}\n\t}\n\t~SegTree() {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t}\n\tvoid update(int a, int b, U x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazyflag[k] = true;\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = nodef(node[2 * k + 1], node[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return nodee;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn nodef(vl, vr);\n\t}\n};\ntemplate<typename T>\nclass RAQRSQ :public SegTree<T, T> {\npublic:\n\tRAQRSQ(int size, const T& def = T()) :SegTree<T, T>(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + range * b; }) {};\n};\ntemplate<typename T>\nclass RAQRMiQ :public SegTree<T, T> {\npublic:\n\tRAQRMiQ(int size, const T& def = T()) :SegTree<T, T>(size, def, INF, [](T a, T b) {return min(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RAQRMaQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRAQRMaQ(int size, const T& def = T()) :base(size, def, -INF, [](T a, T b) {return max(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RUQRSQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRSQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return b; }, [](int range, T a, T b) {return range * b; }) {};\n};\ntemplate<typename T>\nclass RUQRMQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRMQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return min(a, b); }, [](T a, T b) {return b; }, [](int range, T a, T b) {return b; }) {};\n};\ntemplate<typename T>\nclass BIT {\n\tint n;\n\tT* bit;\npublic:\n\tBIT(int n) :n(n) {\n\t\tbit = new T[n];\n\t\tfill(bit, bit + n, T());\n\t}\n\tvoid add(int a, T x) {\n\t\twhile (a < n) {\n\t\t\tbit[a] += x;\n\t\t\ta += a & -a;\n\t\t}\n\t}\n\tT query(int a) {\n\t\tint cnt = 0;\n\t\twhile (a > 0) {\n\t\t\tcnt += bit[a];\n\t\t\ta -= a & -a;\n\t\t}\n\t\treturn cnt;\n\t}\n};\nclass ConvexHullTrick {\n\tbool minOrMax, lineMonotone;\n\tclass Line {\n\tpublic:\n\t\tint a, b;\n\t\tbool isquery;\n\t\tmutable std::function<const Line * ()> getSuc;\n\t\tbool operator<(const Line& x) const {\n\t\t\tif (isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return true;\n\t\t\t\treturn (suc->a - x.a) * a + suc->b - x.b > 0;\n\t\t\t}\n\t\t\tif (x.isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return false;\n\t\t\t\treturn (suc->a - a) * x.a + suc->b - b < 0;\n\t\t\t}\n\t\t\treturn a < x.a;\n\t\t}\n\t};\n\tbool isbad(const set<Line>::iterator x) {\n\t\tif (x == st.begin() || next(x) == st.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tbool isbad(const vector<Line>::iterator x) {\n\t\tif (x == vec.begin() || next(x) == vec.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tset<Line> st;\n\tvector<Line> vec;\npublic:\n\tConvexHullTrick(bool minormax = false, bool lineMonotone = false) :minOrMax(minormax), lineMonotone(lineMonotone) {}\n\tvoid addLine(int a, int b) {\n\t\tif (minOrMax) {\n\t\t\ta = -a; b = -b;\n\t\t}\n\t\tif (!lineMonotone) {\n\t\t\tauto pos = st.lower_bound({ a,-INF,false });\n\t\t\tif (pos != st.end()) {\n\t\t\t\tif ((*pos).a == a) {\n\t\t\t\t\tif ((*pos).b <= b)return;\n\t\t\t\t\tst.erase(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto ite = st.insert({ a,b,false }).first;\n\t\t\tite->getSuc = [=] {return next(ite) == st.end() ? nullptr : &*next(ite); };\n\t\t\tif (isbad(ite)) {\n\t\t\t\tst.erase(ite);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (next(ite) != st.end() && isbad(next(ite)))st.erase(next(ite));\n\t\t\twhile (ite != st.begin() && isbad(prev(ite)))st.erase(prev(ite));\n\t\t}\n\t\telse {\n\t\t\tif (!vec.empty()) {\n\t\t\t\tif (vec.back().a > a) {\n\t\t\t\t\tcerr << \"Line additions are not monotone\" << endl;\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (vec.back().a == a) {\n\t\t\t\t\tif (vec.back().b <= b)return;\n\t\t\t\t\tvec.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec.push_back({ a,b,false });\n\t\t\tauto ite = --vec.end();\n\t\t\tint index = vec.size() - 1;\n\t\t\tite->getSuc = [this, index] {cout << vec.size() << endl; return index == vec.size() - 1 ? nullptr : &*(vec.begin() + index + 1); };\n\t\t\twhile (ite != vec.begin() && isbad(prev(ite))) {\n\t\t\t\t*prev(ite) = vec.back();\n\t\t\t\tvec.pop_back();\n\t\t\t\tite = --vec.end();\n\t\t\t}\n\t\t}\n\t}\n\tint query(int x) {\n\t\tif (!lineMonotone) {\n\t\t\tauto l = *st.lower_bound(Line{ x, 0,true });\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t\telse {\n\t\t\tauto l = *lower_bound(vec.begin(), vec.end() - 1, Line({ x,0,true }));\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t}\n};\ntemplate<typename T>\nclass Matrix {\n\tint n;\n\tT zero, e;\n\tvector<vector<T>> vec;\n\tvoid letmeasure() {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j)vec[i][j] = zero;\n\t\t\t\telse vec[i][j] = e;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tMatrix(int n, T zero, T e) :n(n), zero(zero), e(e) {\n\t\tvec.resize(n, vector<T>(n));\n\t}\n\tMatrix(int n, T zero, T e, vector<int> vec) :n(n), zero(zero), e(e) {\n\t\tif (vec.size() != n * n) {\n\t\t\tcerr << \"Invalid construct of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tthis->vec.resize(n, vector<T>(n));\n\t\trep(i, n) {\n\t\t\trep(j, n)this->vec[i][j] = vec[i * n + j];\n\t\t}\n\t}\n\tT& operator[](int a) {\n\t\treturn vec[a / n][a % n];\n\t}\n\tunsigned int size() { return n; }\n\tMatrix operator*(const Matrix a) {\n\t\tif (this->n != a.n) {\n\t\t\tcerr << \"Invalid multiply of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> memo(n);\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tmemo[j] += vec[i][k] * a.vec[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec[i] = memo;\n\t\t\tmemo.clear();\n\t\t\tmemo.resize(n);\n\t\t}\n\t\treturn *this;\n\t}\n\tstatic Matrix<T> measure(int n, T zero, T e) {\n\t\tMatrix<T> res(n, zero, e);\n\t\tres.letmeasure();\n\t\treturn res;\n\t}\n};\n\nclass mycomplex {\n\tdouble realvalue, imagvalue;\npublic:\n\tmycomplex() :realvalue(0), imagvalue(0) {}\n\tmycomplex(double realvalue, double imagvalue) : realvalue(realvalue), imagvalue(imagvalue) {}\n\tmycomplex(double realvalue) : realvalue(realvalue), imagvalue(0) {}\n\tmycomplex(complex<double> c) :realvalue(c.real()), imagvalue(c.imag()) {}\n\tmycomplex(const mycomplex& rhs) :realvalue(rhs.realvalue), imagvalue(rhs.imagvalue) {}\n\tdouble real()const { return this->realvalue; }\n\tdouble imag()const { return this->imagvalue; }\n\tdouble abs() { return hypot(realvalue, imagvalue); }\n\tmycomplex& operator=(const mycomplex& obj) {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = obj.realvalue;\n\t\t\tthis->imagvalue = obj.imagvalue;\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator=(mycomplex&& obj)noexcept {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = exchange(obj.realvalue, 0);\n\t\t\tthis->imagvalue = exchange(obj.imagvalue, 0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator+=(const mycomplex& rhs) {\n\t\tthis->realvalue += rhs.realvalue;\n\t\tthis->imagvalue += rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator+(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs += rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator-=(const mycomplex& rhs) {\n\t\tthis->realvalue -= rhs.realvalue;\n\t\tthis->imagvalue -= rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tmycomplex& operator-=(const double& rhs) {\n\t\tthis->realvalue -= rhs;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator-(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs -= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator*=(const mycomplex& rhs) {\n\t\tdouble pastreal = this->realvalue;\n\t\tthis->realvalue = this->realvalue * rhs.realvalue - this->imagvalue * rhs.imagvalue;\n\t\tthis->imagvalue = pastreal * rhs.imagvalue + rhs.realvalue * this->imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator*(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs *= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator/=(const mycomplex& rhs) {\n\t\t*this *= mycomplex(rhs.real(), -rhs.imag());\n\t\tdouble dnm = rhs.real() * rhs.real() - rhs.imag() * rhs.imag();\n\t\tthis->realvalue /= dnm;\n\t\tthis->imagvalue /= dnm;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator/(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs /= rhs;\n\t\treturn lhs;\n\t}\n};\nclass FastFourierTransform {\nprivate:\n\tstatic void dft(vector<mycomplex>& func, int inverse) {\n\t\tint sz = func.size();\n\t\tif (sz == 1)return;\n\t\tvector<mycomplex> veca, vecb;\n\t\trep(i, sz / 2) {\n\t\t\tveca.push_back(func[2 * i]);\n\t\t\tvecb.push_back(func[2 * i + 1]);\n\t\t}\n\t\tdft(veca, inverse); dft(vecb, inverse);\n\t\tmycomplex now = 1, zeta = polar(1.0, inverse * 2.0 * acos(-1) / sz);\n\t\trep(i, sz) {\n\t\t\tfunc[i] = veca[i % (sz / 2)] + now * vecb[i % (sz / 2)];\n\t\t\tnow *= zeta;\n\t\t}\n\t}\npublic:\n\ttemplate<typename T>\n\tstatic vector<double> multiply(vector<T> f, vector<T> g) {\n\t\tvector<mycomplex> nf, ng;\n\t\tint sz = 1;\n\t\twhile (sz < f.size() + g.size())sz *= 2;\n\t\tnf.resize(sz); ng.resize(sz);\n\t\trep(i, f.size()) {\n\t\t\tnf[i] = f[i];\n\t\t\tng[i] = g[i];\n\t\t}\n\t\tdft(nf, 1);\n\t\tdft(ng, 1);\n\t\trep(i, sz)nf[i] *= ng[i];\n\t\tdft(nf, -1);\n\t\tvector<double> res;\n\t\trep(i, sz)res.push_back(nf[i].real() / sz);\n\t\treturn res;\n\t}\n};\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\ntypedef long long ll;\nusing namespace std;\n\nconst int N=2010,mod=998244353;\nchar s[N];\nint n,ans,a[N],b[N],f[N][N];\nvoid inc(int &x,int y){ x+=y; x-=(x>=mod)?mod:0; }\n\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\trep(i,1,n) a[i]=a[i-1]+2-(s[i]-'0'),b[i]=b[i-1]+s[i]-'0';\n\tf[0][0]=1;\n\trep(i,0,2*n) rep(j,0,i) if (f[i][j]){\n\t\tif (a[min(i+1,n)]>j) inc(f[i+1][j+1],f[i][j]);\n\t\tif (b[min(i+1,n)]>i-j) inc(f[i+1][j],f[i][j]);\n\t}\n\tprintf(\"%d\\n\",f[2*n][a[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nLL dp[4001][4001];\nconst LL M=998244353;\nstring S;\nint main() {\n\tcin >> S;\n\tdp[0][0]=1;\n\tint a=0;\n\tint b=0;\n\tfor(int i=0;i<2*S.size();i++){\n\t\tif(i<S.size()){\n\t\t\tswitch(S[i]){\n\t\t\t\tcase '0':a+=2;break;\n\t\t\t\tcase '1':a++;b++;break;\n\t\t\t\tcase '2':b+=2;break;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(j+1<=a){\n\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\tdp[i+1][j+1]%=M;\n\t\t\t}\n\t\t\tif(i-j+1<=b){\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tdp[i+1][j]%=M;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2*S.size()][a] << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define MOD(x) ((x) >= mod ? (x) - mod : (x))\n#define ll long long\nusing namespace std;\nconst int maxn = 4010, inf = 1e9 + 233, mod = 998244353;\nint n, ans;\nchar s[maxn];\nint f[maxn][maxn], sumr[maxn], sumb[maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n\tint f = 1; k = 0; char c = getchar();\n\twhile (c < '0' || c > '9') c == '-' && (f = -1), c = getchar();\n\twhile (c <= '9' && c >= '0') k = k * 10 + c - '0', c = getchar();\n\tk *= f;\n}\n\nint main()\n{\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tsumr[i] = sumr[i - 1];\n\t\tsumb[i] = sumb[i - 1];\n\n\t\tif (s[i] == '0') sumr[i] += 2;\n\t\telse if (s[i] == '1') sumr[i]++, sumb[i]++;\n\t\telse sumb[i] += 2;\n\t}\n\tfor (int i = n + 1; i <= n * 2; i++) sumr[i] = sumr[i - 1], sumb[i] = sumb[i - 1];\n\n\tf[0][0] = 1; ans = 0;\n\tfor (int i = 1; i <= n * 2; i++)\n\t{\n\t\tfor (int j = 0; j <= i; j++)\n\t\t{\n\t\t\tif (sumr[i] - j >= 0 && j) f[j][i - j] = MOD(f[j][i - j] + f[j - 1][i - j]);\n\t\t\tif (sumb[i] - (i - j) >= 0 && i - j) f[j][i - j] = MOD(f[j][i - j] + f[j][i - j - 1]);\n\t\t\t// printf(\"f[%d][%d]:%d %d %d %d %d\\n\", j, i - j, f[j][i - j], sumr[i], sumb[i], f[j - 1][i - j], f[j][i - j - 1]);\n\n\t\t\tif (i == 2 * n) ans = MOD(ans + f[j][i - j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n\n#include <algorithm>\n#include <functional>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\nconst int N = 2010, P = 998244353;\n\nchar s[N];\nint dp[N * 2][N * 2];\nint ss0[N], ss1[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P) x -= P;\n}\n\nint main() {\n  //freopen(\"ball.in\", \"r\", stdin);\n  //freopen(\"ball.out\", \"w\", stdout);\n  scanf(\"%s\", s + 1);\n  int n = strlen(s + 1);\n  dp[0][0] = 1;\n  int s0 = 0, s1 = 0;\n  for (int i = 1; i <= n; ++i) {\n    s1 += s[i] - '0';\n    ss0[i] = ss0[i - 1] + ('2' - s[i]);\n    ss1[i] = ss1[i - 1] + (s[i] - '0');\n  }\n  s0 = 2 * n - s1;\n  for (int i = 0; i <= s0; ++i)\n    for (int j = 0; j <= s1; ++j) {\n      int lst0 = ss0[min(i + j + 1, n)] - i, lst1 = ss1[min(i + j + 1, n)] - j;\n      if (lst0) add(dp[i + 1][j], dp[i][j]);\n      if (lst1) add(dp[i][j + 1], dp[i][j]);\n    }\n  printf(\"%d\\n\", dp[s0][s1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 998244353\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \nint ng[4001][4001];\nmint dp[4001][4001];\n\nsigned main(){\n    string s;cin>>s;\n    int n=s.size();\n    vector<int>rv(n),bv(n);\n    int rc=0,bc=0;\n    rep(i,n){\n        rv[i]=(s[i]-'0');\n        bv[i]=2-rv[i];\n        rc+=rv[i];\n        bc+=bv[i];\n    }\n    \n    rep(i,rc+1)rep(j,bc+1)ng[i][j]=false,dp[i][j]=0;\n    dp[0][0]=1;\n\n    {\n        int r=0,b=0;\n        for(int i=0;b<bc;i++){\n            b+=bv[i];\n            if(b+r<i+1){\n                ng[r][b+1]=true;\n                r++;\n            }\n        }\n    }\n    {\n        int r=0,b=0;\n        for(int i=0;r<rc;i++){\n            r+=rv[i];\n            if(r+b<i+1){\n                ng[r+1][b]=true;\n                b++;\n            }\n        }\n    }\n\n    rep(i,rc+1){\n        rep(j,bc+1){\n            if(i>0 and !ng[i-1][j]) dp[i][j]+=dp[i-1][j];\n            if(j>0 and !ng[i][j-1]) dp[i][j]+=dp[i][j-1];\n        }\n    }\n\n    cout<<dp[rc][bc]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\ntypedef long long ll;\nconst int N = 200010;\nconst int mod = 998244353;\nconst int oo = 1e9;\nconst int base = 27;\ntypedef pair<int,int> pii;\n\n\nint dp[2010][2010],f1[2001],f2[2001];\n\nstring s;\n\nint adl(int a , int b){\n  return (1ll*a+b)%mod;\n}\nint calc(int r , int b){\n  if(r+b == 2*s.size())return 1;\n  int &ret = dp[r][b];\n  if(ret != -1)return ret;\n  ret = 0;\n  int idx = r+b;\n  if(idx == s.size()){\n    if(b != f1[s.size()-1])ret = adl(ret,calc(r,b+1));\n    if(r != f2[s.size()-1])ret = adl(ret,calc(r+1,b));\n  }else{\n    if(b != f1[idx])ret = adl(ret,calc(r,b+1));\n    if(r != f2[idx])ret = adl(ret,calc(r+1,b));\n  }\n  return ret;\n}\nint main() {\n  memset(dp,-1,sizeof dp);\n  cin >> s;\n  for (int i = 0; i < s.size(); ++i){\n    if(s[i] == '1')f1[i]++,f2[i]++;\n    if(s[i] == '2')f2[i]+=2;\n    if(s[i] == '0')f1[i]+=2;\n    if(i)\n      f1[i] += f1[i-1];\n    if(i)\n      f2[i] += f2[i-1];\n  }\n  for (int i = s.size(); i <= 2*s.size(); ++i){\n    f1[i] = f1[i-1];\n    f2[i] = f2[i-1];\n  }\n  printf(\"%d\\n\",calc(0,0));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\nconst ll MOD = 998244353;\nconst int MN = 2010;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll dp[MN][MN];\nll comb[MN][MN];\nll pf[MN][2];\n\nint main() {\n\trep(i, MN) {\n\t\tcomb[i][0] = comb[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tcomb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n\t\t}\n\t}\n\n\tstring S; cin >> S;\n\tint N = S.size();\n\n\trep(i, N) {\n\t\tpf[i+1][0] = pf[i][0];\n\t\tpf[i+1][1] = pf[i][1];\n\t\tif (S[i] == '0') {\n\t\t\tpf[i+1][0] += 2;\n\t\t} else if (S[i] == '1') {\n\t\t\tpf[i+1][0]++;\n\t\t\tpf[i+1][1]++;\n\t\t} else {\n\t\t\tpf[i+1][1] += 2;\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\trep(i, N) {\n\t\trep(j, i+1) if (dp[i][j] != 0) {\n\t\t\tint n0 = pf[i][0] + (S[i] != '2');\n\t\t\tint n1 = pf[i][1] + (S[i] != '0');\n\t\t\tint u0 = j, u1 = i - j;\n\t\t\tif (n0 >= u0 + 1) {\n\t\t\t\tadd(dp[i + 1][u0 + 1], dp[i][j]);\n\t\t\t}\n\t\t\tif (n1 >= u1 + 1) {\n\t\t\t\tadd(dp[i + 1][u0], dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i <= N; ++i) {\n\t\tint z0 = pf[N][0] - i;\n\t\tint z1 = N - z0;\n\t\tif (z0 >= 0 && z1 >= 0) {\n\t\t\tll t = dp[N][i] * comb[N][z0] % MOD;\n\t\t\tadd(ans, t);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(long long i=0; i<(long long)(n); i++)\n#define REP(i, k, n) for(long long i=(long long)(k); i<(long long)(n); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n#define PQ(T) priority_queue<T>\n#define PQS(T) priority_queue<T, vector<T>, greater<T> >\n#define deci cout << fixed << setprecision(15);\ntypedef long long ll;\nconst ll inf = 1020304050607080910;\nconst ll mod = 998244353;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T> bool chmin(T&x,T y){if(x>y){x=y;return true;}return false;}\ntemplate<class T> bool chmax(T&x,T y){if(x<y){x=y;return true;}return false;}\nll gcd(ll x,ll y){if(x>y)swap(x, y);while(x!=0){y%=x;swap(x, y);}return y;}\nll mpow(ll x,ll r){if(r==0)return 1;if(r%2==1){return x*mpow(x,r-1)%mod;}else{ll aa=mpow(x,r/2);return aa*aa%mod;}}\n\nll N, ans, dp[2020][2020], rs[2020], bs[2020];\nstring S;\n\nconst int MAX = 100002;\n\n// fac[]・・・a! finv[]・・・(a!)^(-1) inv[]・・・a^(-1)\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid pre_comb(void){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\nlong long comb(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\n\nint main(){\n\tpre_comb();\n\tcin >> S;\n\tN = S.size();\n\tif(S[0] == '0') dp[1][0] = 1, dp[0][1] = 0, rs[0] = 2, bs[0] = 0;\n\telse if(S[0] == '2') dp[1][0] = 0, dp[0][1] = 1, rs[0] = 0, bs[0] = 2;\n\telse dp[1][0] = 1, dp[0][1] = 1, rs[0] = 1, bs[0] = 1;\n\trep(i, N-1){\n\t\trs[i+1] = rs[i] + ('2' - S[i+1]);\n\t\tbs[i+1] = bs[i] + (S[i+1] - '0');\n\t}\n\tfor(int sum=2; sum<=N; sum++){\n\t\trep(j, sum+1){\n\t\t\tint i = sum-j;\n\t\t\tif(j==0){\n\t\t\t\tif(S[sum-1] < '2' || rs[sum-2] >= sum-j) dp[i][j] = dp[i-1][j];\n\t\t\t}else if(j==sum){\n\t\t\t\tif(S[sum-1] > '0' || bs[sum-2] >= j) dp[i][j] = dp[i][j-1];\n\t\t\t}else{\n\t\t\t\tif(S[sum-1] < '2' || rs[sum-2] >= sum-j) dp[i][j] += dp[i-1][j];\n\t\t\t\tif(S[sum-1] > '0' || bs[sum-2] >= j) dp[i][j] += dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][2] << dp[1][1] << dp[2][0] << endl;\n\trep(i, N+1) ans = (ans + comb(N, rs[N-1]-i) * dp[i][N-i] % mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mem(a,i) memset(a,i,sizeof(a))\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define per(i,a,b) for(int i=a;i>=b;--i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair<int,int> pii;\n\nconst ll mod=998244353ll;\nconst int maxn=2005;\nchar s[maxn];\nint n;\nll dp[maxn*2][maxn];\nll pre[maxn];\n\nint main() {\n    while(~scanf(\"%s\",s+1)) {\n        n=strlen(s+1);\n        mem(dp,0);\n        dp[0][0]=1;\n        pre[0]=0;\n        rep(i,1,n) {\n            ll temp=0;\n            if(s[i]=='0') temp=2;\n            else if(s[i]=='1') temp=1;\n            pre[i]=pre[i-1]+temp;\n        }\n        rep(i,1,2*n) {\n            rep(j,0,i) {\n                if(i<=n) {\n                    if((2*i-pre[i])-(i-1-j)>0) {\n                        dp[i][j]+=dp[i-1][j];\n                    }\n                    if(pre[i]-(j-1)>0&&j>0) {\n                        dp[i][j]+=dp[i-1][j-1];\n                    }\n                }\n                else {\n                    if((2*n-pre[n])-(i-1-j)>0) {\n                        dp[i][j]+=dp[i-1][j];\n                    }\n                    if(pre[n]-(j-1)>0&&j>0) {\n                        dp[i][j]+=dp[i-1][j-1];\n                    }\n                }\n                dp[i][j]%=mod;\n                // printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n            }\n        }\n        printf(\"%lld\\n\",dp[2*n][pre[n]]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=924844033;\n#define N 1055050\n\nll n,m,k,l;\nll a[N];\nll r[N];\nll suf[N],pre[N];\nll dp[4000][4000];\nmain(){\n    string s;\n    cin>>s;\n    n=s.size();\n    rep2(i,1,n){\n        a[i]=(s[i-1]-'0');\n        r[i]+=r[i-1]+a[i];\n    }\n    rep2(i,n+1,2*n+1)r[i]=r[i-1];\n    dp[0][0]=1;\n    rep2(i,1,n*2){\n        rep(j,i+1){\n            if(r[i]>=j&&i*2-r[i]>=i-j)\n            dp[i][j]=dp[i-1][j]+(j-1ll>=0ll?dp[i-1][j-1]:0);\n            dp[i][j]%=998244353ll;\n        }\n    }\n    ll sum=0;\n    cout<<dp[n*2][r[n]];\n}   "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\nconst ll MOD = 998244353;\n\nll dp[2001][2001];\n\nclass NCK {\nprivate:\n    ll m_mod;\n\npublic:\n    // mod must be a prime number\n    NCK(ll mod) : m_mod(mod) {}\n\n    // x^y % m_mod\n    ll modPow(ll x, ll y)\n    {\n        ll r = 1, a = x;\n        while (y > 0) {\n            if ((y & 1) == 1) {\n                r = (r * a) % m_mod;\n            }\n            a = (a * a) % m_mod;\n            y /= 2;\n        }\n        return r;\n    }\n\n    // a^-1 ≡ a^(p-2) (mod p)   (p is prime)\n    ll modInverse(ll x)\n    {\n        return modPow(x, m_mod - 2);\n    }\n\n    // Modular division x / y, find modular multiplicative inverse of y\n    // and multiply by x.\n    ll modDivision(ll p, ll q)\n    {\n        return (p * modInverse(q)) % m_mod;\n    }\n\n    // Binomial coifficient C(n,k) in O(k) time.\n    ll choose(ll n, ll k)\n    {\n        if (k > n) {\n            return 0;\n        }\n        ll p = 1, q = 1;\n        for (int i = 1; i <= k; i++) {\n            q = (q * i) % m_mod;\n            p = (p * (n - i + 1)) % m_mod;\n        }\n        return modDivision(p, q);\n    }\n\n    // make nCk table from 0C0 to nCn\n    vector<vector<ll>> makeNckTableFrom00ToNN(ll n_max) {\n        assert(n_max > 0);\n        vector<vector<ll>> table(n_max + 1, vector<ll>(n_max + 1));\n        table[0][0] = 1;\n        FOR(i, 1, n_max + 1) {\n            table[i][0] = 1;\n            FOR(j, 1, n_max + 1) {\n                table[i][j] = (table[i - 1][j - 1] + table[i - 1][j]) % m_mod;\n            }\n        }\n        return table;\n    }\n\n    // make nCk table from nC0 to nCn\n    vector<ll> makeNckTableFromN0ToNN(ll n, ll k_max) {\n        assert(n > 0);\n        assert(n >= k_max);\n        vector<ll> table(n + 1);\n        table[0] = 1;\n        ll p = 1, q = 1;\n        table[0] = 1;\n        FOR(i, 1, k_max + 1) {\n            q = (q * i) % m_mod;\n            p = (p * (n - i + 1)) % m_mod;\n            table[i] = modDivision(p, q);\n        }\n        return table;\n    }\n\n    // make nCk table from n1Ck to n2Ck\n    vector<ll> makeTableFromN1CkToN2Ck(ll n1, ll n2, ll k) {\n        vector<ll> table;\n        ll tmp = -1;\n        FOR(n, n1, n2 + 1) {\n            if (n == n1) {\n                tmp = this->choose(n, k);\n            }\n            else {\n                tmp *= n;\n                tmp %= this->m_mod;\n                tmp = this->modDivision(tmp, n - k);\n            }\n            table.pb(tmp);\n        }\n        return table;\n    }\n\n    // make modInverse table from 0 to n_max\n    vector<ll> makeModInverseTable(ll n_max) {\n        assert(n_max > 0);\n        vector<ll> table(n_max + 1);\n        FOR(i, 1, n_max + 1) {\n            table[i] = modInverse(i);\n        }\n        return table;\n    }\n};\n\nint main(void)\n{\n    cin.sync_with_stdio(false);\n    string S;\n    cin >> S;\n    int N = SIZE(S);\n    vector<int> red(N);\n    vector<int> blue(N);\n    vector<int> red_sum(N);\n    vector<int> blue_sum(N);\n    REP(n, N) {\n        auto ch = S[n];\n        if (ch == '0') {\n            red[n] = 2;\n        }\n        else if (ch == '1') {\n            red[n] = 1;\n            blue[n] = 1;\n        }\n        else {\n            blue[n] = 2;\n        }\n        if (n == 0) {\n            red_sum[n] = red[n];\n            blue_sum[n] = blue[n];\n        }\n        else {\n            red_sum[n] = red_sum[n-1] + red[n];\n            blue_sum[n] += blue_sum[n-1] + blue[n];\n        }\n    }\n\n\n\n    REP(n, N) {\n        auto r = red[n];\n        auto b = blue[n];\n        if (n == 0) {\n            if (r > 0) {\n                dp[n][1] = 1;\n            }\n            if (b > 0) {\n                dp[n][0] = 1;\n            }\n        }\n        else {\n            REP(used_red, n + 1) {\n                if (dp[n - 1][used_red] == 0) continue;\n                auto red_prev = red_sum[n - 1];\n                auto blue_prev = blue_sum[n - 1];\n\n                auto used_blue = n - used_red;\n\n                auto red_avail = (red_prev - used_red) + red[n];\n                auto blue_avail = (blue_prev - used_blue) + blue[n];\n\n                if (red_avail > 0) {\n                    dp[n][used_red + 1] += dp[n - 1][used_red];\n                    dp[n][used_red + 1] %= MOD;\n                }\n                if (blue_avail > 0) {\n                    dp[n][used_red] += dp[n - 1][used_red];\n                    dp[n][used_red] %= MOD;\n                }\n                //cout << \"dp[\" << n << \"][\" << used_red << \"] = \" <<\n                //    dp[n][used_red] << endl;\n            }\n        }\n    }\n\n    ll ans = 0;\n    NCK nck(MOD);\n    REP(used_red, N + 1) {\n        auto used_blue = N - used_red;\n        auto red_avail = red_sum[N - 1] - used_red;\n        auto blue_avail = blue_sum[N - 1] - used_blue;\n\n        ans += dp[N - 1][used_red] * nck.choose(red_avail + blue_avail, red_avail);\n        ans %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 998244353;\nstruct Box {\n    map<pair<int, int>, Int> M;\n    Box() {\n        M[make_pair(0, 0)] = 1;\n    }\n    void push(bool b) {\n        map<pair<int, int>, Int> M2;\n        for (auto &p : M) {\n            auto pp = make_pair(p.first.first + (b == false), p.first.second + (b == true));\n            M2[pp] = p.second;\n        }\n        M.swap(M2);\n    }\n    void pop() {\n        map<pair<int, int>, Int> M2;\n        for (auto &p : M) {\n            if (p.first.first > 0) {\n                M2[make_pair(p.first.first - 1, p.first.second)] += p.second;\n                M2[make_pair(p.first.first - 1, p.first.second)] %= MOD;\n            }\n            if (p.first.second > 0) {\n                M2[make_pair(p.first.first, p.first.second - 1)] += p.second;\n                M2[make_pair(p.first.first, p.first.second - 1)] %= MOD;\n            }\n        }\n        M.swap(M2);\n    }\n    Int number() {\n        Int sum = 0;\n        for (auto &p : M) sum += p.second;\n        return sum % MOD;\n    }\n};\nint main() {\n    string S; cin >> S;\n    Box B;\n    for (int i = 0; i < S.size(); i++) {\n        int t = S[i] - '0';\n        if (t == 0) B.push(false), B.push(false);\n        if (t == 1) B.push(false), B.push(true);\n        if (t == 2) B.push(true), B.push(true);\n        B.pop();\n    }\n    for (int i = 0; i < S.size(); i++) {\n        B.pop();\n    }\n    cout << B.number() << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\n#define next asdnext\n#define prev asdprev\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T1, typename T2> bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ >= 0 ? val_ % MOD : (MOD - (-val_) % MOD) % MOD) {}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return mod_int(-val); }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        int a = MOD, b = val, u = 0, v = 1;\n        while (b > 0) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * v, v);\n        }\n        return mod_int(u);\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nstring S;\nint N;\nusing mint=mod_int<998244353>;\nmint dp[4400][4400];\nsigned main() {\n    cin >> S;\n    N = S.length();\n    vint rlim(2 * N), blim(2 * N);\n    rep(i, N) {\n        if (S[i] == '0') { rlim[i + 1] = rlim[i] + 2, blim[i + 1] = blim[i]; }\n        if (S[i] == '1') { rlim[i + 1] = rlim[i] + 1, blim[i + 1] = blim[i] + 1; }\n        if (S[i] == '2') { rlim[i + 1] = rlim[i], blim[i + 1] = blim[i] + 2; }\n    }\n    rep(i, N) { rlim[i + N + 1] = rlim[i + N], blim[i + N + 1] = blim[i + N]; }\n    dp[0][0] = 1;\n    reps(i, 2 * N) {\n        for (int j = 0; j <= 2 * N; j++) {\n            if (j > rlim[i] || i - j > blim[i]) { continue; }\n            dp[i][j] = dp[i - 1][j];\n            if (j != 0) { dp[i][j] += dp[i - 1][j - 1]; }\n        }\n    }\n    cout << dp[2 * N][rlim[2 * N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define pb(a) push_back\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), n)\n#define ub(v,n) upper_bound(v.begin(), v.end(), n)\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\n#define move(x) ans.push_back(x),c[x]--,now=x;\n \ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\nconst int MOD = 998244353; const int MAX = 200020;\nconst double pi = acos(-1); const double EPS = 1e-12;\nconst ll INF = 2e18;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\n\nint dp[2020][2020];\nint cumR[2020];\nint A[2020],B[2020];\nint sumR,sumB;\nvoid solve() {\n\tstring S;cin>>S;\n\tint N=S.size();\n\tCOMinit();\n\tREP(i,N){\n\t\tint num=S[i]-'0';\n\t\tA[i]+=num;\n\t\tB[i]+=2-num;\n\t\tcumR[i+1]+=cumR[i]+A[i];\n\t\tsumR+=A[i];\n\t\tsumB+=B[i];\n\t}\n\tdp[0][0]=1;\n\tREP(i,N){\n\t\tREP(r,N+1){\n\t\t\tif(r>0&&cumR[i+1]>=r)dp[i+1][r]+=dp[i][r-1];\n\t\t\tint cumB=(i+1)*2-cumR[i+1];\n\t\t\tif(cumB>=i+1-r)dp[i+1][r]+=dp[i][r];\n\t\t\tassert(dp[i+1][r]>=0);\n\t\t\t//pe(i+1);pe(r);print(dp[i+1][r]);\n\t\t}\n\t}\n\tll ans=0;\n\n\tREP(r,N+1){\n\t\tll res=mult(dp[N][r],fac[N]);\n\t\tres=mult(res,mult(finv[sumR-r],finv[sumB-(N-r)]));\n\t\tans=add(ans,res);\n\t}\n\tprint(ans);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n     \nconst int maxn(4005);\nconst int mod(998244353);\n\ninline void Inc(int &x, int y) {\n    x = x + y >= mod ? x + y - mod : x + y;\n}\n\ninline void Dec(int &x, int y) {\n    x = x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Add(int x, int y) {\n    return x + y >= mod ? x + y - mod : x + y;\n}\n\ninline int Sub(int x, int y) {\n    return x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Pow(ll x, int y) {\n    ll ret = 1;\n    for (; y; y >>= 1, x = x * x % mod)\n        if (y & 1) ret = ret * x % mod;\n    return ret;\n}\n\nint n, fac[100000], inv[100000], ans, f[maxn][maxn];\nchar s[maxn];\n\ninline int C(int x, int y) {\n\tif (x < 0 || y < 0 || y > x) return 0;\n\treturn (ll)fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main() {\n\tint i, j, k, cb, cr, mx = 99999;\n\tinv[0] = inv[1] = 1;\n    for (i = 2; i <= mx; ++i) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;\n    for (i = 2; i <= mx; ++i) inv[i] = (ll)inv[i - 1] * inv[i] % mod;\n    for (i = fac[0] = 1; i <= mx; ++i) fac[i] = (ll)fac[i - 1] * i % mod;\n\tscanf(\" %s\", s + 1), n = strlen(s + 1);\n\tf[0][0] = 1, cb = cr = 0;\n\tfor (i = 1; i <= n; ++i) {\n\t\tif (s[i] == '0') cr += 2;\n\t\telse if (s[i] == '1') ++cr, ++cb;\n\t\telse cb += 2;\n\t\tfor (j = 0; j <= min(cr, i); ++j) {\n\t\t\tif (i - j > cb) continue;\n\t\t\tif (j) Inc(f[i][j], f[i - 1][j - 1]);\n\t\t\tInc(f[i][j], f[i - 1][j]);\n\t\t}\n\t}\n\tfor (j = 0; j <= min(cr, n); ++j) Inc(ans, (ll)f[n][j] * C(n, cr - j) % mod);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nlong mo(long n){\n\t\treturn n%998244353;\n\t}\nvoid vl(const char& a,int& r,int& b){\n\tif(a=='0'){r+=2;}\n\telse if(a=='1'){r++;b++;}\n\telse if(a=='2'){b+=2;}\n\telse{}\n}\n\nint main(){//F\n\tstring s;\n\tconst int c=21;\n\tcin>>s;\n\tint le=s.length();\n\tlong liba[2*c+1][2*c]={};//[i][j][k]iはi番目の箱jは赤個数\n\tliba[0][0]=1;\n\tint va[c*2][2]={};\n\tfor(int i=0;i<le;i++){\n\t\tvl(s[i],va[i][0],va[i][1]);\n\t\tif(i>0){\n\t\t\tva[i][0]+=va[i-1][0];\n\t\t\tva[i][1]+=va[i-1][1];\n\t\t}\n\t}\n\tfor(int i=0;i<le;i++)\n\t{\n\t\tva[le+i][0]=va[le+i-1][0];\n\t\tva[le+i][1]=va[le+i-1][1];\n\t}\n\tfor(int i=0;i<(2*le);i++)\n\t{\n\t\tfor(int j=0;j<2*le;j++)\n\t\t\t{\t\n\t\t\t\tif((j<=va[i][0])&&(i-j+1<=va[i][1])&&(i-j+1>=0))\n\t\t\t\t{\n\t\t\t\t\tliba[i+1][j]=mo(liba[i][j]+((j>0)?liba[i][j-1]:0));\n\t\t\t\t}\n\t\t\t}\n\t}\n\tlong cnt=0;\n\tfor(int i=0;i<le*2;i++)\n\t{\n\t\tcnt=mo(cnt+liba[le*2][i]);\n\t}\n\tcout<<cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 2010\n#define P 998244353\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,a[N],u,v,s[N][2],f[N<<1][N<<1];\nchar S[N];\nvoid inc(int &x,int y){x+=y;if (x>=P) x-=P;}\nint main()\n{\n\tscanf(\"%s\",S+1);\n\tn=strlen(S+1);\n\tfor (int i=1;i<=n;i++) a[i]=S[i]-'0';\n\tfor (int i=1;i<=n;i++) u+=2-a[i],v+=a[i];\n\tfor (int i=1;i<=n;i++) s[i][0]=s[i-1][0]+2-a[i],s[i][1]=s[i-1][1]+a[i];\n\tf[0][0]=1;\n\tfor (int i=0;i<=u;i++)\n\t\tfor (int j=0;j<=v;j++)\n\t\tif (i|j)\n\t\t{\n\t\t\tif (s[min(n,i+j)][0]>=i&&s[min(n,i+j)][1]>=j)\n\t\t\t{\n\t\t\t\tif (i) inc(f[i][j],f[i-1][j]);\n\t\t\t\tif (j) inc(f[i][j],f[i][j-1]);\n\t\t\t}\n\t\t}\n\tcout<<f[u][v];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(ll i = (ll)(s); i < (ll)(t); i++)\n#define rrep(i,s,t) for(ll i = (ll)(s-1);(ll)(t) <= i; i--)\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nconstexpr ll INF = numeric_limits<ll>::max()/4;\nconstexpr ll n_max = 2e5+10;\n#define int ll\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) {return '\"' + s + '\"';}\nstring to_string(const char *c) {return to_string((string) c);}\nstring to_string(bool b) {return (b ? \"true\" : \"false\");}\ntemplate <size_t N>\nstring to_string(bitset<N> v){\n    string res = \"\";\n    for(size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n    return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for(const auto &x : v) {\n        if(!first) res += \", \";\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p){return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\n\nvoid debug_out() {cerr << endl;}\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<class T>\nbool chmax(T &a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<class T>\nbool chmin(T &a, T b){if(a > b){a = b; return true;} return false;}\n\ntemplate<std::int_fast64_t Modulus>\nclass modint {\n    using i64 = int_fast64_t;\n\n    public:\n    i64 a;\n\n    constexpr modint(const i64 x = 0) noexcept {\n        this -> a = x % Modulus;\n        if(a < 0){\n            a += Modulus;\n        }\n    }\n    constexpr int getmod() { return Modulus; }\n    constexpr modint operator - () const noexcept {\n        return a ? Modulus - a : 0;\n    }\n    constexpr const i64 &value() const noexcept {return a;}\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if(a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if(a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        i64 a_ = rhs.a, b = Modulus, u = 1, v = 0;\n        while(b){\n            i64 t = a_/b;\n            a_ -= t * b; swap(a_,b);\n            u -= t * v; swap(u,v);\n        }\n        a = a * u % Modulus;\n        if(a < 0) a += Modulus;\n        return *this;\n    }\n    \n    // 自前実装\n    constexpr bool operator==(const modint rhs) noexcept {\n        return a == rhs.a;\n    }\n    constexpr bool operator!=(const modint rhs) noexcept {\n        return a != rhs.a;\n    }\n    constexpr bool operator>(const modint rhs) noexcept {\n        return a > rhs.a;\n    }\n    constexpr bool operator>=(const modint rhs) noexcept {\n        return a >= rhs.a;\n    }\n    constexpr bool operator<(const modint rhs) noexcept {\n        return a < rhs.a;\n    }\n    constexpr bool operator<=(const modint rhs) noexcept {\n        return a <= rhs.a;\n    }\n    constexpr modint& operator++() noexcept {\n        return (*this) += modint(1);\n    }\n    // constexpr modint operator++(int) {\n    //     modint tmp(*this);\n    //     operator++();\n    //     return tmp;\n    // }\n    constexpr modint& operator--() noexcept {\n        return (*this) -= modint(1);\n    }\n    // constexpr modint operator--(int) {\n    //     modint tmp(*this);\n    //     operator--();\n    //     return tmp;\n    // }\n    template<typename T>\n    friend constexpr modint modpow(const modint &mt, T n) noexcept {\n        if(n < 0){\n            modint t = (modint(1) / mt);\n            return modpow(t, -n);\n        }\n        modint res = 1, tmp = mt;\n        while(n){\n            if(n & 1)res *= tmp;\n            tmp *= tmp;\n            n /= 2;\n        }\n        return res;\n    }\n\n    friend constexpr string to_string(const modint &mt) noexcept {\n        return to_string(mt.a);\n    }\n};\n\n// 標準入出力対応\ntemplate<std::int_fast64_t Modulus>\nstd::ostream &operator<<(std::ostream &out, const modint<Modulus> &m) {\n    out << m.a;\n    return out;\n}\ntemplate<std::int_fast64_t Modulus>\nstd::istream &operator>>(std::istream &in, modint<Modulus> &m) {\n    ll a;\n    in >> a;\n    m = modint<Modulus>(a);\n    return in;\n}\n\n// const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nusing mint = modint<MOD>;\nsigned main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;cin >> s;\n    ll n = s.size();\n    vector<ll> v(n);\n    rep(i,0,n){\n        v[i] = s[i] - '0';\n    }\n    vector dp(2*n+1, vector<mint>(2*n+10));\n    dp[0][0] = 1;\n    ll num = 0, all = 0;\n    rep(i,0,n*2){\n        if(i < n){\n            num += v[i];\n            all += 2;\n        }\n        rep(j,0,i+2){\n            if(j && num >= j)dp[i+1][j] += dp[i][j-1];\n            if(all - num >= i - j + 1) dp[i+1][j] += dp[i][j];\n        }\n    }\n\n    debug(dp);\n\n    cout << dp[2*n][num] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353;//1000000007;\n\n\n\n\nint main(){\n    string s;\n    cin>>s;\n    vector<ll> cnt0,cnt1;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='0'){cnt0.push_back(i); cnt0.push_back(i);}\n        else if(s[i]=='1'){cnt0.push_back(i); cnt1.push_back(i);}\n        else{cnt1.push_back(i); cnt1.push_back(i);}\n    }\n    vector<vector<ll>> dp(2*s.size()+1,vector<ll>(2*s.size()+1,0));\n    dp[0][0]=1;\n    for(int i=0;i<2*s.size();i++){\n        for(int t=0;t<2*s.size();t++){\n            if(cnt1.size()>=t+1 && cnt1[t]<=i){\n                dp[i+1][t+1]+=dp[i][t];\n                dp[i+1][t+1]%=MOD;\n            }\n            if(cnt0.size()>=i-t+1 && i-t>=0 && cnt0[i-t]<=i){\n                dp[i+1][t]+=dp[i][t];\n                dp[i+1][t]%=MOD;\n            }\n        }\n    }\n    ll sum=0;\n    for(int i=0;i<=2*s.size();i++){\n        sum+=dp[2*s.size()][i];\n    }\n    cout<<sum%MOD<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  int mb = 0, mr = 0;\n  rep (i, n) {\n    if (s[i] == '0') mr += 2;\n    else if (s[i] == '1') {mr++; mb++;}\n    else {mb += 2;}\n  }\n  vll dp(mr + 1, vl(mb + 1));\n  dp[0][0] = 1;\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (dp[i][j] == 0) continue;\n      if (i > mr || j > mb) continue;\n      int b = 0, r = 0;\n      if (s[can] == '0') {\n        r = 2;\n      }\n      else if (s[can] == '1') {\n        r = b = 1;\n      }\n      else if (s[can] == '2') {\n        b = 2;\n      }\n      int ni = i + r, nj = j + b;\n      if (ni > 0 && ni - 1 <= mr && nj <= mb) {\n        (dp[ni - 1][nj] += dp[i][j]) %= MOD;\n      }\n      if (nj > 0 && ni <= mr && nj - 1 <= mb) {\n        (dp[ni][nj - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (i > mr || j > mb) continue;\n      dp[i][j] = 0;\n    }\n  }\n  for (int can = n; can > 0; can--) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (i > mr || j > mb) continue;\n      if (dp[i][j] == 0) continue;\n      if (i > 0) {\n        (dp[i - 1][j] += dp[i][j]) %= MOD;\n      }\n      if (j > 0) {\n        (dp[i][j - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#include <cassert>\n#define MOD (long)(998244353)\n#define MAX 2000000  // 階乗をいくつまで計算するか\n\nclass modlong {\n    long val;\n    static const long mod = MOD;\n    static long *invs, *facts, *finvs;\n\n    // 階乗, 逆元, 階乗の逆元をMAXまで求める\n    bool initModlong() {\n        invs[1] = \n        facts[0] = facts[1] =\n        finvs[0] = finvs[1] = 1;\n        for (int i=2; i<=MAX; i++) {\n            invs[i]  = -invs[MOD % i] * (MOD / i) % MOD;\n            facts[i] = facts[i - 1] * i % MOD;\n            finvs[i] = finvs[i - 1] * invs[i] % MOD;\n        }\n        return true;\n    }\n\npublic:\n    // 初期化 値を引数に与えなかった場合はval=0としておく\n    modlong(long init = 0) : val(init) {\n        static bool call_once = initModlong(); // static変数の性質により一度だけ呼ばれる\n        assert(call_once); // unusedの回避\n        if (val < 0 || val >= mod) val %= mod;\n        if (val < 0) val += mod;   // 0以上であることを保証\n    }\n\n    // longへのキャスト operator long()で定義すると modlong +\n    // longとかができなくなる\n    inline long tol() { return this->val; }\n\n    // 代入\n    void operator=(const modlong &r) { this->val = r.val; }\n    void operator=(const long &r) { *this = modlong(r); }\n\n    // 足し算; 符号反転; 引き算\n    modlong operator+(const modlong &r) {\n        long ans = this->val + r.val;\n        if (ans >= mod) ans -= mod;\n        return modlong(ans);\n    }\n    modlong operator-() {\n        long ans = mod - this->val;\n        return modlong(ans);\n    }\n    modlong operator-(const modlong &r) {\n        modlong rr = r;\n        return *this + (-rr);\n    }\n\n    //かけ算; 逆元; わり算\n    modlong operator*(const modlong &r) {\n        long ans = this->val * r.val;\n        return modlong(ans);\n    }\n    modlong inv() {\n        assert(*this != 0);\n        if (*this == 1) return modlong(1);\n\n        modlong p, q = *this, m(0), n(1), r, c;\n        p.val = mod;  // p=modとかくとp.val=mod%mod=0となってしまう\n        while (q > MAX) {\n            r = p.val % q.val;  // r.val=p.val % q.val\n                                // とかくよりもこのほうが代入時に%modされるので安全\n            c = m.val - n.val * (p.val / q.val);\n            p = q, q = r, m = n, n = c;\n        }\n        return n * invs[q.val];\n    }\n    modlong operator/(const modlong &r) { return *this * modlong(r).inv(); }\n\n    // ++ -- 前付きと後ろ付き\n    void operator++() { ++this->val; }\n    void operator++(int a) {\n        a = 0;\n        this->val++;\n    }  // a使ってなくねっていうwarningをsilenceするためにaをいじってる\n    void operator--() { --this->val; }\n    void operator--(int a) {\n        a = 0;\n        this->val--;\n    }\n\n    // 四則演算&代入\n    void operator+=(const modlong &r) { *this = *this + r; }\n    void operator-=(const modlong &r) { *this = *this - r; }\n    void operator*=(const modlong &r) { *this = *this * r; }\n    void operator/=(const modlong &r) { *this = *this / r; }\n\n    // べき乗\n    modlong pow(long n) {\n        if (n < 0)\n            return inv().pow(-n);  // 逆元の-n乗\n        else if (n == 0)\n            return modlong(1);\n\n        modlong half = pow(n / 2);\n        if (n % 2)\n            return *this * half * half;\n        else\n            return half * half;\n    }\n    modlong pow(modlong n) { return pow(n.val); }\n\n    // コンビネーション\n    modlong comb(modlong _k) {\n        assert(this->val <= MAX);\n        const long n = this->val, k = _k.val;\n        if (k < 0 || k > n) return 0;\n        if (k == 0 || k == n) return 1;\n        return modlong(facts[n]) * finvs[k] * finvs[n - k];\n    }\n\n    // 階乗\n    modlong fact() { \n        assert(this->val <= MAX);\n        return modlong(facts[this->val]);\n    }\n\n    friend bool operator<(const modlong &l, const modlong &r);\n    friend bool operator>(const modlong &l, const modlong &r);\n    friend bool operator==(const modlong &l, const modlong &r);\n    friend bool operator!=(const modlong &l, const modlong &r);\n    friend bool operator<=(const modlong &l, const modlong &r);\n    friend bool operator>=(const modlong &l, const modlong &r);\n    friend ostream &operator<<(ostream &os, const modlong &out);\n    friend istream &operator>>(istream &is, modlong &out);\n};\n\n//比較\nbool operator<(const modlong &l, const modlong &r) { return l.val < r.val; }\nbool operator>(const modlong &l, const modlong &r) { return l.val > r.val; }\nbool operator==(const modlong &l, const modlong &r) { return l.val == r.val; }\nbool operator!=(const modlong &l, const modlong &r) { return !(l == r); }\nbool operator<=(const modlong &l, const modlong &r) { return !(l > r); }\nbool operator>=(const modlong &l, const modlong &r) { return !(l < r); }\n\n// cout、cerr、cin用の演算子たち\nostream &operator<<(ostream &os, const modlong &out) {\n    os << out.val;\n    return os;\n}\nistream &operator>>(istream &is, modlong &in) {\n    long inl;\n    is >> inl;\n    in.val = inl % MOD;\n    return is;\n}\n\n// コンビネーション\ninline modlong modComb(long n, long k) { return modlong(n).comb(k); }\n// 階乗\ninline modlong modFact(long n) { return modlong(n).fact(); }\n\n// static変数たち\nlong *modlong::invs  = new long[MAX+1],\n     *modlong::facts = new long[MAX+1],\n     *modlong::finvs = new long[MAX+1];\n\nmodlong dp[2001][2001] = {{0}};\n\nint main() {\n    string s;\n    cin >> s;\n    dp[0][0] = 1;\n    int n = s.size();\n    for (int i=0; i<n; i++) {\n        int b = s[i] - '0';\n        for (int j=0; j<=i; j++) {\n            int x = j+b, y = i-j+2-b;\n            if (x > 0) dp[x-1][y] += dp[j][i-j];\n            if (y > 0) dp[x][y-1] += dp[j][i-j];\n        }\n    }\n    modlong ans = 0;\n    for (int i=0; i<=n; i++)\n        ans += dp[i][n-i] * modComb(n, i);\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string &str, vector<int> &z, ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n// ローリングハッシュ\n// 二分探索で LCP を求める機能つき\nstruct RollingHash {\n\tstatic const int base1 = 1007, base2 = 2009;\n\tstatic const int mod1 = 1000000007, mod2 = 1000000009;\n\tvector<long long> hash1, hash2, power1, power2;\n\n\t// construct\n\tRollingHash(const string& S) {\n\t\tint n = (int)S.size();\n\t\thash1.assign(n + 1, 0);\n\t\thash2.assign(n + 1, 0);\n\t\tpower1.assign(n + 1, 1);\n\t\tpower2.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash1[i + 1] = (hash1[i] * base1 + S[i]) % mod1;\n\t\t\thash2[i + 1] = (hash2[i] * base2 + S[i]) % mod2;\n\t\t\tpower1[i + 1] = (power1[i] * base1) % mod1;\n\t\t\tpower2[i + 1] = (power2[i] * base2) % mod2;\n\t\t}\n\t}\n\n\t// get hash of S[left:right]\n\tinline pair<long long, long long> get(int l, int r) const {\n\t\tlong long res1 = hash1[r] - hash1[l] * power1[r - l] % mod1;\n\t\tif (res1 < 0) res1 += mod1;\n\t\tlong long res2 = hash2[r] - hash2[l] * power2[r - l] % mod2;\n\t\tif (res2 < 0) res2 += mod2;\n\t\treturn { res1, res2 };\n\t}\n\n\t// get lcp of S[a:] and T[b:]\n\tinline int getLCP(int a, int b) const {\n\t\tint len = min((int)hash1.size() - a, (int)hash1.size() - b);\n\t\tint low = 0, high = len;\n\t\twhile (high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif (get(a, a + mid) != get(b, b + mid)) high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\treturn low;\n\t}\n};\n\nll mod_pow(ll x, ll n,ll mod) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n//NTT\nll _garner(Array& xs, Array& mods) {\n\tint M = xs.size();\n\n\tArray coeffs(M, 1), constants(M, 0);\n\n\tfor (int i = 0; i < M - 1; ++i) {\n\t\tll mod_i = mods[i];\n\t\t// coffs[i] * v + constants[i] == mr[i].val (mod mr[i].first) を解く\n\t\tll v = (xs[i] - constants[i] + mod_i) % mod_i;\n\t\tv = (v * mod_pow(coeffs[i], mod_i - 2, mod_i)) % mod_i;\n\n\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\tll mod_j = mods[j];\n\t\t\tconstants[j] = (constants[j] + coeffs[j] * v) % mod_j;\n\t\t\tcoeffs[j] = (coeffs[j] * mod_i) % mod_j;\n\t\t}\n\t}\n\n\treturn constants.back();\n}\n\ntemplate<typename T>\ninline void bit_reverse(vector<T>& a) {\n\tint n = a.size();\n\tint i = 0;\n\tfor (int j = 1; j < n - 1; ++j) {\n\t\tfor (int k = n >> 1; k > (i ^= k); k >>= 1);\n\t\tif (j < i) swap(a[i], a[j]);\n\t}\n}\n\ntemplate<long long mod, long long primitive_root>\nclass NTT {\npublic:\n\tlong long get_mod() { return mod; }\n\n\tvoid _ntt(vector<long long>& a, int sign) {\n\t\tconst int n = a.size();\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst long long g = primitive_root; // g is primitive root of mod\n\n\t\tlong long tmp = (mod - 1) * mod_pow(n, mod - 2, mod) % mod; // -1/n\n\t\tlong long h = mod_pow(g, tmp, mod); // ^n√g\n\t\tif (sign == -1) h = mod_pow(h, mod-2,mod);\n\n\t\tbit_reverse(a);\n\n\t\tfor (int m = 1; m < n; m <<= 1) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tlong long _base = mod_pow(h, n / m2, mod);\n\t\t\tlong long _w = 1;\n\t\t\tfor (int x = 0; x < m; ++x) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tlong long u = a[s];\n\t\t\t\t\tlong long d = (a[s + m] * _w) % mod;\n\t\t\t\t\ta[s] = (u + d) % mod;\n\t\t\t\t\ta[s + m] = (u - d + mod) % mod;\n\t\t\t\t}\n\t\t\t\t_w = (_w * _base) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ntt(vector<long long>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<long long>& input) {\n\t\t_ntt(input, -1);\n\n\t\tconst long long n_inv = mod_pow(input.size(), mod - 2, mod);\n\t\tfor (auto &x : input) x = (x * n_inv) % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<long long> convolution(const vector<long long>& a, const vector<long long>& b) {\n\t\tint result_size = a.size() + b.size() - 1;\n\t\tint n = 1; while (n < result_size) n <<= 1;\n\n\t\tvector<long long> _a = a, _b = b;\n\t\t_a.resize(n, 0);\n\t\t_b.resize(n, 0);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\t\tfor (int i = 0; i < n; ++i) _a[i] = (_a[i] * _b[i]) % mod;\n\t\tintt(_a);\n\n\t\t_a.resize(result_size);\n\t\treturn _a;\n\t}\n};\n\nvector<long long> convolution_ntt(vector<long long>& a, vector<long long>& b, long long mod = 1224736769LL) {\n\tfor (auto &x : a) x %= mod;\n\tfor (auto &x : b) x %= mod;\n\n\tll maxval = max(a.size(), b.size()) * *max_element(a.begin(), a.end()) * *max_element(b.begin(), b.end());\n\tif (maxval < 1224736769) {\n\t\tNTT<1224736769, 3> ntt3;\n\t\treturn ntt3.convolution(a, b);\n\t}\n\n\tNTT<167772161, 3> ntt1;\n\tNTT<469762049, 3> ntt2;\n\tNTT<1224736769, 3> ntt3;\n\n\tvector<long long> x1 = ntt1.convolution(a, b);\n\tvector<long long> x2 = ntt2.convolution(a, b);\n\tvector<long long> x3 = ntt3.convolution(a, b);\n\n\tvector<long long> ret(x1.size());\n\tvector<long long> mods{ 167772161, 469762049, 1224736769, mod };\n\tfor (int i = 0; i < x1.size(); ++i) {\n\t\tvector<long long> xs{ x1[i], x2[i], x3[i], 0 };\n\t\tret[i] = _garner(xs, mods);\n\t}\n\n\treturn ret;\n}\n\nll dp[4010][4010];\nll ma[4010];\nll ma2[4010];\nconst ll mod = 998244353;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\tcin >> s;\n\tREP(i, s.size()) {\n\t\tif (s[i] != '2')ma[i + 1] += ma[i]+1;\n\t\telse ma[i + 1] += ma[i];\n\n\t\tif (s[i] != '0')ma2[i + 1] += ma2[i] + 1;\n\t\telse ma2[i + 1] += ma2[i];\n\t\t\n\t\tif (s[i] == '0')ma[i + 2] += 1;\n\t\tif (s[i] == '2')ma2[i + 2] += 1;\n\t}\n\trep(i, s.size(), s.size() * 2)ma[i + 1] += ma[i];\n\trep(i, s.size(), s.size() * 2)ma2[i + 1] += ma2[i];\n\n\tdp[0][0] = 1;\n\tREP(i, s.size() * 2) {\n\t\tREP(j, s.size() * 2) {\n\t\t\tif (ma[i+1] > j)(dp[i + 1][j + 1] += dp[i][j]) %= mod;\n\t\t\tif(ma2[i+1]>i-j)(dp[i + 1][j] += dp[i][j]) %= mod;\n\t\t}\n\t}\n\tcout << dp[s.size() * 2][ma[s.size() * 2]] << endl;\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = 998244353;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\nInt N;\nvector<Int> A, B;\n\n_int used[4010][4010], mem[4010][4010];\n\nInt dfs(Int x, Int a, Int b, Int p, Int q){\n  while(p < N && A[p] == 0) p++;\n  while(q < N && B[q] == 0) q++;\n\n  //pr(x, a, b, p, q);\n  \n  if(p == N || q == N) return 1;\n  if(used[x][a]++) return mem[x][a];\n\n  Int cnt1 = 0, cnt2 = 0;\n  if(p <= x){\n  A[p]--;\n  cnt1 = dfs(x + 1, a + 1, b, p, q);\n  A[p]++;\n  }\n\n  if(q <= x){\n    B[q]--;\n    cnt2 = dfs(x + 1, a, b + 1, p, q);\n    B[q]++;\n  }\n\n  return mem[x][a] = (cnt1 + cnt2)%mod;\n}\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string s;\n  cin>>s;\n  N = s.size();\n  A.resize(N);\n  B.resize(N);\n\n  for(Int i=0;i<N;i++){\n    if(s[i] == '0') A[i] = 2, B[i] = 0;\n    if(s[i] == '1') A[i] = 1, B[i] = 1;\n    if(s[i] == '2') A[i] = 0, B[i] = 2;\n  }\n\n\n  Int ans = dfs(0, 0, 0, 0, 0);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(n);++i)\n#define rrep(i,n) for(int (i)=(n)-1;(i)>=0;--i)\n#define rep1(i,n) for(int (i)=1;(i)<=(n);++i)\n#define rrep1(i,n) for(int (i)=(n);(i)>=1;--i)\n#define pb push_back\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> LP;\ntypedef double db;\nusing namespace std;\nstring s;\nll ans;\nll A[2001];\nll dp[4001][4001];\nll cnt=0;\nll mod = 998244353;\nll N,r,b;\nint main()\n{\n  cin>>s;\n  N=s.size();\n  rep(i,N){\n    A[i+1]=0;\n    if(s[i]=='1') A[i+1]=1;\n    else if(s[i]=='2') A[i+1]=2;\n  }\n  //rep1(i,N) cout<<A[i]<<endl;\n  //cout<<\"asd\"<<endl;\n  dp[0][0] = 1;\n  rep1(i,2*N){\n    if(i<=N) cnt+=2;\n    rep(j,2*N){ // dp[i-1][j]\n      r = j+A[i];\n      b = cnt-r;\n      if(b > 0) dp[i][r] = (dp[i][r]+dp[i-1][j])%mod; //青\n      if(r > 0)  dp[i][r-1] = (dp[i][r-1] + dp[i-1][j])%mod;\n    }\n    cnt-=1;\n  }\n  // rep(i,2*N+1){\n  //   rep(j,2*N+1){\n  //     cout<<dp[i][j]<<\"a\"<<i<<\"b\"<<j<<endl;\n  //   }\n  // }\n  cout<<dp[2*N][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <cstdlib> //������������ڴ���亯��\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ�����������/���\n#include <cwctype.h> //���ַ�����*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a)if (b&1) r=r*a;return r;}\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n\twhile(z[++Z]=x%10+48,x/=10);\n\twhile(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n//int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nconst int mod=998244353,N=2020;\nint n,m,f[N*2][N*2],sum[N][2];\n\nint main()\n{\n\tchar c=read();\n\twhile (!isdigit(c)) c=read();\n\twhile (isdigit(c))\n\t{\n\t\tn++;\n\t\tif (c=='0') sum[n][0]+=2;\n\t\telse\n\t\tif (c=='1') sum[n][0]++,sum[n][1]++;\n\t\telse sum[n][1]+=2;\n\t\tsum[n][0]+=sum[n-1][0];\n\t\tsum[n][1]+=sum[n-1][1];\n\t\tc=read();\n\t}\n\tif (sum[1][0]) f[1][0]=1;\n\tif (sum[1][1]) f[1][1]=1;\n\tfor (int i=2;i<=2*n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tif (j>sum[min(i,n)][1]||i-j>sum[min(i,n)][0]) continue;\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j])%mod;\n\t\t\tif (j) f[i][j]=(f[i][j]+f[i-1][j-1])%mod;\n\t\t}\n\tcout<<f[2*n][sum[n][1]];\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll dp[4444][4444];\n\nvoid modadd(ll &a, ll b){\n\ta += b;\n\ta %= MOD;\n}\n\nint main(){\n\t\n\tstring str;\n\tcin >> str;\n\tll n = str.size();\n\tll sum = 0;\n\tdp[0][0] = 1;\n\tREP(i,2 * n){\n\t\tif(i < n)sum += 2;\n\t\tREP(j, 3 * n / 2)if(dp[i][j]){\n\t\t\tll now = j;\n\t\t\tif(i < n)now += str[i] - '0';\n\t\t\tif(now)modadd(dp[i+1][now-1], dp[i][j]);\n\t\t\tif(sum - now - i)modadd(dp[i+1][now], dp[i][j]);\n\t\t}\n\t}\n\t\n\tcout << dp[2*n][0] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=998244353;\nchar s[2010];\nLL f[4010][4010],n,sum[4010];\nvoid add(LL &x,LL y) {x+=y;x%=mod;}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tsum[i]=sum[i-1];\n\t\tif(s[i]=='0') sum[i]+=2;\n\t\tif(s[i]=='1') sum[i]++;\n\t}\n\tf[0][0]=1;\n\tfor(LL i=0;i<2*n;i++)\n\t\tfor(LL j=0;j<=i;j++) if(f[i][j])\n\t\t{\n\t\t\tLL s1=sum[min(i+1,n)]-j,s2=2*min(i+1,n)-sum[min(i+1,n)]-(i-j);\n\t\t\t//printf(\"%lld %lld %lld %lld %lld\\n\",i,j,f[i][j],s1,s2);\n\t\t\tif(s1) add(f[i+1][j+1],f[i][j]);\n\t\t\tif(s2) add(f[i+1][j],f[i][j]);\n\t\t}\n\tprintf(\"%lld\",f[2*n][sum[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)x.size()\n#define mem(a) memset(a, 0, sizeof(a))\n#define sqr(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\nconst int mn = 4005;\nconst int mod = 998244353;\n#define P mod\n\nint n;\nchar s[mn];\nint sumb[mn],sumr[mn];\nll d[mn][mn];\n\nll dp(int r,int b){\n    ll &ans=d[r][b];\n    if (ans!=-1) return ans;\n    if (r+b<=n&&(r>sumr[r+b]||b>sumb[r+b])||r>sumr[n]||b>sumb[n]) return ans=0;\n    if (r+b==2*n) return ans=1;\n    ans=dp(r+1,b)+dp(r,b+1);\n    if (ans>=mod) ans-=mod;\n    return ans;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;i++){\n        sumb[i]=sumb[i-1]+s[i]-'0';\n        sumr[i]=sumr[i-1]+(2-s[i]+'0');\n    }\n    memset(d,-1,sizeof d);\n\n    printf(\"%lld\\n\",dp(0,0));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n#include <numeric>\n#define M_PI       3.14159265358979323846\n\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define FILL(a, x) memset(a, x, sizeof(a))\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst LL MOD = 998244353;\n\nchar str[2005];\nLL dp[4005][4005];\n\nint main() {\n\tint b = 0, r = 0;\n\tcin >> str;\n\tint n = strlen(str);\n\tdp[0][0] = 1;\n\tREP(i, 2 * n) {\n\t\tif (i < n) {\n\t\t\tb += '2' - str[i];\n\t\t\tr = 2 * (i + 1) - b;\n\t\t}\n\t\tREP(j, i + 1) {\n\t\t\t// B\n\t\t\tif (b > j) {\n\t\t\t\tdp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n\n\t\t\t}\n\t\t\t// R\n\t\t\tif (r - (i - j)>0) {\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2 * n][b] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int mod=998244353;\n\nlong C[2001][2001];\n\nlong comb(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=mod;\n\t\t}\n\t\tC[i][i]=1;\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n=s.length();\n\tint red[n]={};\n\tred[0]=(s[0]=='0'?2:s[0]=='1'?1:0);\n\tfor(int i=1;i<n;i++) red[i]+=red[i-1]+(s[i]=='0'?2:s[i]=='1'?1:0);\n\t\n\tlong dp[n+1][2*n+1]={};\n\tdp[1][0]=(s[0]!='0'?1:0);\n\tdp[1][1]=(s[0]!='2'?1:0);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=max(0,red[i-1]-i);j<=min(i,red[i-1]);j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(j!=0?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcomb(n);\n\tlong ans=0;\n\tfor(int i=0;i<=min(n,red[n-1]);i++){\n\t\tif(i<=red[n-1]) ans+=dp[n][i]*C[n][red[n-1]-i]%mod;\n\t\tans%=mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dxt[6] = {0, 0, -1, -1, 1, 1};\nconst int dyt[6] = {-2, 2, 1, -1, -1, 1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll bt = 30;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst int BIG = 1e9 + 239;\nconst int MOD = 998244353; //1e9 + 7; //;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n\n//random\nmt19937 rnd(239); //rnd(chrono::high_resolution_clock::now().time_since_epoch().count())\n\n//constants\nconst int M = 2e5 + 239;\nconst int N = 2e3 + 239;\nconst int L = 20;\nconst int T = (1 << 20);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 4010;\n\nint n;\nstring s;\nint dp[X][X], kb[X], kr[X];\n\nint fnd(int x, int y)\n{\n    if (x < 0 || y < 0) return 0;\n    if (x == 0 && y == 0) return 1;\n    int t = (x + y);\n    t = min(t, n);\n    if (x > kr[t] || y > kb[t]) return 0;\n    if (dp[x][y] != -1) return dp[x][y];\n    dp[x][y] = (fnd(x - 1, y) + fnd(x, y - 1));\n    if (dp[x][y] >= MOD) dp[x][y] -= MOD;\n    return dp[x][y];\n}\n\nint32_t main()\n{\n    #ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    memset(dp, -1, sizeof(dp));\n    kb[0] = 0;\n    kr[0] = 0;\n    cin >> s;\n    n = (int)s.size();\n    for (int i = 0; i < n; i++)\n    {\n        kb[i + 1] = kb[i];\n        kr[i + 1] = kr[i];\n        if (s[i] == '0')\n            kr[i + 1] += 2;\n        else if (s[i] == '1')\n        {\n            kb[i + 1]++;\n            kr[i + 1]++;\n        }\n        else\n            kb[i + 1] += 2;\n    }\n    cout << fnd(kr[n], kb[n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nstring s;\nll dp[4010][4010];\nint d[2010][2];\n\nvoid solve(){\n    cin >> s;\n    n=s.length();\n    d[0][0]=0;\n    d[0][1]=0;\n    rep(i,2*n+1){\n        rep(j,2*n+1) dp[i][j]=0;\n    }\n    rep(i,n) {\n        d[i+1][0]=d[i][0]+2-(s[i]-'0');\n        d[i+1][1]=d[i][1]+(s[i]-'0');\n    }\n    Rep(i,n,2*n) {\n        d[i+1][0]=d[i][0];\n        d[i+1][1]=d[i][1];\n    }\n    rep(i,2*n){\n        //cout << d[i][0] << \" \" << d[i][1] << endl;\n    }\n    dp[0][0]=1;\n    rep(i,2*n){\n        rep(j,2*n){\n            if (d[i+1][0]>j){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }\n            if (d[i+1][1]>i-j){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=mod;\n            }\n            //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n\n    cout << dp[2*n][d[2*n][0]]%mod << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "/*Bismillahir Rahmanir Rahim*///{\n#include <bits/stdc++.h>\n#include <ext/numeric>\nusing namespace std; using __gnu_cxx::power;\nusing ll = long long; using ull = unsigned long long; using ld = long double;\nconst ll llinf = (1ll<<61)-1; const double eps = 1e-6, ldeps = 1e-9;\nstruct Dbg { static constexpr auto &os = cout;   // replace by cerr in interactive.\ntemplate<class C> static auto dud(C *x)->decltype(os << *x, 0);\ntemplate<class C> static char dud(...);\ntemplate<class C> typename enable_if<sizeof dud<C>(0)!=1,Dbg&>::type operator<<(const C &x) {os<<x; return *this;}\ntemplate<class C> Dbg &dump(C b, C e) {\n    for (struct{C i;int j;} i={(*this<<\"\\n[\",b),0}; i.i!=e and i.j<26; i.i++, i.j++) *this<<\", \"+2*(i.i==b)<<*i.i;\n    return *this << ']';\n}\ntemplate<class C> typename enable_if<sizeof dud<C>(0)==1, Dbg&>::type operator<<(const C &x) {\n    return dump(begin(x), end(x));\n}\ntemplate<class C, size_t X> typename enable_if<!is_same<C, const char>::value, Dbg&>::type operator<<(C (&x)[X]) {\n    return dump(begin(x), end(x));\n}\ntemplate<class B, class C> Dbg &operator<<(const pair<B, C> &x) {return *this<<'{'<<x.first<<\", \"<<x.second<<'}';}\nDbg &operator<<(ostream&(*x)(std::ostream&)) { os << x; return *this; }\n} dbg;\nvoid err(istringstream *iss) { delete iss; }\ntemplate<class C, class... Args> void err(istringstream *iss, const C &val, const Args &... args) {\n    string name; *iss >> name; if (name.back()==',') name.pop_back();\n    dbg << name << \" = \" << val << \"; \", err(iss, args...);\n}\n#define bug(args...) dbg << __LINE__ << \": \", err(new istringstream(#args), args), dbg << endl\n#define cbug(a, args...) if (a) bug(args);\n#define ASSERT(a, o, b, args...) if (!((a)o(b))) bug(a, b, ##args), assert((a)o(b));\n#define sl(a) int(strlen(a))\n#define sz(a) int(a.size())\nint T, Q, cn;//}\nconst int inf = 998244353, mxn = 2005;\n\ntemplate<class C, class D> C& operator +=(C &x, const D &y) { return x = x+y; }//{\ntemplate<class C, class D> C& operator -=(C &x, const D &y) { return x = x-y; }\ntemplate<class C, class D> C& operator *=(C &x, const D &y) { return x = x*y; }\ntemplate<class C, class D> bool operator ==(const C &ls, const D &rs) { return !(ls<rs or rs<ls); }\ntemplate<class C, class D> bool operator !=(const C &ls, const D &rs) { return !(rs==ls); }\ntemplate<class C, class D> bool operator >(const C &ls, const D &rs) { return (rs<ls); }\ntemplate<class C, class D> bool operator <=(const C &ls, const D &rs) { return !(rs<ls); }\ntemplate<class C, class D> bool operator >=(const C &ls, const D &rs) { return !(ls<rs); }\n\nstruct Int// Make sure to not do any operation with non-modded(except *, which must be int, *1 to mod forcefully)\n{\n    int x;\n    Int() = default;\n    Int(const int &rs) : x(rs + (rs>=0 ? 0 : inf)) {};\n    Int operator -() { return inf-*this; }\n    // Int operator ~() = delete;\n    Int operator ~() { return power(*this, inf-2); }\n    Int operator +(const Int &rs) const { return x+rs.x>=inf ? x+rs.x-inf : x+rs.x; }\n    Int operator -(const Int &rs) const { return x-rs.x<0 ? x-rs.x+inf : x-rs.x; }\n    Int operator *(const Int &rs) const { return int(x*ll(rs.x)%inf); }\n    Int operator <<(const int &rs) { return rs==1 ? *this+*this : *this*Int{1<<rs}; }\n    Int& operator <<=(const int &rs) { return *this = *this<<rs; }\n    Int& operator >>=(const int &rs) { return x>>=rs, *this; }  // only for power()\n    Int& operator ++() { return *this += 1; }\n    Int& operator --() { return *this -= 1; }\n    Int operator ++(int) { Int ret = x; ++*this; return ret; }\n    Int operator --(int) { Int ret = x; --*this; return ret; }\n    friend istream& operator >>(istream &is, Int &rs) { return is>>rs.x; }\n    friend ostream& operator <<(ostream &os, const Int &rs) { return os<<rs.x; }\n    friend Int operator +(const Int &ls, const int &rs) { return ls+Int(rs); }\n    friend Int operator +(const int &ls, const Int &rs) { return Int(ls)+rs; }\n    friend Int operator -(const Int &ls, const int &rs) { return ls-Int(rs); }\n    friend Int operator -(const int &ls, const Int &rs) { return Int(ls)-rs; }\n    friend Int operator *(const Int &ls, const int &rs) { return ls*Int(rs); }\n    friend Int operator *(const int &ls, const Int &rs) { return Int(ls)*rs; }\n    bool operator <(const Int &rs) const { return x<rs.x; }\n    friend bool operator <(const int &ls, const Int &rs) { return ls<rs.x; }\n    friend bool operator <(const Int &ls, const int &rs) { return ls.x<rs; }\n};\n\nInt operator\"\"_i(unsigned long long x) { return {int(x)}; }//}\n\nchar s[mxn];\nint n, cs[2][mxn];\n\nInt memo[mxn<<1][mxn<<1];\nbitset<mxn<<1> vstd[mxn<<1];\nInt dp(int move, int red) {\n    if (move == n<<1) return 1;\n    auto &ret = memo[move][red];\n    if (vstd[move][red]) return ret;\n    vstd[move][red] = 1;\n    int blue = move-red;\n    ret = 0;\n    if (cs[0][min(move, n)] > red) ret += dp(move+1, red+1);\n    if (cs[1][min(move, n)] > blue) ret += dp(move+1, red);\n    return ret;\n}\n\nsigned main() { cin.tie(0)->sync_with_stdio(0); cin.exceptions(cin.failbit); cout.precision(11);\n    cin >> s;\n    n = sl(s);\n    for (int i = 0; i < n; i++) {\n        cs[0][i] += s[i] != '2', cs[0][i] += s[i] == '0', cs[1][i] += s[i] != '0', cs[1][i] += s[i] == '2';\n        for (int j = 0; j < 2; j++) {\n            cs[j][i+1] = cs[j][i];\n        }\n    }\n    cout << dp(0, 0) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\nconst int mo=998244353;\n\nint f[4001][4001],s1[2001],s2[2001];\nchar s[2001];\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tint n=strlen(s);\n\tfor(int i=0;i<n;i++) \n\t{\n\t\ts1[i+1]=s1[i]+s[i]-'0';\n\t\ts2[i+1]=2*(i+1)-s1[i+1];\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<=s1[n];i++)\n\t\tfor(int j=0;j<=s2[n];j++)\n\t\t\tif((s1[min(i+j,n)]>=i)&&(s2[min(i+j,n)]>=j))\n\t\t\t{\n\t\t\t\tif(i) f[i][j]=(f[i][j]+f[i-1][j])%mo;\n\t\t\t\tif(j) f[i][j]=(f[i][j]+f[i][j-1])%mo;\n\t\t\t}\n\tcout<<f[s1[n]][s2[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <memory>\n#include <complex>\n#include <numeric>\n#include <cstdio>\n#include <iomanip>\n\n#define REP(i,m,n) for(int i=int(m);i<int(n);i++)\n#define RREP(i,m,n) for(int i=int(n)-1;i>=int(m);--i)\n#define EACH(i,c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n#ifdef LOCAL\n#define DEBUG(s) cout << (s) << endl\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define BR cout << endl;\n#else\n#define DEBUG(s) do{}while(0)\n#define dump(x) do{}while(0)\n#define BR \n#endif\nusing namespace std;\n\nusing UI = unsigned int;\nusing UL = unsigned long;\nusing LL = long long int;\nusing ULL = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VLL = vector<LL>;\nusing VVLL = vector<VLL>;\nusing VS = vector<string>;\nusing PII = pair<int,int>;\nusing VP = vector<PII>;\n\n//struct edge {int from, to, cost;};\n\nconstexpr double EPS = 1e-10;\n//constexpr double PI  = acos(-1.0);\n//constexpr int INF = INT_MAX;\nconstexpr LL MOD = 998244353;\n//inline void modAdd(LL &l, LL &r) {l = (l + r) % MOD;}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\nLL dfs(int n, int blue, VI &ru, VVLL &memo) {\n    if (n <= 0 || blue < 0) return 0;\n    //cout << n << \" \" << blue << \" \" << ru[min((int)ru.size()-1,n)] << \" \" << memo[n][blue] << endl;\n    if (memo[n][blue] > -1) return memo[n][blue];\n    if (n < blue) return memo[n][blue] = 0;\n    if (n <= ru.size()) {\n        if (blue > ru[n-1]) return memo[n][blue] = 0;\n        if (n - blue > 2 * n - ru[n-1]) return memo[n][blue] = 0;\n    } else {\n        int maxb = ru[ru.size()-1];\n        if (blue > maxb) return memo[n][blue] = 0;\n        if (n - blue > 2 * ru.size() - maxb) return memo[n][blue] = 0;\n    }\n    if (n == 1) return 1;\n    return memo[n][blue] = (dfs(n-1, blue - 1, ru, memo) + dfs(n-1, blue, ru, memo)) % MOD;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    VI ru(n);\n    ru[0] = s[0] - '0';\n    REP(i,1,n) ru[i] = ru[i-1] + s[i] - '0';\n    VVLL memo(2*n+1, VLL(2*n+1, -1));\n    cout << dfs(2*n,ru[n-1],ru,memo) << endl;\n}\n\nint main() {\n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nconst int maxd=998244353,N=100000;\nconst double pi=acos(-1.0);\ntypedef long long ll;\nint n,sumr[3030],sumb[3030],dp[4060][4060];\nchar s[3030];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n\twhile ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n\treturn x*f;\n}\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint i,j;n=strlen(s+1);\n\tsumr[0]=0;sumb[0]=0;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tsumr[i]=sumr[i-1];sumb[i]=sumb[i-1];\n\t\tif (s[i]=='0') sumr[i]+=2;\n\t\telse if (s[i]=='1') {sumr[i]++;sumb[i]++;}\n\t\telse if (s[i]=='2') sumb[i]+=2;\n\t}\n\t//for (i=1;i<=n;i++) cout << sumr[i] << \" \";cout << endl;\n\t//for (i=1;i<=n;i++) cout << sumb[i] << \" \";cout << endl; \n\tdp[0][0]=1;\n\tfor (i=1;i<=2*n;i++)\n\t{\n\t\tint nowr=sumr[min(i,n)],nowb=sumb[min(i,n)];\n\t\tfor (j=0;j<=i;j++)\n\t\t{\n\t\t\tif ((nowr>=j) && (nowb>=i-j))\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\tif (j>0) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%maxd;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[2*n][sumr[n]]);\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<cctype>\n#include<set>\n#include<queue>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n\tint x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;\n}\n\nconst int N = 4005, mod = 998244353;\nint sum[N][2], f[N][N];\nchar s[N];\n\ninline void add(int &x,int y) {\n\tx += y; x = x >= mod ? x - mod : x;\n}\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (s[i] == '0') sum[i][0] += 2;\n\t\telse if (s[i] == '1') sum[i][0] ++, sum[i][1] ++;\n\t\telse sum[i][1] += 2;\n\t\tsum[i][0] += sum[i - 1][0], sum[i][1] += sum[i - 1][1];\n\t}\n//\tf[0][0] = 1;\n\n\tif (sum[1][0] >= 1) f[1][1] = 1;\n\tif (sum[1][1] >= 1) f[1][0] = 1;\n\t\n\tfor (int i = 2; i <= (n << 1); ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tint r = j, b = i - j;\n\t\t\tif (r > sum[min(i, n)][0] || b > sum[min(i, n)][1]) continue;;\n\t\t\tadd(f[i][j], f[i - 1][j]);\n\t\t\tif (j) add(f[i][j], f[i - 1][j - 1]);\n//\t\t\tcout << f[i][j] << \" \" << f[i - 1][j] << \" \" << f[i - 1][j - 1] << \"\\n\";\n\t\t}\n\t}\n\tcout << f[n + n][sum[n][0]];\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\ntypedef complex<double> com;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nint dp[4010][4010];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i < n) {\n\t\t\t\tint k = s[i] - '0' + j;\n\t\t\t\tif (i + 2 > k) dp[i + 1][k] += dp[i][j];\n\t\t\t\tif (k > 0) dp[i + 1][k - 1] += dp[i][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (2 * n - i - j > 0) dp[i + 1][j] += dp[i][j];\n\t\t\t\tif (j > 0) dp[i + 1][j - 1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2 * n][0] % 998244353 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong mod=998244353,dp[2002][2002];\nstring s;\nmain()\n{\n\tcin>>s;\n\tint cr=0,cb=0;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=s.size()*2;i++)\n\t{\n\t\tif(i<=s.size())\n\t\t{\n\t\t\tif(s[i-1]=='0')cr+=2;\n\t\t\telse if(s[i-1]=='1')cr++,cb++;\n\t\t\telse cb+=2;\n\t\t}\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=((i-j<=cr&&j<=cb?dp[i-1][j]:0)+(j&&i-j<=cr&&j<=cb?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcout<<dp[s.size()*2][cb]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\n\nconst int N = 2010;\nint cou[2*N + 1][2];\nll dp[2*N + 1][N + 1];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring str;\n\tcin >> str;\n\tint n = str.size();\n\n\t// Snuke always picks some ball, at most from layer L, where L is the current turn.\n\t// After L is large enough, he can pick any ball\n\n\t// so we have N conditions, saying\n\t// \"no more than I blue balls can be picked in the first K rounds\" or same for red\n\n\t// DP[N][K]: How many sequences exist where N balls have been picked, K of which\n\t// have been blue\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint v = (str[i] - '0');\n\t\tcou[i+1][0] = cou[i][0] + (2-v);\n\t\tcou[i+1][1] = cou[i][1] + v;\n\t}\n\tfor (int i = n; i < 2*n; ++i) {\n\t\tcou[i+1][0] = cou[i][0];\n\t\tcou[i+1][1] = cou[i][1];\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2*n; ++i) {\n\t\tfor (int j = 0; j <= min(i, cou[i][1]); ++j) {\n\t\t\tint r = i - j;\n\t\t\tif (r > cou[i][0]) continue;\n\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t} else {\n\t\t\t\tdp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;\n\t\t\t}\n\t\t}\n\t\t// cout << i << ' ' << cou[i][0] << ' ' << cou[i][1] << '\\n';\n\t\t// cout << dp[i][0] << ' ' << dp[i][1] << ' ' << dp[i][2] << ' ' << dp[i][3] << '\\n';\n\t}\n\n\tll res = 0;\n\tfor (int i = 0; i <= 2*n; ++i) res += dp[2*n][i];\n\tres %= MOD;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MAX_COMB = 1e5 + 3;\nconst LL mod = 998244353;\nLL fct[MAX_COMB+1];\nLL invfct[MAX_COMB+1];\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,MAX_COMB+1){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[MAX_COMB];\n\tinvfct[MAX_COMB] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (invfct[MAX_COMB] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,MAX_COMB,0){\n\t\tinvfct[i-1] = invfct[i] * i % mod;\n\t}\n}\n\nLL comb(int x, int y){\n\tif(x < 0 || y < 0 || x < y) return 0;\n\treturn fct[x] * invfct[y] % mod * invfct[x-y] % mod;\n}\n\nLL rep_comb(int x, int y){\n\treturn y==0?1:comb(x+y-1,y);\n}\n\nint main(){\n\tbuild();\n\tstring S; cin >> S;\n\tint N = S.size();\n\tvector<LL> dp(2*N+1,0);\n\tdp[0] = 1;\n\trepp(i,0,N){\n\t\tvector<LL> nx(N*2+1,0);\n\t\tint a = S[i]-'0';\n\t\trepp(k,a,2*N+1) nx[k] = dp[k-a];\n\t\tfill(dp.begin(),dp.end(),0);\n\t\trepp(k,0,i+2) dp[k] = (nx[k]+nx[k+1])%mod;\n\t}\n\tLL ans = 0;\n\trepp(i,0,N+1) (ans += dp[i]*comb(N,i)) %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 2e3 + 23;\nconst int INF = 1e9;\nconst int MOD = 998244353;\n\nint maxR[MaxN][MaxN * 2];\n\nint dp[MaxN * 2][MaxN * 2];\nint sumr;\n\nvoid up(int & x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n\n    string s;\n    cin >> s;\n\n\n\n    int cR[MaxN * 2] = {}, cB[MaxN * 2] = {};\n\n    int n = s.size();\n\n    vector <int> a(n), b(n);\n\n    for(int i = 0; i < n; ++i)\n    {\n        if(s[i] == '0')\n            a[i] = 2;\n        else\n        if(s[i] == '1')\n            a[i] = b[i] = 1;\n        else\n            b[i] = 2;\n\n        sumr += a[i];\n    }\n\n    for(int i = 1; i <= n + n; ++i)\n    {\n        cR[i] = cR[i - 1];\n        cB[i] = cB[i - 1];\n        if(a[0])\n        {\n            --a[0];\n            ++cR[i];\n        }\n        if(b[0])\n        {\n            --b[0];\n            ++cB[i];\n        }\n        for(int j = 1; j < n; ++j)\n        {\n            if(a[j])\n            {\n                --a[j];\n                ++a[j - 1];\n            }\n            if(b[j])\n            {\n                --b[j];\n                ++b[j - 1];\n            }\n        }\n    }\n\n    dp[0][0] = 1;\n    for(int i = 1; i <= 2 * n; ++i)\n    {\n        for(int j = 0; j < i; ++j)\n            if(dp[i - 1][j])\n            {\n                if(cR[i] > j)\n                    up(dp[i][j + 1], dp[i - 1][j]);\n                if(cB[i] >= (i - j))\n                    up(dp[i][j], dp[i - 1][j]);\n            }\n    }\n\n    cout << dp[2 * n][sumr] << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2010,mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nchar str[N];\nint sum[N][2],n;\nll dp[N][N],frac[N],inv[N];\nint main()\n{\n\tscanf(\"%s\",str+1); n=strlen(str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tsum[i][0]=sum[i-1][0]+(str[i]-'0');\n\t\tsum[i][1]=sum[i-1][1]+2-(str[i]-'0');\n\t}\n\tfrac[0]=1;\n\tfor(int i=1;i<=n;++i) frac[i]=frac[i-1]*i%mod;\n\tinv[n]=Pow(frac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\t\n\tdp[0][0]=1;\n\tfor(int i=0;i<n;++i)\n\tfor(int j=0;j<=i;++j)\n\tif(dp[i][j])\n\t{\n\t\tif(sum[i+1][0]>=j+1) dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t\tif(sum[i+1][1]>=i+1-j) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t}\n//\tfor(int j=0;j<=n;++j) printf(\"%0lld\\n\",dp[n][j]); \n\tll ans=0;\n\tfor(int i=0;i<=n;++i) ans=(ans+dp[n][i]*inv[sum[n][0]-i]%mod*inv[sum[n][1]-(n-i)]%mod);\n\tans=ans*frac[n]%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\ninline int topbit(unsigned long long x){\n    return x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n    return __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n    return __builtin_parity(x);\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n    uint32_t a;\n    ModInt& s(uint32_t vv){\n        a=vv<mod?vv:vv-mod;\n        return *this;\n    }\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n    ModInt& operator+=(const ModInt &x){return s(a+x.a);}\n    ModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n    ModInt& operator*=(const ModInt &x){\n        a=uint64_t(a)*x.a%mod;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt &x){\n        *this*=x.inv();\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n    ModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n    ModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n    ModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n    bool operator==(const ModInt &x)const{return a==x.a;}\n    bool operator!=(const ModInt &x)const{return a!=x.a;}\n    bool operator<(const ModInt &x)const{return a<x.a;}\n\n    ModInt operator-()const{return ModInt()-*this;}\n    ModInt pow(int64_t n)const{\n        ModInt res(1),x(*this);\n        while(n){\n            if(n&1)res*=x;\n            x*=x;\n            n>>=1;\n        }\n        return res;\n    }\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n    return (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n    return (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n    int N;\n    vector<Mint>facts,finvs,invs;\n    ModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n        const uint32_t mod=Mint(-1).a+1;\n        invs[1]=1;\n        for(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n        facts[0]=1;\n        finvs[0]=1;\n        for(int i=1;i<N;i++){\n            facts[i]=facts[i-1]*i;\n            finvs[i]=finvs[i-1]*invs[i];\n        }\n    }\n    inline Mint fact(int n)const{return facts[n];}\n    inline Mint finv(int n)const{return finvs[n];}\n    inline Mint inv(int n)const{return invs[n];}\n    inline Mint binom(int n,int k)const{\n        if(n<0||k<0||k>n)return 0;\n        return facts[n]*finvs[k]*finvs[n-k];\n    }\n    inline Mint perm(int n,int k)const{\n        if(n<0||k<0||k>n)return 0;\n        return facts[n]*finvs[n-k];\n    }\n    inline Mint catalan(int n){\n        return facts[2*n]*finvs[n+1]*finvs[n];\n    }\n};\nModIntTable<mint,20>mt;\n\nmint dp[2222][2222];\n\nint B[2222];\n\nsigned main(){\n    string s;cin>>s;\n    int N=s.size();\n\n    rep(i,N){\n        B[i+1]=B[i]+(s[i]-'0');\n    }\n\n    dp[0][0]=1;\n    rep(i,N){\n        rep(j,N){\n            if(dp[i][j]==0)continue;\n            if(j+1<=B[i+1])dp[i+1][j+1]+=dp[i][j];\n            if(i+1-j<=2*(i+1)-B[i+1])dp[i+1][j]+=dp[i][j];\n        }\n    }\n\n    mint ans=0;\n    for(int i=0;i<=N;i++){\n        if(dp[N][i]==0)continue;\n        ans+=dp[N][i]*mt.binom(N,B[N]-i);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \ntemplate<int MAX>\nstruct comcalc{\n    vector<mint> fact,finv,inv;\n    comcalc():fact(MAX),finv(MAX),inv(MAX){\n        fact[0]=mint(1),fact[1]=mint(1),finv[0]=mint(1),finv[1]=mint(1),inv[1]=mint(1);\n        for(int i=2;i<MAX;i++){\n            fact[i]=fact[i-1]*mint(i);\n            inv[i]=mint(0)-inv[mod%i]*(mint(mod/i));\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    mint com(int n,int k){\n        if(n<k) return mint(0);\n        if(n<0 or k<0) return mint(0);\n        return fact[n]*(finv[k]*finv[n-k]);\n    }\n    mint fac(int n){\n        return fact[n];\n    }\n    // 重複組み合わせ:n種類の物から重複を許し，k個選ぶ\n    mint nHk(int n,int k){\n        return com(n+k-1,k);\n    }\n    // 玉n区別，箱k区別，各箱1個以上O(k)\n    mint F12_dis_dis_one(int n,int k){\n        mint ret=1;\n        for(int i=0;i<=k;i++){\n            mint add=com(k,i)*(mint(i).pow(n));\n            if((k-i)%2) ret-=add;\n            else        ret+=add;\n        }\n        return ret;\n    }\n};\nmint pow_mod(mint x,ll n){\n    return x.pow(n);\n}\nmint inv_mod(mint x){\n    return x.inverse();\n}\n// O(n)\nmint fact_mod(ll n){\n    mint ret=1;\n    for(int i=2;i<=n;i++) ret*=mint(i);\n    return ret;\n}\n// O(r)\nmint comb_mod(ll n,ll r){\n    if(r>n-r) r=n-r;\n    if(r==0) return 1;\n    mint a=1,b=mint(fact_mod(r)).inverse();\n    for(int i=0;i<r;i++)a*=mint(n-i);\n    return a*b;\n}\n \nconst int MAX=4010000;\nusing cominit=comcalc<MAX>;\n\nsigned main(){\n    string s;cin>>s;\n    int n=s.size();\n    vector<int>rv(n),bv(n);\n    int rc=0,bc=0;\n    rep(i,n){\n        rv[i]=(s[i]-'0');\n        bv[i]=2-rv[i];\n        rc+=rv[i];\n        bc+=bv[i];\n    }\n\n    int ng[rc+1][bc+1];\n    mint dp[rc+1][bc+1];\n    rep(i,rc+1)rep(j,bc+1)ng[i][j]=false,dp[i][j]=0;\n    dp[0][0]=1;\n\n    {\n        int r=0,b=0;\n        for(int i=0;b<bc;i++){\n            if(bv[i]==0) ng[r++][b+1]=true;\n            else b+=bv[i];\n        }\n    }\n    {\n        int r=0,b=0;\n        for(int i=0;r<rc;i++){\n            if(rv[i]==0) ng[r+1][b++]=true;\n            else r+=rv[i];\n        }\n    }\n\n    rep(i,rc+1){\n        rep(j,bc+1){\n            if(i>0 and !ng[i-1][j]) dp[i][j]+=dp[i-1][j];\n            if(j>0 and !ng[i][j-1]) dp[i][j]+=dp[i][j-1];\n        }\n    }\n\n    // rep(i,rc+1){\n    //     rep(j,bc+1){\n    //         if(ng[i][j]) cout<<\"x \";\n    //         else cout<<dp[i][j]<<\" \";\n    //     }cout<<endl;\n    // }\n\n    cout<<dp[rc][bc]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 998244353;\nint add(int &a, const int &b) {\n\ta = (a + b) % MOD;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring S;\n\tcin >> S;\n\tint N = S.size();\n\tvector<int> R(N + 1, 0);\n\tvector<int> B(N + 1, 0);\n\tfor (int i = 1; i <= N; i++) {\n\t\tR[i] = R[i - 1];\n\t\tB[i] = B[i - 1];\n\n\t\tif (S[i - 1] == '0') {\n\t\t\tR[i] += 2;\n\t\t}\n\t\telse if (S[i - 1] == '1') {\n\t\t\tR[i]++;\n\t\t\tB[i]++;\n\t\t}\n\t\telse {\n\t\t\tB[i] += 2;\n\t\t}\n\t}\n\n\tvector<vector<int> > dp(R[N] + 1, vector<int>(B[N] + 1, 0));\n\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= R[N]; i++) {\n\t\tfor (int j = 0; j <= B[N]; j++) {\n\t\t\tint k = i + j;\n\n\t\t\tif (k > N || (i <= R[k] && j <= B[k])) {\n\t\t\t\tif (i > 0)add(dp[i][j], dp[i - 1][j]);\n\t\t\t\tif (j > 0)add(dp[i][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tcerr << dp[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}*/\n\tcout << dp[R[N]][B[N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<998244353>;\n\nmodint dp[4001][4001];\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  string s;\n  cin >> s;\n  int n = s.size();\n  dp[0][0] = 1;\n  int red = 0, blue = 0;\n  for(int i = 0; i < 2 * n; i++) {\n    int _red = red, _blue = blue;\n    if(i < n) {\n      if(s[i] == '0') red += 2;\n      else if(s[i] == '1') red += 1, blue += 1;\n      else blue += 2;\n    }\n    for(int R = 0; R <= _red; R++) {\n      // use red\n      if(red - R >= 1) {\n        dp[i+1][R + 1] += dp[i][R];\n      }\n      // use blue\n      if(blue - (i - R) >= 1) {\n        dp[i+1][R] += dp[i][R];\n      }\n    }\n  }\n  cout << dp[n * 2][red] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;;\n#define ll long long\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define INF 1<<30\n#define LINF 1LL<<62\n#define all(x) (x).begin(), (x).end()\n#define mp make_pair\n#define pb push_back\nconst ll MOD = 998244353;\n \ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\n\nll dp[4005][4005];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  ll n = s.size();\n  ll r[n], b[n];\n  REP(i,n){\n      r[i] = 0;\n      b[i] = 0;\n  }\n  REP(i,n){\n      if(s[i] == '0'){\n          r[i] += 2;\n      }else  if(s[i]=='1'){\n          r[i]++;\n          b[i]++;\n      }else{\n          b[i]+=2;\n      }\n      if(i!=0){\n          r[i] += r[i-1];\n          b[i] += b[i-1];\n      }\n  }\n  \n  dp[0][0] = 1;\n  REP(i,2*n){\n      REP(j,i+1){\n          if(i<n){\n              if(r[i]>=j+1){\n                  dp[i+1][j+1] += dp[i][j];\n                  dp[i+1][j+1] %= MOD;\n              }\n              if(b[i]>=i+1-j){\n                  dp[i+1][j] += dp[i][j];\n                  dp[i+1][j] %= MOD;\n              }\n          }else{\n              if(r[n-1]>=j+1){\n                  dp[i+1][j+1] += dp[i][j];\n                  dp[i+1][j+1] %= MOD;\n              }\n              if(b[n-1]>=i+1-j){\n                  dp[i+1][j] += dp[i][j];\n                  dp[i+1][j] %= MOD;\n              }\n    \n          }\n      }\n  } \n   ll ans = 0;\n\n  REP(i,2*n){\n      ans += dp[2*n][i];\n      ans %= MOD;\n  }\n  if(n==1){\n      if(s[0] == '1'){\n          ans = 2;\n      }else{\n          ans = 1;\n      }\n  }\n  cout << ans << endl;\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 4005;\n\ninline int add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint dp[MAX_N][MAX_N], ok[MAX_N][MAX_N];\nint tma[2*MAX_N], tmb[2*MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    dp[0][0] = 1;\n    vi apos, bpos;\n    rep(i,n){\n        if(s[i] == '0'){\n            apos.pb(i+1), apos.pb(i+1);\n        }else if(s[i] == '1'){\n            apos.pb(i+1), bpos.pb(i+1);\n        }else{\n            bpos.pb(i+1), bpos.pb(i+1);\n        }\n    }\n    rep(i,len(apos)+1){\n        rep(j,len(bpos)+1){\n            ok[i][j] = INF;\n        }\n    }\n    ok[0][0] = 0;\n    rep(i,len(apos)+1){\n        rep(j,len(bpos)+1){\n            if(i > 0){\n                cmn(ok[i][j], max(ok[i-1][j] + 1, apos[i-1]));\n            }\n            if(j > 0){\n                cmn(ok[i][j], max(ok[i][j-1] + 1, bpos[j-1]));\n            }\n        }\n    }\n    rep(i,len(apos)+1){\n        rep(j,len(bpos)+1){\n            if(i < len(apos) && ok[i+1][j] <= i+j+1){\n                dp[i+1][j] = add(dp[i+1][j], dp[i][j]);\n            }\n            if(j < len(bpos) && ok[i][j+1] <= i+j+1){\n                dp[i][j+1] = add(dp[i][j+1], dp[i][j]);\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,2*n+1){\n        ans = add(ans, dp[i][2*n-i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n\nconst int mod = 998244353;\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< mod >;\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  vector<vector<modint> > dp(n+1,vector<modint>(4*n+1,0));\n  rep(i,n){\n    rep(j,4*n){\n      int red = (j - n*2 + i);\n      int blue = (-(j-2*n)+i);\n      if(red>=0 && blue>=0){        \n        red/=2;blue/=2;\n        if(red+blue!=i) continue;\n        // cout << \"i red blue \" << i << \" \" << red << \" \"<< blue << endl;\n        int nred,nblue;\n        if(s[i]=='0'){\n          if(i!=0) {\n            dp[i][red+1-blue+2*n] += dp[i-1][j];\n            if(blue>0){\n              dp[i][red+2-(blue-1)+2*n] += dp[i-1][j];\n            }\n          }\n          else dp[i][j+1] += 1;\n        }\n        else if(s[i]=='1'){\n          if(i!=0){\n            dp[i][j+1] += dp[i-1][j];\n            dp[i][j-1] += dp[i-1][j];\n          }\n          else{\n            dp[i][j+1] += 1;\n            dp[i][j-1] += 1;\n          }\n        }\n        else if(s[i]=='2'){\n          if(i!=0){\n            dp[i][j-1] += dp[i-1][j];\n            if(red>0) dp[i][red-1-(blue+2)+2*n] += dp[i-1][j];\n          }\n          else dp[i][j-1] += 1;\n        }\n      }\n    }\n  }\n  vector<modint> fact(n+1,1);\n  vector<modint> inv(n+1,1);\n  fact[0]=1;\n  rep1(i,n) fact[i] = fact[i-1]*i;\n  rep(i,n+1) inv[i] = ((modint) 1)/fact[i];\n  vector<modint> comb(n+1);\n  rep(i,n+1) comb[i] = fact[n]*inv[i]*inv[n-i];\n\n  modint ans =0;\n  rep(i,4*n){\n    // if(dp[n-1][i]!=0) cout << i <<\" \"<< dp[n-1][i] << endl;\n    int red = (i-n*2+n)/2;\n    int blue = (-(i-2*n)+n)/2;\n    ans += comb[red]*dp[n-1][i];\n  }\n  cout << ans << endl;\n  \n  return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\nint main(){\n    string S;\n    cin >> S;\n    int N = S.size();\n\n    static int64_t dp[4001][4020];\n    dp[0][0] = 1;\n    int rest = 0;\n    for(int i=0; i<2*N; i++){\n        int plus = i<N ? (S[i] - '0') : 0;\n        if(i<N) rest += 2;\n        rest--;\n        for(int j=0; j<=2*N; j++){\n            if(j+plus <= rest) add(dp[i+1][j+plus], dp[i][j]);\n            if(j+plus-1 <= rest && j+plus-1 >= 0) add(dp[i+1][j+plus-1], dp[i][j]);\n        }\n    }\n    cout << dp[2*N][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[4001][4001];\nint MOD = 998244353;\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s;\n    cin >> s;\n    int n = s.size();\n    for (int i=0; i <= 2*n; i++) for (int j=0; j <= 2*n;j++) dp[i][j] = 0;\n    dp[0][0] = 1;\n    for (int i=0; i < 2*n; i++){\n        for (int j=0; j <= 2*n; j++){\n            if (dp[i][j] == 0) continue;\n            int blue = min(2*i, 2*n) - j, red=j;\n            if (i < n){\n                blue += s[i] - '0';\n                red += 2 - (s[i]-'0');\n            }\n            if (blue > 0){\n                dp[i+1][red] += dp[i][j];\n                dp[i+1][red]%= MOD;\n            }\n            if (red>0){\n                dp[i+1][red-1] += dp[i][j];\n                dp[i+1][red-1] %= MOD;\n            }\n        }\n    }\n    cout << dp[2*n][0];\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n#define debugArrayP(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge].first<< \" \" << x[hoge].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 998244353;\n\nll dp[4010][4010];\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  string S;cin>>S;\n  ll N=S.length();\n  ll J=0;\n  dp[0][1]=1;\n  repeat(i,N){\n    J+=S[i]-'0';\n    for(int j=max(0ll,J-i-1);j<=min(i+1,J);j++){\n      dp[i+1][j+1] = (dp[i][j+1]+dp[i][j])%MOD;\n    }\n  }\n  repeat(i,N){\n    for(int j=max(0ll,J-N+i+1);j<=min(N+i+1,J);j++){\n      dp[N+i+1][j+1] = (dp[N+i][j+1]+dp[N+i][j])%MOD;\n    }\n  }\n  /*\n  repeat(i,2*N+1){\n    debug(i);\n    debug(dp[i][i+1]);\n  }\n  */\n  cout << dp[2*N][J+1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<int mod=998244353>\nclass ModInt {\n  int x;\npublic:\n  ModInt() : x(0) {}\n  ModInt(const ModInt &y): x(y.x) {}\n  ModInt(int64_t y){ x = y % mod; if(x < 0) x += mod; }\n  ModInt &operator += (const ModInt &p){ x += p.x; if(x >= mod) x -= mod; return *this; }\n  ModInt &operator -= (const ModInt &p){ x -= p.x; if(x < 0) x += mod; return *this; }\n  ModInt &operator *= (const ModInt &p){ x = (int) (1LL * x * p.x % mod); return *this; }\n  ModInt &operator /= (const ModInt &p){ *this *= p.inverse(); return *this; }\n  ModInt operator -() const { return ModInt(-x); }\n  ModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n  ModInt operator ^ (const int64_t y) const { return pow(y); }\n  bool operator == (const ModInt &p) const { return x == p.x; }\n  bool operator != (const ModInt &p) const { return x != p.x; }\n  ModInt operator = (const int64_t y) { return *this = ModInt(y); }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0){\n      t = a/b; a -= t*b; swap(a, b);\n      u -= t*v; swap(u, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t y) const {\n    if(x==0) return ModInt(0);\n    int64_t r = 1, t = x;\n    while(y > 0){\n      if(y&1) r = r*t%mod;\n      t = t*t%mod; y >>= 1;\n    }\n    return ModInt(r);\n  }\n  friend ostream &operator << (ostream &os, const ModInt<mod> &p) { return os<<p.x; }\n  friend istream &operator >> (istream &is, ModInt<mod> &a) { int64_t x; is>>x; a = ModInt<mod>(x); return is; }\n};\nusing Int = ModInt<>;\n\n\nint main(){\n  string s;\n  cin>>s;\n  int n = s.size();\n\n  vector<int> red,blue;\n  red.push_back(-1);\n  blue.push_back(-1);\n  rep(i,n){\n    if(s[i]=='0'){red.push_back(i); red.push_back(i);}\n    else if(s[i]=='1'){red.push_back(i); blue.push_back(i);}\n    else {blue.push_back(i); blue.push_back(i);}\n  }\n\n  vector<vector<Int>> dp(2*n+1, vector<Int>(red.size()+1, 0));\n  // [result-length][num of red]\n  dp[0][0] = 1;\n\n  rep(i,2*n) rep(j,red.size()+1) if(j<=i){\n    int ir = j;\n    int ib = i-j;\n    if(ib+1 < blue.size() && blue[ib+1] <= i){\n      dbg(i,ib,blue[ib+1]);\n      dp[i+1][j] += dp[i][j];\n    }\n    if(ir+1 < red.size() && red[ir+1] <= i) {\n      dbg(i,ir,red[ir+1]);\n      dp[i+1][j+1] += dp[i][j];\n    }\n  }\n  cout << dp[2*n][red.size()-1] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n#define ll int\n#define rep(i,n) for(int (i)=0;(i)<(n);++i)\n#define rrep(i,n) for(int (i)=(n)-1;(i)>=0;--i)\n#define rep1(i,n) for(int (i)=1;(i)<=(n);++i)\n#define rrep1(i,n) for(int (i)=(n);(i)>=1;--i)\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> LP;\ntypedef double db;\nusing namespace std;\nstring s;\nll ans;\nll A[2002];\nll dp[4002][4002];\nll cnt=0;\nll mod = 998244353;\nll N,r,b;\nint main()\n{\n  cin>>s;\n  N=s.size();\n  rep(i,N){\n    A[i+1]=0;\n    if(s[i]=='1') A[i+1]=1;\n    else if(s[i]=='2') A[i+1]=2;\n  }\n  //rep1(i,N) cout<<A[i]<<endl;\n  //cout<<\"asd\"<<endl;\n  dp[0][0] = 1;\n  rep1(i,2*N){\n    if(i<=N) cnt+=2;\n    \n    rep(j,2*N){ // dp[i-1][j]\n      r = i<=N ? j + A[i] : j;\n      b = cnt-r;\n      if(b > 0 && r <= 2*N) dp[i][r] = (dp[i][r]+dp[i-1][j])%mod; //青\n      if(r > 0 && r <= 2*N)  dp[i][r-1] = (dp[i][r-1] + dp[i-1][j])%mod;\n    }\n    cnt-=1;\n  }\n  // rep(i,2*N+1){\n  //   rep(j,2*N+1){\n  //     cout<<dp[i][j]<<\"a\"<<i<<\"b\"<<j<<endl;\n  //   }\n  // }\n  cout<<dp[2*N][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n//#define int long long\n\nstring s;\nconst long long MOD = 998244353;\nint dp[5000][5000];\nint cnt[5000];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> s;\n    for (int i = 0; i < s.size(); i++) cnt[i] = (i > 0 ? cnt[i - 1] : 0) + s[i] - '0';\n    dp[0][0] = 1;\n    for (int i = 1; i <= 2 * s.size(); i++)\n    {\n        for (int j = 0; j <= 2 * s.size(); j++)\n        {\n            if (j <= cnt[min(i - 1, (int)s.size() - 1)] &&\n                i - j <= 2 * min(i, (int)s.size()) - cnt[min(i - 1, (int)s.size() - 1)])\n                dp[i][j] = ((j > 0 ? dp[i - 1][j - 1] : 0) + dp[i - 1][j]) % MOD;\n        }\n    }\n    cout << dp[2 * s.size()][cnt[s.size() - 1]];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nchar S[2020];\nint N;\n\nint dp[4040][4040];\n\nint main()\n{\n\tscanf(\"%s\", S);\n\tN = strlen(S);\n\n\tint nb = 0;\n\tfor (int i = 0; i < N; ++i) nb += S[i] - '0';\n\n\tdp[0][0] = 1;\n\tint rmax = 0, bmax = 0;\n\tfor (int i = 0; i < 2 * N; ++i) {\n\t\tif (i < N) {\n\t\t\trmax += 2 - (S[i] - '0');\n\t\t\tbmax += (S[i] - '0');\n\t\t}\n\t\tfor (int b = 0; b <= bmax; ++b) {\n\t\t\tif ((i - b) + 1 <= rmax) ADD(dp[i + 1][b], dp[i][b]);\n\t\t\tif (b + 1 <= bmax) ADD(dp[i + 1][b + 1], dp[i][b]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[2 * N][nb]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD=998244353;\n\nint dp[5000][5000];\nint r,b;\n\nsigned main(){\n  string s;cin>>s;\n  int N=s.size();\n  /*\n  どんなのなら作れるかを考えるタイプ\n  1個目は1人目が持っているやつ\n  2個目は前2人が持っているやつ（ただし1個目で使われたやつは無理）\n  dp[i]:現在赤のボールをi個使っている時の場合の数\n  dp[i][j]:i個目のボールを配って赤いボールをj個消費した時の場合の数\n  */\n  dp[0][0]=1;\n  for(int i=1;i<=2*N;i++){\n    if(i<=N){\n      if(s[i-1]=='0')r+=2;\n      if(s[i-1]=='1')r+=1,b+=1;\n      if(s[i-1]=='2')b+=2;\n    }\n    for(int j=0;j<4005;j++){\n      if(i-j<=b)dp[i][j]+=dp[i-1][j];//青いボールを配る\n      if(j+1<=r)dp[i][j+1]+=dp[i-1][j];//赤いボールを配る\n      dp[i][j]%=MOD;dp[i][j+1]%=MOD;\n    }\n  }\n  cout<<dp[2*N][r]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 998244353\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong DP[4001*4001];\nvoid Calc(){\n\tstring S = res();\n\tint N = S.length();\n\tint r = 0;\n\tint b = 0;\n\tDP[0] = 1;\n\tfor(int i=0;i<2*N;i++){\n\t\tif(i < N){\n\t\t\tif(S[i] == '0'){\n\t\t\t\tr += 2;\n\t\t\t}\n\t\t\telse if(S[i] == '1'){\n\t\t\t\tr++;\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb += 2;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=4000;j++){\n\t\t\tif(r >= j && b >= i+1-j){\n\t\t\t\tif(j != 0){\n\t\t\t\t\tDP[i*4001+4001+j] += DP[i*4001+j-1];\n\t\t\t\t}\n\t\t\t\tDP[i*4001+4001+j] += DP[i*4001+j];\n\t\t\t\tDP[i*4001+4001+j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong ans = 0;\n\tfor(int i=0;i<=4000;i++){\n\t\tans += DP[2*N*4001+i];\n\t}\n\tans %= mod;\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\") \n#include<bits/stdc++.h>\n//#include<bits/extc++.h>\nusing namespace std;\n//using namespace __gnu_pbds;\n//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> set_t;\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pdd pair<double,double>\n#define pb push_back\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-6\n#define MEM(x) memset(x,0,sizeof(x))\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define pi acos(-1)\n#define index Index\n#define Line pll\ntypedef long long LL;\nint cnt0[2005],cnt1[2005];\nint dp[4005][4005];\nint mod=998244353;\nint main(){\n    char c[2005];\n    scanf(\"%s\",c+1);\n    for(int i=1;c[i]!=0;i++){\n        if(c[i]=='0'){\n            cnt0[i]=cnt0[i-1]+2;\n            cnt1[i]=cnt1[i-1];\n        }\n        else if(c[i]=='1'){\n            cnt0[i]=cnt0[i-1]+1;\n            cnt1[i]=cnt1[i-1]+1;\n        }\n        else{\n            cnt0[i]=cnt0[i-1];\n            cnt1[i]=cnt1[i-1]+2;\n        }\n    }\n    int len=strlen(c+1);\n    dp[0][0]=1;\n    for(int i=0;i<=cnt0[len];i++){\n        for(int j=0;j<=cnt1[len];j++){\n         //   printf(\"%d \",dp[i][j]);\n            if(i+j>=len){\n                dp[i+1][j]+=dp[i][j];\n                dp[i][j+1]+=dp[i][j];\n            }\n            else{\n                if(cnt0[i+j+1]-i>0){\n                    dp[i+1][j]+=dp[i][j];\n                }\n                if(cnt1[i+j+1]-j>0){\n                    dp[i][j+1]+=dp[i][j];\n                }\n            }\n            dp[i+1][j]%=mod;\n            dp[i][j+1]%=mod;\n        }\n       // printf(\"\\n\");\n    }\n    printf(\"%lld\\n\",dp[cnt0[len]][cnt1[len]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 4001;\nconst int MOD = 998244353;\nlong long dp[N][N];\nint main() {\n    string s;\n    cin >> s;\n\n    dp[0][0] = 1;\n\n    int n = s.size() * 2;\n    int r = 0, b = 0, sum = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i < s.size()) {\n            if (s[i] == '0') r += 2;\n            if (s[i] == '1') r += 1;\n        }\n\n        for (int j = 0; j <= i; ++j) {\n            if (j < r) (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n            if (i - j < (i + 1) * 2 - r) (dp[i + 1][j] += dp[i][j]) %= MOD;\n        }\n    }\n\n    cout << dp[n][r] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define md 998244353\nusing namespace std;\nstring s;\nlong long red[4005],  mxred[4005], mnred[4005], dp[4005], ans;\nint u;\nint main(){\n  cin >> s;\n  for(int i = 1; i <= s.size(); i++){\n   u += '2' - s[i-1];\n   mxred[i] = min(u, i);\n   mnred[i] = max(0, u - i);\n  }\n  for(int i = s.size() + 1; i <= s.size()*2; i++){\n    mxred[i] = min(u, i);\n    mnred[i] = max(0, u + i - (int)s.size()*2);\n  }\n  dp[0] = 1;\n  for(int i = 1; i <= s.size()*2; i++){\n    for(int j = i; j >= 0; j--){\n      dp[j] = (dp[j] + (j ? dp[j-1] : 0)) % md;\n      if(mxred[i] < j || mnred[i] > j) dp[j] = 0;\n      if(i == s.size()*2){\n        ans = (ans + dp[j]) % md;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tif(N == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tDEBUG(s)\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(j,1,N){\n\t\t\tif(s[j] == 2){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[4010][4010];\nstring S;\n\nvoid solve() {\n\tcin >> S;\n\tint N = sz(S);\n\tvi red, blue;\n\trep(i, 0, N) {\n\t\tif(S[i] == '0') {\n\t\t\tred.pb(i);\n\t\t\tred.pb(i);\n\t\t}\n\t\telse if(S[i] == '1') {\n\t\t\tblue.pb(i);\n\t\t\tred.pb(i);\n\t\t}\n\t\telse {\n\t\t\tblue.pb(i);\n\t\t\tblue.pb(i);\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tint R = sz(red), B = sz(blue);\n\trep(i, 0, R + 1) {\n\t\trep(j, 0, B + 1) {\n\t\t\tif(i == R && j == B) continue;\n\t\t\tif(i == R) ADD(dp[i][j + 1], dp[i][j]);\n\t\t\telse if(j == B) ADD(dp[i + 1][j], dp[i][j]);\n\t\t\telse {\n\t\t\t\tif(i + j >= red[i]) ADD(dp[i + 1][j], dp[i][j]);\n\t\t\t\tif(i + j >= blue[j]) ADD(dp[i][j + 1], dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[R][B] << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tstring S; cin >> S; \n\tint N = S.size(); \n\tlong long dp[4010][4010] = {}; \n\tdp[0][0] = 1; \n\tint A[2010] = {}, B[2010] = {};\n\tfor(int i = 1; i <= N; i++){\n\t\tA[i] = A[i-1] + S.at(i-1) - '0'; \n\t\tB[i] = i * 2 - A[i]; \n\t\tif(A[i] <= B[i]){\n\t\t\tfor(int j = A[i] + 1; j <= i; j++) dp[j][i-j] = -1; \n\t\t}\n\t\telse if(A[i] > B[i]){\n\t\t\tfor(int j = B[i] + 1; j <= i; j++) dp[i-j][j] = -1;\n\t\t}\n\t}\n\tfor(int i = 0; i <= A[N]; i++){\n\t\tfor(int j = 0; j <= B[N]; j++){\n\t\t\tif(dp[i][j] == -1) continue; \n\t\t\tif(i > 0 && dp[i-1][j] >= 0) dp[i][j] += dp[i-1][j]; \n\t\t\tif(j > 0 && dp[i][j-1] >= 0) dp[i][j] += dp[i][j-1]; \n\t\t\tif(dp[i][j] >= 998244353) dp[i][j] -= 998244353; \t\n\t\t}\n\t}\n\tcout << dp[A[N]][B[N]] << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int mod=998244353;\n\nlong C[2001][2001];\n\nlong comb(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=mod;\n\t\t}\n\t\tC[i][i]=1;\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n=s.length();\n\tint red[n]={};\n\tred[0]=(s[0]=='0'?2:s[0]=='1'?1:0);\n\tfor(int i=1;i<n;i++) red[i]+=red[i-1]+(s[i]=='0'?2:s[i]=='1'?1:0);\n\t\n\tlong dp[n+1][2*n+1]={};\n\tdp[1][0]=(s[0]!='0'?1:0);\n\tdp[1][1]=(s[0]!='2'?1:0);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=max(0,red[i-1]-i);j<=min(i,red[i-1]);j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(j!=0?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcomb(n);\n\tlong ans=0;\n\tfor(int i=0;i<=min(n,red[n-1]);i++){\n\t\tif(red[n-1]-i<=n) ans+=dp[n][i]*C[n][red[n-1]-i]%mod;\n\t\tans%=mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long intl;\nint MOD=998244353;\nusing namespace std;\nint main(){\n\tvector <vector<int> > dp(4001,vector <int>(4001,0));\n\tvector <vector<int> > visited(4001,vector <int>(4001,0));\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tvector <pair<int,int> > v;\n\tv.push_back({0,0});\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i-1]=='0'){\n\t\t\tv.push_back({v[i-1].first+2,v[i-1].second});\n\t\t}\n\t\telse if(s[i-1]=='1'){\n\t\t\tv.push_back({v[i-1].first+1,v[i-1].second+1});\n\t\t}\n\t\telse{\n\t\t\tv.push_back({v[i-1].first,v[i-1].second+2});\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tqueue<pair<int,int> > q;\n\tq.push({0,0});\n\twhile(!q.empty()){\n\t\tint a=q.front().first;\n\t\tint b=q.front().second;\n\t\tq.pop();\n\t\tif(visited[a][b]){\n\t\t\tcontinue;\n\t\t}\n\t\tvisited[a][b]=1;\n\t\n\t\tint tot=a+b+1;\n\t\tif(tot>n){\n\t\t\ttot=n;\n\t\t}\n\t\t\n\t\tif(v[tot].second>b){\n\t\t\tdp[a][b+1]+=dp[a][b];\n\t\t\tdp[a][b+1]=dp[a][b+1]%MOD;\n\t\t\tq.push({a,b+1});\n\t\t}\n\t\tif(v[tot].first>a){\n\t\t\tdp[a+1][b]+=dp[a][b];\n\t\t\tdp[a+1][b]=dp[a+1][b]%MOD;\n\t\t\tq.push({a+1,b});\n\t\t}\n\t\t\n\t}\n\tcout<<dp[v[n].first][v[n].second]<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VB;\n\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n#define UNQ(a) a.erase(std::unique(ALL(a)),a.end());\n#define endl \"\\n\"\n\nconst LD EPS=1e-5;\nconst long long INFLL=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9+7;\n\ntemplate<class T>\nvoid chmin(T& a, const T b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n\nconst LL powLL(const LL p, const LL q)\n{\n\tLL t=1;\n\tfor(int i=0;i<q;i++)\n\t\tt*=p;\n\treturn t;\n}\n\ntemplate <typename T>\nstruct has_iter\n{\n\tprivate:\n\t\ttemplate <typename U>\n\t\tstatic constexpr true_type check(typename U::iterator*);\n\t\ttemplate <typename U>\n\t\tstatic constexpr false_type check(...);\n\n\tpublic:\n\t\tstatic constexpr bool value = decltype(check<T>(nullptr))::value;\n};\n\n\ntemplate<typename T, typename U = typename T::iterator>\nvoid print(const T& container)\n{\n\t\tauto&& first=begin(container), last=end(container);\n\t\tauto&& back=prev(last);\n\t\tfor(auto e=first; e!=last; e=next(e))\n\t\t\tcout<<*e<<\" \\n\"[e==back];\n}\n\n\nextern void* enabler;\ntemplate<typename Head, typename enable_if<!has_iter<Head>::value>::type*& = enabler>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<> void print<string>(const string& container)\n{\n\tcout<<container<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\ntemplate<typename... Args>\nvoid printd(const Args&... args)\n{\n\t#ifdef DEBUG\n\t\tprint(args...);\n\t#endif\n}\n\ntemplate<typename Head>\nvoid input(Head& head)\n{\n\tcin>>head;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid input(Head& head, Tail&... tail)\n{\n\tcin>>head;\n\tinput(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec)\n{\n\tfor(T& x: vec) is >> x;\n\treturn is;\n}\n\n\ntemplate<typename T, typename U>\nistream& operator >> (istream& is, pair<T, U>& t)\n{\n\tis>>t.first>>t.second;\n\treturn is;\n}\n\ntemplate<int N, typename... Ts, typename enable_if<N == sizeof...(Ts)-1>::type*& = enabler>\nvoid tuple_in(istream &is, tuple<Ts...> &t)\n{\n\tis>>get<N>(t);\n}\ntemplate<int N, typename... Ts, typename enable_if<N < sizeof...(Ts)-1>::type*& = enabler>\nvoid tuple_in(istream &is, tuple<Ts...> &t)\n{\n\tis>>get<N>(t);\n\ttuple_in<N+1, Ts...>(is, t);\n}\n\ntemplate<typename... Ts>\nistream& operator >> (istream& is, tuple<Ts...>& t)\n{\n\ttuple_in<0, Ts...>(is, t);\n\treturn is;\n}\n\n\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& t)\n{\n\tos<<'('<<t.first<<\", \"<<t.second<<')';\n\treturn os;\n}\n\ntemplate<int N, typename... Ts, typename enable_if<N == sizeof...(Ts)-1>::type*& = enabler>\nvoid tuple_out(ostream &os,const tuple<Ts...> &t)\n{\n\tos<<get<N>(t);\n}\ntemplate<int N, typename... Ts, typename enable_if<N < sizeof...(Ts)-1>::type*& = enabler>\nvoid tuple_out(ostream &os,const tuple<Ts...> &t)\n{\n\tos<<get<N>(t)<<\", \";\n\ttuple_out<N+1, Ts...>(os, t);\n}\n\ntemplate<typename... Ts>\nostream& operator << (ostream& os, const tuple<Ts...>& t)\n{\n\tos<<'(';\n\ttuple_out<0, Ts...>(os, t);\n\tos<<')';\n\treturn os;\n}\n\ntemplate<typename T>\nvector<T> read(int n)\n{\n\tvector<T> t(n);\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename Head, typename... Tail>\nstruct vector_demensions\n{\n\tusing type=vector<typename vector_demensions<Tail...>::type>;\n};\n\ntemplate<typename Head>\nstruct vector_demensions<Head> { using type=Head; };\n\ntemplate<typename T>\nvector<T> make_vectors(int size, T val)\n{\n\treturn vector<T>(size, val);\n}\n\ntemplate<typename T=int, typename... Args>\nauto make_vectors(int size, Args... tail)\n\t-> typename vector_demensions<Args..., T>::type\n{\n\tauto val=make_vectors<T>(forward<Args>(tail)...);\n\treturn vector<decltype(val)>(size, val);\n}\n\n\n\nclass Mod\n{\n\tpublic:\n\t\tusing value_type = long long;\n\tprivate:\n\t\tstatic const value_type MODULO = 998244353;\n\t\tvalue_type value;\n\n\t\tconstexpr value_type Normalize(value_type x) const\n\t\t{\n\t\t\treturn x<0?(x%MODULO+MODULO):(x%MODULO);\n\t\t}\n\n\tpublic:\n\t\tconstexpr Mod():value(0){}\n\t\tconstexpr Mod(const value_type &val):value(Normalize(val)) {}\n\t\t\n\t\texplicit operator value_type () const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr const Mod operator -() const\n\t\t{\n\t\t\treturn Mod(MODULO - value);\n\t\t}\n\t\tconstexpr const Mod operator +(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value + rhs.value);\n\t\t}\n\t\tconstexpr const Mod operator -(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value + (-rhs).value);\n\t\t}\n\t\tconstexpr const Mod operator *(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value * rhs.value);\n\t\t}\n\t\tMod &operator +=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\tMod &operator -=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\tMod &operator *=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\n\n\t\tMod pow(value_type p) const;\n\n\t\tMod inv() const\n\t\t{\n\t\t\treturn pow(MODULO-2);\n\t\t}\n\n\t\tconst Mod operator /(const Mod &rhs) const\n\t\t{\n\t\t\treturn *this * rhs.inv();\n\t\t}\n\t\tMod &operator /=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}  \n\t\tconstexpr bool operator ==(const Mod &rhs)\n\t\t{\n\t\t\treturn value == rhs.value;\n\t\t}\n};\n\nMod Mod::pow(value_type p) const\n{\n\tMod tmp=1, mult=*this;\n\twhile(p)\n\t{\n\t\tif((p&1)>0) tmp*=mult;\n\t\tp>>=1;\n\t\tmult*=mult;\n\t}\n\treturn tmp;\n}\n\nnamespace std\n{\n\tostream& operator<<(ostream& os, const Mod mod)\n\t{\n\t\tos<<(typename Mod::value_type)mod;\n\t\treturn os;\n\t}\n};\n\nclass Factorial\n{\n\tprivate:\n\t\tvector<Mod> ary;\n\tpublic:\n\t\texplicit Factorial(const size_t size):ary(vector<Mod>(size))\n\t\t{\n\t\t\tary[0]=1;\n\t\t\tfor(size_t i=1;i<size;i++)\n\t\t\t\tary[i]=ary[i-1]*i;\n\t\t}\n\n\t\tsize_t size() const {   return ary.size();  }\n\n\t\tMod operator[] (const int id) const\n\t\t{\n\t\t\treturn ary[id];\n\t\t}\n};\nclass FactorialInv\n{\n\tprivate:\n\t\tvector<Mod> ary;\n\tpublic:\n\t\texplicit FactorialInv(const Factorial &fact):ary(vector<Mod>(fact.size()))\n\t\t{\n\t\t\tfor(size_t i=0;i<ary.size();i++)\n\t\t\t\tary[i]=fact[i].inv();\n\t\t}\n\n\t\t//FactorialInv& operator=(FactorialInv&&)=default;\n\n\t\tMod operator[] (const int id) const\n\t\t{\n\t\t\treturn ary[id];\n\t\t}\n};\n\nclass Combination\n{\n\tprivate:\n\t\tconst Factorial *fact;\n\t\tconst FactorialInv *fact_inv;\n\tpublic:\n\t\tCombination(const Factorial &fact_, const FactorialInv &fact_inv_):fact(&fact_),fact_inv(&fact_inv_)\n\t\t{}\n\n\t\tMod operator()(const int n, const int m) const\n\t\t{\n\t\t\treturn (*fact)[n] * (*fact_inv)[m] * (*fact_inv)[n-m];\n\t\t}\n};\n\nint main()\n{\n\tconst int N=4096;\n\tFactorial fact(N);\n\tFactorialInv facti(fact);\n\tCombination comb(fact, facti);\n\n\tstring s=read<string>();\n\tint n=s.size();\n\tint sr=0,sb=0;\n\tREP(i,n)\n\t\tif(s[i]=='0')\n\t\t\tsr+=2;\n\t\telse if(s[i]=='1')\n\t\t{\n\t\t\tsr+=1;\n\t\t\tsb+=1;\n\t\t}\n\t\telse\n\t\t\tsb+=2;\n\t\n\tvector<Mod> dp(n+1);\n\tdp[0]=1;\n\tint r=0,b=0;\n\tREP(i,n)\n\t{\n\t\tif(s[i]=='0')\n\t\t\tr+=2;\n\t\telse if(s[i]=='1')\n\t\t{\n\t\t\tr+=1;\n\t\t\tb+=1;\n\t\t}\n\t\telse\n\t\t\tb+=2;\n\n\t\tvector<Mod> dp2(n+1);\n\t\tREP(j,i+1)\n\t\t{\n\t\t\tif(j+1<=r)\n\t\t\t\tdp2[j+1]+=dp[j];\n\t\t\tif(i+2-(j+1)<=b)\n\t\t\t\tdp2[j]+=dp[j];\n\t\t}\n\t\tswap(dp2, dp);\n\t}\n\tMod ans=0;\n\t//REP(i,n+1)\n\t//\tcout<<(dp[i]==0?0:1)<<\" \\n\"[i==n];\n\tREP(j,n+1)\n\t{\n\t\tif(dp[j]==0) continue;\n\t\tans+=dp[j]*comb(n, sr-j);\n\t}\n\tprint(ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nconstexpr int MOD = 998244353;\nchar str[4005];\nint dp[4005][4005];\nint main()\n{\n\t// freopen(\"yahoo2019-F.in\", \"r\", stdin);\n\tscanf(\"%s\", str);\n\tint n = strlen(str), ans = 0;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n * 2; i++)\n\t{\n\t\tint sum = 0;\n\t\tfor (int j = 0; j <= i && j < n; j++)\n\t\t\tsum += str[j] - '0';\n\t\tfor (int j = 0; j <= i; j++)\n\t\t{\n\t\t\tif (!dp[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j < sum)\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n\t\t\tif (i - j < std::min(n, i + 1) * 2 - sum)\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t\t}\n\t}\n\tfor (int i = 0; i <= n * 2; i++)\n\t\t(ans += dp[n * 2][i]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tif(N == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(j,1,N){\n\t\t\tif(s[j] == 2){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 998244353;\n\nll dp[4010][4010];\nchar s[4010];\nint sum[4010];\nint s2[4010];\n\nvoid add(ll &x, ll y){\n    x += y;\n    if(x >= mod) x -= mod;\n}\nint main(){\n    scanf(\"%s\", s + 1);\n    int n = strlen(s + 1);\n    for(int i = 1; i <= n; i++){\n        sum[i] = sum[i - 1];\n        s2[i] = s2[i - 1];\n        if(s[i] == '0')sum[i] += 2;\n        else if(s[i] == '1')sum[i] += 1, s2[i] += 1;\n        else s2[i] += 2;\n    }\n    for(int i = n + 1; i <= 2 * n; i++)sum[i] = sum[i - 1], s2[i] = s2[i - 1];\n\n    dp[0][0] = 1;\n    for(int i = 1; i <= 2 * n; i++){\n        for(int j = 0; j <= i; j++){\n            if(s2[i] >= i - j && i > j)add(dp[i][j], dp[i - 1][j]);\n            if(sum[i] >= j + 1 && i > j)add(dp[i][j + 1], dp[i - 1][j]);\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i <= 2 * n; i++)add(ans, dp[2 * n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n  return res;\n}\n\nstruct Factorial{\n  int n;\n  const int MOD = 1e9 + 7;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nll dp[2001][2001];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  string s;\n  cin >> s;\n  int n = sz(s);\n  vector<int> rc(n, 0), bc(n, 0);\n  Factorial fac(5001);\n  rep(i, n){\n    if(s[i] == '0')rc[i] += 2;\n    else if(s[i] == '1')rc[i]++, bc[i]++;\n    else bc[i] += 2;\n    if(i > 0){\n      rc[i] += rc[i-1];\n      bc[i] += bc[i-1];\n    }\n  }\n  dp[0][0] = 1;\n  rep(i, n){\n    rep(j, min(rc[i], i+1)+1){\n      if(i+1-j > bc[i])continue;\n      dp[i+1][j] = (dp[i][j] + (j > 0 ? dp[i][j-1]: 0)) % mod;\n    }\n  }\n  ll res = 0;\n  rep(i, n + 1){\n    if(rc[n-1]-i<0)break;\n    ll tmp = dp[n][i];\n    tmp = tmp * fac.comb(n, rc[n-1] - i) % mod;\n    res = (res + tmp) % mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <string>\n\nusing namespace std;\n#define MAX_N 2000\n#define DIV 998244353\ntypedef long long ll;\nint N;\nstring str;\nint arr[MAX_N*2+10][2];\nll dp[MAX_N*2+10][MAX_N*2+10];\nll ans;\n\nint main(){\n\tcin>>str;\n\tN = str.size();\n\tfor(int i=1; i<=N; i++){\n\t\tarr[i][0]+=arr[i-1][0]; arr[i][1] += arr[i-1][1];\t\n\t\tif(str[i-1]=='0'){\n\t\t\tarr[i][0]+=2;\n\t\t}else if(str[i-1]=='1'){\n\t\t\tarr[i][0]++; arr[i][1]++;\n\t\t}else{\n\t\t\tarr[i][1]+=2;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor(int i=1; i<=N*2; i++){\n\t\tfor(int j=0; j<=N*2; j++){\n\t\t\tif(i<=N){\n\t\t\t\tif(arr[i][0] < j || arr[i][1] < i-j)\tcontinue;\n\t\t\t\tdp[i][j] = (dp[i-1][j] + (j==0?0:dp[i-1][j-1]))%DIV;\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(arr[N][0]<j || arr[N][1] < i-j)\tcontinue;\n\t\t\t\tdp[i][j] = (dp[i-1][j] + (j==0?0:dp[i-1][j-1]))%DIV;\n\t\t\t}\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tfor(int i=0; i<=N*2; i++){\n\t\tans+=dp[N*2][i];\n\t\tans = ans%DIV;\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nint N;\nchar S[2011];\n\nMint dp[2011][2011];\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n\n    dp[0][0] = 1;\n    int R = 0, B = 0;\n    REP (i, N*2) {\n\tint adR = 0, adB = 0;\n\tif (i < N) {\n\t    if (S[i] == '0') adR += 2;\n\t    if (S[i] == '1') { adR++; adB++; }\n\t    if (S[i] == '2') adB += 2;\n\t}\n\n\tREP (r, R+1) {\n\t    int b = R+B-i-r;\n\t    if (b < 0 || B < b) continue;\n\t    if (r + adR) dp[i+1][r+adR-1] += dp[i][r];\n\t    if (b + adB) dp[i+1][r+adR] += dp[i][r];\n\t}\n\tR += adR;\n\tB += adB;\n    }\n\n    printf(\"%d\\n\", dp[N*2][0].geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n\nconst int mx=200010;\n//const ll mod=1e9+7;\nconst ll mod = 998244353;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) { if ((x += a.x) >= mod) x -= mod; return *this; }\n    mint& operator-=(const mint a) { if ((x += mod-a.x) >= mod) x -= mod; return *this; }\n    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }\n    mint operator+(const mint a) const { mint res(*this); return res+=a; }\n    mint operator-(const mint a) const { mint res(*this); return res-=a; }\n    mint operator*(const mint a) const { mint res(*this); return res*=a; }\n    mint pow(ll t) const { if (!t) return 1; mint a = pow(t>>1); a *= a; if (t&1) a *= *this; return a; }\n    // for prime mod\n    mint inv() const { return pow(mod-2); }\n    mint& operator/=(const mint a) { return (*this) *= a.inv(); }\n    mint operator/(const mint a) const { mint res(*this); return res/=a; }\n};\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n){  \n  fact.resize(n+1); inv.resize(n+1); invfact.resize(n+1);\n  fact[0]=inv[0]=invfact[0]=1; inv[1]=1;\n  rep(i,n){\n    fact[i+1]=fact[i]*(i+1)%mod;\n    if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n    invfact[i+1]=invfact[i]*inv[i+1]%mod;\n  }\n}\nll perm(int n,int k){ if(n<0||k<0||k>n){ return 0; } else { return fact[n]*invfact[n-k]%mod; } }\nll comb(int n,int k){ if(n<0||k<0||k>n){ return 0; } else { return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod; }}\nll modpow(ll n,ll k){\n  k%=mod-1; if(k<0)k+=mod-1;\n  ll ret=1; while(k){ if(k&1)ret=ret*n%mod; n=n*n%mod; k>>=1; }\n  return ret;\n}\nll modinv(ll a){ return modpow(a, mod-2); }\n\n\nint main(){\n  mod_build(mx);\n  string s;\n  cin >> s;\n  int n = s.size();\n  vector<int> sumr(4010,0);\n  vector<vector<mint>> dp(4010, vector<mint>(4010,0));\n  rep(i,n){\n    int tmp = 0;\n    if(s[i]=='0'){ tmp=2; } else if(s[i]=='1'){ tmp=1; }\n    sumr[i+1] = sumr[i]+tmp;\n  }\n\n  dp[0][0] = 1;\n  rep(i,n)rep(j,i+1){\n    if(dp[i][j].x == 0) continue;\n    if(sumr[i+1] >= j+1){\n      dp[i+1][j+1] += dp[i][j];\n    }\n    if((i+1)*2-sumr[i+1] >= i+1-j){\n      dp[i+1][j] += dp[i][j];\n    }\n  }\n\n  mint ans = 0;\n  rep(i,n+1){\n    ans += dp[n][i]*comb(n,sumr[n]-i);\n  }\n  cout << ans.x << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 998244353;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; scanf(\"%lld\", &x); return x;}\nld fin(){double x; scanf(\"%lf\", &x); return x;}\nchar yuyushiki[1000010]; string stin(){scanf( \"%s\", yuyushiki ); return yuyushiki;}\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\nll dp[4010][4010];\n\nint main(){\n\n  string s = stin();\n  ll n = SZ(s);\n  vector<ll> a(2*n, 0);\n  vector<ll> b(2*n, 0);\n  REP(i, n){\n    a[i] = s[i] - '0';\n    b[i] = 2 - a[i];\n  }\n  vector<ll> as(2*n+1, 0);\n  vector<ll> bs(2*n+1, 0);\n  REP(i, 2*n){\n    as[i+1] = as[i] + a[i];\n    bs[i+1] = bs[i] + b[i];\n  }\n\n  dp[0][0] = 1;\n  \n  REP(i, 2*n){\n    REP(j, i+1){\n      REP(k, 2){\n        ll na = j + k;\n        ll nb = i + 1 - na;\n        if(na <= as[i+1] && nb <= bs[i+1]){\n          dp[i+1][na] += dp[i][j];\n          if(dp[i+1][na] >= MOD){\n            dp[i+1][na] -= MOD;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  REP(i, 2*n+1){\n    ans += dp[2*n][i];\n    if(ans >= MOD){\n      ans -= MOD;\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x (y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int &operator ++ () {return *this += (Mod_Int)1;}\n\n    Mod_Int operator ++ (int) {\n        Mod_Int tmp = *this;\n        ++*this;\n        return tmp;\n    }\n\n    Mod_Int &operator -- () {return *this -= (Mod_Int)1;}\n\n    Mod_Int operator -- (int) {\n        Mod_Int tmp = *this;\n        --*this;\n        return tmp;\n    }\n\n    Mod_Int operator - () const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow (ll n) const {\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse () const {\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e6;\nmint fac[MAX_N+1], ifac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*i;\n    }\n    ifac[MAX_N] = fac[MAX_N].inverse();\n    rep3(i, MAX_N, 1){\n        ifac[i-1] = ifac[i]*i;\n    }\n}\n\nmint comb(int n, int k){\n    return fac[n]*ifac[n-k]*ifac[k];\n}\n\nmint perm(int n, int k){\n    return fac[n]*ifac[n-k];\n}\n\nint main(){\n    string S;\n    cin >> S;\n    int N = sz(S);\n    int r[2*N+1], b[2*N+1];\n    r[0] = b[0] = 0;\n    rep(i, N){\n        r[i+1] = r[i]+('2'-S[i]);\n        b[i+1] = b[i]+(S[i]-'0');\n    }\n    rep2(i, N, 2*N-1) r[i+1] = r[i], b[i+1] = b[i];\n    mint dp[2*N+1][2*N+1];\n    fill(dp[0], dp[2*N+1], 0);\n    dp[0][0] = 1;\n    rep(i, 2*N){\n        rep(j, i+1){\n            if(r[i+1] > j) dp[i+1][j+1] += dp[i][j];\n            if(b[i+1] > i-j) dp[i+1][j] += dp[i][j];\n        }\n    }\n    mint ans = 0;\n    rep(i, 2*N+1) ans += dp[2*N][i];\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <assert.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 2005;\nconst int MOD = 998244353;\n\nint n,cnt[3];\nint MAXr[MAXN << 1];\nint MAXb[MAXN << 1];\nint f[MAXN << 1][MAXN << 1];\n\nchar s[MAXN];\n\nint main()\n{\n//\tfreopen(\"ball.in\",\"r\",stdin);\n//\tfreopen(\"ball.out\",\"w\",stdout);\n\tscanf(\"%s\",s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tcnt[s[i] - '0']++;\n\t\tfor (int j = i;j <= 2 * i;j++)\n\t\t{\n\t\t\tMAXr[j] = max(MAXr[j],min(j,cnt[1] + cnt[0] * 2));\n\t\t\tMAXb[j] = max(MAXb[j],min(j,cnt[1] + cnt[2] * 2));\n\t\t}\n\t}\n\tf[0][0] = 1;\n\tfor (int i = 1;i <= 2 * n;i++)\n\t\tfor (int j = i - MAXb[i];j <= MAXr[i];j++)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif (j > 0)\n\t\t\t\t(f[i][j] += f[i - 1][j - 1]) %= MOD;\n\t\t}\n\tprintf(\"%d\\n\",f[n * 2][MAXr[n * 2]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int p=998244353;\nint n,f[10005][10005],sumr[5005];\nchar s[5005];\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)sumr[i]=sumr[i-1]+'2'-s[i];\n\tf[0][0]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t\tfor(int j=max(0,i-2*min(i,n)+sumr[min(i,n)]);j<=sumr[min(i,n)];j++)\n\t\t\tf[i][j]=(f[i-1][j-1]+f[i-1][j])%p;\n\tint ans=0;\n\tfor(int i=1;i<=2*n;i++)ans=(ans+f[2*n][i])%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,mod=998244353;\nchar s[N];\nint sum1[N],sum2[N];\nll dp[N<<1][N<<1];\nint main()\n{\n    scanf(\"%s\",s+1);\n    int n=strlen(s+1);\n    for(int i=1;i<=n;i++)\n    {\n        sum1[i]=sum1[i-1];\n        sum2[i]=sum2[i-1];\n        if(s[i]=='0') sum1[i]+=2;\n        else if(s[i]=='1') sum1[i]++,sum2[i]++;\n        else sum2[i]+=2;\n    }\n    dp[0][0]=1;\n    for(int i=0;i<=sum1[n];i++)\n        for(int j=0;j<=sum2[n];j++)\n        if(dp[i][j])\n    {\n        if(i<sum1[min(n,i+j+1)]) (dp[i+1][j]+=dp[i][j])%=mod;\n        if(j<sum2[min(n,i+j+1)]) (dp[i][j+1]+=dp[i][j])%=mod;\n    }\n    printf(\"%lld\\n\",dp[sum1[n]][sum2[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n/// --- ModInt Library {{{ ///\n#include <ostream>\ntemplate < ll mod = (ll) 1e9 + 7 >\nstruct ModInt {\n  // math {{{\n  static inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline ll modinv(ll a) {\n    ll x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0) x += mod;\n    return x;\n  }\n  static inline ll modpow(ll a, ll b) {\n    if(b < 0) b = -b, a = modinv(a);\n    ll r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  ll val;\n  constexpr ModInt() : val(0) {}\n  constexpr ModInt(ll t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModInt(ll t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // ModInt <arithmetic-operator>[=] ModInt {{{\n  ModInt operator+(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModInt operator-(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModInt operator*(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModInt operator/(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModInt &operator+=(ModInt const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModInt &operator-=(ModInt const &rhs) { return *this += -rhs; }\n  ModInt &operator*=(ModInt const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModInt &operator/=(ModInt const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModInt operator++(int) {\n    ModInt tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModInt operator--(int) {\n    ModInt tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModInt &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModInt &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModInt operator-() const { return ModInt(val == 0 ? 0 : mod - val, 0); }\n  // ModInt <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModInt operator+(T const &rhs) const {\n      return ModInt(val + rhs % mod);\n    }\n  template < typename T >\n    ModInt operator-(T const &rhs) const {\n      return ModInt(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModInt operator*(T const &rhs) const {\n      return ModInt(val * (rhs % mod));\n    }\n  template < typename T >\n    ModInt operator/(T const &rhs) const {\n      return ModInt(val * modinv(rhs));\n    }\n  template < typename T >\n    ModInt &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModInt inv() const { return ModInt(modinv(val), 0); }\n  ModInt operator~() const { return inv(); }\n  friend ostream &operator<<(ostream &os, ModInt const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModInt operator==(const ModInt &a) const { return val == a.val; }\n  ModInt operator!=(const ModInt &a) const { return val != a.val; }\n  ModInt operator==(const ll &a) const { return val == ModInt(a); }\n  ModInt operator!=(const ll &a) const { return val != ModInt(a); }\n  // }}}\n  // T <arithmetic-operator> ModInt {{{\n  friend constexpr ModInt operator+(ll a, ModInt const &mv) {\n    return ModInt(a % mod + mv.val);\n  }\n  friend constexpr ModInt operator-(ll a, ModInt const &mv) {\n    return ModInt(a % mod - mv.val);\n  }\n  friend constexpr ModInt operator*(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModInt operator/(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModInt operator^(ll x) const { return pow(*this, x); }\n  ModInt &operator^=(ll x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModInt pow(ModInt x, ll y) { return ModInt(modpow(x.val, y), 0); }\n  // }}}\n};\n/// }}}--- ///\n\nconst int mod = 998244353;\nusing modint = ModInt<mod>;\n\nstring s;\n\n// i番目まで, j個赤を使った\nmodint dp[4001][4001];\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> s;\n  n = s.size();\n  int red = 0;\n  for(int i = 0; i < 2 * n; i++) {\n    if(i < n) red += (s[i] - '0');\n    int blue = min(i * 2 + 2, 2 * n) - red;\n    for(int j = 0; j <= min(i + 1, red); j++) {\n      int k = i + 1 - j;\n      if(blue < k) continue;\n      if(j - 1 >= 0) dp[i][j] += i == 0 ? 1 : dp[i-1][j-1];\n      if(k - 1 >= 0) dp[i][j] += i == 0 ? 1 : dp[i-1][j];\n    }\n  }\n  cout << dp[2 * n - 1][red] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s; cin >> s;\n    int n = s.size();\n\n    constexpr int kMod = 998244353;\n\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        sum += s[i] - '0';\n        vector<int> nxt(n + 1, 0);\n        for (int j = 0; j <= n; ++j) {\n            if (dp[j] == 0) continue;\n            if (sum - j > 0) (nxt[j + 1] += dp[j]) %= kMod;\n            if (2 * (i + 1) - sum - (i - j) > 0) (nxt[j] += dp[j]) %= kMod;\n        }\n        dp = nxt;\n    }\n    vector<vector<int>> cnk(n + 1, vector<int>(n + 1, 0));\n    for (int i = 0; i <= n; ++i) {\n        cnk[i][0] = 1;\n        for (int j = 1; j <= i; ++j) cnk[i][j] = (cnk[i - 1][j] + cnk[i - 1][j - 1]) % kMod;\n    }\n    int ans = 0;\n    for (int i = 0; i <= n; ++i) {\n        if (dp[i] == 0) continue;\n        ans += 1LL * dp[i] * cnk[n][sum - i] % kMod;\n        if (ans >= kMod) ans -= kMod;\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<pii, int> ppiii;\ntypedef pair<ll, ll> pll;\ntypedef pair<pii, pii> query;\ntypedef pair<ll, pii> key;\n\nint maxR[4005];\nint maxB[4005];\nint n;\n\nll dp[4005];\nll ndp[4005];\nconst int MOD = 998244353;\nvoid realsolve() {\n  dp[0] = 1;\n  for(int i = 1; i <= n; i++) {\n    memset(ndp, 0, sizeof(ndp));\n    for(int j = 0; j < i; j++) {\n      int currR = j;\n      if(currR + 1 <= maxR[i]) {\n        ndp[j+1] += dp[j];\n        ndp[j+1] %= MOD;\n      }\n      int currB = i - 1 - j;\n      if(currB + 1 <= maxB[i]) {\n        ndp[j] += dp[j];\n        ndp[j] %= MOD;\n      }\n    }\n    memcpy(dp, ndp, sizeof(dp));\n  }\n  cout << dp[maxR[n]] << \"\\n\";\n}\n\n// 0 is 2 red 0 blue\n// 1 is 1`red 1 blue\n// 2 is 0 red 2 blue\nvoid solve() {\n  string s;\n  cin >> s;\n  n = 2 * s.size();\n  {\n    int currR = '2' - s[0];\n    int usedR = 0;\n    for(int i = 1; i <= 2*s.size(); i++) {\n      if(currR) {\n        usedR++;\n        currR--;\n      }\n      maxR[i] = usedR;\n      if(i < s.size()) {\n        currR += '2' - s[i];\n      }\n    }\n  }\n  {\n    int currB = s[0] - '0';\n    int usedB = 0;\n    for(int i = 1; i <= 2*s.size(); i++) {\n      if(currB) {\n        usedB++;\n        currB--;\n      }\n      maxB[i] = usedB;\n      if(i < s.size()) {\n        currB += s[i] - '0';\n      }\n    }\n  }\n  realsolve();\n}\n\nvoid casesolve() {\n  int t;\n  cin >> t;\n  for(int i = 1; i <= t; i++) {\n    cout << \"Case #\" << i << \" \";\n    solve();\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); cout.tie(NULL);\n  solve();\n  // casesolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nstring s;\nll dp[4010][4010];\nint d[2010][2];\n\nvoid solve(){\n    cin >> s;\n    n=s.length();\n    d[0][0]=0;\n    d[0][1]=0;\n    rep(i,2*n){\n        rep(j,n) dp[i][j]=0;\n    }\n    rep(i,n) {\n        d[i+1][0]=d[i][0]+2-(s[i]-'0');\n        d[i+1][1]=d[i][1]+(s[i]-'0');\n    }\n    Rep(i,n,2*n) {\n        d[i+1][0]=d[i][0];\n        d[i+1][1]=d[i][1];\n    }\n    rep(i,2*n){\n        //cout << d[i][0] << \" \" << d[i][1] << endl;\n    }\n    dp[0][0]=1;\n    rep(i,2*n){\n        rep(j,i+1){\n            if (d[i+1][0]>j){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }\n            if (d[i+1][1]>i-j){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=mod;\n            }\n        }\n    }\n\n    cout << dp[2*n][d[2*n][0]]%mod << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#define MOD 998244353\ntypedef long long ll;\nusing namespace std;\n\nint main(){\n  string s;\n  cin>>s;\n  int n=s.size();\n  ll red[2*n+1]={};\n  ll blue[2*n+1]={};\n  for(int i=1;i<=n;i++){\n    if(s[i-1]=='0') red[i]+=2;\n    else if(s[i-1]=='2') blue[i]+=2;\n    else{\n      red[i]++;\n      blue[i]++;\n    }\n    red[i]+=red[i-1];\n    blue[i]+=blue[i-1];\n  }\n  for(int i=n+1;i<=2*n;i++){\n    red[i]=red[i-1];\n    blue[i]=blue[i-1];\n  }\n\n  int m=2*n;\n  ll dp[m+1][m+1]={};\n  dp[0][0]=1;\n  for(int i=1;i<=m;i++){\n    for(int j=0;j<=m;j++){\n      if(red[i]<j||i<j) continue;\n      if(red[i]>j&&j<m){\n        dp[i][j+1]=dp[i][j+1]+dp[i-1][j];\n        dp[i][j+1]%=MOD;\n      }\n      if(blue[i]<i-j) continue;\n      dp[i][j]=dp[i][j]+dp[i-1][j];\n      dp[i][j]%=MOD;\n    }\n  }\n\n  ll ans=0;\n  for(int i=0;i<=m;i++){\n    ans=ans+dp[m][i];\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cout<<a[i]<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst ll p = 998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    \n    string s;\n    cin>>s;\n    int n = s.length();\n    vector<int> blue(2*n);\n    vector<int> red(2*n);\n    for (int i = 0; i<2*n; i++)\n    {\n        if (i!=0) blue[i] = blue[i-1];\n        if (i<n)\n        {\n            if (s[i]=='1') blue[i]++;\n            if (s[i]=='2') blue[i]+=2;\n            red[i] = 2*(i+1) - blue[i];\n        }\n        else red[i] = red[i-1];\n    }\n    \n    vector<vector<int>> cnt(2*n, vector<int>(2*n));\n    if (blue[0]>0) cnt[0][1] = 1;\n    if (blue[0]<2) cnt[0][0] = 1;\n    for (int i = 1; i<2*n; i++)\n    {\n        for (int j = max(0, i+1-red[i]); j<=min(i+1, blue[i]); j++)\n        {\n            if (j<=i)  cnt[i][j] = cnt[i-1][j];\n            if (j>0) cnt[i][j] = add(cnt[i][j], cnt[i-1][j-1]);\n        }\n    }\n    \n    //print(blue);\n    //for (int i = 0; i<2*n; i++) print(cnt[i]);\n    \n    int total = 0;\n    for (int i = 0; i<2*n; i++) total = add(total, cnt[2*n-1][i]);\n    cout<<total;\n    \n}"
  },
  {
    "language": "C++",
    "code": "/*\n022 2\n0 1\n1 0\n2 3\n0 0 0\n0 1 0\n*/\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <sstream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define SZ(x) (int)(x.size())\n#define F0(i,n) for(int i=0;i<n;i++)\n#define F1(i,n) for(int i=1;i<=n;i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define P(x) cerr << #x << \"=\" << x << endl\n\nconst int MOD = 998244353;\nconst double pi = atan(1.0)*4.0;\nconst double eps = 1e-8;\nll gcd(ll x, ll y) { return y ? gcd(y, x%y) : x; }\nint bc(int n) { return n ? bc((n-1)&n)+1 : 0; }\n\nconst int N = 4001;\nint i, j, k, m, n, rn, bn;\nstring s;\nint a[N][N];\nint cred[N], cblue[N];\n\nvoid add(int& x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvoid solve() {\n    n = SZ(s);\n    CL(0, cred); CL(0, cblue); CL(0, a);\n    rn = 0; bn = 0;\n\n    F0(i, n) {\n        if (i > 0) {\n            cred[i] = cred[i - 1];\n            cblue[i] = cblue[i - 1];\n        }\n        if (s[i] == '0') {\n            cred[i] += 2;\n            rn += 2;\n        } else if (s[i] == '1') {\n            cred[i]++;\n            cblue[i]++;\n            rn++;\n            bn++;\n        } else {\n            cblue[i] += 2;\n            bn += 2;\n        }\n    }\n\n    a[0][0] = 1;\n    for (int i = 0; i <= rn; i++) for (int j = 0; j <= bn; j++) {\n        if (i < rn && (i + j >= n || i + 1 <= cred[i + j])) add(a[i + 1][j], a[i][j]);\n        if (j < bn && (i + j >= n || j + 1 <= cblue[i + j])) add(a[i][j + 1], a[i][j]);\n    }\n    cout << a[rn][bn] << endl;\n}\n\nint main() {\n    //freopen(\"x.in\", \"r\", stdin);\n    while (cin >> s) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nconst int MOD = 998244353;\n\nconst int ms = 2020;\n\nint memo[ms][ms + ms];\nstd::string str;\n\nint dp(int round, int red, int blue) {\n\tif(round < (int) str.size()) {\n\t\tif(str[round] == '0') red += 2;\n\t\telse if(str[round] == '1') { red++; blue++; }\n\t\telse blue += 2;\n\t}\n\tint &ans = memo[round][red];\n\tif(ans != -1) return ans;\n\tans = 0;\n\tif(red + blue == 0) return ans = 1;\n\tif(red) {\n\t\tans += dp(round+1, red-1, blue);\n\t}\n\tif(blue) {\n\t\tans += dp(round+1, red, blue-1);\n\t}\n\tif(ans >= MOD) ans -= MOD;\n\treturn ans;\n}\n\nint main() {\n\tmemset(memo, -1, sizeof memo);\n\tstd::cin >> str;\n\tstd::cout << dp(0, 0, 0) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = 998244353;\n\nll dp[4010][4010];\n\nint main() {\n    string S;\n    cin >> S;\n    int N = S.length();\n\n    int rsum[N * 2 + 1], bsum[N * 2 + 1];\n    rsum[0] = bsum[0] = 0;\n    // 各ボール数の累積和 (1-indexed)\n\n    for (int i = 1; i <= N; ++i) {\n        rsum[i] = rsum[i - 1] + ('2' - S[i - 1]);\n        bsum[i] = bsum[i - 1] + (S[i - 1] - '0');\n    }\n    for (int i = N + 1; i <= N * 2; ++i) {\n        rsum[i] = rsum[i - 1];\n        bsum[i] = bsum[i - 1];\n    }\n\n    dp[0][0] = 1;\n    for (int r = 0; r <= rsum[N]; ++r) {\n        for (int b = 0; b <= bsum[N]; ++b) {\n            if (r == rsum[N] && b == bsum[N]) continue;\n\n            // 赤ボールを置けるか？\n            if (rsum[r + b + 1] > r) {\n                dp[r + 1][b] += dp[r][b];\n                dp[r + 1][b] %= MOD;\n            }\n\n            // 青ボールを置けるか？\n            if (bsum[r + b + 1] > b) {\n                dp[r][b + 1] += dp[r][b];\n                dp[r][b + 1] %= MOD;\n            }\n        }\n    }\n\n    cout << dp[rsum[N]][bsum[N]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long intl;\nint MOD=998244353;\nusing namespace std;\nint main(){\n\tvector <vector<int> > dp(2001,vector <int>(2001,0));\n\tvector <vector<int> > visited(2001,vector <int>(2001,0));\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tvector <pair<int,int> > v;\n\tv.push_back({0,0});\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i-1]=='0'){\n\t\t\tv.push_back({v[i-1].first+2,v[i-1].second});\n\t\t}\n\t\telse if(s[i-1]=='1'){\n\t\t\tv.push_back({v[i-1].first+1,v[i-1].second+1});\n\t\t}\n\t\telse{\n\t\t\tv.push_back({v[i-1].first,v[i-1].second+2});\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tqueue<pair<int,int> > q;\n\tq.push({0,0});\n\twhile(!q.empty()){\n\t\tint a=q.front().first;\n\t\tint b=q.front().second;\n\t\tq.pop();\n\t\tif(visited[a][b]){\n\t\t\tcontinue;\n\t\t}\n\t\tvisited[a][b]=1;\n\t\n\t\tint tot=a+b+1;\n\t\tif(tot>n){\n\t\t\ttot=n;\n\t\t}\n\t\t\n\t\tif(v[tot].second>b){\n\t\t\tdp[a][b+1]+=dp[a][b];\n\t\t\tdp[a][b+1]=dp[a][b+1]%MOD;\n\t\t\tq.push({a,b+1});\n\t\t}\n\t\tif(v[tot].first>a){\n\t\t\tdp[a+1][b]+=dp[a][b];\n\t\t\tdp[a+1][b]=dp[a+1][b]%MOD;\n\t\t\tq.push({a+1,b});\n\t\t}\n\t\t\n\t}\n\tcout<<dp[v[n].first][v[n].second]<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int N = 2005, MOD = 998244353;\n\nstring s;\nint su = 0, f[2 * N][2 * N];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    f[0][0] = 1;\n    cin >> s;\n    for (int i = 1; i <= 2 * s.size(); i++)\n    {\n        su += (i <= s.size() ? s[i - 1] - '0' : 0);\n        for (int j = max(0, i - 2 * min((int)s.size(), i) + su); j <= su && j <= i; j++)\n        {\n            (f[i][j] += f[i - 1][j]) %= MOD;\n            if (j > 0)\n                (f[i][j] += f[i - 1][j - 1]) %= MOD;\n        }\n    }\n    cout << f[2 * s.size()][su];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#define N 4400\n#define L 4000\n#define eps 1e-7\n#define inf 1e9+7\n#define db double\n#define ll long long\n#define ldb long double\nusing namespace std;\ninline ll read()\n{\n\tchar ch=0;\n\tll x=0,flag=1;\n\twhile(!isdigit(ch)){ch=getchar();if(ch=='-')flag=-1;}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nconst ll mo=998244353;\nchar s[N];\nll a[N],b[N],f[N][N],dp[N][N];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tll n=strlen(s+1);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\ta[i]=a[i-1],b[i]=b[i-1];\n\t\tif(s[i]=='0')a[i]+=2;\n\t\tif(s[i]=='2')b[i]+=2;\n\t\tif(s[i]=='1')a[i]+=1,b[i]+=1;\n\t}\n\tfor(ll i=0;i<=a[n];i++)\n\tfor(ll j=0;j<=b[n];j++)\n\tif(i+j<2*n)\n\t{\n\t\tf[i][j]=-1;\n\t\tll k=min(n,i+j+1);\n\t\tif(a[k]-i>0&&b[k]-j>0)f[i][j]=1;\n\t\telse\n\t\t{\n\t\t\tif(a[k]-i>0)f[i][j]=0;\n\t\t\tif(b[k]-j>0)f[i][j]=2;\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor(ll i=0;i<=a[n];i++)\n\tfor(ll j=0;j<=b[n];j++)\n\tif(i+j!=0)\n\t{\n\t\tdp[i][j]=0;\n\t\tif(i&&(f[i-1][j]==0||f[i-1][j]==1))dp[i][j]=(dp[i][j]+dp[i-1][j])%mo;\n\t\tif(j&&(f[i][j-1]==1||f[i][j-1]==2))dp[i][j]=(dp[i][j]+dp[i][j-1])%mo;\n\t}\n\tprintf(\"%lld\",dp[a[n]][b[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 10th, 2019\n * Prob: yahoo2019_f\n * Email: hany01dxx@gmail.com & hany01@foxmail.com\n * Inst: Yali High School\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\n#define Rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define X first\n#define Y second\n#define PB(a) push_back(a)\n#define MP(a, b) make_pair(a, b)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(), a.end()\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 WoXiHuanNiA\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate <typename T> inline T read() {\n\tregister T _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n//EOT\n\n\nconst int MAXN = 2005, MOD = 998244353;\n\nchar S[MAXN];\nint n, r[MAXN], b[MAXN], dp[MAXN << 1][MAXN << 1];\n\nint getr(int x) { return r[min(x, n)]; }\nint getb(int x) { return b[min(x, n)]; }\n\nint main() {\n#ifdef hany01\n\tfreopen(\"yahoo2019_f.in\", \"r\", stdin);\n\tfreopen(\"yahoo2019_f.out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%s\", S + 1), n = strlen(S + 1);\n\tFor(i, 1, n) {\n\t\tif (S[i] == '0') r[i] = r[i - 1] + 2, b[i] = b[i - 1];\n\t\telse if (S[i] == '1') r[i] = r[i - 1] + 1, b[i] = b[i - 1] + 1;\n\t\telse b[i] = b[i - 1] + 2, r[i] = r[i - 1];\n\t}\n\n\tdp[0][0] = 1;\n\tFor(i, 1, n << 1) {\n\t\tFor(cntr, 0, min(i - 1, getr(i - 1))) {\n\t\t\tint cntb = i - 1 - cntr;\n\t\t\tif (getr(i) >= cntr + 1) (dp[i][cntr + 1] += dp[i - 1][cntr]) %= MOD;\n\t\t\tif (getb(i) >= cntb + 1) (dp[i][cntr] += dp[i - 1][cntr]) %= MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n << 1][getr(n)]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\nusing ll = long long;\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define mp make_pair\n#define mt make_tuple\n\n/* ----------- debug ---------- */\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p);\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\ninline T sq(T a) { return a * a; }\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a < b) return gcd(b, a);\n    return b == 0 ? a : gcd(b, a % b);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\ntemplate <typename T>\nT iceil(T n, T d) {\n    return (n + d - 1) / d;\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nll dp[4010][4010];\n\nint main() {\n    string S;\n    cin >> S;\n    int N = S.length();\n\n    int r[N * 2 + 1], b[N * 2 + 1];\n    r[0] = b[0] = 0;\n    for (int i = 1; i <= N; ++i) {\n        r[i] = r[i - 1] + ('2' - S[i - 1]);\n        b[i] = b[i - 1] + (S[i - 1] - '0');\n    }\n    for (int i = N + 1; i <= N * 2; ++i) {\n        r[i] = r[i - 1];\n        b[i] = b[i - 1];\n    }\n\n    dp[0][0] = 1;\n    for (int x = 0; x <= r[N]; ++x) {\n        for (int y = 0; y <= b[N]; ++y) {\n            if (r[x + y + 1] > x) {\n                dp[x + 1][y] += dp[x][y];\n                dp[x + 1][y] %= MOD;\n            }\n            if (b[x + y + 1] > y) {\n                dp[x][y + 1] += dp[x][y];\n                dp[x][y + 1] %= MOD;\n            }\n        }\n    }\n\n    cout << dp[r[N]][b[N]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 4005, M = 998244353;\n\nint n, a[N], b[N], d[N][N];\nchar s[N];\n\nint main(){\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    for(int i = 1; i <= n; i++){\n        a[i] = a[i - 1] + s[i] - '0';\n        b[i] = b[i - 1] + 2 - (s[i] - '0');\n    }\n    for(int i = n + 1; i <= 2 * n; i++){\n        a[i] = a[i - 1];\n        b[i] = b[i - 1];\n    }\n    d[0][0] = 1;\n    for(int i = 0; i < 2 * n; i++){\n        for(int j = 0; j <= a[i]; j++){\n            int ta = a[i] - j, tb = b[i] - (i - j);\n            if(ta < 0 || tb < 0) continue;\n            d[i + 1][j + 1] = (d[i + 1][j + 1] + d[i][j]) % M;\n            d[i + 1][j] = (d[i + 1][j] + d[i][j]) % M;\n        }\n    }\n    printf(\"%d\\n\", d[2 * n][a[2 * n]]); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <boost/range/adaptors.hpp>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::adaptors;\n\nint main() {\n    string s;\n    cin >> s;\n\n    constexpr auto M = 998244353L;\n\n    int64_t n = s.size();\n\n    vector<int64_t> dp(2 * n);\n    dp[0] = 1;\n\n    for (auto a :\n         s | transformed([](char c) { return c - '0'; }) | indexed(0)) {\n        auto i = a.index();\n        auto b = a.value();\n\n        vector<int64_t> next(dp.size());\n        for (auto j : irange(0L, 2 * n)) {\n            int64_t remain = i + 2;\n            int64_t blue = j + b;\n            int64_t red = remain - blue;\n\n            if (blue == 0) {\n                next[0] += dp[j];\n            } else if (red == 0) {\n                next[blue - 1] += dp[j];\n            } else {\n                next[blue] += dp[j];\n                next[blue - 1] += dp[j];\n            }\n\n            next[blue] %= M;\n            next[blue - 1] %= M;\n        }\n\n        dp = std::move(next);\n    }\n\n    for (auto i : irange(0L, n)) {\n        vector<int64_t> next(dp.size());\n        for (auto j : irange(0L, 2 * n)) {\n            int64_t remain = n - i;\n            int64_t blue = j;\n            int64_t red = remain - blue;\n\n            if (blue == 0) {\n                next[0] += dp[j];\n            } else if (red == 0) {\n                next[blue - 1] += dp[j];\n            } else {\n                next[blue] += dp[j];\n                next[blue - 1] += dp[j];\n            }\n\n            next[blue] %= M;\n            next[blue - 1] %= M;\n        }\n\n        dp = std::move(next);\n    }\n\n    std::cout << dp[0] << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\ntypedef double db;\nconst int maxn = 2e3 + 5;\nconst ll mod = 998244353;\n\nint n;\nchar s[maxn];\nll dp[maxn][maxn];\nint a[maxn], b[maxn];\n\ntemplate<class T>\nvoid add(T &x, T &y){ x += y; if(x >= mod) x -= mod; }\n\nint main(){\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    rep(i, 1, n)\n        a[i] = a[i-1] + 2 - (s[i] - '0'), b[i] = b[i-1] + s[i] - '0';\n    dp[0][0] = 1;\n    rep(i, 0, 2 * n)\n        rep(j, 0, i)\n            if(dp[i][j]){\n                if(a[min(i + 1, n)] > j)\n                    add(dp[i+1][j+1], dp[i][j]);\n                if(b[min(i + 1, n)] > i - j)\n                    add(dp[i+1][j], dp[i][j]);\n            }\n    printf(\"%lld\\n\", dp[2*n][a[n]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<list>\n#include <cstring>\n#include <functional>\n//#include<unordered_map>\n//#include<unordered_set>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF ((Int)1<<60)\n#define EPS (1e-10)\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define RREP(i,n) for(int i=1; i<=(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst int N = 100005;\n//////////////////////////////\n\nInt dp[4001][4001];\nstring s;\nint n;\n\nvoid solve()\n{\n\tcin >> s;\n\tn = s.size();\n\n\tint rs = 0, bs = 0;\n\tdp[0][0] = 1;\n\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (i < n) {\n\t\t\trs += '2' - s[i];\n\t\t\tbs += s[i] - '0';\n\t\t}\n\t\tfor (int r = 0; r <= rs; r++) {\n\t\t\tint b = i + 1 - r;\n\t\t\tif (b < 0 || b > bs) continue;\n\t\t\tdp[i + 1][r] = (dp[i + 1][r] + dp[i][r]) % MOD2;\n\t\t\tif (r > 0) dp[i + 1][r] = (dp[i + 1][r] + dp[i][r - 1]) % MOD2;\n\t\t}\n\t}\n\n\tcout << dp[2 * n][rs] << endl;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(13);\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\nclass Solver {\n public:\n  int n;\n  string s;\n  vector<vector<Modint<>>> dp;\n  Solver(string s) : n(s.size()), s(s){};\n\n  void solve() {\n    vector<int> cntb(n), cntr(n);\n    for (int i = 0; i < n; ++i) {\n      cntb[i] = (s[i] - '0');\n      cntr[i] = 2 - cntb[i];\n    }\n    auto maxr = find_max(cntr, cntb);\n    auto maxb = find_max(cntb, cntr);\n    int R = accumulate(cntr.begin(), cntr.end(), 0);\n    int B = accumulate(cntb.begin(), cntb.end(), 0);\n    dp = vector<vector<Modint<>>>(R + 1, vector<Modint<>>(B + 1));\n    dp[0][0] = Modint<>(1);\n    for (int r = 0; r <= R; ++r) {\n      for (int b = 0; b <= B; ++b) {\n        if (r > maxr[b] || b > maxb[r]) continue;\n        if (r > 0) dp[r][b] += dp[r - 1][b];\n        if (b > 0) dp[r][b] += dp[r][b - 1];\n      }\n    }\n    cout << dp[R][B] << endl;\n  }\n  vector<int> find_max(vector<int> v, vector<int> v2) {\n    int sum = accumulate(v2.begin(), v2.end(), 0);\n    vector<int> ret(sum + 1);\n    int cnt1 = 0;\n    int cnt2 = 0;\n    int now = 0;\n    for (int i = 0; i < n; ++i) {\n      cnt1 += v[i];\n      cnt2 += v2[i];\n      int nxt = cnt2 - (i + 1);\n      if (i == n - 1) nxt = sum;\n      for (int j = now; j < nxt; ++j) {\n        ret[j] = cnt1;\n      }\n      now = max(now, nxt);\n    }\n    ret[cnt2] = cnt1;\n    return ret;\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  std::string s;\n  std::cin >> s;\n  Problem::Solver sol(s);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAXN 2000\n#define MOD 998244353\nchar s[MAXN+5];\nint n,num1[MAXN+5],num2[MAXN+5];\nint dp[MAXN+5][MAXN+5];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnum2[i]=s[i]-'0';\n\t\tnum1[i]=2-num2[i]+num1[i-1];\n\t\tnum2[i]+=num2[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tint cnt1=num1[min(n,i)],cnt2=num2[min(n,i)];\n\t\tfor(int j=0;j<=i;j++)\n\t\tif(cnt1>=j&&cnt2>=i-j)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j>0)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n*2][num1[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n#define min(x,y) (x < y ? x : y)\n#define max(x,y) (x < y ? y : x)\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nconstexpr ll mod = 998244353;\nconstexpr ll mul(ll a, ll b) { return a * b % mod; }\nll mul(initializer_list<ll> t) { ll res = 1; each(v, t) res = mul(res, v); return res; }\nll add(ll a, ll b) { return (a + b) % mod; }\nll add(initializer_list<ll> t) { ll res = 0; each(v, t) res = add(res, v); return res; }\nll sub(ll a, ll b) { return (a - b + mod) % mod; }\nll sub(initializer_list<ll> t) { auto it = t.begin(); ll res = *(it++); while (it != t.end()) res = sub(res, *(it++)); return res; }\nll inv(ll n); ll power(ll x, ll n) { if (n < 0) return inv(power(x, -n)); ll res = 1; for (ll i = 1; i <= n; i <<= 1) { if (i & n) res = mul(res, x); x = mul(x, x); } return res; }\nll inv(ll n) { return power(n, mod-2); }\nll divi(ll a, ll b) { return mul(a, inv(b)); }\nll divi(initializer_list<ll> t) { auto it = t.begin(); ll res = *(it++); while (it != t.end()) res = divi(res, *(it++)); return res; }\n// template<int n> struct Fact { ll fact[n+1]; public: constexpr Fact() : fact() { fact[0] = 1; rep(i, 1, n+1) fact[i] = fact[i-1] * i % mod; } ll operator[](size_t idx) const { return fact[idx]; } };\n// const auto fact = Fact<int(300000)>();\n// ll comb(ll n, ll r) { if (r < 0) return 0; if (r > n) return 0; return divi(fact[n], mul(fact[r], fact[n-r])); }\n// ll perm(ll n, ll r) { if (r < 0) return 0; if (r > n) return 0; return divi(fact[n], fact[n-r]); }\n\nusing Row = vector<ll>;\nusing Matrix = vector<Row>;\nMatrix E(ll n) { Matrix res(n, Row(n, 0)); rep(i, n) res[i][i] = 1; return res; }\nMatrix mul(const Matrix& A, const Matrix& B) { const ll n = A.size(), m = A[0].size(), l = B[0].size(); assert(m == B.size()); Matrix res(n, Row(l, 0)); rep(i, n) rep(j, m) rep(k, l) res[i][k] = add(res[i][k], mul(A[i][j], B[j][k])); return res; }\nRow mul(const Matrix& A, const Row& x) { Matrix tx(x.size()); rep(i, x.size()) tx[i] = Row(1, x[i]); tx = mul(A, tx); Row res(x.size()); rep(i, x.size()) res[i] = tx[i][0]; return res; }\nMatrix power(Matrix A, ll n) { assert(A.size() == A[0].size()); Matrix res = E(A.size()); for (ll i = 1; i <= n; i <<= 1) { if (i & n) res = mul(res, A); A = mul(A, A); } return res; }\n\nvoid solve() {\n  string s; cin >> s;\n  const ll n = s.size();\n  vector<array<ll, 2>> a(n);\n  rep(i, n) switch (s[i]) {\n    case '0':\n      a[i][0] = 2, a[i][1] = 0;\n      break;\n    case '1':\n      a[i][0] = 1, a[i][1] = 1;\n      break;\n    case '2':\n      a[i][0] = 0, a[i][1] = 2;\n      break;\n  }\n  vector<array<ll, 2>> S(n+1);\n  rep(i, n) rep(j, 2) S[i+1][j] = S[i][j] + a[i][j];\n  vector<vector<ll>> dp(2*n+1, vector<ll>(S[n][0]+1, 0));\n  dp[0][0] = 1;\n  rep(i, 2*n) rep(j, S[n][0]+1) {\n    if (dp[i][j] == 0) continue;\n    ll pos = min(i+1, n);\n    array<ll, 2> used;\n    used[0] = j;\n    used[1] = i-j;\n    rep(k, 2) {\n      if (S[pos][k] - used[k] > 0) {\n        ll nj = k == 0 ? j+1 : j;\n        dp[i+1][nj] = add(dp[i+1][nj], dp[i][j]);\n      }\n    }\n  }\n  ll ans = dp[2*n][S[n][0]];\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[4010][4010], n;\nll nthblueat[4010], nthredat[4010], numblue, numred;\nchar inp[4010];\nint main()\n{\n\tscanf(\" %s\", inp);\n\tn = strlen(inp);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (inp[i] == '0')\n\t\t{\n\t\t\tnthredat[numred++] = i;\n\t\t\tnthredat[numred++] = i;\n\t\t}\n\t\telse if (inp[i] == '1')\n\t\t{\n\t\t\tnthredat[numred++] = i;\n\t\t\tnthblueat[numblue++] = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnthblueat[numblue++] = i;\n\t\t\tnthblueat[numblue++] = i;\n\t\t}\n\t}\n\tdp[0][0]++;\n\tfor (int i = 0; i <= numblue; i++)\n\t{\n\t\tfor (int j = 0; j <= numred; j++)\n\t\t{\n\t\t//\tprintf(\"%d %d - %lld\\n\", i, j, dp[i][j]);\n\t\t\tdp[i][j] %= 998244353;\n\t\t\tif (i < numblue && nthblueat[i] <= i+j)\n\t\t\t{\n\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t}\n\t\t\tif (j < numred && nthredat[j] <= i+j)\n\t\t\t{\n\t\t\t\tdp[i][j+1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[numblue][numred]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong mod=998244353,dp[4004][4004];\nstring s;\nmain()\n{\n\tcin>>s;\n\tint cr=0,cb=0;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=s.size()*2;i++)\n\t{\n\t\tif(i<=s.size())\n\t\t{\n\t\t\tif(s[i-1]=='0')cr+=2;\n\t\t\telse if(s[i-1]=='1')cr++,cb++;\n\t\t\telse cb+=2;\n\t\t}\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=((i-j<=cr&&j<=cb?dp[i-1][j]:0)+(j&&i-j<=cr&&j<=cb?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcout<<dp[s.size()*2][cb]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n#define ll int\n#define rep(i,n) for(int (i)=0;(i)<(n);++i)\n#define rrep(i,n) for(int (i)=(n)-1;(i)>=0;--i)\n#define rep1(i,n) for(int (i)=1;(i)<=(n);++i)\n#define rrep1(i,n) for(int (i)=(n);(i)>=1;--i)\n#define pb push_back\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> LP;\ntypedef double db;\nusing namespace std;\nstring s;\nll ans;\nll A[2001];\nll dp[4001][4001];\nll cnt=0;\nll mod = 998244353;\nll N,r,b;\nint main()\n{\n  cin>>s;\n  N=s.size();\n  rep(i,N){\n    A[i+1]=0;\n    if(s[i]=='1') A[i+1]=1;\n    else if(s[i]=='2') A[i+1]=2;\n  }\n  //rep1(i,N) cout<<A[i]<<endl;\n  //cout<<\"asd\"<<endl;\n  dp[0][0] = 1;\n  rep1(i,2*N){\n    if(i<=N) cnt+=2;\n    rep(j,2*N){ // dp[i-1][j]\n      r = j+A[i];\n      b = cnt-r;\n      if(b > 0 && r <= 2*N) dp[i][r] = (dp[i][r]+dp[i-1][j])%mod; //青\n      if(r > 0 && r <= 2*N)  dp[i][r-1] = (dp[i][r-1] + dp[i-1][j])%mod;\n    }\n    cnt-=1;\n  }\n  // rep(i,2*N+1){\n  //   rep(j,2*N+1){\n  //     cout<<dp[i][j]<<\"a\"<<i<<\"b\"<<j<<endl;\n  //   }\n  // }\n  cout<<dp[2*N][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 2000, md = 998244353;\n\nchar s[MX + 1];\nint mn[2 * MX], mx[2 * MX];\n\nvoid solve(bool inv) {\n\tstatic int cnt[MX + 1];\n\tint n = strlen(s), bal = 0;\n\tfor (int i = 0; i < n; i++) cnt[i + 1] = s[i] - '0';\n\tfor (int k = 2 * n; k > 0; k--) {\n\t\tcnt[0] = 0;\n\t\tfor (int i = 1; i <= (k + 1) / 2; i++)\n\t\t\tif (cnt[i] > 0) {\n\t\t\t\tcnt[i]--;\n\t\t\t\tcnt[i - 1]++;\n\t\t\t}\n\t\t\n\t\tif (inv) cnt[0] ^= 1;\n\t\t\n\t\tbal += cnt[0];\n\t\t(inv ? mn : mx)[2 * n - k] = bal;\n\t}\n}\n\nint dp[2 * MX + 1][2 * MX + 1];\n\nint main() {\n\tignore = scanf(\"%s\", s);\n\tint n = strlen(s);\n\t\n\tsolve(false);\n\t\n\tfor (int i = 0; s[i] != 0; i++) s[i] = '2' - (s[i] - '0');\n\t\n\tsolve(true);\n\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < 2 * n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int d = 0; d < 2; d++)\n\t\t\t\tif (mn[i] <= j + d && j + d <= mx[i]) {\n\t\t\t\t\tdp[i + 1][j + d] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j + d] %= md;\n\t\t\t\t}\n\t\n\tint ans = accumulate(dp[2 * n], dp[2 * n] + 2 * n, 0ll) % md;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\t\t\t\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\t\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=4005,mod=998244353;\nchar s[maxn];\nint n;\nint f[maxn][maxn],binom[maxn][maxn];\nint sum[maxn];\nint add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\nint main(){\n\trep(i,0,maxn-5)rep(j,0,i)binom[i][j]=!j?1:add(binom[i-1][j-1],binom[i-1][j]);\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\trep(i,1,n)sum[i]=sum[i-1]+(s[i]-'0');\n\tf[0][0]=1;\n\trep(i,1,n)rep(j,0,min(sum[i-1],i-1))if(f[i-1][j]){\n\t\tif(i-j<=2*i-sum[i])f[i][j]=add(f[i][j],f[i-1][j]);\n\t\tif(j+1<=sum[i])f[i][j+1]=add(f[i][j+1],f[i-1][j]);\n\t}\n\tint res=0;\n\trep(j,0,min(sum[n],n))res=add(res,1ll*f[n][j]*binom[n][sum[n]-j]%mod);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\n\nll dp[2020][2020];\nint main(){\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tvector<int>red,blue;\n\trep(i,n){\n\t\tif(s[i]=='0'){\n\t\t\tred.push_back(i);\n\t\t\tred.push_back(i);\n\t\t}\n\t\tif(s[i]=='1'){\n\t\t\tred.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t\tif(s[i]=='2'){\n\t\t\tblue.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tint r=red.size(),b=blue.size();\n\trep(i,r+1)rep(j,b+1){\n\t\tdp[i][j]%=mod;\n\t\tint m=i+j;\n\t\tif(j<b&&blue[j]<=m)dp[i][j+1]+=dp[i][j];\n\t\tif(i<r&&red[i]<=m)dp[i+1][j]+=dp[i][j];\n\t}\n\tcout<<dp[r][b]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <numeric>\n#include <cassert>\n#include <array>\n#include <memory>\n#include <random>\n#ifdef DEBUG\n#include \"./Lib/debug.hpp\"\n#include \"./Lib/Timer.hpp\"\n#include \"./Lib/sample.hpp\"\n#else\n#define dump(...)\n#endif\n\n/* (=＾o＾=) */\n#define int ll\n\n/* macro */\n#define FOR(i, b, e) for(ll i = (ll)(b); i < (ll)(e); ++i)\n#define RFOR(i, b, e) for(ll i = (ll)(e-1); i >= (ll)(b); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define REPC(x,c) for(const auto& x:(c))\n#define REPI2(it,b,e) for(auto it = (b); it != (e); ++it)\n#define REPI(it,c) REPI2(it, (c).begin(), (c).end())\n#define RREPI(it,c) REPI2(it, (c).rbegin(), (c).rend())\n#define REPI_ERACE2(it, b, e) for(auto it = (b); it != (e);)\n#define REPI_ERACE(it, c) REPI_ERACE2(it, (c).begin(), (c).end())\n#define ALL(x) (x).begin(),(x).end()\n#define cauto const auto&\n/* macro func */\ntemplate<class T>\ninline auto sort(T& t) { std::sort(ALL(t)); }\ntemplate<class T>\ninline auto rsort(T& t) { std::sort((t).rbegin(), (t).rend()); }\ntemplate<class T>\ninline auto unique(T& t) { (t).erase(unique((t).begin(), (t).end()), (t).end()); }\ntemplate<class T, class S>\ninline auto chmax(T& t, const S& s) { if (s > t) { t = s; return true; } return false; }\ntemplate<class T, class S>\ninline auto chmaxE(T& t, const S& s) { if (s >= t) { t = s; return true; } return false; }\ntemplate<class T, class S>\ninline auto chmin(T& t, const S& s) { if (s < t) { t = s; return true; } return false; }\ninline auto BR() { std::cout << \"\\n\"; }\n\n/* type define */\nusing ll = long long;\nusing PAIR = std::pair<ll, ll>;\nusing VS = std::vector<std::string>;\nusing VL = std::vector<long long>;\nusing VVL = std::vector<VL>;\nusing VVVL = std::vector<VVL>;\nusing VD = std::vector<double>;\ntemplate<class T>\nusing V = std::vector<T>;\n\n/* using std */\nusing std::cout;\nconstexpr char endl = '\\n';\nusing std::cin;\nusing std::pair;\nusing std::string;\nusing std::stack;\nusing std::queue;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::unordered_map;\nusing std::multimap;\nusing std::unordered_multimap;\nusing std::set;\nusing std::unordered_set;\nusing std::unordered_multiset;\nusing std::multiset;\nusing std::bitset;\nusing std::priority_queue;\nusing std::tuple;\n\n/* constant value */\n//constexpr ll MOD = 1000000007;\nconstexpr ll MOD = 998244353;\n\n/* Initial processing  */\nstruct Preprocessing { Preprocessing() { std::cin.tie(0); std::ios::sync_with_stdio(0); }; }_Preprocessing;\n\n/* Remove the source of the bug */\ninline signed pow(signed, signed) { assert(false); return -1; }\n\n/* define hash */\nnamespace std {\ntemplate <>\tclass hash<std::pair<ll, ll>> { public:\tsize_t operator()(const std::pair<ll, ll>& x) const { return hash<ll>()(1000000000 * x.first + x.second); } };\n}\n\n/* input */\ntemplate<class T> std::istream& operator >> (std::istream& is, vector<T>& vec) { for (T& x : vec) is >> x; return is; }\n\n//=============================================================================================\n\nauto solve(const string& s) {\n\n\tll n = s.size();\n\n\tVL sum1; sum1.reserve(2 * n);\n\t{\n\t\tVL v(2 * n);\n\t\tREP(i, n) {\n\t\t\tv[i] = s[i] - '0';\n\t\t}\n\t\tREP(i, 2 * n - 1)if (v[i] > 1) {\n\t\t\tv[i + 1] += v[i] - 1;\n\t\t\tv[i] = 1;\n\t\t}\n\t\tsum1.emplace_back(v[0]);\n\t\tFOR(i, 1, 2 * n) { sum1.emplace_back(sum1.back() + v[i]); }\n\t}\n\n\tVL sum0; sum0.reserve(2 * n);\n\t{\n\t\tVL v(2 * n);\n\t\tREP(i, n) {\n\t\t\tv[i] = 2 - (s[i] - '0');\n\t\t}\n\t\tREP(i, 2 * n - 1)if (v[i] > 1) {\n\t\t\tv[i + 1] += v[i] - 1;\n\t\t\tv[i] = 1;\n\t\t}\n\t\tsum0.emplace_back(v[0]);\n\t\tFOR(i, 1, 2 * n) { sum0.emplace_back(sum0.back() + v[i]); }\n\t}\n\n\n\tVVL dp(2 * n, VL(2 * n + 1));\n\tdp[0][1] = (sum1[0] == 1);\n\tdp[0][0] = (sum0[0] == 1);\n\tFOR(i, 1, 2 * n) FOR(j, 0, 2 * n + 1) {\n\t\tif (j > sum1[i]) { continue; }\n\t\tif (i - j >= sum0[i]) { continue; }\n\t\tdp[i][j] = dp[i - 1][j] + ((j - 1 >= 0) ? dp[i - 1][j - 1] : 0);\n\t\tdp[i][j] %= MOD;\n\t}\n\tll ans = 0;\n\tREPC(x, dp[2 * n - 1]) { chmax(ans, x); }\n\tdump(dp);\n\treturn ans;\n}\n\n\nsigned main() {\n\tstring s;\n\tcin >> s;\n\n\tauto ans = solve(s);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define maxn 2020\n#define mod 998244353\nusing namespace std;\ninline int qpower(int x,int k){\n\tint ans=1;\n\tfor(;k;k>>=1,x=1ll*x*x%mod)if(k&1)ans=1ll*ans*x%mod;\n\treturn ans;\n}\ninline int inv(int x){return qpower(x,mod-2);}\nint n,s1[maxn],s2[maxn],dp[maxn][maxn],fac[maxn];\nchar s[maxn];\nvoid init(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;++i){\n\t\ts1[i]=s1[i-1],s2[i]=s2[i-1];\n\t\tif(s[i]=='0')s1[i]+=2;\n\t\telse if(s[i]=='1')++s1[i],++s2[i];\n\t\telse s2[i]+=2; \n\t}\n}\ninline int f(int x,int y){return 1ll*fac[x+y]*inv(fac[x])%mod*inv(fac[y])%mod;}\nvoid solve(){\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\tfor(int j=0;j<=i;++j){\n\t\tint k=i-j;\n\t\tif(j<=s1[i]&&k<=s2[i]){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i-1][j-1];\n\t\t\tif(dp[i][j]>=mod)dp[i][j]-=mod;\n\t\t}\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tint ans=0;\n\tfor(int i=0;i<=n;++i){\n\t\tint j=n-i;\n\t\tif(i<=s1[n]&&j<=s2[n])ans=(ans+1ll*dp[n][i]*f(s1[n]-i,s2[n]-j))%mod;\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nstring s;\nll dp[4010][4010],d[2010];\n\nvoid solve(){\n    cin >> s;\n    n=s.length();\n    d[0]=0;\n    rep(i,2*n){\n        rep(j,n) dp[i][j]=0;\n    }\n    rep(i,n) d[i+1]=d[i]+2-(s[i]-'0');\n    Rep(i,n,2*n) d[i+1]=d[i];\n    dp[0][0]=1;\n    rep(i,2*n){\n        rep(j,i+1){\n            if (d[i+1]>j){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }\n            if (2*i+2-d[i+1]>i-j){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=mod;\n            }\n        }\n    }\n\n    cout << dp[2*n][d[2*n]]%mod << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\n// -----------------------------------------------------------------------------\n\nconst int N = 4010;\nvector<int> r, b;\nconst int MOD = 998244353;\nint dp[N][N];\n\nint main() {\n#ifdef zerol\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    string s; cin >> s; int n = s.length();\n    int cnt = 0;\n    FOR (i, 0, n) {\n        if (s[i] == '0') {\n            r.push_back(i); r.push_back(i);\n        } else if (s[i] == '1') {\n            r.push_back(i); b.push_back(i);\n        } else {\n            b.push_back(i); b.push_back(i);\n        }\n    }\n    dp[0][0] = 1;\n    FOR (i, 0, 2 * n) FOR (j, 0, 2 * n) {\n        int ti = i + j;\n        if (i < (int) r.size() && r[i] <= ti) {\n            (dp[i + 1][j] += dp[i][j]) %= MOD;\n        }\n        if (j < (int) b.size() && b[j] <= ti) {\n            (dp[i][j + 1] += dp[i][j]) %= MOD;\n        }\n        dbg(i, j, dp[i][j]);\n    }\n    cout << dp[r.size()][b.size()] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <ctime>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <iomanip>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define x first\n#define y second\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)x.size()\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define pi acos(-1)\n#define mod 998244353//1000000007\n#define inf 1000000007\n#define ll long long\n#define ull unsigned long long\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n#define N 2010\n#define _DEBUG\ntemplate <class U,class T> void Max(U &x, T y){if(x<y)x=y;}\ntemplate <class U,class T> void Min(U &x, T y){if(x>y)x=y;}\ntemplate <class T> void add(int &a,T b){a=(a+b)%mod;}\ninline int gcd(int a,int b){return b==0?a:gcd(b,a%b);}\ninline ll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1LL*ans*a%mod;\n        a=1LL*a*a%mod;b>>=1;\n    }\n    return ans;\n}\nint pow(int a,int b,int c){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1LL*ans*a%c;\n        a=1LL*a*a%c;b>>=1;\n    }\n    return ans;\n}\n\nchar s[N];\nint a[N],dp[N<<1],ndp[N<<1];\nint main(){\n    //srand(time(NULL)+clock());\n    int T,ca=0,k,i,j,m=0,K,n;\n    //double start=clock();\n    scanf(\"%s\",s);n=strlen(s);\n    rep(i,0,n)a[i+1]=a[i]+(s[i]=='0'?2:(s[i]=='1'?1:0));\n    dp[0]=1;\n    rep(i,0,n*2){\n        memset(ndp,0,sizeof(ndp));\n        int r=i<n?a[i+1]:a[n];\n        int l=2*(i+1)-r;\n        per(j,0,min(r,i)+1)if(dp[j]){\n            k=i-j;\n            if(j<r)add(ndp[j+1],dp[j]);\n            if(k<l)add(ndp[j],dp[j]);\n        } \n        swap(dp,ndp);\n    }\n    printf(\"%d\\n\",dp[a[n]]);\n    //cerr<<(1.*clock()-start)/CLOCKS_PER_SEC<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 998244353;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nint n;\nchar buf[2521];\nint s[2521];\nint sum[2521];\nll dp[4252][4252];\n\nint main(){\n  scanf(\"%s\",buf);\n  n = strlen(buf);\n  REP(i,n)s[i] = buf[i]-'0';\n  REP(i,n)sum[i+1] = sum[i] + s[i];\n  dp[0][0] = 1;\n  REP(i,2*n)REP(j,i+1){\n    int tot = min(2*n,2*(i+1));\n    int blue = sum[min(i+1,n)];\n    int red = tot - blue;\n    int ub = j;\n    int ur = i-j;\n    if(ub+1 <= blue){\n      (dp[i+1][j+1] += dp[i][j]) %= MOD;\n    }\n    if(ur+1 <= red){\n      (dp[i+1][j] += dp[i][j]) %= MOD;\n    }\n  }\n  printf(\"%lld\\n\",dp[2*n][sum[n]]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n#define mat vector<vector<int>>\nconst int inf = 1 << 30;\nconst ll linf = 1e18;\nconst db EPS = 1e-7;\ntemplate<class T> void chmin(T& x, T y){if(x > y) x = y;}\ntemplate<class T> void chmax(T& x, T y){if(x < y) x = y;}\n\nconst ll mod = 998244353;\nstring S;\nll dp[4010][4010];\npii ball[2010];\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> S;\n    int N = S.length();\n    for(int i = 0; i < N; ++i){\n        int num = '2' - S[i];\n        ball[i].first += num;\n        ball[i].second += 2 - num;\n        ball[i + 1] = ball[i];\n    }\n    dp[0][0] = 1;\n    for(int i = 0; i < 2 * N; ++i){\n        for(int j = 0; j < 2 * N; ++j){\n            int p = min(i + j, N - 1);\n            if(ball[p].first > i){\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= mod;\n            }\n            if(ball[p].second > j){\n                dp[i][j + 1] += dp[i][j];\n                dp[i][j + 1] %= mod;\n            }\n        }\n    }\n    cout << dp[ball[N - 1].first][ball[N - 1].second] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//const ull mod = 1e9 + 7;\nconst ll mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n// conversion number to bit\nstring num2bit(ll num, ll len){\n  string bit = \"\";\n  REP(i, len){\n    bit += char('0'+(num>>i & 1));\n  }\n  return bit;\n}\n\nll dp[4020][4020];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string S;\n    cin >> S;\n    ll N = S.size();\n\n    dp[0][0] = 1;\n\n    ll R=0, B=0;\n    REP(i, 2*N){\n    \tif(i<N){\n    \t\tif(S[i] == '0') R += 2;\n    \t\telse if(S[i] == '2') B += 2;\n    \t\telse R++, B++;\n    \t}\n\n\n    \tREP(j, i+1){\n    \t\tll idx = j;\n    \t\tll jdx = i-j;\n    \t\tif(idx<R) dp[idx+1][jdx] += dp[idx][jdx]; \n    \t\tdp[idx+1][jdx] %= mod;\n    \t\tif(jdx<B) dp[idx][jdx+1] += dp[idx][jdx]; \n    \t\tdp[idx][jdx+1] %= mod;\t\n    \t}\n    }\n\n    ll res = 0;\n    REP(i, 2*N+1){\n    \tres += dp[i][2*N-i];\n    \tres %= mod;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n#define mid ((l+r)>>1)\n#define MAXN 2005\n#define MAXM\n#define mod 998244353\n#define inf (1<<30)\n#define eps (1e-6)\n#define alpha 0.75\n#define rep(i, x, y) for(register int i = x; i <= (y); ++i)\n#define repd(i, x, y) for(register int i = x; i >= (y); --i)\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntemplate <typename T> il bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}\ntemplate <typename T> il bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}\ntemplate <typename T> il void read(T &x) {\n\tchar ch = getchar(); int f = 1; x = 0;\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n\tx *= f;\n}\ntemplate <typename T, typename... Args> il void read(T &x, Args &...args) {\n\tread(x), read(args...);\n}\nint n;\nchar s[MAXN];\nll dp[MAXN][MAXN];\nvoid add(ll &x, ll y) {\n\t(x += y) %= mod;\n}\nint main() {\n\tscanf(\"%s\", s+1);\n\tn = strlen(s+1);\n\tdp[0][0] = 1;\n\tint r = 0, b = 0;\n\trep(i, 1, n * 2) {\n\t\tif(i <= n) b += s[i] - '0', r += '2' - s[i];\n\t\trep(j, 0, i) \n\t\t\tif(r >= j && b >= i-j) {\n\t\t\t\tadd(dp[i][j], dp[i-1][j]);\n\t\t\t\tif(j) add(dp[i][j], dp[i-1][j-1]);\n\t\t\t}\n\t}\n\tcout << dp[n * 2][r] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll divide(ll x, ll y) {\n    return multiply(x, modpower(y, mod - 2));\n}\n\nll frac[1000000];\nll invfrac[1000000];\n\nvoid fracinvfrac(ll n) {\n    frac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        frac[i] = multiply(frac[i - 1], i);\n    }\n    invfrac[n] = divide(1, frac[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        invfrac[i] = multiply(invfrac[i + 1], i + 1);\n    }\n}\n\nll modcombi(ll x, ll y) {\n    if (x < y || y < 0) {\n        return 0;\n    } else if (y == 0) {\n        return 1;\n    } else {\n        return multiply(multiply(frac[x], invfrac[x - y]), invfrac[y]);\n    }\n}\n\nll dp[2010][4010];\n\nint main() {\n    string s;\n    cin >> s;\n    ll len = s.size();\n    REP(i, 0, 2010) {\n        fill(dp[i], dp[i] + 4010, 0);\n    }\n    ll blue = 0;\n    if (s[0] == '0') {\n        dp[0][0] = 1;\n    } else if (s[0] == '1') {\n        dp[0][1] = 1;\n        blue++;\n    } else {\n        dp[0][2] = 1;\n        blue += 2;\n    }\n    REP(i, 0, len - 1) {\n        REP(j, 0, 2 * i + 3) {\n            if (s[i + 1] == '0') {\n                if (j < (i + 1) * 2 - i) {\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n                }\n                if (j >= 1) {\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % mod;\n                }\n            } else if (s[i + 1] == '1') {\n                if (j < (i + 1) * 2 - i) {\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % mod;\n                }\n                if (j >= 1) {\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n                }\n                blue++;\n            } else {\n                if (j < (i + 1) * 2 - i) {\n                    dp[i + 1][j + 2] = (dp[i + 1][j + 2] + dp[i][j]) % mod;\n                }\n                if (j >= 1) {\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % mod;\n                }\n                blue += 2;\n            }\n        }\n    }\n    // REP(i, 0, 10) {\n    //     REP(j, 0, 10) {\n    //         cout << dp[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    fracinvfrac(5000);\n    ll ans = 0;\n    REP(i, 0, 4010) {\n        ans = (ans + multiply(dp[len - 1][i], modcombi(len + 1, i))) % mod;\n    }\n    // REP(i, 0, 10) {\n    //     cout << dp[len - 1][i] << \" \" << modcombi(len, i) << endl;\n    // }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << std::endl; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) { std::cerr << std::boolalpha << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); std::cerr << std::noboolalpha; }\n#else\n\t#define debug(...) {}\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool &b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector<T>& v) {\n\t\tfor (int i = 0, len = v.size(); i < len; ++i){ s << v[i]; if (i < len - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector< dvector<T> >& vv) {\n\t\tfor (int i = 0, len = vv.size(); i < len; ++i){ s << vv[i] << std::endl; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\" << std::endl; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << std::endl; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) { \n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T> &v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T &a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T> &v) { v.erase(unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*-----8<-----library-----8<-----*/\n\nvoid solve() {\n\tstring S;\n\tcin>>S;\n\tll N=S.size();\n\t//dp[i][j] i個の列の中に青玉がj個含まれた場合の数\n\tvector<vector<Modint>> dp(N+1,vector<Modint>(N+1,0));\n\tvector<ll> blue(N,0);\n\trep(i,N){\n\t\tll t=S[i]-'0';\n\t\tblue[i]=t;\n\t\tif(i>0)blue[i]+=blue[i-1];\n\t}\n\tdp[0][0]=1;\n\trep(i,N){\n\t\trep(j,i+1){\n\t\t\t//末尾に青玉追加\n\t\t\tif(blue[i]>=j+1){\n\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t}\n\t\t\t//末尾に赤玉追加\n\t\t\tif(2*(1+i)-blue[i]>=(i+1)-j){\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tdebug(blue);\n\tdebug(dp);\n\n\tModint ans=0;\n\trep(i,N+1){\n\t\tModint t=dp[N][i]*nCk(N,blue.back()-i);\n\t\tans+=t;\n\t}\n\tp(ans);\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 998244353;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\n\n//mod が素数の場合のみ　違う場合はextend euclid を用いる。\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint main() {\n\tstring st;cin>>st;\n\n\tint N=st.size();\n\n\tvector<vector<Mod>>dp(2*N+1,vector<Mod>(2*N+1));\n\tdp[0][0]=1;\n\n\tint b_sum=0;\n\tint a_sum=0;\n\tfor (int i = 0; i < 2 * N; ++i) {\n\t\tif (i < N) {\n\t\t\tb_sum+=st[i]-'0';\n\t\t\ta_sum+='2'-st[i];\n\t\t}\n\t\tint r=b_sum;\n\t\tint l=max(0,i+1-a_sum);\n\t\tfor (int cnt = 0; cnt <= 2 * N; ++cnt) {\n\t\t\tfor (int n_cnt = cnt; n_cnt < cnt + 2; ++n_cnt) {\n\t\t\t\tif (l <= n_cnt&&n_cnt <= r) {\n\t\t\t\t\tdp[i+1][n_cnt]+=dp[i][cnt];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tauto answer=dp[2*N][b_sum].num;\n\tcout<<answer<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,K,Q,A,B;\nstring S, T;\nconst ll MOD = 998244353;\n//const ll MOD = (1e+9) + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<ll,ll> P;\n\nint main(){\n    cin>>S;\n    N = S.size();\n    ll blue_sum = 0;\n    rep(i,N) blue_sum += S[i] - '0';\n    mat dp(N*2 + 1, vec(blue_sum + 1, 0));\n    //dp[i][b]:今まででb個の青ボールを使う\n    dp[0][0] = 1;\n    ll b = 0, r = 0; //各々使える最大値\n    rep(i,N*2){\n        if(i < N) {\n            b += S[i] - '0';\n            r += '2' - S[i];\n        }\n        reps(j, max(0LL, (i+1) - r), b + 1){\n            dp[i+1][j] = dp[i][j];\n            if(j > 0) (dp[i+1][j] += dp[i][j-1])%=MOD;\n        }\n    }\n    cout<<dp[N*2][blue_sum]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\ntypedef long long ll;\nconst int N = 200010;\nconst int mod = 998244353;\nconst int oo = 1e9;\nconst int base = 27;\ntypedef pair<int,int> pii;\n\n\nint dp[4010][4010],f1[4001],f2[4001];\n\nstring s;\n\nll adl(ll a , ll b){\n  return (1ll*a+b)%mod;\n}\nint calc(int r , int b){\n  if(r+b == 2*s.size())return 1;\n  int &ret = dp[r][b];\n  if(ret != -1)return ret;\n  ret = 0;\n  int idx = r+b;\n  if(idx == s.size()){\n    if(b != f1[s.size()-1])ret = adl(ret,calc(r,b+1));\n    if(r != f2[s.size()-1])ret = adl(ret,calc(r+1,b));\n  }else{\n    if(b != f1[idx])ret = adl(ret,calc(r,b+1));\n    if(r != f2[idx])ret = adl(ret,calc(r+1,b));\n  }\n  return ret;\n}\nint main() {\n  memset(dp,-1,sizeof dp);\n  cin >> s;\n  for (int i = 0; i < s.size(); ++i){\n    if(s[i] == '1')f1[i]++,f2[i]++;\n    if(s[i] == '2')f2[i]+=2;\n    if(s[i] == '0')f1[i]+=2;\n    if(i)\n      f1[i] += f1[i-1];\n    if(i)\n      f2[i] += f2[i-1];\n  }\n  printf(\"%d\\n\",calc(0,0));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 998244353\n\nstruct mint {\n    int n;\n    mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { a.n += b.n; if (a.n >= MOD) a.n -= MOD; return a; }\nmint operator-(mint a, mint b) { a.n -= b.n; if (a.n < 0) a.n += MOD; return a; }\nmint operator*(mint a, mint b) { return (long long)a.n * b.n % MOD; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\n\nint min(int x, int y) {\n    return x < y ? x : y;\n}\n\nint N;\nchar S[2001];\n\nint A[2001];\nint B[2001];\n\nmint dp[4040][4040];\n\nint main() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    for (int i = 0; i < N; i++) {\n        int a = S[i] - '0';\n        int b = 2 - a;\n        A[i + 1] = A[i] + a;\n        B[i + 1] = B[i] + b;\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i < N * 2; i++) {\n        for (int j = 0; j <= N * 2; j++) {\n            int k = i - j;\n            if (A[min(N, i + 1)] >= j + 1) dp[i + 1][j + 1] += dp[i][j];\n            if (B[min(N, i + 1)] >= k + 1) dp[i + 1][j] += dp[i][j];\n        }\n    }\n    printf(\"%d\\n\", dp[N * 2][A[N]].n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\nusing namespace std;\n\n/**** Type Define ****/\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n/**** Const List   ****/\n\nconst ll INF = ((ll)1 << 31) - 1;\nconst ll DINF = (ll)1e20;\nconst ll UNION_FIND_MAX = 100000;\nconst ll SEGMENT_TREE_MAX = (1 << 18) - 1;\nconst ll MAX_FLOW_MAX_V = 10000;\nconst ll MIN_COST_FLOW_MAX_V = 10000;\nconst ll BIPARTITE_MATCHING_MAX_V = 10000;\nconst ll DIJKSTRA_MAX_V = 1000000;\n\n\n/**** General Functions ****/\n\ntemplate <typename T>\nT tmin(T a, T b) { return a > b ? b : a; };\n\ntemplate <typename T>\nT tmax(T a, T b) { return a > b ? a : b; };\n\ntemplate <typename T>\nT tadd(T a, T b) { return a + b; };\n\ntemplate <typename T>\nT tmul(T a, T b) { return a * b; };\n\ntemplate <typename T>\nT tpow(T a, T b) { return a * b; };\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll lmin(ll a, ll b) { return a > b ? b : a; };\n\nll lmax(ll a, ll b) { return a > b ? a : b; };\n\n\n/**** Dijkstra ****/\nclass Dijkstra { // double は無理!!\npublic:\n  struct edge { ll to, cost; };\n\n  ll V;\n  vector<edge> G[DIJKSTRA_MAX_V];\n  ll d[DIJKSTRA_MAX_V];\n  priority_queue<P, vector<P>, greater<P> > que;\n\n  Dijkstra() {}\n  Dijkstra(ll v) {\n    init(v);\n  }\n  void init(ll v) {\n    V = v;\n    for (ll i = 0; i < v; i++) {\n      G[i].clear();\n    }\n  }\n  void search(ll from) {\n    for (ll i = 0; i < V; i++) d[i] = INF;\n    d[from] = 0;\n    que.push(P(0, from));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      ll b = p.second;\n      ll c = p.first;\n      if (d[b] <= c) continue;\n      for (ll i = 0; i < G[b].size(); i++) {\n        edge e = G[b][i];\n        ll nc = c + e.cost;\n        ll nt = e.to;\n        if (d[nt] > nc) que.push(P(nc, nt)), d[nt] = nc;\n      }\n    }\n  }\n};\n\n/**** Matrix ****/\n\ntemplate <typename T>\nstruct Matrix {\n  typedef vector<T> vec;\n  typedef vector<vec> mat;\n  ll x, y; // x: horizon  y: vertical\n  mat d;\n\n  Matrix(ll _y, ll _x = -1) {\n    if (_x == -1) _x = _y;\n    x = _x, y = _y;\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = 0;\n  }\n  void unit() {\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = i == j ? 1 : 0;\n  }\n  Matrix copy() {\n    Matrix m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j];\n    return m;\n  }\n  Matrix<T> operator + (Matrix<T>& t) { // No error check! Don't forget to check Matrix size!!\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] + t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator - (Matrix<T>& t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] - t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator * (T t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] * t;\n    return m;\n  }\n  Matrix<T> det(Matrix<T>& t) { // x need to correspond to t.y\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        for (int k = 0; k < t.x; k++) m.d[i][j] += d[i][k] * t.d[k][j]; ////////////// mod???\n    return m;\n  }\n};\n\n/**** Zip ****/\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) { // T need to have operator < !!\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    return (ll)d.size();\n  }\n};\n\n/**** Union Find ****/\n\nclass UnionFind {\n  ll par[UNION_FIND_MAX];\n  ll rank[UNION_FIND_MAX];\npublic:\n  void init(ll n) {\n    for (ll i = 0; i < n; i++) par[i] = i, rank[i] = 0;\n  }\n  UnionFind(ll n) {\n    init(n);\n  }\n  ll findRoot(ll x) {\n    if (par[x] == x) return x;\n    return par[x] = findRoot(par[x]);\n  }\n  void merge(ll x, ll y) {\n    x = findRoot(x);\n    y = findRoot(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return findRoot(x) == findRoot(y);\n  }\n};\n\ntemplate <typename T>\nclass UnionFindT {\n  ll par[UNION_FIND_MAX];\n  ll rank[UNION_FIND_MAX];\n  T weight[UNION_FIND_MAX];\npublic:\n  void init(ll n, T w) {\n    for (ll i = 0; i < n; i++) par[i] = i, rank[i] = 0, weight[i] = w;\n  }\n  UnionFindT(ll n, T w) {\n    init(n, w);\n  }\n  ll findRoot(ll x) {\n    if (par[x] == x) return x;\n    weight[x] += weight[par[x]];\n    return par[x] = findRoot(par[x]);\n  }\n  T getWeight(ll x) {\n    findRoot(x);\n    return weight[x];\n  }\n  bool merge(ll x, ll y, T w) {\n    // weight(y) = weight(x) + wにする\n    w += weight(x);\n    w -= weight(y);\n    x = findRoot(x);\n    y = findRoot(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) {\n      par[x] = y;\n      weight[x] = -w;\n    } else {\n      par[y] = x;\n      weight[y] = w;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n    return true;\n  }\n  T diff(ll x, ll y) { // xが基準でyの重み\n    return weight(y) - weight(x);\n  }\n  bool isSame(ll x, ll y) {\n    return findRoot(x) == findRoot(y);\n  }\n};\n\n/**** Segment Tree ****/\n\ntemplate <typename T>\nstruct SegmentTree {\n  ll n;\n  T dat[SEGMENT_TREE_MAX];\n  function<T(T, T)> acc;\n  T out;\n  SegmentTree(function<T(T, T)> func, T overNum) {\n    acc = func;\n    out = overNum;\n  }\n  void init(ll _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    for (ll i = 0; i < 2 * n - 1; i++) dat[i] = out;\n  }\n  void nodeUpdate(ll k, T d) {\n    // k番目をdに変える\n    k += n - 1;\n    dat[k] = d;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = acc(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  T rangeQuery(ll a, ll b) {\n    return tempRangeQuery(a, b, 0, 0, n);\n  }\n\nprivate:\n  T tempRangeQuery(const ll& a, const ll& b, ll k, ll l, ll r) {\n    if (r <= a || b <= l) return out;\n    if (a <= l && r <= b) return dat[k];\n    T vl = tempRangeQuery(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = tempRangeQuery(a, b, k * 2 + 2, (l + r) / 2, r);\n    return acc(vl, vr);\n  }\n};\n\n/**** Network Flow ****/\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  vector<edge> G[MAX_FLOW_MAX_V];\n  bool used[MAX_FLOW_MAX_V];\n  ll level[MAX_FLOW_MAX_V];\n  ll iter[MAX_FLOW_MAX_V];\n  \n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap) {\n    G[from].push_back((edge){to, cap, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap) {\n    G[e1].push_back((edge){e2, cap, (ll)G[e2].size()});\n    G[e2].push_back((edge){e1, cap, (ll)G[e1].size() - 1});\n  }\n  ll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (!used[e.to]&& e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      memset(used, 0, sizeof(used));\n      ll f = dfs(s, t, INF);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n  void bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      ll v = que.front(); que.pop();\n      for (ll i = 0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  ll dinic_dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for (ll &i= iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        ll d = dinic_dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll dinic(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      ll f;\n      while ((f = dinic_dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\n/**** bipartite matching ****/\n\nclass BipartiteMatching {\npublic:\n  ll V;\n  vector<ll> G[BIPARTITE_MATCHING_MAX_V];\n  ll match[BIPARTITE_MATCHING_MAX_V];\n  bool used[BIPARTITE_MATCHING_MAX_V];\n  \n  BipartiteMatching(ll v) {\n    V = v;\n  }\n  void init(ll v) {\n    V = v;\n    for (ll i = 0; i < BIPARTITE_MATCHING_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll u, ll v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  bool dfs(ll v) {\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      ll u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  ll max_matching() {\n    ll res = 0;\n    memset(match, -1, sizeof(match));\n    for (ll v = 0; v < V;v++) {\n      if (match[v] < 0) {\n        memset(used, 0, sizeof(used));\n        if (dfs(v)) {\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<edge> G[MIN_COST_FLOW_MAX_V];\n  ll dist[MIN_COST_FLOW_MAX_V];\n  ll prevv[MIN_COST_FLOW_MAX_V];\n  ll preve[MIN_COST_FLOW_MAX_V];\n  ll h[MIN_COST_FLOW_MAX_V];\n\n  MinCostFlow(ll v) {\n    V = v;\n  }\n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist, dist + V, 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = tmin<ll>(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\n/**** main function ****/\n\nll n, dp[4001][4001], sum[2001], mod = 998244353;\nchar s[2001];\n\nint main() {\n  scanf(\"%s\", s);\n  while (s[n] != 0) n++;\n  sum[0] = 0;\n  for (ll i = 0; i < n; i++) sum[i+1] = sum[i] + (s[i] == '1' ? 1 : (s[i] == '2' ? 2 : 0));\n  dp[0][0] = 1;\n  for (ll i = 1; i <= 2 * n; i++) {\n    for (ll j = 0; j <= lmin(i, sum[n]); j++) {\n      if (i != j && 2 * i - sum[lmin(i, n)] >= i - j) dp[i][j] += dp[i-1][j];\n      if (j != 0 && sum[lmin(i, n)] >= j) dp[i][j] += dp[i-1][j-1];\n      dp[i][j] %= mod;\n    }\n  }\n  printf(\"%lld\\n\", dp[2*n][sum[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nint N;\nchar S[2011];\n\nMint dp[4011][4011];\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n\n    dp[0][0] = 1;\n    int R = 0, B = 0;\n    REP (i, N*2) {\n\tint adR = 0, adB = 0;\n\tif (i < N) {\n\t    if (S[i] == '0') adR += 2;\n\t    if (S[i] == '1') { adR++; adB++; }\n\t    if (S[i] == '2') adB += 2;\n\t}\n\n\tREP (r, R+1) {\n\t    int b = R+B-i-r;\n\t    if (b < 0 || B < b) continue;\n\t    if (r + adR) dp[i+1][r+adR-1] += dp[i][r];\n\t    if (b + adB) dp[i+1][r+adR] += dp[i][r];\n\t}\n\tR += adR;\n\tB += adB;\n    }\n\n    printf(\"%d\\n\", dp[N*2][0].geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(4001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(2 * N + 1));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                dp[i][j] %= MOD;\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - (i - j);\n                }\n                if (b < 0) continue;\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    (dp[i + 1][j] += dp[i][j]) %= MOD;\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n            if (blue + red != N) {\n                exit(-1);\n            }\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i] % MOD;\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = (left * right) % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 998244353;\n\ntemplate <typename T>\nusing vector2 = vector<vector<T>>;\ntemplate <typename T>\nvector2<T> initVec2(size_t n0, size_t n1, T e = T()){\n    return vector2<T>(n0, vector<T>(n1, e));\n}\n\ntemplate <typename T>\nusing vector3 = vector<vector<vector<T>>>;\ntemplate <typename T>\nvector3<T> initVec3(size_t n0, size_t n1, size_t n2, T e = T()){\n    return vector3<T>(n0, vector2<T>(n1, vector<T>(n2, e)));\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string s;\n    cin >> s;\n    vector<int> r, b;\n    rep(i, SZ(s)){\n        if(s[i] == '0'){\n            r.push_back(i);\n            r.push_back(i);\n        }\n        if(s[i] == '1'){\n            r.push_back(i);\n            b.push_back(i);\n        }\n        if(s[i] == '2'){\n            b.push_back(i);\n            b.push_back(i);\n        }\n    }\n\n    auto dp = initVec2<int>(SZ(r) + 1, SZ(b) + 1);\n    dp[0][0] = 1;\n    rep(i, SZ(r) + 1){\n        rep(j, SZ(b) + 1){\n            if(i < SZ(r) && r[i] <= i + j){\n                dp[i+1][j] += dp[i][j];\n                dp[i+1][j] %= MOD;\n            }\n            if(j < SZ(b) && b[j] <= i + j){\n                dp[i][j+1] += dp[i][j];\n                dp[i][j+1] %= MOD;\n            }\n        }\n    }\n    cout << dp[SZ(r)][SZ(b)] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll mod = 998244353;\n\nll modpower(ll a, ll r){ //a^r\n    ll x = 1;\n    while (r > 0) {\n        if (r & 1) x = x * a % mod;\n        r >>= 1;\n        a = a * a % mod;\n    }\n    return x;\n}\n\nll modinv(ll a){\n    return modpower(a, mod-2);\n}\n\nvector<ll> fact;\nvector<ll> invfact;\n\nvoid set_fact(int n){\n    fact.resize(n+1, 1);\n    invfact.resize(n+1, 1);\n    for (int i = 2; i <= n; i++) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n    invfact[n] = modinv(fact[n]);\n    for (int i = n-1; i >= 2; i--) {\n        invfact[i] = invfact[i+1] * (i+1) % mod;\n    }\n    return;\n}\n\nll comb(int n, int k) {\n    if (k > n || k < 0) return 0;\n    if (k == n || k == 0) return 1;\n    return fact[n] * invfact[n-k] % mod * invfact[k] % mod;\n}\n\nint main(){\n    ll N;\n    string S;\n    cin >> S;\n    N = S.size();\n    vector<ll> blue(N+1, 0), red(N+1, 0);\n    for (int i = 1; i <= N; i++) {\n        blue[i] = blue[i-1] + (S[i-1] - '0');\n        red[i] = 2*i - blue[i];\n    }\n    \n    set_fact(2*N);\n    \n    vector<vector<ll>> dp(N+1, vector<ll>(N+1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= i-1; j++) {\n            if (blue[i] >= j+1) dp[i][j+1] = (dp[i][j+1]+dp[i-1][j])%mod;\n            if (red[i] >= i-j) dp[i][j] = (dp[i][j] + dp[i-1][j])%mod;\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        if (i > blue[N] || N-i > red[N]) continue;\n        ans = (ans + dp[N][i] * comb(N, blue[N]-i) %mod)%mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::stringstream; using std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\nusing std::cerr;\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)                                                     \\\n  {                                                                            \\\n    cerr << #a << \" = {\";                                                      \\\n    for (int qwq = (st); qwq <= (n); ++qwq)                                    \\\n      if (qwq == (st))                                                         \\\n        cerr << a[qwq];                                                        \\\n      else                                                                     \\\n        cerr << \", \" << a[qwq];                                                \\\n    cerr << \"}\" << endl;                                                       \\\n  }\n#define displayv(a) displaya(a, 0, (int)(a.size() - 1))\n#include <ctime>\nclass MyTimer {\n    clock_t st;\npublic:\n    MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n    ~MyTimer() { report(); }\n    void reset() { st = clock_t(); }\n    void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define cerr if(false) std::cout\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(a) ;\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename A, typename B>\nstd::ostream& operator << (std::ostream &cout, const pair<A, B> &x) {\n    return cout << \"(\" << x.first << \", \" << x.second << \")\";\n}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 2000 + 5;\nconst int P = 998244353;\nvoid inc(int &x, int y) { (x += y) >= P ? x -= P : x; }\nvoid dec(int &x, int y) { (x -= y) <  0 ? x += P : x; }\nint n;\nchar s[maxN];\nint r[maxN], b[maxN];\nint f[maxN][maxN];\n\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    memset(r, 0, sizeof(r));\n    memset(b, 0, sizeof(b));\n    for(int i = 1; i <= n; ++ i) {\n        if(s[i] == '0') r[i] = r[i - 1] + 2, b[i] = b[i - 1];\n        if(s[i] == '1') r[i] = r[i - 1] + 1, b[i] = b[i - 1] + 1;\n        if(s[i] == '2') r[i] = r[i - 1], b[i] = b[i - 1] + 2;\n    }\n    memset(f, 0, sizeof(f));\n    f[0][0] = 1;\n    for(int R = 0; R <= r[n]; ++ R) {\n        for(int B = 0; B <= b[n]; ++ B) {\n//            printf(\"f(%d, %d) = %d\\n\", R, B, f[R][B]);\n            int len = std::min(R + B + 1, n);\n            if(R < r[len]) inc(f[R + 1][B], f[R][B]);\n            if(B < b[len]) inc(f[R][B + 1], f[R][B]);\n        }\n    }\n    cout << f[r[n]][b[n]] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 998244353>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N;\nstd::string S;\nbool used[5000][5000];\nmint dp[5000][5000];\nmint func(int32_t i, int32_t r, int32_t b)\n{\n\tif (b < 0) {\n\t\treturn 0_mi;\n\t}\n\tif (r < 0) {\n\t\treturn 0_mi;\n\t}\n\tif (i == 2 * N) {\n\t\treturn 1_mi;\n\t}\n\tauto& memo = dp[i][r];\n\tif (used[i][r]) {\n\t\treturn memo;\n\t}\n\tused[i][r] = true;\n\tif (i < N) {\n\t\tif (S[i] == '0') {\n\t\t\tr += 2;\n\t\t}\n\t\telse if (S[i] == '1') {\n\t\t\tr += 1;\n\t\t\tb += 1;\n\t\t}\n\t\telse {\n\t\t\tb += 2;\n\t\t}\n\t}\n\treturn memo = func(i + 1, r, b - 1) + func(i + 1, r - 1, b);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> S;\n\tN = S.size();\n\tout << func(0,0,0) << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(2001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(N));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - b;\n                }\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    dp[i + 1][j + 1] += dp[i][j];\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    dp[i + 1][j] += dp[i][j];\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i];\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = left * right % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\ntypedef long long ll;\nusing namespace std;\n\nconst int N=4010,mod=998244353;\nchar s[N];\nint n,ans,a[N],b[N],f[N][N];\nvoid inc(int &x,int y){ x+=y; x-=(x>=mod)?mod:0; }\n\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\trep(i,1,n) a[i]=a[i-1]+2-(s[i]-'0'),b[i]=b[i-1]+s[i]-'0';\n\tf[0][0]=1;\n\trep(i,0,2*n) rep(j,0,i) if (f[i][j]){\n\t\tif (a[min(i+1,n)]>j) inc(f[i+1][j+1],f[i][j]);\n\t\tif (b[min(i+1,n)]>i-j) inc(f[i+1][j],f[i][j]);\n\t}\n\tprintf(\"%d\\n\",f[2*n][a[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(n);++i)\n#define rrep(i,n) for(int (i)=(n)-1;(i)>=0;--i)\n#define rep1(i,n) for(int (i)=1;(i)<=(n);++i)\n#define rrep1(i,n) for(int (i)=(n);(i)>=1;--i)\n#define pb push_back\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> LP;\ntypedef double db;\nusing namespace std;\nstring s;\nll ans;\nll A[2001];\nll dp[4001][4001];\nll cnt=0;\nll mod = 998244353;\nll N,r;\nint main()\n{\n  cin>>s;\n  N=s.size();\n  rep(i,N){\n    A[i+1]=0;\n    if(s[i]=='1') A[i+1]=1;\n    else if(s[i]=='2') A[i+1]=2;\n  }\n  dp[0][0]=1;\n  rep1(i,2*N){\n    if(i<=N){\n      cnt+=2;\n      r=A[i];\n    }\n    rep(j,2*N){\n      if(j+r < cnt) dp[i][j+r] = (dp[i][j+r]+dp[i-1][j])%mod; //青\n      if(j+r-1 >= 0)  dp[i][j+r-1] = (dp[i][j+r-1] + dp[i-1][j])%mod;\n    }\n    cnt-=1;\n  }\n  cout<<dp[2*N][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n#define m 998244353\n\nlong mo(long n){\n\t\treturn n%m;\n\t}\nvoid vl(const char& a,int& r,int& b){\n\tif(a=='0'){r+=2;}\n\telse if(a=='1'){r++;b++;}\n\telse{b+=2;}\n}\n\nint main(){\n\tstring s;\n\tconst int c=2000;\n\tcin>>s;\n\tint le=s.length();\n\tlong liba[2*c+1][2*c]={};//[i][j][k]iはi番目の箱jは赤個数\n\tliba[0][0]=1;//赤の個数\n\t\tint va[c*2][2]={};\n\tfor(int i=0;i<le;i++){\n\t\tvl(s[i],va[i][0],va[i][1]);\n\t\tif(i>0){\n\t\t\tva[i][0]+=va[i-1][0];\n\t\t\tva[i][1]+=va[i-1][1];\n\t\t}\n\t}\n\tfor(int i=0;i<le;i++)\n\t{\n\t\tva[le+i][0]=va[le+i-1][0];\n\t\tva[le+i][1]=va[le+i-1][1];\n\t}\n\tfor(int i=0;i<(2*le);i++)\n\t{\n\t\tfor(int j=0;j<2*le;j++)\n\t\t\t{\t\n\t\t\t\tif((j<=va[i][0])&&(i-j+1<=va[i][1])&&(i-j+1>=0))\n\t\t\t\t{\n\t\t\t\t\tliba[i+1][j]=mo(liba[i][j]+((j>0)?liba[i][j-1]:0));\n\t\t\t\t}\n\t\t\t}\n\t}\n\tlong cnt=0;\n\tfor(int i=0;i<le*2;i++)\n\t{\n\t\tcnt=mo(cnt+liba[le*2][i]);\n\t}\n\tcout<<cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////   _LeMur_\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <ctime>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int N = 4005;\nconst int inf = 1000 * 1000 * 1000;\nconst int mod = 998244353;\n\nstring s;\nint dp[N][N];\n\nint sz[N][2];\n\nint main(){\n    cin>>s;\n    for(int i=0;i<(int)s.size();i++){\n        sz[i + 1][0] = sz[i][0];\n        sz[i + 1][1] = sz[i][1];\n        ///\n        int x = s[i] - '0';\n        if(x == 0) sz[i + 1][0] += 2;\n        if(x == 1){\n            sz[i + 1][0]++;\n            sz[i + 1][1]++;\n        }\n        if(x == 2) sz[i + 1][1] += 2;\n    }\n    int n = (int)s.size();\n    for(int i=n+1;i<=2*n;i++){\n        sz[i][0] = sz[n][0];\n        sz[i][1] = sz[n][1];\n    }\n    dp[0][0] = 1;\n    for(int i=1;i<=2*n;i++){\n        for(int j=0;j<i;j++){\n            if(dp[i - 1][j] == 0)continue;\n            if(sz[i][0] - j > 0){\n                dp[i][j + 1] += dp[i - 1][j];\n                dp[i][j + 1] %= mod;\n            }\n            if(sz[i][1] - (i - 1 - j) > 0){\n                dp[i][j] += dp[i - 1][j];\n                dp[i][j] %= mod;\n            }\n        }\n    }\n    int answ = 0;\n    for(int i=0;i<=2*n;i++){\n        answ += dp[2*n][i];\n        answ %= mod;\n    }\n    cout<<answ<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst int MOD = 998244353;\n\nint dp[2001][2001];\nint N;\nstring s;\nint R[2001], B[2001];\n\nint dfs(int r, int b) {\n  if ( r+b == 2*N ) return 1;\n  if ( dp[r][b] >= 0 ) return dp[r][b];\n\n  int ret = 0;\n  if ( r+b >= N ) {\n    if ( R[N-1] > r ) ret += dfs(r+1, b);\n    if ( B[N-1] > b ) ret += dfs(r, b+1);    \n  } else {\n    if ( R[r+b] > r ) ret += dfs(r+1, b);\n    if ( B[r+b] > b ) ret += dfs(r, b+1);    \n  }\n\n  return dp[r][b] = ret%MOD;  \n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  fill_n(*dp, 2001*2001, -1);\n  cin >> s;\n  N = s.size();\n\n  for ( int i = 0; i < N; i++ ) {\n    if ( i ) {\n      R[i] += R[i-1];\n      B[i] += B[i-1];      \n    }\n    if ( s[i] == '0' ) {\n      R[i] += 2;\n    }\n    if ( s[i] == '1' ) {\n      R[i]++;\n      B[i]++;\n    }\n    if ( s[i] == '2' ) {\n      B[i] += 2;      \n    }\n  }\n\n  cout << dfs(0, 0) << endl;  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fec(i, x, y) (int i = head[x], y = g[i].to; i; i = g[i].ne, y = g[i].to)\n#define dbg(...) fprintf(stderr, __VA_ARGS__)\n#define File(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n#define fi first\n#define se second\n#define pb push_back\n\ntemplate<typename A, typename B> inline char SMAX(A &a, const B &b) {return a < b ? a = b , 1 : 0;}\ntemplate<typename A, typename B> inline char SMIN(A &a, const B &b) {return b < a ? a = b , 1 : 0;}\n\ntypedef long long ll; typedef unsigned long long ull; typedef std::pair<int, int> pii;\n\ntemplate<typename I>\ninline void read(I &x) {\n\tint f = 0, c;\n\twhile (!isdigit(c = getchar())) c == '-' ? f = 1 : 0;\n\tx = c & 15;\n\twhile (isdigit(c = getchar())) x = (x << 1) + (x << 3) + (c & 15);\n\tf ? x = -x : 0;\n}\n\nconst int N = 1000 + 7;\nconst int P = 998244353;\n\nint n, cntb[N << 1], dp[N << 1][N << 1];\nchar s[N];\n\ninline void Inc(int &x, int y) {x += y; x >= P ? x -= P : 0;}\n\nint main() {\n\t#ifdef hzhkk\n\tfreopen(\"hkk.in\", \"r\", stdin);\n\t#endif\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tfor (int i = 1; i <= n; ++i) cntb[i] = cntb[i - 1] + s[i] - '0';\n\tfor (int i = n + 1; i <= (n << 1); ++i) cntb[i] = cntb[i - 1];\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= (n << 1); ++i) {\n\t\tfor (int j = std::max(cntb[i] - i, 0); j <= std::min(cntb[i], i); ++j) {\n\t\t\tif (j) dp[i][j] = dp[i - 1][j - 1];\n\t\t\tif (i > j) Inc(dp[i][j], dp[i - 1][j]);\n\t\t\t//  dbg(\"dp[%d][%d] = %d\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n << 1][cntb[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(auto &it : (v))\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define sz(x) (int)(x).size()\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nll dp[4005][4005];\nll sum[2005];\n\nint main(){\n\tios::sync_with_stdio(0);\n    int N;\n    string S;\n    cin >> S;\n    N = sz(S);\n    rep(i,0,N) {\n        sum[i+1] = sum[i] + (S[i] - '0');\n    }\n    dp[0][0] = 1;\n    rep(i,0,2*N) {\n        rep(j,0,2*N+1) {\n            if (j > i)\n                continue;\n            if (i < N && j > sum[i])\n                continue;\n            if (i < N && i-j > 2*i-sum[i])\n                continue;\n            dp[i][j] %= MOD;\n            dp[i+1][j] += dp[i][j];\n            dp[i+1][j+1] += dp[i][j];\n        }\n    }\n    dp[2*N][sum[N]] %= MOD;\n    cout << dp[2*N][sum[N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\nconst int mo=998244353;\n\nint f[2001][2001],s1[2001],s2[2001];\nchar s[2001];\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tint n=strlen(s);\n\tfor(int i=0;i<n;i++) \n\t{\n\t\ts1[i+1]=s1[i]+s[i]-'0';\n\t\ts2[i+1]=2*(i+1)-s1[i+1];\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<=s1[n];i++)\n\t\tfor(int j=0;j<=s2[n];j++)\n\t\t\tif((s1[min(i+j,n)]>=i)&&(s2[min(i+j,n)]>=j))\n\t\t\t{\n\t\t\t\tif(i) f[i][j]=(f[i][j]+f[i-1][j])%mo;\n\t\t\t\tif(j) f[i][j]=(f[i][j]+f[i][j-1])%mo;\n\t\t\t}\n\tcout<<f[s1[n]][s2[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nll pow(ll x,ll y){\n  if(y==0) return 1;\n  ll res=pow(x,y/2);\n  res*=res;\n  res%=mod;\n  if(y%2==1) res*=x;\n  return res%mod;\n}\nll gyaku(ll x){\n  return pow(x,mod-2);\n}\nvector<ll> frac,gfrac;\nvoid set_frac(ll n){\n  frac.push_back(1);\n  gfrac.push_back(1);\n  for(ll i=1;i<=n;i++){\n    frac.push_back(frac[i-1]*i%mod);\n    gfrac.push_back(gyaku(frac[i]));\n  }\n}\nll nCr(ll n,ll r){\n  ll res=frac[n]*gfrac[r]%mod;\n  res*=gfrac[n-r];\n  return res%mod;\n}\nll dp[2005][4005]={0};\nint main(){\n  string s; cin>>s;\n  ll n=s.length(),rnum=0,bnum=0;\n  vector<ll> rsum,bsum;\n  rsum.push_back(0);\n  bsum.push_back(0);\n  for(int i=0;i<n;i++){\n    ll R=0,B=0;\n    if(s[i]=='0') R+=2;\n    else if(s[i]=='1'){\n      R++;\n      B++;\n    }\n    else B+=2;\n    rnum+=R;\n    rsum.push_back(rnum);\n    bnum+=B;\n    bsum.push_back(bnum);\n  }\n  set_frac(n+10);\n/*  for(int i=0;i<=n;i++) cout<<rsum[i]<<\" \";\n  cout<<endl;\n  for(int i=0;i<=n;i++) cout<<bsum[i]<<\" \";\n  cout<<endl; */\n  dp[0][0]=1;\n  for(int i=0;i<n;i++){\n    for(int r=0;r<n;r++){\n      if(rsum[i+1]>=r+1) dp[i+1][r+1]+=dp[i][r];\n      if(bsum[i+1]>=(i+1-r)) dp[i+1][r]+=dp[i][r];\n      dp[i+1][r+1]%=mod;\n      dp[i+1][r]%=mod;\n    }\n  }\n  //cout<<rnum<<\" \"<<bnum<<endl;\n  ll ans=0;\n/*  for(int i=0;i<=n;i++){\n    for(int j=0;j<=rnum;j++) cout<<dp[i][j]<<\" \";\n    cout<<endl;\n  } */\n  for(int i=0;i<=n;i++){\n    if(rnum<i) continue;\n    ll kans=nCr(n,rnum-i);\n    kans*=dp[n][i];\n    kans%=mod;\n    ans+=kans;\n    ans%=mod;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\n#define fi first\n#define se second\n\nint dp[4003][4003],r[2003],b[2003];\n\nsigned main(){\n  string s;\n  cin>>s;\n  int n=s.size();\n  r(i,s.size()){\n    if(s[i]=='0')r[i]=2;\n    if(s[i]=='1')r[i]=1,b[i]=1;\n    if(s[i]=='2')b[i]=2;\n  }\n  r(i,s.size()-1){\n    r[i+1]+=r[i];\n    b[i+1]+=b[i];\n  }\n  dp[0][0]=1;\n  r(i,n*2){\n    r(j,n*2)if(j<=i){\n      int x=min(i,n-1);\n      if(r[x]-j>0)dp[i+1][j+1] += dp[i][j];\n      if(b[x]-(i-j)>0)dp[i+1][j] += dp[i][j];\n      dp[i+1][j+1]%=998244353;\n      dp[i+1][j]%=998244353;\n    }\n  }\n  int sum=0;\n  r(i,2003)sum+=dp[n*2][i],sum%=998244353;\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nlong long cc[2001][2001];\nlong long c(int x,int y){\n\tif(~cc[x][y])\n\t   return cc[x][y];\n\tif(x==y)\n\t   return 1;\n\tif(y==0)\n\t   return 1;\n\tif(y==1)\n\t   return x;\n\tif(y==x-1)\n\t   return x;\n\treturn cc[x][y]=(c(x-1,y-1)+c(x-1,y));\n}\nint main()\n{\n\tmemset(cc,-1,sizeof(cc));\n\tcin>>s;\n\tint mode;\n\tif(s[0]=='0'||s[0]=='2')\n\t   mode=2;\n\telse\n\t   mode=1;\n\tlong long summ=1;\n\tlong long cntb=0,cntr=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tcntb+=(s[i]-'0');\n\t\tcntr+=('2'-s[i]);\n\t}\n\tcout<<(c(s.size()*2,cntb)/mode)%998244353;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst ll mod = 998244353;\n\nstring s;\nll cum1[2010], cum2[2010];\nll d[2010][2010];\n\nsigned main() {\n\tcin >> s;\n\tint n = (int)s.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '0')cum1[i + 1] += 2;\n\t\tif (s[i] == '1')cum1[i + 1]++, cum2[i + 1]++;\n\t\tif (s[i] == '2')cum2[i + 1] += 2;\n\t\tcum1[i + 1] += cum1[i];\n\t\tcum2[i + 1] += cum2[i];\n\t}\n\td[0][0] = 1;\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tif (j + 1<= cum1[min(n, i + 1)])d[j + 1][i - j] = (d[j + 1][i - j] + d[j][i - j]) % mod;\n\t\t\tif (i - j + 1 <= cum2[min(n, i + 1)])d[j][i + 1 - j] = (d[j][i + 1 - j] + d[j][i - j]) % mod;\n\t\t}\n\t}\n\tcout << d[cum1[n]][cum2[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nconst int MOD = 998244353;\n\nint main() {\n  static char S[2019]; scanf(\"%2018s\", S);\n  int N = strlen(S);\n  static int subsums[2001];\n  subsums[0] = 0;\n  for(int i = 0; i < N; ++i) {\n    subsums[i+1] = subsums[i] + (S[i] - '0');\n    // fprintf(stderr, \"subsums[%d] = %d\\n\", i+1, subsums[i+1]);\n  }\n  static int dp[4001] = {};\n  dp[0] = 1;\n  for(int i = 1; i <= N; ++i) {\n    for(int j = i; j >= 0; --j) {\n      if(j > subsums[i] || i-j > i*2-subsums[i]) {\n        dp[j] = 0;\n        continue;\n      }\n      if(j > 0) dp[j] = (dp[j] + dp[j-1]) % MOD;\n    }\n    // for(int j = 0; j <= i; ++j) {\n    //   fprintf(stderr, \"dp[%d][%d] = %d\\n\", i, j, dp[j]);\n    // }\n  }\n  for(int i = 0; i < N; ++i) {\n    for(int j = subsums[N] - 1; j >= 0; --j) {\n      dp[j+1] = (dp[j+1] + dp[j]) % MOD;\n    }\n  }\n  printf(\"%d\\n\", dp[subsums[N]]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate < typename T >\nvoid vprint(T &v){\n\tREP(i, v.size()){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tvector<ll> red(N+1, 0), blue(N+1, 0);\n\tREP(i, N){\n\t\tif(S[i]=='0'){\n\t\t\tred[i+1] = red[i] + 2;\n\t\t\tblue[i+1] = blue[i];\n\t\t}else if(S[i]=='1'){\n\t\t\tred[i+1] = red[i] + 1;\n\t\t\tblue[i+1] = blue[i] + 1;\n\t\t}else{\n\t\t\tred[i+1] = red[i];\n\t\t\tblue[i+1] = blue[i] + 2;\n\t\t}\n\t}\n\tll ma = 4040;\n\tll dp[ma][ma];\n\tREP(i, ma)REP(j, ma) dp[i][j] = 0;\n\tdp[0][0] = 1;\n\tREP(i, 2*N){\n\t\tll ikeru = min((ll)i, N-1);\n\t\tll ikered = red[ikeru+1];\n\t\tll ikeblue = blue[ikeru+1];\n\t\tREP(j, 2*N){\n\t\t\tif(ikered>j){\n\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\tdp[i+1][j+1] %= mod;\n\t\t\t}\n\t\t\tif(ikeblue>i-j){\n\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\tdp[i+1][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2*N][red[N]] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n#define debugArrayP(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge].first<< \" \" << x[hoge].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 998244353;\n\nll dp[2010][2010];\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  string S;cin>>S;\n  ll N=S.length();\n  ll J=0;\n  dp[0][1]=1;\n  repeat(i,N){\n  J+=S[i]-'0';\n    for(int j=max(0ll,J-i-1);j<=min(i+1,J);j++){\n      dp[i+1][j+1] = (dp[i][j+1]+dp[i][j])%MOD;\n    }\n  }\n  repeat(i,N){\n    for(int j=max(0ll,J-N);j<=min(N,J);j++){\n      dp[N+i+1][j+1] = (dp[N+i][j+1]+dp[N+i][j])%MOD;\n    }\n  }\n  cout << dp[2*N][J+1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\ntypedef complex<double> com;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nint dp[4010][4010];\nll mod = 998244353;\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i < n) {\n\t\t\t\tint k = s[i] - '0' + j;\n\t\t\t\tif (i + 2 > k) {\n\t\t\t\t\tdp[i + 1][k] += dp[i][j];\n\t\t\t\t\tif (dp[i + 1][k] > mod) dp[i + 1][k] -= mod;\n\t\t\t\t}\n\t\t\t\tif (k > 0) {\n\t\t\t\t\tdp[i + 1][k - 1] += dp[i][j];\n\t\t\t\t\tif (dp[i + 1][k - 1] > mod) dp[i + 1][k - 1] -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (2 * n - i - j > 0) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\tif (dp[i + 1][j] > mod) dp[i + 1][j] -= mod;\n\t\t\t\t}\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\tif (dp[i + 1][j - 1] > mod) dp[i + 1][j - 1] -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2 * n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\nconst int M=998244353;\nchar s[3333]; \nbool b[4444][4444];\nint f[4444][4444];\nint sub[5][2]={{'3',0},{'4','3'},{0,'4'}};\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tint R=0,B=0;\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='0')R+=2;\n\t\tif(s[i]=='1')++R,++B;\n\t\tif(s[i]=='2')B+=2;\n\t}\n\tint x=0,y=0;\n\twhile(1)\n\t{\n\t\tint pl=0;\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\tif(s[i]=='0'||s[i]=='2'){pl=i;break;}\n\t\tif(pl==0)break;\n\t\tif(s[pl]=='0')\n\t\t{\n\t\t\tb[x][y+pl]=1;\n\t\t\ts[1]=sub[s[1]-'0'][0];\n\t\t\t++x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[x+pl][y]=1;\n\t\t\ts[1]=sub[s[1]-'0'][1];\n\t\t\t++y;\n\t\t}\n\t\tfor(register int i=1;i<n;++i)\n\t\t{\n\t\t\tif(s[i]=='3')\n\t\t\t{\n\t\t\t\tif(s[i+1]!='0'&&s[i+1]!='3')s[i]='1',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t\t\telse s[i]='0',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(s[i+1]!='2'&&s[i+1]!='4')s[i]='1',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t\t\telse s[i]='2',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t}\n\t\t}\n\t\tif(!s[n])--n;\n\t}\n\tf[0][0]=1;\n\tfor(register int i=0;i<=R;++i)\n\t\tfor(register int j=0;j<=B;++j)\n\t\t\tif(b[i][j]==0)\n\t\t\t{\n\t\t\t\tif(i)f[i][j]=(f[i][j]+f[i-1][j])%M;\n\t\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1])%M;\n\t\t\t}\n\tprintf(\"%d\\n\",f[R][B]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nvoid radd(int &x, int y)\n{\n\tx=add(x,y);\n}\n\nint a[111111];\nint dp[4555][4555];\nint c[2];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring s; cin>>s;\n\tint n=s.length();\n\tfor(int i=0;i<n;i++) a[i]=s[i]-'0';\n\tdp[0][0]=1;\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(i<n)\n\t\t{\n\t\t\tc[0]+=a[i];\n\t\t\tc[1]+=2-a[i];\n\t\t}\n\t\tfor(int j=0;j<=2*n;j++)\n\t\t{\n\t\t\tint v=dp[i][j];\n\t\t\tif(v==0) continue;\n\t\t\tint C[2]={c[0],c[1]};\n\t\t\tC[0]-=j;\n\t\t\tC[1]-=(i-j);\n\t\t\t//cerr<<i<<' '<<j<<' '<<v<<' '<<C[0]<<' '<<C[1]<<'\\n';\n\t\t\tif(C[0]<0||C[1]<0) continue;\n\t\t\t//choose 1\n\t\t\tif(C[1]>0) radd(dp[i+1][j],v);\n\t\t\t//choose 0\n\t\t\tif(C[0]>0) radd(dp[i+1][j+1],v);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=2*n;i++) ans=add(ans,dp[2*n][i]);\n\tcout<<ans<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\n#include <complex>\n//#include <atcoder/all>\nusing namespace std;\n//using namespace atcoder;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    for(auto itr = a.begin(); itr != a.end(); itr++){\n\t\tcout << *itr << \" \";\n\t}\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){\n\tcout << \"debug: \" << a << \" \" << b << \"\\n\";\n}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << \"debug: \" << a << \" \" << b << \" \" << c << \"\\n\";\n}\nvoid mark() {cout << \"#\" << \"\\n\";}\nll pcount(ll x) {return __builtin_popcountll(x);}\n//const int mod = 1e9 + 7;\nconst int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nmint dp[2][4040]; //i番目, 青j個並べた\nvl r(4040,inf);\nvl b(4040,inf);\n\nint main(){\n    string s; cin >> s;\n    int n = s.size();\n    int rid = 0, bid = 0;\n    int R = 0, B = 0;\n    rep(i,n){\n        if(s[i] == '0'){\n            r[rid++] = i;\n            r[rid++] = i;\n        }\n        if(s[i] == '1'){\n            r[rid++] = i;\n            b[bid++] = i;\n        }\n        if(s[i] == '2'){\n            b[bid++] = i;\n            b[bid++] = i;\n        }\n    }\n    dp[0][0] = 1;\n    rep(i,2*n){\n        rep(j,bid+1) dp[1][j] = 0; \n        rep(j,i+1){\n            //blue : j個, red : i-j個\n            if(b[j] <= i) dp[1][j+1] += dp[0][j];\n            if(r[i-j] <= i) dp[1][j] += dp[0][j];\n        }\n        swap(dp[0], dp[1]);\n    }\n    cout << dp[0][bid].value() << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_f\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass reverse_range {private:struct I {int x;int operator*() {return x-1;}bool operator!=(I& lhs) {return x>lhs.x;}void operator++() {--x;}};I i, n;public:reverse_range(int n) :i({ 0 }), n({ n }){}reverse_range(int i, int n) :i({ i }), n({ n }){}I& begin() {return n;}I& end() {return i;}};\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }reverse_range operator!(){return reverse_range(*i,*n);}};\n\nLL dp[4123][4123];\nconstexpr int mod =998244353;\nLL RS[2123];\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    dp[0][0]=1;\n    for(int i:range(n)){\n        int r=s[i]-'0';\n        RS[i+1]=RS[i]+r;\n    }\n    for(int i:range(1,2*n+1)){\n        int rs=RS[min(i,n)];\n        int cs=2*min(i,n)-RS[min(i,n)];\n        for(int j:range(i+1)){\n            int r=j;\n            int c=i-j;\n            if(r<=rs&&r>0){\n                dp[r][c]+=dp[r-1][c];\n            }\n            if(c<=cs&&c>0){\n                dp[r][c]+=dp[r][c-1];\n            }\n            dp[r][c]%=mod;\n        }\n    }\n    cout<<dp[RS[n]][2*n-RS[n]]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[2010][2010], n;\nll nthblueat[2010], nthredat[2010], numblue, numred;\nchar inp[2010];\nint main()\n{\n\tscanf(\" %s\", inp);\n\tn = strlen(inp);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (inp[i] == '0')\n\t\t{\n\t\t\tnthredat[numred++] = i;\n\t\t\tnthredat[numred++] = i;\n\t\t}\n\t\telse if (inp[i] == '1')\n\t\t{\n\t\t\tnthredat[numred++] = i;\n\t\t\tnthblueat[numblue++] = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnthblueat[numblue++] = i;\n\t\t\tnthblueat[numblue++] = i;\n\t\t}\n\t}\n\tdp[0][0]++;\n\tfor (int i = 0; i <= numblue; i++)\n\t{\n\t\tfor (int j = 0; j <= numred; j++)\n\t\t{\n\t\t//\tprintf(\"%d %d - %lld\\n\", i, j, dp[i][j]);\n\t\t\tdp[i][j] %= 998244353;\n\t\t\tif (i < numblue && nthblueat[i] <= i+j)\n\t\t\t{\n\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t}\n\t\t\tif (j < numred && nthredat[j] <= i+j)\n\t\t\t{\n\t\t\t\tdp[i][j+1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[numblue][numred]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PP;\ntypedef complex<double> com;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nint dp[4010][4010];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i < n) {\n\t\t\t\tint k = s[i] - '0' + j;\n\t\t\t\tif (i + 2 > k) dp[i + 1][k] += dp[i][j];\n\t\t\t\tif (k > 0) dp[i + 1][k - 1] += dp[i][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (2 * n - j > 0) dp[i + 1][j] += dp[i][j];\n\t\t\t\tif (j > 0) dp[i + 1][j - 1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2 * n][0] % 998244353 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void mmax(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void mmin(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nconstexpr lint MOD = 998244353;\n\nvector<vector<plint>> dp1;\nvector<vector<lint>> dp2;\nint N;\nint main()\n{\n    string S;\n    cin >> S;\n    N = S.length();\n\n    ndarray(dp1, N, N * 2 + 1);\n    lint R = 0, B = 0;\n    IREP(i, N)\n    {\n        if (S[i] == '0') dp1[i][0] = plint(2, 0);\n        if (S[i] == '1') dp1[i][0] = plint(1, 1);\n        if (S[i] == '2') dp1[i][0] = plint(0, 2);\n        R += dp1[i][0].first;\n        B += dp1[i][0].second;\n        REP(t, N * 2)\n        {\n            dp1[i][t + 1] = dp1[i][t];\n            if (i < N - 1) dp1[i][t + 1] = dp1[i][0] + dp1[i + 1][t];\n        }\n    }\n\n    ndarray(dp2, R + 1, B + 1);\n    dp2[0][0] = 1;\n    REP(i, R + 1) REP(j, B + 1)\n    {\n        if (i) dp2[i][j] += dp2[i - 1][j];\n        if (j) dp2[i][j] += dp2[i][j - 1];\n        dp2[i][j] %= MOD;\n        if (dp1[0][i + j - 1].first < i or dp1[0][i + j - 1].second < j) dp2[i][j] = 0;\n    }\n    cout << dp2[R][B] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define pb(a) push_back\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), n)\n#define ub(v,n) upper_bound(v.begin(), v.end(), n)\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\n#define move(x) ans.push_back(x),c[x]--,now=x;\n \ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\nconst int MOD = 998244353; const int MAX = 200020;\nconst double pi = acos(-1); const double EPS = 1e-12;\nconst ll INF = 2e18;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\n\nint dp[2020][2020];\nint cumR[2020];\nint A[2020],B[2020];\nint sumR,sumB;\nvoid solve() {\n\tstring S;cin>>S;\n\tint N=S.size();\n\tCOMinit();\n\tREP(i,N){\n\t\tint num=S[i]-'0';\n\t\tA[i]+=num;\n\t\tB[i]+=2-num;\n\t\tcumR[i+1]+=cumR[i]+A[i];\n\t\tsumR+=A[i];\n\t\tsumB+=B[i];\n\t}\n\tdp[0][0]=1;\n\tREP(i,N){\n\t\tREP(r,N+1){\n\t\t\tif(r>0&&cumR[i+1]>=r)dp[i+1][r]+=dp[i][r-1];\n\t\t\tint cumB=(i+1)*2-cumR[i+1];\n\t\t\tif(cumB>=i+1-r)dp[i+1][r]+=dp[i][r];\n\t\t\tdp[i+1][r]%=MOD;\n\t\t\t//pe(i+1);pe(r);print(dp[i+1][r]);\n\t\t}\n\t}\n\tll ans=0;\n\n\tREP(r,N+1){\n\t\tll res=mult(dp[N][r],fac[N]);\n\t\tres=mult(res,mult(finv[sumR-r],finv[sumB-(N-r)]));\n\t\tans=add(ans,res);\n\t}\n\tprint(ans);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n\nint main() {\n    string s; cin >> s;\n    int n = s.size();\n    long long r = 0; long long b = 0;\n    long long dp[2*n+1][2*n+1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (int i = 0; i < 2*n; i++) {\n        if (i < n) {\n            if (s[i] == '0') {\n                r += 2;\n            } else if (s[i] == '1') {\n                r += 1; b += 1;\n            } else {\n                b += 2;\n            }\n        }\n        for (int j = 0; j < 2*n+1; j++) {\n            if (j < r) {\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= mod;\n            }\n            if (i-j < b) {\n                dp[i+1][j] += dp[i][j];\n                dp[i+1][j] %= mod;\n            }\n        }\n    }\n    cout << dp[2*n][r] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nll dp[4001][4001];\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n\n    dp[0][0] = 1LL;\n    int red = 0, r = 0;\n    for(int i=0;i<2*n;++i) {\n        if(i < n) {\n            r = 2 - int(s[i] - '0');\n            red += r;\n        }\n        for(int j=0;j<=min(i,red);++j) {\n            if(j < red) {\n                dp[i+1][j+1] += dp[i][j];\n            } else {\n                dp[i+1][j+1] = 0;\n            }\n            dp[i+1][j+1] %= MOD;\n            if(i-j < min(i+1,n)*2-red) {\n                dp[i+1][j] += dp[i][j];\n            } else {\n                dp[i+1][j] = 0;\n            }\n            dp[i+1][j] %= MOD;\n        }\n    }\n\n    cout << dp[2*n][red] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n#define debugArrayP(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge].first<< \" \" << x[hoge].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 998244353;\n\nll dp[4010][4010];\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  string S;cin>>S;\n  ll N=S.length();\n  ll J=0;\n  dp[0][1]=1;\n  repeat(i,N){\n    J+=S[i]-'0';\n    for(int j=max(0ll,J-i-1);j<=min(i+1,J);j++){\n      dp[i+1][j+1] = (dp[i][j+1]+dp[i][j])%MOD;\n    }\n  }\n  repeat(i,N){\n    for(int j=max(0ll,J-N);j<=min(N,J);j++){\n      dp[N+i+1][j+1] = (dp[N+i][j+1]+dp[N+i][j])%MOD;\n    }\n  }\n  cout << dp[2*N][J+1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\nconst int M=998244353;\nchar s[3333]; \nint b[2222][2222],f[2222][2222];\nint sub[5][2]={{'3',0},{'4','3'},{0,'4'}};\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tint R=0,B=0;\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='0')R+=2;\n\t\tif(s[i]=='1')++R,++B;\n\t\tif(s[i]=='2')B+=2;\n\t}\n\tint x=0,y=0;\n\twhile(1)\n\t{\n\t\tint pl=0;\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\tif(s[i]=='0'||s[i]=='2'){pl=i;break;}\n\t\tif(pl==0)break;\n\t\tif(s[pl]=='0')\n\t\t{\n\t\t\tb[x][y+pl]=1;\n\t\t\ts[1]=sub[s[1]-'0'][0];\n\t\t\t++x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[x+pl][y]=1;\n\t\t\ts[1]=sub[s[1]-'0'][1];\n\t\t\t++y;\n\t\t}\n\t\tfor(register int i=1;i<n;++i)\n\t\t{\n\t\t\tif(s[i]=='3')\n\t\t\t{\n\t\t\t\tif(s[i+1]!='0'&&s[i+1]!='3')s[i]='1',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t\t\telse s[i]='0',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(s[i+1]!='2'&&s[i+1]!='4')s[i]='1',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t\t\telse s[i]='2',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t}\n\t\t}\n\t\tif(!s[n])--n;\n\t}\n\tf[0][0]=1;\n\tfor(register int i=0;i<=R;++i)\n\t\tfor(register int j=0;j<=B;++j)\n\t\t\tif(b[i][j]==0)\n\t\t\t{\n\t\t\t\tif(i)f[i][j]=(f[i][j]+f[i-1][j])%M;\n\t\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1])%M;\n\t\t\t}\n\tprintf(\"%d\\n\",f[R][B]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\npublic:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr double eps = 1e-9;\n\nvoid solve() {\n    constexpr i64 mod = 998244353;\n\n    string S;\n    cin >> S;\n\n    set<string> st;\n    function<void(vector<vector<int>>, int, string)> dfs=[&](vector<vector<int>> v, int i, string res){\n        if(v.empty()){\n            st.insert(res);\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            dfs(v,0,res);\n            return;\n        }\n\n        rep(j,0,v[i].size()){\n            auto nv=v;\n            auto nres=res;\n            if(i==0){\n                nres+='0'+nv[i][j];\n            }else{\n                nv[i-1].emplace_back(nv[i][j]);\n            }\n            nv[i].erase(begin(nv[i])+j);\n            dfs(nv,i+1,nres);\n        }\n    };\n\n    const i64 N=S.size();\n\n    vector<vector<int>> v(N);\n    rep(i,0,N){\n        if(S[i]=='0'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(0);\n        }else if(S[i]=='1'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(1);\n        }else{\n            v[i].emplace_back(1);\n            v[i].emplace_back(1);\n        }\n    }\n\n    string mini,maxi;\n\n    function<void(vector<vector<int>>, int, string)> find_min=[&](vector<vector<int>> v, int i, string res){\n        if(v.empty()){\n            mini=res;\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            find_min(v,0,res);\n            return;\n        }\n\n        sort(begin(v[i]),end(v[i]));\n        if(i==0){\n            res+='0'+v[i][0];\n        }else{\n            v[i-1].emplace_back(v[i][0]);\n        }\n        v[i].erase(begin(v[i]));\n        find_min(v,i+1,res);\n    };\n\n    function<void(vector<vector<int>>, int, string)> find_max=[&](vector<vector<int>> v, int i, string res){\n        if(v.empty()){\n            maxi=res;\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            find_max(v,0,res);\n            return;\n        }\n\n        sort(rbegin(v[i]),rend(v[i]));\n        if(i==0){\n            res+='0'+v[i][0];\n        }else{\n            v[i-1].emplace_back(v[i][0]);\n        }\n        v[i].erase(begin(v[i]));\n        find_max(v,i+1,res);\n    };\n\n    find_min(v,0,\"\");\n    find_max(v,0,\"\");\n\n    print(mini);\n    print(maxi);\n\n    vector<i64> rmin(N),bmin(N);\n    {\n        i64 r=0,b=0;\n        rep(i,0,N){\n            rep(j,0,2){\n                if(v[i][j]==0) ++r;\n                else ++b;\n            }\n            rmin[i]=max(i+1-b,i64(0));\n            bmin[i]=max(i+1-r,i64(0));\n        }\n    }\n\n    print(rmin);\n    print(bmin);\n\n    function<fp<mod>(string)> count=[&](string m) {\n        constexpr i64 maxn = 2000;\n        static fp<mod> dp[maxn * 2][2][maxn + 1]; // 桁, 境界か?, 使用したbの数\n        fill_n((fp<mod> *) dp, maxn * 2 * 2 * (maxn + 1), fp<mod>(0));\n\n        i64 sumb=0;\n        rep(i,0,m.size()) if(m[i]=='1') ++sumb;\n\n        if(m[0]=='0'){\n            dp[0][1][0]=1;\n        }else{\n            dp[0][0][0]=1;\n            dp[0][1][1]=1;\n        }\n\n        rep(i,0,m.size()-1){\n            rep(j,0,2){\n                rep(k, 0, sumb + 1){\n                    if(i<N){\n                        i64 r=i+1-k;\n                        i64 b=k;\n                        if(r<rmin[i] or b<bmin[i]) continue;\n                    }\n\n                    // r=0を置く\n                    if(m[i+1]=='0'){\n                        if(j==0){\n                            // 既に境界より低い\n                            dp[i+1][0][k]+=dp[i][j][k];\n                        }else{\n                            dp[i+1][1][k]+=dp[i][j][k];\n                        }\n                    }else{\n                        dp[i+1][0][k]+=dp[i][j][k];\n                    }\n\n                    // sumb=1を置く\n                    if(k < sumb) {\n                        if (m[i + 1] == '0') {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界を超える\n                            }\n                        } else {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界にいる\n                                dp[i+1][1][k+1]+=dp[i][j][k];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[m.size()-1][0][sumb] + dp[m.size() - 1][1][sumb];\n    };\n\n    const auto ans=count(maxi)-count(mini)+1;\n\n    cout << ans << endl;\n/*\n#ifdef DEBUG\n    dfs(v,0,\"\");\n    print(st.size());\n    for(auto str:st){\n        cout << str << endl;\n    }\n#endif\n */\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    friend constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    friend constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y); return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint inverse(const modint &other) noexcept { assert(other); return other; }\n    friend constexpr modint pow(const modint &other, long long exp) noexcept { return other; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(string,s);\n        const int n(s.size());\n        vector<mint> dp(n*2+1);\n        dp[0]=1;\n        int red=0,blue=0;\n        for(int i=0; i<n*2; ++i)\n        {\n            if(i<n)\n            {\n                blue+=s[i]-'0';\n                red+=2-(s[i]-'0');\n            }\n            for(int r=i,b=0; r>=0; --r,++b)\n            {\n                if(r<red and b<=blue) dp[r+1]+=dp[r];\n                if(b==blue) dp[r]=0;\n            }\n        }\n        cout << dp[red] << \"\\n\";\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nll mod=998244353;\nll combi(ll N_, ll C_) {\n    const int NUM_=400001;\n    static ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n    if (fact[0]==0) {\n        inv[1]=fact[0]=factr[0]=1;\n        for (int i=2;i<=NUM_;++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n        for (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mod, factr[i]=factr[i-1]*inv[i]%mod;\n    }\n    if(C_<0 || C_>N_) return 0;\n    return factr[C_]*fact[N_]%mod*factr[N_-C_]%mod;\n}\nll dp[4005][4005];\nll sum[2005];\nll sum2[2005];\nint n;\nbool ok1(int i,int j){\n    if(i>=n){\n        return sum[n]-j>=1;\n    }else{\n        return sum[i]-j>=1;\n    }\n}\nbool ok2(int i,int j){\n    if(i>=n){\n        return sum2[n]-j>=1;\n    }else{\n        return sum2[i]-j>=1;\n    }\n}\nint main(){\n    string s;\n    cin >> s;\n    n = (int)s.size();\n    int r = 0;\n    int b = 0;\n    rep(i,n){\n        if(s[i] == '0'){\n            sum[i] += 2;\n        }\n        else if(s[i] == '1'){\n            sum[i]++;\n            sum2[i]++;\n        }else{\n            sum2[i]+=2;\n        }\n        sum[i+1] += sum[i];\n        sum2[i+1] += sum2[i];\n    }\n//    rep(i,n){\n//        show(sum[i]);\n//    }\n    dp[0][0] = 1;\n    rep(i,2*n){\n        for(int j = 0; j <= i; j++){\n            if(dp[i][j]==0)continue;\n            if(ok1(i,j)){\n                dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j])%mod;\n            }\n            if(ok2(i,i-j)){\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j])%mod;\n            }\n        }\n    }\n//    rep(i,2*n+1){\n//        show(i);\n//        rep(j,i+1){\n//            show(dp[i][j]);\n//        }\n//    }\n    ll ans = 0;\n    rep(i,2*n+1){\n        ans += dp[2*n][i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//#define int long long\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nvoid solve() {\n\tstring s; cin >> s;\n    int n = (int)s.size();\n    mint dp[4040][4040];\n    rep(i, 4040) {\n        rep(j, 4040) {\n            dp[i][j] = 0;\n        }\n    }\n    vector<int> cntr(n + 1, 0), cntb(n + 1, 0);\n    rep(i, n) {\n        if(s[i] == '0') {\n            cntr[i + 1] = cntr[i] + 2;\n            cntb[i + 1] = cntb[i];\n        } else if(s[i] == '1') {\n            cntr[i + 1] = cntr[i] + 1;\n            cntb[i + 1] = cntb[i] + 1;\n        } else {\n            cntr[i + 1] = cntr[i];\n            cntb[i + 1] = cntb[i] + 2;\n        }\n    }\n    dp[0][0] = (mint)1;\n    rep(i, 2 * n) {\n        rep(j, 2 * n + 1) {\n            if(i + 1 >= n || cntr[i + 1] >= j) {\n                if(j > cntr[n]) continue;\n                dp[i + 1][j] += dp[i][j - 1];\n            }\n            if(i + 1 >= n || cntb[i + 1] >= i - j + 1) {\n                if(i - j + 1 > cntb[n]) continue;\n                dp[i + 1][j] += dp[i][j];\n            }\n        }\n    }\n    cout << dp[2 * n][cntr[n]] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 998244353\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \ntemplate<int MAX>\nstruct comcalc{\n    vector<mint> fact,finv,inv;\n    comcalc():fact(MAX),finv(MAX),inv(MAX){\n        fact[0]=mint(1),fact[1]=mint(1),finv[0]=mint(1),finv[1]=mint(1),inv[1]=mint(1);\n        for(int i=2;i<MAX;i++){\n            fact[i]=fact[i-1]*mint(i);\n            inv[i]=mint(0)-inv[mod%i]*(mint(mod/i));\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    mint com(int n,int k){\n        if(n<k) return mint(0);\n        if(n<0 or k<0) return mint(0);\n        return fact[n]*(finv[k]*finv[n-k]);\n    }\n    mint fac(int n){\n        return fact[n];\n    }\n    // 重複組み合わせ:n種類の物から重複を許し，k個選ぶ\n    mint nHk(int n,int k){\n        return com(n+k-1,k);\n    }\n    // 玉n区別，箱k区別，各箱1個以上O(k)\n    mint F12_dis_dis_one(int n,int k){\n        mint ret=1;\n        for(int i=0;i<=k;i++){\n            mint add=com(k,i)*(mint(i).pow(n));\n            if((k-i)%2) ret-=add;\n            else        ret+=add;\n        }\n        return ret;\n    }\n};\nmint pow_mod(mint x,ll n){\n    return x.pow(n);\n}\nmint inv_mod(mint x){\n    return x.inverse();\n}\n// O(n)\nmint fact_mod(ll n){\n    mint ret=1;\n    for(int i=2;i<=n;i++) ret*=mint(i);\n    return ret;\n}\n// O(r)\nmint comb_mod(ll n,ll r){\n    if(r>n-r) r=n-r;\n    if(r==0) return 1;\n    mint a=1,b=mint(fact_mod(r)).inverse();\n    for(int i=0;i<r;i++)a*=mint(n-i);\n    return a*b;\n}\n \nconst int MAX=4010000;\nusing cominit=comcalc<MAX>;\n\nsigned main(){\n    string s;cin>>s;\n    int n=s.size();\n    vector<int>rv(n),bv(n);\n    int rc=0,bc=0;\n    rep(i,n){\n        rv[i]=(s[i]-'0');\n        bv[i]=2-rv[i];\n        rc+=rv[i];\n        bc+=bv[i];\n    }\n\n    int ng[rc+1][bc+1];\n    mint dp[rc+1][bc+1];\n    rep(i,rc+1)rep(j,bc+1)ng[i][j]=false,dp[i][j]=0;\n    dp[0][0]=1;\n\n\n    {\n        int r=0,b=0;\n        for(int i=0;b<bc;i++){\n            b+=bv[i];\n            if(b+r<i+1){\n                ng[r][i+1]=true;\n                r++;\n            }\n        }\n    }\n    {\n        int r=0,b=0;\n        for(int i=0;r<rc;i++){\n            r+=rv[i];\n            if(r+b<i+1){\n                ng[i+1][b]=true;\n                b++;\n            }\n        }\n    }\n\n    rep(i,rc+1){\n        rep(j,bc+1){\n            if(i>0 and !ng[i-1][j]) dp[i][j]+=dp[i-1][j];\n            if(j>0 and !ng[i][j-1]) dp[i][j]+=dp[i][j-1];\n        }\n    }\n\n    // rep(i,rc+1){\n    //     rep(j,bc+1){\n    //         if(ng[i][j]) cout<<\"x \";\n    //         else cout<<dp[i][j]<<\" \";\n    //     }cout<<endl;\n    // }\n\n    cout<<dp[rc][bc]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\nll dp[2000][2010];\nint sum[2000];\nconst int MAX_P=2010;\nll extgcd(ll a, ll b, ll& x, ll&y){\n    ll d=a;\n    if(b!=0){\n        d=extgcd(b, a%b, y, x);\n        y-=(a/b)*x;\n    }\n    else {\n        x=1; y=0;\n    }\n    return d;\n}\n\nll mod_inverse(ll a, ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\n//n!modp\nll fact[MAX_P];\n\n//n!=a p＾eとした時のa modpを求める。O(log_p n)\nll mod_fact(ll n, ll p, ll& e){\n    e=0;\n    if(n==0) return 1;\n    \n    //pの倍数の部分を計算\n    ll res=mod_fact(n/p,p,e);\n    e+=n/p;\n    \n    //(p-1)!≡-1なので(p-1)!^(n/p)はn/pの偶奇だけで計算できる\n    if(n/p%2!=0) return res*(p-fact[n%p])%p;\n    return res*fact[n%p]%p;\n}\n\n//nCk modpを求める。O(log_p n)\nll mod_comb(ll n, ll k, ll p){\n    if(n<0||k<0||n<k) return 0;\n    ll e1, e2, e3;\n    ll a1=mod_fact(n,p,e1), a2=mod_fact(k,p,e2), a3=mod_fact(n-k,p,e3);\n    if(e1>e2+e3) return 0;\n    return a1*mod_inverse(a2*a3%p,p)%p;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string S;\n    cin>>S;\n    int N=S.length();\n    sum[0]=2-(S[0]-'0');\n    rep(i,1,N){\n        sum[i]=sum[i-1]+2-(S[i]-'0');\n    }\n    if(S[0]=='0'){\n        dp[0][0]=0;\n        dp[0][1]=1;\n    }\n    if(S[0]=='1'){\n        dp[0][0]=1;\n        dp[0][1]=1;\n    }\n    if(S[0]=='2'){\n        dp[0][0]=1;\n        dp[0][1]=0;\n    }\n    rep(i,1,N){\n        rep(j,0,i+2){\n            if(j==0){\n                dp[i][j]=(dp[i-1][0]&&sum[i]<=i+1?1:0);\n            }\n            else{\n                dp[i][j]=(sum[i]>j-1?dp[i-1][j-1]:0)+(2*i-sum[i-1]>0||sum[i]-sum[i-1]!=2?dp[i-1][j]:0);\n                dp[i][j]%=MOD;\n            }\n        }\n    }\n    fact[1]=1;\n    rep(i,2,MAX_P){\n        fact[i]=fact[i-1]*i;\n        fact[i]%=MOD;\n    }\n    ll ans=0;\n    rep(i,0,min(sum[N-1]+1, N+1)){\n        ans+=mod_comb(N, sum[N-1]-i, MOD)*dp[N-1][i]%MOD;\n        ans%=MOD;\n    }\n    cout << ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxN=4010;\nconst int Mod=998244353;\n\nchar Input[maxN];\nint n;\nint Sum[maxN][2];\nint F[maxN][maxN];\n\nvoid Plus(int &x,int y);\n\nint main(){\n    scanf(\"%s\",Input+1);n=strlen(Input+1);\n    for (int i=1;i<=n;i++){\n        Sum[i][0]=Sum[i-1][0];Sum[i][1]=Sum[i-1][1];\n        if (Input[i]=='0') Sum[i][0]+=2;\n        if (Input[i]=='1') Sum[i][0]++,Sum[i][1]++;\n        if (Input[i]=='2') Sum[i][1]+=2;\n    }\n    for (int i=n+1;i<=n+n;i++) Sum[i][0]=Sum[i-1][0],Sum[i][1]=Sum[i-1][1];\n    //for (int i=1;i<=n+n;i++) cout<<\"(\"<<Sum[i][0]<<\" \"<<Sum[i][1]<<\") \";cout<<endl;\n    F[0][0]=1;\n    for (int i=0;i<n+n;i++)\n        for (int j=0;j<=min(i,Sum[i][0]);j++){\n            if (Sum[i+1][0]>j) Plus(F[i+1][j+1],F[i][j]);//,cout<<\"(\"<<i<<\" \"<<j<<\")->(\"<<i+1<<\",\"<<j+1<<\")\"<<endl;\n            if (Sum[i+1][1]>i-j) Plus(F[i+1][j],F[i][j]);//,cout<<\"(\"<<i<<\" \"<<j<<\")->(\"<<i+1<<\",\"<<j<<\")\"<<endl;\n        }\n        /*\n    for (int i=1;i<=n+n;i++){\n        for (int j=0;j<=i;j++) cout<<F[i][j]<<\" \";cout<<endl;\n    }\n    //*/\n    int Ans=0;\n    for (int i=0;i<=n+n;i++) Plus(Ans,F[n+n][i]);\n    printf(\"%d\\n\",Ans);return 0;\n}\nvoid Plus(int &x,int y){\n    x+=y;if (x>=Mod) x-=Mod;return;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nusing i8 = ::std::int_least8_t;\nusing i32 = ::std::int_least32_t;\nusing i64 = ::std::int_least64_t;\nusing u8 = ::std::uint_least8_t;\nusing u32 = ::std::uint_least32_t;\nusing u64 = ::std::uint_least64_t;\nusing isize = ::std::ptrdiff_t;\nusing usize = ::std::size_t;\n\ntemplate <class T = usize> class rep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend rep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr rep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(f); }\n\tconstexpr itr end() const noexcept { return itr(l); }\n};\ntemplate <class T = usize> class revrep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend revrep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr revrep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(l - 1); }\n\tconstexpr itr end() const noexcept { return itr(f - 1); }\n};\ntemplate <class T> bool amax(T &a, const T &b) {\n\treturn a <= b ? (a = b, 1) : 0;\n}\ntemplate <class T> bool amin(T &a, const T &b) {\n\treturn b <= a ? (a = b, 1) : 0;\n}\ntemplate <class T> bool asmax(T &a, const T &b) {\n\treturn b <= a ? 0 : (a = b, 1);\n}\ntemplate <class T> bool asmin(T &a, const T &b) {\n\treturn a <= b ? 0 : (a = b, 1);\n}\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class T> auto md_vec(usize n, const T &value) {\n\treturn ::std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(usize n, Args... args) {\n\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> const T &as_const(const T &v) noexcept { return v; }\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n\treturn a <= b ? b - a : a - b;\n}\n#include <cassert>\n#include <cstdint>\n\ntemplate <::std::uint_least32_t Modulus> class modint {\n\tusing u32 = ::std::uint_least32_t;\n\tusing u64 = ::std::uint_least64_t;\n\tusing i64 = ::std::int_fast64_t;\n\tclass optimize_tag_t {};\n\tstatic constexpr optimize_tag_t optimize_tag{};\n\npublic:\n\tusing value_type = u32;\n\tvalue_type a;\n\nprivate:\n\tstatic constexpr value_type cst(i64 x) noexcept {\n\t\tx %= static_cast<i64>(Modulus);\n\t\tif (x < static_cast<i64>(0)) {\n\t\t\tx += static_cast<i64>(Modulus);\n\t\t}\n\t\treturn static_cast<value_type>(x);\n\t}\n\n\tconstexpr modint(optimize_tag_t, const value_type &x) noexcept : a(x) {}\n\npublic:\n\tconstexpr modint() noexcept : a(static_cast<value_type>(0)) {}\n\tconstexpr modint(const i64 &x) noexcept : a(cst(x)) {}\n\tconstexpr value_type value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint &o) const noexcept {\n\t\treturn modint(optimize_tag,\n\t\t\ta + o.a < Modulus ? a + o.a : a + o.a - Modulus);\n\t}\n\tconstexpr modint operator-(const modint &o) const noexcept {\n\t\treturn modint(optimize_tag, a < o.a ? a + Modulus - o.a : a - o.a);\n\t}\n\tconstexpr modint operator*(const modint &o) const noexcept {\n\t\treturn modint(\n\t\t\toptimize_tag,\n\t\t\tstatic_cast<value_type>(static_cast<u64>(a) * static_cast<u64>(o.a) %\n\t\t\t\tstatic_cast<u64>(Modulus)));\n\t}\n\tconstexpr modint operator/(const modint &o) const {\n\t\treturn modint(\n\t\t\toptimize_tag,\n\t\t\tstatic_cast<value_type>(static_cast<u64>(a) * static_cast<u64>((~o).a) %\n\t\t\t\tstatic_cast<u64>(Modulus)));\n\t}\n\tmodint &operator+=(const modint &o) noexcept {\n\t\tif ((a += o.a) >= Modulus)\n\t\t\ta -= Modulus;\n\t\treturn *this;\n\t}\n\tmodint &operator-=(const modint &o) noexcept {\n\t\tif (a < o.a)\n\t\t\ta += Modulus;\n\t\ta -= o.a;\n\t\treturn *this;\n\t}\n\tmodint &operator*=(const modint &o) noexcept {\n\t\ta = static_cast<value_type>(static_cast<u64>(a) * static_cast<u64>(o.a) %\n\t\t\tstatic_cast<u64>(Modulus));\n\t\treturn *this;\n\t}\n\tmodint &operator/=(const modint &o) {\n\t\ta = static_cast<u64>(a) * (~o).a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint inverse() const noexcept {\n\t\tassert(a != static_cast<value_type>(0) && \"0 does not have inverse\");\n\t\treturn pow(static_cast<u64>(Modulus - static_cast<value_type>(2)));\n\t}\n\tconstexpr modint operator~() const noexcept { return inverse(); }\n\tconstexpr modint operator-() const noexcept {\n\t\tif (a == static_cast<value_type>(0)) {\n\t\t\treturn modint(optimize_tag, static_cast<value_type>(0));\n\t\t}\n\t\telse {\n\t\t\treturn modint(optimize_tag, Modulus - a);\n\t\t}\n\t}\n\tmodint &operator++() noexcept {\n\t\tif (++a == Modulus) {\n\t\t\ta = static_cast<value_type>(0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmodint &operator--() noexcept {\n\t\tif (a == static_cast<value_type>(0)) {\n\t\t\ta = Modulus;\n\t\t}\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr bool operator==(const modint &o) const noexcept { return a == o.a; }\n\tconstexpr bool operator!=(const modint &o) const noexcept { return a != o.a; }\n\tconstexpr bool operator<(const modint &o) const noexcept { return a < o.a; }\n\tconstexpr bool operator<=(const modint &o) const noexcept { return a <= o.a; }\n\tconstexpr bool operator>(const modint &o) const noexcept { return a > o.a; }\n\tconstexpr bool operator>=(const modint &o) const noexcept { return a >= o.a; }\n\tconstexpr explicit operator bool() const noexcept { return a; }\n\tconstexpr explicit operator value_type() const noexcept { return a; }\n\tmodint pow(u64 x) const noexcept {\n\t\tu64 t = a, u = 1;\n\t\twhile (x) {\n\t\t\tif (x & 1)\n\t\t\t\tu = u * t % Modulus;\n\t\t\tt = (t * t) % Modulus;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn modint(optimize_tag, static_cast<value_type>(u));\n\t}\n};\n\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include<array>\n#include<string>\n\nint main() {\n\tusing mint = modint<998244353>;\n\t::std::string s;\n\t::std::cin >> s;\n\tconst usize n = s.size();\n\t::std::vector<u32> a(n);\n\tfor (const auto i : rep<>(0, n)) {\n\t\ta[i] = s[i] - '0';\n\t}\n\t::std::array<::std::vector<usize>, 2> pri;\n\tfor (const auto i : rep<>(0, n)) {\n\t\tif (a[i] == 0) {\n\t\t\tpri[0].emplace_back(i);\n\t\t\tpri[0].emplace_back(i);\n\t\t}\n\t\telse if (a[i] == 1) {\n\t\t\tpri[0].emplace_back(i);\n\t\t\tpri[1].emplace_back(i);\n\t\t}\n\t\telse {\n\t\t\tpri[1].emplace_back(i);\n\t\t\tpri[1].emplace_back(i);\n\t\t}\n\t}\n\tconst usize x = pri[0].size(), y = pri[1].size();\n\tauto dp = md_vec(x + 1, y + 1, mint());\n\tdp[0][0] = 1;\n\tfor (const auto i : rep<>(0, x + 1)) {\n\t\tfor (const auto j : rep<>(0, y + 1)) {\n\t\t\tif (i != x&&pri[0][i] <= i + j) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t\tif (j != y&&pri[1][j] <= i + j) {\n\t\t\t\tdp[i][j + 1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t::std::cout << dp[x][y].a << ::std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long MOD = 998244353;\n\nvector<long long> F, RF, R;\n\nvoid init(long long N) {\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tR[i] = MOD - (R[MOD % i] * (MOD / i)) % MOD;\n\t\tRF[i] = (RF[i - 1] * R[i]) % MOD;\n\t}\n\treturn;\n}\n\nlong long Comb(long long A, long long B) {\n\tif (B < 0 || A < B) return 0;\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nint main() {\n\tstring S;\n\tvector<long long> R, B;\n\tcin >> S;\n\tlong long N = S.size();\n\tinit(N);\n\tR.resize(N + 1), B.resize(N + 1);\n\tvector<vector<long long> > DP(N + 1, vector<long long>(N + 1, 0));\n\tDP[0][0] = 1;\n\tR[0] = B[0] = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (S[i] == '0') R[i + 1] = R[i] + 2, B[i + 1] = B[i] + 0;\n\t\tif (S[i] == '1') R[i + 1] = R[i] + 1, B[i + 1] = B[i] + 1;\n\t\tif (S[i] == '2') R[i + 1] = R[i] + 0, B[i + 1] = B[i] + 2;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (j != 0) DP[i][j] = (DP[i][j] + DP[i - 1][j - 1]) % MOD;\n\t\t\tDP[i][j] = (DP[i][j] + DP[i - 1][j]) % MOD;\n\t\t}\n\t\tfor (int j = 0; j < i - B[i]; j++) DP[i][j] = 0;\n\t\tfor (int j = R[i] + 1; j <= N; j++) DP[i][j] = 0;\n\t}\n\tlong long ANS = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS += DP[N][i] * Comb(N, R[N] - i);\n\t\tANS %= MOD;\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 998244353\n#define mod(mod_x) ((((long long)mod_x)+modulo)%modulo)\n#define Inf 1000000000000\n\nint main() {\n\t\n\tstring S;\n\tcin>>S;\n\t\n\tvector<vector<int>> dp(S.size()*2+1,vector<int>(S.size()*2+1,0));\n\t\n\tdp[0][0] = 1;\n\t\n\tint R = 0;\n\tint B = 0;\n\t\n\tfor(int i=0;i<2*S.size();i++){\n\t\tif(i<S.size()){\n\t\t\tB += S[i]-'0';\n\t\t\tR += 2-(S[i]-'0');\n\t\t}\n\t\tfor(int j=0;j<=2*S.size();j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\tif(j+1<=R){\n\t\t\t\tdp[i+1][j+1] = mod(dp[i+1][j+1] + dp[i][j]);\n\t\t\t}\n\t\t\tif((i+1)-j <= B){\n\t\t\t\tdp[i+1][j] = mod(dp[i+1][j] + dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i=0;i<S.size()*2+1;i++)ans = mod(ans + dp.back()[i]);\n\t\n\tcout<<ans<<endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll kaijo(ll a);\n\nint main(){\nstring S;\nll N=S.size();\nll num1=0,num2=0;\nfor(ll i=0;i<N;i++){\n  if(S[i]=='1'){\n    num1++;\n  }\n  else if(S[i]=='2'){\n    num2++;\n  }\n}\nll num0=N-num1-num2;\nll ans=0;\nll tmp;\nif(num0>num2){\n  tmp = num2;\n}\nelse{\n  tmp = num0;\n}\nnum0 -=tmp;\nnum2 -=tmp;\nnum1 +=2*tmp;\n\nfor(ll i=0;num1<2;i++){\nans += kaijo(N)/(kaijo(num0)*kaijo(num1)*kaijo(num2))\n\n}\nprintf(\"%lld\\n\",ans);\n}\n\nll kaijo(ll a){\n\nif(a==0)\nreturn 1;\n  int sum = 1;\n   for (int i = 1; i <= a; ++i)\n   {\n       sum *= i;\n   }\n   return sum;\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\ni64 cnt[2020][2020];\n\ntemplate <class T>\nT pow(T x, T n, T mod) {\n    T ret = 1;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <class T>\nT inverse(T x, T p) { return pow(x, p - 2, p); }\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    int n = s.size();\n    constexpr i64 mod = 998244353;\n\n    std::vector<i64> fact(n + 1), inv(n + 1);\n    fact[0] = 1;\n    for (i64 i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    inv[n] = inverse(fact[n], mod);\n    for (i64 i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n\n    if (s[0] == '0') {\n        cnt[1][1] = 1;\n    } else if (s[0] == '1') {\n        cnt[1][0] = cnt[1][1] = 1;\n    } else {\n        cnt[1][0] = 1;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j <= i - 1; j++) {\n            if (s[i - 1] == '0') {\n                cnt[i][j + 1] = (cnt[i][j + 1] + cnt[i - 1][j]) % mod;\n                cnt[i][j + 2] = (cnt[i][j + 2] + cnt[i - 1][j]) % mod;\n            } else if (s[i - 1] == '1') {\n                cnt[i][j] = (cnt[i][j] + cnt[i - 1][j]) % mod;\n                cnt[i][j + 1] = (cnt[i][j + 1] + cnt[i - 1][j]) % mod;\n            } else {\n                if (j) cnt[i][j - 1] = (cnt[i][j - 1] + cnt[i - 1][j]) % mod;\n                cnt[i][j] = (cnt[i][j] + cnt[i - 1][j]) % mod;\n            }\n        }\n    }\n\n    i64 ret = 0;\n    for (int i = 0; i <= n; i++) {\n        ret = (ret + cnt[n][i] * fact[n] % mod * inv[i] % mod * inv[n - i] % mod) % mod;\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nll mo=998244353;\nll dp[4020][4020];\nint NR[2020],NB[2020];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S;\n\tN=S.size();\n\tFOR(i,N) {\n\t\tNR[i+1]=NR[i]+('2'-S[i]);\n\t\tNB[i+1]=NB[i]+(S[i]-'0');\n\t}\n\tdp[0][0]=1;\n\tfor(int r=0;r<=NR[N];r++) {\n\t\tfor(int b=0;b<=NB[N];b++) if(dp[r][b]) {\n\t\t\tint nr=NR[min(N,r+b+1)];\n\t\t\tint nb=NB[min(N,r+b+1)];\n\t\t\t\n\t\t\tif(nr>r) (dp[r+1][b]+=dp[r][b])%=mo;\n\t\t\tif(nb>b) (dp[r][b+1]+=dp[r][b])%=mo;\n\t\t}\n\t}\n\t\n\tcout<<dp[NR[N]][NB[N]]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N=2e3+10;\nconst int mod=998244353;\nint n,dp[N<<1][N<<1],s1[N],s2[N];\nchar s[N];\ninline void Add(int &x,int y){x+=y;x-=x>=mod? mod:0;}\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(register int i=1;i<=n;i++)s2[i]=s[i]-'0';\n\tfor(register int i=1;i<=n;i++)s1[i]=2-s2[i];\n\tfor(register int i=1;i<=n;i++)s1[i]+=s1[i-1],s2[i]+=s2[i-1];\n\tdp[0][0]=1;\n\tfor(register int i=1;i<=(n<<1);i++)\n\t\tfor(register int j=0;j<=s2[n];j++)\n\t\t\tif(i-j<=s1[min(i,n)]&&j<=s2[min(i,n)])\n\t\t\t\tAdd(dp[i][j],dp[i-1][j-1]),Add(dp[i][j],dp[i-1][j]);\n\tprintf(\"%d\\n\",dp[n<<1][s2[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define ldb long double\n#define mt meke_tuple\ntemplate<typename T> bool ckmn(T &a, T b){ T c=a;a=min(a,b);return a!=c;}\ntemplate<typename T> bool ckmx(T &a, T b){ T c=a;a=max(a,b);return a!=c;}\n\nconst int mod=998244353;\nint add(int a, int b){ a+=b;return a>=mod?a-mod:a;}\nvoid ckadd(int &a, int b){ a=add(a,b);}\nint sub(int a, int b){ a-=b;return a<0?a+mod:a;}\nvoid cksub(int &a, int b){ a=sub(a,b);}\nint mul(int a, int b){ return (ll)a*b%mod;}\nvoid ckmul(int &a, int b){ a=mul(a,b);}\nint powmod(int x, int k){ int ans=1;for(;k;k>>=1,ckmul(x,x)) if(k&1) ckmul(ans,x);return ans;}\nint inv(int x){ return powmod(x,mod-2);}\n\nconst int N=4050;\nint F[N],I[N];\nint binom(int n, int k){ return mul(F[n],mul(I[k],I[n-k]));}\nvoid calc()\n{\n\tF[0]=1;\n\tfor(int i=1;i<N;i++) F[i]=mul(F[i-1],i);\n\tI[N-1]=inv(F[N-1]);\n\tfor(int i=N-2;~i;i--) I[i]=mul(I[i+1],i+1);\n}\n\nint dp[N][N],r[N],b[N];\nint main()\n{\n\tcalc();\n\tdp[0][0]=1;\n\tstring s;\n\tcin>>s;\n\tint n=s.size(),i,j;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tr[i+1]=r[i]+(2-(s[i]-'0'));\n\t\tb[i+1]=b[i]+(s[i]-'0');\n\t}\n\tfor(i=n+1;i<=n*2;i++) r[i]=r[i-1],b[i]=b[i-1];\n\tfor(i=0;i<n*2;i++) for(j=0;j<=i;j++)\n\t{\n\t\tint B=j,R=i-j;\n\t\tif(r[i+1]>R)\n\t\t{\n\t\t\tdp[i+1][j]=add(dp[i+1][j],dp[i][j]);\n\t\t}\n\t\tif(b[i+1]>B)\n\t\t{\n\t\t\tdp[i+1][j+1]=add(dp[i+1][j+1],dp[i][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(i=0;i<=2*n;i++) ans=add(ans,dp[n*2][i]);\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tif(N == 1){\n\t\tif(S[0] == S[1]){\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse cout << 2 << endl;\n\t\treturn 0;\n\t}\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(j,1,N){\n\t\t\tif(s[j] == 2){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t\tif(s[j] == 1 && j*N+1 == i){\n\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\nconst int mod = 998244353;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return w*s;}\nint f[4020][4020];\nint n;\nchar s[100010];\ninline int add(int a,int b){a+=b;if(a>=mod) a-=mod;return a;}\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tint Sum1=0,Sum2=0;\n\tf[0][0]=1;\n\tfor(rint i=0;i<2*n;++i)\n\t{\t\n\t\tif(i+1<=n)\n\t\t{\n\t\t\tif(s[i+1]=='0') Sum1+=2;\n\t\t\tif(s[i+1]=='1') Sum1+=1,Sum2+=1;\n\t\t\tif(s[i+1]=='2') Sum2+=2;\n\t\t}\n\t\tfor(rint j=0;j<=2*n;++j)\n\t\t{\n\t\t\tif(!f[i][j]) continue;\n\t\t\tif(Sum1-j>0)\n\t\t\t{\n\t\t\t\tf[i+1][j+1]=add(f[i+1][j+1],f[i][j]); \n\t\t\t}\n\t\t\tif((Sum2-(i-j))>0)\n\t\t\t{\n\t\t\t\tf[i+1][j]=add(f[i+1][j],f[i][j]);\n\t\t\t}\n\t\t}\n\t}//int ans=0;\n\t//for(rint i=0;i<=n;++i) ans=add(ans,f[2*n][i]);\n\tcout<<f[2*n][Sum1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\n#define next asdnext\n#define prev asdprev\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T1, typename T2> bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ >= 0 ? val_ % MOD : (MOD - (-val_) % MOD) % MOD) {}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return mod_int(-val); }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        int a = MOD, b = val, u = 0, v = 1;\n        while (b > 0) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * v, v);\n        }\n        return mod_int(u);\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nstring S;\nint N;\nusing mint=mod_int<998244353>;\nmint dp[2200][2200];\nsigned main() {\n    cin >> S;\n    N = S.length();\n    vint rlim(2 * N), blim(2 * N);\n    rep(i, N) {\n        if (S[i] == '0') { rlim[i + 1] = rlim[i] + 2, blim[i + 1] = blim[i]; }\n        if (S[i] == '1') { rlim[i + 1] = rlim[i] + 1, blim[i + 1] = blim[i] + 1; }\n        if (S[i] == '2') { rlim[i + 1] = rlim[i], blim[i + 1] = blim[i] + 2; }\n    }\n    rep(i, N) { rlim[i + N + 1] = rlim[i + N], blim[i + N + 1] = blim[i + N]; }\n    dp[0][0] = 1;\n    reps(i, 2 * N) {\n        for (int j = 0; j <= 2 * N; j++) {\n            if (j > rlim[i] || i - j > blim[i]) { continue; }\n            dp[i][j] = dp[i - 1][j];\n            if (j != 0) { dp[i][j] += dp[i - 1][j - 1]; }\n        }\n    }\n    cout << dp[2 * N][rlim[2 * N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=998244353,N=4e3+5;\nint i,j,k,n,f[N][N],a[N],b[N];\nchar c[N];\nint main(){\n\tscanf(\"%s\",c+1);n=strlen(c+1);\n\tfor(i=1;i<=n;++i)a[i]=a[i-1]+c[i]-'0',b[i]=b[i-1]+'2'-c[i];f[0][0]=1;\n\tfor(i=0;i<=a[n];++i)\n\t\tfor(j=!i;j<=b[n];++j){\n\t\t\tk=std::min(n,i+j);\n\t\t\tif(i<=a[k] && j<=b[k])f[i][j]=((i?f[i-1][j]:0)+(j?f[i][j-1]:0))%mo;\n\t\t}\n\tprintf(\"%d\\n\",f[a[n]][b[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int NS = (int)2e3 + 5, mod = 998244353;\nint dp[NS << 1][NS << 1];\nvector<int> redBall, blueBall;\nstring s;\n\nint add(int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> s;\n    for (int i = 0; i < (int)s.size(); ++i) {\n        if (s[i] == '0') redBall.push_back(i + 1), redBall.push_back(i + 1);\n        else if (s[i] == '1') redBall.push_back(i + 1), blueBall.push_back(i + 1);\n        else blueBall.push_back(i + 1), blueBall.push_back(i + 1);\n    }\n\n    dp[0][0] = 1;\n    for (int rPlusB = 0; rPlusB < 2 * (int)s.size(); ++rPlusB) {\n        for (int r = 0; r <= min(rPlusB, (int)redBall.size() ); ++r) {\n            int b = rPlusB - r;\n            if (!dp[r][b]) continue ;\n            if (r != (int)redBall.size() && redBall[r] <= r + b + 1) {\n                dp[r + 1][b] = add(dp[r + 1][b], dp[r][b]);\n            }\n            if (b != (int)blueBall.size() && blueBall[b] <= r + b + 1) {\n                dp[r][b + 1] = add(dp[r][b + 1], dp[r][b]);\n            }\n        }\n    }\n\n    cout << dp[redBall.size()][blueBall.size()];\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n \n \nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 4002\nchar buf[MAX];\nstring s;\nvector<int> posw;\nvector<int> posb;\nint dp[MAX][MAX];\nint main(){\n\tscanf(\"%s\",buf);\n\ts=buf;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='0'){\n\t\t\tposw.push_back(i);\n\t\t\tposw.push_back(i);\n\t\t}\n\t\tif(s[i]=='1'){\n\t\t\tposw.push_back(i);\n\t\t\tposb.push_back(i);\n\t\t}\n\t\tif(s[i]=='2'){\n\t\t\tposb.push_back(i);\n\t\t\tposb.push_back(i);\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tint n=s.size();\n\tfor(int i=0;i<n*2;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\tint white=j;\n\t\t\tint black=i-j;\n\t\t\tif(white<posw.size()&&posw[white]<=i){\n\t\t\t\taddto(dp[i+1][j+1],dp[i][j]);\n\t\t\t}\n\t\t\tif(black<posb.size()&&posb[black]<=i){\n\t\t\t\taddto(dp[i+1][j],dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint ret=dp[n*2][posw.size()];\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate < typename T >\nvoid vprint(T &v){\n\tREP(i, v.size()){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tvector<ll> red(N+1, 0), blue(N+1, 0);\n\tREP(i, N){\n\t\tif(S[i]=='0'){\n\t\t\tred[i+1] = red[i] + 2;\n\t\t\tblue[i+1] = blue[i];\n\t\t}else if(S[i]=='1'){\n\t\t\tred[i+1] = red[i] + 1;\n\t\t\tblue[i+1] = blue[i] + 1;\n\t\t}else{\n\t\t\tred[i+1] = red[i];\n\t\t\tblue[i+1] = blue[i] + 2;\n\t\t}\n\t}\n\tll ma = 200;\n\tll dp[ma][ma];\n\tREP(i, ma)REP(j, ma) dp[i][j] = 0;\n\tdp[0][0] = 1;\n\tREP(i, 2*N){\n\t\tll ikeru = min((ll)i, N-1);\n\t\tll ikered = red[ikeru+1];\n\t\tll ikeblue = blue[ikeru+1];\n\t\tREP(j, 2*N){\n\t\t\tif(ikered>j){\n\t\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t\t\tdp[i+1][j+1] %= mod;\n\t\t\t}\n\t\t\tif(ikeblue>i-j){\n\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\tdp[i+1][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2*N][red[N]] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define mod (int)(1e9+7)\n#define inf (int)(3e18)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define P std::pair<int,int>\n#define PiP std::pair<int,std::pair<int,int>>\n#define all(v) v.begin(),v.end()\n#define mkp std::make_pair\n#define prique(T) std::priority_queue<T,vector<T>,greater<T>>\nusing namespace std;\ntemplate<class T> inline void chmax(T &a, T b) {\n\ta = std::max(a, b);\n}\ntemplate<class T> inline void chmin(T &a, T b) {\n\ta = std::min(a, b);\n}\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0)\n\t\t\treturn false;\n\t}\n\treturn x != 1;\n}\nint gcd(int x, int y) {\n\tif (y == 0)\n\t\treturn x;\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\nint kai(int x, int y) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i;\n\t\tres %= mod;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m = mod) {\n\tint res = 1;\n\tx %= m;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint comb(int x, int y) {\n\tif (y > x)\n\t\treturn 0;\n\treturn kai(x, y) * mod_pow(kai(y, y), mod - 2, mod) % mod ;\n}\nint get_rand(int MIN, int MAX) {\n\tstd::random_device rnd;\n\tstd::mt19937 mt32(rnd());\n\tstd::uniform_int_distribution<int> engine(MIN, MAX);\n\treturn engine(mt32);\n}\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\tBIT(int x) {\n\t\tbit.resize(x + 1, 0);\n\t\tn = x;\n\t}\n\tvoid add(int x, int y) {\n\t\twhile (x <= n) {\n\t\t\tbit[x] += y;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint sum(int x) {\n\t\tint res = 0;\n\t\twhile (x > 0) {\n\t\t\tres += bit[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> par, size;\n\tUnionFind(int x) {\n\t\tpar.resize(x);\n\t\tsize.resize(x, 1);\n\t\trep(i,x)\n\t\t\tpar[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint consize(int x) {\n\t\treturn size[find(x)];\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn;\n\t\tif (size[x] < size[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsize[y] += size[x];\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tsize[x] += size[y];\n\t\t}\n\t}\n};\n\nstruct Tree {\n\tint size;\n\tvector<int> par, depth;\n\tvector<int> doubling[30];\n\tvector<vector<int>> G;\n\tint root = 0;\n\tTree(int x) {\n\t\tpar.resize(x);\n\t\tdepth.resize(x);\n\t\trep(i,30)\n\t\t{\n\t\t\tdoubling[i].resize(x, -1);\n\t\t}\n\t\tG.resize(x);\n\t\tsize = x;\n\t}\n\tvoid add_edge(int x, int y) {\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tvoid dfs(int x) {\n\t\tfor (int i : G[x]) {\n\t\t\tif (depth[i] == -1) {\n\t\t\t\tdepth[i] = depth[x] + 1;\n\t\t\t\tdoubling[0][i] = x;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t}\n\tvoid init() {\n\t\trep(i,size)\n\t\t\tdepth[i] = -1;\n\t\tdepth[root] = 0;\n\t\tdfs(root);\n\t\trep(i,29)\n\t\t{\n\t\t\trep(j,size)\n\t\t\t{\n\t\t\t\tif (doubling[i][j] == -1)\n\t\t\t\t\tdoubling[i + 1][j] = -1;\n\t\t\t\telse\n\t\t\t\t\tdoubling[i + 1][j] = doubling[i][doubling[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int x, int y) {\n\t\tif (depth[x] > depth[y])\n\t\t\tswap(x, y);\n\t\tfor (int i = 29; i >= 0; i--) {\n\t\t\tif ((depth[y] - depth[x]) >> i & 1) {\n\t\t\t\ty = doubling[i][y];\n\t\t\t}\n\t\t}\n\t\tif (x == y)\n\t\t\treturn x;\n\t\tfor (int i = 29; i >= 0; i--) {\n\t\t\tif (doubling[i][x] != doubling[i][y]) {\n\t\t\t\tx = doubling[i][x];\n\t\t\t\ty = doubling[i][y];\n\t\t\t}\n\t\t}\n\t\treturn doubling[0][x];\n\t}\n};\n\nstruct RollingHash {\n\tint Base = 283;\n\tconst int MASK30 = (1ll << 30) - 1;\n\tconst int MASK31 = (1ll << 31) - 1;\n\tconst int MOD = (1ll << 61) - 1;\n\tvector<int> hash, power;\n\tint calcmod(int val) {\n\t\tval = (val & MOD) + (val >> 61);\n\t\tif (val > MOD)\n\t\t\tval -= MOD;\n\t\treturn val;\n\t}\n\tint mul(int x, int y) {\n\t\tint xu = x >> 31;\n\t\tint xd = x & MASK31;\n\t\tint yu = y >> 31;\n\t\tint yd = y & MASK31;\n\t\tint mid = xd * yu + xu * yd;\n\t\tint midu = mid >> 30;\n\t\tint midd = mid & MASK30;\n\t\treturn calcmod(xu * yu * 2 + midu + (midd << 31) + xd * yd);\n\t}\n\tRollingHash(string s) {\n\t\t//Base=get_rand(1<<7,1<<8);\n\t\tint sz = s.size();\n\t\thash.resize(sz + 1, 0);\n\t\tpower.resize(sz + 1, 1);\n\t\trep(i,sz)\n\t\t{\n\t\t\thash[i + 1] = (mul(hash[i], Base) + s[i]) % MOD;\n\t\t\tpower[i + 1] = mul(power[i], Base) % MOD;\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tint res = (hash[r] - mul(hash[l], power[r - l]) + MOD) % MOD;\n\t\treturn res;\n\t}\n\tint lcp(int x, int y) {\n\t\tint len = min(hash.size() - y, hash.size() - x);\n\t\tint ok = 0, ng = len + 1;\n\t\twhile (ng - ok > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (get(x, x + mid) == get(y, y + mid))\n\t\t\t\tok = mid;\n\t\t\telse\n\t\t\t\tng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n};\nstruct Segtree {\n\tint size = 1;\n\tvector<int> dat, lazy;\n\tSegtree(int x) {\n\t\twhile (size < x)\n\t\t\tsize *= 2;\n\t\tdat.resize(size * 2 - 1, inf);\n\t\tlazy.resize(size * 2 - 1, inf);\n\t}\n\tvoid eval(int k, int l, int r) {\n\t\tchmin(dat[k], lazy[k]);\n\t\tif (r - l > 1) {\n\t\t\tchmin(lazy[k * 2 + 1], lazy[k]);\n\t\t\tchmin(lazy[k * 2 + 2], lazy[k]);\n\t\t}\n\t\tlazy[k] = inf;\n\t}\n\tvoid update(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)\n\t\t\tr = size;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)\n\t\t\treturn;\n\t\tif (a <= l && r <= b) {\n\t\t\tchmin(lazy[k], x);\n\t\t\teval(k, l, r);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n\tint query(int a, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)\n\t\t\tr = size;\n\t\teval(k, l, r);\n\t\tif (r - l == 1) {\n\t\t\treturn dat[k];\n\t\t}\n\t\tif (a < (l + r) / 2) {\n\t\t\treturn query(a, k * 2 + 1, l, (l + r) / 2);\n\t\t}\n\t\treturn query(a, k * 2 + 2, (l + r) / 2, r);\n\t}\n};\n\ntemplate<class T> vector<int> KMP(vector<T> target, vector<T> pattern) {\n\tvector<int> table(pattern.size() + 1);\n\ttable[0] = 0;\n\tint j = 0;\n\tREP(i,(int)pattern.size())\n\t{\n\t\tif (pattern[i] == pattern[j]) {\n\t\t\ttable[i] = j++;\n\t\t} else {\n\t\t\ttable[i] = j;\n\t\t\tj = 0;\n\t\t}\n\t}\n\ttable[pattern.size()] = j;\n\tj = 0;\n\tvector<int> res;\n\tint i = 0;\n\twhile (i < target.size()) {\n\t\tif (j < pattern.size() && target[i] == pattern[j]) {\n\t\t\ti++;\n\t\t\tj++;\n\t\t} else {\n\t\t\tif (!j)\n\t\t\t\ti++;\n\t\t\tj = table[j];\n\t\t}\n\t\tif (j == pattern.size())\n\t\t\tres.push_back(i - j);\n\t}\n\treturn res;\n}\n\nint perm[1000005];\nvoid init_perm(){\n\tperm[0]=1;\n\tREP(i,1000005)perm[i]=perm[i-1]*i%mod;\n}\nint nCk(int x,int y){\n\treturn perm[x]*mod_pow(perm[x-y],mod-2)%mod*mod_pow(perm[y],mod-2)%mod;\n}\n/*--------Library Zone!--------*/\n\n\nstring s;\nint dp[4005][4005],sum[2005],sum2[2005];\nconst int MOD=998244353;\nsigned main(){\n\tcin>>s;\n\trep(i,s.size()){\n\t\tsum[i+1]=sum[i]+('2'-s[i]);\n\t\tsum2[i+1]=sum2[i]+(s[i]-'0');\n\t}\n\tdp[0][0]=1;\n\trep(i,s.size()*2)rep(j,i+1){\n\t\tdp[i][j]%=MOD;\n\t\tif(dp[i][j]==0)continue;\n\t\tif(sum[min((int)s.size(),i+1)]>=j+1){\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t}\n\t\tif(sum2[min((int)s.size(),i+1)]>=i-j+1){\n\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t}\n\t}\n\tint res=0;\n\trep(i,s.size()*2){\n\t\tres+=dp[s.size()*2][i];\n\t\tres%=MOD;\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//#define int long long\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nvoid solve() {\n\tstring s; cin >> s;\n    int n = (int)s.size();\n    mint dp[4040][4040];\n    rep(i, 4040) {\n        rep(j, 4040) {\n            dp[i][j] = 0;\n        }\n    }\n    vector<int> cntr(n + 1, 0), cntb(n + 1, 0);\n    rep(i, n) {\n        if(s[i] == '0') {\n            cntr[i + 1] = cntr[i] + 2;\n            cntb[i + 1] = cntb[i];\n        } else if(s[i] == '1') {\n            cntr[i + 1] = cntr[i] + 1;\n            cntb[i + 1] = cntb[i] + 1;\n        } else {\n            cntr[i + 1] = cntr[i];\n            cntb[i + 1] = cntb[i] + 2;\n        }\n    }\n    dp[0][0] = (mint)1;\n    rep(i, 2 * n) {\n        rep(j, 2 * n) {\n            if(i + 1 >= n || cntr[i + 1] >= j) {\n                if(j > cntr[n]) continue;\n                dp[i + 1][j] += dp[i][j - 1];\n            }\n            if(i + 1 >= n || cntb[i + 1] >= i - j + 1) {\n                if(i - j + 1 > cntb[n]) continue;\n                dp[i + 1][j] += dp[i][j];\n            }\n        }\n    }\n    cout << dp[2 * n][cntr[n]] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define POWER9 1000000000\n#define MOD POWER9+7\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n/*\nint N,M;\nint a[300][300];\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(9);\n\n\tcin >> N >> M;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<M; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\treturn 0;\n}*/\n\n#define MOD 998244353\nstring S;\nint wa[2][2001];\nint ready[4000][4000];\n\nLL dp[4000][4000];\nLL solve(int now, int red){\n\tif(now == S.size()*2) return 1;\n\tif(dp[now][red] != -1) return dp[now][red];\n\tint tmp = ready[red][now-red];\n\tint choiceR = wa[0][tmp] - red;\n\tint choiceB = wa[1][tmp] - (now-red);\n\tLL re = 0;\n\tif(choiceR > 0) re += (LL)solve(now+1, red+1);\n\tif(choiceB > 0) re += (LL)solve(now+1, red);\n\tcout << now << \" \" << red << \" \" << re << endl;\n\treturn dp[now][red] = re % MOD;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(9);\n\n\tcin >> S;\n\tfor(int i=0; i<S.size(); i++){\n\t\tif(S[i] == '0'){\n\t\t\twa[0][i] = 2 + (i!=0?wa[0][i-1]:0);\n\t\t\twa[1][i] = (i!=0?wa[1][i-1]:0);\n\t\t}\n\t\tif(S[i] == '1'){\n\t\t\twa[0][i] = 1 + (i!=0?wa[0][i-1]:0);\n\t\t\twa[1][i] = 1 + (i!=0?wa[1][i-1]:0);\n\t\t}\n\t\tif(S[i] == '2'){\n\t\t\twa[0][i] = (i!=0?wa[0][i-1]:0);\n\t\t\twa[1][i] = 2 + (i!=0?wa[1][i-1]:0);\n\t\t}\n\t\t//cout << wa[0][i] << \" \" << wa[1][i] << endl;\n\t}\n\twa[0][S.size()] = wa[0][S.size()-1];\n\twa[1][S.size()] = wa[1][S.size()-1];\n\tready[0][0] = 0;\n\tfor(int i=0; i<S.size()*2; i++){\n\t\tfor(int j=0; j<S.size()*2; j++){\n\t\t\tif(i == 0 && j == 0) continue;\n\t\t\tready[i][j] = 0;\n\t\t\tif(i != 0){\n\t\t\t\tint tmp = ready[i-1][j];\n\t\t\t\tif(tmp == S.size()) ready[i][j] = max(ready[i][j], ready[i-1][j]);\n\t\t\t\telse if(S[tmp] != '2') ready[i][j] = max(ready[i][j], ready[i-1][j]+1);\n\t\t\t\telse ready[i][j] = max(ready[i][j], ready[i-1][j]);\n\t\t\t}\n\t\t\tif(j != 0){\n\t\t\t\tint tmp = ready[i][j-1];\n\t\t\t\tif(tmp == S.size()) ready[i][j] = max(ready[i][j], ready[i][j-1]);\n\t\t\t\telse if(S[tmp] != '0') ready[i][j] = max(ready[i][j], ready[i][j-1]+1);\n\t\t\t\telse ready[i][j] = max(ready[i][j], ready[i][j-1]);\n\t\t\t}\n\t\t\t//cout << ready[i][j] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\tfor(int i=0; i<S.size()*2; i++){\n\t\tfor(int j=0; j<S.size()*2; j++){\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tcout << solve(0,0)%MOD << endl;\n\n\treturn 0;\n}\n\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << setprecision(9);\n\n\n\nreturn 0;\n}\n*/\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << std::setprecision(9);\n\n\n\nreturn 0;\n}\n*/\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << std::setprecision(9);\n\n\n\nreturn 0;\n}\n*/\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << std::setprecision(9);\n\n\n\nreturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rg register\nusing namespace std;\nconst int MAXN=2010;\nconst int Mod=998244353;\nchar Str[MAXN];\nint n,Ans,Seq[MAXN],Pre[MAXN],Dp[MAXN][MAXN],C[MAXN][MAXN];\ninline void Add(rg int &A,rg int B){   A+=B,A-=A>=Mod?Mod:0;   }\nint main()\n{   scanf(\"%s\",Str+1),n=strlen(Str+1);\n\tfor(rg int i=0;i<=n;i++) C[i][0]=1;\n\tfor(rg int i=1;i<=n;i++) Seq[i]=Str[i]-'0',Pre[i]=Pre[i-1]+Seq[i];\n\tfor(rg int i=1;i<=n;i++)\n\t\tfor(rg int j=1;j<=i;j++) C[i][j]=C[i-1][j],Add(C[i][j],C[i-1][j-1]);\n\tDp[0][0]=1;\n\tfor(rg int i=1;i<=n;i++)\n\t\tfor(rg int j=0;j<=i;j++)\n\t\t{   if(Pre[i-1]+(Seq[i]!=0)>=j) Add(Dp[i][j],Dp[i-1][j-1]);\n\t\t\tif(2*i-2-Pre[i-1]+(Seq[i]<=1)>=i-j) Add(Dp[i][j],Dp[i-1][j]);\n\t\t}\n\tfor(rg int i=0;i<=n;i++) Add(Ans,1ll*Dp[n][i]*C[n][Pre[n]-i]%Mod);\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define REP(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, a, b) for(int i=(a); i<(b); ++i)\n#define FORR(i, a, b) for(int i=(b)-1; i>=(a); --i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<'\\n'\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i, v.size())cout<<' '<<v[i];cout<<'\\n'\n#define ALL(a) (a).begin(), (a).end()\n\n#define CHMIN(a, b) a=min((a), (b))\n#define CHMAX(a, b) a=max((a), (b))\n\n// const ll MOD=1000000007ll;\n const ll MOD=998244353ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nconst double EPS=1e-11;\n#define EQ0(x) (abs((x))<EPS)\n#define EQ(a, b) (abs((a)-(b))<EPS)\n\nll dp[4334][4334];\nint blew[2525];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tREP(i, n){\n\t\tblew[i+1]=blew[i]+(s[i]-'0');\n\t}\n\tdp[0][0]=1;\n\tREP(i, n<<1){\n\t\tint bnum=blew[min(i+1, n)];\n\t\tint rnum=min(i+1, n)*2-bnum;\n\t\tFOR(j, max(1, i+1-rnum), min(bnum, i+1)+1){\n\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j-1])%MOD;\n\t\t}\n\t\tFOR(j, max(1, i+1-bnum), min(rnum, i+1)+1){\n\t\t\tdp[i+1][i+1-j]=(dp[i+1][i+1-j]+dp[i][i+1-j])%MOD;\n\t\t}\n\t}\n\tcout<<dp[n<<1][blew[n]]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(j,1,N){\n\t\t\tif(s[j] == 2){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t\tif(s[j] == 1 && j == 2*N-i){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tif(min[0])DP[0][0] = 0;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ninline void setmin(int &x, int y) { if (y < x) x = y; }\ninline void setmax(int &x, int y) { if (y > x) x = y; }\ninline void setmin(ll &x, ll y) { if (y < x) x = y; }\ninline void setmax(ll &x, ll y) { if (y > x) x = y; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 52;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD2) {\n        x -= MOD2;\n    }\n}\n\nint dp[2 * 2000 + 1][2 * 2000 + 1];\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    string s;\n    cin >> s;\n    int n = sz(s);\n    int prefR[n];\n    rep(i, 0, n) {\n        if (s[i] == '0') {\n            prefR[i] = 2;\n        } else if (s[i] == '1') {\n            prefR[i] = 1;\n        } else {\n            prefR[i] = 0;\n        }\n        if (i > 0) {\n            prefR[i] += prefR[i - 1];\n        }\n    }\n    dp[0][0] = 1;\n    rep(i, 0, n * 2) {\n        rep(cr, 0, n * 2 + 1) {\n            if (dp[i][cr] == 0) {\n                continue;\n            }\n            int cb = i - cr;\n            int tr = prefR[min(n - 1, i)], tb = min(n, i + 1) * 2 - tr;\n            if (cr < tr) {\n                add(dp[i + 1][cr + 1], dp[i][cr]);\n            }\n            if (cb < tb) {\n                add(dp[i + 1][cr], dp[i][cr]);\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, 0, n * 2 + 1) {\n        add(ans, dp[n * 2][i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint dp[4001][4001];\nint MOD = 998244353;\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s;\n    cin >> s;\n    int n = s.size();\n    for (int i=0; i <= 2*n; i++) for (int j=0; j <= 2*n;j++) dp[i][j] = 0;\n    dp[0][0] = 1;\n    for (int i=0; i < 2*n; i++){\n        for (int j=0; j <= 2*n; j++){\n            if (dp[i][j] == 0) continue;\n            int blue = min(2*i, 2*n) - j, red=j;\n            if (i < n){\n                blue += s[i] - '0';\n                red += 2 - (s[i]-'0');\n            }\n            if (blue > 0){\n                dp[i+1][red] += dp[i][j];\n                dp[i+1][red]%= MOD;\n            }\n            if (red>0){\n                dp[i+1][red-1] += dp[i][j];\n                dp[i+1][red-1] %= MOD;\n            }\n        }\n    }\n    cout << dp[2*n][0];\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef int LL;\ntypedef double dl;\n#define opt operator\n#define pb push_back\nconst LL maxn=4e3+9,mod=998244353,inf=0x3f3f3f3f;\nLL Read(){\n\tLL x(0),f(1); char c=getchar();\n\twhile(c<'0' || c>'9'){\n\t\tif(c=='-') f=-1; c=getchar();\n\t}\n\twhile(c>='0' && c<='9'){\n\t\tx=(x<<3ll)+(x<<1ll)+c-'0'; c=getchar();\n\t}return x*f;\n}\nvoid Chkmin(LL &x,LL y){\n\tif(y<x) x=y;\n}\nvoid Chkmax(LL &x,LL y){\n\tif(y>x) x=y;\n}\nvoid add(LL &x,LL y){\n\tx+=y; x=(x>=mod?x-mod:x);\n}\nvoid dec(LL x,LL y){\n\tx-=y; x=(x<0?x+mod:x);\n}\nLL mul(LL x,LL y){\n\treturn 1ll*x*y%mod;\n}\nLL Pow(LL base,LL b){\n\tLL ret(1); while(b){\n\t\tif(b&1) ret=mul(ret,base); base=mul(base,base); b>>=1;\n\t}return ret;\n}\nLL fac[maxn],fav[maxn];\nLL C(LL N,LL M){\n\tif(M>N) return 0;\n\treturn 1ll*fac[N]*fav[M]%mod*fav[N-M]%mod;\n}\nLL n;\nLL f[maxn][maxn],a[maxn];\nchar s[maxn];\nvoid Fir(){\n\tLL N(4000);\n\tfac[0]=1;\n\tfor(LL i=1;i<=N;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tfav[N]=Pow(fac[N],mod-2);\n\tfor(LL i=N;i>=1;--i) fav[i-1]=1ll*fav[i]*i%mod;\n}\nint main(){\n    scanf(\" %s\",s+1);\n    n=strlen(s+1);\n    Fir();\n    for(LL i=1;i<=n;++i){\n    \t/*\n    \tsum[i]=sum[i-1];\n    \tif(s[i]=='1') sum[i]++;\n    \tif(s[i]=='2') sum[i]+=2;\n\t\t*/\n    \ta[i]=s[i]-'0';\n\t}\n    f[0][0]=1;\n    for(LL i=0;i<n;++i){\n    \tfor(LL j=0;j<=2*i;++j){\n    \t\tif(j){\n    \t\t\tadd(f[i+1][j-1+a[i+1]],f[i][j]);\n\t\t\t}else if(a[i+1]){\n\t\t\t\tadd(f[i+1][j-1+a[i+1]],f[i][j]);\n\t\t\t}\n\t\t\tif(i-j){\n\t\t\t\tadd(f[i+1][j+a[i+1]],f[i][j]);\n\t\t\t}else if(a[i+1]!=2){\n\t\t\t\tadd(f[i+1][j+a[i+1]],f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%d %d\\n\",f[1][0],f[2][2]);\n\tLL ans(0);\n\tfor(LL j=0;j<=2*n;++j){\n\t\t//printf(\"(%d,%d)\",f[n][j],C(n,j));\n\t\tadd(ans,1ll*f[n][j]*C(n,j)%mod);\n\t}\n\t//puts(\"\");\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int MD=1e9+7;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,r,s;public:UnionFind(int N){p=r=vi(N);s=vi(N,1);fr(i,N){p[i]=i;}}int find(int i){return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){if(r[a=find(a)]>r[b=find(b)]){swap(a,b);}s[b]+=s[a];r[p[a]=b]+=r[a]==r[b];}bool same(int a,int b){return find(a)==find(b);}int size(int x){return s[find(x)];}};\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tconst int M=998244353;\n\tstr S;cin>>S;\n\tint N=S.size();\n\tvvl d(2*N+1,vl(2*N+1));\n\td[0][0]=1;\n\tint x=0,y;\n\tfr(i,2*N){\n\t\tif(i<N){\n\t\t\tx+=S[i]-'0';\n\t\t\ty=2*(i+1)-x;\n\t\t}\n\t\tfoor(j,0,i){\n\t\t\tfr(k,2){\n\t\t\t\tif(j+!k<=x&&i-j+k<=y){\n\t\t\t\t\t(d[j+!k][i-j+k]+=d[j][i-j])%=M;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(d[x][y]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nstring s;\nll dp[8010][8010];\nint d[2010][2];\n\nvoid solve(){\n    cin >> s;\n    n=s.length();\n    d[0][0]=0;\n    d[0][1]=0;\n    rep(i,2*n+1){\n        rep(j,2*n+1) dp[i][j]=0;\n    }\n    rep(i,n) {\n        d[i+1][0]=d[i][0]+2-(s[i]-'0');\n        d[i+1][1]=d[i][1]+(s[i]-'0');\n    }\n    Rep(i,n,2*n) {\n        d[i+1][0]=d[i][0];\n        d[i+1][1]=d[i][1];\n    }\n    rep(i,2*n+1){\n        //cout << d[i][0] << \" \" << d[i][1] << endl;\n    }\n    dp[0][0]=1;\n    rep(i,2*n){\n        rep(j,2*n){\n            if (d[i+1][0]>j){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }\n            if (d[i+1][1]>i-j){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=mod;\n            }\n            //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n\n    ll ans=0;\n    rep(i,2*n+1){\n        ans+=dp[2*n][i];\n        ans%=mod;\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define clr(x) memset(x, 0, sizeof(x))\n#define cpy(x,y) memcpy(x, y, sizeof(y))\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\n\n#ifdef _DEBUG\n#define LOCAL\n#endif\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#define dbg1(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 1; ABC <= n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#define dbg1(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 4e3 + 41;\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint n;\nchar s[MAX];\nint prefb[MAX];\nint prefr[MAX];\nint d[MAX][MAX];\n\nint qb[MAX];\n\nvoid solve() {\n\tfi(1, n) {\n\t\tint c = (int) (s[i] - '0');\n\t\tprefb[i] = prefb[i - 1] + c;\n\t\tprefr[i] = prefr[i - 1] + (2 - c);\n\t}\n//\tdbg1(prefb, n);\n//\tdbg1(prefr, n);\n\td[1][0] = 1;\n\tfi(1, n * 2) {\n//\t\terr(\"i = %d:\\n\", i);\n//\t\tdbg0(d[i], n * 2 + 1);\n\n\t\tint pos = min(i, n);\n\t\tfj(0, i - 1) {//have red\n\t\t\tif (!d[i][j]) continue;\n\t\t\t{//place red\n\t\t\t\tint want = j + 1;\n\t\t\t\tint have = prefr[pos];\n\t\t\t\tif (want <= have) {\n\t\t\t\t\td[i + 1][j + 1] = add(d[i + 1][j + 1], d[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{//place blue\n\t\t\t\tint want = i - j - 1 + 1;\n\t\t\t\tint have = prefb[pos];\n\t\t\t\tif (want <= have) {\n\t\t\t\t\td[i + 1][j] = add(d[i + 1][j], d[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n//\tdbg1(d[n * 2 + 1], n * 2 + 1);\n\tint ans = 0;\n\tfi(0, n * 2) {\n\t\tans = add(ans, d[n * 2 + 1][i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\t\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\tcin >> s;\n\tvector<int>v;\n\tvector<int>w;\n\tfor (auto i : s)v.push_back({ i - '0' });\n\tfor (auto i : v)w.push_back(2 - i);\n\tN = s.size();\n\tM = accumulate(v.begin(), v.end(),0);\n\tvector<vector<long long int>>dp(N * 2 + 1, vector<long long int>(M + 1));\n\tdp[0][0] = 1;\n\tint box = 0, bag = 0;\n\tint bbox = 0, bbag = 0;\n\tfor (int i = 1; i <= N * 2; i++) {\n\t\tfor (int j = 0; j < min(i, (int)v.size()); j++) {\n\t\t\tif (v[j]) {\n\t\t\t\tv[j]--;\n\t\t\t\tbox++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < min(i, (int)w.size()); j++) {\n\t\t\tif (w[j]) {\n\t\t\t\tw[j]--;\n\t\t\t\tbag++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i - bag; j <= M; j++) {\n\t\t\tif (i - 1 - bbag <= j && j <= bbox)dp[i][j] += dp[i - 1][j];\n\t\t\tif (i - 1 - bbag <= j - 1 && j - 1 <= bbox)dp[i][j] += dp[i - 1][j - 1];\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t\tbbox = box;\n\t\tbbag = bag;\n\t}\n\tcout << dp.back().back() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\n\nstring str;\nint n;\n\nll dp[4005][4005];\n\nint main(){\n  cin>>str;\n  n=str.size();\n  dp[0][0]=1;\n\n  ll cnt=0;\n  for(int i=0;i<n*2;i++){\n\n    if(i<n)cnt+=2;\n    \n    for(int j=0;j<=i*2;j++){\n      if(dp[i][j]==0)continue;\n      ll R=j;\n\n      if( i<n){\n        if(str[i]=='0'){\n          R+=2;\n        }else if(str[i]=='1'){\n          R++;\n        }\n      }\n      ll B=cnt-R;\n      if(R>0){\n        int nj=j;\n        if(R==j+2)nj++;\n        if(R==j)nj--;\n        dp[i+1][nj]+=dp[i][j];\n        dp[i+1][nj]%=mod;\n      }\n      \n      if(B>0){\n        int nj=j;\n        if(R==j+2)nj+=2;\n        if(R==j+1)nj++;\n        dp[i+1][nj]+=dp[i][j];\n        dp[i+1][nj]%=mod;\n      }\n    }\n    \n\n    cnt--;\n  }\n  /*\n  for(int i=0;i<=n*2;i++){\n    for(int j=0;j<=n*2;j++){\n      printf(\"%02d \",(int)dp[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  cout<<dp[2*n][0]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define mod 998244353\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n;\n  char s[2100];\n  scanf(\"%s\", s);\n  n = strlen(s);\n  ll dp[2 * n][2 * n + 1], sum[2 * n];\n  for(i = 0; i < 2 * n; ++i) {\n    if(i) {\n      sum[i] = sum[i - 1];\n      if(i < n) sum[i] += s[i] - '0';\n    } else sum[i] = s[i] - '0';\n    for(j = 0; j <= 2 * n; ++j) dp[i][j] = 0;\n  }\n  if(sum[0] != 2) dp[0][0] = 1;\n  if(sum[0]) dp[0][1] = 1;\n  for(i = 1; i < 2 * n; ++i) {\n    for(j = 0; j < 2 * n; ++j) if((i + 1) * 2 - sum[i] > i - j && i + 1 - j > 0) dp[i][j] += dp[i - 1][j];\n    for(j = 1; j <= 2 * n; ++j) if(sum[i] >= j) dp[i][j] += dp[i - 1][j - 1];\n    for(j = 0; j <= 2 * n; ++j) dp[i][j] %= mod;\n  }\n  printf(\"%lld\", dp[2 * n - 1][sum[2 * n - 1]]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) (int)x.size()\n#define sz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst ll mod = 998244353;\nchar X[2020];\nll dp[4020][4020];\nint sa[4040], sb[4040];\n\nint main() {\n\tscanf(\"%s\", X + 1);\n\tint N = (int)strlen(X + 1);\n\tfor(int i=1;i<=N;i++) sa[i] = sa[i-1] + (X[i] - '0');\n\tfor(int i=1;i<=N;i++) sb[i] = sb[i-1] + 2 - (X[i] - '0');\n\tdp[0][0] = 1;\n\tfor(int a=0;a<=sa[N];a++) for(int b=0;b<=sb[N];b++) {\n\t\tif(a < sa[N] && (a+b >= N || sa[a+b+1] >= a+1)) dp[a+1][b] = (dp[a+1][b] + dp[a][b]) % mod;\n\t\tif(b < sb[N] && (a+b >= N || sb[a+b+1] >= b+1)) dp[a][b+1] = (dp[a][b+1] + dp[a][b]) % mod;\n\t}\n\tprintf(\"%lld\\n\", dp[sa[N]][sb[N]]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nll ans = 0;\nconst ll mo = 998244353;\n\nint main()\n{\nstring s ;\ncin >> s ;\nll r=0,b=0;\nrep(i,s.size()){\n  if(s[i]=='0')r+=2;\n  else if(s[i]=='2')b+=2;\n  else {r++;b++;}\n}\nvector<ll> rr,bb;\nrr.push_back(0);\nbb.push_back(0);\nrep(i,s.size()){\n  if(s[i]=='0'){\n    rr.push_back(rr.back()+2);\n    bb.push_back(bb.back());\n  }\n  if(s[i]=='1'){\n    rr.push_back(rr.back()+1);\n    bb.push_back(bb.back()+1);\n  }\n  if(s[i]=='2'){\n    bb.push_back(bb.back()+2);\n    rr.push_back(rr.back());\n  }\n}\nwhile(rr.size()!=2*s.size()+1)rr.push_back(rr.back());\nwhile(bb.size()!=2*s.size()+1)bb.push_back(bb.back());\nvector<vector<ll>> v(s.size()*2, vector<ll>(r+1,0) );\nif(s[0]=='0')v[0][1]=1;\nif(s[0]=='1'){v[0][0]=1;v[0][1]=1;}\nif(s[0]=='2')v[0][0]=1;\nrep(i,s.size()*2-1){\n  rep(j,r+1){\n    if(i+2-j<=bb[i+2]){\n      v[i+1][j]+=v[i][j];\n      v[i+1][j]%=mo;\n    }\n    if(j+1<=rr[i+2]){\n      v[i+1][j+1]+=v[i][j];\n      v[i+1][j+1]%=mo;\n    }\n  }\n}\ncout << v[s.size()*2-1][r] << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nconst int maxn = 2100;\nconst int mod = 998244353;\nchar z[maxn];\nint n;\nint prer[maxn];\nint dp[maxn*2][maxn*2];\nvoid work () {\n\tint i , j;\n\tscanf ( \"%s\" , z + 1 );\n\tn = strlen ( z + 1 );\n\tfor ( i = 1 ; i <= n ; i++ ) prer[i] = prer[i-1] + (2-z[i]+'0');\n\tfor ( i = n + 1 ; i <= n + n ; i++ ) prer[i] = prer[i-1];\n\tdp[0][0] = 1;\n\tfor ( i = 0 ; i < n * 2 ; i++ ) {\n\t\tfor ( j = 0 ; j <= i ; j++ ) {\n\t\t\tif ( j < prer[i+1] ) {\n\t\t\t\tdp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod;\n\t\t\t}\n\t\t\tif ( i - j < i * 2 + 2 - prer[i+1] ) {\n\t\t\t\tdp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod;\n\t\t\t}\n\t\t\t//printf ( \"%d %d %d\\n\" , i , j , dp[i][j] );\n\t\t}\n\t}\n\tprintf ( \"%d\\n\" , dp[n*2][prer[n*2]] );\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nll MOD = 998244353;\n\nstring S;\n\nint thres[2][2020], N, R, B;\nll dp[4040][4040];\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> S;\n    N = S.size();\n\n    for (int i = 1; i <= N; ++i) {\n        thres[0][i] = thres[0][i-1] + 2 - (S[i-1] - '0');\n        thres[1][i] = thres[1][i-1] + (S[i-1] - '0');\n    }\n    R = thres[0][N]; B = thres[1][N];\n    cout << R << \" \" << B << endl;\n\n    dp[0][0] = 1;\n    for (int w = 1; w <= 2*N; ++w) {\n        int rM = w <= N ? thres[0][w] : R;\n        for (int r = 0; r <= rM; ++r) {\n            int b = w - r;\n            if (b > (w <= N ? thres[1][w] : B)) continue;\n            if (r > 0) (dp[r][b] += dp[r-1][b]) %= MOD;\n            if (b > 0) (dp[r][b] += dp[r][b-1]) %= MOD;\n        }\n    }\n\n    cout << dp[R][B] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=998244353;\nconst long double eps=1e-60;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\n\nint main(){\n    string s;cin>>s;\n    ll n=s.size();\n    vi sum(n);\n    sum[0]=s[0]-'0';\n    rep(i,n-1)sum[i+1]=sum[i]+s[i+1]-'0';\n    ll r=sum[n-1],b=n*2-r;\n    vvi dp(r+1,vi(b+1));\n    dp[0][0]=1;\n    rep(i,r+1)rep(j,b+1){\n        ll k=min(i+j,n-1);\n        if(sum[k]>i)dp[i+1][j]=(dp[i][j]+dp[i+1][j])%mod;\n        if(2*(k+1)-sum[k]>j)dp[i][j+1]=(dp[i][j]+dp[i][j+1])%mod;\n    }\n    out(dp[r][b]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int _=2005,yl=998244353;\nstring s;\nll f[_<<1][_<<1],n,ans;\nint main(){\n\tcin>>s;n=s.length();s='0'+s;f[0][0]=1;\n\tfor(int i=1,cnt=0,t=0;i<=n*2;++i){\n\t\tif(i<=n)cnt+=s[i]-'0',t+=2;\n\t\tfor(int j=max(0,i-(t-cnt));j<=cnt;++j){\n\t\t\tif(j==0)f[i][j]=f[i-1][j];\n\t\t\telse f[i][j]=(f[i-1][j]+f[i-1][j-1])%yl;\n\t\t\tif(i==n*2)ans+=f[i][j];\n\t\t}\n\t}\n\tcout<<ans%yl<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        if(k < 0) k += M - 1;\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing modint = ModInt<Mod>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    string s;\n    cin >> s;\n    int n = s.size();\n    V<int> a(n + 1), b(n + 1);\n    rep(i, n) {\n        a[i + 1] = a[i] + s[i] - '0';\n        b[i + 1] = b[i] + '2' - s[i];\n    }\n    V<V<modint>> dp(2, V<modint>(b[n] + 1));\n    dp[0][0] = 1;\n    rep(i, a[n] + 1) FOR(j, !i, b[n] + 1) {\n        int k = min<int>(n, i + j);\n        dp[i & 1][j] = (i <= a[k] && j <= b[k] ? (i ? dp[i - 1 & 1][j] : 0) +\n                                                     (j ? dp[i & 1][j - 1] : 0)\n                                               : 0);\n    }\n    cout << dp[a[n] & 1][b[n]] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <math.h>\n#include <map>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod (ll)(1e9+7)\n#define int ll\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nint dp[8001][8001];\n\nsigned main() {\n  string s;\n  cin >> s;\n  vector<int> ak, ao;\n  rep(i, 0, s.length()) {\n    if(s[i] == '0') {\n      ak.pb(i);\n      ak.pb(i);\n    }else if(s[i] == '1') {\n      ak.pb(i);\n      ao.pb(i);\n    }else {\n      ao.pb(i);\n      ao.pb(i);\n    }\n  }\n\n  sort(ak.begin(), ak.end());\n  sort(ao.begin(), ao.end());\n  dp[0][0] = 1;\n  rep(i, 0, ak.size() + 1) {\n    rep(j, 0, ao.size() + 1) {\n      if(i < ak.size() && i + j >= ak[i]) dp[i + 1][j] += dp[i][j], dp[i + 1][j] %= 998244353;\n      if(j < ao.size() && i + j >= ao[j]) dp[i][j + 1] += dp[i][j], dp[i][j + 1] %= 998244353;\n      else break;\n    }\n  }\n  cout << dp[ak.size()][ao.size()] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing ll = long long int;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = 998244353ll;\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll memo[4444][4444];\nbool done[4444][4444];\n\nint m,r[4444],b[4444];\n\nll solve(int i, int j){\n\tif(done[i][j]){\n\t\treturn memo[i][j];\n\t}\n\tdone[i][j] = true;\n\tif(i>r[i+j] || j>b[i+j]){\n\t\treturn memo[i][j] = 0ll;\n\t}\n\tif(i+j==m){\n\t\treturn memo[i][j] = 1ll;\n\t}\n\tmemo[i][j] = solve(i+1,j)+solve(i,j+1);\n\tmemo[i][j] %= MOD;\n\treturn memo[i][j];\n}\n\nint main(void){\n\tint n,i;\n\tstd::string s;\n\tstd::cin >> s;\n\tn = s.l_ength(); m = n*2;\n\tfor(i=0; i<n; ++i){\n\t\tr[i+1] = s[i]-'0';\n\t\tb[i+1] = '2'-s[i];\n\t}\n\tfor(i=1; i<m; ++i){\n\t\tr[i+1] += r[i];\n\t\tb[i+1] += b[i];\n\t}\n\tstd::cout << solve(0,0) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <memory>\n#include <complex>\n#include <numeric>\n#include <cstdio>\n#include <iomanip>\n\n#define REP(i,m,n) for(int i=int(m);i<int(n);i++)\n#define RREP(i,m,n) for(int i=int(n)-1;i>=int(m);--i)\n#define EACH(i,c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n#ifdef LOCAL\n#define DEBUG(s) cout << (s) << endl\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define BR cout << endl;\n#else\n#define DEBUG(s) do{}while(0)\n#define dump(x) do{}while(0)\n#define BR \n#endif\nusing namespace std;\n\nusing UI = unsigned int;\nusing UL = unsigned long;\nusing LL = long long int;\nusing ULL = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VLL = vector<LL>;\nusing VVLL = vector<VLL>;\nusing VS = vector<string>;\nusing PII = pair<int,int>;\nusing VP = vector<PII>;\n\n//struct edge {int from, to, cost;};\n\nconstexpr double EPS = 1e-10;\n//constexpr double PI  = acos(-1.0);\n//constexpr int INF = INT_MAX;\nconstexpr int MOD = 998244353;\n//inline void modAdd(LL &l, LL &r) {l = (l + r) % MOD;}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\nLL dfs(int n, int blue, VI &ru, VVLL &memo) {\n    if (n <= 0 || blue < 0) return 0;\n    //cout << n << \" \" << blue << \" \" << ru[min((int)ru.size()-1,n)] << \" \" << memo[n][blue] << endl;\n    if (memo[n][blue] > -1) return memo[n][blue];\n    if (n <= ru.size()) {\n        if (blue > ru[n-1]) return memo[n][blue] = 0;\n        if (n - blue > 2 * n - ru[n-1]) return memo[n][blue] = 0;\n    } else {\n        int maxb = ru[ru.size()-1];\n        if (blue > maxb) return memo[n][blue] = 0;\n        if (n - blue > 2 * ru.size() - maxb) return memo[n][blue] = 0;\n    }\n    if (n == 1) return memo[n][blue] = 1;\n    return memo[n][blue] = (dfs(n-1, blue - 1, ru, memo) + dfs(n-1, blue, ru, memo)) % MOD;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    VI ru(n);\n    ru[0] = s[0] - '0';\n    REP(i,1,n) ru[i] = ru[i-1] + s[i] - '0';\n    VVLL memo(2*n+1, VLL(2*n+1, -1));\n    cout << dfs(2*n,ru[n-1],ru,memo) << endl;\n}\n\nint main() {\n    solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, DP[4001][4001], R[2001], B[2001];\nstring S;\n\n\nint main() {\n\tcin >> S;\n\tN = S.size();\n\tfor (int i = 1; i <= N; ++i) {\n\t\tswitch (S[i - 1]) {\n\t\tcase '0':\n\t\t\tR[i] = 2;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tR[i] = B[i] = 1;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tB[i] = 2;\n\t\t\tbreak;\n\t\t}\n\t\tR[i] += R[i - 1];\n\t\tB[i] += B[i - 1];\n\t}\n\tDP[0][0] = 1;\n\tfor (int i = 0; i < N * 2; ++i) {\n\t\tfor (int j = max(0, i - B[min(i, N)]); j <= R[min(i, N)] && j <= i; ++j) {\n\t\t\tif (j + 1 <= R[min(i + 1, N)]) {\n\t\t\t\tDP[j + 1][i - j] = (DP[j + 1][i - j] + DP[j][i - j]) % 998244353;\n\t\t\t}\n\t\t\tif (i - j + 1 <= B[min(i + 1, N)]) {\n\t\t\t\tDP[j][i - j + 1] = (DP[j][i - j + 1] + DP[j][i - j]) % 998244353;\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[R[N]][B[N]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n    // 二次元ベクターの基本\n    /*\n    vector<vector<int>> dp; // 宣言\n    dp.resize(n); // 1次元めの要素数決定\n    dp[i].push_back(int); // プッシュバック\n    rep(i,n){\n        sort(dp[i].begin(),dp[i].end()); // 二次元めで昇順ソート\n    }\n    */\n\n    // 整数スキャン（複数）\n    /*\n    int x;\n    scanf(\"%d\",&x);\n    int y;\n    scanf(\"%d\",&y);\n    int z;\n    scanf(\"%d\",&z);\n\n    // n個の整数のスキャン\n    /*\n    ll a[n] = {};\n    rep(i,n){\n        scanf(\"%lld\",&a[i]);\n    }\n    */\n\n    // 文字列スキャン\n    /*\n    string s;\n    cin >> s;\n    */\n\n    // n個の文字列スキャン\n    /*\n    vector<string> slist;\n    rep(i,n){\n        string s;\n        cin >> s;\n        slist.push_back(s);\n    }\n    */\n\nint main() {\n    string s;\n    cin >> s;\n\n    int si = s.size();\n    int snu[si];\n    int t[si*2];\n    int snut[si];\n    int tt[si*2];\n\n    ll two[4100] ={};\n\n    two[0] = 1;\n    srep(i,1,4050){\n        two[i]=two[i-1]*2;\n        if(two[i]>998244353){\n            two[i] %= 998244353;\n        }\n    }\n\n    rep(i,si){\n        if(s[i]=='0'){\n            snu[i]=0;\n            snut[i]=0;\n        }\n        if(s[i]=='1'){\n            snu[i]=1;\n            snut[i]=1;\n        }\n        if(s[i]=='2'){\n            snu[i]=2;\n            snut[i]=2;\n        }\n    }\n\n    // 赤なら0,青なら1\n    // 辞書順最初\n    rep(i,si*2){\n        if(i%2==0){\n            if(snu[0]==2){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)]==0){\n                snu[si-1-(i/2)]=3;\n            }else{\n                snu[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snu[0]==2||snu[0]==4){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)-1]==0&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 1;\n            }else if(snu[si-1-(i/2)-1]==1&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 2;\n            }else if(snu[si-1-(i/2)-1]==2&&snu[si-1-(i/2)]==3){\n                snu[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n\n        rep(j,i+1){\n            cout << t[j];\n        }\n        cout << endl;\n        */\n    }\n    int cm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cm[i]=t[i];\n        }else{\n            cm[i]=t[i]+cm[i-1];\n        }\n        \n    }\n    //cout << endl;\n\n    // 辞書順最後\n    rep(i,si*2){\n        if(i%2==0){\n            if(snut[0]==0){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)]!=2){\n                snut[si-1-(i/2)]=3;\n            }else{\n                snut[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snut[0]==0||snut[0]==3){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)-1]==0&&snut[si-1-(i/2)]==4){\n                snut[si-1-(i/2)-1] = 1;\n            }else if(snut[si-1-(i/2)-1]==1&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 0;\n            }else if(snut[si-1-(i/2)-1]==2&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n        rep(j,i+1){\n            cout << tt[j];\n        }\n        cout << endl;\n        */\n    }\n    int cmm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cmm[i]=tt[i];\n        }else{\n            cmm[i]=tt[i]+cmm[i-1];\n        }\n        \n    }\n\n    ll dp[si*2][si*2+1];\n    rep(i,si*2+1){\n        dp[0][i]=0;\n    }\n    if(cm[0]==0)dp[0][0]=1;\n    dp[0][1]=cmm[0];\n    srep(i,1,si*2){\n        rep(j,si*2+1){\n            if(j<cm[i]){\n                dp[i][j]=0;\n            }else if(j>cmm[i]){\n                dp[i][j]=0;\n            }else{\n                if(cm[i]<=j&&j<=cmm[i]){\n                    if(j==0){\n                        dp[i][j]=dp[i-1][j];\n                    }else{\n                        dp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n                    }\n                    \n                    if(dp[i][j]>998244353){\n                        dp[i][j] %= 998244353;\n                    }\n                }\n            }\n        }\n    }\n    \n    ll ans = 0;\n    rep(i,si*2+1){\n        ans+=dp[si*2][i];\n        if(ans>998244353){\n            ans %= 998244353;\n        }\n    }\n\n    return 0;\n}\n \n \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2010,mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nchar str[N];\nint sum[N][2],n;\nll dp[N][N],frac[N],inv[N];\nint main()\n{\n\tscanf(\"%s\",str+1); n=strlen(str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tsum[i][0]=sum[i-1][0]+(str[i]-'0');\n\t\tsum[i][1]=sum[i-1][1]+2-(str[i]-'0');\n\t}\n\tfrac[0]=1;\n\tfor(int i=1;i<=n;++i) frac[i]=frac[i-1]*i%mod;\n\tinv[n]=Pow(frac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\t\n\tdp[0][0]=1;\n\tfor(int i=0;i<n;++i)\n\tfor(int j=0;j<=i;++j)\n\tif(dp[i][j])\n\t{\n\t\tif(sum[i+1][0]>=j+1) dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t\tif(sum[i+1][1]>=i+1-j) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t}\n//\tfor(int j=0;j<=n;++j) printf(\"%0lld\\n\",dp[n][j]); \n\tll ans=0;\n\tfor(int i=0;i<=n;++i) if(sum[n][0]>=i&&sum[n][1]>=(n-i)) ans=(ans+dp[n][i]*inv[sum[n][0]-i]%mod*inv[sum[n][1]-(n-i)]%mod);\n\tans=ans*frac[n]%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <iterator>\n#pragma warning(disable:4996)\n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223372036854775807\n#define INF 2147483647\n//#define MOD 1000000007\n#define MOD 998244353\nusing namespace std;\n\nll dp[4005][4005];\n\nint main(int argc, char* argv[])\n{\n    char str[2005]={0};\n    scanf(\"%s\", str);\n    long n=strlen(str);\n\n    vector<long> r(n);\n    vector<long> b(n);\n    vector<ll> sr(2*n+1,0);\n    vector<ll> sb(2*n+1,0);\n    long i;\n    for(i=0; i<n; i++) {\n        r[i]='2'-str[i];\n        b[i]=str[i]-'0';\n        sr[i+1]=(sr[i]+r[i])%MOD;\n        sb[i+1]=(sb[i]+b[i])%MOD;\n    }\n    for(i=n; i<2*n; i++) {\n        sr[i+1]=sr[i];\n        sb[i+1]=sb[i];\n    }\n\n    dp[0][0]=1;\n    long j;\n    for(i=1; i<=2*n; i++) {\n        for(j=0; j<=i; j++) {\n            if ( j <= sr[i] ) dp[i][j] = dp[i-1][j-1] %MOD;\n            if ( i-j <= sb[i] ) dp[i][j] = (dp[i][j] + dp[i-1][j]) %MOD;\n        }\n    }\n\n    ll sum=0;\n    for(j=0; j<=2*n; j++) {\n        sum = (sum + dp[2*n][j]) %MOD;\n    }\n    printf(\"%lld\\n\", sum);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int mod = 998244353, maxn = 2000;\n\nint dp[2 * maxn + 1][2 * maxn + 1];\nmultiset<int> pos[2];\n\nint solve(int i, int n0, int n1, int n) {\n  if (i == 2 * n) {\n    return 1;\n  }\n\n  int &res = dp[n0][n1];\n  if (res != -1) return res;\n\n  pair<int, int> range;\n  if (i < n) {\n    range = {0, i};\n  } else {\n    range = {0, n - 1};\n  }\n\n  res = 0;\n  for (int val = 0; val < 2; ++val) {\n    auto it = pos[val].lower_bound(range.first);\n    if (it != pos[val].end() && *it <= range.second) {\n      int this_pos = *it;\n      pos[val].erase(it);\n      res += solve(i + 1, n0 + (val == 0), n1 + (val == 1), n);\n      if (res >= mod) res -= mod;\n      pos[val].insert(this_pos);\n    }\n  }\n\n  return res;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '0') {\n      pos[0].insert(i);\n      pos[0].insert(i);\n    } else if (s[i] == '1') {\n      pos[0].insert(i);\n      pos[1].insert(i);\n    } else {\n      pos[1].insert(i);\n      pos[1].insert(i);\n    }\n  }\n\n  memset(dp, -1, sizeof(dp));\n  int result = solve(0, 0, 0, n);\n  printf(\"%d\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int mod=998244353;\n\nlong C[2001][4001];\n\nlong comb(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=mod;\n\t\t}\n\t\tC[i][i]=1;\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n=s.length();\n\tint red[n]={};\n\tred[0]=(s[0]=='0'?2:s[0]=='1'?1:0);\n\tfor(int i=1;i<n;i++) red[i]+=red[i-1]+(s[i]=='0'?2:s[i]=='1'?1:0);\n\t\n\tlong dp[n+1][2*n+1]={};\n\tdp[1][0]=(s[0]!='0'?1:0);\n\tdp[1][1]=(s[0]!='2'?1:0);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=max(0,red[i-1]-i);j<=min(i,red[i-1]);j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(j!=0?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcomb(n);\n\tlong ans=0;\n\tfor(int i=0;i<=min(n,red[n-1]);i++){\n\t\tif(i<=red[n-1]) ans+=dp[n][i]*C[n][red[n-1]-i]%mod;\n\t\tans%=mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) { return std::vector<T>(n, std::forward<T>(val)); }\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\ntemplate<class Cond> struct chain {\n  Cond cond; chain(Cond cond) : cond(cond) {}\n  template<class T> bool operator()(T& a, const T& b) const { if(cond(a, b)) { a = b; return true; } return false; }\n};\ntemplate<class Cond> chain<Cond> make_chain(Cond cond) { return chain<Cond>(cond); }\n\n#include <iostream>\nusing i64 = long long;\ntemplate<i64 M> struct modint { i64 a;\n  constexpr modint(const i64 x = 0): a((x%M+M)%M){}\n  constexpr i64 value() const { return a; }\n  constexpr modint inv() const { return this->pow(M-2); }\n  constexpr modint pow(i64 r) const {\n    modint ans(1); modint aa = *this;\n    while(r) { if(r & 1) ans *= aa; aa *= aa; r >>= 1; }\n    return ans;\n  }\n  constexpr modint& operator=(const i64 r) { a = (r % M + M) % M; return *this; }\n  constexpr modint& operator+=(const modint r) { a += r.a; if(a >= M) a -= M; return *this; }\n  constexpr modint& operator-=(const modint r) { a -= r.a; if(a < 0) a += M; return *this; }\n  constexpr modint& operator*=(const modint r) { a = a * r.a % M; return *this; }\n  constexpr modint& operator/=(const modint r) { (*this) *= r.inv(); return *this; }\n  constexpr modint operator+(const modint r) const { return modint(*this) += r; }\n  constexpr modint operator-(const modint r) const { return modint(*this) -= r; }\n  constexpr modint operator*(const modint r) const { return modint(*this) *= r; }\n  constexpr modint operator/(const modint r) const { return modint(*this) /= r; }\n  constexpr bool operator!=(const modint r) const { return this->value() != r.value(); }\n};\n\ntemplate<const i64 M> std::ostream& operator<<(std::ostream& os, const modint<M>& m) { os << m.value(); return os; }\n\nusing fp = modint<998244353>;\n\nint main() {\n  string S;\n  cin >> S;\n  i64 N = S.size();\n  auto dp = ndvec(N * 2 + 1, N * 2 + 1, fp(0));\n  dp[0][0] = fp(1);\n  i64 rsum = 0;\n  rep(i,0,N * 2) {\n    i64 R = 0;\n    if(i < N)\n      R = (int)(S[i] - '0');\n    rsum += R;\n    i64 n = std::min(N * 2, (i + 1) * 2);\n    rep(j,0,N * 2 + 1) {\n      i64 r = rsum - j;\n      i64 b = n - rsum - (i - j);\n      if(b < 0 || r < 0) continue;\n      if(r > 0) {\n        dp[i + 1][j + 1] += dp[i][j];\n      }\n      if(b > 0) {\n        dp[i + 1][j] += dp[i][j];\n      }\n    }\n  }\n  cout << dp[N * 2][rsum] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 998244353;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m,a,b,c,d,e,f,g,h,r,w,l,num,ans,ok,ng,mid;\nll x[500005],y[500005],z[500005];\nll dp[5050][5005];\nll sum[305];\n\nchar s[500005],t[500005],u[500005];\nbool dame,flag;\n//string s;\n\nint main(){\n\tcin >> s;\n\tn = strlen(s);\n\tll r=0,b=0;\n\tll rsum[5000],bsum[45000];\n\tfor(i=0;i<n;i++){\n\t\tif(s[i] == '2'){\n\t\t\tb += 2;\n\t\t}else if(s[i] == '1'){\n\t\t\tr += 1;\n\t\t\tb += 1;\n\t\t}else{\n\t\t\tr += 2;\n\t\t}\n\t\trsum[i+1] = r;\n\t\tbsum[i+1] = b;\n\t}\n\tfor(i=n;i<n*2;i++){\n\t\trsum[i+1] = r;\n\t\tbsum[i+1] = b;\n\t}\n\tdp[0][0] = 1;\n\tfor(i=0;i<=r;i++){\n\t\tfor(j=0;j<=b;j++){\n\t\t\tif(i+j == 0)continue;\n\t\t\tif(rsum[i+j] >= i && i >= 1){\n\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t}\n\t\t\tif(bsum[i+j] >= j && j >= 1){\n\t\t\t\tdp[i][j] += dp[i][j-1];\n\t\t\t}\n\t\t\tdp[i][j] %= mod;\n\t\t\t//pe(dp[i][j]);\n\t\t}\n\t\t//el;\n\t}\n\tp(dp[r][b]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define LL long long\n#define PB push_back\n#define INF 2000000000\n#define X first\n#define Y second\nusing namespace std;\nconst LL mod = 998244353;\nconst LL MAX = 600005;\nstring s;\nLL can[4005][4005];\nLL dp[4005][4005];\nLL add(LL a , LL b)\n{\n\treturn a + b >= mod ? a + b - mod : a + b;\n}\n\nint main()\n{\n\t//freopen(\"input.txt\" , \"r\" , stdin);\n\tcin >> s;\n\tLL n = s.size();\n\n\tLL cntBlue = 0 , cntRed = 0;\n\t//How about last?\n\tfor(LL hid = 0; hid <= 2 * n; hid++)\n\t{\n\t\tfor(LL blue = 0; blue <= hid; blue++)\n\t\t{\n\t\t\tLL red = hid - blue;\n\t\t\tcan[blue][red] = blue <= cntBlue && red <= cntRed &&  (!blue && !red || blue && can[blue - 1][red] || red && can[blue][red - 1]);\n\t\t}\n\t\tif(hid < n)\n\t\t{\n\t\t\tif(s[hid] == '0')\n\t\t\t\tcntBlue += 2;\n\t\t\tif(s[hid] == '1')\n\t\t\t\tcntBlue++ , cntRed++;\n\t\t\tif(s[hid] == '2')\n\t\t\t\tcntRed += 2;\n\t\t}\n\t}\n\t\n\tdp[0][0] = 1;\n\tfor(LL cnt = 0; cnt < 2 * n; cnt++)\n\t{\n\t\tfor(LL blue = 0; blue <= cnt; blue++)\n\t\t{\t\n\t\t\tLL red = cnt - blue;\n\t\t\tif(can[blue + 1][red])\n\t\t\t\tdp[blue + 1][red] = add(dp[blue + 1][red] , dp[blue][red]);\n\t\t\tif(can[blue][red + 1])\n\t\t\t\tdp[blue][red + 1] = add(dp[blue][red + 1] , dp[blue][red]);\n\t\t}\n\t}\n\tLL ans = 0;\n\tfor(LL i = 0; i <= 2 * n; i++)\n\t\tans = add(ans , dp[2 * n - i][i]);\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\nll dp[2000][2010];\nint sum[2000];\nconst int MAX_P=2010;\nll extgcd(ll a, ll b, ll& x, ll&y){\n    ll d=a;\n    if(b!=0){\n        d=extgcd(b, a%b, y, x);\n        y-=(a/b)*x;\n    }\n    else {\n        x=1; y=0;\n    }\n    return d;\n}\n\nll mod_inverse(ll a, ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\n//n!modp\nll fact[MAX_P];\n\n//n!=a p＾eとした時のa modpを求める。O(log_p n)\nll mod_fact(ll n, ll p, ll& e){\n    e=0;\n    if(n==0) return 1;\n    \n    //pの倍数の部分を計算\n    ll res=mod_fact(n/p,p,e);\n    e+=n/p;\n    \n    //(p-1)!≡-1なので(p-1)!^(n/p)はn/pの偶奇だけで計算できる\n    if(n/p%2!=0) return res*(p-fact[n%p])%p;\n    return res*fact[n%p]%p;\n}\n\n//nCk modpを求める。O(log_p n)\nll mod_comb(ll n, ll k, ll p){\n    if(n<0||k<0||n<k) return 0;\n    ll e1, e2, e3;\n    ll a1=mod_fact(n,p,e1), a2=mod_fact(k,p,e2), a3=mod_fact(n-k,p,e3);\n    if(e1>e2+e3) return 0;\n    return a1*mod_inverse(a2*a3%p,p)%p;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string S;\n    cin>>S;\n    int N=S.length();\n    sum[0]=2-(S[0]-'0');\n    rep(i,1,N){\n        sum[i]=sum[i-1]+2-(S[i]-'0');\n    }\n    if(S[0]=='0'){\n        dp[0][0]=0;\n        dp[0][1]=1;\n    }\n    if(S[0]=='1'){\n        dp[0][0]=1;\n        dp[0][1]=1;\n    }\n    if(S[0]=='2'){\n        dp[0][0]=1;\n        dp[0][1]=0;\n    }\n    rep(i,1,N){\n        rep(j,0,i+2){\n            if(j==0){\n                dp[i][j]=(dp[i-1][0]&&sum[i]<=i+1?1:0);\n            }\n            else{\n                dp[i][j]=(sum[i]>j-1?dp[i-1][j-1]:0)+(sum[i]-j<=i+1?dp[i-1][j]:0);\n                dp[i][j]%=MOD;\n            }\n        }\n    }\n    fact[1]=1;\n    rep(i,2,MAX_P){\n        fact[i]=fact[i-1]*i;\n        fact[i]%=MOD;\n    }\n    ll ans=0;\n    rep(i,0,min(sum[N-1]+1, N+1)){\n        ans+=mod_comb(N, sum[N-1]-i, MOD)*dp[N-1][i]%MOD;\n        ans%=MOD;\n    }\n    cout << ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 4010\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int mod=998244353;\nint f[N][N],s[N]; char c[N];\nint main()\n{\tint n,ans=0; scanf(\"%s\",c+1); n=strlen(c+1);\n\tfor(rint i=1;i<=n;i++)\n\t{\ts[i]=s[i-1];\n\t\tif(c[i]=='0') s[i]+=2;\n\t\telse if(c[i]=='1') s[i]++;\n\t}\n\tf[0][0]=1;\n\tfor(rint i=0;i<n+n;i++)\n\tfor(rint j=0;j<=i;j++)\n\t{\tif(s[min(i+1,n)]-j>0) (f[i+1][j+1]+=f[i][j])%=mod;\n\t\tif(2*min(i+1,n)-s[min(i+1,n)]-(i-j)>0) (f[i+1][j]+=f[i][j])%=mod;\n\t}\n\tfor(rint i=0;i<=n+n;i++) (ans+=f[n+n][i])%=mod;\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tstring S;\n\tcin >> S;\n\n\tll dp[4001][4001] = {};\n\tdp[0][0] = 1;\n\n\tint N = S.size();\n\tll mod = 998244353;\n\n\trep(i, N) {\n\t\tint A = S[i] - '0';\n\t\trep(j, 4001) {\n\t\t\tif (dp[i][j]) {\n\t\t\t\tif (j + A > 0) {\n\t\t\t\t\tdp[i + 1][j + A - 1] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j + A - 1] %= mod;\n\t\t\t\t}\n\t\t\t\tif (2 + i - j - A > 0) {\n\t\t\t\t\tdp[i + 1][j + A] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j + A] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = N; i < 2 * N; i++) {\n\t\trep(j, 4001) {\n\t\t\tif (dp[i][j]) {\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j - 1] %= mod;\n\t\t\t\t}\n\t\t\t\tif (2 * N - i - j > 0) {\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tco(dp[2 * N][0]);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define _for(i,j,N) for(int i = (j); i < (N);i++)\n#define _rep(i,j,N) for(int i = (j); i <= (N);i++)\n#define _dec(i,j,N) for(int i = (N-1);i >= 0;i--)\n#define _dep(i,j,N) for(int i = (N); i>= 0;i--)\n#define ALL(x) x.begin(),x.end()\n#define LL long long\n#define ULL unsigned LL\n#define PB push_back\n\n\nLL dp[2][40005];\nint R[4005];\nint B[4005];\n\nconst LL mod = 998244353;\n\nint main()\n{\n    string s;\n    cin >> s;\n    int sz = s.size();\n    R[0] = (B[0] = 0);\n    _rep(i,1,sz){\n        R[i] = R[i-1];B[i] = B[i-1];\n        if(s[i-1] == '0') R[i] += 2;\n        else if(s[i-1] == '1'){R[i]++;B[i]++;}\n        else B[i]+=2;\n    }\n    _rep(i,sz+1,2*sz){\n        R[i] = R[i-1];B[i] = B[i-1];\n    }\n\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = 1;\n    int t = 1;\n    _rep(n,1,2*sz){\n        int bef = t^1;\n        _rep(i,0,n){\n            LL &ans = dp[t][i];\n            if(B[n] < n-i){ans = 0;continue;}\n            if(R[n] < i){ans = 0;break;}\n            if(!i){ans = dp[bef][i];continue;}\n            ans = (dp[bef][i] + dp[bef][i-1])%mod;\n            //printf(\"%d %d %lld\\n\",n,i,ans);\n        }\n        t = t^1;\n    }\n\n    /*\n    _rep(i,1,sz){\n        printf(\"%d \",B[i]);\n    }\n    printf(\"\\n\");\n    //cout << R[sz] << endl;\n    */\n\n    printf(\"%lld\\n\",dp[t^1][R[sz]]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 998244353;\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\t\n\tstatic int r[2002] = {};\n\tstatic int b[2002] = {};\n\trep1(i,n){\n\t\tr[i] = 2-(s[i-1]-'0');\n\t\tb[i] = s[i-1]-'0';\n\t}\n\trep1(i,n){\n\t\tr[i] += r[i-1];\n\t\tb[i] += b[i-1];\n\t}\n\t\n\tstatic ll dp[2][4002] = {};\n\tstatic int t = 0, t_ = 1;\n\tdp[t][0] = 1;\n\trep1(i,2*n){\n\t\trep(j,4002)dp[t_][j] = 0;\n\t\tint max_r = r[min(n,i)];\n\t\tint max_b = b[min(n,i)];\n\t\trep(j,4002){\n\t\t\tif(j+1 <= max_r)dp[t_][j+1] += dp[t][j];\n\t\t\tif(i-j <= max_b)dp[t_][j] += dp[t][j];\n\t\t}\n\t\trep(j,4002){\n\t\t\tdp[t_][j] %= M;\n\t\t}\n\t\tswap(t,t_);\n\t}\n\tcout << dp[t][r[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 998244353\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \ntemplate<int MAX>\nstruct comcalc{\n    vector<mint> fact,finv,inv;\n    comcalc():fact(MAX),finv(MAX),inv(MAX){\n        fact[0]=mint(1),fact[1]=mint(1),finv[0]=mint(1),finv[1]=mint(1),inv[1]=mint(1);\n        for(int i=2;i<MAX;i++){\n            fact[i]=fact[i-1]*mint(i);\n            inv[i]=mint(0)-inv[mod%i]*(mint(mod/i));\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    mint com(int n,int k){\n        if(n<k) return mint(0);\n        if(n<0 or k<0) return mint(0);\n        return fact[n]*(finv[k]*finv[n-k]);\n    }\n    mint fac(int n){\n        return fact[n];\n    }\n    // 重複組み合わせ:n種類の物から重複を許し，k個選ぶ\n    mint nHk(int n,int k){\n        return com(n+k-1,k);\n    }\n    // 玉n区別，箱k区別，各箱1個以上O(k)\n    mint F12_dis_dis_one(int n,int k){\n        mint ret=1;\n        for(int i=0;i<=k;i++){\n            mint add=com(k,i)*(mint(i).pow(n));\n            if((k-i)%2) ret-=add;\n            else        ret+=add;\n        }\n        return ret;\n    }\n};\nmint pow_mod(mint x,ll n){\n    return x.pow(n);\n}\nmint inv_mod(mint x){\n    return x.inverse();\n}\n// O(n)\nmint fact_mod(ll n){\n    mint ret=1;\n    for(int i=2;i<=n;i++) ret*=mint(i);\n    return ret;\n}\n// O(r)\nmint comb_mod(ll n,ll r){\n    if(r>n-r) r=n-r;\n    if(r==0) return 1;\n    mint a=1,b=mint(fact_mod(r)).inverse();\n    for(int i=0;i<r;i++)a*=mint(n-i);\n    return a*b;\n}\n \nconst int MAX=4010000;\nusing cominit=comcalc<MAX>;\n\nint ng[4001][4001];\nmint dp[4001][4001];\n\nsigned main(){\n    string s;cin>>s;\n    int n=s.size();\n    vector<int>rv(n),bv(n);\n    int rc=0,bc=0;\n    rep(i,n){\n        rv[i]=(s[i]-'0');\n        bv[i]=2-rv[i];\n        rc+=rv[i];\n        bc+=bv[i];\n    }\n\n    \n    rep(i,rc+1)rep(j,bc+1)ng[i][j]=false,dp[i][j]=0;\n    dp[0][0]=1;\n\n\n    {\n        int r=0,b=0;\n        for(int i=0;b<bc;i++){\n            b+=bv[i];\n            if(b+r<i+1){\n                ng[r][b+1]=true;\n                r++;\n            }\n        }\n\n        \n    }\n    {\n        int r=0,b=0;\n        for(int i=0;r<rc;i++){\n            r+=rv[i];\n            if(r+b<i+1){\n                ng[r+1][b]=true;\n                b++;\n            }\n        }\n    }\n\n    rep(i,rc+1){\n        rep(j,bc+1){\n            if(i>0 and !ng[i-1][j]) dp[i][j]+=dp[i-1][j];\n            if(j>0 and !ng[i][j-1]) dp[i][j]+=dp[i][j-1];\n        }\n    }\n\n    cout<<dp[rc][bc]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nstring s;\nll dp[8010][8010];\nint d[4010][2];\n\nvoid solve(){\n    cin >> s;\n    n=s.length();\n    d[0][0]=0;\n    d[0][1]=0;\n    rep(i,2*n+1){\n        rep(j,2*n+1) dp[i][j]=0;\n    }\n    rep(i,n) {\n        int m=s[i]-'0';\n        d[i+1][0]=d[i][0]+2-m;\n        d[i+1][1]=d[i][1]+m;\n    }\n    Rep(i,n,2*n) {\n        d[i+1][0]=d[i][0];\n        d[i+1][1]=d[i][1];\n    }\n    rep(i,2*n+1){\n        //cout << d[i][0] << \" \" << d[i][1] << endl;\n    }\n    dp[0][0]=1;\n    rep(i,2*n){\n        rep(j,2*n){\n            if (d[i+1][0]>j){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }\n            if (d[i+1][1]>i-j){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=mod;\n            }\n            //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n\n    ll ans=0;\n    rep(i,2*n+1){\n        ans+=dp[2*n][i];\n        ans%=mod;\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(4001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(2 * N + 1));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                dp[i][j] %= MOD;\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - b;\n                }\n                if(b < 0) continue;\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    (dp[i + 1][j] += dp[i][j]) %= MOD;\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n            if(blue + red != N){\n                exit(-1);\n            }\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i] % MOD;\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = (left * right) % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll n;\nstring s;\nll a[2002];\nll r[2002];\nll b[2002];\nconst ll mod =998244353;\nll dp[4002][2002];\nll solve(ll id, ll ur)\n{\n        if(id == n+n+1) return 1LL;\n        if(dp[id][ur] != -1) return dp[id][ur];\n        ll &ret = dp[id][ur];\n        ret = 0LL;\n        ll ub = id-1-ur;\n        ll yo = id;\n        if(id >= n) yo = n;\n        ll totr = r[yo];\n        ll totb = b[yo];\n        if(ur < totr) ret = (ret + solve(id+1,ur+1))%mod;\n        if(ub < totb) ret = (ret + solve(id+1, ur))%mod;\n        return ret;\n}\nint main()\n{\n        cin >> s;\n        n = s.length();\n        for(ll i=1;i<=n;i++) {\n                a[i] = s[i-1] - '0';\n                if(a[i] == 0) r[i] += 2;\n                else if(a[i] == 1) {\n                        r[i]++;\n                        b[i]++;\n                }else b[i] += 2;\n                r[i] += r[i-1];\n                b[i] += b[i-1];\n        }\n        memset(dp,-1,sizeof dp);\n        cout << solve(1,0) << endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define all(v) (v).begin(),(v).end()\ntemplate<class T>bool chmax(T &a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate<class T>bool chmin(T &a,T b){if(b<a){a=b;return 1;} return 0;}\n\nint dx[4] = {0,0,-1,1};\nint dy[4] = {1,-1,0,0};\nstring rlud = \"RLUD\";\n\n\nconst int MAX = 10000;\nconst int mod = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\nll dp[2][2001][2001];\n\n// run : ctrl + c \nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    \n    string s;\n    cin>>s;\n    int n = s.size();\n    COMinit();\n    int r=0,b=0;\n    int x = 1;\n    dp[0][0][0] = 1;\n    for(int i=0;i<n;i++){\n        int nb=b,nr=r;\n        if(s[i]=='0')nr+=2;\n        if(s[i]=='2')nb+=2;\n        if(s[i]=='1')nr++,nb++;\n        for(int j=0;j<=i;j++){\n            dp[x][j][i-j]=0;\n        }\n        for(int j=0;j<=i;j++){\n            if(r>=j && b>=i-j){\n                if(nr-j>0){\n                    dp[x][nr-j-1][nb-(i-j)] += dp[x^1][r-j][b-(i-j)];\n                    dp[x][nr-j-1][nb-(i-j)] %= mod;\n                }\n                if(nb-(i-j)>0){\n                    dp[x][nr-j][nb-(i-j)-1] += dp[x^1][r-j][b-(i-j)];\n                    dp[x][nr-j][nb-(i-j)-1] %= mod;\n                }\n            }\n        }\n        r=nr, b=nb;\n        x ^= 1;\n    }\n    ll ans = 0;\n    x ^= 1;\n    for(int i=0;i<=n;i++){\n        ans += (dp[x][i][n-i] * COM(n,i))%mod;\n        ans %= mod;\n    }\n    cout << ans << endl;\n\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=998244353, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\nvector<vector<ll> > dp(5000, vector<ll> (5000, 0));\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    ll num = 0;\n    ll ret = 0, blue = 0;\n    string s;\n    cin >> s;\n    ll n = s.length();\n    for(int i=0;i<n;i++){\n    \tif(s[i] == '1') num++;\n    \telse if(s[i] == '2') num += 2;\n    }\n    dp[0][0] = 1;\n    for(int i=0;i<n*2;i++){\n    \tif(i < n){\n    \t\tif(s[i] == '0') ret += 2;\n    \t\telse if(s[i] == '1') ret++, blue++;\n    \t\telse blue += 2;\n    \t}\n    \tfor(int j=0;j<n*2;j++){\n    \t\tif(i-j+1 <= ret)(dp[i+1][j] += dp[i][j]) %= mod;\n    \t\tif(j+1 <= blue) (dp[i+1][j+1] += dp[i][j]) %= mod;\n    \t}\n    }\n    cout << dp[n*2][num] << endl; \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\npublic:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr double eps = 1e-9;\n\nvoid solve() {\n    constexpr i64 mod = 998244353;\n\n    string S;\n    cin >> S;\n\n    function<void(vector<vector<int>>&, int, string&)> find_min=[&](vector<vector<int>> &v, int i, string &res){\n        while(!v.empty()) {\n            if (i == v.size()) {\n                if (v.back().empty()) {\n                    v.pop_back();\n                }\n                i=0;\n                continue;\n            }\n\n            sort(begin(v[i]), end(v[i]));\n            if (i == 0) {\n                res += '0' + v[i][0];\n            } else {\n                v[i - 1].emplace_back(v[i][0]);\n            }\n            v[i].erase(begin(v[i]));\n            ++i;\n        }\n    };\n\n    function<void(vector<vector<int>>&, int, string&)> find_max=[&](vector<vector<int>> &v, int i, string &res){\n        while(!v.empty()) {\n            if (i == v.size()) {\n                if (v.back().empty()) {\n                    v.pop_back();\n                }\n                i=0;\n                continue;\n            }\n\n            sort(rbegin(v[i]), rend(v[i]));\n            if (i == 0) {\n                res += '0' + v[i][0];\n            } else {\n                v[i - 1].emplace_back(v[i][0]);\n            }\n            v[i].erase(begin(v[i]));\n            ++i;\n        }\n    };\n\n    const i64 N=S.size();\n    vector<vector<int>> v(N);\n    rep(i,0,N){\n        if(S[i]=='0'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(0);\n        }else if(S[i]=='1'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(1);\n        }else{\n            v[i].emplace_back(1);\n            v[i].emplace_back(1);\n        }\n    }\n\n    string mini,maxi;\n    {\n        auto tv=v;\n        find_min(tv, 0, mini);\n    }\n    {\n        auto tv=v;\n        find_max(tv, 0, maxi);\n    }\n\n    vector<i64> rmin(N),bmin(N);\n    {\n        i64 r=0,b=0;\n        rep(i,0,N){\n            rep(j,0,2){\n                if(v[i][j]==0) ++r;\n                else ++b;\n            }\n            rmin[i]=max(i+1-b,i64(0));\n            bmin[i]=max(i+1-r,i64(0));\n        }\n    }\n\n    function<fp<mod>(string)> count=[&](string m) {\n        constexpr i64 maxn = 2000;\n        static fp<mod> dp[maxn * 2][2][2*maxn + 1]; // 桁, 境界か?, 使用したbの数\n        fill_n((fp<mod> *) dp, maxn * 2 * 2 * (2*maxn + 1), fp<mod>(0));\n\n        i64 sumb=0;\n        rep(i,0,m.size()) if(m[i]=='1') ++sumb;\n\n        if(m[0]=='0'){\n            dp[0][1][0]=1;\n        }else{\n            dp[0][0][0]=1;\n            dp[0][1][1]=1;\n        }\n\n        rep(i,0,m.size()-1){\n            rep(j,0,2){\n                rep(k, 0, sumb + 1){\n                    if(i<N){\n                        i64 r=i+1-k;\n                        i64 b=k;\n                        if(r<rmin[i] or b<bmin[i]) continue;\n                    }\n\n                    // r=0を置く\n                    if(m[i+1]=='0'){\n                        if(j==0){\n                            // 既に境界より低い\n                            dp[i+1][0][k]+=dp[i][j][k];\n                        }else{\n                            dp[i+1][1][k]+=dp[i][j][k];\n                        }\n                    }else{\n                        dp[i+1][0][k]+=dp[i][j][k];\n                    }\n\n                    // b=1を置く\n                    if(k < sumb) {\n                        if (m[i + 1] == '0') {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界を超える\n                            }\n                        } else {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界にいる\n                                dp[i+1][1][k+1]+=dp[i][j][k];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[m.size()-1][0][sumb] + dp[m.size() - 1][1][sumb];\n    };\n\n    const auto ans=count(maxi)-count(mini)+1;\n    cout << ans << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAXN 4000\n#define MOD 998244353\nchar s[MAXN+5];\nint n,num1[MAXN+5],num2[MAXN+5];\nint dp[MAXN+5][MAXN+5];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnum2[i]=s[i]-'0';\n\t\tnum1[i]=2-num2[i]+num1[i-1];\n\t\tnum2[i]+=num2[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tint cnt1=num1[min(n,i)],cnt2=num2[min(n,i)];\n\t\tfor(int j=0;j<=i;j++)\n\t\tif(cnt1>=j&&cnt2>=i-j)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j>0)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n*2][num1[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=2e3;\nstring S;\nll dp[MAX_N*2+1][MAX_N*2+1];\nint rcnt[MAX_N+1],bcnt[MAX_N+1];\nint main(){\n\tcin>>S;\n\tint N=(int)S.size();\n\tREP(i,N){\n\t\tint b=S[i]-'0';\n\t\tbcnt[i+1]=bcnt[i]+b;\n\t\trcnt[i+1]=rcnt[i]+2-b;\n\t}\n\tdp[rcnt[N]][bcnt[N]]=1;\n\tfor(int n=rcnt[N]-1;n>=0;n--){\n\t\tfor(int m=bcnt[N]-1;m>=0;m--){\n\t\t\tint rlb=upper_bound(rcnt,rcnt+N+1,n)-rcnt,blb=upper_bound(bcnt,bcnt+N+1,m)-bcnt;\n\t\t\tif(n+m>rlb){\n\t\t\t\tdp[n][m]+=dp[n+1][m];\n\t\t\t}\n\t\t\tif(n+m>blb){\n\t\t\t\tdp[n][m]+=dp[n][m+1];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)(n); i++)\n#define Loopr(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(extra_i, vector.size()) { cout << vector[extra_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(extra_i, matrix.size()) { Loop(extra_j, matrix[extra_i].size()) { cout << matrix[extra_i][extra_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e-9; }\nbool inrange(int x, int t) { return x >= 0 && x < t; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nnamespace mod_op {\n\n\tconst ll MOD = 998244353;\n\n\tclass modll {\n\tprivate:\n\t\tll val;\n\t\tinline ll modify(ll x) { ll ret = x % MOD; if (ret < 0) ret += MOD; return ret; }\n\t\tinline ll inv(ll x) {\n\t\t\tif (x == 0) return 1 / x;\n\t\t\telse if (x == 1) return 1;\n\t\t\telse return modify(inv(MOD % x) * modify(-MOD / x));\n\t\t}\n\tpublic:\n\t\tmodll(ll init = 0) { val = modify(init); return; }\n\t\tmodll(const modll& another) { val = another.val; return; }\n\t\tinline modll& operator=(const modll &another) { val = another.val; return *this; }\n\t\tinline modll operator+(const modll &x) { return modify(val + x.val); }\n\t\tinline modll operator-(const modll &x) { return modify(val - x.val); }\n\t\tinline modll operator*(const modll &x) { return modify(val * x.val); }\n\t\tinline modll operator/(const modll &x) { return modify(val * inv(x.val)); }\n\t\tinline modll& operator+=(const modll &x) { val = modify(val + x.val); return *this; }\n\t\tinline modll& operator-=(const modll &x) { val = modify(val - x.val); return *this; }\n\t\tinline modll& operator*=(const modll &x) { val = modify(val * x.val); return *this; }\n\t\tinline modll& operator/=(const modll &x) { val = modify(val * inv(x.val)); return *this; }\n\t\tinline bool operator==(const modll &x) { return val == x.val; }\n\t\tinline bool operator!=(const modll &x) { return val != x.val; }\n\t\tfriend inline istream& operator >> (istream &is, modll& x) { is >> x.val; return is; }\n\t\tfriend inline ostream& operator << (ostream &os, const modll& x) { os << x.val; return os; }\n\t\tll get_val() { return val; }\n\t};\n}\n\nusing namespace mod_op;\ntypedef vector<modll> vmodll;\ntypedef vector<vector<modll>> vvmodll;\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.length();\n\tvll r(n * 2), b(n * 2);\n\tLoop(i, n * 2) {\n\t\tif (i > 0) {\n\t\t\tr[i] = r[i - 1];\n\t\t\tb[i] = b[i - 1];\n\t\t}\n\t\tif (i < n) {\n\t\t\tif (s[i] == '0') {\n\t\t\t\tr[i] += 2;\n\t\t\t}\n\t\t\telse if (s[i] == '1') {\n\t\t\t\tr[i]++;\n\t\t\t\tb[i]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[i] += 2;\n\t\t\t}\n\t\t}\n\t}\n\tvvmodll dp(n * 2 + 1, vmodll(n * 2 + 1));\n\tdp[0][0] = 1;\n\tLoop(k, n * 2) {\n\t\tLoopdiag(i, j, n * 2, n * 2, k) {\n\t\t\tif (i + 1 <= r[k]) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t\tif (j + 1 <= b[k]) {\n\t\t\t\tdp[i][j + 1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[r.back()][b.back()] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(Int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(Int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(Int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(Int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(Int n,Int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(Int n,Int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(Int n,Int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(Int n,Int k){\n    Mint res;\n    init(k);\n    for(Int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(Int n,Int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(Int n,Int k){\n    Mint res;\n    for(Int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(Int n){\n    Mint res;\n    init(n);\n    for(Int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    Int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(Int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(Int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nusing M = Mint<Int, 998244353>;\nconst Int MAX = 4040;\nM dp[2][MAX][MAX];\nInt ri[MAX],ra[MAX];\nInt n;\n\n\n\nsigned main(){\n  string s;\n  cin>>s;\n  n=s.size();\n  {\n    vector<Int> cnt(n,0);\n    for(Int i=0;i<n;i++) cnt[i]=2-(s[i]-'0');\n    for(Int i=0;i<=n*2;i++){\n      ra[i]=cnt[0];\n      if(i==n*2) break;\n      for(Int j=1;j<n;j++)\n        if(cnt[j]) cnt[j-1]++,cnt[j]--;\n    }\n  }\n  {\n    vector<Int> cnt(n,0);\n    for(Int i=0;i<n;i++) cnt[i]=s[i]-'0';\n    for(Int i=0;i<=n*2;i++){\n      ri[i]=min(2+i,n*2)-cnt[0];      \n      if(i==n*2) break;\n      for(Int j=1;j<n;j++)\n        if(cnt[j]) cnt[j-1]++,cnt[j]--;\n    }\n  }\n\n  dp[0][0][0]=1;\n  for(Int i=0;i<n*2;i++){\n    for(Int j=0;j<=i;j++){\n      Int x=ra[i]-j;\n      Int y=(min(2+i,n*2)-ri[i])-(i-j);\n      if(x<0||y<0) continue;\n      // red\n      if(x){\n        dp[x==1][i+1][j+1]+=dp[0][i][j];\n        dp[1][i+1][j+1]+=dp[1][i][j];\n      }\n      // blue\n      if(y){\n        dp[0][i+1][j]+=dp[0][i][j];\n        dp[1][i+1][j]+=dp[1][i][j];\n      }\n    }    \n  }\n  //cout<<ra[n*2]<<\" \"<<ri[n*2]<<endl;\n  cout<<dp[1][n*2][ra[n*2]].v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vpii         vector<pair<int,int>>\n#define gph          map<int, vector<int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define FORS(i, n) for(; i < (int)(n); i++)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define printArr(A,n) { cout << #A << \" = \"; FOR(i,n) cout << A[i] << ' '; cout << endl; }\nusing namespace std;\n#define int long long int\n\nconst int mod =998244353;\nvi fac(4000);\nint prev2[2001][2001] = {0};\nlong long inv(long long a, long long b = mod){\n return 1<a ? b - inv(b%a,a)*b/a : 1;\n}\nint choose(int a, int b){\n    if(b > a)return 0;\n    assert(a <= 2000);\n    int ans = fac[a] * inv(fac[b]);\n    ans %= mod;\n    ans *= inv(fac[a- b]);\n    ans %= mod;\n    return ans;\n}\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n\n    string s;cin >> s;\n    int n = s.length();\n    int r = 0, g = 0;\n    prev2[0][0] = 1;\n    FOR(i, n){\n\n        if(s[i] == '0')r += 2;\n        else if(s[i] == '1')r += 1, g += 1;\n        else g += 2;\n\n        //prev2ious length was i\n        for(int reds = 0; reds <= i; reds++){\n            int greens = i - reds;\n            if(g > greens){\n                prev2[greens + 1][reds] += prev2[greens][reds];\n                prev2[greens + 1][reds] %= mod; \n            }\n            if(r > reds){\n                prev2[greens][reds + 1] += prev2[greens][reds];\n                prev2[greens][reds + 1] %= mod; \n            }\n        }\n    }\n    fac[0] =1;\n    FOR1(i, 2000)fac[i] = fac[i-1]*i, fac[i] %= mod;\n    int ans= 0;\n    for(int reds = 0; reds <= n; reds++){\n        int greens = n - reds;\n        ans += prev2[greens][reds] * choose(n, r - reds);\n        ans %= mod;\n    }\n    cout << ans;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nauto no = [](){cout << \"NO\"; exit(0);};\nauto read = [](){int x; cin >> x; return x;};\n#define maxn 4800\nconst LL mod = 998244353;\nLL f[maxn][maxn];\nLL b[maxn], s[maxn];\nchar S[maxn]; \nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> (S + 1);\n\tint N = strlen(S + 1);\n\tfor(int i = 1; i <= N; i += 1){\n\t\tb[i] = S[i] - '0';\n\t\ts[i] = s[i - 1] + b[i]; \n\t}\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= 2 * N; i += 1)\n\t\tfor(int j = 0; j <= 2 * N; j += 1) if(j <= s[min(i, N)] and i - j <= 2 * min(i, N) - s[min(i, N)])\n\t\t\tf[i][j] = ((j ? f[i - 1][j - 1] : 0) + f[i - 1][j]) % mod;\n\tcout << f[2 * N][s[N]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nll mem[4010][4010], rd[4010], bl[4010], n;\nconst ll mod=998244353;\nll dp(int x, int red){\n    if(x==2*n){\n        return 1;\n    }\n    if(mem[x][red]!=-1){\n        return mem[x][red];\n    }\n    ll res;\n    res=(ll)((bl[x]-x+red+1)>0)*dp(x+1, red)+(ll)((rd[x]-red)>0)*dp(x+1, red+1);\n    res%=mod;\n    mem[x][red]=res;\n//    cout<<x<<\" \"<<red<<\" \"<<res<<endl;\n    return res;\n}\nchar s[40010];\nint main(){\n    scanf(\"%s\", s);\n    n=strlen(s);\n//    reverse(s, s+n);\n    for(int i=0; i<2*n; ++i){\n        rd[i+1]=rd[i];\n        bl[i+1]=bl[i];\n        if(i<n){\n            if(s[i]=='0'){\n                rd[i+1]+=2;\n            }\n            else if(s[i]=='1'){\n                rd[i+1]+=1;\n                bl[i+1]+=1;\n            }\n            else{\n                bl[i+1]+=2;\n            }\n        }\n    }\n    memset(mem, -1, sizeof mem);\n    ll ans=dp(1, 0);\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\ntemplate< int mod >\nstruct Combination {\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz) : mfact(sz + 1), rfact(sz + 1) {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nCombination< mod > uku(6001);\nstring S;\nint dp[6001][6001];\n\n\nint rec2(int red, int blue) {\n  return uku.C(red + blue, red);\n}\n\n\nint rec(int idx, int red, int blue) {\n  if(idx == S.size()) return rec2(red, blue);\n  if(~dp[idx][red]) return dp[idx][red];\n  int R = red, B = idx - R;\n  if(idx < S.size()) {\n    if(S[idx] == '0') R += 2;\n    else if(S[idx] == '1') R++, B++;\n    else B += 2;\n  }\n  int ret = 0;\n  if(R > 0) ret += rec(idx + 1, R - 1, B);\n  if(B > 0) ret += rec(idx + 1, R, B - 1);\n  ret %= mod;\n  return dp[idx][red] = ret;\n}\n\nint main() {\n  cin >> S;\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, 0, 0) << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <memory>\n#include <complex>\n#include <numeric>\n#include <cstdio>\n#include <iomanip>\n\n#define REP(i,m,n) for(int i=int(m);i<int(n);i++)\n#define RREP(i,m,n) for(int i=int(n)-1;i>=int(m);--i)\n#define EACH(i,c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n#ifdef LOCAL\n#define DEBUG(s) cout << (s) << endl\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define BR cout << endl;\n#else\n#define DEBUG(s) do{}while(0)\n#define dump(x) do{}while(0)\n#define BR \n#endif\nusing namespace std;\n\nusing UI = unsigned int;\nusing UL = unsigned long;\nusing LL = long long int;\nusing ULL = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VLL = vector<LL>;\nusing VVLL = vector<VLL>;\nusing VS = vector<string>;\nusing PII = pair<int,int>;\nusing VP = vector<PII>;\n\n//struct edge {int from, to, cost;};\n\nconstexpr double EPS = 1e-10;\n//constexpr double PI  = acos(-1.0);\n//constexpr int INF = INT_MAX;\nconstexpr LL MOD = 998244353;\n//inline void modAdd(LL &l, LL &r) {l = (l + r) % MOD;}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\nLL dfs(int n, int blue, VI &ru, VVLL &memo) {\n    if (n <= 0 || blue < 0) return 0;\n    //cout << n << \" \" << blue << \" \" << ru[min((int)ru.size()-1,n)] << \" \" << memo[n][blue] << endl;\n    if (memo[n][blue] > -1) return memo[n][blue];\n    if (n <= ru.size()) {\n        if (blue > ru[n-1]) return memo[n][blue] = 0;\n        if (n - blue > 2 * n - ru[n-1]) return memo[n][blue] = 0;\n    } else {\n        int maxb = ru[ru.size()-1];\n        if (blue > maxb) return memo[n][blue] = 0;\n        if (n - blue > 2 * ru.size() - maxb) return memo[n][blue] = 0;\n    }\n    if (n == 1) {\n        if (ru[0] == 0 && blue == 1) return memo[n][blue] = 0;\n        if (ru[0] == 2 && blue == 0) return memo[n][blue] = 0;\n        return memo[n][blue] = 1;\n    }\n    return memo[n][blue] = (dfs(n-1, blue - 1, ru, memo) + dfs(n-1, blue, ru, memo)) % MOD;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    VI ru(n);\n    ru[0] = s[0] - '0';\n    REP(i,1,n) ru[i] = ru[i-1] + s[i] - '0';\n    VVLL memo(2*n+1, VLL(2*n+1, -1));\n    cout << dfs(2*n,ru[n-1],ru,memo) << endl;\n}\n\nint main() {\n    solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\nstring s;\nvector<int> ve[2];\n\nint dp[4100][4100];\nsigned main(){\n\n//\t  cin.tie(0);\n  //  \t\t\tios::sync_with_stdio(false);\n\n\tcin>>s;\n\tint n=s.length();\n\n\tint ze=0,one=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='0'){\n\t\t\tze+=2;\n\t\t\tve[0].pb(i*2);\n\t\t\tve[0].pb(i*2+1);\n\t\t}\n\t\t\n\t\tif(s[i]=='1'){\n\t\t\tze++;\n\t\t\tone++;\n\t\t\tve[0].pb(i*2);\n\t\t\tve[1].pb(i*2+1);\n\t\t}\n\t\t\n\t\tif(s[i]=='2'){\n\t\t\tone+=2;\n\t\t\tve[1].pb(i*2);\n\t\t\tve[1].pb(i*2+1);\n\t\t}\n\t}\n\t\n\tdp[0][0]=1;\n\tmod=998244353;\n\tfor(int i=0;i<=ze;i++)for(int j=0;j<=one;j++){\n\t\tif(dp[i][j]==0) continue;\n\t\tif(i==ze && j==one) continue;\n\t\t\n\t\tint kaku=i+j+1;\n\t\tif(i<ze){\n\t\t\tint nxt=ve[0][i];\n\t\t\tint lef=nxt-kaku;\n\t\t\tint rig=nxt+kaku;\n\t\t\t\n\t\t\tif(lef<=kaku-1 && kaku-1<=rig){\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tdp[i+1][j]%=mod;\n\t\t\t}\n\t\t}\n\t\tif(j<one){\n\t\t\tint nxt=ve[1][j];\n\t\t\tint lef=nxt-kaku;\n\t\t\tint rig=nxt+kaku;\n\t\t\t\n\t\t\tif(lef<=kaku-1 && kaku-1<=rig){\n\t\t\t\tdp[i][j+1]+=dp[i][j];\n\t\t\t\tdp[i][j+1]%=mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\tcout<<dp[ze][one]<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll dp[4444][4444];\n\nvoid modadd(ll &a, ll b){\n\ta += b;\n\ta %= MOD;\n}\n\nint main(){\n\t\n\tstring str;\n\tcin >> str;\n\tll n = str.size();\n\tll sum = 0;\n\tdp[0][0] = 1;\n\tREP(i,2 * n){\n\t\tif(i < n)sum += 2;\n\t\tREP(j, 2 * n)if(dp[i][j]){\n\t\t\tll now = j;\n\t\t\tif(i < n)now += str[i] - '0';\n\t\t\tif(now)modadd(dp[i+1][now-1], dp[i][j]);\n\t\t\tif(sum - now - i)modadd(dp[i+1][now], dp[i][j]);\n\t\t}\n\t}\n\t//cerr << endl << endl;\n\t//SHOW2d(dp,2*n+1,2*n+1);\n\t\n\tcout << dp[2*n][0] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int32_t M=998244353;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\nconst int N=4020;\nmint dp[N][N];\nint sr[N];\nint sb[N];\nint32_t main(){\n    string s;\n    cin>>s;\n    int n=sz(s);\n    forn(i,n){\n        if(i)sr[i]=sr[i-1],sb[i]=sb[i-1];\n        if(s[i]=='0')sr[i]+=2;\n        if(s[i]=='1')sr[i]+=1,sb[i]+=1;\n        if(s[i]=='2')sb[i]+=2;\n    }\n    for(int i=n;i<n+n;++i)sr[i]=sr[i-1],sb[i]=sb[i-1];\n    dp[0][0]=1;\n    forn(i,n+n){\n        forn(r,i+1){\n            int b=i-r;\n            int sk=sr[i]-r;\n            int ss=sb[i]-b;\n            if(sk>0)dp[i+1][r+1]+=dp[i][r];\n            if(ss>0)dp[i+1][r]+=dp[i][r];\n        }\n    }\n    cout<<dp[n+n][sr[n]]<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <string.h>\n#define INF 1000000000000000LL\n#define SIZE 4005\n#define MOD 998244353\n\nusing namespace std;\ntypedef long long ll;\n\nint ball[SIZE][2];\nll dp[SIZE][SIZE];\n\nint main()\n{\n\tstring s;\n  \tcin >> s;\n  \tint N = s.length();\n  \tball[0][0] = ball[0][1] = 0;\n  \tfor(int i = 0; i < N; i++){\n    \tif(s[i] == '0'){\n        \tball[i][0]+=2;\n        } else if(s[i] == '1'){\n        \tball[i][0]+=1;\n          \tball[i][1]+=1;\n        } else {\n        \tball[i][1]+=2;\n        }\n      \tif(i > 0){\n        \tball[i][0] += ball[i-1][0];\n          \tball[i][1] += ball[i-1][1];\n        }\n    }\n  \tdp[0][0] = 1;\n  \tint red = ball[N-1][0];\n  \tint blue = ball[N-1][1];\n  \tfor(int i = 0; i <= red;i++){\n      \tfor(int j = 0; j <= blue; j++){\n          \tif(dp[i][j] == 0) continue;\n            int num = min(i+j, N-1);\n            int r = ball[num][0] - i;\n            int b = ball[num][1] - j;\n      \t\tif(r > 0){\n            \tdp[i+1][j] += dp[i][j];\n              \tif(dp[i+1][j] >= MOD) dp[i+1][j]-=MOD;\n            }\n      \t\tif(b > 0){\n            \tdp[i][j+1] += dp[i][j];\n              \tif(dp[i][j+1] >= MOD) dp[i][j+1]-=MOD;            \n            }\n        }\n    }\n  \tcout << dp[red][blue] << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define mod 998244353\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint r[8010];\nint b[8010];\nint ar[8010];\nint ab[8010];\nll dp[4010][4010];\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    \n    rep(i,n){\n        if(s[i]=='0'){\n            ar[i] = 2;\n        }else if(s[i]=='1'){\n            ar[i] = 1;\n            ab[i] = 1;\n        }else{\n            ab[i] = 2;\n        }\n    }\n    if(s[0]=='0'){\n        r[0] = 1;\n    }else if(s[0]=='1'){\n        r[0] = 1;\n        b[0] = 1;\n    }else{\n        b[0] = 1;\n    }\n    for(int i=1;i<=8005;i++){\n        r[i] = r[i-1];\n        b[i] = b[i-1];\n        if(ar[i]>=1){\n            r[i]++;\n        }\n        if(ar[i-1]>=2){\n            r[i]++;\n        }\n        if(ab[i]>=1){\n            b[i]++;\n        }\n        if(ab[i-1]>=2){\n            b[i]++;\n        }\n        // if(i<=4){\n        //     cerr << r[i] << \" \" << b[i] << endl;\n        // }\n    }\n    dp[0][0] = 1;\n    for(int i=0;i<=2*n;i++){\n        for(int j=0;j<=2*n;j++){\n            if(i==0&&j==0)continue;\n            if(r[i+j-1]<i||b[i+j-1]<j)continue;\n            //cerr << i << \" \"<< j << endl;\n            if(i!=0){\n                dp[i][j] += dp[i-1][j];\n                dp[i][j] %= mod;\n            }\n            if(j!=0){\n                dp[i][j] += dp[i][j-1];\n                dp[i][j] %= mod;\n            }\n        }\n    }\n    //cerr << r[4010] << \" \" << b[4010] << endl;\n    cout << dp[r[4010]][b[4010]] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n#define endl '\\n'\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\n\n\nint T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    string s;\n    while(cin >> s){\n        n = s.size();\n        vi mxr(n * 2 + 1), mxb(n * 2 + 1);\n        REP(i, n) {\n            if (s[i] == '0') mxr[i] = 2;\n            if (s[i] == '1') mxr[i] = 1;\n            if (s[i] == '1') mxb[i] = 1;\n            if (s[i] == '2') mxb[i] = 2;\n        }\n        REP(i, 2 * n) {\n            mxr[i + 1] += mxr[i];\n            mxb[i + 1] += mxb[i];\n        }\n        vector<ll> dp(n * 2 + 1);\n        dp[0] = 1;\n        REP(i, n * 2) {\n            vector<ll> nxt(n * 2 + 1);\n            REP(r, i + 1) {\n                int b = i - r;\n                if (r <= mxr[i] && b + 1 <= mxb[i]) {\n                    (nxt[r] += dp[r]) %= MOD;\n                }\n                if (r + 1 <= mxr[i] && b <= mxb[i]) {\n                    (nxt[r + 1] += dp[r]) %= MOD;\n                }\n            }\n            swap(dp, nxt);\n        }\n        cout << accumulate(ALL(dp), 0ll) % MOD << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define llong long long\nusing namespace std;\n\nconst int N = 4000;\nconst int P = 998244353;\nllong dp[N+3][N+3];\nchar str[N+3];\nint sa[N+3],sb[N+3];\nint n;\n\nint main()\n{\n\tscanf(\"%s\",str+1); n = strlen(str+1);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tint x = str[i]-'0',y = 2-x;\n\t\tsa[i] = sa[i-1]+x; sb[i] = sb[i-1]+y;\n\t}\n\tfor(int i=n+1; i<=n+n; i++) sa[i] = sa[i-1],sb[i] = sb[i-1];\n\tdp[0][0] = 1ll;\n\tfor(int i=1; i<=n+n; i++)\n\t{\n\t\tfor(int j=max(0,i-sb[i]); j<=min(i,sa[i]); j++)\n\t\t{\n\t\t\tdp[i][j] = 0ll;\n\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\tif(j>0) dp[i][j] += dp[i-1][j-1];\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\t\tdp[i][j] %= P;\n\t\t}\n\t}\n\tllong ans = 0ll;\n\tfor(int i=0; i<=n+n; i++) ans = (ans+dp[n+n][i])%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tint n = s.size();\n\tconstexpr ll mod = 998244353ll;\n\tvvl dp(2 * n + 1, vl(2 * n + 1, 0));\n\tvi cnt(n + 1, 0);\n\tREP(i, n) {\n\t\tcnt[i + 1] = cnt[i] + s[i] - '0';\n\t}\n\tdp[0][0] = 1;\n\tREP(i, dp.size() - 1) {\n\t\tREP(j, dp[i].size()) {\n\t\t\tif (j + 1 < dp[i].size() && cnt[min(ll(n), i + 1)] >= j + 1) {\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tdp[i + 1][j + 1] %= mod;\n\t\t\t}\n\t\t\tif (2 * (min(ll(n), i + 1)) - cnt[min(ll(n), i + 1)] >= i + 1 - j) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tREP(i, dp.back().size()) {\n\t\tans += dp.back()[i];\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=4010 ;\nconst LL MOD = 998244353;\nchar s[N];\nLL f[N][N];\nint pre[N],n;\n\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tscanf(\"%s\", s+1); n=strlen(s+1);\n\tpre[0] =0;\n\tfor (int i=1; i<=n; ++i) pre[i]=pre[i-1] + s[i]-'0';\n\tfor (int i=n+1; i<=n+n; ++i) pre[i]=pre[i-1];\n\tmemset(f, 0 ,sizeof(f));\n\tf[0][0] =1;\n\tfor (int i=1; i<=2*n; ++i){\n\t\tint avail=min(n,i)*2,preR,preB;\n\t\tfor (int j=0; j<= i; ++j){\n\t\t\tpreR = j;preB = i-j;\n\t\t\tif ( preR > avail-pre[i] || preB>pre[i]) continue;\n\t\t\tf[i][j] =f[i-1][j];\n\t\t\tif ( j) f[i][j]=(f[i][j]+f[i-1][j-1])%MOD;\n\t\t\t#ifdef che\n//\t\t\tdebug(\"f[%d][%d] = %lld\\n\", i,j,f[i][j]);\n\t\t\t#endif\t\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n+n][n+n-pre[n]]);\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ld infl = 1e100;\nconst ll mod = 998244353;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nll dp[4010][4010];\nint blue[2010];\nint red[2010];\n\nint main() {\n\tstring s;\tcin >> s;\n\tint n = s.size();\n\tblue[0] = s[0] - '0';\n\tred[0] = 2 - blue[0];\n\tsrep(i, 1, n) {\n\t\tblue[i] = blue[i - 1] + s[i] - '0';\n\t\tred[i] = 2 * (i + 1) - blue[i];\n\t}\n\tdp[0][0] = 1;\n\tint m = 2 * n;\n\trep(i, m) {\n\t\tREP(j, blue[n - 1]) {\n\t\t\tdp[i][j] %= mod;\n\t\t\tif (!dp[i][j])\tcontinue;\n\t\t\t// red\n\t\t\tif (red[min(i, n - 1)] >= i + 1 - j) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t\t// blue\n\t\t\tif (blue[min(i, n - 1)] >= j + 1) {\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][blue[n - 1]] % mod<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod = (int)(998244353)>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt res(1), mul(x);\n    while (n) {\n      if (n & 1) res *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return res;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\n\nstruct Combination {\n  vector<ModInt<>> _fact, _rfact, _inv;\n  Combination(long long nsize = 5000000)\n      : _fact(nsize + 1), _rfact(nsize + 1), _inv(nsize + 1) {\n    _fact[0] = _rfact[nsize] = _inv[0] = 1;\n    for (int i = 1; i <= nsize; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[nsize] /= _fact[nsize];\n    for (int i = nsize - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for (int i = 1; i <= nsize; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n  inline ModInt<> fact(int k) const { return _fact[k]; }\n\n  inline ModInt<> rfact(int k) const { return _rfact[k]; }\n\n  inline ModInt<> inv(int k) const { return _inv[k]; }\n\n  ModInt<> P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  ModInt<> C(int p, int q) const {\n    if (q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  // n types,choose r\n  ModInt<> H(int n, int r) const {\n    if (n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\nint n;\nstring s;\nvector<int> cnt[2];\nvector<vector<ModInt<>>> dp;\nCombination com;\n\nModInt<> solve();\n\nint main() {\n  cin >> s;\n  n = s.size();\n  cout << solve() << endl;\n  return 0;\n}\n\nModInt<> solve() {\n  cnt[0].assign(n + 1, 0);\n  cnt[1].assign(n + 1, 0);\n  for (int i = 0; i < n; ++i) {\n    cnt[0][i + 1] = cnt[0][i] + (s[i] <= '1') + (s[i] == '0');\n    cnt[1][i + 1] = cnt[1][i] + (s[i] >= '1') + (s[i] == '2');\n  }\n  dp.assign(n + 1, vector<ModInt<>>(n + 1, 0));\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j <= i + 1; ++j) {\n      // use\n      if (j != 0 && cnt[0][i + 1] >= j) dp[i + 1][j] += dp[i][j - 1];\n      // not use\n      if (j != i + 1 && cnt[1][i + 1] >= (i + 1 - j)) dp[i + 1][j] += dp[i][j];\n    }\n  ModInt<> res;\n  for (int i = 0; i <= min(n, cnt[0][n]); ++i)\n    res += dp[n][i] * com.C(n, cnt[0][n] - i);\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD = 998244353;\nconst int INF = LLONG_MAX;\n\nsigned main(){\n\n    string s; cin >> s;\n    int n = (int)s.size();\n    vector<int> a(2 * n, 0);   \n    vector<int> b(2 * n, 0);   \n    for(int i = 0; i < n; i++){\n        if(s[i] == '2') a[i] += 2;\n        else if(s[i] == '1'){\n            a[i]++;\n            b[i]++;\n        }else b[i] += 2;\n    }\n\n    for(int i = 1; i < 2 * n; i++){\n        a[i] += a[i - 1];\n        b[i] += b[i - 1];\n    }\n\n    int sumR = a[2 * n - 1];\n    int sumB = b[2 * n - 1];\n\n    // dp[i][j] := i 番目まで見て、r を j 個使った時の通り数\n    vector<vector<int> > dp(2 * n + 1, vector<int> (sumR + 1, 0));\n    dp[0][0] = 1LL;\n    for(int i = 0; i < 2 * n; i++){\n        for(int j = 0; j <= sumR; j++){\n            if(dp[i][j] == 0) continue;\n            \n            //r を使う\n            if(a[i] - j > 0){\n                dp[i + 1][j + 1] += dp[i][j];\n                dp[i + 1][j + 1] %= MOD;\n            }\n\n            //b を使う\n            if(b[i] - i + j > 0){\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= MOD;\n            }\n        }\n    }\n\n    cout << dp[2 * n][sumR] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\n\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nll dp[4001][4001];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tvl r(2*n+1),b(2*n+1);\n\trep(i,n){\n\t\tr[i+1]=r[i]+2-(s[i]-'0');\n\t\tb[i+1]=b[i]+(s[i]-'0');\n\t}\n\trep(i,n){\n\t\tr[n+i+1]=r[n+i];\n\t\tb[n+i+1]=b[n+i];\n\t}\n\tdp[0][0]=1;\n\trep(i,2*n){\n\t\trep(j,i+1){\n\t\t\tint k=i-j;\n\t\t\t//puta(j,k);\n\t\t\tif(j<b[i+1]){\n\t\t\t\tdp[j+1][k]+=dp[j][k];\n\t\t\t\tdp[j+1][k]%=998244353;\n\t\t\t}\n\t\t\tif(k<r[i+1]){\n\t\t\t\tdp[j][k+1]+=dp[j][k];\n\t\t\t\tdp[j][k+1]%=998244353;\n\t\t\t}\n\n\t\t}\n\t}\n\tcout<<dp[b[n]][r[n]]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nLL mod = 998244353;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string S;\n  cin >> S;\n\n  //r_i\n  vector<LL> dp(4001, 0);\n  dp[0] = 1;\n\n  LL r = 0;\n  LL b = 0;\n  REP(i, S.size())\n  {\n    LL num = S[i] - '0';\n    r += 2 - num;\n    b += num;\n\n    vector<LL> newdp(4001, 0);\n    REP(j,i+1){\n      if(j==r){\n        newdp[j] += dp[j];\n      }\n      else if (i - j == b)\n      {\n        newdp[j+1] += dp[j];\n      }else{\n        newdp[j] += dp[j];\n        newdp[j+1] += dp[j];\n      }\n      newdp[j] %= mod;\n      newdp[j+1] %= mod;\n    }\n    REP(i,4001){\n      dp[i] = newdp[i]%mod;\n    }\n  }\n\n  REP(i, S.size())\n  {\n    vector<LL> newdp(4001, 0);\n    REP(j,i+1+S.size()){\n      if(j==r){\n        newdp[j] += dp[j];\n      }\n      else if (i+S.size() - j == b)\n      {\n        newdp[j+1] += dp[j];\n      }else{\n        newdp[j] += dp[j];\n        newdp[j+1] += dp[j];\n      }\n      newdp[j] %= mod;\n      newdp[j+1] %= mod;\n    }\n    REP(i,4001){\n      dp[i] = newdp[i]%mod;\n    }\n  }\n\n  LL sum = 0;\n\n  REP(i,4001){\n    sum += dp[i];\n    sum %= mod;\n  }\n\n  cout << sum%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\n//const ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a) {\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\tfor (int i = 0; i<s.first; i++)for (int j; j< s.second; j++)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T>\nstd::pair<matrix<T>, vector<int>> LU_decomposition(matrix<T> a) {\n\tif (a.size().first != a.size().second)throw runtime_error(\"matrix error\");\n\tstd::vector<int> pi(a.size().first);\n\tstd::iota(ALL(pi), 0);\n\tvalarray<T> tmp(a.size().first);\n\tfor (int i = 0; i < a.size().first; i++) {\n\t\t//int pivot = i;\n\t\t//T max = abs(a[i][i]);\n\t\t//for (int j = i + 1; j < a.size().first; j++) {\n\t\t//\tif (max < abs(a[j][i])) {\n\t\t//\t\tmax = abs(a[j][i]);\n\t\t//\t\tpivot = j;\n\t\t//\t}\n\t\t//}\n\t\t//std::swap(i, pivot);\n\t\t//pi.push_back(pivot);\n\t\tstd::slice slice(i + 1, a.size().first - i - 1, 1);\n\t\tfor (int j = i + 1; j < a.size().first; j++) {\n\t\t\ttmp[slice] = a[i][slice];\n\t\t\ttmp *= a[j][i] / a[i][i];\n\t\t\ta[j][slice] -= tmp[slice];\n\t\t\ta[j][i] = a[j][i] / a[i][i];\n\t\t}\n\t}\n\treturn std::make_pair(std::move(a), std::move(pi));\n}\ntemplate<class T>\nmatrix<T>LU_solve(pair<matrix<T>, std::vector<int>> a, matrix<T> b) {\n\tauto pi = std::move(a.second);\n\tauto A = std::move(a.first);\n\tif (A.size().first != A.size().second || A.size().first != b.size().first)throw runtime_error(\"matrix error\");\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tstd::swap(b[i], b[pi[i]]);\n\t}\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tfor (int j = 0; j < i; j++)b[i] -= A[i][j] * b[j];\n\t}\n\tfor (int i = A.size().first - 1; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < A.size().first; j++)b[i] -= A[i][j] * b[j];\n\t\tb[i] /= A[i][i];\n\t}\n\treturn b;\n}\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tvoid propagate(int a, int b, int k, int l, int r, int p) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].second += p;\n\t\t\t(obj[k].first *= pow(2, p, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (obj[k].second) {\n\t\t\t\t(obj[k * 2 + 1].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\t(obj[k * 2 + 2].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\tobj[k * 2 + 1].second += obj[k].second;\n\t\t\t\tobj[k * 2 + 2].second += obj[k].second;\n\t\t\t}\n\t\t\tpropagate(a, b, k * 2 + 1, l, (l + r) / 2, p), propagate(a, b, k * 2 + 2, (l + r) / 2, r, p);\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {//[a,b)\n\t\t//propagate(a, b, 0);\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid propagate(int a, int b, int p = 1) {//[a,b)\n\t\treturn propagate(a, b, 0, 0, offset + 1, p);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, const T &a) {\n\t\t//propagate(k, k + 1, 0);\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tcap -= max_flow(from, to, cap) - prev;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\nll extgcd(ll a, ll b, ll&x, ll&y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nll mod_inv(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn(m + x % m) % m;\n}\npll linear_congruence(const vector<ll>& A, const vll& B, const vll&M) {\n\tll x = 0, m = 1;\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n\t\tif (b%d != 0)return make_pair(0, -1);\n\t\tll t = b / d * mod_inv(a / d, M[i] / d) % (M[i] / d);\n\t\t//if (x + m * t < 0)return pll(x%m, m);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//円の接線?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//面積??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nstruct unionfind_ {\n\tvector<int> par, rank, size_,a;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind_(int n) :par(n), rank(n), size_(n, 1),a(n) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tcmin(a[x],a[y]);\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nint main() {\n\tstring s;\n\tcin >> s;\n\tll sum = 0;\n\trep(i, s.size())sum += s[i] - '0';\n\tvector<vi> c(sum+1, vi(s.size() * 2 - sum+1));\n\tc[0][0] = 1;\n\tvi a(s.size()),b(a);\n\trep(i, s.size())a[i] = s[i] - '0', b[i] = 2 - a[i];\n\trep1(i, s.size() - 1)a[i] += a[i - 1], b[i] += b[i - 1];\n\trep(i, sum+1) {\n\t\trep(j, s.size() * 2 - sum+1) {\n\t\t\tc[i][j] += (i!=0&&a[min(i + j - 1ull, s.size() - 1ull)] >= i ? c[i - 1][j] : 0) + (j!=0&&b[min(i + j - 1ull, s.size() - 1ull)] >= j ? c[i][j - 1] : 0);\n\t\t\tc[i][j] %= 998244353;\n\t\t}\n\t}\n\tcout << c[sum][s.size() * 2 - sum] << endl;\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\nstruct node {\nmap<char,unique_ptr<node>> next;\nnode* fail = nullptr, *match_list = nullptr;\nstd::vector<int> match;\n}root;\nint pattern;\n//template<class string>\nAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\nroot.fail = &root;\nfor (int i = 0; i < vs.size(); i++) {\nnode* now = &root;\nfor (auto c : vs[i]) {\nif (!now->next[c])now->next[c]=make_unique<node>();\nnow = now->next[c].get();\n}\nnow->match.push_back(i);\n}\nstd::queue<node*> que;\nque.push(&root);\nwhile (!que.empty()) {\nauto now = que.front();\nque.pop();\nfor (auto &next : now->next) {\nif (!next.second)continue;\nif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\nelse next.second->fail = now->fail->fail;\n//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\nif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\nelse next.second->match_list = next.second->fail;\nque.push(next.second.get());\n}\n}\n}\nauto match_n(string str) {\nvector<int> num(pattern);\n\n}\nauto match_list(string str) {\nvector<pair<int, int>> list;\nauto now = &root;\nfor (int i = 0; i < str.size(); i++) {\nif (now->next.count(str[i]))now = now->next[str[i]].get();\nelse now = now->fail;\nauto match = now->match_list;\ndo {\nmatch\n}\n}\n}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "/**/\n/*\n * \tMeet me on the battlefield\n*/\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#ifndef rd\n#define endl '\\n'\n#endif\n#define deb cout<<\"Line: \"<<__LINE__<<\" plz \"\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\n#define pii pair<int,int>\n#define sz(x) ((int)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define all(con) con.begin(),con.end()\nconst int inf=1e9;\nconst int mod=998244353;\n#define dpr(x) cout<<#x<<\": \"<<x<<endl\ntypedef vector<int> vi;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nint dp[4005][4005];\nint n;\nint a[4005][2];\nstring s;\nvoid solve()\n{\n\tcin>>s;\n\tint n=s.length();\n\tfor(int i=1; i<=n; i++) {\n\t\ta[i][0]=s[i-1]-'0'+a[i-1][0];\n\t\ta[i][1]='2'-s[i-1]+a[i-1][1];\n\t}\n\tfor(int i=n+1; i<=2*n; i++) {\n\t\ta[i][0]+=a[i-1][0];\n\t\ta[i][1]+=a[i-1][1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1; i<=2*n; i++) {\n\t\tfor(int j=0; j<=i; j++) {\n\t\t\tif(j>0&&a[i][0]>=j) {\n\t\t\t\tdp[i][j]+=dp[i-1][j-1];\n\t\t\t}\n\t\t\tif(a[i][1]>=i-j) {\n\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t}\n\t\t\tdp[i][j]%=mod;\n\t\t}\n\t}\n\tll ans=0;\n\t// for(int i=0; i<=2*n; i++)\n\t// \tans+=dp[2*n][i];\n\t// ans%=mod;\n\tcout<<dp[2*n][a[n][0]]<<endl;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::steady_clock::now().time_since_epoch().count());\n\tauto clk=clock();\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcout<<endl<<endl<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n/**/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\nint n,c[2005][2005],f[2005][2005],a[2005],b[2005];\nll ans;\nchar s[100005];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tc[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) \n\t\t{\n\t\t\tc[i][j]=c[i-1][j-1]+c[i-1][j];\n\t\t\tif(c[i][j]>=mod) c[i][j]-=mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=a[i-1],b[i]=b[i-1];\n\t\tif(s[i]=='0') a[i]+=2;\n\t\telse if(s[i]=='1') a[i]++,b[i]++;\n\t\telse b[i]+=2;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=min(i,a[i]);j++)\n\t\t{\n\t\t\tif(i-j>b[i]) continue;\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j>0) f[i][j]+=f[i-1][j-1];\n\t\t\tif(f[i][j]>=mod) f[i][j]-=mod;\n\t\t\t//printf(\"f(%d,%d)=%d\\n\",i,j,f[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t\tif(f[n][i]) ans=(ans+1ll*f[n][i]*c[n][a[n]-i])%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n    // 二次元ベクターの基本\n    /*\n    vector<vector<int>> dp; // 宣言\n    dp.resize(n); // 1次元めの要素数決定\n    dp[i].push_back(int); // プッシュバック\n    rep(i,n){\n        sort(dp[i].begin(),dp[i].end()); // 二次元めで昇順ソート\n    }\n    */\n\n    // 整数スキャン（複数）\n    /*\n    int x;\n    scanf(\"%d\",&x);\n    int y;\n    scanf(\"%d\",&y);\n    int z;\n    scanf(\"%d\",&z);\n\n    // n個の整数のスキャン\n    /*\n    ll a[n] = {};\n    rep(i,n){\n        scanf(\"%lld\",&a[i]);\n    }\n    */\n\n    // 文字列スキャン\n    /*\n    string s;\n    cin >> s;\n    */\n\n    // n個の文字列スキャン\n    /*\n    vector<string> slist;\n    rep(i,n){\n        string s;\n        cin >> s;\n        slist.push_back(s);\n    }\n    */\n\nint main() {\n    string s;\n    cin >> s;\n\n    int si = s.size();\n    int snu[si];\n    int t[si*2];\n    int snut[si];\n    int tt[si*2];\n\n    ll two[4100] ={};\n\n    two[0] = 1;\n    srep(i,1,4050){\n        two[i]=two[i-1]*2;\n        if(two[i]>998244353){\n            two[i] %= 998244353;\n        }\n    }\n\n    rep(i,si){\n        if(s[i]=='0'){\n            snu[i]=0;\n            snut[i]=0;\n        }\n        if(s[i]=='1'){\n            snu[i]=1;\n            snut[i]=1;\n        }\n        if(s[i]=='2'){\n            snu[i]=2;\n            snut[i]=2;\n        }\n    }\n\n    // 赤なら0,青なら1\n    // 辞書順最初\n    rep(i,si*2){\n        if(i%2==0){\n            if(snu[0]==2){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)]==0){\n                snu[si-1-(i/2)]=3;\n            }else{\n                snu[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snu[0]==2||snu[0]==4){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)-1]==0&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 1;\n            }else if(snu[si-1-(i/2)-1]==1&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 2;\n            }else if(snu[si-1-(i/2)-1]==2&&snu[si-1-(i/2)]==3){\n                snu[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n\n        rep(j,i+1){\n            cout << t[j];\n        }\n        cout << endl;\n        */\n    }\n    int cm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cm[i]=t[i];\n        }else{\n            cm[i]=t[i]+cm[i-1];\n        }\n        \n    }\n    //cout << endl;\n\n    // 辞書順最後\n    rep(i,si*2){\n        if(i%2==0){\n            if(snut[0]==0){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)]!=2){\n                snut[si-1-(i/2)]=3;\n            }else{\n                snut[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snut[0]==0||snut[0]==3){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)-1]==0&&snut[si-1-(i/2)]==4){\n                snut[si-1-(i/2)-1] = 1;\n            }else if(snut[si-1-(i/2)-1]==1&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 0;\n            }else if(snut[si-1-(i/2)-1]==2&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n        rep(j,i+1){\n            cout << tt[j];\n        }\n        cout << endl;\n        */\n    }\n    int cmm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cmm[i]=tt[i];\n        }else{\n            cmm[i]=tt[i]+cmm[i-1];\n        }\n        //cout << tt[i];\n    }\n\n    ll dp[si*2][si*2+1];\n    rep(i,si*2+1){\n        dp[0][i]=0;\n    }\n    if(cm[0]==0)dp[0][0]=1;\n    dp[0][1]=cmm[0];\n    srep(i,1,si*2){\n        rep(j,si*2+1){\n            if(j<cm[i]){\n                dp[i][j]=0;\n            }else if(j>cmm[i]){\n                dp[i][j]=0;\n            }else{\n                if(cm[i]<=j&&j<=cmm[i]){\n                    if(j==0){\n                        dp[i][j]=dp[i-1][j];\n                    }else{\n                        dp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n                    }\n                    \n                    if(dp[i][j]>998244353){\n                        dp[i][j] %= 998244353;\n                    }\n                }\n            }\n        }\n    }\n    \n    ll ans = 0;\n    rep(i,si*2+1){\n        ans+=dp[si*2-1][i];\n        if(ans>998244353){\n            ans %= 998244353;\n        }\n    }\n\n\n    /*\n    rep(i,si*2){\n        cout << t[i];\n    }\n    cout << endl;\n    rep(i,si*2){\n        cout << tt[i];\n    }\n    cout << endl;\n    cout << cm[si*2-1] << ' ' << cmm[si*2-1] << endl; \n    */\n    cout << ans << endl;\n    return 0;\n}\n \n \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 1000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) *b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\n\n///////////////////////////\n\nint main() {\n\n\tstring S;\n\tcin >> S;\n\n\tll N = S.size();\n\n\tvector<ll> a(N + 1);\n\trepn(i, N) a[i] = S[i - 1] - '0';\n\n\tvector<vector<ll>> dp(2*N + 1, vector<ll>(2 * N + 1, 0));\n\n\tdp[0][0] = 1;\n\n\tll b = 0;\n\n\trepn(i, N) {\n\t\tb += a[i];\n\n\t\tfor (ll j = max(b - i,0); j <= b; j++) {\n\t\t\tif (j > 0) { dp[i][j] += dp[i - 1][j - 1]; }\n\t\t\tdp[i][j] += dp[i - 1][j];\n\n\n\t\t\tdp[i][j] %= MOD;\n\n\t\t\t//cout << i << j << dp[i][j] << endl;\n\t\t}\n\t}\n\n\tfor (ll i = N + 1; i <= 2*N; i++) {\n\t\tfor(ll j=max(b+i-2*N,0); j<=b; j++) {\n\t\t\tif (j > 0) { dp[i][j] += dp[i - 1][j - 1]; }\n\t\t\tdp[i][j] += dp[i - 1][j];\n\n\n\t\t\tdp[i][j] %= MOD;\n\n\t\t\t//cout << i << j << dp[i][j] << endl;\n\t\t}\n\t}\n\n\tcout << dp[2 * N][b];\n\t\n\t\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt dp[2160][2160];\nInt res;\nInt n;\nstring str;\nInt fact[1080000];\nInt revfact[1080000];\nInt rev[1080000];\n\nvoid init(){\n  Int m = MOD;\n  fact[0] = 1;\n  revfact[0] = 1;\n  rev[0] = 0;\n  rev[1] = 1;\n  for(int i = 1;i < 1080000;i++){\n    fact[i] = fact[i-1] * i % m;\n    if(i>1)rev[i] = MOD / i * (MOD-rev[MOD % i]) % MOD;\n    revfact[i] = revfact[i-1] * rev[i] % MOD;\n  }\n}\n\nclass Initter{\npublic:\n  Initter(){\n    init();\n  }\n};\nInitter initter;\nInt nCk(Int n, Int k){\n  if(n < k)return 0;\n  if(k < 0)return 0;\n  return fact[n] * revfact[n-k] % MOD * revfact[k] % MOD;\n}\n\nInt cntr, cntb;\n\nint main(){\n  dp[0][0] = 1;\n  cin >> str;\n  n= str.size();\n  for(int i = 1;i <= n;i++){\n    char s = str[i-1];\n    s -= '0';\n    cntr += 2 - s;\n    cntb += s;\n    for(int j = 0;j <= n;j++){\n      if(cntr - j > 0){\n\tdp[i][j+1] += dp[i-1][j];\n\tdp[i][j+1]%=MOD;\n      }\n      if(cntb - (i-j-1) > 0){\n\tdp[i][j] += dp[i-1][j];\n\tdp[i][j] %= MOD;\n      }\n    }\n  }\n  for(int j = 0;j <= n;j++){\n    //    cout << dp[n][j] << endl;\n    res += dp[n][j] *nCk(n, cntr-j) %MOD;\n    res %= MOD;\n  }cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int p=998244353;\nint n,f[10005][10005],sumr[5005];\nchar s[5005];\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)sumr[i]=sumr[i-1]+'2'-s[i];\n\tf[0][0]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t\tfor(int j=max(0,i-2*min(i,n)+sumr[min(i,n)]);j<=sumr[min(i,n)];j++)\n\t\t\tf[i][j]=(f[i-1][j-1]+f[i-1][j])%p;\n\tint ans=0;\n\tfor(int i=0;i<=2*n;i++)ans=(ans+f[2*n][i])%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(4001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(2 * N + 1));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - b;\n                }\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    dp[i + 1][j + 1] += dp[i][j];\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    dp[i + 1][j] += dp[i][j];\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i];\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = (left * right) % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\nconst int M=998244353;\nchar s[3333]; \nbool b[4444][4444]；\nint f[4444][4444];\nint sub[5][2]={{'3',0},{'4','3'},{0,'4'}};\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tint R=0,B=0;\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='0')R+=2;\n\t\tif(s[i]=='1')++R,++B;\n\t\tif(s[i]=='2')B+=2;\n\t}\n\tint x=0,y=0;\n\twhile(1)\n\t{\n\t\tint pl=0;\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\tif(s[i]=='0'||s[i]=='2'){pl=i;break;}\n\t\tif(pl==0)break;\n\t\tif(s[pl]=='0')\n\t\t{\n\t\t\tb[x][y+pl]=1;\n\t\t\ts[1]=sub[s[1]-'0'][0];\n\t\t\t++x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[x+pl][y]=1;\n\t\t\ts[1]=sub[s[1]-'0'][1];\n\t\t\t++y;\n\t\t}\n\t\tfor(register int i=1;i<n;++i)\n\t\t{\n\t\t\tif(s[i]=='3')\n\t\t\t{\n\t\t\t\tif(s[i+1]!='0'&&s[i+1]!='3')s[i]='1',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t\t\telse s[i]='0',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(s[i+1]!='2'&&s[i+1]!='4')s[i]='1',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t\t\telse s[i]='2',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t}\n\t\t}\n\t\tif(!s[n])--n;\n\t}\n\tf[0][0]=1;\n\tfor(register int i=0;i<=R;++i)\n\t\tfor(register int j=0;j<=B;++j)\n\t\t\tif(b[i][j]==0)\n\t\t\t{\n\t\t\t\tif(i)f[i][j]=(f[i][j]+f[i-1][j])%M;\n\t\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1])%M;\n\t\t\t}\n\tprintf(\"%d\\n\",f[R][B]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst lint mod = 998244353;\nconst lint INF = mod*mod;\nconst int MAX = 100010;\n\nlint dp[4010][4010];\n\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    int R[n+1], B[n+1];\n    int curr=0, curb=0;\n    rep(i, n){\n        if(s[i]=='0') {\n            R[curr++]=i; R[curr++]=i;\n        }\n        else if(s[i]=='1'){\n            R[curr++]=i; B[curb++]=i;\n        }\n        else{\n            B[curb++]=i; B[curb++]=i;\n        }\n    }\n\n    rep(i, curr+1)rep(j, curb+1) dp[i][j]=0;\n    dp[0][0]=1;\n    rep(i, curr+1)rep(j, curb+1)if(dp[i][j]){\n        if(i<curr && R[i]<=i+j) (dp[i+1][j]+=dp[i][j])%=mod;\n        if(j<curb && B[j]<=i+j) (dp[i][j+1]+=dp[i][j])%=mod;\n    }\n    printf(\"%lld\\n\", dp[curr][curb]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mem(a,i) memset(a,i,sizeof(a))\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define per(i,a,b) for(int i=a;i>=b;--i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair<int,int> pii;\n\nconst ll mod=998244353ll;\nconst int maxn=2050;\nchar s[maxn];\nint n;\nll dp[maxn*2][maxn*2];\nll pre[maxn];\n\nint main() {\n    while(~scanf(\"%s\",s+1)) {\n        n=strlen(s+1);\n        mem(dp,0);\n        dp[0][0]=1;\n        pre[0]=0;\n        rep(i,1,n) {\n            ll temp=0;\n            if(s[i]=='0') temp=2;\n            else if(s[i]=='1') temp=1;\n            pre[i]=pre[i-1]+temp;\n        }\n        rep(i,1,2*n) {\n            rep(j,0,2*n) {\n                if(i<=n) {\n                    if((2*i-pre[i])-(i-1-j)>0&&i-1>=j) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n                    }\n                    if(pre[i]-(j-1)>0&&j>0) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                    }\n                }\n                else {\n                    if((2*n-pre[n])-(i-1-j)>0&&i-1>=j) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n                    }\n                    if(pre[n]-(j-1)>0&&j>0) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                    }\n                }\n                // printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n            }\n        }\n        printf(\"%lld\\n\",dp[2*n][pre[n]]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<time.h>\n#include<cassert>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define EPS (1e-13)\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rep(i,n) for(int (i) = 0 ; (i) < (n) ; (i)++)\n#define mkp make_pair\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\nconst int Mod = 1e9 + 7;\nconst int mod = 998244353;\nconst ll Inf = 3 * 1e18;\nconst int inf = 15 * 1e8;\nll read() {\n\tll u, k = scanf(\"%lld\", &u);\n\treturn u;\n}\nll gcd(ll i, ll j) {\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcd(j % i, i);\n}\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % p;\n\t\tx = x * x % p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll bcount(ll x) {\n\tint sum = 0;\n\tfor (int i = 0; i < 20; i++)\n\t\tif ((1ll << i) & x) sum++;\n\treturn sum;\n}\n/*const int fn_ = 2000000;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll mod = Mod) {\n\tif (!fact_[0]) {\n\t\tfact_[0] = 1; comp_[0] = 1;\n\t\tfor (int i = 1; i < fn_; i++) {\n\t\t\tfact_[i] = fact_[i - 1] * i % mod;\n\t\t\tcomp_[i] = mod_pow(fact_[i], mod - 2, mod);\n\t\t}\n\t}\n\tif (x < y) return 0;\n\treturn fact_[x] * comp_[x - y] % mod * comp_[y] % mod;\n}*/\n//---------------------------------------------------\nint a[5000], b[5000];\nint dp[5000][5000];\nint n;\nstring s;\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\t//a[i]=i個の赤い球を入れるために必要な最小操作回数\n\t//a[i]=k  前からi個めの球を入れるまでにk回の操作が必要であった。\n\t//a[i]    i個めのボールが前からa[i-1]番目以降の場所にいる場合、その回数分が必要\n\tfor (int i = 1; i < 5000; i++)\n\t\ta[i] = inf, b[i] = inf;\n\tint t = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\tif (a[t - 1] >= i) {\n\t\t\t\ta[t++] = a[t - 1] + 1;\n\t\t\t\ta[t++] = a[t - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[t++] = i + 1;\n\t\t\t\ta[t++] = i + 2;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (a[t - 1] >= i) a[t++] = a[t - 1] + 1;\n\t\t\telse a[t++] = i + 1;\n\t\t}\n\t}\n\tt = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '2') {\n\t\t\tif (b[t - 1] >= i) {\n\t\t\t\tb[t++] = b[t - 1] + 1;\n\t\t\t\tb[t++] = b[t - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[t++] = i + 1;\n\t\t\t\tb[t++] = i + 2;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (b[t - 1] >= i) b[t++] = b[t - 1] + 1;\n\t\t\telse b[t++] = i + 1;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tfor (int j = 0; j <= 2 * n; j++) {\n\t\t\tif (a[j] <= i && b[i - j] <= i) {\n\t\t\t\tdp[i][j] = ((j == 0 ? 0 : dp[i - 1][j - 1]) + dp[i - 1][j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= 2 * n; i++) {\n\t\t(ans += dp[2 * n][i]) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tll value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 998244353\nusing namespace std;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int tasu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\n\nint n, R[4005], B[4005], f[4005][4005];\nchar S[2005];\n\nint main(){\n\tscanf(\"%s\", S + 1), n = strlen(S + 1);\n\tfor(register int i = 1; i <= n; i++){\n\t\tR[i] = R[i - 1] - S[i] + '2';\n\t\tB[i] = B[i - 1] + S[i] - '0';\n\t}\n\tfor(register int i = n + 1; i <= (n << 1); i++){\n\t\tR[i] = R[i - 1];\n\t\tB[i] = B[i - 1];\n\t}\n\tn <<= 1, f[0][0] = 1;\n\tfor(register int i = 1; i <= n; i++)\n\t\tfor(register int j = max(0, i - B[i]); j <= R[i]; j++)\n\t\t\tf[i][j] = tasu(f[i - 1][j - 1], f[i - 1][j]);\n\treturn printf(\"%d\\n\", f[n][R[n]]), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst lint mod = 998244353;\nconst lint INF = mod*mod;\nconst int MAX = 100010;\n\nint R[4010], B[4010];\nlint dp[4010][4010];\n\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    int curr=0, curb=0;\n    rep(i, n){\n        if(s[i]=='0') {\n            R[curr++]=i; R[curr++]=i;\n        }\n        else if(s[i]=='1'){\n            R[curr++]=i; B[curb++]=i;\n        }\n        else{\n            B[curb++]=i; B[curb++]=i;\n        }\n    }\n\n    rep(i, curr+1)rep(j, curb+1) dp[i][j]=0;\n    dp[0][0]=1;\n    rep(i, curr+1)rep(j, curb+1)if(dp[i][j]){\n        if(i<curr && R[i]<=i+j) (dp[i+1][j]+=dp[i][j])%=mod;\n        if(j<curb && B[j]<=i+j) (dp[i][j+1]+=dp[i][j])%=mod;\n    }\n    printf(\"%lld\\n\", dp[curr][curb]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2010,mod = 998244353;\nchar s[maxn];\nint num1[maxn],num2[maxn],n,f[maxn][maxn],c[maxn][maxn],ans;\n\nint main()\n{\n    scanf(\"%s\",s + 1);\n    n = strlen(s + 1);\n    c[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++)\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        num1[i] = num1[i - 1];\n        num2[i] = num2[i - 1];\n        if (s[i] == '0')\n            num1[i] += 2;\n        if (s[i] == '1')\n            num1[i]++,num2[i]++;\n        if (s[i] == '2')\n            num2[i] += 2;\n    }\n    f[0][0] = 1;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if (f[i][j])\n            {\n                if (j + 1 <= num1[i + 1])\n                    f[i + 1][j + 1] = (f[i + 1][j + 1] + f[i][j]) % mod;\n                if (i + 1 - j <= num2[i + 1])\n                    (f[i + 1][j] += f[i][j]) %= mod;\n            }\n    for (int i = 0; i <= num1[n]; i++)\n        ans = (ans + 1LL * f[n][i] * c[n][num1[n] - i] % mod) % mod;\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];puts(\"\");}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n// int dx[]={0,1,0,-1};\n// int dy[]={1,0,-1,0};//RDLU\n#define yes puts(\"YES\")\n#define no puts(\"NO\")\n\n//nCr mod m\n#define MOD 998244353\n#define M 1000000\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 1;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tvi co(n+1);\n\trep(i,n)co[i+1]=co[i]+s[i]-'0';\n\tvi dp(n+1);\n\tdp[0]=1;\n\trep(i,n){\n\t\tvi ndp(n+1);\n\t\trep(j,n)if(dp[j]){\n\t\t\tif(j+1<=co[i+1])(ndp[j+1]+=dp[j])%=MOD;\n\t\t\tif(i+1-j<=2*i+2-co[i+1])(ndp[j]+=dp[j])%=MOD;\n\t\t}\n\t\tdp=ndp;\n\t}\n\tint out=0;\n\trep(i,n+1)(out+=dp[i]*nCr(n,co[n]-i)%MOD)%=MOD;\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll mod = 998244353;\n\nconst int N = 4004;\nll dp[N][N];\nint f[N];\nint main(){\n    f[0] = 0;\n    for(int i=1; i<N; ++i) f[i] = f[i-1]+i;\n\n    string s;\n    cin >>s;\n\n    int n = s.size();\n\n    vector<int> r,b;\n    rep(i,n){\n        if(s[i]=='0') rep(j,2) r.pb(i);\n        else if(s[i]=='1'){\n            r.pb(i);\n            b.pb(i);\n        }\n        else rep(j,2) b.pb(i);\n    }\n\n    int R = r.size(), B = b.size();\n\n    vector<int> ca(R+1);\n    rep(i,R) ca[i+1] = ca[i] + r[i]+1;\n\n    vector<int> cb(R+1);\n    rep(i,B) cb[i+1] = cb[i] + b[i]+1;\n\n    dp[0][0] = 1;\n    rep(i,2*n)rep(rr,R+1)if(dp[i][rr]>0){\n        int bb = i-rr;\n\n        int csum = ca[rr]+cb[bb];\n        if(rr<R){\n            int nc = csum + r[rr]+1;\n            if(nc <= f[i+1]){\n                (dp[i+1][rr+1] += dp[i][rr]) %= mod;\n            }\n        }\n        if(bb<B){\n            int nc = csum + b[bb]+1;\n            if(nc <= f[i+1]){\n                (dp[i+1][rr] += dp[i][rr]) %= mod;\n            }\n        }\n    }\n\n    cout << dp[2*n][R] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 998244353\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \ntemplate<int MAX>\nstruct comcalc{\n    vector<mint> fact,finv,inv;\n    comcalc():fact(MAX),finv(MAX),inv(MAX){\n        fact[0]=mint(1),fact[1]=mint(1),finv[0]=mint(1),finv[1]=mint(1),inv[1]=mint(1);\n        for(int i=2;i<MAX;i++){\n            fact[i]=fact[i-1]*mint(i);\n            inv[i]=mint(0)-inv[mod%i]*(mint(mod/i));\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    mint com(int n,int k){\n        if(n<k) return mint(0);\n        if(n<0 or k<0) return mint(0);\n        return fact[n]*(finv[k]*finv[n-k]);\n    }\n    mint fac(int n){\n        return fact[n];\n    }\n    // 重複組み合わせ:n種類の物から重複を許し，k個選ぶ\n    mint nHk(int n,int k){\n        return com(n+k-1,k);\n    }\n    // 玉n区別，箱k区別，各箱1個以上O(k)\n    mint F12_dis_dis_one(int n,int k){\n        mint ret=1;\n        for(int i=0;i<=k;i++){\n            mint add=com(k,i)*(mint(i).pow(n));\n            if((k-i)%2) ret-=add;\n            else        ret+=add;\n        }\n        return ret;\n    }\n};\nmint pow_mod(mint x,ll n){\n    return x.pow(n);\n}\nmint inv_mod(mint x){\n    return x.inverse();\n}\n// O(n)\nmint fact_mod(ll n){\n    mint ret=1;\n    for(int i=2;i<=n;i++) ret*=mint(i);\n    return ret;\n}\n// O(r)\nmint comb_mod(ll n,ll r){\n    if(r>n-r) r=n-r;\n    if(r==0) return 1;\n    mint a=1,b=mint(fact_mod(r)).inverse();\n    for(int i=0;i<r;i++)a*=mint(n-i);\n    return a*b;\n}\n \nconst int MAX=4010000;\nusing cominit=comcalc<MAX>;\n\nint ng[4001][4001];\nmint dp[4001][4001];\n\nsigned main(){\n    string s;cin>>s;\n    int n=s.size();\n    vector<int>rv(n),bv(n);\n    int rc=0,bc=0;\n    rep(i,n){\n        rv[i]=(s[i]-'0');\n        bv[i]=2-rv[i];\n        rc+=rv[i];\n        bc+=bv[i];\n    }\n\n    \n    rep(i,rc+1)rep(j,bc+1)ng[i][j]=false,dp[i][j]=0;\n    dp[0][0]=1;\n\n\n    {\n        int r=0,b=0;\n        for(int i=0;b<bc;i++){\n            b+=bv[i];\n            if(b+r<i+1){\n                ng[r][i+1]=true;\n                r++;\n            }\n        }\n\n        \n    }\n    {\n        int r=0,b=0;\n        for(int i=0;r<rc;i++){\n            r+=rv[i];\n            if(r+b<i+1){\n                ng[i+1][b]=true;\n                b++;\n            }\n        }\n    }\n\n    rep(i,rc+1){\n        rep(j,bc+1){\n            if(i>0 and !ng[i-1][j]) dp[i][j]+=dp[i-1][j];\n            if(j>0 and !ng[i][j-1]) dp[i][j]+=dp[i][j-1];\n        }\n    }\n\n    // rep(i,rc+1){\n    //     rep(j,bc+1){\n    //         if(ng[i][j]) cout<<\"x\";\n    //         else cout<<\"o\";\n    //     }cout<<endl;\n    // }\n\n    cout<<dp[rc][bc]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include<bits/stdc++.h>\n// using namespace std;\n// typedef long long int lint;\n// #define rep(i,n) for(lint i=0;i<(lint)(n);++i)\n// #define repi(i,a,b) for(lint i=(lint)(a);i<(lint)(b);++i)\n// #define all(n) (n).begin(),(n).end()\n// vector<lint> dx={-1,1,0,0};\n// vector<lint> dy={0,0,-1,1};\n// #define endl '\\n'\n// constexpr lint INF=1LL<<60;\n\n// map<pair<lint,lint>,lint>dist;\n// lint k;\n// template<typename T>\n// struct reroot{\n//     vector<vector<lint>>g;\n//     vector<lint>p_list;\n//     vector<T>p_table;\n//     vector<bool>p_checked;\n//     vector<map<lint,T>>table;\n//     vector<T>ans;\n//     reroot(auto g):g(g),p_list(g.size(),-1),p_checked(g.size(),0),table(g.size()){\n//         p_table.resize(g.size(),e);\n//         ans.resize(g.size(),e);\n//         dfs1(0,-1);\n//         for(int i=0;i<(int)g.size();++i)ans[i]=dfs2(i,-1);\n//     }\n//     T dfs1(lint n,lint p){\n//         p_list[n]=p;\n//         T tmp1=e,tmp2=e;\n//         vector<T>tmp(g[n].size());\n//         rep(i,g[n].size()){\n//             lint t=g[n][i];\n//             if(t==p)continue;\n//             table[n][t]=tmp1;\n//             tmp1=f(tmp1,tmp[i]=dfs1(t,n));\n//         }\n//         for(lint i=g[n].size()-1;i>=0;--i){\n//             lint t=g[n][i];\n//             if(t==p)continue;\n//             table[n][t]=f(table[n][t],tmp2);\n//             tmp2=f(tmp[i],tmp2);\n//         }\n//         return fix(table[n][p]=tmp1,dist[minmax(n,p)]);\n//     }\n//     T dfs2(lint n,lint p){\n//         if(n==-1)return e;\n//         if(!p_checked[n]){\n//             p_checked[n]=1;\n//             p_table[n]=dfs2(p_list[n],n);\n//         }\n//         if(p==-1){\n//             return f(table[n][p_list[n]],p_table[n]);\n//         }else{\n//             if(p_list[n]==-1)return fix(table[n][p],dist[minmax(n,p)]);\n//             else return fix(f(table[n][p],p_table[n]),dist[minmax(n,p)]);\n//         }\n//     }\n//     vector<T>query(){\n//         return ans;\n//     }\n//     T e=T(1,0);\n//     T f(T s,T t){\n//         T res(s.size()+t.size(),0);\n//         rep(i,s.size())rep(j,t.size()){\n//             if(res[i+j]<s[i]+t[j])res[i+j]=s[i]+t[j];\n//         }\n//         while(res.back()==0)res.pop_back();\n//         if(res.size()==0)res.push_back(0);\n//         if(lint(res.size())>k+1)res.resize(k+1);\n//         return res;\n//     }\n//     T fix(T s,lint c){\n//         s.push_back(s.back()+c);\n//         if(lint(s.size())>k+1)s.resize(k+1);\n//         return s;\n//     }\n// };\n\n// int64_t mod_pow(int64_t x,int64_t y,int64_t mod){\n//     int64_t ret=1;\n//     while(y){\n//         if(y&1)(ret*=x)%=mod;\n//         (x*=x)%=mod;\n//         y>>=1;\n//     }\n//     return ret;\n// }\n// auto meld(tuple<int64_t,int64_t,int64_t,int> s,tuple<int64_t,int64_t,int64_t,int> t){\n//     constexpr int64_t base=10007;\n//     constexpr int64_t mod[3]={1000000007LL,999999937LL,998244353LL};\n//     int64_t a[3]={};\n//     a[0]=(get<0>(s)*mod_pow(base,get<3>(t),mod[0])%mod[0]+get<0>(t))%mod[0];\n//     a[1]=(get<1>(s)*mod_pow(base,get<3>(t),mod[1])%mod[1]+get<1>(t))%mod[1];\n//     a[2]=(get<2>(s)*mod_pow(base,get<3>(t),mod[2])%mod[2]+get<2>(t))%mod[2];\n//     return make_tuple(a[0],a[1],a[2],get<3>(s)+get<3>(t));\n// }\n// auto make(char c){\n//     return make_tuple(int64_t(c),int64_t(c),int64_t(c),1);\n// }\n\n// int main(){\n//     cin.tie(nullptr);\n//     ios::sync_with_stdio(false);\n// }\n\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nsigned main() {\n    vector<vector<modInt>> dp(4010,vector<modInt>(4010));\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 998244353;\nll dp[4005][4005];\nll R_sum[4005];\nll B_sum[4005];\nll red[4005];\nll blue[4005];\n\nint main() {\n    //cout.precision(10);\n    string S;\n    cin >> S;\n    ll N = S.size();\n    S = \"#\" + S;\n    for(int i = 1; i <= N; i++) {\n        R_sum[i] = R_sum[i - 1];\n        B_sum[i] = B_sum[i - 1];\n        if(S[i] == '0') {\n            R_sum[i] += 2;\n        }\n        if(S[i] == '1') {\n            R_sum[i]++;\n            B_sum[i]++;\n        }\n        if(S[i] == '2') {\n            B_sum[i] += 2;\n        }\n    }\n    for(int i = N + 1; i <= 2 * N + 1; i++) {\n        R_sum[i] = R_sum[i - 1];\n        B_sum[i] = B_sum[i - 1];\n    }\n    for(int i = 1; i <= 2 * N; i++) {\n        red[i] = red[i - 1];\n        if(R_sum[i] > red[i]) red[i]++;\n    }\n    for(int i = 1; i <= 2 * N; i++) {\n        blue[i] = blue[i - 1];\n        if(B_sum[i] > blue[i]) blue[i]++;\n    }\n    for(int i = 1; i <= 2 * N; i++) {\n        //cout << i << \" \" << red[i] << \" \" << blue[i] << endl;\n    }\n    dp[0][0] = 1;\n    for(int num_r = 0; num_r <= R_sum[N]; num_r++) {\n        for(int num_b = 0; num_b <= B_sum[N]; num_b++) {\n            int total = num_r + num_b;\n            if(red[total] < num_r) continue;\n            if(blue[total] < num_b) continue;\n            if(num_r > 0) {\n                dp[num_r][num_b] = (dp[num_r][num_b] + dp[num_r - 1][num_b]) % mod;\n            }\n            if(num_b > 0) {\n                dp[num_r][num_b] = (dp[num_r][num_b] + dp[num_r][num_b - 1]) % mod;\n            }\n        }\n    }\n    cout << dp[R_sum[N]][B_sum[N]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\ndouble pi=2*acos(0);\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    string s;cin>>s;\n    int n=s.size();\n    ll dp[4001][4001];\n    memset(dp,0,sizeof dp);\n  dp[0][0]=1;\n    int nr=0,nb=0;\n    rep(i,0,n){\n        if(s[i]=='0')nr+=2;\n        else if(s[i]=='1'){\n            nr++;\n            nb++;\n        }\n        else nb+=2;\n        rep(j,0,i+1){\n            ll k=i-j;\n            if(k<nr){\n                (dp[j][k+1]+=dp[j][k])%=mod2;\n            }\n            if(j<nb){\n                (dp[j+1][k]+=dp[j][k])%=mod2;\n            }\n        }\n        \n    }\n    rep(i,n,2*n){\n        rep(j,0,i+1){\n            ll k=i-j;\n            if(k<nr){\n                (dp[j][k+1]+=dp[j][k])%=mod2;\n            }\n            if(j<nb){\n                (dp[j+1][k]+=dp[j][k])%=mod2;\n            }\n        }\n    }\n    cout<<dp[nb][nr]<<endl;\n  /*rep(i,0,nb+1){\n    rep(j,0,nr+1)cout<<dp[i][j]<<\" \";\n    cout<<endl;\n  }*/\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int inf = 1e17;\nconst int mod = 998244353;\ntypedef pair<int, int> P;\ntypedef pair<int,P> PP;\nint rwa[2005];\nint dp[4004][4004];\n\nsigned main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\trep(i, n) {\n\t\tif (s[i] == '0')rwa[i + 1] += 2;\n\t\tif (s[i] == '1')rwa[i + 1]++;\n\t\trwa[i + 1] += rwa[i];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, i+1) {\n\t\t\tint r = j, b = i - j;\n\t\t\tint br = rwa[min(n, i + 1)], bb = min(n, i + 1) * 2 - br;\n\t\t\tif (br >= r + 1 && bb >= b)dp[i + 1][j + 1] += dp[i][j];\n\t\t\tif (br >= r&&bb >= b + 1)dp[i + 1][j]+= dp[i][j];\n\t\t\tdp[i + 1][j + 1] %= mod;\n\t\t\tdp[i + 1][j] %= mod;\n\t\t}\n\t}\n\tint sum = 0;\n\trep(i, 2 * n + 1)sum += dp[2 * n][i];\n\tcout << sum%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\ntypedef long double ld;\ntypedef long long ll;\n\n\nconst int mod = 998244353;\n\nint add(int x) {  \n  return x;\n}\n\ntemplate<typename... T>\nint add(int x, T... y) {  \n  x += add(y...);\n  if (x >= mod)\n        x -= mod;\n  return x;\n}\n\ntemplate<typename... T>\nint udd(int &x, T... y) { \n  return x = add(x, y...);\n}\n\ntemplate<typename... T>\nint sub(int x, T... y) { \n  return add(x, mod - add(y...));\n}\n\nint mul(int x) { \n  return x;\n}\n\ntemplate<typename... T>\nint mul(int x, T... y) { \n  return 1ll * x * mul(y...) % mod;\n}\n\nint bin(int x, int to) { \n  int y = 1;\n  while (to) { \n        if (to & 1)\n                  y = mul(x, y);\n            x = mul(x, x);\n                to >>= 1;\n  }\n  return y;\n}\n\nint inv(int x) { \n  assert(x != 0);\n  return bin(x, mod - 2);\n}\n\nconst int M = 4040;\n\nint d[M][M];\nstring s;\nint n;\nint a[M], b[M];\n\nvoid read() {\n  cin >> s;\n  n = s.length();\n\n  a[0] = b[0] = 0;\n\n  for (int i = 0; i < n; ++i) {\n    int x = s[i] - '0';\n    int y = 2 - x;\n    a[i + 1] = a[i] + x;\n    b[i + 1] = b[i] + y;\n  }\n  for (int i = n; i <= 2 * n; ++i) {\n    a[i + 1] = a[i];\n    b[i + 1] = b[i];\n  }\n}\n\nvoid calc() {\n  int x = a[n], y = b[n];\n\n\n  for (int i = 0; i <= x; ++i)\n    for (int j = 0; j <= y; ++j)\n      d[i][j] = 0;\n\n  d[0][0] = 1;\n\n  for (int i = 0; i <= x; ++i)\n    for (int j = 0; j <= y; ++j) {\n      int curx = a[i + j + 1] - i;\n      int cury = b[i + j + 1] - j;\n      if (curx < 0 || cury < 0)\n        continue;\n\n      if (curx > 0) {\n        udd(d[i + 1][j], d[i][j]);\n      }\n\n      if (cury > 0) {\n        udd(d[i][j + 1], d[i][j]);\n      }\n    }\n\n  //for (int i = 0; i <= x; ++i, cerr << \"\\n\")\n    //for (int j = 0; j <= y; ++j, cerr << \" \")\n      //cerr << d[i][j];\n\n  cout << d[x][y] << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"f.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n\n  read();\n  calc();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst ll mod = 998244353;\n\nstring s;\nll cum1[2010], cum2[2010];\nll d[4010][4010];\n\nsigned main() {\n\tcin >> s;\n\tint n = (int)s.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '0')cum1[i + 1] += 2;\n\t\tif (s[i] == '1')cum1[i + 1]++, cum2[i + 1]++;\n\t\tif (s[i] == '2')cum2[i + 1] += 2;\n\t\tcum1[i + 1] += cum1[i];\n\t\tcum2[i + 1] += cum2[i];\n\t}\n\td[0][0] = 1;\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tif (j + 1<= cum1[min(n, i + 1)])d[j + 1][i - j] = (d[j + 1][i - j] + d[j][i - j]) % mod;\n\t\t\tif (i - j + 1 <= cum2[min(n, i + 1)])d[j][i + 1 - j] = (d[j][i + 1 - j] + d[j][i - j]) % mod;\n\t\t}\n\t}\n\tcout << d[cum1[n]][cum2[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define mod (int)(1e9+7)\n#define inf (int)(3e18)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define P std::pair<int,int>\n#define PiP std::pair<int,std::pair<int,int>>\n#define all(v) v.begin(),v.end()\n#define mkp std::make_pair\n#define prique(T) std::priority_queue<T,vector<T>,greater<T>>\nusing namespace std;\ntemplate<class T> inline void chmax(T &a, T b) {\n\ta = std::max(a, b);\n}\ntemplate<class T> inline void chmin(T &a, T b) {\n\ta = std::min(a, b);\n}\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0)\n\t\t\treturn false;\n\t}\n\treturn x != 1;\n}\nint gcd(int x, int y) {\n\tif (y == 0)\n\t\treturn x;\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\nint kai(int x, int y) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i;\n\t\tres %= mod;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m = mod) {\n\tint res = 1;\n\tx %= m;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint comb(int x, int y) {\n\tif (y > x)\n\t\treturn 0;\n\treturn kai(x, y) * mod_pow(kai(y, y), mod - 2, mod) % mod ;\n}\nint get_rand(int MIN, int MAX) {\n\tstd::random_device rnd;\n\tstd::mt19937 mt32(rnd());\n\tstd::uniform_int_distribution<int> engine(MIN, MAX);\n\treturn engine(mt32);\n}\nstruct BIT {\n\tvector<int> bit;\n\tint n;\n\tBIT(int x) {\n\t\tbit.resize(x + 1, 0);\n\t\tn = x;\n\t}\n\tvoid add(int x, int y) {\n\t\twhile (x <= n) {\n\t\t\tbit[x] += y;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint sum(int x) {\n\t\tint res = 0;\n\t\twhile (x > 0) {\n\t\t\tres += bit[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> par, size;\n\tUnionFind(int x) {\n\t\tpar.resize(x);\n\t\tsize.resize(x, 1);\n\t\trep(i,x)\n\t\t\tpar[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint consize(int x) {\n\t\treturn size[find(x)];\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn;\n\t\tif (size[x] < size[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsize[y] += size[x];\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tsize[x] += size[y];\n\t\t}\n\t}\n};\n\nstruct Tree {\n\tint size;\n\tvector<int> par, depth;\n\tvector<int> doubling[30];\n\tvector<vector<int>> G;\n\tint root = 0;\n\tTree(int x) {\n\t\tpar.resize(x);\n\t\tdepth.resize(x);\n\t\trep(i,30)\n\t\t{\n\t\t\tdoubling[i].resize(x, -1);\n\t\t}\n\t\tG.resize(x);\n\t\tsize = x;\n\t}\n\tvoid add_edge(int x, int y) {\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tvoid dfs(int x) {\n\t\tfor (int i : G[x]) {\n\t\t\tif (depth[i] == -1) {\n\t\t\t\tdepth[i] = depth[x] + 1;\n\t\t\t\tdoubling[0][i] = x;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t}\n\tvoid init() {\n\t\trep(i,size)\n\t\t\tdepth[i] = -1;\n\t\tdepth[root] = 0;\n\t\tdfs(root);\n\t\trep(i,29)\n\t\t{\n\t\t\trep(j,size)\n\t\t\t{\n\t\t\t\tif (doubling[i][j] == -1)\n\t\t\t\t\tdoubling[i + 1][j] = -1;\n\t\t\t\telse\n\t\t\t\t\tdoubling[i + 1][j] = doubling[i][doubling[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int x, int y) {\n\t\tif (depth[x] > depth[y])\n\t\t\tswap(x, y);\n\t\tfor (int i = 29; i >= 0; i--) {\n\t\t\tif ((depth[y] - depth[x]) >> i & 1) {\n\t\t\t\ty = doubling[i][y];\n\t\t\t}\n\t\t}\n\t\tif (x == y)\n\t\t\treturn x;\n\t\tfor (int i = 29; i >= 0; i--) {\n\t\t\tif (doubling[i][x] != doubling[i][y]) {\n\t\t\t\tx = doubling[i][x];\n\t\t\t\ty = doubling[i][y];\n\t\t\t}\n\t\t}\n\t\treturn doubling[0][x];\n\t}\n};\n\nstruct RollingHash {\n\tint Base = 283;\n\tconst int MASK30 = (1ll << 30) - 1;\n\tconst int MASK31 = (1ll << 31) - 1;\n\tconst int MOD = (1ll << 61) - 1;\n\tvector<int> hash, power;\n\tint calcmod(int val) {\n\t\tval = (val & MOD) + (val >> 61);\n\t\tif (val > MOD)\n\t\t\tval -= MOD;\n\t\treturn val;\n\t}\n\tint mul(int x, int y) {\n\t\tint xu = x >> 31;\n\t\tint xd = x & MASK31;\n\t\tint yu = y >> 31;\n\t\tint yd = y & MASK31;\n\t\tint mid = xd * yu + xu * yd;\n\t\tint midu = mid >> 30;\n\t\tint midd = mid & MASK30;\n\t\treturn calcmod(xu * yu * 2 + midu + (midd << 31) + xd * yd);\n\t}\n\tRollingHash(string s) {\n\t\t//Base=get_rand(1<<7,1<<8);\n\t\tint sz = s.size();\n\t\thash.resize(sz + 1, 0);\n\t\tpower.resize(sz + 1, 1);\n\t\trep(i,sz)\n\t\t{\n\t\t\thash[i + 1] = (mul(hash[i], Base) + s[i]) % MOD;\n\t\t\tpower[i + 1] = mul(power[i], Base) % MOD;\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tint res = (hash[r] - mul(hash[l], power[r - l]) + MOD) % MOD;\n\t\treturn res;\n\t}\n\tint lcp(int x, int y) {\n\t\tint len = min(hash.size() - y, hash.size() - x);\n\t\tint ok = 0, ng = len + 1;\n\t\twhile (ng - ok > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (get(x, x + mid) == get(y, y + mid))\n\t\t\t\tok = mid;\n\t\t\telse\n\t\t\t\tng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n};\nstruct Segtree {\n\tint size = 1;\n\tvector<int> dat, lazy;\n\tSegtree(int x) {\n\t\twhile (size < x)\n\t\t\tsize *= 2;\n\t\tdat.resize(size * 2 - 1, inf);\n\t\tlazy.resize(size * 2 - 1, inf);\n\t}\n\tvoid eval(int k, int l, int r) {\n\t\tchmin(dat[k], lazy[k]);\n\t\tif (r - l > 1) {\n\t\t\tchmin(lazy[k * 2 + 1], lazy[k]);\n\t\t\tchmin(lazy[k * 2 + 2], lazy[k]);\n\t\t}\n\t\tlazy[k] = inf;\n\t}\n\tvoid update(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)\n\t\t\tr = size;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)\n\t\t\treturn;\n\t\tif (a <= l && r <= b) {\n\t\t\tchmin(lazy[k], x);\n\t\t\teval(k, l, r);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n\tint query(int a, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)\n\t\t\tr = size;\n\t\teval(k, l, r);\n\t\tif (r - l == 1) {\n\t\t\treturn dat[k];\n\t\t}\n\t\tif (a < (l + r) / 2) {\n\t\t\treturn query(a, k * 2 + 1, l, (l + r) / 2);\n\t\t}\n\t\treturn query(a, k * 2 + 2, (l + r) / 2, r);\n\t}\n};\n\ntemplate<class T> vector<int> KMP(vector<T> target, vector<T> pattern) {\n\tvector<int> table(pattern.size() + 1);\n\ttable[0] = 0;\n\tint j = 0;\n\tREP(i,(int)pattern.size())\n\t{\n\t\tif (pattern[i] == pattern[j]) {\n\t\t\ttable[i] = j++;\n\t\t} else {\n\t\t\ttable[i] = j;\n\t\t\tj = 0;\n\t\t}\n\t}\n\ttable[pattern.size()] = j;\n\tj = 0;\n\tvector<int> res;\n\tint i = 0;\n\twhile (i < target.size()) {\n\t\tif (j < pattern.size() && target[i] == pattern[j]) {\n\t\t\ti++;\n\t\t\tj++;\n\t\t} else {\n\t\t\tif (!j)\n\t\t\t\ti++;\n\t\t\tj = table[j];\n\t\t}\n\t\tif (j == pattern.size())\n\t\t\tres.push_back(i - j);\n\t}\n\treturn res;\n}\n\nint perm[1000005];\nvoid init_perm(){\n\tperm[0]=1;\n\tREP(i,1000005)perm[i]=perm[i-1]*i%mod;\n}\nint nCk(int x,int y){\n\treturn perm[x]*mod_pow(perm[x-y],mod-2)%mod*mod_pow(perm[y],mod-2)%mod;\n}\n/*--------Library Zone!--------*/\n\n\nstring s;\nint dp[4005][4005],sum[2005],sum2[2005];\nconst int MOD=998244353;\nsigned main(){\n\tcin>>s;\n\trep(i,s.size()){\n\t\tsum[i+1]=sum[i]+('2'-s[i]);\n\t\tsum2[i+1]=sum2[i]+(s[i]-'0');\n\t}\n\tdp[0][0]=1;\n\trep(i,s.size()*2)rep(j,i+1){\n\t\tdp[i][j]%=MOD;\n\t\tif(dp[i][j]==0)continue;\n\t\tif(sum[min((int)s.size(),i+1)]>=j+1){\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t}\n\t\tif(sum2[min((int)s.size(),i+1)]>=i-j+1){\n\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t}\n\t}\n\tint res=0;\n\trep(i,s.size()*2+1){\n\t\tres+=dp[s.size()*2][i];\n\t\tres%=MOD;\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimise (\"ofast\")\n#pragma GCC optimise(\"unroll-loops\")\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 4000 + 10;\nconst ll MOD = 998244353;\nconst ll INF = 1000000000000000000;\nconst ll LOG = 25;\n\nstring s;\nint n, dp[N][N], num[N][2];\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tmemset(num, -1, sizeof num);\n\tcin >> s;\n\tn = s.size();\n\tint cnt0 = 0, cnt1 = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (s[i - 1] == '0') cnt0++, num[cnt0][0] = i, cnt0++, num[cnt0][0] = i;\n\t\telse if(s[i - 1] == '1') cnt0++, cnt1++, num[cnt0][0] = i, num[cnt1][1] = i;\n\t\telse cnt1++, num[cnt1][1] = i, cnt1++, num[cnt1][1] = i;\n\t}\n\tint c = 1;\n\tdp[0][c] = 1;\n\tfor (int i = 1; i <= 2 * n; i++){\n\t\tfor (int j = 0; j <= min(i, cnt0); j++){\n\t\t\tint koj = num[j][0];\n\t\t\tif (koj <= i){\n\t\t\t//\tcout << \"YES \" << i << ' ' << j << '\\n';\n              dp[i][j + c] += dp[i - 1][j - 1 + c]; \n\t\t\t}\n\t\t\tkoj = num[i - j][1];\n\t\t\tif (koj <= i) dp[i][j + c] += dp[i - 1][j + c];\n\t\t\tdp[i][j + c] %= MOD;\n\t\t\t//cout << i << ' ' << j << ' ' << num[j][0] << ' ' << dp[i][j + c] << '\\n';\n\t\t}\n\t}\n\tcout << dp[2 * n][cnt0 + c];\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(long long i=0; i<(long long)(n); i++)\n#define REP(i, k, n) for(long long i=(long long)(k); i<(long long)(n); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n#define PQ(T) priority_queue<T>\n#define PQS(T) priority_queue<T, vector<T>, greater<T> >\n#define deci cout << fixed << setprecision(15);\ntypedef long long ll;\nconst ll inf = 1020304050607080910;\nconst ll mod = 998244353;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T> bool chmin(T&x,T y){if(x>y){x=y;return true;}return false;}\ntemplate<class T> bool chmax(T&x,T y){if(x<y){x=y;return true;}return false;}\nll gcd(ll x,ll y){if(x>y)swap(x, y);while(x!=0){y%=x;swap(x, y);}return y;}\nll mpow(ll x,ll r){if(r==0)return 1;if(r%2==1){return x*mpow(x,r-1)%mod;}else{ll aa=mpow(x,r/2);return aa*aa%mod;}}\n\nll N, ans, dp[2020][2020], rs[2020], bs[2020];\nstring S;\n\nconst int MAX = 100002;\n\n// fac[]・・・a! finv[]・・・(a!)^(-1) inv[]・・・a^(-1)\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid pre_comb(void){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\nlong long comb(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\n\nint main(){\n\tpre_comb();\n\tcin >> S;\n\tN = S.size();\n\tif(S[0] == '0') dp[1][0] = 1, dp[0][1] = 0, rs[0] = 2, bs[0] = 0;\n\telse if(S[0] == '2') dp[1][0] = 0, dp[0][1] = 1, rs[0] = 0, bs[0] = 2;\n\telse dp[1][0] = 1, dp[0][1] = 1, rs[0] = 1, bs[0] = 1;\n\trep(i, N-1){\n\t\trs[i+1] = rs[i] + ('2' - S[i+1]);\n\t\tbs[i+1] = bs[i] + (S[i+1] - '0');\n\t}\n\tfor(int sum=2; sum<=N; sum++){\n\t\trep(j, sum+1){\n\t\t\tint i = sum-j;\n\t\t\tif(j==0){\n\t\t\t\tif(S[sum-1] < '2' || rs[sum-2] >= sum-j) dp[i][j] = dp[i-1][j];\n\t\t\t}else if(j==sum){\n\t\t\t\tif(S[sum-1] > '0' || bs[sum-2] >= j) dp[i][j] = dp[i][j-1];\n\t\t\t}else{\n\t\t\t\tif(S[sum-1] < '2' || rs[sum-2] >= sum-j) dp[i][j] += dp[i-1][j];\n\t\t\t\tif(S[sum-1] > '0' || bs[sum-2] >= j) dp[i][j] += dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, N+1) ans = (ans + comb(N, rs[N-1]-i) * dp[i][N-i] % mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nvector<vector <lint> > dp;\nint ma[2010],mb[2010];\nlint mo=998244353;\nint main()\n{\n\tstring s;cin>>s;int n=s.size();\n\tma[0]=mb[0]=0;\n\trep(i,n){\n\t\tma[i+1]=ma[i]+(s[i]-'0');\n\t\tmb[i+1]=mb[i]+2-(s[i]-'0');\n\t}\n\t//memset(dp,0,sizeof(dp));dp[0][0]=1;\n\tint x=ma[n],y=mb[n];\n\trep(i,x+5){\n\t\tvector<lint> cl(y+5,0);dp.pb(cl);\n\t}\n\tdp[0][0]=1;\n\trep(i,x+1) rep(j,y+1){\n\t\t//cout<<i<<' '<<j<<' '<<ma[i+j+1]<<' '<<mb[i+j+1]<<endl;\n\t\tdp[i][j]%=mo;\n\t\tif(i<x && i<ma[min(n,i+j+1)]) dp[i+1][j]+=dp[i][j];\n\t\tif(j<y && j<mb[min(n,i+j+1)]) dp[i][j+1]+=dp[i][j];\n\t}\n\tcout<<dp[x][y]%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[4444][4444];\nint main() {\n\tstring s;\n\tcin >> s;\n\tint p = 998244353, r = 0, n = s.length(), c = 0;\n\td[0][0] = 1;\n\tfor (int i = 1; i <= n + n; i++) {\n\t\tif (i <= n) c += s[i - 1] - '0';\n\t\tfor (int j = max({ 0,c - i,c + i - n - n }); j <= min(i, c); j++)\n\t\t\t((i < n + n ? d[i][j] : r) += d[i - 1][j] + (j ? d[i - 1][j - 1] : 0)) %= p;\n\t}\n\tcout << r << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353;//1000000007;\n\n\n\n\nint main(){\n    string s;\n    cin>>s;\n    vector<ll> cnt0,cnt1;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='0'){cnt0.push_back(i); cnt0.push_back(i);}\n        else if(s[i]=='1'){cnt0.push_back(i); cnt1.push_back(i);}\n        else{cnt1.push_back(i); cnt1.push_back(i);}\n    }\n    vector<vector<ll>> dp(2*s.size()+1,vector<ll>(2*s.size()+1,0));\n    dp[0][0]=1;\n    for(int i=0;i<2*s.size();i++){\n        for(int t=0;t<2*s.size();t++){\n            if(cnt1.size()>=t+1 && cnt1[t]<=i){\n                dp[i+1][t+1]+=dp[i][t];\n                dp[i+1][t+1]%=MOD;\n            }\n            if(cnt0.size()>=i-t+1 && cnt0[i-t]<=i){\n                dp[i+1][t]+=dp[i][t];\n                dp[i+1][t]%=MOD;\n            }\n        }\n    }\n    ll sum=0;\n    for(int i=0;i<=2*s.size();i++){\n        sum+=dp[2*s.size()][i];\n    }\n    cout<<sum%MOD<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nll dp[4010][4010];\n\nint main(int argc, char const* argv[])\n{\n  string s; cin >> s;\n  int n = sz(s);\n  int r = 0;\n  rep(i, sz(s)){\n    if(s[i] == '0')r += 2;\n    else if(s[i] == '1')r++;\n  }\n  dp[0][0] = 1;\n  int cr = 0, cb = 0;\n  rep(i, 2 * n){\n    if(i < n){\n      if(s[i] == '0')cr += 2;\n      else if(s[i] == '1')cr++, cb++;\n      else cb += 2;\n    }\n    rep(j, r + 1){\n      if(dp[i][j] == 0)continue;\n      int rr = cr - j, rb = cb - (i - j);\n      if(rr > 0){\n        (dp[i+1][j+1] += dp[i][j]) %= mod;\n      }\n      if(rb > 0){\n        (dp[i+1][j] += dp[i][j]) %= mod;\n      }\n    }\n  }\n  cout << dp[2*n][r] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef double DOUBLE;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst ll LL_INF = 1e17 + 10;\nconst int INF = 1e9 + 10;\nconst ll MOD = 998244353;\n\nconst int MAXN = 4e3 + 5;\n\nchar s[MAXN];\nchar mn[MAXN], mx[MAXN];\nll mn_val, mx_val;\n\nll dp[MAXN][MAXN];\n\nint lower[MAXN], upper[MAXN];\nint cnt_1;\n\nint cnt[MAXN][2];\nint n;\n\nvoid process(char *res, int pref) {\n\tcnt_1 = 0;\n\tREP(i, 0, n) {\n\t\tcnt[i][0] = '2' - s[i];\n\t\tcnt[i][1] = 2 - cnt[i][0];\n\t\tcnt_1 += cnt[i][1];\n\t\t\n\t\t//printf(\"%d: %d %d\\n\", i, cnt[i][0], cnt[i][1]);\n\t}\n\tint top = 0;\n\tREP(i, 0, 2 * n) {\n\t\tif (cnt[0][pref] > 0) {\n\t\t\tres[top] = pref;\n\t\t} else {\n\t\t\tres[top] = pref ^ 1;\n\t\t}\n\t\tcnt[0][res[top]]--;\n\t\ttop++;\n\t\tREP(j, 1, n) {\n\t\t\tif (cnt[j][pref] > 0) {\n\t\t\t\tcnt[j][pref]--;\n\t\t\t\tcnt[j - 1][pref]++;\n\t\t\t} else if (cnt[j][pref ^ 1] > 0) {\n\t\t\t\tcnt[j][pref ^ 1]--;\n\t\t\t\tcnt[j - 1][pref ^ 1]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*REP(j, 0, n) {\n\t\t\tprintf(\"%d: %d %d\\n\", j, cnt[j][0], cnt[j][1]);\n\t\t}*/\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%s\", &s[0]);\n\tn = strlen(s);\n\t\n\tprocess(mn, 0);\n\tprocess(mx, 1);\n\t\n\tint offset_mn = 0, offset_mx = 0;\n\tREPN(i, 0, 2 * n) {\n\t\tlower[i] = INF;\n\t\tupper[i] = -1;\n\t}\n\tlower[0] = upper[0] = 0;\n\tREP(i, 0, 2 * n) {\n\t\tif (mn[i]) {\n\t\t\toffset_mn++;\n\t\t}\n\t\tif (mx[i]) {\n\t\t\toffset_mx++;\n\t\t}\n\t\tint ind_mn = i + 1 - offset_mn;\n\t\tint ind_mx = i + 1 - offset_mx;\n\t\tlower[ind_mn] = min(lower[ind_mn], offset_mn);\n\t\tupper[ind_mx] = max(upper[ind_mx], offset_mx);\n\t}\n\t\n\tint cnt_0 = 2 * n - cnt_1;\n\tREPN(i, 0, cnt_0) {\n\t\tREPN(j, 0, cnt_1) {\n\t\t\tif (lower[i] <= j && j <= upper[i]) {\n\t\t\t\tif (!i && !j) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t} else if (!i) {\n\t\t\t\t\tdp[i][j] = dp[i][j - 1];\n\t\t\t\t} else if (!j) {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[cnt_0][cnt_1]);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main(){\n    string S;\n    while(cin >> S){\n        const int N = S.size();\n        vector<vector<int>> dp(2*N+1, vector<int>(2*N+1, 0));\n        dp[0][0] = 1;\n        vector<int> red(N+1, 0);\n        vector<int> blue(N+1, 0);\n        for(int i=0;i<N;i++){\n            red[i+1] = red[i] + (2-(S[i]-'0'));\n            blue[i+1] = blue[i] + (S[i]-'0');\n        }\n        int res = 0;\n        for(int r=0;r<=2*N;r++){\n            for(int b=0;b<=2*N;b++){\n                int turn = r+b;\n                if(turn == 2*N) res = (res + dp[r][b]) % MOD;\n                if(turn >= 2*N) continue;\n                if(turn >= N){\n                    if(r+1 <= red[N] && b <= blue[N]) dp[r+1][b] = (dp[r+1][b] + dp[r][b]) % MOD;\n                    if(r <= red[N] && b+1 <= blue[N]) dp[r][b+1] = (dp[r][b+1] + dp[r][b]) % MOD;\n                } else {\n                    if(r+1 <= red[turn] + (S[turn] != '2' ? 1 : 0) && b <= blue[turn]) dp[r+1][b] = (dp[r+1][b] + dp[r][b]) % MOD;\n                    if(r <= red[turn] && b+1 <= blue[turn] + (S[turn] != '0' ? 1 : 0)) dp[r][b+1] = (dp[r][b+1] + dp[r][b]) % MOD;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define showoff     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define pb          push_back\n#define pii         pair<long long,long long>\n#define FOR(i,a,b)  for(long long i=a;i<b;++i)\n#define RFOR(i,a,b) for(long long i=a;i>b;--i)\n#define f           first\n#define se          second\n#define maxn        400005\n#define all(v)      v.begin(),v.end()\n#define sz(x)       (long long)x.size()\n#define mod         998244353\n#define pqueue      priority_queue<long long>\n#define pdqueue     priority_queue< long long,vector<long long> ,greater< long long >>\n \ntypedef long long ll;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//const long long md = 998244353;\n \n/*const long long mod = 998244353;\nlong long power(long long a,long long n)\n{\n\tif(n == 1)return a%mod;\n\tif(n == 0)return 1;\n\tif(n&1)return ((a%mod)*(power((a*a)%mod,n/2))%mod)%mod;\n\treturn power((a*a)%mod,n/2)%mod;\n}\n*/\n\n\nint main()\n{\n\tll n, ans = 0;\n\tstring s;\n\tcin >> s;\n\n\tn = s.length()*2;\n\n\tll dpA[4001];\n\tll dpB[4001];\n\tll *dp1;\n\tll *dp2;\n\n\tFOR (i,0,n+1) {\n\t\tdpA[0] = 0;\n\t}\n\tif (s[0] != '2') dpA[0] = 1;\n\tif (s[0] != '0') dpA[1] = 1;\n\tdp2 = dpA;\n\n\tll r = s[0] == '0' ? 2 : (s[0] == '1' ? 1 : 0);\n\tll w = 2;\n\tFOR (i,1,n) {\n\t\tif (i % 2 > 0) {\n\t\t\tdp1 = dpA;\n\t\t\tdp2 = dpB;\n\t\t} else {\n\t\t\tdp1 = dpB;\n\t\t\tdp2 = dpA;\n\t\t}\n\t\tif (i < s.length()) {\n\t\t\tw += 2;\n\t\t\tr += s[i] == '0' ? 2 : (s[i] == '1' ? 1 : 0);\n\t\t}\n\n\t\tif ((w - r) > i) dp2[0] = dp1[0];\n\t\telse dp2[0] = 0;\n\n\t\tFOR (j,1,n+1) {\n\t\t\tif (r >= j)\n\t\t\t\tdp2[j] = dp1[j-1];\n\t\t\telse\n\t\t\t\tdp2[j] = 0;\n\t\t\tif ((w - r) > (i - j)) {\n\t\t\t\tdp2[j] += dp1[j];\n\t\t\t\tif (dp2[j] > mod)\n\t\t\t\t\tdp2[j] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp2[r] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\n\n\nint main(){\n    string s;cin >> s;\n    int N=s.length();\n    vector<int> a,b;\n    for (int i = 0; i < N; i++) {\n        if(s[i]=='0'){\n            a.pb(i);\n            a.pb(i);\n        }\n        else if(s[i]=='1'){\n            a.pb(i);\n            b.pb(i);\n        }\n        else{\n            b.pb(i);\n            b.pb(i);\n        }\n    }\n    vector<vector<LL>> dp(2*N+1,vector<LL>(2*N+1,0));\n    dp[0][0]=1;\n    for (int i = 0; i < 2*N; i++) {\n        for (int j = 0; j < 2*N; j++) {\n            int k=i+j;\n            if(i<a.size()&&a[i]<=k) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n            if(j<b.size()&&b[j]<=k) dp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod;\n\n        }\n    }\n    cout << dp[a.size()][b.size()] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstring s;\nint dp[4005][4005];\nint suma[4005];\nint sumb[4005];\n\nint main(void){\n    cin >> s;\n    int n=s.size();\n    for(int i=0;i<(int)s.size();i++){\n        suma[i+1]+=suma[i];\n        sumb[i+1]+=sumb[i];\n        if(s[i]=='0'){\n            suma[i+1]+=2;\n        }\n        if(s[i]=='1'){\n            suma[i+1]+=1;\n            sumb[i+1]+=1;\n        }\n        if(s[i]=='2'){\n            sumb[i+1]+=2;\n        }\n    }\n    for(int i=n;i<2*n;i++){\n        suma[i+1]+=suma[i];\n        sumb[i+1]+=sumb[i];\n    }\n    dp[0][0]=1;\n    for(int i=0;i<n*2;i++){\n        for(int j=0;j<=i;j++){\n            //printf(\"%d %d %d\\n\",i,j,dp[i][j]);\n            if(dp[i][j]==0)continue;\n            if(suma[i+1]>=j+1){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=MOD;\n            }\n            if(sumb[i+1]>=i-j+1){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=MOD;\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[n*2][suma[n]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;}\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;}\n    return false;\n}\n\nconst int MAX = 510000;\nvector<ll> fac(MAX),finv(MAX),inv(MAX);\n\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    rep2(i,2,MAX){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\nll COM(int n,int k){\n    if (n<k) return 0;\n    if (n<0||k<0) return 0;\n    return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S; cin >> S;\n    int N=S.size();\n    vector<int> sum(N+1);\n    sum[0]=0;\n    rep(i,N){\n        sum[i+1]=sum[i];\n        if (S[i]=='0') sum[i+1]+=2;\n        if (S[i]=='1') ++sum[i+1];\n    }\n    vector<vector<ll>> dp(N+1,vector<ll>(N+1,0));\n    dp[0][0]=1;\n    rep(i,N){\n        rep(j,N+1){\n            if (sum[i+1]>=j+1) dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%MOD;\n            if (2*(i+1)-sum[i+1]>=i-j+1) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n        }\n    }\n    ll ans=0,s=sum[N];\n    COMinit();\n    rep(i,N+1) ans=(ans+dp[N][i]*COM(N,s-i)%MOD)%MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//ans= (2^(n+m) - 2^(n+m-rank))/2\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring str;cin>>str;\n\tint i,j,n;n=str.size();\n\tstatic llint dp[4001][4002]={0};\n\tdp[0][1]=1;\n\t//数、青\n\tint wa=0;\n\tfor(i=1;i<=2*n;i++){\n\t\tif(i<=n){wa+=str[i-1]-'0';}\n\t\tfor(j=max(0,wa-i)+1;j<=wa+1;j++){\n\t\t\tdp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%mod;\n\t\t}\n\t}\n\tcout<<dp[n+n][wa+1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fec(i, x, y) (int i = head[x], y = g[i].to; i; i = g[i].ne, y = g[i].to)\n#define dbg(...) fprintf(stderr, __VA_ARGS__)\n#define File(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n#define fi first\n#define se second\n#define pb push_back\n\ntemplate<typename A, typename B> inline char SMAX(A &a, const B &b) {return a < b ? a = b , 1 : 0;}\ntemplate<typename A, typename B> inline char SMIN(A &a, const B &b) {return b < a ? a = b , 1 : 0;}\n\ntypedef long long ll; typedef unsigned long long ull; typedef std::pair<int, int> pii;\n\ntemplate<typename I>\ninline void read(I &x) {\n\tint f = 0, c;\n\twhile (!isdigit(c = getchar())) c == '-' ? f = 1 : 0;\n\tx = c & 15;\n\twhile (isdigit(c = getchar())) x = (x << 1) + (x << 3) + (c & 15);\n\tf ? x = -x : 0;\n}\n\nconst int N = 2000 + 7;\nconst int P = 998244353;\n\nint n, cntb[N << 1], dp[N << 1][N << 1];\nchar s[N];\n\ninline void Inc(int &x, int y) {x += y; x >= P ? x -= P : 0;}\n\nint main() {\n\t#ifdef hzhkk\n\tfreopen(\"hkk.in\", \"r\", stdin);\n\t#endif\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tfor (int i = 1; i <= n; ++i) cntb[i] = cntb[i - 1] + s[i] - '0';\n\tfor (int i = n + 1; i <= (n << 1); ++i) cntb[i] = cntb[i - 1];\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= (n << 1); ++i) {\n\t\tfor (int j = std::max(cntb[i] - i, 0); j <= std::min(cntb[i], i); ++j) {\n\t\t\tif (j) dp[i][j] = dp[i - 1][j - 1];\n\t\t\tif (i > j) Inc(dp[i][j], dp[i - 1][j]);\n\t\t\t//  dbg(\"dp[%d][%d] = %d\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n << 1][cntb[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 998244353\n\nint N;\nstring S;\nint R[4001],B[4001];\nll dp[4001][4001];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>S;\n  N=S.size();\n  rep(i,N){\n    if(S[i]=='0'){\n      R[i+1]=R[i]+2;\n      B[i+1]=B[i];\n    }\n    if(S[i]=='1'){\n      R[i+1]=R[i]+1;\n      B[i+1]=B[i]+1;\n    }\n    if(S[i]=='2'){\n      R[i+1]=R[i];\n      B[i+1]=B[i]+2;\n    }\n  }\n\n  dp[0][0]=1;\n  rep(i,2*N)rep(j,R[N]+1){\n    if(dp[i][j]==0)continue;\n    // dbg(i); dbg(j); dbg(dp[i][j]);\n    if(i>=N){\n      if(R[N]>=j+1)(dp[i+1][j+1]+=dp[i][j])%=mod;\n      if(B[N]>=i-j+1)(dp[i+1][j]+=dp[i][j])%=mod;\n    }else{\n      { // red\n        if(R[i+1]>=j+1)(dp[i+1][j+1]+=dp[i][j])%=mod;\n      }\n      { // blue\n        if(B[i+1]>=i-j+1)(dp[i+1][j]+=dp[i][j])%=mod;\n      }\n    }\n  }\n\n  cout<<dp[2*N][R[N]]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 2005;\nconst int mod = 998244353;\n\nint C[Maxn][Maxn];\nstring s;\nint dp[Maxn][Maxn];\nint res;\n\nint main()\n{\n    for (int i = 0; i < Maxn; i++) {\n        C[i][0] = C[i][i] = 1;\n        for (int j = 1; j < i; j++)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    }\n    cin >> s;\n    dp[0][0] = 1;\n    for (int i = 0; i < s.length(); i++)\n        for (int j = 0; j <= i; j++) if (dp[i][j]) {\n            int blue = j, red = i - j;\n            if (s[i] == '0') red += 2;\n            else if (s[i] == '1') red++, blue++;\n            else blue += 2;\n            if (red > 0) dp[i + 1][blue] = (dp[i + 1][blue] + dp[i][j]) % mod;\n            if (blue > 0) dp[i + 1][blue - 1] = (dp[i + 1][blue - 1] + dp[i][j]) % mod;\n        }\n    for (int j = 0; j <= s.length(); j++)\n        res = (res + ll(dp[s.length()][j]) * C[s.length()][j]) % mod;\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<time.h>\n#include<cassert>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define EPS (1e-13)\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rep(i,n) for(int (i) = 0 ; (i) < (n) ; (i)++)\n#define mkp make_pair\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\nconst int Mod = 1e9 + 7;\nconst int mod = 998244353;\nconst ll Inf = 3 * 1e18;\nconst int inf = 15 * 1e8;\nll read() {\n\tll u, k = scanf(\"%lld\", &u);\n\treturn u;\n}\nll gcd(ll i, ll j) {\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcd(j % i, i);\n}\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % p;\n\t\tx = x * x % p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll bcount(ll x) {\n\tint sum = 0;\n\tfor (int i = 0; i < 20; i++)\n\t\tif ((1ll << i) & x) sum++;\n\treturn sum;\n}\n/*const int fn_ = 2000000;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll mod = Mod) {\n\tif (!fact_[0]) {\n\t\tfact_[0] = 1; comp_[0] = 1;\n\t\tfor (int i = 1; i < fn_; i++) {\n\t\t\tfact_[i] = fact_[i - 1] * i % mod;\n\t\t\tcomp_[i] = mod_pow(fact_[i], mod - 2, mod);\n\t\t}\n\t}\n\tif (x < y) return 0;\n\treturn fact_[x] * comp_[x - y] % mod * comp_[y] % mod;\n}*/\n//---------------------------------------------------\nint a[5000], b[5000];\nint dp[5000][5000];\nint n;\nstring s;\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\t//a[i]=i個の赤い球を入れるために必要な最小操作回数\n\t//a[i]=k  前からi個めの球を入れるまでにk回の操作が必要であった。\n\t//a[i]    i個めのボールが前からa[i-1]番目以降の場所にいる場合、その回数分が必要\n\tfor (int i = 1; i < 5000; i++)\n\t\ta[i] = inf, b[i] = inf;\n\tint t = 1, sum = 0;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\tif (a[t - 1] >= i) {\n\t\t\t\ta[t] = a[t - 1] + 1;\n\t\t\t\tt++;\n\t\t\t\ta[t] = a[t - 1] + 1;\n\t\t\t\tt++;\n\t\t\t\tsum += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[t++] = i + 1;\n\t\t\t\ta[t++] = i + 2;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (a[t - 1] >= i) {\n\t\t\t\ta[t] = a[t - 1] + 1;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\telse a[t++] = i + 1;\n\t\t}\n\t}\n\tt = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '2') {\n\t\t\tif (b[t - 1] >= i) {\n\t\t\t\tb[t] = b[t - 1] + 1;\n\t\t\t\tt++;\n\t\t\t\tb[t] = b[t - 1] + 1; \n\t\t\t\tt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[t++] = i + 1;\n\t\t\t\tb[t++] = i + 2;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (b[t - 1] >= i) {\n\t\t\t\tb[t] = b[t - 1] + 1;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\telse b[t++] = i + 1;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tfor (int j = 0; j <= 2 * n; j++) {\n\t\t\tif (a[j] <= i && b[i - j] <= i) {\n\t\t\t\tdp[i][j] = ((j == 0 ? 0 : dp[i - 1][j - 1]) + dp[i - 1][j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= 2 * n; i++) {\n\t\t(ans += dp[2 * n][i]) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define N 4010\nconst ll MOD = (ll)998244353;\nint n;\nchar s[N];\nll f[N][N];\nint a[N], b[N];\n\ntemplate <class T>\nvoid add(T &x, T &y) { x += y; if (x >= MOD) x -= MOD; }\n\nint main()\n{\n\twhile (scanf(\"%s\", s + 1) != EOF)\n\t{\n\t\tn = strlen(s + 1);\n\t\tfor (int i = 1; i <= n; ++i) a[i] = a[i - 1] + 2 - (s[i] - '0'), b[i] = b[i - 1] + s[i] - '0';\n\t\tmemset(f, 0, sizeof f);\n\t\tf[0][0] = 1;\n\t\tfor (int i = 0; i <= 2 * n; ++i)\n\t\t\tfor (int j = 0; j <= i; ++j) if (f[i][j])\n\t\t\t{\n\t\t\t\tif (a[min(i + 1, n)] > j) add(f[i + 1][j + 1], f[i][j]);\n\t\t\t\tif (b[min(i + 1, n)] > i - j) add(f[i + 1][j], f[i][j]);\n\t\t\t}\n\t\tprintf(\"%lld\\n\", f[2 * n][a[n]]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nint main() {\n  string S;\n  cin >> S;\n  int red = 0, blue = 0;\n\n  vector< int > dp{1};\n  for(int i = 0; i < S.size() * 2; i++) {\n    if(i < S.size()) {\n      if(S[i] == '0') red += 2;\n      else if(S[i] == '1') red += 1, blue += 1;\n      else blue += 2;\n    }\n    vector< int > dp2(red + 1);\n    for(int red_used = 0; red_used < dp.size(); red_used++) {\n      int blue_used = i - red_used;\n      if(red_used < red) (dp2[red_used + 1] += dp[red_used]) %= mod;\n      if(blue_used < blue) (dp2[red_used] += dp[red_used]) %= mod;\n    }\n    dp.swap(dp2);\n  }\n  cout << dp.back() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing pint=pair<int,int>;\nusing pll=pair<ll,ll>;\n#define MOD 998244353LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n#define MAX_N 1000000\n\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n\tlong long d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\tif(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n\telse return -1;\n}\nvector<long long> fact(MAX_N+1, INF);\nlong long mod_fact(long long n, long long& e) {\n\tif(fact[0] == INF) {\n\t\tfact[0]=1;\n\t\tif(MAX_N != 0) fact[1]=1;\n\t\tfor(ll i = 2; i <= MAX_N; ++i) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t}\n\t}\n\te = 0;\n\tif(n == 0) return 1;\n\tlong long res = mod_fact(n / MOD, e);\n\te += n / MOD;\n\tif((n / MOD) % 2 != 0) return (res * (MOD - fact[n % MOD])) % MOD;\n\treturn (res * fact[n % MOD]) % MOD;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n\tif(n < 0 || k < 0 || n < k) return 0;\n\tlong long e1, e2, e3;\n\tlong long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n\tif(e1 > e2 + e3) return 0;\n\treturn (a1 * mod_inverse((a2 * a3) % MOD, MOD)) % MOD;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tint n = (int)s.size();\n\tvector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));\n\tdp[0][0] = 1;\n\tREP(i, n) REP(j, n + 1) {\n\t\tll b = j, r = 2 * i - j - i;\n\t\tif(s[i] == '0') r += 2;\n\t\telse if(s[i] == '1') {\n\t\t\tr += 1; b += 1;\n\t\t} else {\n\t\t\tb += 2;\n\t\t}\n\t\tif(b > 0) {\n\t\t\tdp[i + 1][b - 1] += dp[i][j];\n\t\t\tdp[i + 1][b - 1] %= MOD;\n\t\t}\n\t\tif(r > 0) {\n\t\t\tdp[i + 1][b] += dp[i][j];\n\t\t\tdp[i + 1][b] %= MOD;\n\t\t}\n\t}\n\tll ans = 0;\n\tREP(i, n + 1) {\n\t\tans += dp[n][i] * mod_comb(n, i);\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 998244353;\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 2100;\n\nstring s;\n\nint n;\nint cc[MAXN][2];\n\nll dp[MAXN][MAXN];\n\nvoid add(ll &a, ll b) {\n\ta = (a + b) % MOD;\n}\n\nll cnk[MAXN][MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tfor (int i = 0; i < MAXN; ++i)\n\t\tfor (int j = 0; j < MAXN; ++j) {\n\t\t\tif (i == j || j == 0)\n\t\t\t\tcnk[i][j] = 1;\n\t\t\telse if (j > i)\n\t\t\t\tcnk[i][j] = 0;\n\t\t\telse\n\t\t\t\tcnk[i][j] = (cnk[i - 1][j] + cnk[i - 1][j - 1]) % MOD;\n\t\t}\n\tcin >> s;\n\tn = s.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tcc[i + 1][0] = cc[i][0] + 2 - (s[i] - '0');\n\tfor (int i = 0; i < n; ++i)\n\t\tcc[i + 1][1] = cc[i][1] + (s[i] - '0');\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tif (i - j + 1 <= cc[i + 1][0])\n\t\t\t\tadd(dp[i + 1][j], dp[i][j]);\n\t\t\tif (j + 1 <= cc[i + 1][1])\n\t\t\t\tadd(dp[i + 1][j + 1], dp[i][j]);\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tif (dp[n][i]) {\n\t\t\tadd(ans, dp[n][i] * cnk[n][cc[n][1] - i]);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <set>\n#include <sys/timeb.h>\n#include <fstream>\n#include <random>\n#include <regex>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <iomanip>\n#include <limits>\n#include <stack>\n\nusing namespace std;\n\n#define DEBUG_\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n#define MOD2 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\n\n#ifdef DEBUG_\n#define DEB\n#else\n#define DEB if(false)\n#endif\n\n#ifdef DEBUG_\n#define dump(...) DUMPOUT<<\"  \"; \\\ndump_func(string(#__VA_ARGS__) + \":\", \"[\" + to_string(__LINE__) + \":\" + __FUNCTION__ + \"]\"); \\\nDUMPOUT<<\"    \"; \\\ndump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<Pll> vPll;\ntypedef vector<Pd>vPd;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef vector<vector<vector<int> > > vvvi;\ntypedef vector<vector<vector<ll> > > vvvll;\ntypedef vector<vector<vector<Pi> > > vvvPi;\ntypedef vector<vector<vector<vector<Pi> > > > vvvvPi;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n\tDUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&&... tail) {\n\tDUMPOUT << head;\n\tif (sizeof...(Tail) <= 1) {\n\t\tDUMPOUT << \" \";\n\t}\n\telse {\n\t\tDUMPOUT << \", \";\n\t}\n\tdump_func(std::move(tail)...);\n}\n\n// vector\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec) is >> x;\n\treturn is;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// vector\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vec) {\n\tos << \"{\";\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tos << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// map\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, map<T, U>& map_var) {\n\tos << \"{\";\n\trepi(itr, map_var) {\n\t\tos << \"(\" << itr->first << \",\" << itr->second << \")\";\n\t\titr++;\n\t\tif (itr == map_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// set\ntemplate<typename T>\nostream& operator << (ostream& os, set<T>& set_var) {\n\tos << \"{\";\n\trepi(itr, set_var) {\n\t\tos << \"  \" << *itr << endl;\n\t\titr++;\n\t\tif (itr == set_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\nstring YN(bool y, int id = 0) { if (id)cout << id; return (y ? \"YES\" : \"NO\"); }\nstring yn(bool y, int id = 0) { if (id)cout << id; return (y ? \"Yes\" : \"No\"); }\nstring ON(bool y, int id = 0) { if (id)cout << id; return (y ? \"OK\" : \"NG\"); }\n\nint dir4[4][2] = { { 0,-1 },{ -1,0 },{ 1,0 },{ 0,1 } };\nint dir8[8][2] = { { -1,-1 },{ 0,-1 },{ 1,-1 },{ -1,0 },{ 1,0 },{ -1,1 },{ 0,1 },{ 1,1 } };\nchar dirchar[4] = { '<','^','>','v' };\n\n// [a,b)\nint irand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_int_distribution<int> dist(a, b - 1);\n\treturn dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_real_distribution<double> dist(a, b);\n\treturn dist(Rand);\n}\n\nstruct Edge {\nint from, to, cost;\nbool operator<(Edge e) {\nreturn cost < e.cost;\n}\n};\nusing Graph = vec<vec<Edge>>;\n\nostream& operator << (ostream& os, Edge &edge) {\nos << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\nreturn os;\n}\n\n//======================================================\n\n// モジュラ逆数を求める(modが素数と仮定)\nvoid ModInv(int n, vector<ll> &inv, int mod) {\n\tinv[0] = 0;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tinv[i] = mod - ((mod / i) * inv[mod % i] % mod);\n\t}\n}\n\n// n!をmodで割った余り\nvoid FacInv(int n, vector<ll> &inv, vector<ll> &fac, vector<ll> &facInv, int mod) {\n\tfac[0] = facInv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac[i] = (fac[i - 1] * i) % mod;\n\t\tfacInv[i] = (facInv[i - 1] * (int)inv[i]) % mod;\n\t}\n}\n\n// nCkをmodで割った余りを求める。mod素数限定\n// ModInv()とFacInv()が必要\nll CombiMod(int n, int k, int mod, const vll &fac, const vll &facInv) {\n\tif (n == 0 && k == 0) return 1;\n\tif (n <= 0 || k < 0 || k > n) return 0;\n\tif (k == 0) return 1;\n\treturn (((fac[n] * facInv[k]) % mod) * facInv[n - k]) % mod;\n}\n\nint main(void) {\n\tstring s;\n\tcin >> s;\n\tint N = s.size();\n\tint base = max(10, 2 * N);\n\tvvll dp(N + 1, vll(base * 2, 0));\n\t\n\tdp[0][base] = 1;\n\trep(i, N) {\n\t\tint offset = 0;\n\t\tif (s[i] == '0') {\n\t\t\toffset = 2;\n\t\t}\n\t\telse if (s[i] == '2') {\n\t\t\toffset = -2;\n\t\t}\n\t\trepr(j, -i, i + 1) {\n\t\t\tif (j + 1 + offset <= i + 1) {\n\t\t\t\tdp[i + 1][j + 1 + offset + base] += dp[i][j + base];\n\t\t\t\tdp[i + 1][j + 1 + offset + base] %= MOD2;\n\t\t\t}\n\t\t\tif (j - 1 + offset <= i + 1) {\n\t\t\t\tdp[i + 1][j - 1 + offset + base] += dp[i][j + base];\n\t\t\t\tdp[i + 1][j - 1 + offset + base] %= MOD2;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<ll> inv(N + 1);\n\tvector<ll> fac(N + 1);\n\tvector<ll> facInv(N + 1);\n\n\tModInv(N, inv, MOD2);\n\tFacInv(N, inv, fac, facInv, MOD2);\n\n\tll ans = 0;\n\tfor (int j = -N; j <= N; j += 2) {\n\t\tint k = (j + N) / 2;\n\t\tans += dp[N][j + base] * CombiMod(N, k, MOD2, fac, facInv);\n\t\tans %= MOD2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define N 4010\n#define mod 998244353\nll f[N][N],c[N],d[N];\nint main(){\n  string s;cin>>s;\n  for(int i=0;i<N;i++)c[i]=d[i]=1e17;\n  c[0]=0; for(int i=0;i<s.size();i++)c[i+1]=c[i]+(s[i]-'0');\n  d[0]=0; for(int i=0;i<s.size();i++)d[i+1]=d[i]+('2'-s[i]);\n  for(int i=0;i<N;i++)for(int j=0;j<N;j++) f[i][j]=0; f[0][0]=1;\n  for(int i=0;i<=c[s.size()];i++)for(int j=0;j<=d[s.size()];j++){\n    ll k=i+j+1;\n    if(c[k]>i)f[i+1][j]=(f[i+1][j]+f[i][j])%mod;\n    if(d[k]>j)f[i][j+1]=(f[i][j+1]+f[i][j])%mod;\n  }\n  cout<<f[c[s.size()]][d[s.size()]]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;   \n#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update> \n#define ld long double\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define sz(a) (ll)(a.size())\nconst int M = 2002;\nconst int mod = 998244353;\nint n;\nint csb[M],csr[M],dp[2*M][2*M];\nint solve(int x,int y)\n{\n\tif(dp[x][y] != -1)\n\t\treturn dp[x][y];\n\tif(x>2*n)\n\t\treturn 1;\n\tint id = min(x,n);\n\tint r = csr[id] - y;\n\tint b = csb[id] - (x-1-y);\n\tint res = 0;\n\tif(r)\n\t\tres += solve(x+1,y+1);\n\tif(b)\n\t\tres += solve(x+1,y);\n\treturn dp[x][y] = res%mod;\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tstring s;\n\tcin>>s;\n\tn = sz(s);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint b = s[i]-'0';\n\t\tcsb[i+1] = csb[i] + b;\n\t\tcsr[i+1] = csr[i] + 2 - b;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<solve(1,0)<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;;\n#define ll long long\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define INF 1<<30\n#define LINF 1LL<<62\n#define all(x) (x).begin(), (x).end()\n#define mp make_pair\n#define pb push_back\nconst ll MOD = 998244353;\n \ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\n\nll dp[4005][4005];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  ll n = s.size();\n  ll r[n], b[n];\n  REP(i,n){\n      r[i] = 0;\n      b[i] = 0;\n  }\n  REP(i,n){\n      if(s[i] == '0'){\n          r[i] += 2;\n      }else  if(s[i]=='1'){\n          r[i]++;\n          b[i]++;\n      }else{\n          b[i]+=2;\n      }\n      if(i!=0){\n          r[i] += r[i-1];\n          b[i] += b[i-1];\n      }\n  }\n  \n  dp[0][0] = 1;\n  REP(i,2*n){\n      REP(j,i+1){\n          if(i<n){\n              if(r[i]>=j+1){\n                  dp[i+1][j+1] += dp[i][j];\n                  dp[i+1][j+1] %= MOD;\n              }\n              if(b[i]>=i+1-j){\n                  dp[i+1][j] += dp[i][j];\n                  dp[i+1][j] %= MOD;\n              }\n          }else{\n              if(r[n-1]>=j+1){\n                  dp[i+1][j+1] += dp[i][j];\n                  dp[i+1][j+1] %= MOD;\n              }\n              if(b[n-1]>=i+1-j){\n                  dp[i+1][j] += dp[i][j];\n                  dp[i+1][j] %= MOD;\n              }\n    \n          }\n      }\n  } \n   ll ans = 0;\n\n  REP(i,2*n+1){\n      ans += dp[2*n][i];\n      ans %= MOD;\n  }\n  if(n==1){\n      if(s[0] == '1'){\n          ans = 2;\n      }else{\n          ans = 1;\n      }\n  }\n  cout << ans << endl;\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint mod = 998244353;\nstring s;\nvector<int> sr;\nvector<int> sb;\nint dp[4001][4001];\n\nint main() {\n\tint i, j;\n\t\n\tcin >> s;\n\tint n = s.length();\n\t\n\trep(i, n) {\n\t\tif (s[i] == '0') {\n\t\t\tsr.push_back(i);\n\t\t\tsr.push_back(i);\n\t\t}\n\t\tif (s[i] == '1') {\n\t\t\tsr.push_back(i);\n\t\t\tsb.push_back(i);\n\t\t}\n\t\tif (s[i] == '2') {\n\t\t\tsb.push_back(i);\n\t\t\tsb.push_back(i);\n\t\t}\n\t}\n\t\n\tdp[0][0] = 1;\n\trep(i, sr.size() + 1) {\n\t\trep(j, sb.size() + 1) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tif (i < sr.size() && sr[i] <= i + j) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t}\n\t\t\tif (j < sb.size() && sb[j] <= i + j) {\n\t\t\t\tdp[i][j + 1] += dp[i][j];\n\t\t\t\tdp[i][j + 1] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[sr.size()][sb.size()] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 998244353\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main(){\n\tchar a[N];\n\tf(i, N)a[i] = 0;\n\tlong long dp[5000];\n\tlong long dp2[5000];\n\tint l[5000];\n\tint r[5000];\n\tf(i, 5000){\n\t\tdp[i] = 0;\n\t\tdp2[i] = 0;\n\t}\n\tint n, k;\n\tint x, y, z;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%s\",a);\n\tn = strlen(a);\n\tl[0] = 0;\n\tr[0] = 0;\n\tf(i, n){\n\t\tif (a[i] == '0'){\n\t\t\tr[i + 1] = r[i];\n\t\t\tl[i + 1] = max(r[i + 1] - i - 1, 0);\n\t\t}\n\t\telse if (a[i] == '1'){\n\t\t\tr[i + 1] = r[i] + 1;\n\t\t\tl[i + 1] = max(r[i+1] - i-1, 0);\n\t\t}\n\t\telse{\n\t\t\tr[i + 1] = r[i] + 2;\n\t\t\tl[i + 1] = max(r[i+1] - i-1, 0);\n\t\t}\n\t}\n\tf(i, n){\n\t\tr[i + n + 1] = r[i + n];\n\t\tl[i + n + 1] = max(0, r[i + n + 1] + i + 1 - n);\n\t}\n\tdp[0] = 1;\n\tf(i, 2 * n){\n\t\tfor (int j = l[i]; j <= r[i]; j++){\n\t\t\tif (l[i + 1] <= j&&j <= r[i + 1])dp2[j] = (dp[j] + dp2[j]) % MOD;\n\t\t\tif (l[i + 1] <= (j + 1) && (j + 1) <= r[i + 1])dp2[j + 1] = (dp[j] + dp2[j + 1]) % MOD;\n\t\t}\n\t\tf(j, 5000){\n\t\t\tdp[j] = dp2[j];\n\t\t\tdp2[j] = 0;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", dp[r[2*n]]);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\nusing namespace std;\nlong long p = 998244353;\n//long long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nint root(int x, vel& pa) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x], pa); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y, vel& pa) {\n    x = root(x, pa);\n    y = root(y, pa);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nint lcm(int x, int y) {\n    x = abs(x); y = abs(y);\n    return x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai(int max_kai) {\n    kai = vel(max_kai, 1);\n    inv_kai = kai;\n    rep(i, max_kai - 1) {\n        kai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n        inv_kai[i + 1] = modinv(kai[i + 1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)) { return 0; }\n    int ans = (kai[n] * inv_kai[r]) % p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin, vector<pin>, greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nvel mul(vel& a, vel& b) {\n    int n = a.size();\n    int m = b.size();\n    vel ans(n + m - 1, 0);\n    rep(i, n) {\n        rep(j, m) {\n            ans[i + j] += a[i] * b[j];\n            ans[i + j] %= p;\n        }\n    }\n    return ans;\n}\nvel rui_p(vel& a, int n) {\n    if (n == 0) { return { 1 }; }\n    vel qans = rui_p(a, n / 2);\n    qans = mul(qans, qans);\n    if (n % 2 == 1) {\n        qans = mul(qans, a);\n    }\n    return qans;\n}\nvvel disj_min(vel& v) {\n    int n = v.size();\n    vvel ret(22, vel(n));\n    ret[0] = v;\n    rep(i, 21) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nvvel disj_max(vel& v) {\n    int n = v.size();\n    vvel ret(20, vel(n));\n    ret[0] = v;\n    rep(i, 19) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nint find_min(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return max(dv[i][l], dv[i][r - (1 << i)]);\n}\nbool is_prime(int n) {\n    if (n == 0 || n == 1) { return false; }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) { return false; }\n    }\n    return true;\n}\n#define double long double\n#define pd pair<double,double>\n#define bs bitset<300>\nvoid per(int& ans) {\n    ans %= p;\n    if (ans < 0) { ans += p; }\n}\nint count_zero(V<bs>& a) {\n    int n = a.size();\n    int now_st = 0;\n    rep(i, 300) {\n        int fir_ze = -1;\n        for (int j = now_st; j < n; j++) {\n            if (a[j][i]) { fir_ze = j; break; }\n        }\n        if (fir_ze >= 0) {\n            rep(j, n) {\n                if (j != fir_ze&&a[j][i]) {\n                    a[j] = a[fir_ze] xor a[j];\n                }\n            }\n            swap(a[now_st], a[fir_ze]);\n            now_st++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        bool fl = true;\n        rep(j, 300) {\n            if (a[i][j]) { fl = false; break; }\n        }\n        if (fl) { ans++; }\n    }\n    return ans;\n}\nsigned main() {\n    string s; cin >> s;\n    int n = s.size();\n    vel sx(n + 1, 0); vel sy = sx;\n    rep(i, n) {\n        sx[i + 1] = sx[i] + (s[i] - '0');\n        sy[i + 1] = (2*i + 2) - sx[i + 1];\n    }\n    vvel dp(2 * n + 2, vel(2 * n + 2, 0)); dp[0][0] = 1;\n    rep(x, 2 * n + 1) {\n        rep(y, 2 * n + 1) {\n            int turn = min(x + y+1,n);\n            int lx = sx[turn];\n            int ly = sy[turn];\n            if (x + 1 <= lx && y <= ly) {\n                dp[x + 1][y] += dp[x][y];\n                dp[x + 1][y] %= p;\n            }\n            if (x <= lx && y+1 <= ly) {\n                dp[x][y + 1] += dp[x][y];\n                dp[x][y + 1] %= p;\n            }\n        }\n    }\n    cout << dp[sx[n]][sy[n]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<time.h>\n#include<cassert>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define EPS (1e-13)\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rep(i,n) for(int (i) = 0 ; (i) < (n) ; (i)++)\n#define mkp make_pair\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\nconst int Mod = 1e9 + 7;\nconst int mod = 998244353;\nconst ll Inf = 3 * 1e18;\nconst int inf = 15 * 1e8;\nll read() {\n\tll u, k = scanf(\"%lld\", &u);\n\treturn u;\n}\nll gcd(ll i, ll j) {\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcd(j % i, i);\n}\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % p;\n\t\tx = x * x % p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll bcount(ll x) {\n\tint sum = 0;\n\tfor (int i = 0; i < 20; i++)\n\t\tif ((1ll << i) & x) sum++;\n\treturn sum;\n}\n/*const int fn_ = 2000000;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll mod = Mod) {\n\tif (!fact_[0]) {\n\t\tfact_[0] = 1; comp_[0] = 1;\n\t\tfor (int i = 1; i < fn_; i++) {\n\t\t\tfact_[i] = fact_[i - 1] * i % mod;\n\t\t\tcomp_[i] = mod_pow(fact_[i], mod - 2, mod);\n\t\t}\n\t}\n\tif (x < y) return 0;\n\treturn fact_[x] * comp_[x - y] % mod * comp_[y] % mod;\n}*/\n//---------------------------------------------------\nint a[5000], b[5000];\nint dp[5000][5000];\nint n;\nstring s;\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\t//a[i]=i個の赤い球を入れるために必要な最小操作回数\n\t//a[i]=k  前からi個めの球を入れるまでにk回の操作が必要であった。\n\t//a[i]    i個めのボールが前からa[i-1]番目以降の場所にいる場合、その回数分が必要\n\tfor (int i = 1; i < 5000; i++)\n\t\ta[i] = inf, b[i] = inf;\n\tint t = 1, sum = 0;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\tif (a[t - 1] >= i) {\n\t\t\t\ta[t++] = a[t - 1] + 1;\n\t\t\t\ta[t++] = a[t - 1] + 1;\n\t\t\t\tsum += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[t++] = i + 1;\n\t\t\t\ta[t++] = i + 2;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (a[t - 1] >= i) a[t++] = a[t - 1] + 1;\n\t\t\telse a[t++] = i + 1;\n\t\t}\n\t}\n\tt = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '2') {\n\t\t\tif (b[t - 1] >= i) {\n\t\t\t\tb[t++] = b[t - 1] + 1;\n\t\t\t\tb[t++] = b[t - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[t++] = i + 1;\n\t\t\t\tb[t++] = i + 2;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (b[t - 1] >= i) b[t++] = b[t - 1] + 1;\n\t\t\telse b[t++] = i + 1;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tfor (int j = 0; j <= 2 * n; j++) {\n\t\t\tif (a[j] <= i && b[i - j] <= i) {\n\t\t\t\tdp[i][j] = ((j == 0 ? 0 : dp[i - 1][j - 1]) + dp[i - 1][j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[2 * n][sum] % mod + mod) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 998244353;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\nll dp[4010][4010] = {};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    ll N = S.size();\n    dp[0][0] = 1;\n    ll red = 0, blue = 0;\n    rep(i,0,2*N){\n        if(i < N){\n            if(S[i] == '0'){\n                red += 2;\n            }else if(S[i] == '1'){\n                red++; blue++;\n            }else{\n                blue += 2;\n            }\n        }\n        rep(j,0,i+1){\n            ll r = j;\n            ll b = i - j;\n            if(r < red){\n                dp[i+1][r+1] += dp[i][r];\n                dp[i+1][r+1] %= MOD;\n            }\n            if(b < blue){\n                dp[i+1][r] += dp[i][r];\n                dp[i+1][r] %= MOD;\n            }\n        }\n    }\n    print(dp[2*N][red]);\n\n    \n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nconst int MOD = 998244353;\n\nconst int ms = 2020;\n\nint memo[ms + ms][ms + ms];\nstd::string str;\n\nint dp(int round, int red, int blue) {\n\tif(round < (int) str.size()) {\n\t\tif(str[round] == '0') red += 2;\n\t\telse if(str[round] == '1') { red++; blue++; }\n\t\telse blue += 2;\n\t}\n\tint &ans = memo[round][red];\n\tif(ans != -1) return ans;\n\tans = 0;\n\tif(red + blue == 0) return ans = 1;\n\tif(red) {\n\t\tans += dp(round+1, red-1, blue);\n\t}\n\tif(blue) {\n\t\tans += dp(round+1, red, blue-1);\n\t}\n\tif(ans >= MOD) ans -= MOD;\n\treturn ans;\n}\n\nint main() {\n\tmemset(memo, -1, sizeof memo);\n\tstd::cin >> str;\n\tstd::cout << dp(0, 0, 0) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"unroll-loops\")\n#pragma GCC push_options\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\n#include <xmmintrin.h>\n#include <immintrin.h>\nusing namespace::std;\n__attribute__((constructor))void init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\ntemplate<typename T>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T,typename E>using hash_map=__gnu_pbds::gp_hash_table<T,E>;\ntemplate<typename T>using pqueue =__gnu_pbds::priority_queue<T, greater<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n//#define MOD 1000000007LL\n#define MOD 998244353LL\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,n) for(lint i=0;i<lint(n);++i)\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrep(i,n) for(lint i=lint(n)-1;i>=0;--i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\n#define all(n) begin(n),end(n)\n#define dist(a,b,c,d) sqrt(pow(a-c,2)+pow(b-d,2))\ninline lint gcd(lint A,lint B){return B?gcd(B,A%B):A;}\ninline lint lcm(lint A,lint B){return A/gcd(A,B)*B;}\n// inline cint cgcd(cint A,cint B){return B?cgcd(B,A%B):A;}\n// inline cint clcm(cint A,cint B){return A/cgcd(A,B)*B;}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\nauto call=[&](auto f,auto... args){return f(f,args...);};\n \nclass mint {\n  using u64 = std::uint_fast64_t;\n    public:\n    u64 a;\n    constexpr mint(const u64 x = 0)noexcept:a(x % MOD){}\n    constexpr u64 &value()noexcept{return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr mint operator+(const mint rhs)const noexcept{return mint(*this) += rhs;}\n    constexpr mint operator-(const mint rhs)const noexcept{return mint(*this)-=rhs;}\n    constexpr mint operator*(const mint rhs) const noexcept {return mint(*this) *= rhs;}\n    constexpr mint operator/(const mint rhs) const noexcept {return mint(*this) /= rhs;}\n    constexpr mint &operator+=(const mint rhs) noexcept {\n        a += rhs.a;\n        if (a >= MOD)a -= MOD;\n        return *this;\n    }\n    constexpr mint &operator-=(const mint rhs) noexcept {\n        if (a<rhs.a)a += MOD;\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr mint &operator*=(const mint rhs) noexcept {\n        a = a * rhs.a % MOD;\n        return *this;\n    }\n    constexpr mint operator++(int n) noexcept {\n        a += 1;\n        if (a >= MOD)a -= MOD;\n        return *this;\n    }\n    constexpr mint operator--(int n) noexcept {\n        if (a<1)a += MOD;\n        a -= 1;\n        return *this;\n    }\n    constexpr mint &operator/=(mint rhs) noexcept {\n        u64 exp=MOD-2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    mint pow(long long n){\n        long long x=a;\n        mint ret = 1;\n        while(n>0) {\n            if(n&1)(ret*=x);\n            (x*=x)%=MOD;\n            n>>=1;\n        }\n        return ret;\n    }\n    mint inv()const{\n        int _a=a,b=MOD,u=1,v=0,t;\n        while(b>0) {\n            t=_a/b;\n            swap(_a-=t*b,b);\n            swap(u-=t*v,v);\n        }\n        return mint(u);\n    }\n    mint comb(lint b){\n        using lint=long long;\n        static bool init=1;\n        static lint fac[1000001],ifac[1000001];\n        if(init){\n            init=0;\n            fac[0]=1;\n            ifac[0]=1;\n            auto mod_pow=[&](lint x,lint n){\n                lint ans = 1;\n                while(n != 0){\n                    if(n&1)ans=ans*x%MOD;\n                    x=x*x%MOD;\n                    n=n>>1;\n                }\n                return ans;\n            };\n            for(int i=0;i<1000000;i++){\n                fac[i+1]=fac[i]*(i+1)%MOD;\n                ifac[i+1]=ifac[i]*mod_pow(i+1, MOD-2)%MOD;\n            }\n        }\n        if(a==0&&b==0)return 1;\n        if((lint)a<b||a<0)return 0;\n        lint tmp=ifac[a-b]*ifac[b]%MOD;\n        return tmp*fac[a]%MOD;\n    }\n    \n    friend ostream& operator<<(ostream& lhs, const mint& rhs) noexcept {\n        lhs << rhs.a;\n        return lhs;\n    }\n    friend istream& operator>>(istream& lhs,mint& rhs) noexcept {\n        lhs >> rhs.a;\n        return lhs;\n    }\n};\ninline mint fact(lint a){return a?fact(a-1)*a:1;}\n\nint main(){\n    string s;\n    cin>>s;\n    lint n=s.size();\n    vec a(n,0);\n    a[0]=s[0]-'0';\n    repi(i,1,n)a[i]=a[i-1]+s[i]-'0';\n    vector<vector<mint>> dp(2*n+1,vector<mint>(2*n,0));\n    dp[0][0]=1;\n    repi(i,1,n+1)rep(j,a[i-1]+1){\n        if(j==0)dp[i][j]+=dp[i-1][j];\n        else dp[i][j]+=dp[i-1][j-1]+dp[i-1][j];\n        if(j<a[i-1]-i)dp[i][j]=0;\n    }\n    repi(i,n+1,2*n+1)rep(j,a.back()+1){\n        if(j==0)dp[i][j]+=dp[i-1][j];\n        else dp[i][j]+=dp[i-1][j-1]+dp[i-1][j];\n        if(j<a.back()-i)dp[i][j]=0;\n    }\n    cout<<dp[2*n][a.back()]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nint read() {\n\tint x; cin >> x; return x;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nclass UnionFind {\nprotected:\n\tint* par, * rank, * size;\npublic:\n\tUnionFind(unsigned int size) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tthis->size = new int[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tthis->size[i] = 1;\n\t\t}\n\t}\n\tint find(int n) {\n\t\tif (par[n] == n)return n;\n\t\treturn par[n] = find(par[n]);\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m)return;\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tsize[m] += size[n];\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tsize[n] += size[m];\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t}\n\tbool same(int n, int m) {\n\t\treturn find(n) == find(m);\n\t}\n\tint getsize(int n) {\n\t\treturn size[find(n)];\n\t}\n};\nclass PerpetualUnionFind :UnionFind {\n\tP* notparent;\n\tvector<P>* sizevec;\n\tint opcount = 0;\npublic:\n\tPerpetualUnionFind(unsigned int size) :UnionFind(size) {\n\t\tthis->sizevec = new vector<P>[size];\n\t\tnotparent = new P[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsizevec[i].push_back(make_pair(-1, 1));\n\t\t\tnotparent[i] = make_pair(INF, i);\n\t\t}\n\t}\n\tint find(int n, int t = INF) {\n\t\tif (opcount <= t) {\n\t\t\tif (par[n] == n)return n;\n\t\t\treturn par[n] = find(par[n]);\n\t\t}\n\t\tif (notparent[n].first <= t)return find(notparent[n].second, t);\n\t\treturn n;\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m) {\n\t\t\topcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tnotparent[n] = make_pair(opcount, m);\n\t\t\tsizevec[m].push_back(make_pair(opcount, sizevec[m].back().second + sizevec[n].back().second));\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tnotparent[m] = make_pair(opcount, n);\n\t\t\tsizevec[n].push_back(make_pair(opcount, sizevec[n].back().second + sizevec[m].back().second));\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t\topcount++;\n\t}\n\tbool same(int n, int m, int t = INF) {\n\t\treturn find(n, t) == find(m, t);\n\t}\n\tint getsize(int n, int t = INF) {\n\t\tn = find(n, t);\n\t\tauto ite = lower_bound(sizevec[n].begin(), sizevec[n].end(), make_pair(t, (int)0));\n\t\tif (ite == sizevec[n].end())ite--;\n\t\tif (t < (*ite).first)ite--;\n\t\treturn (*ite).second;\n\t}\n};\nclass RollingHash {\n\tstring s;\n\tint n, m;\n\tmodInt base;\n\tvector<modInt> has, power;\npublic:\n\tRollingHash(string s, int m, int b) : n(s.size()), m(m), base(b, m) { init(s, m, b); }\n\tvoid init(string s, int m, int b) {\n\t\tn = s.size();\n\t\thas.resize(n);\n\t\tpower.resize(n);\n\t\tbase = modInt(b, m);\n\t\tthis->s = s;\n\t\tthis->m = m;\n\t\trep(i, n) {\n\t\t\thas[i] = modInt(s[i], m);\n\t\t\tif (i) {\n\t\t\t\thas[i] += base * has[i - 1];\n\t\t\t\tpower[i] = power[i - 1] * base;\n\t\t\t}\n\t\t\telse power[i] = 1;\n\t\t}\n\t}\n\toperator int() const {\n\t\treturn has.back();\n\t}\n\tint query(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\treturn has[b - 1] - power[b - a] * (!a ? modInt(0) : has[a - 1]);\n\t}\n\tRollingHash& operator+=(string t) {\n\t\ts += t;\n\t\thas.resize(n + t.size());\n\t\tpower.resize(n + t.size());\n\t\tfor (int i = n; i < n + t.size(); i++) {\n\t\t\thas[i] = modInt(t[i] * base, m);\n\t\t\thas[i] += base * has[i - 1];\n\t\t\tpower[i] = power[i - 1] * base;\n\t\t}\n\t\tn += t.size();\n\t\treturn *this;\n\t}\n};\ntemplate<typename T, typename U>\nclass SegTree {\n\tint n = 1;\n\tT* node = NULL;\n\tU* lazy = NULL;\n\tbool* lazyflag = NULL;\n\tT nodee;\n\tfunction<T(T, T)> nodef;\n\tfunction<U(U, U)> lazyf;\n\tfunction<T(int, T, U)> updf;\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazyflag[k]) {\n\t\t\tnode[k] = updf(r - l, node[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tif (lazyflag[2 * k + 1])lazy[2 * k + 1] = lazyf(lazy[2 * k + 1], lazy[k]);\n\t\t\t\telse lazy[2 * k + 1] = lazy[k];\n\t\t\t\tif (lazyflag[2 * k + 2])lazy[2 * k + 2] = lazyf(lazy[2 * k + 2], lazy[k]);\n\t\t\t\telse lazy[2 * k + 2] = lazy[k];\n\t\t\t\tlazyflag[2 * k + 1] = lazyflag[2 * k + 2] = true;\n\t\t\t}\n\t\t\tlazyflag[k] = false;\n\t\t}\n\t}\npublic:\n\tSegTree(int m, int init, T nodee, function<T(T, T)> nodef, function<U(U, U)> lazyf, function<T(int, T, U)> updf) :nodee(nodee), nodef(nodef), lazyf(lazyf), updf(updf) {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t\twhile (n < m)n *= 2;\n\t\tnode = new T[2 * n], lazy = new U[2 * n], lazyflag = new bool[2 * n];\n\t\trep(i, 2 * n) {\n\t\t\tnode[i] = init;\n\t\t\tlazyflag[i] = false;\n\t\t}\n\t}\n\t~SegTree() {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t}\n\tvoid update(int a, int b, U x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazyflag[k] = true;\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = nodef(node[2 * k + 1], node[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return nodee;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn nodef(vl, vr);\n\t}\n};\ntemplate<typename T>\nclass RAQRSQ :public SegTree<T, T> {\npublic:\n\tRAQRSQ(int size, const T& def = T()) :SegTree<T, T>(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + range * b; }) {};\n};\ntemplate<typename T>\nclass RAQRMiQ :public SegTree<T, T> {\npublic:\n\tRAQRMiQ(int size, const T& def = T()) :SegTree<T, T>(size, def, INF, [](T a, T b) {return min(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RAQRMaQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRAQRMaQ(int size, const T& def = T()) :base(size, def, -INF, [](T a, T b) {return max(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RUQRSQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRSQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return b; }, [](int range, T a, T b) {return range * b; }) {};\n};\ntemplate<typename T>\nclass RUQRMQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRMQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return min(a, b); }, [](T a, T b) {return b; }, [](int range, T a, T b) {return b; }) {};\n};\ntemplate<typename T>\nclass BIT {\n\tint n;\n\tT* bit;\npublic:\n\tBIT(int n) :n(n) {\n\t\tbit = new T[n];\n\t\tfill(bit, bit + n, T());\n\t}\n\tvoid add(int a, T x) {\n\t\twhile (a < n) {\n\t\t\tbit[a] += x;\n\t\t\ta += a & -a;\n\t\t}\n\t}\n\tT query(int a) {\n\t\tint cnt = 0;\n\t\twhile (a > 0) {\n\t\t\tcnt += bit[a];\n\t\t\ta -= a & -a;\n\t\t}\n\t\treturn cnt;\n\t}\n};\nclass ConvexHullTrick {\n\tbool minOrMax, lineMonotone;\n\tclass Line {\n\tpublic:\n\t\tint a, b;\n\t\tbool isquery;\n\t\tmutable std::function<const Line * ()> getSuc;\n\t\tbool operator<(const Line& x) const {\n\t\t\tif (isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return true;\n\t\t\t\treturn (suc->a - x.a) * a + suc->b - x.b > 0;\n\t\t\t}\n\t\t\tif (x.isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return false;\n\t\t\t\treturn (suc->a - a) * x.a + suc->b - b < 0;\n\t\t\t}\n\t\t\treturn a < x.a;\n\t\t}\n\t};\n\tbool isbad(const set<Line>::iterator x) {\n\t\tif (x == st.begin() || next(x) == st.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tbool isbad(const vector<Line>::iterator x) {\n\t\tif (x == vec.begin() || next(x) == vec.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tset<Line> st;\n\tvector<Line> vec;\npublic:\n\tConvexHullTrick(bool minormax = false, bool lineMonotone = false) :minOrMax(minormax), lineMonotone(lineMonotone) {}\n\tvoid addLine(int a, int b) {\n\t\tif (minOrMax) {\n\t\t\ta = -a; b = -b;\n\t\t}\n\t\tif (!lineMonotone) {\n\t\t\tauto pos = st.lower_bound({ a,-INF,false });\n\t\t\tif (pos != st.end()) {\n\t\t\t\tif ((*pos).a == a) {\n\t\t\t\t\tif ((*pos).b <= b)return;\n\t\t\t\t\tst.erase(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto ite = st.insert({ a,b,false }).first;\n\t\t\tite->getSuc = [=] {return next(ite) == st.end() ? nullptr : &*next(ite); };\n\t\t\tif (isbad(ite)) {\n\t\t\t\tst.erase(ite);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (next(ite) != st.end() && isbad(next(ite)))st.erase(next(ite));\n\t\t\twhile (ite != st.begin() && isbad(prev(ite)))st.erase(prev(ite));\n\t\t}\n\t\telse {\n\t\t\tif (!vec.empty()) {\n\t\t\t\tif (vec.back().a > a) {\n\t\t\t\t\tcerr << \"Line additions are not monotone\" << endl;\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (vec.back().a == a) {\n\t\t\t\t\tif (vec.back().b <= b)return;\n\t\t\t\t\tvec.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec.push_back({ a,b,false });\n\t\t\tauto ite = --vec.end();\n\t\t\tint index = vec.size() - 1;\n\t\t\tite->getSuc = [this, index] {cout << vec.size() << endl; return index == vec.size() - 1 ? nullptr : &*(vec.begin() + index + 1); };\n\t\t\twhile (ite != vec.begin() && isbad(prev(ite))) {\n\t\t\t\t*prev(ite) = vec.back();\n\t\t\t\tvec.pop_back();\n\t\t\t\tite = --vec.end();\n\t\t\t}\n\t\t}\n\t}\n\tint query(int x) {\n\t\tif (!lineMonotone) {\n\t\t\tauto l = *st.lower_bound(Line{ x, 0,true });\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t\telse {\n\t\t\tauto l = *lower_bound(vec.begin(), vec.end() - 1, Line({ x,0,true }));\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t}\n};\ntemplate<typename T>\nclass Matrix {\n\tint n;\n\tT zero, e;\n\tvector<vector<T>> vec;\n\tvoid letmeasure() {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j)vec[i][j] = zero;\n\t\t\t\telse vec[i][j] = e;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tMatrix(int n, T zero, T e) :n(n), zero(zero), e(e) {\n\t\tvec.resize(n, vector<T>(n));\n\t}\n\tMatrix(int n, T zero, T e, vector<int> vec) :n(n), zero(zero), e(e) {\n\t\tif (vec.size() != n * n) {\n\t\t\tcerr << \"Invalid construct of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tthis->vec.resize(n, vector<T>(n));\n\t\trep(i, n) {\n\t\t\trep(j, n)this->vec[i][j] = vec[i * n + j];\n\t\t}\n\t}\n\tT& operator[](int a) {\n\t\treturn vec[a / n][a % n];\n\t}\n\tunsigned int size() { return n; }\n\tMatrix operator*(const Matrix a) {\n\t\tif (this->n != a.n) {\n\t\t\tcerr << \"Invalid multiply of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> memo(n);\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tmemo[j] += vec[i][k] * a.vec[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec[i] = memo;\n\t\t\tmemo.clear();\n\t\t\tmemo.resize(n);\n\t\t}\n\t\treturn *this;\n\t}\n\tstatic Matrix<T> measure(int n, T zero, T e) {\n\t\tMatrix<T> res(n, zero, e);\n\t\tres.letmeasure();\n\t\treturn res;\n\t}\n};\n\nclass mycomplex {\n\tdouble realvalue, imagvalue;\npublic:\n\tmycomplex() :realvalue(0), imagvalue(0) {}\n\tmycomplex(double realvalue, double imagvalue) : realvalue(realvalue), imagvalue(imagvalue) {}\n\tmycomplex(double realvalue) : realvalue(realvalue), imagvalue(0) {}\n\tmycomplex(complex<double> c) :realvalue(c.real()), imagvalue(c.imag()) {}\n\tmycomplex(const mycomplex& rhs) :realvalue(rhs.realvalue), imagvalue(rhs.imagvalue) {}\n\tdouble real()const { return this->realvalue; }\n\tdouble imag()const { return this->imagvalue; }\n\tdouble abs() { return hypot(realvalue, imagvalue); }\n\tmycomplex& operator=(const mycomplex& obj) {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = obj.realvalue;\n\t\t\tthis->imagvalue = obj.imagvalue;\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator=(mycomplex&& obj)noexcept {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = exchange(obj.realvalue, 0);\n\t\t\tthis->imagvalue = exchange(obj.imagvalue, 0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator+=(const mycomplex& rhs) {\n\t\tthis->realvalue += rhs.realvalue;\n\t\tthis->imagvalue += rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator+(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs += rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator-=(const mycomplex& rhs) {\n\t\tthis->realvalue -= rhs.realvalue;\n\t\tthis->imagvalue -= rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tmycomplex& operator-=(const double& rhs) {\n\t\tthis->realvalue -= rhs;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator-(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs -= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator*=(const mycomplex& rhs) {\n\t\tdouble pastreal = this->realvalue;\n\t\tthis->realvalue = this->realvalue * rhs.realvalue - this->imagvalue * rhs.imagvalue;\n\t\tthis->imagvalue = pastreal * rhs.imagvalue + rhs.realvalue * this->imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator*(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs *= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator/=(const mycomplex& rhs) {\n\t\t*this *= mycomplex(rhs.real(), -rhs.imag());\n\t\tdouble dnm = rhs.real() * rhs.real() - rhs.imag() * rhs.imag();\n\t\tthis->realvalue /= dnm;\n\t\tthis->imagvalue /= dnm;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator/(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs /= rhs;\n\t\treturn lhs;\n\t}\n};\nclass FastFourierTransform {\nprivate:\n\tstatic void dft(vector<mycomplex>& func, int inverse) {\n\t\tint sz = func.size();\n\t\tif (sz == 1)return;\n\t\tvector<mycomplex> veca, vecb;\n\t\trep(i, sz / 2) {\n\t\t\tveca.push_back(func[2 * i]);\n\t\t\tvecb.push_back(func[2 * i + 1]);\n\t\t}\n\t\tdft(veca, inverse); dft(vecb, inverse);\n\t\tmycomplex now = 1, zeta = polar(1.0, inverse * 2.0 * acos(-1) / sz);\n\t\trep(i, sz) {\n\t\t\tfunc[i] = veca[i % (sz / 2)] + now * vecb[i % (sz / 2)];\n\t\t\tnow *= zeta;\n\t\t}\n\t}\npublic:\n\ttemplate<typename T>\n\tstatic vector<double> multiply(vector<T> f, vector<T> g) {\n\t\tvector<mycomplex> nf, ng;\n\t\tint sz = 1;\n\t\twhile (sz < f.size() + g.size())sz *= 2;\n\t\tnf.resize(sz); ng.resize(sz);\n\t\trep(i, f.size()) {\n\t\t\tnf[i] = f[i];\n\t\t\tng[i] = g[i];\n\t\t}\n\t\tdft(nf, 1);\n\t\tdft(ng, 1);\n\t\trep(i, sz)nf[i] *= ng[i];\n\t\tdft(nf, -1);\n\t\tvector<double> res;\n\t\trep(i, sz)res.push_back(nf[i].real() / sz);\n\t\treturn res;\n\t}\n};\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef gp_hash_table<long long, long long> umap;\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (long long i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (long long i = (n) - 1; i >= 0; i--)\n#define foreach(it,ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar,val) memset(ar, val, sizeof(ar))\n#define fill0(ar) fill((ar), 0)\n#define fillinf(ar, n) fr(i,0,(n)) ar[i] = INF\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define arr1d(a,n) cout << #a << \" : \"; fr(_,1,n) cout << a[_] << ' '; cout << endl;\n#define arr1d0(a,n) cout << #a << \" : \"; rep(_,n) cout << a[_] << ' '; cout << endl;\n#define arr2d(a,n,m) cout << #a << \" :\" << endl; fr(_,1,n) {fr(__,1,m) cout << a[_][__] << ' '; cout << endl;}\n#define arr2d0(a,n,m) cout << #a << \" :\" << endl; rep(_,n) {rep(__,m) cout << a[_][__] << ' '; cout << endl;}\n/*Author Ritick Goenka || ritick(codechef) ||ritick(codeforces) */\n/*IIT Roorkee = <3 */\n#define ull unsigned long long\n#define ll long long\n#define ld double\n#define ui unsigned int\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define y0 yyyyyy0\n#define y1 yyyyyy1\n#define sot(bello) bello.begin(),bello.end()\n#define BIT(n) (1<<(n))\n#define SQR(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n#define LSOne(S) (S) & (-S)\ninline bool EQ(double a, double b) {return fabs(a - b) < 1e-9;}\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\n\ntemplate<typename T>inline T gcd(T a, T b){if (b == 0)return a;else return gcd(b, a % b);}\ntemplate<typename T>inline T lcm(T a, T b){return (a * b) / gcd(a, b);}\ntemplate<typename T> string toStr(T x) {stringstream st; st << x; string s; st >> s; return s;}\ntemplate<class T>\nvoid splitStr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ninline int two(int n) {return 1 << n;}\ninline int isOnBit(int n, int b) {return (n >> b) & 1;}\ninline void onBit(int & n, int b) {n |= two(b);}\ninline void offBit(int & n, int b) {n &= ~two(b);}\ninline int lastBit(int n) {return n & (-n);}\ninline int cntBit(int n) {int res = 0; while(n && ++res) n -= n &(-n); return res;}\n\nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy8[] = {0, 1, 0, -1, -1, 1, -1, 1};\n\n#define INP \"test.inp\"\n#define OUT \"test.out\"\n\n#define PI 3.1415926535897932385\n#define INF 1000000000000000\n#define EPS 1e-7\n#define MAXN 100000\n#define MOD 998244353\n#define dec decr\n//END OF COMPETITVE PROGRAMMING TEMPLATE\nll gcd(ll a, ll b) \n{ \n    if (a == 0) \n        return b; \n    return gcd(b % a, a); \n} \nll modexp(ll x, ll y, ll p)\n{\n    ll res = 1;   \n    x = x % p;  \n    while (y > 0)\n    {\n        if (y & 1)    \n            res = (res*x) % p;\n        y = y>>1;     \n        x = (x*x) % p; \n    }\n    return res;\n}\nll dp[6005][6005];\nll r[6005];\nll b[6005];\nll n1;\nll fn(ll br,ll bb)\n{\n    // debug(br);\n    // debug(bb);\n    if(br<0||bb<0)\n        return 0;\n    ll n=br+bb;\n    if((br<r[n]||bb<b[n]))\n        return 0;\n    if(dp[br][bb]!=-1)\n        return dp[br][bb];\n    return dp[br][bb]=(fn(br-1,bb)+fn(br,bb-1))%MOD;\n\n}\n\nint main () \n{\n\tios_base::sync_with_stdio(false);\n            cin.tie(NULL);\n\t    cout<<setprecision(11);\n            string s;\n            cin>>s;\n            ll x=0;\n            ll rc=0,bc=0;\n            rep(i,3005)\n            {\n                rep(j,3005)\n                    dp[i][j]=-1;\n            }\n            ll n=s.length();\n            // debug(n);\n            n1=n;\n            dp[0][0]=1;\n            rep(i,n)\n            {\n                if(s[i]=='0')\n                    rc++;\n                if(s[i]=='2')\n                    bc++;\n                r[i+1]=max(r[i],rc-bc);\n                b[i+1]=max(b[i],bc-rc);\n            }\n            rep(i,n)\n            {\n                // debug(r[i+1]);\n                // debug(b[i+1]);\n\n                r[n+i]=r[n+i-1];\n                b[n+i]=b[n+i-1];\n            }\n            // debug(n-bc+rc);\n            // debug(n);\n            cout<<fn(n-bc+rc,n-rc+bc);\n            return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nll mo=998244353;\nll dp[4020][4020];\nint NR[2020],NB[2020];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S;\n\tN=S.size();\n\tFOR(i,N) {\n\t\tNR[i+1]=NR[i]+('2'-S[i]);\n\t\tNB[i+1]=NB[i]+(S[i]-'0');\n\t}\n\tdp[0][0]=1;\n\tfor(int r=0;r<=NR[N];r++) {\n\t\tfor(int b=0;b<=NB[N];b++) if(dp[r][b]) {\n\t\t\tint nr=NR[min(N,r+b)];\n\t\t\tint nb=NB[min(N,r+b)];\n\t\t\tif(r+b<N && S[r+b]!='2') nr++;\n\t\t\tif(r+b<N && S[r+b]!='0') nb++;\n\t\t\t\n\t\t\tif(nr>r) (dp[r+1][b]+=dp[r][b])%mo;\n\t\t\tif(nb>b) (dp[r][b+1]+=dp[r][b])%mo;\n\t\t}\n\t}\n\t\n\tcout<<dp[NR[N]][NB[N]]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <memory>\n#include <complex>\n#include <numeric>\n#include <cstdio>\n#include <iomanip>\n\n#define REP(i,m,n) for(int i=int(m);i<int(n);i++)\n#define RREP(i,m,n) for(int i=int(n)-1;i>=int(m);--i)\n#define EACH(i,c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n#ifdef LOCAL\n#define DEBUG(s) cout << (s) << endl\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define BR cout << endl;\n#else\n#define DEBUG(s) do{}while(0)\n#define dump(x) do{}while(0)\n#define BR \n#endif\nusing namespace std;\n\nusing UI = unsigned int;\nusing UL = unsigned long;\nusing LL = long long int;\nusing ULL = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VLL = vector<LL>;\nusing VVLL = vector<VLL>;\nusing VS = vector<string>;\nusing PII = pair<int,int>;\nusing VP = vector<PII>;\n\n//struct edge {int from, to, cost;};\n\nconstexpr double EPS = 1e-10;\n//constexpr double PI  = acos(-1.0);\n//constexpr int INF = INT_MAX;\nconstexpr LL MOD = 998244353;\n//inline void modAdd(LL &l, LL &r) {l = (l + r) % MOD;}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\nLL dfs(int n, int blue, VI &ru, VVLL &memo) {\n    if (n <= 0 || blue < 0) return 0;\n    //cout << n << \" \" << blue << \" \" << ru[min((int)ru.size()-1,n)] << \" \" << memo[n][blue] << endl;\n    if (memo[n][blue] > -1) return memo[n][blue];\n    if (n <= ru.size()) {\n        if (blue > ru[n-1]) return memo[n][blue] = 0;\n        if (n - blue > 2 * n - ru[n-1]) return memo[n][blue] = 0;\n    } else {\n        int maxb = ru[ru.size()-1];\n        if (blue > maxb) return memo[n][blue] = 0;\n        if (n - blue > 2 * ru.size() - maxb) return memo[n][blue] = 0;\n    }\n    if (n == 1) return memo[n][blue] = 1;\n    return memo[n][blue] = (dfs(n-1, blue - 1, ru, memo) + dfs(n-1, blue, ru, memo)) % MOD;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    VI ru(n);\n    ru[0] = s[0] - '0';\n    REP(i,1,n) ru[i] = ru[i-1] + s[i] - '0';\n    VVLL memo(2*n+1, VLL(2*n+1, -1));\n    cout << dfs(2*n,ru[n-1],ru,memo) << endl;\n}\n\nint main() {\n    solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 998244353;\n\nint n;\nchar buf[2000+10];\nint trs[10000];\nint crs[10000];\nint tbs[10000];\nint cbs[10000];\n\ninline int calcMaxR(int turn) {\n  return crs[turn+1];\n}\ninline int calcMaxB(int turn) {\n  return cbs[turn+1];\n}\n\nll memo[4010][4010];\nll solve(int pos, int r) {\n  ll &res = memo[pos][r];\n  if(res < 0) {\n    if(pos == n*2) {\n      res = 1;\n    } else {\n      res = 0;\n      if(calcMaxR(pos) >= r+1) {\n        res += solve(pos+1, r+1);\n      }\n      if(calcMaxB(pos) >= pos-r+1) {\n        res = (res + solve(pos+1, r)) % MOD;\n      }\n    }\n  }\n  return res;\n}\n\nint main(void) {\n  scanf(\"%s\", buf);\n  n = strlen(buf);\n  REP(i, n) {\n    if(buf[i] == '0') {\n      trs[i] = 2;\n    } else if(buf[i] == '1') {\n      trs[i] = 1;\n      tbs[i] = 1;\n    } else if(buf[i] == '2') {\n      tbs[i] = 2;\n    } else {\n      assert(false);\n    }\n  }\n  REP(i, 2*n) {\n    if(trs[i] > 1) {\n      trs[i+1] += trs[i]-1;\n      trs[i] = 1;\n    }\n    crs[i+1] = crs[i] + trs[i];\n    if(tbs[i] > 1) {\n      tbs[i+1] += tbs[i]-1;\n      tbs[i] = 1;\n    }\n    cbs[i+1] = cbs[i] + tbs[i];\n  }\n  \n  memset(memo, -1, sizeof memo);\n  ll res = solve(0, 0);\n  \n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 998244353>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N;\nstd::string S;\nbool used[5000][5000];\nmint dp[5000][5000];\nmint func(int32_t i, int32_t r, int32_t b)\n{\n\tif (i == 2 * N) {\n\t\treturn 1_mi;\n\t}\n\tif (b<0) {\n\t\treturn 0_mi;\n\t}\n\tif (r < 0) {\n\t\treturn 0_mi;\n\t}\n\tauto& memo = dp[i][r];\n\tif (used[i][r]) {\n\t\treturn memo;\n\t}\n\tused[i][r] = true;\n\tif (i < N) {\n\t\tif (S[i] == '0') {\n\t\t\tr += 2;\n\t\t}\n\t\telse if (S[i] == '1') {\n\t\t\tr += 1;\n\t\t\tb += 1;\n\t\t}\n\t\telse {\n\t\t\tb += 2;\n\t\t}\n\t}\n\treturn memo = func(i + 1, r, b - 1) + func(i + 1, r - 1, b);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> S;\n\tN = S.size();\n\tout << func(0,0,0)/2 << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\nconst ll MOD = 998244353ll;\n\nint main() {\n  string S;\n  while (cin >> S) {\n    int N = S.size();\n    vector<ll> dp(N + 10, 0ll);\n    dp[0] = 1;\n    int sr = 0, sb = 0;\n    for (int i = 0; i < 2 * N; i++) {\n      if (i < N) {\n        if (S[i] == '0') {\n          sr += 2;\n        } else if (S[i] == '1') {\n          sr += 1;\n          sb += 1;\n        } else {\n          sb += 2;\n        }\n      }\n      vector<ll> ndp(N + 10, 0ll);\n      for (int r = 0; r <= i; r++) {\n        int b = i - r;\n        if (sr - r > 0) {\n          (ndp[r + 1] += dp[r]) %= MOD;\n        }\n        if (sb - b > 0) {\n          (ndp[r] += dp[r]) %= MOD;\n        }\n      }\n      dp.swap(ndp);\n    }\n    cout << dp[sr] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=4005;\nconst int mod=998244353;\nint n,cnt1,cnt2;\nstring s;\nchar c[maxn];\nint dp[maxn][maxn],id1[maxn],id2[maxn];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tc[0]='a';scanf(\"%s\",c+1);n=strlen(c)-1;\n\tREP(i,n){\n\t\tif(c[i]=='0')id1[++cnt1]=i,id1[++cnt1]=i;\n\t\telse if(c[i]=='1')id1[++cnt1]=i,id2[++cnt2]=i;\n\t\telse id2[++cnt2]=i,id2[++cnt2]=i;\n\t}\n\tdp[0][0]=1;\n\trep(i,2*n)rep(j,min(i,cnt1)+1){\n\t\tint cur=dp[i][j],k=i-j;\n\t\tif(j+1<=cnt1&&id1[j+1]<=i+1)dp[i+1][j+1]=(dp[i+1][j+1]+cur)%mod;\n\t\tif(k+1<=cnt2&&id2[k+1]<=i+1)dp[i+1][j]=(dp[i+1][j]+cur)%mod;\n\t}\n\tprintf(\"%d\\n\",dp[2*n][cnt1]);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n\nconst int mod = 998244353;\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< mod >;\nvoid comb(modint *c, ll n){\n  c[0] = 1;\n  rep1(i,n){\n    c[i] = c[i-1]*((modint) n+1-i)/((modint) i);\n  }\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  vector<vector<modint> > dp(n+1,vector<modint>(4*n+1,0));\n  rep(i,n){\n    rep(j,4*n){\n      int red = (j - n*2 + i);\n      int blue = (-(j-2*n)+i);\n      if(red>=0 && blue>=0){        \n        red/=2;blue/=2;\n        if(red+blue!=i) continue;\n        // cout << \"i red blue \" << i << \" \" << red << \" \"<< blue << endl;\n        int nred,nblue;\n        if(s[i]=='0'){\n          if(i!=0) {\n            dp[i][red+1-blue+2*n] += dp[i-1][j];\n            if(blue>0){\n              dp[i][red+2-(blue-1)+2*n] += dp[i-1][j];\n            }\n          }\n          else dp[i][j+1] += 1;\n        }\n        else if(s[i]=='1'){\n          if(i!=0){\n            dp[i][j+1] += dp[i-1][j];\n            dp[i][j-1] += dp[i-1][j];\n          }\n          else{\n            dp[i][j+1] += 1;\n            dp[i][j-1] += 1;\n          }\n        }\n        else if(s[i]=='2'){\n          if(i!=0){\n            dp[i][j-1] += dp[i-1][j];\n            if(red>0) dp[i][red-1-(blue+2)+2*n] += dp[i-1][j];\n          }\n          else dp[i][j-1] += 1;\n        }\n      }\n    }\n  }\n  // vector<modint> fact(n+1,1);\n  // vector<modint> inv(n+1,1);\n  // fact[0]=1;\n  // rep1(i,n) fact[i] = fact[i-1]*i;\n  // rep(i,n+1) inv[i] = ((modint) 1)/fact[i];\n  // vector<modint> comb(n+1);\n  // rep(i,n+1) comb[i] = fact[n]*inv[i]*inv[n-i];\n\n  modint C[n + 1];\n  comb(C, n);\n\n  modint ans =0;\n  rep(i,4*n){\n    // if(dp[n-1][i]!=0) cout << i <<\" \"<< dp[n-1][i] << endl;\n    int red = (i-n*2+n)/2;\n    int blue = (-(i-2*n)+n)/2;\n    ans += C[red]*dp[n-1][i];\n  }\n  cout << ans << endl;\n  \n  return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(Int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(Int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(Int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(Int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(Int n,Int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(Int n,Int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(Int n,Int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(Int n,Int k){\n    Mint res;\n    init(k);\n    for(Int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(Int n,Int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(Int n,Int k){\n    Mint res;\n    for(Int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(Int n){\n    Mint res;\n    init(n);\n    for(Int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    Int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(Int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(Int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nusing M = Mint<Int, 998244353>;\nconst Int MAX = 4040;\nM dp[2][MAX][MAX];\nInt ri[MAX],ra[MAX];\nInt n;\n\n\n\nsigned main(){\n  string s;\n  cin>>s;\n  n=s.size();\n  {\n    vector<Int> cnt(n,0);\n    for(Int i=0;i<n;i++) cnt[i]=2-(s[i]-'0');\n    for(Int i=0;i<=n*2;i++){\n      ra[i]=cnt[0];\n      if(i==n*2) break;\n      for(Int j=1;j<n;j++)\n        if(cnt[j]) cnt[j-1]++,cnt[j]--;\n    }\n  }\n  {\n    vector<Int> cnt(n,0);\n    for(Int i=0;i<n;i++) cnt[i]=s[i]-'0';\n    for(Int i=0;i<=n*2;i++){\n      ri[i]=min(2+i,n*2)-cnt[0];      \n      if(i==n*2) break;\n      for(Int j=1;j<n;j++)\n        if(cnt[j]) cnt[j-1]++,cnt[j]--;\n    }\n  }\n  if(ra[n*2]==0){\n    cout<<1<<endl;\n    return 0;\n  }\n  dp[0][0][0]=1;\n  for(Int i=0;i<n*2;i++){\n    for(Int j=0;j<=i;j++){\n      //cout<<i<<\" \"<<j<<endl;\n      //cout<<dp[0][i][j].v<<endl;\n      //cout<<dp[1][i][j].v<<endl;\n      Int x=ra[i]-j;\n      Int y=(min(2+i,n*2)-ri[i])-(i-j);\n      if(x<0||y<0) continue;\n      // red\n      if(x){\n        dp[x==1][i+1][j+1]+=dp[0][i][j];\n        dp[1][i+1][j+1]+=dp[1][i][j];\n      }\n      // blue\n      if(y){\n        dp[0][i+1][j]+=dp[0][i][j];\n        dp[1][i+1][j]+=dp[1][i][j];\n      }\n    }    \n  }\n  //cout<<ra[n*2]<<\" \"<<ri[n*2]<<endl;\n  cout<<dp[1][n*2][ra[n*2]].v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nconst ll MOD = 998244353;\nll dp[2010][2010];\nll cntr[4010];\nll cntb[4010];\n\nint main() {\n    string S;\n    cin >> S;\n    dp[0][0] = 1;\n    for(ll i = 0; i < S.size(); i++){\n        char c = S[i];\n        cntr[i + 1] = cntr[i] + 2 * (c == '0') + (c == '1'); \n        cntb[i + 1] = cntb[i] + 2 * (c == '2') + (c == '1');\n    }\n    for(ll i = S.size(); i < 4010; i++){\n        cntr[i + 1] = cntr[i];\n        cntb[i + 1] = cntb[i];\n    }\n    for(ll i = 1; i <= 2 * S.size(); i++){\n        for(ll r = 0; r <= min(i, cntr[i]); r++){\n            ll b = i - r;\n            if(b > cntb[i]) continue;\n            if(r > 0) dp[r][b] += dp[r - 1][b];\n            if(b > 0) dp[r][b] += dp[r][b - 1];\n            dp[r][b] %= MOD;\n        }\n    }\n    cout << dp[cntr[4010 - 1]][cntb[4010 - 1]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma gcc optimize(\"Ofast\")\n\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef int64_t lld;\ntypedef pair<int,int> pii;\ntypedef pair<lld,lld> pll;\ntypedef pair<int,pll> pip;\ntypedef pair<pll,int> ppi;\ntypedef pair<lld,pll> plp;\ntypedef pair<pll,lld> ppl;\ntypedef pair<pll,pll> ppp;\ntemplate<typename T>\nusing maxHeap = priority_queue<T,vector<T>,less<T>>;\ntemplate<typename T>\nusing minHeap = priority_queue<T,vector<T>,greater<T>>;\n#define ff first\n#define ss second\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define endl '\\n'\n#define jizz cin.tie(0);cout.tie(0);ios::sync_with_stdio(0);\ninline void input(int &_x) {\n    _x = 0;\n    int _tmp = 1; char _tc = getchar();\n    while((_tc < '0' || _tc > '9') && _tc != '-') _tc = getchar();\n    if(_tc == '-') _tc = getchar(), _tmp = -1;\n    while(_tc >= '0' && _tc <= '9') _x = _x*10+(_tc-48), _tc = getchar();\n    _x *= _tmp;\n}\ninline void output(int _x) {\n    char _buff[20]; int _f = 0;\n    if(_x == 0)putchar('0');\n    while(_x > 0)\n    {\n        _buff[_f++] = _x%10+'0';\n        _x /= 10;\n    }\n    for(_f-=1; _f >= 0; _f--)\n        putchar(_buff[_f]);\n    putchar('\\n');\n}\ntemplate<typename Iter>\nostream& _out(ostream &s, Iter b, Iter e) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\ntemplate<class T1,class T2>\nostream& operator<<(ostream& out, pair<T1,T2> p) {\n    return out << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) {\n     return _out(s,c.begin(),c.end());\n }\n#ifdef erd1\n    #define pprint(x) cerr<<__PRETTY_FUNCTION__<<\":\"<<__LINE__<<\" - \"<<(#x)<<\"=\"<<(x)<<endl\n#else\n    #define pprint(x)\n#endif\n\n// code starts here\nvector<int> dp;\nvoid M(int& a){ if(a>998244353) a-=998244353; }\nsigned main(){\n    string s;\n    cin >> s;\n    int n = s.size(), curb=0;\n    dp.resize(2*n+1);\n    dp[0] = 1;\n    for(int i = 0, curr = 0; i < 2*n; i++){\n        if(i<n)curb += s[i]-'0', curr+='2'-s[i];\n        for(int j = 2*n; j >= 0; j--){\n            int cur = dp[j];\n            if(!(curr>i-j)) dp[j]=0;\n            if(curb>j) M(dp[j+1]+=cur);\n        }\n    }\n    cout << dp[curb] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\n//ll MOD = 1000000007;\nll MOD = 998244353;\n//vector<mint> dp(N, Mint);\n//vector<vector<mint>> dp2(N, vector<mint>(N, Mint));\n//vector<vector<vector<mint>>> dp3(N, vector<vector<mint>>(N, vector<mint>(N, Mint)));\nstruct mint{\n  ll x;\n  mint(ll x=0):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i);\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n//第二種スターリング数\nconst ll MAXStir2 = 3010;\nvector<vector<mint>> Stir2memo(MAXStir2, vector<mint>(MAXStir2, Mint));\nvector<mint> Bellmemo(MAXStir2, Mint);\nvoid Stir2init(){\n  Stir2memo[0][0] = 1;\n  rep(i, MAXStir2-1)rep(j, i+1)Stir2memo[i+1][j+1] = Stir2memo[i][j] + Stir2memo[i][j+1] * (j+1);\n  rep(i, MAXStir2){\n    Bellmemo[i] = 0;\n    rep(j,i+1) Bellmemo[i] += Stir2memo[i][j];\n  }\n}\nmint Stir2(ll i, ll j){//区別できるi個をjグループに分ける場合の数\n  if(i < 0 || j < 0 || i < j) return 0;\n  return Stir2memo[i][j];\n}\nmint Bell(ll x){//区別できるx個をグループ分けする方法全ての場合の数\n  if(x < 0) return 0;\n  return Bellmemo[x];\n}\nmint kai_mod(ll K){\n  if(K < 0) return 0;\n  if(K == 0) return 1;\n  return kai_mod(K-1) * K;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\n\n//Range Sum Query\nconst ll N_ = (1 << 18);\nll seg[2*N_-1];\n//未確認\nvoid add(ll k, ll x){\n  k += N_-1;\n  seg[k] += x;\n  while(k > 0){\n    k = (k-1)/2;\n    seg[k] = seg[2*k+1] + seg[2*k+2];\n  }\n}\n\nll get_sum(ll x, ll y, ll k = 0, ll left = 0, ll right = N_){\n  if(right <= x || y <= left) return 0;\n  if(x <= left && right <= y) return seg[k];\n  ll mid = (left + right) / 2;\n  ll l = get_sum(x, y, 2*k+1, left, mid);\n  ll r = get_sum(x, y, 2*k+2, mid, right);\n  return l + r;\n}\n\nmint dp[4010][4010];\nll N;\nll B;\nvoid solve(){\n  dp[0][0] = 1;//i番目まで見て、青をj個使った\n  for(ll i = 0; i < 2*N; i++){\n    ll can_use_blue = get_sum(0, i+1);\n    ll can_use_red = 2 * (i+1) - can_use_blue;\n    for(ll j = 0; j <= B; j++){\n      if(can_use_blue >= j+1){\n        dp[i+1][j+1] += dp[i][j];\n      }\n      if(can_use_red >= i+1-j ){\n        dp[i+1][j] += dp[i][j];\n      }\n    }\n  }\n\n  dp[2*N][B].get();\n}\n\nint main(){\n  string S;\n  cin >> S;\n  N = S.size();\n  rep(i, N){\n    if(S[i] == '2') add(i, 2);\n    if(S[i] == '1') add(i, 1);\n  }\n  B = get_sum(0, N_);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  int mb = 0, mr = 0;\n  rep (i, n) {\n    if (s[i] == '0') mr += 2;\n    else if (s[i] == '1') {mr++; mb++;}\n    else {mb += 2;}\n  }\n  vll dp(mr + 1, vl(mb + 1));\n  dp[0][0] = 1;\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (dp[i][j] == 0) continue;\n      if (i > mr || j > mb) continue;\n      int b = 0, r = 0;\n      if (s[can] == '0') {\n        r = 2;\n      }\n      else if (s[can] == '1') {\n        r = b = 1;\n      }\n      else if (s[can] == '2') {\n        b = 2;\n      }\n      int ni = i + r, nj = j + b;\n      if (ni > 0) {\n        (dp[ni - 1][nj] += dp[i][j]) %= MOD;\n      }\n      if (nj > 0) {\n        (dp[ni][nj - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      dp[i][j] = 0;\n    }\n  }\n  for (int can = n; can > 0; can--) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (dp[i][j] == 0) continue;\n      if (i > mr || j > mb) continue;\n      if (i > 0) {\n        (dp[i - 1][j] += dp[i][j]) %= MOD;\n      }\n      if (j > 0) {\n        (dp[i][j - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\nconst ll mod = 998244353;\nint n;\nint a[2000];\n\nint main(){\n  string s;\n  cin >> s;\n\n  n = s.size();\n  REP(i,n) a[i] = s[i] - '0';\n\n  vector<ll> dp(n + n + 1);\n  dp[a[0]] = 1;\n\n  REP(i,n+n){\n    const int tot = 2 * min(i + 1, n) - i;\n    const int add = (i + 1 < n) ? a[i + 1] : 0;\n    //printf(\"%d %d\\n\", tot, add);\n\n    vector<ll> next(n + n + 1);\n    REP(j,n+n+1){\n      if(j > 0) next[j + add - 1] = (next[j + add - 1] + dp[j]) % mod;\n      if(j != tot) next[j + add] = (next[j + add] + dp[j]) % mod;\n    }\n\n    dp.swap(next);\n    //REP(j,n+n+1) printf(\"%lld \", dp[j]); puts(\"\");\n  }\n\n  printf(\"%lld\\n\", dp[0]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nconst int N = 4e3+15;\n\nint dp[N][N];\n\nint a[N],b[N];\n\nconst int mod = 998244353;\n\nint add(int x,int y){\n\treturn (x+y)%mod;\n}\nint solveDp(int x,int y,int apos,int bpos){\n\tif(x==apos && y==bpos){\n\t\treturn 1;\n\t}\n\tint &ret = dp[x][y];\n\tif(ret!=-1){\n\t\treturn ret;\n\t}\n\tint ind = x+ y;\n\tret = 0;\n\tif(x<apos && a[x]<=ind){\n\t\tret = add(ret, solveDp(x+1,y,apos,bpos));\n\t}\n\tif(y<bpos && b[y]<=ind){\n\t\tret = add(ret, solveDp(x,y+1,apos,bpos));\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint n;\n\tstring s;\n\tcin>>s;\n\tn = s.size();\n\tint apos = 0,bpos = 0;\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0;i<n;++i){\n\t\tif(s[i]=='1'){\n\t\t\ta[apos++] = i;\n\t\t\tb[bpos++] = i;\n\t\t} else if(s[i]=='0'){\n\t\t\ta[apos++] = i;\n\t\t\ta[apos++] = i;\n\t\t} else {\n\t\t\tb[bpos++] = i;\n\t\t\tb[bpos++] = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", solveDp(0,0,apos,bpos));\n}\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\nconst int MAX = 210000;\nconst int MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAX; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nlong long COM(int n, int k){\n    if(n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\n\n\nstring S;\nlong long dp[5100][5100];\nint sumr[5100];\n\nint main() {\n    COMinit();\n    while (cin >> S) {\n        int N = S.size();\n\n        sumr[0] = 0;\n        for (int i = 0; i < N; ++i) {\n            int num = 0;\n            if (S[i] == '0') num += 2;\n            else if (S[i] == '1') num += 1;\n            sumr[i+1] = sumr[i] + num;\n        }\n        \n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        for (int i = 0; i < N; ++i) {\n            for (int r = 0; r <= i; ++r) {\n                if (dp[i][r] == 0) continue;\n                if (sumr[i+1] >= r + 1) {\n                    dp[i+1][r+1] += dp[i][r];\n                    dp[i+1][r+1] %= MOD;\n                }\n                if ((i+1)*2 - sumr[i+1] >= i + 1 - r) {\n                    dp[i+1][r] += dp[i][r];\n                    dp[i+1][r] %= MOD;\n                }\n            }\n        }\n\n        long long res = 0;\n        for (int r = 0; r <= N; ++r) {\n            res += dp[N][r] * COM(N, sumr[N] - r) % MOD;\n            res %= MOD;\n        }\n\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntemplate<typename T, int FAC_MAX> struct Comb {\n    vector<T> fac, ifac;\n    Comb() {\n        fac.resize(FAC_MAX, 1); ifac.resize(FAC_MAX, 1); rep(i, 1, FAC_MAX)fac[i] = fac[i - 1] * i;\n        ifac[FAC_MAX - 1] = T(1) / fac[FAC_MAX - 1]; rrep(i, FAC_MAX - 2, 1)ifac[i] = ifac[i + 1] * T(i + 1);\n    }\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) {\n        if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k);\n    }\n}; // nHk = (n+k-1)Ck : n is separator\ntypedef ModInt<998244353> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nstring S;\nmint dp[4040][4040];\nint N;\nComb<mint, 201010> com;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S;\n    N = S.length();\n\n    dp[0][0] = 1;\n    int R = 0, B = 0;\n    rep(i, 0, N) {\n        if (S[i] == '0') R += 2;\n        else if (S[i] == '1') {\n            R++;\n            B++;\n        }\n        else B += 2;\n\n\n        rep(r, 0, i + 1) {\n            if (S[i] == '0') {\n                dp[i + 1][r + 1] += dp[i][r];\n\n                int b2 = i - r;\n                if (0 < B - b2) dp[i + 1][r] += dp[i][r];\n            }\n            else if (S[i] == '1') {\n                dp[i + 1][r + 1] += dp[i][r];\n                dp[i + 1][r] += dp[i][r];\n            }\n            else {\n                dp[i + 1][r] += dp[i][r];\n\n                int r2 = r;\n                if (0 < R - r2) dp[i + 1][r + 1] += dp[i][r];\n            }\n        }\n    }\n\n    mint ans = 0;\n    \n    rep(r, 0, N + 1) {\n        int rr = R - r;\n        int bb = B - (N - r);\n\n        ans += dp[N][r] * com.aCb(rr + bb, rr);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nint read() {\n\tint x; cin >> x; return x;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nclass UnionFind {\nprotected:\n\tint* par, * rank, * size;\npublic:\n\tUnionFind(unsigned int size) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tthis->size = new int[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tthis->size[i] = 1;\n\t\t}\n\t}\n\tint find(int n) {\n\t\tif (par[n] == n)return n;\n\t\treturn par[n] = find(par[n]);\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m)return;\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tsize[m] += size[n];\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tsize[n] += size[m];\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t}\n\tbool same(int n, int m) {\n\t\treturn find(n) == find(m);\n\t}\n\tint getsize(int n) {\n\t\treturn size[find(n)];\n\t}\n};\nclass PerpetualUnionFind :UnionFind {\n\tP* notparent;\n\tvector<P>* sizevec;\n\tint opcount = 0;\npublic:\n\tPerpetualUnionFind(unsigned int size) :UnionFind(size) {\n\t\tthis->sizevec = new vector<P>[size];\n\t\tnotparent = new P[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsizevec[i].push_back(make_pair(-1, 1));\n\t\t\tnotparent[i] = make_pair(INF, i);\n\t\t}\n\t}\n\tint find(int n, int t = INF) {\n\t\tif (opcount <= t) {\n\t\t\tif (par[n] == n)return n;\n\t\t\treturn par[n] = find(par[n]);\n\t\t}\n\t\tif (notparent[n].first <= t)return find(notparent[n].second, t);\n\t\treturn n;\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m) {\n\t\t\topcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tnotparent[n] = make_pair(opcount, m);\n\t\t\tsizevec[m].push_back(make_pair(opcount, sizevec[m].back().second + sizevec[n].back().second));\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tnotparent[m] = make_pair(opcount, n);\n\t\t\tsizevec[n].push_back(make_pair(opcount, sizevec[n].back().second + sizevec[m].back().second));\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t\topcount++;\n\t}\n\tbool same(int n, int m, int t = INF) {\n\t\treturn find(n, t) == find(m, t);\n\t}\n\tint getsize(int n, int t = INF) {\n\t\tn = find(n, t);\n\t\tauto ite = lower_bound(sizevec[n].begin(), sizevec[n].end(), make_pair(t, (int)0));\n\t\tif (ite == sizevec[n].end())ite--;\n\t\tif (t < (*ite).first)ite--;\n\t\treturn (*ite).second;\n\t}\n};\nclass RollingHash {\n\tstring s;\n\tint n, m;\n\tmodInt base;\n\tvector<modInt> has, power;\npublic:\n\tRollingHash(string s, int m, int b) : n(s.size()), m(m), base(b, m) { init(s, m, b); }\n\tvoid init(string s, int m, int b) {\n\t\tn = s.size();\n\t\thas.resize(n);\n\t\tpower.resize(n);\n\t\tbase = modInt(b, m);\n\t\tthis->s = s;\n\t\tthis->m = m;\n\t\trep(i, n) {\n\t\t\thas[i] = modInt(s[i], m);\n\t\t\tif (i) {\n\t\t\t\thas[i] += base * has[i - 1];\n\t\t\t\tpower[i] = power[i - 1] * base;\n\t\t\t}\n\t\t\telse power[i] = 1;\n\t\t}\n\t}\n\toperator int() const {\n\t\treturn has.back();\n\t}\n\tint query(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\treturn has[b - 1] - power[b - a] * (!a ? modInt(0) : has[a - 1]);\n\t}\n\tRollingHash& operator+=(string t) {\n\t\ts += t;\n\t\thas.resize(n + t.size());\n\t\tpower.resize(n + t.size());\n\t\tfor (int i = n; i < n + t.size(); i++) {\n\t\t\thas[i] = modInt(t[i] * base, m);\n\t\t\thas[i] += base * has[i - 1];\n\t\t\tpower[i] = power[i - 1] * base;\n\t\t}\n\t\tn += t.size();\n\t\treturn *this;\n\t}\n};\ntemplate<typename T, typename U>\nclass SegTree {\n\tint n = 1;\n\tT* node = NULL;\n\tU* lazy = NULL;\n\tbool* lazyflag = NULL;\n\tT nodee;\n\tfunction<T(T, T)> nodef;\n\tfunction<U(U, U)> lazyf;\n\tfunction<T(int, T, U)> updf;\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazyflag[k]) {\n\t\t\tnode[k] = updf(r - l, node[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tif (lazyflag[2 * k + 1])lazy[2 * k + 1] = lazyf(lazy[2 * k + 1], lazy[k]);\n\t\t\t\telse lazy[2 * k + 1] = lazy[k];\n\t\t\t\tif (lazyflag[2 * k + 2])lazy[2 * k + 2] = lazyf(lazy[2 * k + 2], lazy[k]);\n\t\t\t\telse lazy[2 * k + 2] = lazy[k];\n\t\t\t\tlazyflag[2 * k + 1] = lazyflag[2 * k + 2] = true;\n\t\t\t}\n\t\t\tlazyflag[k] = false;\n\t\t}\n\t}\npublic:\n\tSegTree(int m, int init, T nodee, function<T(T, T)> nodef, function<U(U, U)> lazyf, function<T(int, T, U)> updf) :nodee(nodee), nodef(nodef), lazyf(lazyf), updf(updf) {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t\twhile (n < m)n *= 2;\n\t\tnode = new T[2 * n], lazy = new U[2 * n], lazyflag = new bool[2 * n];\n\t\trep(i, 2 * n) {\n\t\t\tnode[i] = init;\n\t\t\tlazyflag[i] = false;\n\t\t}\n\t}\n\t~SegTree() {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t}\n\tvoid update(int a, int b, U x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazyflag[k] = true;\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = nodef(node[2 * k + 1], node[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return nodee;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn nodef(vl, vr);\n\t}\n};\ntemplate<typename T>\nclass RAQRSQ :public SegTree<T, T> {\npublic:\n\tRAQRSQ(int size, const T& def = T()) :SegTree<T, T>(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + range * b; }) {};\n};\ntemplate<typename T>\nclass RAQRMiQ :public SegTree<T, T> {\npublic:\n\tRAQRMiQ(int size, const T& def = T()) :SegTree<T, T>(size, def, INF, [](T a, T b) {return min(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RAQRMaQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRAQRMaQ(int size, const T& def = T()) :base(size, def, -INF, [](T a, T b) {return max(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RUQRSQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRSQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return b; }, [](int range, T a, T b) {return range * b; }) {};\n};\ntemplate<typename T>\nclass RUQRMQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRMQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return min(a, b); }, [](T a, T b) {return b; }, [](int range, T a, T b) {return b; }) {};\n};\ntemplate<typename T>\nclass BIT {\n\tint n;\n\tT* bit;\npublic:\n\tBIT(int n) :n(n) {\n\t\tbit = new T[n];\n\t\tfill(bit, bit + n, T());\n\t}\n\tvoid add(int a, T x) {\n\t\twhile (a < n) {\n\t\t\tbit[a] += x;\n\t\t\ta += a & -a;\n\t\t}\n\t}\n\tT query(int a) {\n\t\tint cnt = 0;\n\t\twhile (a > 0) {\n\t\t\tcnt += bit[a];\n\t\t\ta -= a & -a;\n\t\t}\n\t\treturn cnt;\n\t}\n};\nclass ConvexHullTrick {\n\tbool minOrMax, lineMonotone;\n\tclass Line {\n\tpublic:\n\t\tint a, b;\n\t\tbool isquery;\n\t\tmutable std::function<const Line * ()> getSuc;\n\t\tbool operator<(const Line& x) const {\n\t\t\tif (isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return true;\n\t\t\t\treturn (suc->a - x.a) * a + suc->b - x.b > 0;\n\t\t\t}\n\t\t\tif (x.isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return false;\n\t\t\t\treturn (suc->a - a) * x.a + suc->b - b < 0;\n\t\t\t}\n\t\t\treturn a < x.a;\n\t\t}\n\t};\n\tbool isbad(const set<Line>::iterator x) {\n\t\tif (x == st.begin() || next(x) == st.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tbool isbad(const vector<Line>::iterator x) {\n\t\tif (x == vec.begin() || next(x) == vec.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tset<Line> st;\n\tvector<Line> vec;\npublic:\n\tConvexHullTrick(bool minormax = false, bool lineMonotone = false) :minOrMax(minormax), lineMonotone(lineMonotone) {}\n\tvoid addLine(int a, int b) {\n\t\tif (minOrMax) {\n\t\t\ta = -a; b = -b;\n\t\t}\n\t\tif (!lineMonotone) {\n\t\t\tauto pos = st.lower_bound({ a,-INF,false });\n\t\t\tif (pos != st.end()) {\n\t\t\t\tif ((*pos).a == a) {\n\t\t\t\t\tif ((*pos).b <= b)return;\n\t\t\t\t\tst.erase(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto ite = st.insert({ a,b,false }).first;\n\t\t\tite->getSuc = [=] {return next(ite) == st.end() ? nullptr : &*next(ite); };\n\t\t\tif (isbad(ite)) {\n\t\t\t\tst.erase(ite);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (next(ite) != st.end() && isbad(next(ite)))st.erase(next(ite));\n\t\t\twhile (ite != st.begin() && isbad(prev(ite)))st.erase(prev(ite));\n\t\t}\n\t\telse {\n\t\t\tif (!vec.empty()) {\n\t\t\t\tif (vec.back().a > a) {\n\t\t\t\t\tcerr << \"Line additions are not monotone\" << endl;\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (vec.back().a == a) {\n\t\t\t\t\tif (vec.back().b <= b)return;\n\t\t\t\t\tvec.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec.push_back({ a,b,false });\n\t\t\tauto ite = --vec.end();\n\t\t\tint index = vec.size() - 1;\n\t\t\tite->getSuc = [this, index] {cout << vec.size() << endl; return index == vec.size() - 1 ? nullptr : &*(vec.begin() + index + 1); };\n\t\t\twhile (ite != vec.begin() && isbad(prev(ite))) {\n\t\t\t\t*prev(ite) = vec.back();\n\t\t\t\tvec.pop_back();\n\t\t\t\tite = --vec.end();\n\t\t\t}\n\t\t}\n\t}\n\tint query(int x) {\n\t\tif (!lineMonotone) {\n\t\t\tauto l = *st.lower_bound(Line{ x, 0,true });\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t\telse {\n\t\t\tauto l = *lower_bound(vec.begin(), vec.end() - 1, Line({ x,0,true }));\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t}\n};\ntemplate<typename T>\nclass Matrix {\n\tint n;\n\tT zero, e;\n\tvector<vector<T>> vec;\n\tvoid letmeasure() {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j)vec[i][j] = zero;\n\t\t\t\telse vec[i][j] = e;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tMatrix(int n, T zero, T e) :n(n), zero(zero), e(e) {\n\t\tvec.resize(n, vector<T>(n));\n\t}\n\tMatrix(int n, T zero, T e, vector<int> vec) :n(n), zero(zero), e(e) {\n\t\tif (vec.size() != n * n) {\n\t\t\tcerr << \"Invalid construct of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tthis->vec.resize(n, vector<T>(n));\n\t\trep(i, n) {\n\t\t\trep(j, n)this->vec[i][j] = vec[i * n + j];\n\t\t}\n\t}\n\tT& operator[](int a) {\n\t\treturn vec[a / n][a % n];\n\t}\n\tunsigned int size() { return n; }\n\tMatrix operator*(const Matrix a) {\n\t\tif (this->n != a.n) {\n\t\t\tcerr << \"Invalid multiply of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> memo(n);\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tmemo[j] += vec[i][k] * a.vec[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec[i] = memo;\n\t\t\tmemo.clear();\n\t\t\tmemo.resize(n);\n\t\t}\n\t\treturn *this;\n\t}\n\tstatic Matrix<T> measure(int n, T zero, T e) {\n\t\tMatrix<T> res(n, zero, e);\n\t\tres.letmeasure();\n\t\treturn res;\n\t}\n};\n\nclass mycomplex {\n\tdouble realvalue, imagvalue;\npublic:\n\tmycomplex() :realvalue(0), imagvalue(0) {}\n\tmycomplex(double realvalue, double imagvalue) : realvalue(realvalue), imagvalue(imagvalue) {}\n\tmycomplex(double realvalue) : realvalue(realvalue), imagvalue(0) {}\n\tmycomplex(complex<double> c) :realvalue(c.real()), imagvalue(c.imag()) {}\n\tmycomplex(const mycomplex& rhs) :realvalue(rhs.realvalue), imagvalue(rhs.imagvalue) {}\n\tdouble real()const { return this->realvalue; }\n\tdouble imag()const { return this->imagvalue; }\n\tdouble abs() { return hypot(realvalue, imagvalue); }\n\tmycomplex& operator=(const mycomplex& obj) {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = obj.realvalue;\n\t\t\tthis->imagvalue = obj.imagvalue;\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator=(mycomplex&& obj)noexcept {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = exchange(obj.realvalue, 0);\n\t\t\tthis->imagvalue = exchange(obj.imagvalue, 0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator+=(const mycomplex& rhs) {\n\t\tthis->realvalue += rhs.realvalue;\n\t\tthis->imagvalue += rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator+(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs += rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator-=(const mycomplex& rhs) {\n\t\tthis->realvalue -= rhs.realvalue;\n\t\tthis->imagvalue -= rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tmycomplex& operator-=(const double& rhs) {\n\t\tthis->realvalue -= rhs;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator-(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs -= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator*=(const mycomplex& rhs) {\n\t\tdouble pastreal = this->realvalue;\n\t\tthis->realvalue = this->realvalue * rhs.realvalue - this->imagvalue * rhs.imagvalue;\n\t\tthis->imagvalue = pastreal * rhs.imagvalue + rhs.realvalue * this->imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator*(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs *= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator/=(const mycomplex& rhs) {\n\t\t*this *= mycomplex(rhs.real(), -rhs.imag());\n\t\tdouble dnm = rhs.real() * rhs.real() - rhs.imag() * rhs.imag();\n\t\tthis->realvalue /= dnm;\n\t\tthis->imagvalue /= dnm;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator/(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs /= rhs;\n\t\treturn lhs;\n\t}\n};\nclass FastFourierTransform {\nprivate:\n\tstatic void dft(vector<mycomplex>& func, int inverse) {\n\t\tint sz = func.size();\n\t\tif (sz == 1)return;\n\t\tvector<mycomplex> veca, vecb;\n\t\trep(i, sz / 2) {\n\t\t\tveca.push_back(func[2 * i]);\n\t\t\tvecb.push_back(func[2 * i + 1]);\n\t\t}\n\t\tdft(veca, inverse); dft(vecb, inverse);\n\t\tmycomplex now = 1, zeta = polar(1.0, inverse * 2.0 * acos(-1) / sz);\n\t\trep(i, sz) {\n\t\t\tfunc[i] = veca[i % (sz / 2)] + now * vecb[i % (sz / 2)];\n\t\t\tnow *= zeta;\n\t\t}\n\t}\npublic:\n\ttemplate<typename T>\n\tstatic vector<double> multiply(vector<T> f, vector<T> g) {\n\t\tvector<mycomplex> nf, ng;\n\t\tint sz = 1;\n\t\twhile (sz < f.size() + g.size())sz *= 2;\n\t\tnf.resize(sz); ng.resize(sz);\n\t\trep(i, f.size()) {\n\t\t\tnf[i] = f[i];\n\t\t\tng[i] = g[i];\n\t\t}\n\t\tdft(nf, 1);\n\t\tdft(ng, 1);\n\t\trep(i, sz)nf[i] *= ng[i];\n\t\tdft(nf, -1);\n\t\tvector<double> res;\n\t\trep(i, sz)res.push_back(nf[i].real() / sz);\n\t\treturn res;\n\t}\n};\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nconst int mod=998244353;\nint n,pre[2222][2],dp[4444][4444],res;\nvoid add(int &a,int b)\n{\n\ta+=b;\n\tif (a>=mod) a-=mod;\n}\nint main()\n{\n\tcin>>s;\n\tn=s.size();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (s[i-1]=='0')\n\t\t{\n\t\t\tpre[i][0]=pre[i-1][0]+2;\n\t\t\tpre[i][1]=pre[i-1][1];\n\t\t}\n\t\telse if (s[i-1]=='1')\n\t\t{\n\t\t\tpre[i][0]=pre[i-1][0]+1;\n\t\t\tpre[i][1]=pre[i-1][1]+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpre[i][0]=pre[i-1][0];\n\t\t\tpre[i][1]=pre[i-1][1]+2;\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor (int i=0;i<2*n;i++)\n\t{\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tif (!dp[i][j]) continue;\n\t\t\tif (pre[min(n,i+1)][1]>j)\n\t\t\t{\n\t\t\t\tadd(dp[i+1][j+1],dp[i][j]);\n\t\t\t}\n\t\t\tif (pre[min(n,i+1)][0]>i-j)\n\t\t\t{\n\t\t\t\tadd(dp[i+1][j],dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0;i<=2*n;i++) add(res,dp[2*n][i]);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=4010;\nconst int mod=998244353;\nint sum1,sum2;\nchar s[MAXN];\nint f[MAXN][2],dp[MAXN][MAXN];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n    for (int i=1;i<=n;i++) sum1+=(s[i]-'0');\n    sum2=2*n-sum1;\n    for (int i=1;i<=n;i++) f[i][0]+=f[i-1][0]+(s[i]-'0'),f[i][1]+=f[i-1][1]+2-(s[i]-'0');\n\tdp[0][0]=1;\n\tfor (int i=0;i<=sum1;i++){\n\t\tfor (int j=0;j<=sum2;j++)\n\t\t if (i|j)\n\t\t if (i<=f[min(i+j,n)][0]&&j<=f[min(i+j,n)][1]) \n\t\t {\n\t\t \tif (i) dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\t \tif (j) dp[i][j]=(dp[i][j]+dp[i][j-1])%mod; \n\t\t }\n\t} \n    cout << dp[sum1][sum2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ninline int in()\n{\n\tint k=0;char ch=gt;\n\twhile(ch<'-')ch=gt;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn k;\n}\nconst int N=2e5+5,YL=998244353;\ninline int ksm(int a,int k){int r=1;while(k){if(k&1)r=1ll*r*a%YL;a=1ll*a*a%YL,k>>=1;}return r;}\nint f[4005][4005],sr[4005],sb[4005],fac[4005],fnv[4005];\nchar s[20005];\ninline void add(int &x,int y){if((x+=y)>=YL)x-=YL;}\ninline int C(int x,int y){return y>x?0:1ll*fac[x]*fnv[y]%YL*fnv[x-y]%YL;}\nint main()\n{\n\tscanf(\"%s\",s+1);int n=strlen(s+1);fac[0]=1;\n\tfor(int i=1;i<=n+n;++i)fac[i]=1ll*fac[i-1]*i%YL;fnv[n+n]=ksm(fac[n+n],YL-2);\n\tfor(int i=n+n;i>=1;--i)fnv[i-1]=1ll*fnv[i]*i%YL;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tif(s[i]=='1')++sr[i],++sb[i];\n\t\telse if(s[i]=='2')sb[i]+=2;\n\t\telse sr[i]+=2;\n\tfor(int i=1;i<=n;++i)sr[i]+=sr[i-1],sb[i]+=sb[i-1];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i-1;++j)\n\t\t{\n\t\t\tint nr=j,nb=i-1-j;\n\t\t\tif(s[i]=='1')++nr,++nb;\n\t\t\telse if(s[i]=='2')nb+=2;\n\t\t\telse nr+=2;\n\t\t\tif(nb>0)add(f[i][nr],f[i-1][j]);\n\t\t\tif(nr>0)add(f[i][nr-1],f[i-1][j]);\n\t\t}\n\tint ans=0;\n\tfor(int i=0;i<=n;++i)ans=(1ll*f[n][i]*C(n,i)+ans)%YL;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 2050\n#define MOD 998244353\nvoid add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}\nint n,ans;char s[MAX];\nint f[MAX][MAX],C[MAX][MAX];\nint sb[MAX];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;++i)sb[i]=sb[i-1]+s[i]-48;\n\tfor(int i=0;i<=n;++i)C[i][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t{\n\t\t\tif(sb[i]-j)add(f[i][j+1],f[i-1][j]);\n\t\t\tif((2*i-sb[i])-(i-1-j))add(f[i][j],f[i-1][j]);\n\t\t}\n\tfor(int j=0;j<=n;++j)add(ans,1ll*f[n][j]*C[n][sb[n]-j]%MOD);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nstring s;\nvi a,b;\n\nint main(){\n\tcin>>s;\n\tn=s.size();\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='0'){\n\t\t\ta.push_back(i);\n\t\t\ta.push_back(i);\n\t\t}\n\t\tif(s[i]=='1'){\n\t\t\ta.push_back(i);\n\t\t\tb.push_back(i);\n\t\t}\n\t\tif(s[i]=='2'){\n\t\t\tb.push_back(i);\n\t\t\tb.push_back(i);\n\t\t}\n\t}\n\tint h=a.size(),w=b.size();\n\tvvi dp(h+1,vi(w+1));\n\tdp[0][0]++;\n\tfor(int i=0;i<=h;i++) for(int j=0;j<=w;j++){\n\t\tif(i<h&&a[i]<=(lower_bound(a.begin(),a.end(),a[i])-a.begin())+min(j,(lower_bound(b.begin(),b.end(),a[i])-b.begin()))) (dp[i+1][j]+=dp[i][j])%=mod;\n\t\tif(j<w&&b[j]<=min(i,(lower_bound(a.begin(),a.end(),b[j])-a.begin()))+(lower_bound(b.begin(),b.end(),b[j])-b.begin())) (dp[i][j+1]+=dp[i][j])%=mod;\n\t}\n\tcout<<dp[h][w]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,a[2010];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll iv[2010]={};\nll inv(ll x){\n  if(iv[x]<1) iv[x]=pwr(x,MOD-2);\n  return iv[x];\n}\n\nll nC[2010]={1};\nll comb(ll r){\n  if(nC[r]==0) nC[r]=mlt(comb(r-1),mlt(n-r+1,inv(r)));\n  return nC[r];\n}\n\nint main(){\n  n=0;\n  ll R=0,B=0,r=0,b=0;\n  char c;\n  for(;cin>>c;){\n    a[n]=c-'0';\n    if(a[n]<1) R+=2;\n    else if(a[n]<2){R++;B++;}\n    else B+=2;\n    n++;\n  }\n  ll dp[2010][2010]={};\n  dp[0][0]=1;\n  fr(i,n){\n    if(a[i]<1) r+=2;\n    else if(a[i]<2){r++;b++;}\n    else b+=2;\n    fr(j,n+1){\n      ll k=i-j;\n      if(k<0) break;\n      if(r-j>0) dp[i+1][j+1]=ad(dp[i+1][j+1],dp[i][j]);\n      if(b-k>0) dp[i+1][j]=ad(dp[i+1][j],dp[i][j]);\n    }\n  }\n  ll ans=0;\n  fr(j,n+1) if(R>=j) ans=ad(ans,mlt(dp[n][j],comb(R-j)));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;;\n#define ll long long\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define INF 1<<30\n#define LINF 1LL<<62\n#define all(x) (x).begin(), (x).end()\n#define mp make_pair\n#define pb push_back\nconst ll MOD = 998244353;\n \ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\n\nll dp[4005][4005];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  ll n = s.size();\n  ll r[n], b[n];\n  REP(i,n){\n      r[i] = 0;\n      b[i] = 0;\n  }\n  REP(i,n){\n      if(s[i] == '0'){\n          r[i] += 2;\n      }else  if(s[i]=='1'){\n          r[i]++;\n          b[i]++;\n      }else{\n          b[i]+=2;\n      }\n      if(i!=0){\n          r[i] += r[i-1];\n          b[i] += b[i-1];\n      }\n  }\n  \n  dp[0][0] = 1;\n  REP(i,2*n){\n      REP(j,i+1){\n          if(i<n){\n              if(r[i]>=j+1){\n                  dp[i+1][j+1] += dp[i][j];\n                  dp[i+1][j+1] %= MOD;\n              }\n              if(b[i]>=i+1-j){\n                  dp[i+1][j] += dp[i][j];\n                  dp[i+1][j] %= MOD;\n              }\n          }else{\n              if(r[n-1]>=j+1){\n                  dp[i+1][j+1] += dp[i][j];\n                  dp[i+1][j+1] %= MOD;\n              }\n              if(b[n-1]>=i+1-j){\n                  dp[i+1][j] += dp[i][j];\n                  dp[i+1][j] %= MOD;\n              }\n    \n          }\n      }\n  } \n   ll ans = 0;\n\n  REP(i,2*n){\n      ans += dp[2*n][i];\n      ans %= MOD;\n  }\n  cout << ans << endl;\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[2005][2005];\nint tot[2005][2];\nconst int mod=998244353;\n\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif      \n\n    string a;\n    cin>>a;\n    int n=a.length();\n    dp[0][0]=1;\n    a=\"#\"+a;\n    for(int i=1;i<=n;i++)\n    {\n        tot[i][0]=tot[i-1][0];\n        tot[i][1]=tot[i-1][1];\n        if(a[i]=='0')\n            tot[i][0]+=2;\n        else if(a[i]=='1')\n        {\n            tot[i][0]++;\n            tot[i][1]++;\n        }\n        else\n        {\n            tot[i][1]+=2;\n        }        \n    }\n\n    for(int i=0;i<=tot[n][0];i++)\n    {\n        for(int j=0;j<=tot[n][1];j++)\n        {\n            if(i+j==0)\n                continue;\n            if(i>0)\n            {\n                int z=i+j;\n                z=min(z,n);\n                if(tot[z][0]>=i)\n                {\n                    dp[i][j]+=dp[i-1][j];\n                }\n            }\n            if(j>0)\n            {\n                int z=i+j;\n                z=min(z,n);\n                if(tot[z][1]>=j)\n                {\n                    dp[i][j]+=dp[i][j-1];\n                }\n            }\n            dp[i][j]%=mod;\n        }\n    }\n    cout<<dp[tot[n][0]][tot[n][1]];\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\nint p = 998244353;\nint M = 0x7777777777777777777777777;\nint N;\nint rok[2048];\nint bok[2048];\nint dp[2048][2048];\n\nint solve(int r, int b) {\n\tif(r+b==0) {\n\t\treturn 1;\n\t}\n\tif(!dp[r][b]) {\n\t\tint ret = 0;\n\t\tif(r<=rok[r+b] && b<=bok[r+b]) {\n\t\t\tif(r) {\n\t\t\t\tret += solve(r-1, b);\n\t\t\t}\n\t\t\tif(b) {\n\t\t\t\tret += solve(r, b-1);\n\t\t\t}\n\t\t\tif(p<=ret) {\n\t\t\t\tret -= p;\n\t\t\t}\n\t\t}\n\t\tdp[r][b] = ret ^ M;\n\t}\n\treturn dp[r][b] ^ M;\n}\n\nint main() {\n\tchar S[2048];\n\tscanf(\"%s\", S);\n\tint halfN = strlen(S);\n\tN = halfN+halfN;\n\tint rsum = 0;\n\tint bsum = 0;\n\t{\n\t\tint lateR = 0;\n\t\tint lateB = 0;\n\t\tfor(int n=0; n<halfN; ++n) {\n\t\t\trok[n] = rsum;\n\t\t\tbok[n] = bsum;\n\t\t\trsum += lateR;\n\t\t\tbsum += lateB;\n\t\t\tif(S[n]=='0') {\n\t\t\t\t++rsum;\n\t\t\t\tlateR = 1;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse if(S[n]=='1') {\n\t\t\t\t++rsum;\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 1;\n\t\t\t}\n\t\t}\n\t\trsum += lateR;\n\t\tbsum += lateB;\n\t\tfor(int n=halfN; n<N+2; ++n) {\n\t\t\trok[n] = rsum;\n\t\t\tbok[n] = bsum;\n\t\t}\n\t}\n\tfor(int n=0; n<N+2; ++n) {\n\t\tprintf(\"%d %d\\n\", rok[n], bok[n]);\n\t}\n\tprintf(\"%d\\n\", solve(rsum, bsum));\n\tfor(int r=0; r<=rsum; ++r) {\n\t\tfor(int b=0; b<=bsum; ++b) {\n\t\t\tprintf(\" %d\", solve(r, b));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nV<int> a, b;\nint n;\n\nint dp[4003][4003];\n\nint rec(int i, int j) {\n\tif (dp[i][j] != -1) return dp[i][j];\n\tint& res = dp[i][j];\n\tres = 0LL;\n\n\tint rest = i + j;\n\tif (rest < a[i] || rest < b[j]) return res = 0LL;\n\tif (i == 0 && j == 0) return res = 1LL;\n\tif (i == 0) return res = rec(i, j - 1);\n\tif (j == 0) return res = rec(i - 1, j);\n\treturn res = (rec(i, j - 1) + rec(i - 1, j)) % MOD;\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(std::string, s);\n\tn = s.size();\n\n\tFILL(dp, -1LL);\n\n\ta.emplace_back(-1);\n\tb.emplace_back(-1);\n\tREP(i, n) {\n\t\tif (s[i] == '0') {\n\t\t\ta.emplace_back(i + 1);\n\t\t\ta.emplace_back(i + 1);\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\ta.emplace_back(i + 1);\n\t\t\tb.emplace_back(i + 1);\n\t\t}\n\t\telse if (s[i] == '2') {\n\t\t\tb.emplace_back(i + 1);\n\t\t\tb.emplace_back(i + 1);\n\t\t}\n\t}\n\n\tOUT(rec(a.size() - 1, b.size() - 1))BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=998244353;\nint n;\nchar s[2005];\nint sum[2005],d[4005][4005];\n\nint mod(int x){return x>=cys?x-cys:x;}\n\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tfor(int i=1;i<=n;i++) sum[i]=sum[i-1]+s[i]-'0';\n\td[0][0]=1;\n\tfor(int i=1;i<=2*n;i++){\n\t\tfor(int j=sum[min(n,i)];j>=0;j--){\n\t\t\tif(i-j<=2*min(n,i)-sum[min(n,i)]) d[i][j]=d[i-1][j];\n\t\t\tif(j>=1) d[i][j]=mod(d[i][j]+d[i-1][j-1]);\n\t\t}\n\t}\n\tcout<<d[2*n][sum[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v(0) {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<998244353>;\n\nint n;\nstring s;\nMint dp[4020][2020];\nbool used[4020][2020] = {};\n\nMint calc(int ph, int _r) {\n    if (ph == 2 * n) return Mint(1);\n    if (used[ph][_r]) return dp[ph][_r];\n    used[ph][_r] = true;\n    int r = _r;\n    int b = 2 * min(n, ph) - ph - r;\n    if (ph < n) {\n        if (s[ph] == '0') r++;\n        else b++;\n        if (s[ph] == '2') b++;\n        else r++;\n    }\n    Mint ans = 0;\n    if (r) ans += calc(ph + 1, r - 1);\n    if (b) ans += calc(ph + 1, r);\n\n    return dp[ph][_r] = ans;\n}\n\nint main() {\n    cin >> s;\n    n = int(s.size());\n\n    cout << calc(0, 0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nconst int N=4100,mod=998244353;\nint ksm(int x,int k)\n{\n\tint s=1;for(;k;k>>=1,x=1ll*x*x%mod)\n\t\t\t\tif(k&1) s=1ll*s*x%mod;return s;\n}\nint n,jc[N],bl,rd,dp[N][N],ans;\nchar s[N];\nvoid add(int &x,int y) {x+=y;if(x>=mod) x-=mod;}\nint C(int n,int k) {return 1ll*jc[n]*ksm(jc[k],mod-2)%mod*ksm(jc[n-k],mod-2)%mod;}\nvoid Get(int i,int &rd,int &bl)\n{\n\tif(s[i]=='1') rd++,bl++;\n\telse if(s[i]=='0') rd+=2;\n\telse bl+=2;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);jc[0]=1;\n\tfor(int i=1;i<=n*2;i++) jc[i]=1ll*jc[i-1]*i%mod;\n\tfor(int i=1;i<=n;i++) Get(i,rd,bl);\n\n\tdp[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int r=0;r<=i;r++)\n\t\t\tif(dp[i][r])\n\t\t\t{\n\t\t\t\tint sr=r,sb=i-r;\n\t\t\t\tGet(i+1,sr,sb);\n\t\t\t\tif(sr) add(dp[i+1][sr-1],dp[i][r]);\n\t\t\t\tif(sb) add(dp[i+1][sr],dp[i][r]);\n\t\t\t}\n\tfor(int r=0;r<=n;r++)\n\t\tadd(ans,1ll*dp[n][r]*C(n,r)%mod);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define inf 1e18\n#define mod 998244353\n\nusing namespace std;\n\nstring s;\nllint sumR[2005], sumB[2005];\nllint gateR[2005], gateB[2005];\nllint capR[4005], capB[4005];\nllint dp[4005][4005];\n\nint main(void)\n{\n\tcin >> s;\n\tint n = s.size();\n\ts = \"#\" + s;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tsumR[i] = sumR[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tgateR[i] = gateR[i-1];\n\t\tgateB[i] = gateB[i-1];\n\t\tif(s[i] == '0') sumR[i] += 2, gateR[i]++;\n\t\tif(s[i] == '1') sumR[i]++, sumB[i]++;\n\t\tif(s[i] == '2') sumB[i] += 2, gateB[i]++;\n\t}\n\t\n\tfor(int i = 0; i <= n; i++) capR[i] = capB[i] = inf;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(s[i] == '2') capR[gateB[i]-1] = min(capR[gateB[i]-1], sumR[i]);\n\t\tif(s[i] == '0') capB[gateR[i]-1] = min(capB[gateR[i]-1], sumB[i]);\n\t}\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tfor(int j = 0; j <= 2*n; j++){\n\t\t\tif(i < j) continue;\n\t\t\tdp[i][j] += dp[i-1][j], dp[i][j] %= mod;\n\t\t\tif(j > 0) dp[i][j] += dp[i-1][j-1], dp[i][j] %= mod;\n\t\t\tllint r = j, b = i-j;\n\t\t\tif(r > capR[b] ) dp[i][j] = 0;\n\t\t}\n\t}\n\t\n\t//for(int i = 0; i <= n; i++) cout << capR[i] << \" \"; cout << endl;\n\t//for(int i = 0; i <= n; i++) cout << capB[i] << \" \"; cout << endl;\n\t\n\t/*for(int i = 0; i <= 2*n; i++){\n\t\tfor(int j = 0; j <= 2*n; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tllint Rsum = sumR[n];\n\tcout << dp[2*n][Rsum] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\ntypedef long long ll;\nusing namespace std;\n\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18+7;\n\nsigned main(){\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tvector<vector<int>> dp(2 * n + 1, vector<int>(2 * n + 1, 0));\n\tvector<int> v(n);\n\tfor(int i = 0; i < n; ++i)\n\t\tv[i] = s[i] - '0';\n\tvector<int> rui(n + 1, 0);\n\tfor(int i = 0; i < n; ++i)\n\t\trui[i + 1] = rui[i] + v[i];\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < 2 * n; ++i){\n\t\tfor(int j = 0; j <= 2 * n; ++j){\n\t\t\tif(!dp[i][j])\n\t\t\t\tcontinue;\n\t\t\tif(rui[min(n, i + 1)] > j)\n\t\t\t\tdp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % 998244353;\n\t\t\tif(2 * min(n, i + 1) - rui[min(n, i + 1)] > i - j)\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % 998244353;\n\t\t}\n\t}\n\tcout << dp.back()[rui.back()] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 998244353;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\nmint dp[4010][4010][2];\n\ninline int rest_ball(int i,int n){\n\tconst int total = 2 * min(i,n) - i;\n\treturn total;\n}\n\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\n\tif(s == string(n,'2')){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tdp[0][0][0] = ONE;\n\n\trep(i,2*n)rep(j,2*n+1)rep(k,2){\n\t\tif(dp[i][j][k] == ZERO) continue;\n\t\tconst int all = rest_ball(i, n);\n\t\tint nr = j, nb = all - j;\n\n\t\tif(i < n){\n\t\t\tconst int idx = s[i] - '0';\n\t\t\tnr += idx;\n\t\t\tnb += 2 - idx;\n\t\t}\n\n\t\t// red\n\t\tif(nr > 0){\n\t\t\tint nk = k;\n\t\t\tif(nr - 1 == 0) nk = 1;\n\t\t\tdp[i+1][nr-1][nk] += dp[i][j][k];\n\t\t}\n\n\t\t// blue\n\t\tif(nb > 0){\n\t\t\tint nk = k;\n\t\t\tdp[i+1][nr][nk] += dp[i][j][k];\n\t\t}\n\t}\n\n\tmint ans = dp[2 * n][0][1];\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> pr;\n\nconst ll mod = 998244353;\nconst int maxn = 4020;\n\nchar ch[maxn];\nint mxr[maxn],mxb[maxn],r,b,n;\nll f[maxn][maxn];\n\ninline void up(ll &x,ll y) { x = (x+y) % mod; }\nint main(){\n\tscanf(\"%s\",ch + 1);\n\tn = strlen(ch + 1);\n\trep(i,1,n){\n\t\tif ( ch[i] == '0' ) r += 2;\n\t\telse if ( ch[i] == '2' ) b += 2;\n\t\telse r++ , b++;\n\t\tmxr[i] = min(mxr[i - 1] + 1,r);\n\t\tmxb[i] = min(mxb[i - 1] + 1,b);\n\t}\n\trep(i,n + 1,n * 2){\n\t\tmxr[i] = min(mxr[i - 1] + 1,r);\n\t\tmxb[i] = min(mxb[i - 1] + 1,b);\n\t}\n\tf[0][0] = 1;\n\trep(i,0,n * 2){\n\t\trep(j,i - mxb[i],mxr[i]){\n\t\t\tup(f[i + 1][j],f[i][j]);\n\t\t\tup(f[i + 1][j + 1],f[i][j]);\n\t\t}\n\t}\n\tcout<<f[n * 2][r]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n#include <string.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n\ntypedef long long lint;\n\nusing namespace std;\nlint p=998244353;\n\nint main(){\n  string S;\n  cin>>S;\n  int N=S.size();\n  int r[2*N+1],b[2*N+1];\n  r[0]=0;\n  b[0]=0;\n  int rt=0;\n  int bt=0;\n  int i=0;\n  for(auto c:S){\n    if(c=='0')rt+=2;\n    else if(c=='1'){\n      rt+=1;\n      bt+=1;\n    } else bt+=2;\n    r[i+1]=r[i];\n    if(rt>0){\n      r[i+1]++;\n      rt--;\n    }\n    b[i+1]=b[i];\n    if(bt>0){\n      b[i+1]++;\n      bt--;\n    }\n    i++;\n  }\n  REP(i,N){\n    r[i+N+1]=r[i+N];\n    if(rt>0){\n      r[i+N+1]++;\n      rt--;\n    }\n    b[i+N+1]=b[i+N];\n    if(bt>0){\n      b[i+N+1]++;\n      bt--;\n    }\n  }\n  // REP(i,2*N+1)cerr<<r[i]<<\" \"<<b[i]<<endl;\n  int R=r[2*N];\n  lint dp[2*N+1][R+1];\n  REP(i,2*N+1)REP(j,R+1)dp[i][j]=0;\n  dp[0][0]=1;\n  FOR(i,1,2*N+1)FOR(j,0,R+1){\n    if(j<i-b[i]){\n      dp[i][j]=0;\n      continue;\n    }\n    if(j==0){\n      dp[i][j]=1;\n      continue;\n    }\n    if(j>r[i])dp[i][j]=dp[i-1][j];\n    else dp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n    dp[i][j]%=p;\n  }\n  cout<<dp[2*N][R]<<endl;\n  // REP(i,2*N+1){\n  //   REP(j,R+1)cerr<<dp[i][j]<<\" \";\n  //   cerr<<endl;\n  // }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <memory>\n#include <complex>\n#include <numeric>\n#include <cstdio>\n#include <iomanip>\n\n#define REP(i,m,n) for(int i=int(m);i<int(n);i++)\n#define RREP(i,m,n) for(int i=int(n)-1;i>=int(m);--i)\n#define EACH(i,c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n#ifdef LOCAL\n#define DEBUG(s) cout << (s) << endl\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define BR cout << endl;\n#else\n#define DEBUG(s) do{}while(0)\n#define dump(x) do{}while(0)\n#define BR \n#endif\nusing namespace std;\n\nusing UI = unsigned int;\nusing UL = unsigned long;\nusing LL = long long int;\nusing ULL = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VLL = vector<LL>;\nusing VVLL = vector<VLL>;\nusing VS = vector<string>;\nusing PII = pair<int,int>;\nusing VP = vector<PII>;\n\n//struct edge {int from, to, cost;};\n\nconstexpr double EPS = 1e-10;\n//constexpr double PI  = acos(-1.0);\n//constexpr int INF = INT_MAX;\nconstexpr LL MOD = 998244353;\n//inline void modAdd(LL &l, LL &r) {l = (l + r) % MOD;}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\nLL dfs(int n, int blue, VI &ru, VVLL &memo) {\n    if (n <= 0 || blue < 0) return 0;\n    //cout << n << \" \" << blue << \" \" << ru[min((int)ru.size()-1,n)] << \" \" << memo[n][blue] << endl;\n    if (memo[n][blue] > -1) return memo[n][blue];\n    if (n <= ru.size()) {\n        if (blue > ru[n-1]) return memo[n][blue] = 0;\n        if (n - blue > 2 * n - ru[n-1]) return memo[n][blue] = 0;\n    } else {\n        int maxb = ru[ru.size()-1];\n        if (blue > maxb) return memo[n][blue] = 0;\n        if (n - blue > 2 * ru.size() - maxb) return memo[n][blue] = 0;\n    }\n    if (n == 1) return 1;\n    return memo[n][blue] = (dfs(n-1, blue - 1, ru, memo) + dfs(n-1, blue, ru, memo)) % MOD;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    VI ru(n);\n    ru[0] = s[0] - '0';\n    REP(i,1,n) ru[i] = ru[i-1] + s[i] - '0';\n    VVLL memo(2*n+1, VLL(2*n+1, -1));\n    cout << dfs(2*n,ru[n-1],ru,memo) << endl;\n}\n\nint main() {\n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 2000, md = 998244353;\n\nchar s[MX + 1];\nint mn[2 * MX], mx[2 * MX];\n\nvoid solve(bool inv) {\n\tstatic int cnt[MX + 1];\n\tint n = strlen(s), bal = 0;\n\tfor (int i = 0; i < n; i++) cnt[i + 1] = s[i] - '0';\n\tfor (int k = 2 * n; k > 0; k--) {\n\t\tcnt[0] = 0;\n\t\tfor (int i = 1; i <= (k + 1) / 2; i++)\n\t\t\tif (cnt[i] > 0) {\n\t\t\t\tcnt[i]--;\n\t\t\t\tcnt[i - 1]++;\n\t\t\t}\n\t\t\n\t\tif (inv) cnt[0] ^= 1;\n\t\t\n\t\tbal += cnt[0];\n\t\t(inv ? mn : mx)[2 * n - k] = bal;\n\t}\n}\n\nint dp[2 * MX + 1][2 * MX + 1];\n\nint main() {\n\tignore = scanf(\"%s\", s);\n\tint n = strlen(s);\n\t\n\tsolve(false);\n\t\n\tfor (int i = 0; s[i] != 0; i++) s[i] = '2' - (s[i] - '0');\n\t\n\tsolve(true);\n\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < 2 * n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int d = 0; d < 2; d++)\n\t\t\t\tif (mn[i] <= j + d && j + d <= mx[i]) {\n\t\t\t\t\tdp[i + 1][j + d] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j + d] %= md;\n\t\t\t\t}\n\t\n\tint ans = accumulate(dp[2 * n], dp[2 * n] + 2 * n + 1, 0ll) % md;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define llong long long\nusing namespace std;\n\nconst int N = 4000;\nconst int P = 998244353;\nllong dp[N+3][N+3];\nchar str[N+3];\nint sa[N+3],sb[N+3];\nint n;\n\nint main()\n{\n\tscanf(\"%s\",str+1); n = strlen(str+1);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tint x = str[i]-'0',y = 2-x;\n\t\tsa[i] = sa[i-1]+x; sb[i] = sb[i-1]+y;\n\t}\n\tfor(int i=n+1; i<=n+n; i++) sa[i] = sa[i-1],sb[i] = sb[i-1];\n\tdp[0][0] = 1ll;\n\tfor(int i=1; i<=n+n; i++)\n\t{\n\t\tfor(int j=max(0,i-sb[i]); j<=min(i,sa[i]); j++)\n\t\t{\n\t\t\tdp[i][j] = 0ll;\n\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\tif(j>0) dp[i][j] += dp[i-1][j-1];\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\t\tdp[i][j] %= P;\n\t\t}\n\t}\n\tllong ans = 0ll;\n\tfor(int i=0; i<=n; i++) ans = (ans+dp[n+n][i])%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=2010;\nconst int mod=998244353;\nint sum1,sum2;\nchar s[MAXN];\nint f[MAXN][2],dp[MAXN][MAXN];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n    for (int i=1;i<=n;i++) sum1+=(s[i]-'0');\n    sum2=2*n-sum1;\n    for (int i=1;i<=n;i++) f[i][0]+=f[i-1][0]+(s[i]-'0'),f[i][1]+=f[i-1][1]+2-(s[i]-'0');\n\tdp[0][0]=1;\n\tfor (int i=0;i<=sum1;i++){\n\t\tfor (int j=0;j<=sum2;j++)\n\t\t if (i|j)\n\t\t if (i<=f[min(i+j,n)][0]&&j<=f[min(i+j,n)][1]) \n\t\t {\n\t\t \tif (i) dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\t \tif (j) dp[i][j]=(dp[i][j]+dp[i][j-1])%mod; \n\t\t }\n\t} \n    cout << dp[sum1][sum2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll MOD = 998244353;\n\nll Solve() {\n    string s;\n    cin >> s;\n\n    const int n = s.size();\n    vector<int> b(2 * n + 1), r(2 * n + 1);\n    for (int i = 1; i <= n; ++i) {\n        if (s[i - 1] == '0') r[i] = 2;\n        else if (s[i - 1] == '2') b[i] = 2;\n        else { ++r[i]; ++b[i]; }\n    }\n    for (int i = 1; i <= 2 * n; ++i) {\n        r[i] += r[i - 1];\n        b[i] += b[i - 1];\n    }\n\n    vector<vector<ll>> dp(2 * n + 1, vector<ll>(r[2 * n] + 1));\n    dp[0][0] = 1;\n    for (int i = 1; i <= 2 * n; ++i) {\n        for (int j = max(0, i - b[i]); j <= r[i] && 0 <= i - j; ++j) {\n            if (0 < j) (dp[i][j] += dp[i - 1][j - 1]) %= MOD;\n            (dp[i][j] += dp[i - 1][j]) %= MOD;\n        }\n    }\n    return dp[2 * n][r[2 * n]];\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    cout << Solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define MN 4010\n#define mod 998244353\n\nint f[MN][MN];\nint r[MN], b[MN];\nchar s[MN];\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1); \n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x = s[i] - '0';\n\t\tr[i] = r[i - 1]; b[i] = b[i - 1];\n\t\tif(x == 0) r[i] += 2;\n\t\tif(x == 1) r[i]++, b[i]++;\n\t\tif(x == 2) b[i] += 2;\n\t}\n\tfor(int i = n + 1; i <= 2 * n; i++) r[i] = r[i - 1], b[i] = b[i - 1];\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= 2 * n; i++)\n\t{\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tint k = i - j;\n\t\t\tif(j > r[i] || k > b[i]) continue;\n\t\t\tif(j) f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mod;\n\t\t\tif(k) f[i][j] = (f[i][j] + f[i - 1][j]) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[2 * n][r[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000, mod = 998244353;\nchar s[maxn + 10];\nint f[maxn * 2 + 10][maxn * 2 + 10], n, now;\n\ninline void addto(int &x, int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n * 2; ++i) {\n\t\tif (i <= n) {\n\t\t\tif (s[i] == '0') now += 2;\n\t\t\telse if (s[i] == '1') ++now;\n\t\t}\n\t\tfor (int j = 0; j <= i; ++j)\n\t\t\tif (j <= now && i - j <= min(i, n) * 2 - now) {\n\t\t\t\tf[i][j] = f[i - 1][j];\n\t\t\t\tif (j) addto(f[i][j], f[i - 1][j - 1]);\n\t\t\t}\n\t}\n\tprintf(\"%d\", f[n * 2][now]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define _overload3(_1,_2,_3,name,...)name\n#define _rep(i,n)repi(i,0,n)\n#define repi(i,a,b)for(int i=int(a),i##_len=(b);i<i##_len;++i)\n#define MSVC_UNKO(x)x\n#define rep(...)MSVC_UNKO(_overload3(__VA_ARGS__,repi,_rep,_rep)(__VA_ARGS__))\n#define all(c)c.begin(),c.end()\n#define write(x)cout<<(x)<<'\\n'\nusing namespace std; typedef long long ll; template<class T>using vv = vector<vector<T>>;\ntemplate<class T>auto vvec(int n, int m, T v) { return vv<T>(n, vector<T>(m, v)); }\nconstexpr int INF = 1 << 29, MOD = 998244353; constexpr ll LINF = 1LL << 60;\nstruct aaa { aaa() { cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }; }aaaa;\n\nll mpow(ll x, ll n) { ll y = 1; for (; n > 0; n /= 2) { y = n % 2 ? y * x % MOD : y; x = x * x % MOD; } return y; }\nstruct Combination {\n    vector<ll> fact, ifact;\n    Combination(int n) : fact(n + 1), ifact(n + 1) {\n        fact[0] = 1; for (int i = 0; i < n; ++i) fact[i + 1] = fact[i] * (i + 1) % MOD;\n        ifact[n] = mpow(fact[n], MOD - 2); for (int i = n; i > 0; --i) ifact[i - 1] = ifact[i] * i % MOD;\n    }\n    ll operator ()(int n, int k) { return k < 0 || k > n ? 0 : fact[n] * ifact[n - k] % MOD * ifact[k] % MOD; }\n} C(4e3);\n\nint main() {\n    string S;\n    cin >> S;\n    int N = S.size();\n\n    vector<int> bsum(N + 1);\n    rep(i, N) bsum[i + 1] = bsum[i] + (S[i] - '0');\n\n    vv<ll> memo = vvec(N + 1, N + 1, 0LL);\n    memo[0][0] = 1;\n    rep(i, N) {\n        int bl = bsum[i] + (S[i] == '2'), bh = bsum[i] + (S[i] != '0');\n        if (2 * i + 1 - bl >= i + 1) memo[i + 1][0] = memo[i][0];\n        if (bh >= i + 1) memo[i + 1][i + 1] = memo[i][i];\n        rep(j, 1, i + 1) {\n            if (2 * i + 1 - bl >= i + 1 - j && bh >= j) {\n                memo[i + 1][j] = (memo[i][j - 1] + memo[i][j]) % MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep(j, 0, N + 1) {\n        if (memo[N][j]) {\n            ans = (ans + memo[N][j] * C(N, bsum[N] - j)) % MOD;\n        }\n    }\n    write(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Pct puts(\"------ Yes ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\n#define fir first\n#define sec second\n#define ls son[u][0]\n#define rs son[u][1]\n#define eps 1e-8\n#define PI acos(-1.0)\nusing namespace std;\ntemplate <class T> void rd(T &x){ x = 0; int f = 1; char ch = getchar(); while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); } while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar(); x *= f; }\n\ntypedef long long ll;\nconst int N = 4e3 + 5;\nconst int mod = 998244353;\nint n, _r, _b;\nll f[N][N], fac[N], fin[N];\nchar s[N];\n\nvoid add(ll &a, ll b){ a = (a + b) % mod; }\n\nll Inv(ll x){ return x <= 1 ? 1 : Inv(mod % x) * (mod - mod / x) % mod; }\n\nll C(ll n, ll m){ return fac[n] * fin[m] % mod * fin[n - m] % mod; }\n\nint main(){\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\n\tfac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;\n\tfin[n] = Inv(fac[n]);\n\tper(i, n, 1) fin[i - 1] = fin[i] * i % mod;\n\t\n\tf[0][0] = 1;\n\trep(i, 1, n){\n\t\tif(s[i] == '0') _r += 2;\n\t\telse if(s[i] == '2') _b += 2;\n\t\telse _r ++, _b ++;\n\t\trep(j, 0, 2 * (i - 1)){\n\t\t\tint r = j, b = 2 * (i - 1) - j;\n\t\t\tif(s[i] == '0'){\n\t\t\t\tadd(f[i][r + 1], f[i - 1][r]);\n\t\t\t\tif(b) add(f[i][r + 2], f[i - 1][r]);\n\t\t\t}\n\t\t\telse if(s[i] == '1'){\n\t\t\t\tadd(f[i][r], f[i - 1][r]);\n\t\t\t\tadd(f[i][r + 1], f[i - 1][r]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(r) add(f[i][r - 1], f[i - 1][r]);\n\t\t\t\tadd(f[i][r], f[i - 1][r]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll ans = 0;\n\trep(i, max(0, _r - n), min(_r, n)) add(ans, C(n, _r - i) * f[n][i] % mod);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 4005;\nconst int P = 998244353;\n\nchar a[maxn];\nint f[maxn/2][maxn];\nint n, r[maxn], b[maxn];\n\nvoid add(int &x, int y){x += y; if(x>=P) x-=P;}\nint main()\n{\n\t#ifdef MPS\t\n\t\tfp(\"1.in\",\"r\",stdin);\n\t\tfp(\"1.out\",\"w\",stdout);\n\t#endif\n\tsf(\"%s\",a+1);\n\tn = strlen(a+1);\n\tfo(i,1,n)\n\t{\n\t\tif(a[i] == '0') r[i] = 2, b[i] = 0;\n\t\telse if(a[i] == '1') r[i] = 1, b[i] = 1;\n\t\telse r[i] = 0, b[i] = 2;\n\t\tr[i] += r[i-1]; b[i] += b[i-1];\n\t}\n\tf[0][0] = 1;\n\tint ans = 0;\n\tfo(i,1,n*2) fo(j,0,n*2)\n\t{\n\t\tif(j >= 1 && r[(int)ceil(i/2.0)] >= j-1) add(f[i][j], f[i-1][j-1]);\t\n\t\tif(b[(int)ceil(i/2.0)] >= i-j) add(f[i][j], f[i-1][j]);\n\t\tif(i == n*2) add(ans,f[i][j]);\n\t}\n\tpf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<62;\nconst double eps=1e-5;\nconst ll MOD=998244353LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n\tstring s;cin>>s;\n\tint n=s.length();\n\tvector<int> c1(2*n+10),c2(2*n+10);\n\tint co1=1,co2=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='0'){\n\t\t\tc1[co1]=i+1;\n\t\t\tco1++;\n\t\t\tc1[co1]=i+1;\n\t\t\tco1++;\n\t\t}else if(s[i]=='1'){\n\t\t\tc1[co1]=i+1;\n\t\t\tco1++;\n\t\t\tc2[co2]=i+1;\n\t\t\tco2++;\n\t\t}else if(s[i]=='2'){\n\t\t\tc2[co2]=i+1;\n\t\t\tco2++;\n\t\t\tc2[co2]=i+1;\n\t\t\tco2++;\n\t\t}\n\t}\n\tvector<vector<ll>> dp(2*n+10,vector<ll>(2*n+10));\n\tdp[0][0]=1;\n\tfor(int i=1;i<=2*n;i++){\n\t\tfor(int j=0;j<co1;j++){\n\t\t\tint k=i-j;\n\t\t\tif(j>0&&c1[j]<=i){\n\t\t\t\tdp[i][j]+=dp[i-1][j-1];\n\t\t\t}\n\t\t\tif(k>0&&c2[k]<=i){\n\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t}\n\t\t\tdp[i][j]%=MOD;\n\t\t}\n\t}\n\tcout<<dp[2*n][co1-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define mdn 998244353\nusing namespace std;\nint f[4100][4100];\nchar ch[2100]; int n;\nint pre[2100];\nint main()\n{\n\tscanf(\"%s\",ch+1); n = strlen(ch+1);\n\tfor(int i=1;i<=n;i++)\tpre[i]=pre[i-1]+ch[i]-'0';\n\tf[0][0] = 1;// int ans = 0;\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tfor(int j=0;j<=min(pre[min(i,n)],i);j++)\n\t\t{\n\t\t\tif(j>0 && ((i<=n && pre[i]>=j) || (i>n && pre[n]>=j)))\tf[i][j] = (f[i][j] + f[i-1][j-1])%mdn;\n\t\t\tif((i<=n && 2*i-pre[i]>=i-j) || (i>n && 2*n-pre[n]>=i-j))\tf[i][j] = (f[i][j] + f[i-1][j])%mdn;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n*2][pre[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#define N 4400\n#define L 4000\n#define eps 1e-7\n#define inf 1e9+7\n#define db double\n#define ll long long\n#define ldb long double\nusing namespace std;\ninline ll read()\n{\n\tchar ch=0;\n\tll x=0,flag=1;\n\twhile(!isdigit(ch)){ch=getchar();if(ch=='-')flag=-1;}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nconst ll mo=998244353;\nchar s[N];\nll a[N],b[N],f[N][N],dp[N][N];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tll n=strlen(s+1);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\ta[i]=a[i-1],b[i]=b[i-1];\n\t\tif(s[i]=='0')a[i]+=2;\n\t\tif(s[i]=='2')b[i]+=2;\n\t\tif(s[i]=='1')a[i]+=1,b[i]+=1;\n\t}\n\tfor(ll i=0;i<=a[n];i++)\n\tfor(ll j=0;j<=b[n];j++)\n\tif(i+j<2*n)\n\t{\n\t\tf[i][j]=-1;\n\t\tll k=min(n,i+j+1);\n\t\tif(a[k]-i>0&&b[k]-j>0)f[i][j]=1;\n\t\telse\n\t\t{\n\t\t\tif(a[k]-i>0)f[i][j]=0;\n\t\t\tif(b[k]-j>0)f[i][j]=2;\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor(ll i=0;i<=a[n];i++)\n\tfor(ll j=0;j<=b[n];j++)\n\tif(i+j!=0)\n\t{\n\t\tdp[i][j]=0;\n\t\tif(i&&(f[i-1][j]==0||f[i-1][j]==1))dp[i][j]=(dp[i][j]+dp[i-1][j])%mo;\n\t\tif(j&&(f[i][j-1]==1||f[i][j-1]==2))dp[i][j]=(dp[i][j]+dp[i][j-1])%mo;\n\t}\n\tprintf(\"%lld\",dp[a[n]][b[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nconst int MOD = 998244353;\n\nusing namespace std;\n\nlong dp[4001][4001];\n\nint main(){\n    string S;\n    cin >> S;\n    int N = S.size();\n    int cnt_r = 0;\n    int cnt_b = 0;\n    dp[0][0] = 1;\n    for(int i = 0; i < 2*N; i++){\n        if(i < N){\n            if(S[i] == '0'){\n                cnt_r += 2;\n            }\n            if(S[i] == '1'){\n                cnt_r += 1;\n                cnt_b += 1;\n            }\n            if(S[i] == '2'){\n                cnt_b += 2;\n            }\n        }\n        for(int j = 0; j < 2*N;j++){\n            int rem_r = cnt_r - j;\n            int rem_b = cnt_r+cnt_b-i-rem_r;\n            if(rem_r > 0){\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= MOD;\n            }\n            if(rem_b > 0){\n                dp[i+1][j] += dp[i][j];\n                dp[i+1][j] %= MOD;\n            }\n        }\n    }\n    long ans = 0;\n    for(int i = 0; i <= 2*N; i++){\n        ans += dp[2*N][i];\n        ans %= MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tmodInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n    assert(s != \"02\");\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 2e3 + 10; \nconst int MOD = 998244353;\nchar s[N];\nint dp[N*2][N*2];\nint sum[N], sm[N];\nint main() {\n\tint n;\n\tscanf(\"%s\", s+1);\n\tn = strlen(s+1);\n\tfor (int i = 1; i <= n; ++i) sum[i] = sum[i-1] + s[i]-'0';\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2*n; ++i) {\n\t\tint p = min(i, n);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif(sum[p] > j) dp[i][j+1] = (dp[i][j+1] + dp[i-1][j]) % MOD;\n\t\t\tif(2*i - sum[p] > i-1-j) dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD; \n\t\t}\n\t} \n\tprintf(\"%d\\n\", dp[2*n][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 998244353\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong DP[4001*4001];\nvoid Calc(){\n\tstring S = res();\n\tint N = S.length();\n\tint r = 0;\n\tint b = 0;\n\tDP[0] = 1;\n\tfor(int i=0;i<2*N;i++){\n\t\tif(i < N){\n\t\t\tif(S[i] == '0'){\n\t\t\t\tr += 2;\n\t\t\t}\n\t\t\telse if(S[i] == '1'){\n\t\t\t\tr++;\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb += 2;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=4000;j++){\n\t\t\tif(r >= j && b >= i+1-j){\n\t\t\t\tif(j != 0){\n\t\t\t\t\tDP[i*4001+4001+j] += DP[i*4001+j-1];\n\t\t\t\t}\n\t\t\t\tDP[i*4001+4001+j] += DP[i*4001+j];\n\t\t\t}\n\t\t}\n\t}\n\tlong ans = 0;\n\tfor(int i=0;i<=4000;i++){\n\t\tans += DP[2*N*4001+i];\n\t}\n\tans %= mod;\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define M 4010\n#define P 998244353\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[M];\n\nint n, S[M], F[M][M];\n\nsigned main() {\n    scanf(\"%s\", ch + 1), n = strlen(ch + 1);\n    for(int i = 1; i <= n; i++) S[i] = S[i - 1] + ch[i] - '0';\n    F[0][0] = 1;\n    for(int i = 0; i < n * 2; i++)\n        for(int j = max((i < n ? i - (2 * i - S[i]) : i - (2 * n - S[n])), 0ll); j <= (i < n ? S[i] : S[n]); j++)\n            F[i + 1][j] = (F[i + 1][j] + F[i][j]) % P,\n            F[i + 1][j + 1] = (F[i + 1][j + 1] + F[i][j]) % P;\n    ll ans = 0;\n    printf(\"%lld\\n\", (F[2 * n][S[n]] % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size(),r = 0;\n    vector<vector<ll>> dp(2*n+1,vector<ll>(2*n+1,0));\n    dp[0][0] = 1;\n    for (int i = 0;i < 2*n;++i) {\n        if (i < n) {\n            if (s[i] == '0') r += 2;\n            else if (s[i] == '1') r += 1;\n        }\n        for (int j = 0;j < min(2*i+2,2*n);++j) {\n            if (j && j <= r) dp[i+1][j] = dp[i][j-1];\n            if (i+1-j <= min(2*i+2,2*n)-r) dp[i+1][j] += dp[i][j];\n            dp[i+1][j] %= mod;\n        }\n    }\n    cout << dp[2*n][r] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int mod = 998244353, maxn = 2000;\n\nint dp[maxn + 1][maxn + 1];\nmultiset<int> pos[2];\n\nint solve(int i, int n0, int n1, int n) {\n  if (i == 2 * n) {\n    return 1;\n  }\n\n  int &res = dp[n0][n1];\n  if (res != -1) return res;\n\n  pair<int, int> range;\n  if (i < n) {\n    range = {0, i};\n  } else {\n    range = {0, n - 1};\n  }\n\n  res = 0;\n  for (int val = 0; val < 2; ++val) {\n    auto it = pos[val].lower_bound(range.first);\n    if (it != pos[val].end() && *it <= range.second) {\n      int this_pos = *it;\n      pos[val].erase(it);\n      res += solve(i + 1, n0 + (val == 0), n1 + (val == 1), n);\n      if (res >= mod) res -= mod;\n      pos[val].insert(this_pos);\n    }\n  }\n\n  return res;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '0') {\n      pos[0].insert(i);\n      pos[0].insert(i);\n    } else if (s[i] == '1') {\n      pos[0].insert(i);\n      pos[1].insert(i);\n    } else {\n      pos[1].insert(i);\n      pos[1].insert(i);\n    }\n  }\n\n  memset(dp, -1, sizeof(dp));\n  int result = solve(0, 0, 0, n);\n  printf(\"%d\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nusing MMK = IntMod<998244353>;\n\nstring s;\nint N;\nMMK DP[2001][2001];\nint A[2001];\nint B[2001];\nint main() {\n\tcin >> s;\n\tN = s.size();\n\t\n\tREP(i, 0, N) {\n\t\tA[i + 1] = A[i] + ('2' - s[i]);\n\t\tB[i + 1] = B[i] + (s[i] - '0');\n\t}\n\n\tDP[0][0] = 1;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N + 1) {\n\t\t\t// 未来を見据えて\n\t\t\tint a = (i + 1) - j;\n\t\t\tint b = j;\n\t\t\t\n\t\t\tif (a > A[i + 1] || b > B[i + 1]) continue;\n\t\t\tDP[i + 1][j] += DP[i][j];\n\t\t\tif (j > 0) DP[i + 1][j] += DP[i][j - 1];\n\t\t}\n\t}\n\n\tMMK sum = 0;\n\tint AN = A[N];\n\tint BN = B[N];\n\tREP(j, 0, N + 1) {\n\t\tint a = N - j;\n\t\tint b = j;\n\n\t\tint arem = AN - a;\n\t\tint brem = BN - b;\n\t\tif (arem < 0 || brem < 0) continue;\n\t\tsum += DP[N][j] * MMK::Combi(arem + brem, arem);\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define per(i,a,b) for (int i=(b)-1;i>=a;i--)\n#define sz(a) (int) a.size()\n#define de(a) cout<<#a<<\" = \"<<a<<endl\n#define dd(a) cout<<#a<<\" = \"<<a<<\" \"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n//-----\nconst int N = 2e5+7;\nint dp[2007][4007];\nint r[N],b[N],n;\nconst int MOD = 998244353;\nint C[4007][4007];\nint add(int a,int b) {\n    a += b;\n    if(a >= MOD) a -= MOD;\n    return a;\n}\nint dfs(int dep,int hr,int hb,int rr,int rb) {\n    if(dep == n) {\n        return C[rr+rb][rr];\n    }\n    dep++;\n    if(dp[dep][hr] != -1) return dp[dep][hr];\n    rr += r[dep];\n    rb += b[dep];\n\n    int ret = 0;\n    if(rr) ret = add(ret,dfs(dep,hr+1,hb,rr-1,rb));\n    if(rb) ret = add(ret,dfs(dep,hr,hb+1,rr,rb-1));\n    return dp[dep][hr] = ret;\n}\nchar s[4007];\nint main()\n{\n    scanf(\"%s\",s+1);\n    //scanf(\"%d\",&n);\n    n = strlen(s+1);\n    memset(dp,-1,sizeof(dp));\n    rep(i,0,2*n+3) {\n        rep(j,0,i+1) {\n            if(j == 0 || i == j) C[i][j] = 1;\n            else C[i][j] = add(C[i-1][j],C[i-1][j-1]);\n        }\n    }\n    rep(i,1,n+1) {\n        char t = s[i];\n        if(t == '0') r[i] = 2;\n        else if(t == '1') r[i] = b[i] = 1;\n        else b[i] = 2;\n    }\n    printf(\"%d\\n\",dfs(0,0,0,0,0));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 998244353;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nclass ModInt {\npublic:\n    long long x;\n    constexpr ModInt(const long long x=0) : x((x+MOD)%MOD) {}\n    constexpr ModInt& operator+=(const ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    constexpr ModInt operator+(const ModInt rhs) const {\n        return ModInt(*this) += rhs; \n    }\n    constexpr ModInt& operator-=(const ModInt& rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    constexpr ModInt operator-(const ModInt rhs) const {\n        return ModInt(*this) -= rhs; \n    }\n    constexpr ModInt& operator*=(const ModInt& rhs) {\n        x = x * rhs.x % MOD;\n        return *this;\n    }\n    constexpr ModInt operator*(const ModInt rhs) const {\n        return ModInt(*this) *= rhs; \n    }\n    constexpr ModInt& operator/=(const ModInt& rhs) {\n        ModInt div = powmod(rhs, MOD - 2);\n        (x *= div.x) %= MOD;\n        return *this;\n    }\n    constexpr ModInt operator/(const ModInt rhs) const {\n        return ModInt(*this) /= rhs;\n    }\n    constexpr ModInt powmod(ModInt m, long long p) {\n        if (p == 0) return ModInt(1);\n        ModInt tmp = powmod(m, p / 2);\n        if (p & 1) return tmp * tmp * m;\n        else return tmp * tmp;\n    }\n    constexpr ModInt& operator++() {\n        x += 1;\n        return *this;\n    }\n    constexpr ModInt operator++(int) {\n        ModInt tmp(*this);\n        operator++();\n        return tmp;\n    }\n    constexpr ModInt& operator--() {\n        x -= 1;\n        return *this;\n    }\n    constexpr ModInt operator--(int) {\n        ModInt tmp(*this);\n        operator--();\n        return tmp;\n    }\n\n    friend ostream& operator<<(ostream& os, const ModInt &rhs) {\n        os << rhs.x;\n        return os;\n    }\n    friend istream& operator>>(istream& is, ModInt& rhs) {\n        is >> rhs.x;\n        return is;\n    }\n};\nbool operator==(const ModInt& lhs, const ModInt& rhs) {\n    return lhs.x == rhs.x;\n}\nbool operator!=(const ModInt& lhs, const ModInt& rhs) {\n    return !(lhs == rhs);\n}\nModInt powmod(ModInt m, long long p) {\n    if (p == 0) return ModInt(1);\n    ModInt tmp = powmod(m, p / 2);\n    if (p & 1) return tmp * tmp * m;\n    else return tmp * tmp;\n}\n\nusing modi = ModInt;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s; cin >> s;\n    int n = s.size();\n    V<modi> fac(n + 1, 1), invfac(n + 1, 1);\n    for (ll i = 2; i < (ll)(n + 1); i++) {\n        fac[i] = fac[i - 1] * modi(i);\n        invfac[i] = invfac[i - 1] * powmod(modi(i), MOD - 2);\n    }\n\n    // dp[i][j]: i 回目（= i 人目）の操作の後、j 個赤があるときの並べ方\n    V< V<modi> > dp(n + 1, V<modi>(n + 1, 0));\n    dp[0][0] = modi(1);\n    int red = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '0') red += 2;\n        else if (s[i] == '1') red++;\n        for (int j = 0; j <= i; j++) {\n            // 赤を足せる\n            if (j <= i && j < red) dp[i + 1][j + 1] += dp[i][j];\n            // 青を足せる\n            if (2 * (i + 1) - red >= i + 1 - j) dp[i + 1][j] += dp[i][j];\n        }\n    }\n\n    // for (int i = 0; i <= n; i++) DEBUG_VLL(dp[i])\n\n    modi ans = 0;\n    for (int i = 0; i <= min(n, red); i++) {\n        ans += dp[n][i] * fac[n] * invfac[red - i] * invfac[n - red + i];\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/indexed.hpp>\n\nusing namespace std;\nusing namespace boost::adaptors;\nusing namespace std::string_literals;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\nusing boost::irange;\nconstexpr ll MOD = 998244353;\n\nint main()\n{\n  string s;\n  cin>>s;\n  int n=s.size();\n  int m=2*n;\n  vecll count_r(m+1, 0);\n  vecll count_b(m+1, 0);\n  for (int i:irange(0,n)) {\n    switch (s[i]) {\n      case '0': \n        count_r[i+1] = count_r[i] + 2;\n        count_b[i+1] = count_b[i] + 0;\n        break;\n      case '1':\n        count_r[i+1] = count_r[i] + 1;\n        count_b[i+1] = count_b[i] + 1;\n        break;\n      case '2':\n        count_r[i+1] = count_r[i] + 0;\n        count_b[i+1] = count_b[i] + 2;\n        break;\n    }\n  }\n  for (int i:irange(n,m)) {\n    count_r[i+1] = count_r[i];\n    count_b[i+1] = count_b[i];\n  }\n  vector<vecll> dp(m+1, vecll(m+1, 0));\n  dp[0][0] = 1;\n  for (int i:irange(0,m+1)) {\n    for (int j:irange(0,m+1)) {\n      int t = i+j;\n      if (t > m) break;\n      if (i > count_r[t] || j > count_b[t]) continue;\n      if (i > 0) dp[i][j] += dp[i-1][j];\n      if (j > 0) dp[i][j] += dp[i][j-1];\n      dp[i][j] %= MOD;\n    }\n  }\n  cout<<dp[count_r.back()][count_b.back()]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ld long double\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nconstexpr double eps=1e-8;\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint Random(int mi,int ma){\n    random_device rnd;\n    mt19937 mt(rnd());//32bit\n    //[mi,ma]\n    uniform_int_distribution<int>engine(mi,ma);\n    return engine(mt);\n}\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nvector<int>kaijo,invkaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    invkaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n    rep(i,n+1)invkaijo[i]=modpow(kaijo[i],mod-2);\n}\nint comb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return kaijo[a]*invkaijo[a-b]%mod*invkaijo[b]%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nint n,dp[4010][4010],cnt[2];\nsigned main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    string s;\n    cin>>s;\n    n=s.size();\n    dp[0][0]=1;\n    rep(i,2*n){\n        if(i<n){\n            if(s[i]=='0')cnt[0]+=2,cnt[1]+=0;\n            if(s[i]=='1')cnt[0]+=1,cnt[1]+=1;\n            if(s[i]=='2')cnt[0]+=0,cnt[1]+=2;\n        }\n        rep(j,cnt[0]+1){\n            if(j<cnt[0]){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=998244353;\n            }\n            if(i+1-j<=cnt[1]){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=998244353;\n            }\n        }\n    }\n    cout<<dp[2*n][cnt[0]]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n#define mid ((l+r)>>1)\n#define MAXN 4005\n#define MAXM\n#define mod 998244353\n#define inf (1<<30)\n#define eps (1e-6)\n#define alpha 0.75\n#define rep(i, x, y) for(register int i = x; i <= (y); ++i)\n#define repd(i, x, y) for(register int i = x; i >= (y); --i)\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntemplate <typename T> il bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}\ntemplate <typename T> il bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}\ntemplate <typename T> il void read(T &x) {\n\tchar ch = getchar(); int f = 1; x = 0;\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n\tx *= f;\n}\ntemplate <typename T, typename... Args> il void read(T &x, Args &...args) {\n\tread(x), read(args...);\n}\nint n;\nchar s[MAXN];\nll dp[MAXN][MAXN];\nvoid add(ll &x, ll y) {\n\t(x += y) %= mod;\n}\nint main() {\n\tscanf(\"%s\", s+1);\n\tn = strlen(s+1);\n\tdp[0][0] = 1;\n\tint r = 0, b = 0;\n\trep(i, 1, n * 2) {\n\t\tif(i <= n) b += s[i] - '0', r += '2' - s[i];\n\t\trep(j, 0, i) \n\t\t\tif(r >= j && b >= i-j) {\n\t\t\t\tadd(dp[i][j], dp[i-1][j]);\n\t\t\t\tif(j) add(dp[i][j], dp[i-1][j-1]);\n\t\t\t}\n\t}\n\tcout << dp[n * 2][r] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <iomanip>\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define ROF(i, j, k) for(int i = (int)(j); i >= (int)(k); --i)\n#define FORLL(i, n, m) for(long long i = n; i < (long long)(m); i++)\n#define SORT(v, n) sort(v, v+n)\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nusing namespace std;\nusing ll = long long;\ntypedef pair<int, int> P;\n\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\n\nconst int MAX = 210000;\nconst ll MOD = 998244353;\nll dp[5100][5100];\nll sum[5100];\nll fac[MAX], finv[MAX], inv[MAX];\n\nll comb_init(){\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  FOR(i, 2, MAX){\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\nll comb(int n, int k){\n  if(n < k) return 0;\n  if(n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;\n}\nll modpow(ll a,ll n, ll mod){\n  ll res = 1;\n  while(n > 0){\n    if(n&1) res = res*a%mod;\n    a = a*a%mod;\n    n >>= 1;\n  }\n  return res;\n}\nll modinv(ll a, ll mod){\n  ll b = mod, u = 1, v = 0;\n  while(b){\n    ll t = a/b;\n    a -= t*b; swap(a, b);\n    u -= t*v; swap(u, v);\n  }\n  u %= mod;\n  if(u < 0) u += mod;\n  return u;\n}\nint\nmain(void){  \n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  string s;\n  cin >> s;\n\n  comb_init();\n  int n = s.size();\n\n  sum[0] = 0LL;\n  REP(i, n){\n    int num = 0;\n    if(s[i] == '0') num += 2;\n    else if(s[i] == '1') num += 1;\n    sum[i+1] = sum[i] + num;\n  }\n  //なぜ 1?\n  dp[0][0] = 1;\n  REP(i, n){\n    REP(r, i+1){\n      if(dp[i][r] == 0) continue;\n      //赤の総数が r+1個 以上ならば\n      if(sum[i+1] >= r+1){\n\tdp[i+1][r+1] += dp[i][r];\n\tdp[i+1][r+1] %= MOD;\n      }\n      //青の総数が i+1-r個 以上ならば\n      if((i+1)*2-sum[i+1] >= i+1-r){\n\tdp[i+1][r] += dp[i][r];\n\tdp[i+1][r] %= MOD;\n      }\n    }\n  }\n  ll res = 0LL;\n  REP(r, n+1){\n    res += dp[n][r] * comb(n, sum[n]-r)%MOD;\n    res %= MOD;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll dp[4001][4001];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  string s; cin >> s;\n  int n = s.size();\n  int nn = 2*n;\n\n  rep(i, 4001) {\n    rep(j, 4001) {\n      dp[i][j] = 0;\n    }\n  }\n\n  vector<ll> red(n+1);\n  vector<ll> blue(n+1);\n  rep(i, n) {\n    red[i+1] = red[i];\n    blue[i+1] = blue[i];\n    if (s[i] == '0') {\n      red[i+1] += 2;\n    } else if (s[i] == '1') {\n      red[i+1]++; blue[i+1]++;\n    } else {\n      blue[i+1] += 2;\n    }\n  }\n\n  dp[0][0] = 1;\n  for(int i=1; i<=nn; i++) {\n    for(int j=0; j<=i; j++) {\n      int k = i-j;\n      if (j==0 && k==0) continue;\n      int tmp = min(n, i);\n      //debug(tmp);debug(blue[tmp]);debugln(red[tmp]);\n      if (j <= blue[tmp] && k <= red[tmp]) {\n        if (j>0) dp[j][k] += dp[j-1][k];\n        dp[j][k] %= mod;\n        if (k>0) dp[j][k] += dp[j][k-1];\n        dp[j][k] %= mod;\n        //debug(j);debug(k);debugln(dp[j][k]);\n      }\n    }\n  }\n\n  ll ans = 0;\n  for(int j=0; j<=nn; j++) {\n    ans += dp[j][nn-j];\n    ans %= mod;\n  }\n  cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 998244353;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n    int n = s.length();\n    vector<vector<ll>> dp(2 * n + 1, vector<ll>(2 * n + 1, 0));\n    dp[0][0] = 1;\n    vector<vector<ll>> sum(n + 1, vector<ll>(2, 0));\n    s = \"$\" + s;\n    for (int i = 1; i <= n; i++)\n    {\n        sum[i][0] = sum[i - 1][0];\n        sum[i][1] = sum[i - 1][1];\n        if (s[i] == '0')\n        {\n            sum[i][0] += 2;\n        }\n        else if (s[i] == '1')\n        {\n            sum[i][0]++;\n            sum[i][1]++;\n        }\n        else\n        {\n            sum[i][1] += 2;\n        }\n    }\n    // i := 赤の個数\n    // j := 青の個数\n    for (int i = 0; i <= 2 * n; i++)\n    {\n        for (int j = 0; j <= 2 * n; j++)\n        {\n            int turn = min(i + j, n);\n            bool red = (sum[turn][0] >= i) && (i > 0);\n            bool blue = (sum[turn][1] >= j) && (j > 0);\n            if (red)\n            {\n                dp[i][j] += dp[i - 1][j];\n                dp[i][j] %= MOD;\n            }\n            if (blue)\n            {\n                dp[i][j] += dp[i][j - 1];\n                dp[i][j] %= MOD;\n            }\n        }\n    }\n    cout << dp[sum[n][0]][sum[n][1]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2000;\nconst int N2 = N * 2 + 1;\nconst int MOD = 998244353;\n\nvoid update(int& x, int a)\n{\n  x += a;\n  if (x >= MOD) {\n    x -= MOD;\n  }\n}\n\nchar s[N + 1];\nint dp[2][N2];\n\nint main()\n{\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  int reds = 0, blues = 0;\n  for (int i = 0; i < 2 * n; ++ i) {\n    memset(dp[i + 1 & 1], 0, sizeof(dp[i + 1 & 1]));\n    int b = i < n ? s[i] - '0' : 0;\n    int r = i < n ? 2 - b : 0;\n    for (int j = 0; j <= i; ++ j) {\n      if (dp[i & 1][j]) {\n        if (j + 1 <= reds + std::min(r, 1)) {\n          update(dp[i + 1 & 1][j + 1], dp[i & 1][j]);\n        }\n        if (i - j + 1 <= blues + std::min(b, 1)) {\n          update(dp[i + 1 & 1][j], dp[i & 1][j]);\n        }\n      }\n    }\n    reds += r;\n    blues += b;\n  }\n  int result = 0;\n  for (int j = 0; j <= 2 * n; ++ j) {\n    update(result, dp[2 * n & 1][j]);\n  }\n  printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 998244353;\n\nstring str;\n\nll dp[4010][4010];\nll sum[4010];\nll sum2[4010];\n\nint main() {\n    cin >> str;\n    ll n = str.size();\n    rep(i,n) {\n        if (str[i] == '0') sum[i] = 2;\n        else if (str[i] == '1') sum[i] = 1;\n    }\n    for (int i = 1; i < 2*n; i++) sum[i] += sum[i-1];\n    rep(i,n) {\n        if (str[i] == '2') sum2[i] = 2;\n        else if (str[i] == '1') sum2[i] = 1;\n    }\n    for (int i = 1; i < 2*n; i++) sum2[i] += sum2[i-1];\n    dp[0][0] = 1;\n    rep(i,2*n) {\n        rep(j,2*n+1) {\n            if (sum[i] > j) {\n                dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%MOD;\n            }\n            if (sum2[i] > i-j) {\n                dp[i+1][j] = (dp[i+1][j]+dp[i][j])%MOD;\n            }\n        }\n    }\n    cout << dp[2*n][sum[2*n-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define IL inline\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int U;\ntypedef unsigned long long LLU;\ntypedef pair<int,int> PII;\ntypedef long double LD;\nIL LL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\n#define io read()\nconst int mod=998244353;\nconst int N=2008;\nchar s[N];\nint n; \nint nr[N*2],nb[N*2];\nint f[N*2][N*2],ans;\nIL void upd(int &x,int y)\n{\n\tx+=y;\n\tif(x>=mod)\tx-=mod;\t\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;++i){\n\t\tint t=0,p=0;\n\t\tif(s[i]=='0')\tt=2,p=0;\n\t\telse if(s[i]=='1')\tt=1,p=1;\n\t\telse\tt=0,p=2;\n\t\tnr[i]=nr[i-1]+t;\t\n\t\tnb[i]=nb[i-1]+p;\n\t}\n\tfor(int i=n+1;i<=n+n;++i){\n\t\tnr[i]=nr[n];\n\t\tnb[i]=nb[n];\t\n\t}\n\tfor(int i=1;i<=n+n;++i){\n\t//\tcout<<\"!!\"<<i<<' '<<nr[i]<<' '<<nb[i]<<'\\n';\t\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<n+n;++i){\n\t\tfor(int j=0;j<=i;++j){\n\t\t\t//cout<<i<<' '<<j<<' '<<f[i][j]<<'\\n';\n\t\t\tif(nr[i+1]>j){\n\t\t\t\tupd(f[i+1][j+1],f[i][j]);\n\t\t\t}\t\n\t\t\tif(nb[i+1]>i-j){\n\t\t\t\tupd(f[i+1][j],f[i][j]);\t\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=0;j<=n+n;++j){\n\t\tupd(ans,f[n+n][j]);\t\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"unroll-loops\")\n#pragma GCC push_options\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\n#include <xmmintrin.h>\n#include <immintrin.h>\nusing namespace::std;\n__attribute__((constructor))void init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\ntemplate<typename T>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T,typename E>using hash_map=__gnu_pbds::gp_hash_table<T,E>;\ntemplate<typename T>using pqueue =__gnu_pbds::priority_queue<T, greater<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n//#define MOD 1000000007LL\n#define MOD 998244353LL\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,n) for(lint i=0;i<lint(n);++i)\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrep(i,n) for(lint i=lint(n)-1;i>=0;--i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\n#define all(n) begin(n),end(n)\n#define dist(a,b,c,d) sqrt(pow(a-c,2)+pow(b-d,2))\ninline lint gcd(lint A,lint B){return B?gcd(B,A%B):A;}\ninline lint lcm(lint A,lint B){return A/gcd(A,B)*B;}\n// inline cint cgcd(cint A,cint B){return B?cgcd(B,A%B):A;}\n// inline cint clcm(cint A,cint B){return A/cgcd(A,B)*B;}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\nauto call=[&](auto f,auto... args){return f(f,args...);};\n \nclass mint {\n  using u64 = std::uint_fast64_t;\n    public:\n    u64 a;\n    constexpr mint(const u64 x = 0)noexcept:a(x % MOD){}\n    constexpr u64 &value()noexcept{return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr mint operator+(const mint rhs)const noexcept{return mint(*this) += rhs;}\n    constexpr mint operator-(const mint rhs)const noexcept{return mint(*this)-=rhs;}\n    constexpr mint operator*(const mint rhs) const noexcept {return mint(*this) *= rhs;}\n    constexpr mint operator/(const mint rhs) const noexcept {return mint(*this) /= rhs;}\n    constexpr mint &operator+=(const mint rhs) noexcept {\n        a += rhs.a;\n        if (a >= MOD)a -= MOD;\n        return *this;\n    }\n    constexpr mint &operator-=(const mint rhs) noexcept {\n        if (a<rhs.a)a += MOD;\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr mint &operator*=(const mint rhs) noexcept {\n        a = a * rhs.a % MOD;\n        return *this;\n    }\n    constexpr mint operator++(int n) noexcept {\n        a += 1;\n        if (a >= MOD)a -= MOD;\n        return *this;\n    }\n    constexpr mint operator--(int n) noexcept {\n        if (a<1)a += MOD;\n        a -= 1;\n        return *this;\n    }\n    constexpr mint &operator/=(mint rhs) noexcept {\n        u64 exp=MOD-2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    mint pow(long long n){\n        long long x=a;\n        mint ret = 1;\n        while(n>0) {\n            if(n&1)(ret*=x);\n            (x*=x)%=MOD;\n            n>>=1;\n        }\n        return ret;\n    }\n    mint inv()const{\n        int _a=a,b=MOD,u=1,v=0,t;\n        while(b>0) {\n            t=_a/b;\n            swap(_a-=t*b,b);\n            swap(u-=t*v,v);\n        }\n        return mint(u);\n    }\n    mint comb(lint b){\n        using lint=long long;\n        static bool init=1;\n        static lint fac[1000001],ifac[1000001];\n        if(init){\n            init=0;\n            fac[0]=1;\n            ifac[0]=1;\n            auto mod_pow=[&](lint x,lint n){\n                lint ans = 1;\n                while(n != 0){\n                    if(n&1)ans=ans*x%MOD;\n                    x=x*x%MOD;\n                    n=n>>1;\n                }\n                return ans;\n            };\n            for(int i=0;i<1000000;i++){\n                fac[i+1]=fac[i]*(i+1)%MOD;\n                ifac[i+1]=ifac[i]*mod_pow(i+1, MOD-2)%MOD;\n            }\n        }\n        if(a==0&&b==0)return 1;\n        if((lint)a<b||a<0)return 0;\n        lint tmp=ifac[a-b]*ifac[b]%MOD;\n        return tmp*fac[a]%MOD;\n    }\n    \n    friend ostream& operator<<(ostream& lhs, const mint& rhs) noexcept {\n        lhs << rhs.a;\n        return lhs;\n    }\n    friend istream& operator>>(istream& lhs,mint& rhs) noexcept {\n        lhs >> rhs.a;\n        return lhs;\n    }\n};\ninline mint fact(lint a){return a?fact(a-1)*a:1;}\n\nint main(){\n    string s;\n    cin>>s;\n    lint n=s.size();\n    vec a(n,0);\n    a[0]=s[0]-'0';\n    repi(i,1,n)a[i]=a[i-1]+s[i]-'0';\n    vector<vector<mint>> dp(2*n+1,vector<mint>(2*n,0));\n    dp[0][0]=1;\n    repi(i,1,n+1)rep(j,a[i-1]+1){\n        if(j==0)dp[i][j]+=dp[i-1][j];\n        else dp[i][j]+=dp[i-1][j-1]+dp[i-1][j];\n        if(j<a[i-1]-i)dp[i][j]=0;\n    }\n    repi(i,n+1,2*n+1)rep(j,a.back()+1){\n        if(j==0)dp[i][j]+=dp[i-1][j];\n        else dp[i][j]+=dp[i-1][j-1]+dp[i-1][j];\n        if(j<a.back()-i)dp[i][j]=0;\n    }\n    cout<<dp[2*n][a.back()]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\ntemplate <long long mod>\nstruct modular {\n    long long value;\n    modular(long long x = 0LL) {\n        value = x % mod;\n        if (value < 0LL) value += mod;\n    }\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0LL) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        long long a = 0LL, b = 1, c = other.value, m = mod;\n        while (c != 0LL) {\n            long long t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0LL) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular operator-() { return modular(-value); }\n    modular operator+(modular rhs) { return modular(*this) += rhs; }\n    modular operator-(modular rhs) { return modular(*this) -= rhs; }\n    modular operator*(modular rhs) { return modular(*this) *= rhs; }\n    modular operator/(modular rhs) { return modular(*this) /= rhs; }\n    bool operator==(modular rhs) { return value == rhs.value; }\n    bool operator!=(modular rhs) { return value != rhs.value; }\n    bool operator<(modular rhs) { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0LL) x.value += mod;\n    return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0LL) x.value += mod;\n    return stream;\n};\nconst long long mod = 998244353LL;\nusing mint = modular<mod>;\n\ninline mint pw(mint a, long long n) {\n    mint res = 1;\n    while (n > 0LL) {\n        if (n & 1LL) {\n            res *= a;\n        }\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\nvector<mint> fact, finv;\ninline void cinit(int n) {\n    fact.resize(n, mint(1));\n    finv.resize(n, mint(1));\n    for (int i = 2; i < n; i++) {\n        fact[i] = fact[i - 1] * i;\n    }\n    finv[n - 1] /= fact[n - 1];\n    for (int i = n - 2; i >= 2; i--) {\n        finv[i] = finv[i + 1] * (i + 1);\n    }\n}\ninline mint C(int n, int k) {\n    if (n < k || k < 0 || n < 0) {\n        return mint(0LL);\n    }\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a, b;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '0') {\n            a.emplace_back(i);\n            a.emplace_back(i);\n        } else if (s[i] == '1') {\n            a.emplace_back(i);\n            b.emplace_back(i);\n        } else {\n            b.emplace_back(i);\n            b.emplace_back(i);\n        }\n    }\n    int x = a.size(), y = b.size();\n    vector<vector<mint>> dp(x + 1, vector<mint>(y + 1));\n    dp[0][0] = 1;\n    for (int i = 0; i <= x; i++) {\n        for (int j = 0; j <= y; j++) {\n            if (i != x && a[i] <= i + j) {\n                dp[i + 1][j] += dp[i][j];\n            }\n            if (j != y && b[j] <= i + j) {\n                dp[i][j + 1] += dp[i][j];\n            }\n        }\n    }\n    cout << dp[x][y] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=2e3;\nstring S;\nll dp[MAX_N*2+1][MAX_N*2+1];\nint rcnt[MAX_N+1],bcnt[MAX_N+1];\nint main(){\n\tcin>>S;\n\tint N=(int)S.size();\n\tREP(i,N){\n\t\tint b=S[i]-'0';\n\t\tbcnt[i+1]=bcnt[i]+b;\n\t\trcnt[i+1]=rcnt[i]+2-b;\n\t}\n\tdp[rcnt[N]][bcnt[N]]=1;\n\tfor(int n=rcnt[N]-1;n>=0;n--){\n\t\tfor(int m=bcnt[N]-1;m>=0;m--){\n\t\t\tint rlb=lower_bound(rcnt,rcnt+N+1,n)-rcnt,blb=lower_bound(bcnt,bcnt+N+1,m)-bcnt;\n\t\t\tif(n+m>=rlb){\n\t\t\t\tdp[n][m]+=dp[n+1][m];\n\t\t\t}\n\t\t\tif(n+m>=blb){\n\t\t\t\tdp[n][m]+=dp[n][m+1];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define sp << \" \" <<\n#define mod 998244353\n\nlong long d[2005][2005];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int dp[2001][2001];\n    dp[0][0]=1;\n\tdp[1][0]=1;\n\tdp[1][1]=1;\n\tfor(int i=2;i<=2000;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n        {\n\t\t\tif(!j)\n\t\t\t{\n\t\t\t\tdp[i][j]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j]+dp[i-1][j-1];\n\t\t\t\tdp[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n    string s;\n    cin >> s;\n    if(s[0]=='0')\n        d[0][2]=1;\n    else if(s[0]=='1')\n        d[1][1]=1;\n    else\n        d[2][0]=1;\n    for(int k=1;k<s.length();k++)\n    {\n        int l=k+2;\n        for(int i=0;i<=l;i++)\n        {\n            if(s[k]=='0')\n            {\n                if(i!=0)\n                    d[i-1][l-i+2]+=d[i][l-i]%mod;\n                d[i][l-i+1]+=d[i][l-i]%mod;\n            }\n            else if(s[k]=='1')\n            {\n                if(i!=0)\n                    d[i][l-i+1]+=d[i][l-i]%mod;\n                if(i!=l)\n                    d[i+1][l-i]+=d[i][l-i]%mod;\n            }\n            else\n            {\n                if(i!=l)\n                    d[i-1+2][l-i-1]+=d[i][l-i]%mod;\n                d[i+1][l-i]+=d[i][l-i]%mod;\n            }\n        }\n    }\n    int l=s.length();\n    l++;\n    long long p=0;\n    for(int i=0;i<=l;i++)\n    {\n        p+=d[i][l-i]*dp[l][i];\n        p%=mod;\n    }\n    cout << p;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\nint p = 998244353;\nint M = 0x7777777777777777777777777;\nint N;\nint rok[2048];\nint bok[2048];\nint dp[2048][2048];\n\nint solve(int r, int b) {\n\tif(r+b==0) {\n\t\treturn 1;\n\t}\n\tif(!dp[r][b]) {\n\t\tint ret = 0;\n\t\tif(r<=rok[r+b] && b<=bok[r+b]) {\n\t\t\tif(r) {\n\t\t\t\tret += solve(r-1, b);\n\t\t\t}\n\t\t\tif(b) {\n\t\t\t\tret += solve(r, b-1);\n\t\t\t}\n\t\t\tif(p<=ret) {\n\t\t\t\tret -= p;\n\t\t\t}\n\t\t}\n\t\tdp[r][b] = ret ^ M;\n\t}\n\treturn dp[r][b] ^ M;\n}\n\nint main() {\n\tchar S[2048];\n\tscanf(\"%s\", S);\n\tint halfN = strlen(S);\n\tN = halfN+halfN;\n\tint rsum = 0;\n\tint bsum = 0;\n\t{\n\t\tint lateR = 0;\n\t\tint lateB = 0;\n\t\tfor(int n=0; n<halfN; ++n) {\n\t\t\tif(S[n]=='0') {\n\t\t\t\t++rsum;\n\t\t\t\tlateR = 1;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse if(S[n]=='1') {\n\t\t\t\t++rsum;\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 1;\n\t\t\t}\n\t\t\trok[n+1] = rsum;\n\t\t\tbok[n+1] = bsum;\n\t\t\trsum += lateR;\n\t\t\tbsum += lateB;\n\t\t}\n\t\tfor(int n=halfN; n<N+2; ++n) {\n\t\t\trok[n+1] = rsum;\n\t\t\tbok[n+1] = bsum;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", solve(rsum, bsum));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(4001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(2 * N + 1));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                dp[i][j] %= MOD;\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - b;\n                }\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    (dp[i + 1][j] += dp[i][j]) %= MOD;\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n            if(blue + red != N){\n                exit(-1);\n            }\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i] % MOD;\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = (left * right) % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// 01Trie BIT CHT DFT FFT avl cmd cusum dijkstra dinic geo2 gin graph kruskal lca lcm matrix ncm next_combination ppuf segtree st tmp topcoder uf vi \n\nint fact[1145140];\nint pascal_table[100][100];\n\n/*\n * tableをdoubleにしてncmの割合も求められる\n * 1/2して下ってゆくように書き換えてその場で作る.\n */\nvoid make_pascal(int mod)\n{\n    rep(i, 100) {\n        pascal_table[i][0] = 1;\n        for (int j = 1; j < i; j++) {\n            pascal_table[i][j] = (pascal_table[i-1][j-1] +\n                    pascal_table[i-1][j]) % mod;\n        }\n        pascal_table[i][i] = 1;\n    }\n}\n\nint gcd(int a, int b) { if (b == 0) return a; return gcd(b, a%b); }\n\nint extgcd(int a, int b, int &x, int &y)\n{\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else { x = 1; y = 0; }\n    return d;\n}\n\nint repow(int x, int n, int mod)\n{\n    if (n == 0) return 1;\n    int res = repow(x * x % mod, n / 2, mod);\n    if (n & 1) res = res * x % mod;\n    return res;\n}\n\nint mod_inverse(int a, int m)\n{\n    int x, y;\n    extgcd(a, m, x, y);\n    return ( m + x % m ) % m;\n}\n\nint table(int n, int p)\n{\n    int sum = 1;\n    fact[0] = 1;\n    Rep(i, n+2) {\n        sum *= i;\n        sum %= p;\n        fact[i] = sum;\n    }\n}\n\nint mod_fact(int n, int p, int &e)\n{\n    e = 0;\n    if (n == 0) return 1;\n    int res = mod_fact(n / p, p, e);\n    e += n / p;\n\n    if (n / p % 2 != 0) return res * (p - fact[n % p]) % p;\n    return res * fact[n % p] % p;\n}\n\n/*\n * nCr mod p\n * nHr = (n+r-1)Cr\n * 必ずtable()を呼んでから使う.\n * n = 1001000くらいで\n */\nint mod_comb(int n, int k, int p) {\n    if (n < 0 || k < 0 || n < k) return 0;\n    int e1, e2, e3;\n    int a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n-k, p, e3);\n    if (e1 > e2 + e3) return 0;\n    return a1 * mod_inverse(a2 * a3 % p, p) % p;\n}\n\nint ncm(int n, int r)\n{\n    if (r == 0) return 1;\n    return (n-r+1) * ncm(n, r-1) / r;\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string st;\n    cin >> st;\n\n    int mod = 998244353;\n    table(1001000, mod);\n\n    vvi dp(st.size()*2+2, vi(st.size()*2+2, 0));\n    dp[0][0] = 1;\n    int mmn = 0, mm = 0;\n    rep(i, st.size()) {\n        if (st[i] == '0') {\n            mmn += 2;\n        } else if (st[i] == '2') {\n            mm += 2;\n        } else {\n            mmn++; mm++;\n        }\n        rep(j, mmn) {\n            dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod;\n        }\n        rep(j, min(mm, i+1)) {\n            dp[i+1][i-j] = (dp[i+1][i-j] + dp[i][i-j]) % mod;\n        }\n        //cout << mmn << \" \" << mm << endl;\n        //rep(j, i+2) cout << dp[i+1][j] << \" \"; cout << endl;\n    }\n\n    /*\n    rep(i, st.size()+1) {\n        rep(j, i+1) {\n            cout << dp[i][j] << \" \";\n        }cout << endl;\n    }\n    //*/\n\n    int ans = 0;\n    rep(i, dp[st.size()].size()) {\n        ans = (ans + \n                dp[st.size()][i] * mod_comb(st.size(), mmn-i, mod)) % mod;\n    }\n\n    std::cout << ans << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef gp_hash_table<long long, long long> umap;\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (long long i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (long long i = (n) - 1; i >= 0; i--)\n#define foreach(it,ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar,val) memset(ar, val, sizeof(ar))\n#define fill0(ar) fill((ar), 0)\n#define fillinf(ar, n) fr(i,0,(n)) ar[i] = INF\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define arr1d(a,n) cout << #a << \" : \"; fr(_,1,n) cout << a[_] << ' '; cout << endl;\n#define arr1d0(a,n) cout << #a << \" : \"; rep(_,n) cout << a[_] << ' '; cout << endl;\n#define arr2d(a,n,m) cout << #a << \" :\" << endl; fr(_,1,n) {fr(__,1,m) cout << a[_][__] << ' '; cout << endl;}\n#define arr2d0(a,n,m) cout << #a << \" :\" << endl; rep(_,n) {rep(__,m) cout << a[_][__] << ' '; cout << endl;}\n/*Author Ritick Goenka || ritick(codechef) ||ritick(codeforces) */\n/*IIT Roorkee = <3 */\n#define ull unsigned long long\n#define ll long long\n#define ld double\n#define ui unsigned int\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define y0 yyyyyy0\n#define y1 yyyyyy1\n#define sot(bello) bello.begin(),bello.end()\n#define BIT(n) (1<<(n))\n#define SQR(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n#define LSOne(S) (S) & (-S)\ninline bool EQ(double a, double b) {return fabs(a - b) < 1e-9;}\n \ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n \n \ntemplate<typename T>inline T gcd(T a, T b){if (b == 0)return a;else return gcd(b, a % b);}\ntemplate<typename T>inline T lcm(T a, T b){return (a * b) / gcd(a, b);}\ntemplate<typename T> string toStr(T x) {stringstream st; st << x; string s; st >> s; return s;}\ntemplate<class T>\nvoid splitStr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n \ninline int two(int n) {return 1 << n;}\ninline int isOnBit(int n, int b) {return (n >> b) & 1;}\ninline void onBit(int & n, int b) {n |= two(b);}\ninline void offBit(int & n, int b) {n &= ~two(b);}\ninline int lastBit(int n) {return n & (-n);}\ninline int cntBit(int n) {int res = 0; while(n && ++res) n -= n &(-n); return res;}\n \nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy8[] = {0, 1, 0, -1, -1, 1, -1, 1};\n \n#define INP \"test.inp\"\n#define OUT \"test.out\"\n \n#define PI 3.1415926535897932385\n#define INF 1000000000000000\n#define EPS 1e-7\n#define MAXN 100000\n#define MOD 998244353\n#define dec decr\n//END OF COMPETITVE PROGRAMMING TEMPLATE\nll gcd(ll a, ll b) \n{ \n    if (a == 0) \n        return b; \n    return gcd(b % a, a); \n} \nll modexp(ll x, ll y, ll p)\n{\n    ll res = 1;   \n    x = x % p;  \n    while (y > 0)\n    {\n        if (y & 1)    \n            res = (res*x) % p;\n        y = y>>1;     \n        x = (x*x) % p; \n    }\n    return res;\n}\nll dp[6005][6005];\nll r[6005];\nll r1[6005];\nll b1[6005];\nll b[6005];\nll n1;\nll fn(ll br,ll bb)\n{\n    // debug(br);\n    // debug(bb);\n    if(br<0||bb<0)\n        return 0;\n    ll n=br+bb;\n    // if((br<r[n]||bb<b[n]))\n        // return 0;\n    if(br>r1[n]||bb>b1[n])\n        return 0;\n    if(dp[br][bb]!=-1)\n        return dp[br][bb];\n    return dp[br][bb]=(fn(br-1,bb)+fn(br,bb-1))%MOD;\n \n}\n \nint main () \n{\n    ios_base::sync_with_stdio(false);\n            cin.tie(NULL);\n        cout<<setprecision(11);\n            string s;\n            cin>>s;\n            ll x=0;\n            ll rc=0,bc=0;\n            rep(i,6005)\n            {\n                rep(j,6005)\n                    dp[i][j]=-1;\n            }\n            ll n=s.length();\n            // debug(n);\n            n1=n;\n            dp[0][0]=1;\n            rep(i,n)\n            {\n                // debug(i);\n                if(s[i]=='0')\n                {\n                    rc++;\n                    r1[i+1]=r1[i]+2;\n                    b1[i+1]=b1[i];\n\n                }\n                else if(s[i]=='2')\n                {\n                    bc++;\n                    b1[i+1]=b1[i]+2;\n                    r1[i+1]=r1[i];\n\n                }\n                else\n                {\n                    r1[i+1]=r1[i]+1;\n                    b1[i+1]=b1[i]+1;\n                }\n                r[i+1]=max(r[i],rc-bc);\n                b[i+1]=max(b[i],bc-rc);\n                // debug(b1[i+1]);\n                //     debug(r1[i+1]);\n            }\n            rep(i,n)\n            {\n                // debug(r1[i+1]);\n                // debug(b1[i+1]);\n                r1[n+i+1]=r1[n+i];\n                b1[n+i+1]=b1[n+i];\n\n                r[n+i+1]=r[n+i];\n                b[n+i+1]=b[n+i];\n            }\n            // debug(n-bc+rc);\n            // debug(n);\n            cout<<fn(n-bc+rc,n-rc+bc);\n            return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n\n#define N 300005\n#define M 8000005\n\n#define ls (t<<1)\n#define rs ((t<<1)|1)\n#define mid ((l+r)>>1)\n\n#define mk make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nint i,j,m,n,p,k,f[2005][2005],ans,C[2005][2005];\n\nchar c[2005];\n\n#define Mo 998244353\n\nint main()\n{\n\t\tscanf(\"%s\",c+1);\n\t\tn=strlen(c+1);\n\t\tf[0][0]=1;\n\t\tfor (i=0;i<2005;++i)\n\t\t{\n\t\t\t\tC[i][0]=1;\n\t\t\t\tfor(j=1;j<=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mo;\n\t\t}\n\t\tfor (i=0;i<n;++i)\n\t\t\tfor (j=0;j<=i;++j)\n\t\t\t\t\tif (f[i][j])\n\t\t\t\t{\n\t\t\t\t\t\tint a=j,b=i-j;\n\t\t\t\t\t\tif (c[i+1]=='0') a+=2;\n\t\t\t\t\t\tif (c[i+1]=='1') a++,b++;\n\t\t\t\t\t\tif (c[i+1]=='2') b+=2;\n\t\t\t\t\t\tif (a>0) (f[i+1][a-1]+=f[i][j])%=Mo;\n\t\t\t\t\t\tif (b>0) (f[i+1][a]+=f[i][j])%=Mo;\n\t\t\t\t}\n\t\tfor (i=0;i<=n;++i) if (f[n][i]) (ans+=1ll*f[n][i]*C[n][i]%Mo)%=Mo;\n\t\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <complex>\n#include <stdlib.h>\n#include <stdio.h>\n#include <functional>\n#include <cfloat>\n#include <math.h>\n#include <numeric>\n#include <string.h>\n\n\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll mod = 998244353;\nll fact[210200];\nll invfact[210200];\n\ninline ll take_mod(ll a){\n    return (a % mod + mod) % mod;\n}\n\ninline ll add(ll a, ll b){\n    return take_mod(a+b);\n}\n\ninline ll sub(ll a, ll b){\n    return take_mod(a-b);\n}\n\n\ninline ll mul(ll a, ll b){\n    return take_mod(a * b);\n}\n\ninline ll powMod(ll x, ll n){\n    ll res = 1LL;\n    while(n > 0){\n        if(n & 1) res = mul(res, x);\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n\nll mod_inv(ll x){\n    return powMod(x, mod-2);\n}\n\n// nは上限\nvoid make_fact(ll n){\n    fact[0] = 1;\n    ll res = 1;\n    for(int i = 1; i <= n; i++){\n        fact[i] = res;\n        res = mul(res, i+1);\n    }\n}\n\n// nは上限\nvoid make_invfact(ll n){\n    invfact[0] = 1;\n    invfact[n] = mod_inv(fact[n]);\n    for(int i = n-1; i >= 1; i--){\n        invfact[i] = mul(invfact[i + 1], i + 1);\n    }\n}\n\nll perm(ll n, ll k){\n    return mul(fact[n], invfact[n-k]);\n}\n\nll comb(ll n, ll k){\n    return mul(mul(fact[n], invfact[n-k]), invfact[k]);\n}\n\nll dp[4100][4100];\n\nint main(){\n    string s;\n    cin >> s;\n\n    int red[4100], blue[4100];\n    red[0] = 0;\n    blue[0] = 0;\n\n    int redNum = 0, blueNum = 0;\n    int redTotal = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(s[i] == '0'){\n            redNum += 2;\n            redTotal += 2;\n        }\n        else if(s[i] == '1'){\n            redNum++;\n            redTotal++;\n            blueNum++;\n        }\n        else{\n            blueNum += 2;\n        }\n        if(redNum > 0){\n            red[i+1] = red[i] + 1;\n            redNum--;\n        }\n        else{\n            red[i+1] = red[i];\n        }\n\n        if(blueNum > 0){\n            blue[i+1] = blue[i] + 1;\n            blueNum--;\n        }\n        else{\n            blue[i+1] = blue[i];\n        }\n    }\n    for(int i = s.length(); i < 2 * s.length(); i++){\n        if(redNum > 0){\n            red[i+1] = red[i] + 1;\n            redNum--;\n        }\n        else{\n            red[i+1] = red[i];\n        }\n        if(blueNum > 0){\n            blue[i+1] = blue[i] + 1;\n            blueNum--;\n        }\n        else{\n            blue[i+1] = blue[i];\n        }\n    }\n\n    for(int i = 0; i < 4100; i++){\n        for(int j = 0; j < 4100; j++){\n            dp[i][j] = 0;\n        }\n    }\n\n    dp[0][0] = 1;\n    for(int i = 0; i < 2 * s.length(); i++){\n        for(int j = 0; j <= i; j++){\n            if(red[i+1] >= j + 1){\n                dp[i+1][j+1] = add(dp[i+1][j+1], dp[i][j]);   // 赤を渡す\n            }\n            if(blue[i+1] >= (i - j) + 1){\n                dp[i+1][j] = add(dp[i+1][j], dp[i][j]);       // 青を渡す\n            }\n        }\n    }\n\n    cout << dp[2 * s.length()][redTotal] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 4e3 + 5, MOD = 998244353;\nint dp[N][N];\n\nvoid add(int &a, int b) {\n    a += b;\n    if (a >= MOD)   \n        a -= MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string s;\n    cin >> s;\n\n    dp[0][0] = 1;\n\n    int red = 0, n = s.size();\n\n    for (int i = 0; i < n * 2; i++) {\n        if (i < n)\n            red += s[i] - '0';\n        for (int j = 0; j <= red; j++) {\n            if (j + 1 <= red) {\n                add(dp[i + 1][j + 1], dp[i][j]);\n            }\n            if (min(n, i + 1) * 2 - red - (i - j) > 0) {\n                add(dp[i + 1][j], dp[i][j]);\n            }\n        }\n    }\n\n    cout << dp[2 * n][red] << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MOD 998244353\n\nstring s;\nint n;\n\nlong long memo[4010][4010] = {};\n\nlong long dp(int i, int r, int b){\n  if(i == n*2){\n    return 1;\n  }\n\n  int oldr;\n  oldr = r;\n  if(memo[i][r] != -1){\n    return memo[i][r];\n  }\n\n  if(i < n){\n    if(s[i] == '0'){\n      r += 2;\n    }else if(s[i] == '1'){\n      r++; b++;\n    }else{\n      b += 2;\n    }\n  }\n\n  long long ans = 0;\n  if(r > 0){\n    ans = (ans + dp(i+1, r-1, b)) % MOD;\n  }\n  if(b > 0){\n    ans = (ans + dp(i+1, r, b-1)) % MOD;\n  }\n\n  return memo[i][oldr] = ans;\n}\n\nint main(){\n  cin >> s;\n  n = s.size();\n\n  memset(memo, -1, sizeof(memo));\n\n  cout << dp(0, 0, 0) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define all(v) (v).begin(),(v).end()\ntemplate<class T>bool chmax(T &a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate<class T>bool chmin(T &a,T b){if(b<a){a=b;return 1;} return 0;}\n\nint dx[4] = {0,0,-1,1};\nint dy[4] = {1,-1,0,0};\nstring rlud = \"RLUD\";\n\n\nconst int MAX = 10000;\nconst int mod = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\nll dp[2001][2001];\n\n// run : ctrl + c \nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    \n    string s;\n    cin>>s;\n    int n = s.size();\n    COMinit();\n    int r=0,b=0;\n    dp[0][0] = 1;\n    for(int i=0;i<n;i++){\n        int nb=b,nr=r;\n        if(s[i]=='0')nr+=2;\n        if(s[i]=='2')nb+=2;\n        if(s[i]=='1')nr++,nb++;\n        for(int j=0;j<=i;j++){\n            if(r>=j && b>=i-j){\n                if(nr-j>0){\n                    dp[i+1][nr-j-1] += dp[i][r-j];\n                    dp[i+1][nr-j-1] %= mod;\n                }\n                if(nb-(i-j)>0){\n                    dp[i+1][nr-j] += dp[i][r-j];\n                    dp[i+1][nr-j] %= mod;\n                }\n            }\n        }\n        r=nr, b=nb;\n    }\n    ll ans = 0;\n    for(int i=0;i<=n;i++){\n        ans += (dp[n][i] * COM(n,i))%mod;\n        ans %= mod;\n    }\n    cout << ans << endl;\n\n    \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\n#ifdef int\nconstexpr int INF = LLONG_MAX / 10;\n#else\nconstexpr int INF = INT_MAX / 10;\n#endif\nconstexpr double eps = 1e-9;\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline ll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline ll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(ll n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nll mypow(ll a, ll b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tll memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass modInt {\n\tll value;\npublic:\n\tmodInt() : value(0) {}\n\ttemplate<typename T>\n\tmodInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(int)(-value % (int)modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline modInt& operator+=(const modInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator++() {\n\t\tif (value == modulo- 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline modInt operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline modInt& operator-=(const modInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline modInt& operator*=(const modInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> modInt operator+(const T& rhs)const { return modInt(*this) += rhs; }\n\ttemplate<typename T> modInt& operator+=(const T& rhs) { return operator+=(modInt(rhs)); }\n\ttemplate<typename T> modInt operator-(const T& rhs)const { return modInt(*this) -= rhs; }\n\ttemplate<typename T> modInt& operator-=(const T& rhs) { return operator-=(modInt(rhs)); }\n\ttemplate<typename T> modInt operator*(const T& rhs)const { return modInt(*this) *= rhs; }\n\ttemplate<typename T> modInt& operator*=(const T& rhs) { return operator*=(modInt(rhs)); }\n\ttemplate<typename T> modInt operator/(const T& rhs)const { return modInt(*this) /= rhs; }\n\ttemplate<typename T> modInt& operator/=(const T& rhs) { return operator/=(modInt(rhs)); }\n};\nint n, r[2010];\nstring s;\nmodInt<998244353> dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=998244353;\n\nint N;\nchar buf[114514];\nLL dp[4145][4145];\nint R[2145];\nint B[2145];\n\nint main() {\n  scanf(\"%s\", buf);\n  N = strlen(buf);\n  reps(i, 1, N+1) {\n    R[i] = R[i-1];\n    B[i] = B[i-1];\n    if (buf[i-1] == '0') R[i] += 2;\n    else if (buf[i-1] == '2') B[i] += 2;\n    else if (buf[i-1] == '1') {\n      R[i]++;\n      B[i]++;\n    } else assert(0);\n  }\n\n  dp[0][0] = 1;\n  reps(i, 1, 2*N+1) {\n    rep(a, i) {\n      LL v = dp[i-1][a];\n      int b = i-1 - a;\n\n      int t = min(i, N);\n      int rrem = R[t]-a;\n      if (rrem > 0) {\n        dp[i][a+1] += v;\n        dp[i][a+1] %= MOD;\n      }\n\n      int brem = B[t]-b;\n      if (brem > 0) {\n        dp[i][a] += v;\n        dp[i][a] %= MOD;\n      }\n    }\n  }\n\n  LL ans = 0;\n  rep(i, 2*N+1) {\n    ans += dp[2*N][i];\n    ans %= MOD;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ninline int add(int x,int y)\n{\n    return (x + y)%MOD;\n}\n\ninline int sub(int x,int y)\n{\n    return (x+MOD-y)%MOD;\n}\n\ninline int mul(int x,int y)\n{\n    return (ll)x*y%MOD;\n}\n\nint dp[MAX_N][MAX_N], ok[MAX_N][MAX_N];\nint tma[2*MAX_N], tmb[2*MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    dp[0][0] = 1;\n    vi apos, bpos;\n    rep(i,n){\n        if(s[i] == '0'){\n            apos.pb(i+1), apos.pb(i+1);\n        }else if(s[i] == '1'){\n            apos.pb(i+1), bpos.pb(i+1);\n        }else{\n            bpos.pb(i+1), bpos.pb(i+1);\n        }\n    }\n    rep(i,len(apos)+1){\n        rep(j,len(bpos)+1){\n            ok[i][j] = INF;\n        }\n    }\n    ok[0][0] = 0;\n    rep(i,len(apos)+1){\n        rep(j,len(bpos)+1){\n            if(i > 0){\n                cmn(ok[i][j], max(ok[i-1][j] + 1, apos[i-1]));\n            }\n            if(j > 0){\n                cmn(ok[i][j], max(ok[i][j-1] + 1, bpos[j-1]));\n            }\n        }\n    }\n    rep(i,len(apos)+1){\n        rep(j,len(bpos)+1){\n            if(i < len(apos) && ok[i+1][j] <= i+j+1){\n                dp[i+1][j] = add(dp[i+1][j], dp[i][j]);\n            }\n            if(j < len(bpos) && ok[i][j+1] <= i+j+1){\n                dp[i][j+1] = add(dp[i][j+1], dp[i][j]);\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,2*n+1){\n        ans = add(ans, dp[i][2*n-i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 998244353;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nconst int calender[13] = {0, 31,28,31,30,31,30,31,31,30,31,30,31};\nconst int ucalender[13] = {0, 31,29,31,30,31,30,31,31,30,31,30,31};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\nstatic const long long MOD=1e9 + 7;\n\nlong long modinv(long long a, const long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}//mod mでの逆元aを計算\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstruct combination{\n    int mod = MOD;\n    vector<long long> fact, ifact, inv;\n    combination(int n, const int tmp = MOD):fact(n+1), ifact(n + 1), inv(n+1){\n        mod = tmp;\n        assert(n < mod);\n        fact[0] = 1;\n        for(int i = 1; i <= n; i++) fact[i] = fact[i-1]*i%mod;\n        ifact[n] = modpow(fact[n], mod - 2, mod);\n        for(int i = n; i >= 1; --i) ifact[i-1] = ifact[i] * i%mod;\n        for(int i = 1; i <= n; i++) inv[i] = fact[i-1] * ifact[i] % mod;\n    }\n    long long C(int n, int k){\n        if(k < 0 || k > n) return 0;\n        return fact[n]*ifact[k]%mod*ifact[n-k] % mod;\n    }\n};\n// combination cb(10, 11); \n// cout << cb.C(10, 3) << endl;\n\n\nmodint dp[2010][2010];\n\nint main(){\n    iosetup();\n    string S; cin >> S;\n    int n = S.size();\n    memset(dp, 0, sizeof dp);\n    combination cb(n, mod);\n    dp[0][0] = 1;\n    int cnt = 0;\n    rep(i, 0, n){\n        cnt += S[i] - '0';\n        rep(j, 0, n + 1){\n            if((i + 1) - j <= 2 * (i + 1) - cnt)\n                dp[i+1][j] += dp[i][j];\n            if(j-1 >= 0 and cnt >= j)dp[i+1][j] += dp[i][j-1];\n        }\n    }\n    // rep(i, 1, n + 1){\n    //     rep(j, 0, 3){\n    //         cerr << dp[i][j] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    modint ans = 0;\n    rep(i, 0, n + 1){\n        ans += dp[n][i] * cb.C(n, cnt - i);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Mod=998244353;\nchar s[2010];\nint n,f[4010][4010],r[2010],b[2010];\nvoid upd(int &x,int v)\n{\n\tx=(x+v)%Mod;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tr[i]=r[i-1];\n\t\tb[i]=b[i-1];\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tr[i]+=2;\n\t\t}\n\t\telse if (s[i]=='1')\n\t\t{\n\t\t\tr[i]++;\n\t\t\tb[i]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[i]+=2;\n\t\t}\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n*2;i++)\n\t{\n\t\tfor (int j=0;j<=r[n];j++)\n\t\t{\n\t\t\tint v=f[i-1][j];\n\t\t\tif (!v)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i>n || j+1<=r[i-1] || (j==r[i-1] && (s[i]=='0' || (s[i]=='1' && i-j-1<=b[i-1]))))\n\t\t\t{\n\t\t\t\tupd(f[i][j+1],v);\n\t\t\t}\n\t\t\tif (i>n || i-j<=b[i-1] || (i-j-1==b[i-1] && (s[i]=='2' || (s[i]=='1' && j<=r[i-1]))))\n\t\t\t{\n\t\t\t\tif (i-j>b[n])\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tupd(f[i][j],v);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=r[n];i++)\n\t{\n\t\tupd(ans,f[n*2][i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* به نام یزدان */\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 4000 + 5, MOD = 998244353;\nint n, cnt[2][MAX_N], dp[MAX_N][MAX_N];\n\nvoid read_input() {\n\tstring s;\n\tcin >> s;\n\tn = s.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] == '0')\n\t\t\tcnt[0][i + 1] += 2;\n\t\telse if (s[i] == '1')\n\t\t\tcnt[0][i + 1]++, cnt[1][i + 1]++;\n\t\telse\n\t\t\tcnt[1][i + 1] += 2;\n\tfor (int j = 0; j < 2; j++)\n\t\tfor (int i = 1; i <= 2 * n; i++)\n\t\t\tcnt[j][i] += cnt[j][i - 1];\n}\n\nvoid solve() {\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tif (cnt[0][i] >= j && cnt[1][i] >= i - j) {\n\t\t\t\tif (j)\n\t\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\t\tif (i - j)\n\t\t\t\t\t(dp[i][j] += dp[i - 1][j]) %= MOD;\n\t\t\t}\n}\n\nvoid print_output() {\n\tint ans = 0;\n\tfor (int i = 0; i <= 2 * n; i++)\n\t\tans += dp[2 * n][i];\n\tcout << ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tread_input();\n\tsolve();\n\tprint_output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long ll;\n#define int ll\nll n,rnum,bnum;\nbool f[6005][6005],g[6005][6005];\nll dp[6005][6005]={0};\nconst ll mod=998244353;\nvoid need_red(vector<ll> vec){\n  vector<ll> need_num(6005,0);\n  ll pos=1,num=0;\n  for(int i=0;i<vec.size();i++){\n    if(vec[i]==0) num++;\n    else if(vec[i]==1){\n      need_num[pos]=num;\n      pos++;\n    }\n    else{\n      need_num[pos]=num;\n      pos++;\n      need_num[pos]=num;\n      pos++;\n    }\n  }\n  for(int i=0;i<6005;i++){\n    for(int j=0;j<6005;j++) f[i][j]=false;\n  }\n  for(int i=0;i<6005;i++){\n    for(int j=0;j<6005;j++){\n      if(j>=need_num[i]) f[i][j]=true;\n    }\n  }\n}\nvoid need_blue(vector<ll> vec){\n  vector<ll> need_num(6005,0);\n  ll pos=1,num=0;\n  for(int i=0;i<vec.size();i++){\n    if(vec[i]==0) num++;\n    else if(vec[i]==1){\n      need_num[pos]=num;\n      pos++;\n    }\n    else{\n      need_num[pos]=num;\n      pos++;\n      need_num[pos]=num;\n      pos++;\n    }\n  }\n  for(int i=0;i<6005;i++){\n    for(int j=0;j<6005;j++) g[i][j]=false;\n  }\n  for(int i=0;i<6005;i++){\n    for(int j=0;j<6005;j++){\n      if(i>=need_num[j]) g[i][j]=true;\n    }\n  }\n}\nint main(){\n  string s;\n  cin>>s;\n  n=s.length();\n  rnum=0;\n  bnum=0;\n  vector<ll> rball,bball;\n  for(int i=0;i<n;i++){\n    if(s[i]=='0') {\n      rball.push_back(2);\n      bball.push_back(0);\n      rnum+=2;\n    }\n    else if(s[i]=='1'){\n      rball.push_back(1);\n      bball.push_back(1);\n      rnum++; bnum++;\n    }\n    else{\n      rball.push_back(0);\n      bball.push_back(2);\n      bnum+=2;\n    }\n  }\n  need_red(rball);\n  need_blue(bball);\n  dp[0][0]=1;\n  for(int i=0;i<6005;i++){\n    for(int j=0;j<6005;j++){\n      dp[i][j]%=mod;\n    //  if(i<rnum){\n        if(f[i][j]&&g[i][j]&&f[i+1][j]) dp[i+1][j]+=dp[i][j];\n        dp[i+1][j]%=mod;\n    //  }\n    //  if(j<bnum){\n        if(f[i][j]&&g[i][j]&&g[i][j+1]) dp[i][j+1]+=dp[i][j];\n        dp[i][j+1]%=mod;\n    //  }\n    }\n  }\n  cout<<dp[rnum][bnum]%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YESNO OUT(three(solve(),\"YES\",\"NO\"))\n#define YesNo OUT(three(solve(),\"Yes\",\"No\"))\n#define WL(A,B) OUT(three(solve(),A,B))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntemplate<class T> inline bool chmax(int a, int b, T c, T d) { return c > d ? a : b; }\ntemplate<class T> inline bool chmin(int a, int b, T c, T d) { return c > d ? a : b; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<ut, VI, greater<LL> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 1e6 + 1000;\nconst int SIZE2 = 4010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p =998244353;\nconst LL INF = 1LL << 30;\nconst long double EPS = 1e-7;\nconst LL inf = 1000000000;\ntypedef pair<ld, ut> pld;\nut N, M, K, L, Q,  H, W, R;\nVI edges[SIZE];\nLL vals[SIZE], answer = zero;\n//LL maps[SIZE2][SIZE2];\nLL A[SIZE],B[SIZE],C[SIZE],D[SIZE],E[SIZE];\nLL DP[SIZE2][SIZE2];\nbool check[SIZE2][SIZE2];\nLL sumR[SIZE], sumB[SIZE];\nLL solve2(LL n,LL sum) {\n\tif (n == 0) return sum==0;\n\tif (sum < 0) return 0;\n\tif (check[n][sum]) return DP[n][sum];\n\tcheck[n][sum] = true;\n\tif (n <= N) {\n\t\tif (sumR[n ] < sum) return 0;\n\t\tif (sumB[n ] < n - sum) return 0;\n\t}\n\t//cout << n << \" \" << sum << \" \" << DP[n][sum] << endl;\n\treturn DP[n][sum] = (solve2(n - 1, sum) + solve2(n - 1, sum - 1))%p;\n}\nLL solve() {\n\tstring s;\n\tcin >> s;\n\tN = s.size();\n\tLL sum = 0;\n\tREP(i, s.size()) {\n\t\tA[i] = s[i] - '0';\n\t\tsum += A[i];\n\t\tsumR[i + 1] = sumR[i] + A[i];\n\t\tsumB[i + 1] = sumB[i] + (2-A[i]);\n\t}\n\treturn solve2(2 * N,sum);\n}\n\n\n\n\n//!!!!!!!!!!!!!!!!!!!実装を詰める!!!!!!!!!!!!!!!!!!!!!!!!!\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(0);\n\tcout << solve() << endl;\n\t\n\t//cin >> N;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\n\nint dp[4001][4001];\nsigned main(){\n\n    string S; cin >> S;\n    int N = S.size();\n    int r = 0, b = 0;\n    int mod = 998244353;\n\n    REP(i, 4001) REP(j, 4001) dp[i][j] = 0;\n    dp[0][0] = 1;\n    REP(i, 2 * N){\n        if(i < N){\n            if(S[i] == '0') r += 2;\n            else if(S[i] == '1'){\n                r += 1; b += 1;\n            }else b += 2;\n        }\n        REP(j, i + 1){\n            if(j + 1 <= b){\n                dp[i + 1][j + 1] += dp[i][j];\n                dp[i + 1][j + 1] %= mod;\n            }\n            if(i + 1 - j <= r){\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= mod;\n            }\n        }\n    }\n    cout << dp[2 * N][b] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 2e3 + 10; \nconst int MOD = 998244353;\nchar s[N];\nint dp[N*2][N*2];\nint sum[N], sm[N];\nint main() {\n\tint n;\n\tscanf(\"%s\", s+1);\n\tn = strlen(s+1);\n\tfor (int i = 1; i <= n; ++i) sum[i] = sum[i-1] + s[i]-'0';\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2*n; ++i) {\n\t\tint p = min(i, n);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif(sum[p] > j) dp[i][j+1] = (dp[i][j+1] + dp[i-1][j]) % MOD;\n\t\t\tif(2*i - sum[p] > i-1-j) dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD; \n\t\t}\n\t} \n\tprintf(\"%d\\n\", dp[2*n][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e3 + 5;\nconst int MOD = 998244353;\nvoid update(int& x, int y){x += y; if(x >= MOD) x -= MOD;}\nchar s[N];\nint C[N][N], f[N][N];\nint n;\nvoid init()\n{\n\tC[0][0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1;j <= i; j++)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tinit();\n\tint s1 = 0, s0 = 0;\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tint t = s[i] - '0';\n\t\ts0 += 2 - t;\n\t\ts1 += t;\n\t\tfor(int j=0;j<=min(s1,i);j++){\n\t\t\tif(j) update(f[i][j], f[i - 1][j - 1]);\n\t\t\tif(i-j <= s0) update(f[i][j], f[i - 1][j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= min(s1, n); i++)\n        update(ans, (ll)f[n][i] * C[n][s1-i] % MOD);\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::stringstream; using std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\nusing std::cerr;\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)                                                     \\\n  {                                                                            \\\n    cerr << #a << \" = {\";                                                      \\\n    for (int qwq = (st); qwq <= (n); ++qwq)                                    \\\n      if (qwq == (st))                                                         \\\n        cerr << a[qwq];                                                        \\\n      else                                                                     \\\n        cerr << \", \" << a[qwq];                                                \\\n    cerr << \"}\" << endl;                                                       \\\n  }\n#define displayv(a) displaya(a, 0, (int)(a.size() - 1))\n#include <ctime>\nclass MyTimer {\n    clock_t st;\npublic:\n    MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n    ~MyTimer() { report(); }\n    void reset() { st = clock_t(); }\n    void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define cerr if(false) std::cout\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(a) ;\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename A, typename B>\nstd::ostream& operator << (std::ostream &cout, const pair<A, B> &x) {\n    return cout << \"(\" << x.first << \", \" << x.second << \")\";\n}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 2000 + 5;\nconst int P = 998244353;\nvoid inc(int &x, int y) { (x += y) >= P ? x -= P : x; }\nvoid dec(int &x, int y) { (x -= y) <  0 ? x += P : x; }\nint n;\nchar s[maxN];\nint r[maxN], b[maxN];\nint f[maxN * 2][maxN * 2];\n\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    memset(r, 0, sizeof(r));\n    memset(b, 0, sizeof(b));\n    for(int i = 1; i <= n; ++ i) {\n        if(s[i] == '0') r[i] = r[i - 1] + 2, b[i] = b[i - 1];\n        if(s[i] == '1') r[i] = r[i - 1] + 1, b[i] = b[i - 1] + 1;\n        if(s[i] == '2') r[i] = r[i - 1], b[i] = b[i - 1] + 2;\n    }\n    memset(f, 0, sizeof(f));\n    f[0][0] = 1;\n    for(int R = 0; R <= r[n]; ++ R) {\n        for(int B = 0; B <= b[n]; ++ B) {\n//            printf(\"f(%d, %d) = %d\\n\", R, B, f[R][B]);\n            int len = std::min(R + B + 1, n);\n            if(R < r[len]) inc(f[R + 1][B], f[R][B]);\n            if(B < b[len]) inc(f[R][B + 1], f[R][B]);\n        }\n    }\n    cout << f[r[n]][b[n]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 998244353\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\nvoid add(int &a, int b){\n  a = ((a+b) % MOD + MOD) % MOD;\n}\n\ninline int mul(int a, int b) {\n    #if !defined(_WIN32) || defined(_WIN64)\n      return (int) ((long long) a * b % MOD);\n    #endif\n      unsigned long long x = (long long) a * b;\n      unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n      asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n      );\n      return m;\n}\n\ninline int modpow(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n      }\n      a = mul(a, a);\n      b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n    a %= MOD;\n    if (a < 0) a += MOD;\n    int b = MOD, u = 0, v = 1;\n    while (a) {\n      int t = b / a;\n      b -= t * a; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    assert(b == 1);\n    if (u < 0) u += MOD;\n    return u;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n  //問題文を読む時間をケチらない！！\n\n  string s;\n  cin >> s;\n\n  int n = s.size();\n\n  int r = 0, b = 0;\n  vector<int> dp[n+1];\n  //赤の数\n  REP(i,n+1) dp[i].assign(n+1,0);\n  dp[0][0] = 1;\n  REP(i,n){\n    if(s[i] == '0') r += 2;\n    else if(s[i] == '1') r++,b++;\n    else b += 2;\n    REP(j,n+1){\n      if(b >= (i+1)-j) add(dp[i+1][j],dp[i][j]);\n      if(r >= j+1) add(dp[i+1][j+1],dp[i][j]);\n    }\n  }\n\n  vector<int> fact(n+1,1);\n  REP(i,n) fact[i+1] = mul(fact[i],i+1);\n\n  int ans = 0;\n  REP(i,n+1){\n    if(r-i < 0 || b-(n-i) < 0) continue;\n    add(ans,mul(dp[n][i],mul(fact[n],inv(mul(fact[r-i],fact[b-(n-i)])))));\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Pct puts(\"------ Yes ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\n#define fir first\n#define sec second\n#define ls son[u][0]\n#define rs son[u][1]\n#define eps 1e-8\n#define PI acos(-1.0)\nusing namespace std;\ntemplate <class T> void rd(T &x){ x = 0; int f = 1; char ch = getchar(); while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); } while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar(); x *= f; }\n\ntypedef long long ll;\nconst int N = 4e3 + 5;\nconst int mod = 998244353;\nint n, _r, _b;\nll f[N][N], fac[N], fin[N];\nchar s[N];\n\nvoid add(ll &a, ll b){ a = (a + b) % mod; }\n\nll Inv(ll x){ return x <= 1 ? 1 : Inv(mod % x) * (mod - mod / x) % mod; }\n\nll C(ll n, ll m){ return fac[n] * fin[m] % mod * fin[n - m] % mod; }\n\nint main(){\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\n\tfac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;\n\tfin[n] = Inv(fac[n]);\n\tper(i, n, 1) fin[i - 1] = fin[i] * i % mod;\n\t\n\tf[0][0] = 1;\n\trep(i, 1, n){\n\t\tif(s[i] == '0') _r += 2;\n\t\telse if(s[i] == '2') _b += 2;\n\t\telse _r ++, _b ++;\n\t\trep(j, 0, 2 * (i - 1)){\n\t\t\tint r = j, b = 2 * (i - 1) - j;\n\t\t\tif(s[i] == '0'){\n\t\t\t\tadd(f[i][r + 1], f[i - 1][r]);\n\t\t\t\tif(b) add(f[i][r + 2], f[i - 1][r]);\n\t\t\t}\n\t\t\telse if(s[i] == '1'){\n\t\t\t\tadd(f[i][r], f[i - 1][r]);\n\t\t\t\tadd(f[i][r + 1], f[i - 1][r]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(r) add(f[i][r - 1], f[i - 1][r]);\n\t\t\t\tadd(f[i][r], f[i - 1][r]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll ans = 0;\n\trep(i, 0, min(_r, n)) add(ans, C(n, _r - i) * f[n][i] % mod);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int N = 2020;\n\nint main() {\n  vector<int> fac(N), finv(N);\n  fac[0] = finv[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fac[i] = mul(fac[i - 1], i);\n    finv[i] = inv(fac[i]);\n  }\n\n  auto comb = [&](int n, int m) {\n    if (m < 0) return 0;\n    int res = fac[n];\n    res = mul(res, finv[m]);\n    res = mul(res, finv[n - m]);\n    return res;\n  };\n\n  string s;\n  cin >> s;\n  int n = s.length();\n\n  vector< vector<int> > dp(n + 1, vector<int>(n + 1));\n  dp[0][0] = 1;\n  int red = 0, blue = 0;\n  for (int i = 1; i <= n; i++) {\n    if (s[i - 1] == '0') red += 2;\n    if (s[i - 1] == '1') red++, blue++;\n    if (s[i - 1] == '2') blue += 2;\n    for (int j = 0; j <= i; j++) {\n      if (j <= red && i - j <= blue) {\n        if (j > 0) add(dp[j][i - j], dp[j - 1][i - j]);\n        if (i - j > 0) add(dp[j][i - j], dp[j][i - j - 1]);\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i <= n; i++) {\n    add(res, mul(dp[i][n - i], comb(n, red - i)));\n  }\n  cout << res << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef gp_hash_table<long long, long long> umap;\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (long long i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (long long i = (n) - 1; i >= 0; i--)\n#define foreach(it,ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar,val) memset(ar, val, sizeof(ar))\n#define fill0(ar) fill((ar), 0)\n#define fillinf(ar, n) fr(i,0,(n)) ar[i] = INF\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define arr1d(a,n) cout << #a << \" : \"; fr(_,1,n) cout << a[_] << ' '; cout << endl;\n#define arr1d0(a,n) cout << #a << \" : \"; rep(_,n) cout << a[_] << ' '; cout << endl;\n#define arr2d(a,n,m) cout << #a << \" :\" << endl; fr(_,1,n) {fr(__,1,m) cout << a[_][__] << ' '; cout << endl;}\n#define arr2d0(a,n,m) cout << #a << \" :\" << endl; rep(_,n) {rep(__,m) cout << a[_][__] << ' '; cout << endl;}\n/*Author Ritick Goenka || ritick(codechef) ||ritick(codeforces) */\n/*IIT Roorkee = <3 */\n#define ull unsigned long long\n#define ll long long\n#define ld double\n#define ui unsigned int\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define y0 yyyyyy0\n#define y1 yyyyyy1\n#define sot(bello) bello.begin(),bello.end()\n#define BIT(n) (1<<(n))\n#define SQR(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n#define LSOne(S) (S) & (-S)\ninline bool EQ(double a, double b) {return fabs(a - b) < 1e-9;}\n \ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n \n \ntemplate<typename T>inline T gcd(T a, T b){if (b == 0)return a;else return gcd(b, a % b);}\ntemplate<typename T>inline T lcm(T a, T b){return (a * b) / gcd(a, b);}\ntemplate<typename T> string toStr(T x) {stringstream st; st << x; string s; st >> s; return s;}\ntemplate<class T>\nvoid splitStr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n \ninline int two(int n) {return 1 << n;}\ninline int isOnBit(int n, int b) {return (n >> b) & 1;}\ninline void onBit(int & n, int b) {n |= two(b);}\ninline void offBit(int & n, int b) {n &= ~two(b);}\ninline int lastBit(int n) {return n & (-n);}\ninline int cntBit(int n) {int res = 0; while(n && ++res) n -= n &(-n); return res;}\n \nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy8[] = {0, 1, 0, -1, -1, 1, -1, 1};\n \n#define INP \"test.inp\"\n#define OUT \"test.out\"\n \n#define PI 3.1415926535897932385\n#define INF 1000000000000000\n#define EPS 1e-7\n#define MAXN 100000\n#define MOD 998244353\n#define dec decr\n//END OF COMPETITVE PROGRAMMING TEMPLATE\nll gcd(ll a, ll b) \n{ \n    if (a == 0) \n        return b; \n    return gcd(b % a, a); \n} \nll modexp(ll x, ll y, ll p)\n{\n    ll res = 1;   \n    x = x % p;  \n    while (y > 0)\n    {\n        if (y & 1)    \n            res = (res*x) % p;\n        y = y>>1;     \n        x = (x*x) % p; \n    }\n    return res;\n}\nll dp[6005][6005];\nll r[6005];\nll r1[6005];\nll b1[6005];\nll b[6005];\nll n1;\nll fn(ll br,ll bb)\n{\n    // debug(br);\n    // debug(bb);\n    if(br<0||bb<0)\n        return 0;\n    ll n=br+bb;\n    if((br<r[n]||bb<b[n]))\n        return 0;\n    // if(br>r1[n]||bb>b1[n])\n    //     return 0;\n    if(dp[br][bb]!=-1)\n        return dp[br][bb];\n    return dp[br][bb]=(fn(br-1,bb)+fn(br,bb-1))%MOD;\n \n}\n \nint main () \n{\n    ios_base::sync_with_stdio(false);\n            cin.tie(NULL);\n        cout<<setprecision(11);\n            string s;\n            cin>>s;\n            ll x=0;\n            ll rc=0,bc=0;\n            rep(i,3005)\n            {\n                rep(j,3005)\n                    dp[i][j]=-1;\n            }\n            ll n=s.length();\n            // debug(n);\n            n1=n;\n            dp[0][0]=1;\n            rep(i,n)\n            {\n                // debug(i);\n                if(s[i]=='0')\n                {\n                    rc++;\n                    r1[i+1]=r1[i]+2;\n                    b1[i+1]=b1[i];\n\n                }\n                else if(s[i]=='2')\n                {\n                    bc++;\n                    b1[i+1]=b1[i]+2;\n                    r1[i+1]=r1[i];\n\n                }\n                else\n                {\n                    r1[i+1]=r1[i]+1;\n                    b1[i+1]=b1[i]+1;\n                }\n                r[i+1]=max(r[i],rc-bc);\n                b[i+1]=max(b[i],bc-rc);\n                // debug(b1[i+1]);\n                //     debug(r1[i+1]);\n            }\n            rep(i,n)\n            {\n                // debug(r1[i+1]);\n                // debug(b1[i+1]);\n                r1[n+i+1]=r1[n+i];\n                b1[n+i+1]=b1[n+i];\n\n                r[n+i+1]=r[n+i];\n                b[n+i+1]=b[n+i];\n            }\n            // debug(n-bc+rc);\n            // debug(n);\n            cout<<fn(n-bc+rc,n-rc+bc);\n            return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define gc() getchar()\n#define mod 998244353\n#define Add(x,v) (x+=v)>=mod&&(x-=mod)\ntypedef long long LL;\nconst int N=4005;\n\nint f[N][N],sum1[N],sum2[N];\nchar s[N];\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tif(s[i]=='0') sum1[i]=2;\n\t\telse if(s[i]=='1') sum1[i]=sum2[i]=1;\n\t\telse sum2[i]=2;\n\t\tsum1[i]+=sum1[i-1], sum2[i]+=sum2[i-1];\n\t}\n\tf[0][0]=1;\n\tfor(int i=1,lim=n<<1; i<=lim; ++i)\n\t{\n\t\tint n1=sum1[std::min(i,n)],n2=sum2[std::min(i,n)];\n\t\tfor(int j=0; j<=i; ++j)\n\t\t\tif(n1>=j && n2>=i-j)\n\t\t\t{\n\t\t\t\tf[i][j]=f[i-1][j];//Add\n\t\t\t\tif(j) Add(f[i][j],f[i-1][j-1]);\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n<<1][sum1[n]]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint r[4003], b[4003];\nll dp[2][4003][4003];\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n    for(int i = 0; i < n; i++){\n        if(s[i] == '0') r[i] += 2;\n        if(s[i] == '1'){\n            r[i]++;\n            b[i]++;\n        }\n        if(s[i] == '2') b[i] += 2;\n        r[i + 1] += r[i];\n        b[i + 1] += b[i];\n    }\n    for(int i = n; i < n * 2; i++){\n        r[i + 1] = r[i];\n        b[i + 1] = b[i];\n    }\n    dp[0][0][0] = 1;\n    for(int i = 1; i <= n * 2; i++){\n        for(int j = 1; j <= min(i, r[i - 1]); j++)\n            dp[i % 2][j][i - j] = (dp[i % 2][j][i - j] + dp[(i + 1) % 2][j - 1][i - j]) % MOD;\n        for(int j = 1; j <= min(i, b[i - 1]); j++)\n            dp[i % 2][i - j][j] = (dp[i % 2][i - j][j] + dp[(i + 1) % 2][i - j][j - 1]) % MOD;\n    }\n    cout << dp[n % 2][r[n * 2]][b[n * 2]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <array>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\n#define FOR(i, a, b) for(decltype(b) i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\n\nusing namespace std;\n\n#ifdef INPUT\n#include <sstream>\nstringstream input(R\"(\n12001021211100201020\n)\");\n#define cin input\n#endif\n\nint p[4096][4096];\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\n\tint n = s.size() * 2;\n\n\tp[0][0] = 1;\n\n\tint nr = 0, nb = 0;\n\tREP (i, n)\n\t{\n\t\tif (i < n / 2)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '0':\n\t\t\t\tnr += 2;\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\t++nr;\n\t\t\t\t++nb;\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tnb += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tREP (j, i + 2)\n\t\t{\n\t\t\tint k = i + 1 - j;\n\t\t\tif (k > nb || j > nr)\n\t\t\t\tcontinue;\n\t\t\tif (j > 0)\n\t\t\t\tp[j][k] += p[j - 1][k];\n\t\t\tif (k > 0)\n\t\t\t\tp[j][k] += p[j][k - 1];\n\t\t\tp[j][k] %= 998244353;\n\t\t}\n\n\t}\n\n\n\tcout << p[nr][nb] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 998244353;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  string s; cin >> s;\n  int n = SZ(s);\n  vector<int> r(n);\n  REP(i, n) {\n    if(s[i] == '0') r[i] = 2;\n    else if(s[i] == '1') r[i] = 1;\n  }\n\n  vector<int> su(2*n+1);\n  REP(i, n) {\n    su[i+1] = su[i] + r[i];\n  }\n  FOR(i, n, 2*n + 1) {\n    su[i+1] = su[i];\n  }\n\n  vvll dp(2*n+1, vll(2*n+1, 0));\n  dp[0][0] = 1;\n  REP(i, 2*n) {\n    REP(j, 2*n+1) {\n      if(dp[i][j] == 0) continue;\n      int nowr = su[i+1] - j;\n      int nowb = 2 * min(i+1, n) - su[i+1] - (i - j);\n      //cout << i << \":\" << j << \" \" << nowr << \":\" << nowb << endl;\n      if(nowr > 0) {\n        (dp[i+1][j+1] += dp[i][j]) %= MOD;\n      }\n      if(nowb > 0) {\n        (dp[i+1][j] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n\n\n  ll ans = 0;\n  REP(j, 2*n+1) {\n    (ans += dp[2*n][j]) %= MOD;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;}\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;}\n    return false;\n}\n\nconst int MAX = 510000;\nvector<ll> fac(MAX),finv(MAX),inv(MAX);\n\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    rep2(i,2,MAX){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\nll COM(int n,int k){\n    if (n<k) return 0;\n    if (n<0||k<0) return 0;\n    return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S; cin >> S;\n    int N=S.size();\n    vector<int> sum(N+1);\n    sum[0]=0;\n    rep(i,N){\n        sum[i+1]=sum[i];\n        if (S[i]=='0') sum[i+1]+=2;\n        if (S[i]=='1') ++sum[i+1];\n    }\n    vector<vector<ll>> dp(N+1,vector<ll>(N+1,0));\n    dp[0][0]=1;\n    rep(i,N){\n        rep(j,N+1){\n            if (sum[i+1]>=j+1) dp[i+1][j+1]+=dp[i][j];\n            if (2*(i+1)-sum[i+1]>=i-j+1) dp[i+1][j]+=dp[i][j];\n        }\n    }\n    ll ans=0,s=sum[N];\n    COMinit();\n    rep(i,N+1) ans=(ans+dp[N][i]*COM(N,s-i)%MOD)%MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 998244353\ninline void add(int &x, int v) { x += v; if (x>=MOD)x-=MOD; }\n\nint N;\nstring S;\nint dp[4003][4003];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> S;\n  N = S.length();\n  dp[0][0] = 1;\n\n  int pre = 0;\n  rep(i, 2*N) {\n    if (i < N) pre += (int)(S[i]-'0');\n    rep(j, 2*N+1) {\n      rep(k, 2) {\n        int state = j+k;\n        if (state > 2*N) continue;\n        if (i < N && !(pre-(i+1) <= state && state <= pre)) continue;\n        add(dp[i+1][state], dp[i][j]);\n      }\n    }\n  }\n  cout << dp[2*N][pre] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define POWER9 1000000000\n#define MOD POWER9+7\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n/*\nint N,M;\nint a[300][300];\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(9);\n\n\tcin >> N >> M;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<M; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\treturn 0;\n}*/\n\n#define MOD 998244353\nstring S;\nint wa[2][2001];\nint ready[4000][4000];\n\nLL dp[4000][4000];\nLL solve(int now, int red){\n\tif(now == S.size()*2) return 1;\n\tif(dp[now][red] != -1) return dp[now][red];\n\tint tmp = ready[red][now-red];\n\tint choiceR = wa[0][tmp] - red;\n\tint choiceB = wa[1][tmp] - (now-red);\n\tLL re = 0;\n\tif(choiceR > 0) re += (LL)solve(now+1, red+1);\n\tif(choiceB > 0) re += (LL)solve(now+1, red);\n\t//cout << now << \" \" << red << \" \" << re << endl;\n\treturn dp[now][red] = re % MOD;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(9);\n\n\tcin >> S;\n\tfor(int i=0; i<S.size(); i++){\n\t\tif(S[i] == '0'){\n\t\t\twa[0][i] = 2 + (i!=0?wa[0][i-1]:0);\n\t\t\twa[1][i] = (i!=0?wa[1][i-1]:0);\n\t\t}\n\t\tif(S[i] == '1'){\n\t\t\twa[0][i] = 1 + (i!=0?wa[0][i-1]:0);\n\t\t\twa[1][i] = 1 + (i!=0?wa[1][i-1]:0);\n\t\t}\n\t\tif(S[i] == '2'){\n\t\t\twa[0][i] = (i!=0?wa[0][i-1]:0);\n\t\t\twa[1][i] = 2 + (i!=0?wa[1][i-1]:0);\n\t\t}\n\t\t//cout << wa[0][i] << \" \" << wa[1][i] << endl;\n\t}\n\twa[0][S.size()] = wa[0][S.size()-1];\n\twa[1][S.size()] = wa[1][S.size()-1];\n\tready[0][0] = 0;\n\tfor(int i=0; i<S.size()*2; i++){\n\t\tfor(int j=0; j<S.size()*2; j++){\n\t\t\tif(i == 0 && j == 0) continue;\n\t\t\tready[i][j] = 0;\n\t\t\tif(i != 0){\n\t\t\t\tint tmp = ready[i-1][j];\n\t\t\t\tif(tmp == S.size()) ready[i][j] = max(ready[i][j], ready[i-1][j]);\n\t\t\t\telse if(S[tmp] != '2') ready[i][j] = max(ready[i][j], ready[i-1][j]+1);\n\t\t\t\telse ready[i][j] = max(ready[i][j], ready[i-1][j]);\n\t\t\t}\n\t\t\tif(j != 0){\n\t\t\t\tint tmp = ready[i][j-1];\n\t\t\t\tif(tmp == S.size()) ready[i][j] = max(ready[i][j], ready[i][j-1]);\n\t\t\t\telse if(S[tmp] != '0') ready[i][j] = max(ready[i][j], ready[i][j-1]+1);\n\t\t\t\telse ready[i][j] = max(ready[i][j], ready[i][j-1]);\n\t\t\t}\n\t\t\t//cout << ready[i][j] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\tfor(int i=0; i<S.size()*2; i++){\n\t\tfor(int j=0; j<S.size()*2; j++){\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tcout << solve(0,0)%MOD << endl;\n\n\treturn 0;\n}\n\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << setprecision(9);\n\n\n\nreturn 0;\n}\n*/\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << std::setprecision(9);\n\n\n\nreturn 0;\n}\n*/\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << std::setprecision(9);\n\n\n\nreturn 0;\n}\n*/\n\n/*\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\ncout << std::setprecision(9);\n\n\n\nreturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nconst int maxn=2010;\nint n,s[maxn];\nll dp[maxn][maxn*2],ans,C[maxn][maxn*2];\nchar S[maxn];\nint main() {\n\tscanf(\"%s\",S+1); n=strlen(S+1);\n\tfor (int i=0;i<=n;i++) {\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor (int j=1;j<i;j++)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tfor (int i=1;i<=n;i++) s[i]=s[i-1]+S[i]-'0';\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=0;j<=s[i];j++) {\n\t\tif (2*i-s[i]<i-j) continue;\n\t\tdp[i][j]=dp[i-1][j];\n\t\tif (j) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n\t\tif (i==n) ans=(ans+dp[i][j]*C[n][s[n]-j])%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 998244353 /*1e9 + 7*/ ;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\nint main() {\n    string s;\n    cin >> s;\n    ll n = s.size();\n    \n    vector<vector<ll>> dp(2 * n + 1, vector<ll>(2 * n + 1));\n    ll r = 0;\n    dp[0][0] = 1;\n    for(ll i = 0; i < 2 * n; i++){\n        if(i < n){\n            r += 2 - (s[i] - '0');\n        }\n        for(ll j = 0; j <= min(i, r); j++){\n            if(j < r){\n                dp[i + 1][j + 1] += dp[i][j];\n                dp[i + 1][j + 1] %= MOD;\n            }\n            if(i - j < min(i + 1, n) * 2 - r){\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= MOD;\n            }\n            \n        }\n    }\n    cout << dp[2 * n][r] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(ll x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(ll exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &x) { if((val += x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &x) { if((val += mod - x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &x) { val = static_cast<unsigned long long>(val) * x.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &x) {\n    // assert(__gcd(static_cast<int>(x.val), mod) == 1);\n    unsigned a = x.val, b = mod; int u = 1, v = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      swap(a -= tmp * b, b);\n      swap(u -= tmp * v, v);\n    }\n    return *this *= u;\n  }\n  bool operator==(const ModInt &x) const { return val == x.val; }\n  bool operator!=(const ModInt &x) const { return val != x.val; }\n  bool operator<(const ModInt &x) const { return val < x.val; }\n  bool operator<=(const ModInt &x) const { return val <= x.val; }\n  bool operator>(const ModInt &x) const { return val > x.val; }\n  bool operator>=(const ModInt &x) const { return val >= x.val; }\n  ModInt &operator++() { if (++val == mod) val = 0; return *this; }\n  ModInt operator++(int) { ModInt res = *this; ++*this; return res; }\n  ModInt &operator--() { val = (val == 0 ? mod : val) - 1; return *this; }\n  ModInt operator--(int) { ModInt res = *this; --*this; return res; }\n  ModInt operator+() const { return *this; }\n  ModInt operator-() const { return ModInt(val ? mod - val : 0); }\n  ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n  ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n  ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n  ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n  friend ostream &operator<<(ostream &os, const ModInt &x) { return os << x.val; }\n  friend istream &operator>>(istream &is, ModInt &x) { ll val; is >> val; x = ModInt(val); return is; }\n};\nModInt abs(const ModInt &x) { return x; }\nstruct Combinatorics {\n  int val; // \"val!\" and \"mod\" must be disjoint.\n  vector<ModInt> fact, fact_inv, inv;\n  Combinatorics(int val = 10000000) : val(val), fact(val + 1), fact_inv(val + 1), inv(val + 1) {\n    fact[0] = 1;\n    FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[val] = ModInt(1) / fact[val];\n    for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n    FOR(i, 1, val + 1) inv[i] = fact[i - 1] * fact_inv[i];\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val && k <= val);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\n};\n\nint main() {\n  string s; cin >> s;\n  int n = s.length();\n  Combinatorics com(n);\n  vector<int> red(n + 1, 0);\n  REP(i, n) {\n    if (s[i] == '0') {\n      red[i + 1] += 2;\n    } else if (s[i] == '1') {\n      red[i + 1] += 1;\n    }\n  }\n  FOR(i, 1, n + 1) red[i] += red[i - 1];\n  vector<vector<ModInt> > dp(n + 1, vector<ModInt>(n + 1, 0));\n  dp[0][0] = 1;\n  REP(i, n) REP(j, i + 1) {\n    if (j + 1 <= red[i + 1]) dp[i + 1][j + 1] += dp[i][j];\n    if (i - j + 1 <= (i + 1) * 2 - red[i + 1]) dp[i + 1][j] += dp[i][j];\n  }\n  // REP(i, n + 1) REP(j, n + 1) cout << dp[i][j] << \" \\n\"[j == n];\n  ModInt ans = 0;\n  REP(j, n + 1) ans += dp[n][j] * com.nCk(n, red[n] - j);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nusing ll=long long;\nusing ull=unsigned long long;\nusing uint=unsigned int;\nusing pcc=pair<char,char>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pdd=pair<double,double>;\nusing tuplis=pair<ll,pll>;\ntemplate<class T> using pq=priority_queue<T,vector<T>,greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MOD=1000000007;\nconst ll MODD=0x3b800001;\nconst int INF=0x3fffffff;\nconst double DINF=numeric_limits<double>::infinity();\nconst vector<pii> four={{-1,0},{0,1},{1,0},{0,-1}};\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) _rep2(i,n)\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) _rrep2(i,n)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(range(__VA_ARGS__),double(0))\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define _rrange(i) (i).rbegin(),(i).rend()\n#define _rrange2(i,k) (i).rbegin(),(i).rbegin()+k\n#define _rrange3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rrange(...) _overload3(__VA_ARGS__,_rrange3,_rrange2,_rrange)(__VA_ARGS__)\n#define yes(i) out(i?\"yes\":\"no\")\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n#define Possible(i) out(i?\"Possible\":\"Impossible\")\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\n__attribute__((constructor)) void SETTINGS(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(20);};\ntemplate<class T>\ninline constexpr T gcd (T a,T b) {if(!a||!b)return 0;return a%b?gcd(b,a%b):b;}\ntemplate<class T>\ninline constexpr T lcm (T a,T b) {return a*b/gcd(a,b);}\ntemplate<class T>\ninline constexpr T min(vector<T>& v){return *min_element(range(v));}\ninline char min(string& v){return *min_element(range(v));}\ntemplate<class T>\ninline constexpr T max(vector<T>& v){return *max_element(range(v));}\ninline char max(string& v){return *max_element(range(v));}\ninline ll pow(ll a,ll b){if(b==0)return 1;ll ans=pow(a,b/2);return ans*ans*(b&1?a:1);}\ninline ll modpow(ll a,ll b,ll mod){if(b==0)return 1;ll ans=pow(a,b/2);return ans*ans*(b&1?a:1)%mod;}\ntemplate<typename T>\ninline bool update_min(T& mn,const T& cnt){if(mn>cnt){mn=cnt;return 1;}else return 0;}\ntemplate<typename T>\ninline bool update_max(T& mx,const T& cnt){if(mx<cnt){mx=cnt;return 1;}else return 0;}\ninline void in() {}\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator >> (istream& is, array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<class T>\nostream& operator << (ostream& os, deque<T>& deq){os << deq[0];rep(i,1,deq.size()){os << ' ' << deq[i];}return os;}\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate<class T,class L>\npair<T,L> operator + (pair<T,L> a, pair<T,L> b){return {a.first + b.first, a.second + b.second};}\ntemplate<class T,class L>\npair<T,L> operator +=(pair<T,L> a, pair<T,L> b){a.first += b.first; a.second += b.second; return a;}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <class T>\ninline bool out(T t){cout<<t<<'\\n';return 0;}\ninline bool out(){cout<<'\\n';return 0;}\ntemplate <class Head, class... Tail>\ninline bool out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);return 0;}\ntemplate <class T>\ninline void err(T t){cerr<<t<<'\\n';}\ninline void err(){cerr<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void err(Head head,Tail... tail){cerr<<head<<' ';out(move(tail)...);}\n\n\nll n;\nvector<pll>sum;\nsigned main(){\n    STR(s);\n    n=s.size();\n    sum.resize(n*2);\n    rep(n){\n        if(i>0){\n            sum[i].first+=sum[i-1].first;\n            sum[i].second+=sum[i-1].second;\n        }\n        sum[i].first+=s[i]-'0';\n        sum[i].second+='2'-s[i];\n    }\n    rep(i,n,n*2)sum[i]=sum[i-1];\n    vec(ll,dp,2*n+1);\n    dp[0]=1;\n    rep(2*n){\n        vec(ll,dp2,2*n+1);\n        rep(j,2*n){\n            if(sum[i].first>=j&&sum[i].second>=i+1-j)dp2[j]=(dp2[j]+dp[j])%MODD;\n            if(sum[i].first>=j+1&&sum[i].second>=i-j)dp2[j+1]=(dp2[j+1]+dp[j])%MODD;\n        }\n        dp.swap(dp2);\n    }\n    out(sum(dp));\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define se second\n#define Mod 998244353 \n\nint main(){\n    ll i,j;\n    string s;\n    cin>>s;\n    ll n=s.size();\n\n    ll b=0;\n    ll r=0;\n    vector< vector<ll> > v(4040,vector<ll>(4040,0));\n\n    for(i=0;i<n;i++){\n        if(s[i]=='0'){\n            for(j=0;j<r;j++) v[j][b]=1;\n        }\n        if(s[i]=='2'){\n            for(j=0;j<b;j++) v[r][j]=2;\n        }\n        if(s[i]=='0') r+=2;\n        if(s[i]=='2') b+=2;\n        if(s[i]=='1') {\n            r++;\n            b++;\n        }\n    }\n\n    vector< vector<ll> > ans(4040,vector<ll>(4040,0));\n\n    ans[0][0]=1;\n\n    for(i=0;i<=r;i++){\n        for(j=0;j<=b;j++){\n            if(i!=0||j!=0){\n            ans[i][j]=0;\n            if(i-1>=0){\n                if(v[i-1][j]!=2){\n                ans[i][j]+=ans[i-1][j];\n                }\n            }\n            if(j-1>=0){\n                if(v[i][j-1]!=1){\n                ans[i][j]+=ans[i][j-1];\n                }\n            }\n            ans[i][j]%=Mod;\n            }\n        }\n    }\n\n    cout<<ans[r][b]<<endl;\n\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=998244353;\nint n;\nchar s[2005];\nint sum[2005],d[2005][4005];\n\nint mod(int x){return x>=cys?x-cys:x;}\n\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tfor(int i=1;i<=n;i++) sum[i]=sum[i-1]+s[i]-'0';\n\td[0][0]=1;\n\tfor(int i=1;i<=2*n;i++){\n\t\tfor(int j=sum[min(n,i)];j>=0;j--){\n\t\t\tif(i-j<=2*min(n,i)-sum[min(n,i)]) d[i][j]=d[i-1][j];\n\t\t\tif(j>=1) d[i][j]=mod(d[i][j]+d[i-1][j-1]);\n\t\t}\n\t}\n\tcout<<d[2*n][sum[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> ivec;\n\nconst int MOD=998244353;\nint INF=100100100100100;\n\nint b[2010];\nint dp[2010][4020];\nint cb[3010];\n\nint add(int a,int b){\n  return (a+b)%MOD;\n}\nint prod(int a,int b){\n  return (a*b)%MOD;\n}\n\nint beki(int a,int b)\n{\n\tif(b==0)return 1;\n\tint x=beki(a,b/2);\n\tif(b%2==0)return (x*x)%MOD;\n\telse return (((a*x)%MOD)*x)%MOD;\n}\n\nint inv(int a)\n{\n\treturn beki(a,MOD-2);\n}\n\nvoid combi(int a,int b)\n{\n\tint ret=1;\n    cb[0]=1;\n\tfor(int i=1;i<=b;i++)\n\t{\n\t\tret=(((ret*(a+1-i))%MOD)*inv(i))%MOD;\n      cb[i]=ret;\n\t}\n\t//return ret;\n}\n\n\n\nsigned main(){\n  string s;cin>>s;\n  int n=s.length();\n  rep(i,n){\n    int ppp=s[i]-'0';\n    if(i==0)b[0]=ppp;\n    else b[i]=b[i-1]+ppp;\n  }\n  dp[0][0]=1;\n  rep(i,n){\n    rep(j,2*n){\n      if(b[i]>j)(dp[i+1][j+1]+=dp[i][j])%=MOD;\n      if(j+i+2>b[i])(dp[i+1][j]+=dp[i][j])%=MOD;\n    }\n  }\n  int ans=0;\n  combi(n+1,n+1);\n  rep(i,b[n-1]+1){\n    (ans+=prod(dp[n-1][i],cb[b[n-1]-i]))%=MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <numeric>\n#include <cassert>\n#include <array>\n#include <memory>\n#include <random>\n#ifdef DEBUG\n#include \"./Lib/debug.hpp\"\n#include \"./Lib/Timer.hpp\"\n#include \"./Lib/sample.hpp\"\n#else\n#define dump(...)\n#endif\n\n/* (=＾o＾=) */\n#define int ll\n\n/* macro */\n#define FOR(i, b, e) for(ll i = (ll)(b); i < (ll)(e); ++i)\n#define RFOR(i, b, e) for(ll i = (ll)(e-1); i >= (ll)(b); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define REPC(x,c) for(const auto& x:(c))\n#define REPI2(it,b,e) for(auto it = (b); it != (e); ++it)\n#define REPI(it,c) REPI2(it, (c).begin(), (c).end())\n#define RREPI(it,c) REPI2(it, (c).rbegin(), (c).rend())\n#define REPI_ERACE2(it, b, e) for(auto it = (b); it != (e);)\n#define REPI_ERACE(it, c) REPI_ERACE2(it, (c).begin(), (c).end())\n#define ALL(x) (x).begin(),(x).end()\n#define cauto const auto&\n/* macro func */\ntemplate<class T>\ninline auto sort(T& t) { std::sort(ALL(t)); }\ntemplate<class T>\ninline auto rsort(T& t) { std::sort((t).rbegin(), (t).rend()); }\ntemplate<class T>\ninline auto unique(T& t) { (t).erase(unique((t).begin(), (t).end()), (t).end()); }\ntemplate<class T, class S>\ninline auto chmax(T& t, const S& s) { if (s > t) { t = s; return true; } return false; }\ntemplate<class T, class S>\ninline auto chmaxE(T& t, const S& s) { if (s >= t) { t = s; return true; } return false; }\ntemplate<class T, class S>\ninline auto chmin(T& t, const S& s) { if (s < t) { t = s; return true; } return false; }\ninline auto BR() { std::cout << \"\\n\"; }\n\n/* type define */\nusing ll = long long;\nusing PAIR = std::pair<ll, ll>;\nusing VS = std::vector<std::string>;\nusing VL = std::vector<long long>;\nusing VVL = std::vector<VL>;\nusing VVVL = std::vector<VVL>;\nusing VD = std::vector<double>;\ntemplate<class T>\nusing V = std::vector<T>;\n\n/* using std */\nusing std::cout;\nconstexpr char endl = '\\n';\nusing std::cin;\nusing std::pair;\nusing std::string;\nusing std::stack;\nusing std::queue;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::unordered_map;\nusing std::multimap;\nusing std::unordered_multimap;\nusing std::set;\nusing std::unordered_set;\nusing std::unordered_multiset;\nusing std::multiset;\nusing std::bitset;\nusing std::priority_queue;\nusing std::tuple;\n\n/* constant value */\n//constexpr ll MOD = 1000000007;\nconstexpr ll MOD = 998244353;\n\n/* Initial processing  */\nstruct Preprocessing { Preprocessing() { std::cin.tie(0); std::ios::sync_with_stdio(0); }; }_Preprocessing;\n\n/* Remove the source of the bug */\ninline signed pow(signed, signed) { assert(false); return -1; }\n\n/* define hash */\nnamespace std {\ntemplate <>\tclass hash<std::pair<ll, ll>> { public:\tsize_t operator()(const std::pair<ll, ll>& x) const { return hash<ll>()(1000000000 * x.first + x.second); } };\n}\n\n/* input */\ntemplate<class T> std::istream& operator >> (std::istream& is, vector<T>& vec) { for (T& x : vec) is >> x; return is; }\n\n//=============================================================================================\n\n\n\nsigned main() {\n\tstring s;\n\tcin >> s;\n\tll n = s.size();\n\n\tVL sum1; sum1.reserve(2 * n);\n\t{\n\t\tVL v(2 * n);\n\t\tREP(i, n) {\n\t\t\tv[i] = s[i] - '0';\n\t\t}\n\t\tREP(i, 2 * n - 1)if (v[i] > 1) {\n\t\t\tv[i + 1] += v[i] - 1;\n\t\t\tv[i] = 1;\n\t\t}\n\t\tsum1.emplace_back(v[0]);\n\t\tFOR(i, 1, 2 * n) { sum1.emplace_back(sum1.back() + v[i]); }\n\t}\n\n\tVL sum0; sum0.reserve(2 * n);\n\t{\n\t\tVL v(2 * n);\n\t\tREP(i, n) {\n\t\t\tv[i] = 2 - (s[i] - '0');\n\t\t}\n\t\tREP(i, 2 * n - 1)if (v[i] > 1) {\n\t\t\tv[i + 1] += v[i] - 1;\n\t\t\tv[i] = 1;\n\t\t}\n\t\tsum0.emplace_back(v[0]);\n\t\tFOR(i, 1, 2 * n) { sum0.emplace_back(sum0.back() + v[i]); }\n\t}\n\n\n\tVVL dp(2 * n, VL(2 * n));\n\tdp[0][1] = (sum1[0] == 1);\n\tdp[0][0] = (sum0[0] == 1);\n\tFOR(i, 1, 2 * n) FOR(j, 0, 2 * n) {\n\t\tif (j > sum1[i]) { continue; }\n\t\tif (i - j >= sum0[i]) { continue; }\n\t\tdp[i][j] = dp[i - 1][j] + ((j - 1 >= 0) ? dp[i - 1][j - 1] : 0);\n\t\tdp[i][j] %= MOD;\n\t}\n\tll ans = 0;\n\tREPC(x, dp[2 * n - 1]) { chmax(ans, x); }\n\tcout << ans << endl;\n\tdump(dp, sum1, sum0);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 2/9/2019, 10:35:35 PM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 998244353;\nconst int MAX_SIZE = 1000010;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = ((MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    factinv[i] = (inv[i] * factinv[i - 1]) % MOD;\n  }\n}\n\nlong long C(int n, int k)\n{\n  if (n >= 0 && k >= 0 && n - k >= 0)\n  {\n    return ((fact[n] * factinv[k]) % MOD * factinv[n - k]) % MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n  else if (n % 2 == 1)\n  {\n    return (x * power(x, n - 1)) % MOD;\n  }\n  else\n  {\n    long long half = power(x, n / 2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcd(long long x, long long y)\n{\n  return y ? gcd(y, x % y) : x;\n}\n\nstring S;\nint N;\nll DP[2010][4010];\nint R[2010];\nint B[2010];\n\nint main()\n{\n  init();\n  cin >> S;\n  N = S.size();\n  for (auto i = 0; i < 4010; i++)\n  {\n    DP[0][i] = 0;\n  }\n  DP[0][0] = 1;\n  R[0] = B[0] = 0;\n  for (auto i = 1; i <= N; i++)\n  {\n    if (S[i - 1] == '0')\n    {\n      R[i] = R[i - 1] + 2;\n      B[i] = B[i - 1];\n    }\n    else if (S[i - 1] == '1')\n    {\n      R[i] = R[i - 1] + 1;\n      B[i] = B[i - 1] + 1;\n    }\n    else\n    {\n      R[i] = R[i - 1];\n      B[i] = B[i - 1] + 2;\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    // cerr << \"R[\" << i + 1 << \"] = \" << R[i + 1] << \", B[\" << i + 1 << \"] = \" << B[i + 1] << endl;\n    for (auto j = 0; j <= i; j++)\n    {\n      if (DP[i][j] == 0)\n      {\n        continue;\n      }\n      // cerr << \"DP[\" << i << \"][\" << j << \"] = \" << DP[i][j] << endl;\n      int r = j;\n      int b = i - r;\n      if (R[i + 1] - r > 0)\n      {\n        DP[i + 1][j + 1] += DP[i][j];\n        DP[i + 1][j + 1] %= MOD;\n      }\n      if (B[i + 1] - b > 0)\n      {\n        DP[i + 1][j] += DP[i][j];\n        DP[i + 1][j] %= MOD;\n      }\n    }\n  }\n  ll ans = 0;\n  for (auto i = 0; i <= N; i++)\n  {\n    if (DP[N][i] == 0)\n    {\n      continue;\n    }\n    int r = i;\n    int b = N - i;\n    int res_r = R[N] - r;\n    int res_b = B[N] - b;\n    ans += (DP[N][i] * C(res_r + res_b, res_r)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4000;\ntypedef long long ll;\nconst int mod=998244353;\nint f[maxn+5][maxn+5];\nint R[maxn+5],B[maxn+5];\nchar s[maxn+5];\nint n;\nvoid upd(int &x,int y)\n{\n    x=(x+y)%mod;\n}\nint main()\n{\n\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;++i)\n        if(s[i]=='0') R[i]=2;\n        else if(s[i]=='1') R[i]=B[i]=1;\n        else if(s[i]=='2') B[i]=2;\n    for(int i=1;i<=2*n;++i) R[i]+=R[i-1],B[i]+=B[i-1];\n    f[0][0]=1;\n    for(int i=0;i<2*n;++i)\n        for(int j=0;j<=2*n;++j)\n        {\n            if(f[i][j]==0) continue;\n            int rr=0,bb=0;\n            if(s[i+1]=='0') rr=2;\n            if(s[i+1]=='1') rr=bb=1;\n            if(s[i+1]=='2') bb=2;\n            //rr+=j;\n            //if(i<=n) bb+=2*i-j;else bb+=2*n-j;\n            int k=R[i]+B[i]-j-i;\n            if(j+rr-1>=0&&j+rr-1<=2*n)\n                upd(f[i+1][j+rr-1],f[i][j]);\n            if(k+bb-1>=0&&k+bb-1<=2*n)\n                upd(f[i+1][j+rr],f[i][j]);\n        }\n    /*for(int i=1;i<=2*n;++i)\n        for(int j=0;j<=min(2*i,2*n);++j)\n    {\n        int rr=j;\n        int bb=min(2*i,2*n)-rr;\n        printf(\"%d %d %d : %d\\n\",i,rr,bb,f[i][j]);\n    }*/\n    cout<<f[2*n][0];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll     = long long;\nusing pii    = pair<int, int>;\nusing pll    = pair<ll, ll>;\nusing vi     = vector<int>;\nusing vl     = vector<ll>;\nusing vvi    = vector<vi>;\nusing vvl    = vector<vl>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 998244353;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\ntemplate <class C>\nvoid print(const C &c, std::ostream &os = std::cout) {\n    std::copy(std::begin(c), std::end(c), std::ostream_iterator<typename C::value_type>(os, \" \"));\n    os << std::endl;\n}\n\n// mod int struct\n// original : https://github.com/beet-aizu/library/blob/master/mod/mint.cpp\n\nstruct mint {\n    ll v;\n    ll mod;\n    mint() : v(0) {}\n    mint(signed v, ll mod = MOD) : v(v), mod(mod) {}\n    mint(ll t, ll mod = MOD) : mod(mod) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    mint pow(ll k) {\n        mint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    static mint add_identity() { return mint(0); }\n    static mint mul_identity() { return mint(1); }\n\n    mint inv() { return pow(mod - 2); }\n\n    mint &operator+=(mint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    mint &operator-=(mint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    mint &operator*=(mint a) {\n        v = 1LL * v * a.v % mod;\n        return *this;\n    }\n    mint &operator/=(mint a) { return (*this) *= a.inv(); }\n\n    mint operator+(mint a) const { return mint(v) += a; };\n    mint operator-(mint a) const { return mint(v) -= a; };\n    mint operator*(mint a) const { return mint(v) *= a; };\n    mint operator/(mint a) const { return mint(v) /= a; };\n\n    mint operator-() const { return v ? mint(mod - v) : mint(v); }\n\n    bool operator==(const mint a) const { return v == a.v; }\n    bool operator!=(const mint a) const { return v != a.v; }\n    bool operator<(const mint a) const { return v < a.v; }\n\n    // find x s.t. a^x = b\n    static ll log(ll a, ll b) {\n        const ll sq = 40000;\n        unordered_map<ll, ll> dp;\n        dp.reserve(sq);\n        mint res(1);\n        for (int r = 0; r < sq; r++) {\n            if (!dp.count(res.v))\n                dp[res.v] = r;\n            res *= a;\n        }\n        mint p = mint(a).inv().pow(sq);\n        res    = b;\n        for (int q = 0; q <= MOD / sq + 1; q++) {\n            if (dp.count(res.v)) {\n                ll idx = q * sq + dp[res.v];\n                if (idx > 0)\n                    return idx;\n            }\n            res *= p;\n        }\n        assert(0);\n        return ll(-1);\n    }\n\n    static mint comb(long long n, int k) {\n        mint num(1), dom(1);\n        for (int i = 0; i < k; i++) {\n            num *= mint(n - i);\n            dom *= mint(i + 1);\n        }\n        return num / dom;\n    }\n};\nostream &operator<<(ostream &os, mint m) {\n    os << m.v;\n    return os;\n}\n\nstruct Combination {\n    vector<ll> fac, finv, inv;\n\n    Combination(ll maxN) {\n        maxN += 100; // for safety\n        fac.resize(maxN + 1);\n        finv.resize(maxN + 1);\n        inv.resize(maxN + 1);\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1]            = 1;\n        for (ll i = 2; i <= maxN; ++i) {\n            fac[i]  = fac[i - 1] * i % MOD;\n            inv[i]  = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n    ll operator()(ll n, ll k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n};\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<vector<mint>> dp(n + 1, vector<mint>(n+1, 0));\n    int b    = 0;\n    int r    = 0;\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        b += s[i] - '0';\n        r += 2 - (s[i] - '0');\n        for (int j = 0; j <= n; ++j) {\n            if (j <= b && j > 0)\n                dp[i + 1][j] += dp[i][j - 1];\n            if (i + 1 - j <= r)\n                dp[i + 1][j] += dp[i][j];\n        }\n    }\n    mint ret = 0;\n    Combination nCk(2 * n);\n    for (int i = 0; i <= n; ++i) {\n        int brem = b - i;\n        ret += dp[n][i] * nCk(n, brem);\n    }\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int N=4001;\nchar s[N];\nint t[N];\ntypedef long long ll;\nint fac[N],inv[N],finv[N];\ntemplate<class T>inline void Inc(T&x,int y){x+=y;if(x>=mod) x-=mod;}\ninline int C(int n,int m){if(n<m) return 0;return (ll)fac[n]*finv[m]%mod*finv[n-m]%mod;}\nint n;\nint dp[N][N];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tint red=0,blue=0;fac[0]=finv[0]=1;inv[1]=1;\n\tfor(int i=2;i<=n;++i) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod,finv[i]=(ll)finv[i-1]*inv[i]%mod;\n\tfor(int i=1;i<=n;++i) t[i]=s[i]-'0';\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;++i) {\n\t\tif(t[i]==1) ++red,++blue;else if(t[i]==0) red+=2;else blue+=2;\n\t\tfor(int j=0;j<=red;++j){\n\t\t\tif(j>0) Inc(dp[i][j],dp[i-1][j-1]);\n\t\t\tif(i-j<=blue) Inc(dp[i][j],dp[i-1][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=red;++i) {int f=dp[n][i];Inc(ans,(ll)f*C(n,red-i)%mod);}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define pb(a) push_back\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), n)\n#define ub(v,n) upper_bound(v.begin(), v.end(), n)\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\n#define move(x) ans.push_back(x),c[x]--,now=x;\n \ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\nconst int MOD = 998244353; const int MAX = 200020;\nconst double pi = acos(-1); const double EPS = 1e-12;\nconst ll INF = 2e18;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\n\nint dp[2020][2020];\nint cumR[2020];\nint A[2020],B[2020];\nint sumR,sumB;\nvoid solve() {\n\tstring S;cin>>S;\n\tint N=S.size();\n\tCOMinit();\n\tREP(i,N){\n\t\tint num=S[i]-'0';\n\t\tA[i]+=num;\n\t\tB[i]+=2-num;\n\t\tcumR[i+1]+=cumR[i]+A[i];\n\t\tsumR+=A[i];\n\t\tsumB+=B[i];\n\t}\n\tdp[0][0]=1;\n\tREP(i,N){\n\t\tREP(r,N+1){\n\t\t\tif(r>0&&cumR[i+1]>=r)dp[i+1][r]+=dp[i][r-1];\n\t\t\tint cumB=(i+1)*2-cumR[i+1];\n\t\t\tif(cumB>=i+1-r)dp[i+1][r]+=dp[i][r];\n\t\t\tassert(dp[i+1][r]<0);\n\t\t\t//pe(i+1);pe(r);print(dp[i+1][r]);\n\t\t}\n\t}\n\tll ans=0;\n\n\tREP(r,N+1){\n\t\tll res=mult(dp[N][r],fac[N]);\n\t\tres=mult(res,mult(finv[sumR-r],finv[sumB-(N-r)]));\n\t\tans=add(ans,res);\n\t}\n\tprint(ans);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 998244353 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 4010\n\nll dp[SIZE][SIZE];\n\nint main(){\n  char s[SIZE];\n  int n;\n\n  scanf(\"%s\", s);\n  n = strlen(s);\n\n  int R = 0, B = 0;\n\n  dp[0][0] = 1;\n\n  for(int i=0;i<n*2;i++){\n    if (i < n) {\n      if (s[i] == '0') { R += 2; }\n      if (s[i] == '1') { R += 1; B += 1; }\n      if (s[i] == '2') { B += 2; }\n    }\n\n    for(int j=0;j<=R;j++){\n      int r = j, b = i - j;\n\n      if(r < R) (dp[i+1][r+1] += dp[i][r]) %= mod;\n      if(b < B) (dp[i+1][r] += dp[i][r]) %= mod;\n    }\n  }\n\n  cout << dp[n*2][R] << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n \n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n \ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n \nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n \ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tModInt():x(0) {\n\t\t// do nothing\n\t}\n\tModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n        ModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n        ModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n        ModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n        ModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n        ModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n        ModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n        ModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n        ModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n        ModInt p(y);\n        *this = p;\n        return *this;\n    }\n    ModInt operator=(const long long y) {\n        ModInt p(y);\n\t\t*this = p;\n        return *this;\n    }\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n        x++;\n        if(x>=mod) x-=mod;\n        return *this; \n    }\n\tModInt operator--() { \n        x--;\n        if(x<0) x+=mod;\n        return *this; \n    }\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD2>;\n\nint main() {\n\tstring S; cin >> S;\n\tS = \".\" + S;\n\tint N = S.size();\n\tauto dp = multivector(2*N-1,2*N-1,modint(0));\n\tvector<int> sumR(N,0),sumB(N,0);\n\tfor(int i = 1; i < N; ++i) {\n\t\tif(S[i]=='0') sumR[i]=2;\n\t\tif(S[i]=='1') sumR[i]=1,sumB[i]=1;\n\t\tif(S[i]=='2') sumB[i]=2;\n\t}\n\tfor(int i = 1; i < N; ++i) {\n\t\tsumR[i] += sumR[i-1];\n\t\tsumB[i] += sumB[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i = 1; i < 2*N-1; ++i) {\n\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\tint R = j, B = i - j;\n\t\t\tif(sumR[min(i,N-1)]<R||sumB[min(i,N-1)]<B) continue;\n\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\tif(j) dp[i][j] += dp[i-1][j-1];\n\t\t}\n\t}\n\tcout << accumulate(ALL(dp[2*N-2]),modint(0)) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include <map>\n#include <fstream>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <assert.h>\n#include <complex>\nusing namespace std;\n#define eps 0.000001\n#define LONG_INF 10000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 65536*16\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long dp[5000][5000] = {};\nint main() {\n\tstring s;\n\tcin >> s;\n\tlong long blue = 0;\n\tlong long red = 0;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < 2*s.length(); ++i) {\n\t\tif (i < s.length()) {\n\t\t\tif (s[i] == '0') red += 2;\n\t\t\telse if (s[i] == '1') {\n\t\t\t\tred++;\n\t\t\t\tblue++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tblue += 2;\n\t\t\t}\n\t\t}\n\t\tfor (int blue_got = 0;blue_got <= i; ++blue_got) {\n\t\t\tint red_got = i - blue_got;\n\t\t\tif (blue_got == blue) {\n\t\t\t\tdp[blue_got][red_got + 1] += dp[blue_got][red_got];\n\t\t\t\tdp[blue_got][red_got + 1] %= MOD;\n\t\t\t}\n\t\t\telse if (red_got == red) {\n\t\t\t\tdp[blue_got + 1][red_got] += dp[blue_got][red_got];\n\t\t\t\tdp[blue_got + 1][red_got] %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[blue_got + 1][red_got] += dp[blue_got][red_got];\n\t\t\t\tdp[blue_got + 1][red_got] %= MOD;\n\t\t\t\tdp[blue_got][red_got + 1] += dp[blue_got][red_got];\n\t\t\t\tdp[blue_got][red_got + 1] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[blue][red] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\n\nstring str;\nint n;\n\nll dp[4005][4005];\n\nint main(){\n  cin>>str;\n  n=str.size();\n  dp[0][0]=1;\n\n  ll cnt=0;\n  for(int i=0;i<n*2;i++){\n\n    if(i<n)cnt+=2;\n    \n    for(int j=0;j<=4000;j++){\n      if(dp[i][j]==0)continue;\n      ll R=j;\n\n      if(i<n){\n        if(str[i]=='0'){\n          R+=2;\n        }else if(str[i]=='1'){\n          R++;\n        }\n      }\n      \n      ll B=cnt-R;\n      if(R>0){\n        int nj=j;\n        if(R==j+2)nj++;\n        if(R==j)nj--;\n        if(nj>0){\n          dp[i+1][nj]+=dp[i][j];\n          dp[i+1][nj]%=mod;\n        }\n        \n      }\n      \n      if(B>0){\n        int nj=j;\n        if(R==j+2)nj+=2;\n        if(R==j+1)nj++;\n        dp[i+1][nj]+=dp[i][j];\n        dp[i+1][nj]%=mod;\n      }\n    }\n    \n\n    cnt--;\n  }\n  /*\n  for(int i=0;i<=n*2;i++){\n    for(int j=0;j<=n*2;j++){\n      printf(\"%02d \",(int)dp[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  cout<<dp[2*n][0]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 4010 \nusing namespace std;\nstring st;\nint n,a[N],b[N],dp[N][N],mo=998244353;\nint main(){\n\tcin>>st;n=st.length();\n\tfor (int i=1;i<=n;i++)a[i]=st[i-1]-'0'+a[i-1],b[i]=b[i-1]+'2'-st[i-1];\n\tdp[0][0]=1;\n\tfor (int i=0;i<=a[n];i++)\n\t\tfor (int j=0;j<=b[n];j++)\n\t\t\tif (i<=a[min(n,i+j)]&&j<=b[min(n,i+j)])dp[i][j]=(dp[i][j]+(j?dp[i][j-1]:0)+(i?dp[i-1][j]:0))%mo;\n\tcout<<dp[a[n]][b[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\n\nconst int N = 2e3 + 10;\nchar s[N];\nint dp[N][N];\nint A[N], B[N];\nint n;\n\nint solve(int x, int y, int step) {\n  if (x + y == 2 * n) return 1;\n  step = min(step, n);\n  int& ret = dp[x][y];\n  if (ret >= 0) return ret;\n  ret = 0;\n  // trace(x, y, step, A[step], B[step]);\n  if (A[step] > x) ret = (ret + solve(x + 1, y, step + 1)) % MOD;\n  if (B[step] > y) ret = (ret + solve(x, y + 1, step + 1)) % MOD;\n  // trace(x, y, ret);\n  return ret;\n}\n\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '0') {\n      A[i + 1] = A[i] + 2;\n      B[i + 1] = B[i];\n    } else if (s[i] == '1') {\n      A[i + 1] = A[i] + 1;\n      B[i + 1] = B[i] + 1;\n    } else {\n      A[i + 1] = A[i];\n      B[i + 1] = B[i] + 2;\n    }\n  }\n  memset(dp, 255, sizeof(dp));\n  int ret = solve(0, 0, 1);\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(2001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(2 * N + 1));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - b;\n                }\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    dp[i + 1][j + 1] += dp[i][j];\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    dp[i + 1][j] += dp[i][j];\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i];\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = left * right % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**********************************************************************/\n/********                                                      ********/\n/********                     Writer:孙~~                      ********/\n/********                       Lang:C++                       ********/\n/********                     Status:Unknow                    ********/\n/********                                                      ********/\n/**********************************************************************/\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <list>\n#include <cstdlib>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <deque>\n#include <cstring>\n#include <cmath>\n//#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int SIZE=2005;\nconst double EPS=1e-6;\nconst int MOD=998244353;\n\nlong long dp[SIZE*2][SIZE*2];\nint r[SIZE*2],b[SIZE*2];\n\nint main(){\n\t/*main function start*/\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n//\tcout<<n<<endl;\n\tfor(int i=1;i<=n;i++) if(s[i-1]=='0') r[i]=r[i-1]+2,b[i]=b[i-1]; else if(s[i-1]=='1') r[i]=r[i-1]+1,b[i]=b[i-1]+1; else r[i]=r[i-1],b[i]=b[i-1]+2;\n\tfor(int i=n+1;i<=n*2;i++) r[i]=r[i-1],b[i]=b[i-1];\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n*2;i++){\n//\t\tcout<<\"TEST \"<<i<<\" \"<<b[i]<<\" \"<<max(i-b[i],0)<<\" \"<<min(i,r[i])<<endl;\n\t\tfor(int j=max(i-b[i],0);j<=min(i,r[i]);j++){\n\t\t\tif(j>0) dp[i][j]+=dp[i-1][j-1];\n\t\t\tif(i!=j) dp[i][j]+=dp[i-1][j];\n\t\t\tdp[i][j]%=MOD;\n//\t\t\tcout<<dp[i][j]<<\" \";\n\t\t}\n//\t\tcout<<endl;\n\t}\n\tlong long ans=0;\n\tfor(int i=0;i<=min(n*2,r[n*2]);i++){\n\t\tans+=dp[n*2][i];\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n//\tcout<<c[2][0]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define rep(i,n) for (int i = 0; i < n; i++)\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, ll> p;\ntypedef complex<double> com;\nconst int mod = 1e9 + 7;\nconst int MOD = 998244353;\nconst int inf = 1 << 30;\n\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tvector<vector<int>> dp(2 * n + 1);\n\trep(i, 2 * n + 1) {\n\t\tdp[i].resize(2 * n + 1);\n\t\trep(j, 2 * n + 1) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tint sumr = 0, sumb = 0;\n\trep(i, 2 * n) {\n\t\tif (i < n) {\n\t\t\tsumr += s[i] - '0';\n\t\t\tsumb += '2' - s[i];\n\t\t}\n\t\trep(j, sumr+1) {\n\t\t\tif (i + 1 < j || sumb < i + 1 - j) continue;\n\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\tif (j != 0) dp[i + 1][j] += dp[i][j - 1];\n\t\t\tdp[i + 1][j] %= MOD;\n\t\t}\n\t}\n\tcout << dp[2 * n][sumr] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <type_traits>\nnamespace loquat {\ntemplate <int MOD>\nclass modulus_integer {\npublic:\n\ttypedef modulus_integer<MOD> self_type;\nprivate:\n\tint m_value;\n\tstatic self_type unsafe_construct(int x) noexcept {\n\t\tself_type y;\n\t\ty.m_value = x;\n\t\treturn y;\n\t}\npublic:\n\tmodulus_integer() noexcept\n\t\t: m_value(0)\n\t{ }\n\tmodulus_integer(int x) noexcept\n\t\t: m_value(x % MOD)\n\t{\n\t\tif(m_value < 0){ m_value += MOD; }\n\t}\n\tint operator*() const noexcept { return m_value; }\n\tself_type& operator=(const self_type& x) noexcept {\n\t\tm_value = x.m_value;\n\t\treturn *this;\n\t}\n\tself_type operator+(const self_type& x) const noexcept {\n\t\tconst int y = m_value + x.m_value;\n\t\treturn unsafe_construct(y >= MOD ? y - MOD : y);\n\t}\n\tself_type& operator+=(const self_type& x) noexcept {\n\t\treturn (*this = *this + x);\n\t}\n};\ntemplate <int MOD>\ninline std::ostream& operator<<(\n\tstd::ostream& os, const modulus_integer<MOD>& x)\n{\n\tos << *x;\n\treturn os;\n}\n}\nusing namespace std;\nusing mint = loquat::modulus_integer<998244353>;\nstatic mint dp[4001][4001];\nint main(){\n\tios_base::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; ++i){ a[i] = s[i] - '0'; }\n\tvector<int> r, b;\n\tfor(int i = 0; i < n; ++i){\n\t\tswitch(a[i]){\n\t\tcase 0:\n\t\t\tr.push_back(i);\n\t\t\tr.push_back(i);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tr.push_back(i);\n\t\t\tb.push_back(i);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tb.push_back(i);\n\t\t\tb.push_back(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tconst int m = 2 * n;\n\tfor(int i = 0; i <= m; ++i){\n\t\tfor(int j = 0; j <= m; ++j){ dp[i][j] = 0; }\n\t}\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < m; ++i){\n\t\tfor(int j = 0; j <= i; ++j){\n\t\t\tconst int x = j, y = i - j;\n\t\t\tif(x < r.size() && r[x] <= i){\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t}\n\t\t\tif(y < b.size() && b[y] <= i){\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[m][r.size()] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing vll = std::vector<long long>;\nconstexpr long long mod{998244353};\n\nint main()\n{\n\tstd::string s;\n\tstd::cin >> s;\n\tint blue{}, red{}, n;\n\tn = s.size();\n\tfor (auto& e: s) blue += e - '0';\n\tred = 2 * n - blue;\n\tstd::vector<vll> dp(2 * n + 1, vll(blue + 1));\n\tdp[0][0] = 1;\n\tint available_blue{}, available_red{};\n\tfor (int length{1}; length <= n; length++)\n\t{\n\t\tavailable_blue += s[length - 1] - '0';\n\t\tavailable_red += '2' - s[length - 1];\n\t\tfor (int blue_i{1}; blue_i <= available_blue; blue_i++)\n\t\t\tdp[length][blue_i] = dp[length - 1][blue_i - 1];\n\t\tfor (int blue_i{std::max(0, length - available_red)}; blue_i <= std::min(blue, length); blue_i++)\n\t\t{\n\t\t\tdp[length][blue_i] += dp[length - 1][blue_i];\n\t\t\tdp[length][blue_i] %= mod;\n\t\t}\n\t}\n\tfor (int length{n + 1}; length <= 2 * n; length++)\n\t{\n\t\tfor (int blue_i{}; blue_i <= blue; blue_i++)\n\t\t{\n\t\t\tif (blue_i && blue_i <= blue)\n\t\t\t\tdp[length][blue_i] += dp[length - 1][blue_i - 1];\n\t\t\tif (length - blue_i <= red)\n\t\t\t{\n\t\t\t\tdp[length][blue_i] += dp[length - 1][blue_i];\n\t\t\t\tdp[length][blue_i] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[2 * n][blue]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n\nconst int mod = 998244353;\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< mod >;\nvoid comb(vector<modint> &res){\n  int n = res.size()-1;\n  res[0] = 1;\n  rep1(i,n){\n    res[i] = res[i-1]*((modint) n+1-i)/((modint) i);\n  }\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  vector<vector<modint> > dp(n+1,vector<modint>(4*n+1,0));\n  rep(i,n){\n    rep(j,4*n){\n      int red = (j - n*2 + i);\n      int blue = (-(j-2*n)+i);\n      if(red>=0 && blue>=0){        \n        red/=2;blue/=2;\n        if(red+blue!=i) continue;\n        // cout << \"i red blue \" << i << \" \" << red << \" \"<< blue << endl;\n        int nred,nblue;\n        if(s[i]=='0'){\n          if(i!=0) {\n            dp[i][red+1-blue+2*n] += dp[i-1][j];\n            if(blue>0){\n              dp[i][red+2-(blue-1)+2*n] += dp[i-1][j];\n            }\n          }\n          else dp[i][j+1] += 1;\n        }\n        else if(s[i]=='1'){\n          if(i!=0){\n            dp[i][j+1] += dp[i-1][j];\n            dp[i][j-1] += dp[i-1][j];\n          }\n          else{\n            dp[i][j+1] += 1;\n            dp[i][j-1] += 1;\n          }\n        }\n        else if(s[i]=='2'){\n          if(i!=0){\n            dp[i][j-1] += dp[i-1][j];\n            if(red>0) dp[i][red-1-(blue+2)+2*n] += dp[i-1][j];\n          }\n          else dp[i][j-1] += 1;\n        }\n      }\n    }\n  }\n  // vector<modint> fact(n+1,1);\n  // vector<modint> inv(n+1,1);\n  // fact[0]=1;\n  // rep1(i,n) fact[i] = fact[i-1]*i;\n  // rep(i,n+1) inv[i] = ((modint) 1)/fact[i];\n  // vector<modint> comb(n+1);\n  // rep(i,n+1) comb[i] = fact[n]*inv[i]*inv[n-i];\n\n  vector<modint> res(n+1);\n  comb(res);\n\n  modint ans =0;\n  rep(i,4*n){\n    int red = (i-n*2+n)/2;\n    int blue = (-(i-2*n)+n)/2;\n    if(red>=0 && blue>=0 && red+blue==n){\n      ans += res[red]*dp[n-1][i];\n    }\n  }\n  cout << ans << endl;\n  \n  return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(auto &it : (v))\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define sz(x) (int)(x).size()\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nll dp[4005][2005];\nll sum[2005];\n\nint main(){\n\tios::sync_with_stdio(0);\n    int N;\n    string S;\n    cin >> S;\n    N = sz(S);\n    rep(i,0,N) {\n        sum[i+1] = sum[i] + (S[i] - '0');\n    }\n    dp[0][0] = 1;\n    rep(i,0,2*N) {\n        rep(j,0,2*N+1) {\n            if (j > i)\n                continue;\n            if (i < N && j > sum[i])\n                continue;\n            if (i < N && i-j > 2*i-sum[i])\n                continue;\n            dp[i][j] %= MOD;\n            dp[i+1][j] += dp[i][j];\n            dp[i+1][j+1] += dp[i][j];\n        }\n    }\n    dp[2*N][sum[N]] %= MOD;\n    cout << dp[2*N][sum[N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n\n#define int long long\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define REPS(i, n) for (int i = 1, i##_len = (n); i <= i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i <= i##_len; ++i)\n#define REV(i, a, b) for (int i = (a); i >= (b); --i)\n#define CLR(a, b) memset((a), (b), sizeof(a))\n#define DUMP(x) cout << #x << \" = \" << (x) << endl;\n#define INF 1001001001001001001ll\n#define fcout cout << fixed << setprecision(10)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint dp[4005][4005];\nint mod = 998244353;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    string s;\n    cin >> s;\n\n    int N = s.size();\n\n    vector<int> sum(N + 1, 0);\n    REP(i, N) {\n        char c = s[i];\n        int r = 0;\n        switch (c) {\n            case '0':\n                r += 2;\n                break;\n            case '1':\n                r += 1;\n                break;\n        }\n        sum[i + 1] = sum[i] + r;\n    }\n\n    dp[0][0] = 1;\n    REP(i, 2 * N) {\n        REP(r, sum[N] + 1) {\n            if (r > i) break;\n\n            int t = i + 1 > N ? N : i + 1;\n\n            // 赤を足す\n            if (sum[t] >= r + 1) {\n                dp[i + 1][r + 1] += dp[i][r];\n                dp[i + 1][r + 1] %= mod;\n            }\n            // 青を足す\n            if ((i + 1) * 2 - sum[t] >= i + 1 - r) {\n                dp[i + 1][r] += dp[i][r];\n                dp[i + 1][r] %= mod;\n            }\n\n        }\n    }\n\n    cout << dp[2 * N][sum[N]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\npublic:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr double eps = 1e-9;\n\nvoid solve() {\n    constexpr i64 mod = 998244353;\n\n    string S;\n    cin >> S;\n\n    /*\n    set<string> st;\n    function<void(vector<vector<int>>, int, string)> dfs=[&](vector<vector<int>> v, int i, string res){\n        if(v.empty()){\n            st.insert(res);\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            dfs(v,0,res);\n            return;\n        }\n\n        rep(j,0,v[i].size()){\n            auto nv=v;\n            auto nres=res;\n            if(i==0){\n                nres+='0'+nv[i][j];\n            }else{\n                nv[i-1].emplace_back(nv[i][j]);\n            }\n            nv[i].erase(begin(nv[i])+j);\n            dfs(nv,i+1,nres);\n        }\n    };\n*/\n    const i64 N=S.size();\n\n    function<void(vector<vector<int>>&, int, string&)> find_min=[&](vector<vector<int>> &v, int i, string &res){\n        while(!v.empty()) {\n            if (i == v.size()) {\n                if (v.back().empty()) {\n                    v.pop_back();\n                }\n                i=0;\n                continue;\n            }\n\n            sort(begin(v[i]), end(v[i]));\n            if (i == 0) {\n                res += '0' + v[i][0];\n            } else {\n                v[i - 1].emplace_back(v[i][0]);\n            }\n            v[i].erase(begin(v[i]));\n            ++i;\n        }\n    };\n\n    function<void(vector<vector<int>>&, int, string&)> find_max=[&](vector<vector<int>> &v, int i, string &res){\n        while(!v.empty()) {\n            if (i == v.size()) {\n                if (v.back().empty()) {\n                    v.pop_back();\n                }\n                i=0;\n                continue;\n            }\n\n            sort(rbegin(v[i]), rend(v[i]));\n            if (i == 0) {\n                res += '0' + v[i][0];\n            } else {\n                v[i - 1].emplace_back(v[i][0]);\n            }\n            v[i].erase(begin(v[i]));\n            ++i;\n        }\n    };\n\n    vector<vector<int>> v(N);\n    rep(i,0,N){\n        if(S[i]=='0'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(0);\n        }else if(S[i]=='1'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(1);\n        }else{\n            v[i].emplace_back(1);\n            v[i].emplace_back(1);\n        }\n    }\n\n    string mini,maxi;\n    {\n        auto tv=v;\n        find_min(tv, 0, mini);\n    }\n    {\n        auto tv=v;\n        find_max(tv, 0, maxi);\n    }\n    print(mini);\n    print(maxi);\n\n    vector<i64> rmin(N),bmin(N);\n    {\n        i64 r=0,b=0;\n        rep(i,0,N){\n            rep(j,0,2){\n                if(v[i][j]==0) ++r;\n                else ++b;\n            }\n            rmin[i]=max(i+1-b,i64(0));\n            bmin[i]=max(i+1-r,i64(0));\n        }\n    }\n\n    print(rmin);\n    print(bmin);\n\n    function<fp<mod>(string)> count=[&](string m) {\n        constexpr i64 maxn = 2000;\n        static fp<mod> dp[maxn * 2][2][maxn + 1]; // 桁, 境界か?, 使用したbの数\n        fill_n((fp<mod> *) dp, maxn * 2 * 2 * (maxn + 1), fp<mod>(0));\n\n        i64 sumb=0;\n        rep(i,0,m.size()) if(m[i]=='1') ++sumb;\n\n        if(m[0]=='0'){\n            dp[0][1][0]=1;\n        }else{\n            dp[0][0][0]=1;\n            dp[0][1][1]=1;\n        }\n\n        rep(i,0,m.size()-1){\n            rep(j,0,2){\n                rep(k, 0, sumb + 1){\n                    if(i<N){\n                        i64 r=i+1-k;\n                        i64 b=k;\n                        if(r<rmin[i] or b<bmin[i]) continue;\n                    }\n\n                    // r=0を置く\n                    if(m[i+1]=='0'){\n                        if(j==0){\n                            // 既に境界より低い\n                            dp[i+1][0][k]+=dp[i][j][k];\n                        }else{\n                            dp[i+1][1][k]+=dp[i][j][k];\n                        }\n                    }else{\n                        dp[i+1][0][k]+=dp[i][j][k];\n                    }\n\n                    // sumb=1を置く\n                    if(k < sumb) {\n                        if (m[i + 1] == '0') {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界を超える\n                            }\n                        } else {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界にいる\n                                dp[i+1][1][k+1]+=dp[i][j][k];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[m.size()-1][0][sumb] + dp[m.size() - 1][1][sumb];\n    };\n\n    const auto ans=count(maxi)-count(mini)+1;\n\n    cout << ans << endl;\n/*\n#ifdef DEBUG\n    dfs(v,0,\"\");\n    print(st.size());\n    for(auto str:st){\n        cout << str << endl;\n    }\n#endif\n */\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define mdn 998244353\nusing namespace std;\nint f[4100][4100];\nchar ch[2100]; int n;\nint pre[2100];\nint main()\n{\n\tscanf(\"%s\",ch+1); n = strlen(ch+1);\n\tfor(int i=1;i<=n;i++)\tpre[i]=pre[i-1]+ch[i]-'0';\n\tf[0][0] = 1;// int ans = 0;\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tfor(int j=0;j<=min(pre[min(i,n)],i);j++)\n\t\t{\n\t\t\tif(j>0 && ((i<=n && pre[i]>=j) || (i>n && pre[n]>=j)))\tf[i][j] = (f[i][j] + f[i-1][j-1])%mdn;\n\t\t\tif((i<=n && 2*i-pre[i]>=i-j) || (i>n && 2*n-pre[n]>=i-j))\tf[i][j] = (f[i][j] + f[i-1][j])%mdn;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n*2][pre[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nll ans = 0;\nconst ll mo = 998244353;\n\nint main()\n{\nstring s ;\ncin >> s ;\nll r=0,b=0;\nrep(i,s.size()){\n  if(s[i]=='0')r+=2;\n  else if(s[i]=='2')b+=2;\n  else {r++;b++;}\n}\nvector<ll> rr,bb;\nrr.push_back(0);\nbb.push_back(0);\nrep(i,s.size()){\n  if(s[i]=='0'){\n    rr.push_back(rr.back()+1);\n    rr.push_back(rr.back()+1);\n    bb.push_back(bb.back());\n  }\n  if(s[i]=='1'){\n    rr.push_back(rr.back()+1);\n    bb.push_back(bb.back()+1);\n  }\n  if(s[i]=='2'){\n    bb.push_back(bb.back()+1);\n    bb.push_back(bb.back()+1);\n    rr.push_back(rr.back());\n  }\n}\nwhile(rr.size()!=2*s.size()+1)rr.push_back(rr.back());\nwhile(bb.size()!=2*s.size()+1)bb.push_back(bb.back());\nvector<vector<ll>> v(s.size()*2, vector<ll>(r+1,0) );\nif(s[0]=='0')v[0][1]=1;\nif(s[0]=='1'){v[0][0]=1;v[0][1]=1;}\nif(s[0]=='2')v[0][0]=1;\nrep(i,s.size()*2-1){\n  rep(j,r+1){\n    if(i+2-j<=bb[i+2]){\n      v[i+1][j]+=v[i][j];\n      v[i+1][j]%=mo;\n    }\n    if(j+1<=rr[i+2]){\n      v[i+1][j+1]+=v[i][j];\n      v[i+1][j+1]%=mo;\n    }\n  }\n}\ncout << v[s.size()*2-1][r] << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**********************************************************************/\n/********                                                      ********/\n/********                     Writer:孙~~                      ********/\n/********                       Lang:C++                       ********/\n/********                     Status:Unknow                    ********/\n/********                                                      ********/\n/**********************************************************************/\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <list>\n#include <cstdlib>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <deque>\n#include <cstring>\n#include <cmath>\n//#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF=0x3f3f3f3f;\nconst int SIZE=2005;\nconst double EPS=1e-6;\nconst int MOD=998244353;\n\nlong long dp[SIZE][SIZE],c[SIZE][SIZE];\nint r[SIZE],b[SIZE];\n\nint main(){\n\t/*main function start*/\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n//\tcout<<n<<endl;\n\tfor(int i=1;i<=n;i++) if(s[i-1]=='0') r[i]=r[i-1]+2,b[i]=b[i-1]; else if(s[i-1]=='1') r[i]=r[i-1]+1,b[i]=b[i-1]+1; else r[i]=r[i-1],b[i]=b[i-1]+2;\n\tfor(int i=n+1;i<=n*2;i++) r[i]=r[i-1],b[i]=b[i-1];\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n*2;i++){\n//\t\tcout<<\"TEST \"<<i<<\" \"<<b[i]<<\" \"<<max(i-b[i],0)<<\" \"<<min(i,r[i])<<endl;\n\t\tfor(int j=max(i-b[i],0);j<=min(i,r[i]);j++){\n\t\t\tif(j>0) dp[i][j]+=dp[i-1][j-1];\n\t\t\tif(i!=j) dp[i][j]+=dp[i-1][j];\n\t\t\tdp[i][j]%=MOD;\n//\t\t\tcout<<dp[i][j]<<\" \";\n\t\t}\n//\t\tcout<<endl;\n\t}\n\tlong long ans=0;\n\tfor(int i=0;i<=min(n*2,r[n*2]);i++){\n\t\tans+=dp[n*2][i];\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n//\tcout<<c[2][0]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main() {\n\tstd::string s; cin >> s;\n\t\n\tint A = 0, B = 0;\n\tconst int MOD = 998244353;\n\tstd::vector<std::vector<std::vector<int>>> dp(2 * s.size() + 1, std::vector<std::vector<int>>(2 * s.size() + 1, std::vector<int>(2, 0)));\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < 2 * s.size(); i++) {\n\t\tif(i < s.size()) {\n\t\t\tif(s[i] == '0') {\n\t\t\t\tA += 2;\n\t\t\t} else if(s[i] == '1') {\n\t\t\t\tA++;\n\t\t\t\tB++;\n\t\t\t} else {\n\t\t\t\tB += 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j = 0; j <= A; j++) {\n\t\t\tint X = A - j, Y = B - (i - j);\n\t\t\tif(X > 0) (dp[i + 1][j + 1][0] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\t\t\tif(Y > 0) (dp[i + 1][j][1] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(auto v: dp[2 * s.size()]) for(auto w: v) (ans += w) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nstring s;\nllint sumR[2005], sumB[2005];\nllint dp[4005][4005];\n\nint main(void)\n{\n\tcin >> s;\n\tint n = s.size();\n\ts = \"#\" + s;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tsumR[i] = sumR[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tif(s[i] == '0') sumR[i] += 2;\n\t\tif(s[i] == '1') sumR[i]++, sumB[i]++;\n\t\tif(s[i] == '2') sumB[i] += 2;\n\t}\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tfor(int j = 0; j <= 2*n; j++){\n\t\t\tdp[i][j] += dp[i-1][j], dp[i][j] %= mod;\n\t\t\tif(j > 0) dp[i][j] += dp[i-1][j-1], dp[i][j] %= mod;\n\t\t\tif(i <= n && (j > sumR[i] || i-j > sumB[i])) dp[i][j] = 0;\n\t\t}\n\t}\n\tcout << dp[2*n][sumR[n]] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define FOR(i, a, b) for (int (i) = (a); (i) <= (b); (i)++)\n#define ROF(i, a, b) for (int (i) = (a); (i) >= (b); (i)--)\n#define REP(i, n) FOR(i, 0, (n)-1)\n#define sqr(x) ((x) * (x))\n#define all(x) (x).begin(), (x).end()\n#define reset(x, y) memset(x, y, sizeof(x))\n#define uni(x) (x).erase(unique(all(x)), (x).end());\n#define BUG(x) cerr << #x << \" = \" << (x) << endl\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define _1 first\n#define _2 second\n\nconst int maxn = 2123;\nconst ll MOD = 998244353;\n\nchar s[maxn];\nll dp[maxn][maxn], fac[maxn], ifac[maxn];\nint avail[2][maxn];\n\nll inv(ll a) {\n    ll ret = 1, pw = MOD - 2;\n    while (pw) {\n        if (pw & 1) ret = ret * a % MOD;\n        a = a * a % MOD;\n        pw >>= 1;\n    }\n    return ret;\n}\n\nll C(int n, int m) {\n    if (m < 0 || m > n) return 0;\n    return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint main() {\n    scanf(\"%s\", s + 1);\n    int n = strlen(s + 1);\n    fac[0] = fac[1] = 1;\n    ifac[0] = ifac[1] = 1;\n    FOR(i, 2, n) fac[i] = fac[i - 1] * i % MOD;\n    FOR(i, 2, n) ifac[i] = inv(fac[i]);\n    FOR(i, 1, n) {\n        avail[0][i] = avail[0][i - 1];\n        avail[1][i] = avail[1][i - 1];\n        if (s[i] == '0') avail[0][i] += 2;\n        else if (s[i] == '1') avail[0][i]++, avail[1][i]++;\n        else avail[1][i] += 2;\n    }\n    dp[0][0] = 1;\n    REP(i, n) REP(j, min(avail[0][i] + 1, i + 1)) {\n            int used[2] = {j, i - j};\n            if (used[1] > avail[1][i]) continue;\n            if (avail[0][i + 1] > used[0]) dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n            if (avail[1][i + 1] > used[1]) dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD;\n        }\n    ll ans = 0;\n    REP(i, avail[0][n] + 1) {\n        int rem[2] = {avail[0][n] - i, avail[1][n] - n + i};\n        ll way = dp[n][i] * C(n, rem[0]) % MOD;\n        ans = (ans + way) % MOD;\n    }\n    printf(\"%lld\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nconst LLI mod = 998244353;\n\nLLI dp[4100][4100];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  while(cin >> s){\n    int n = s.size();\n\n    fill_array(dp,0);\n\n    vector<int> r(2*n+1), b(2*n+1);\n    REP(i,n){\n      switch(s[i]){\n      case '0':\n\tr[i+1] = r[i] + 2;\n\tb[i+1] = b[i];\n\tbreak;\n      case '1':\n\tr[i+1] = r[i] + 1;\n\tb[i+1] = b[i] + 1;\n\tbreak;\n      case '2':\n\tr[i+1] = r[i];\n\tb[i+1] = b[i] + 2;\n\tbreak;\n      }\n    }\n    FOR(i,n,2*n){\n      r[i+1] = r[i];\n      b[i+1] = b[i];\n    }\n\n    dp[0][0] = 1;\n\n    REP(i,2*n){\n      REPE(j,2*n){\n\tif(i+1 < j) continue;\n\tif(j <= r[i+1] && i+1-j<=b[i+1]){\n\t  (dp[i+1][j] += dp[i][j-1]) %= mod;\n\t  (dp[i+1][j] += dp[i][j]) %= mod;\n\t}\n      }\n    }\n\n    \n    cout << dp[2*n][r[n]] << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nconst long long mod = 998244353;\n\nlong long dp[4040][4040];\n\nint N;\nchar ch[2020];\n\nvoid input(){\n\tscanf(\"%s\", ch);\n\tN = strlen(ch);\n}\n\nlong long solve(){\n\tint rall = 0, ball = 0;\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < N * 2; ++i){\n\t\tif(i < N){\n\t\t\tif(ch[i] == '0') rall += 2;\n\t\t\telse if(ch[i] == '1'){\n\t\t\t\trall++;\n\t\t\t\tball++;\n\t\t\t}else{\n\t\t\t\tball += 2;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j <= i; ++j){\n\t\t\tint r = j, b = i - j;\n\t\t\tif(r + 1 <= rall){\n\t\t\t\tdp[r + 1][b] = (dp[r + 1][b] + dp[r][b]) % mod;\n\t\t\t}\n\t\t\tif(b + 1 <= ball){\n\t\t\t\tdp[r][b + 1] = (dp[r][b + 1] + dp[r][b]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[rall][ball];\n}\n\nint main(){\n\tinput();\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <utility>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <climits>\n#include <numeric>\n#include<stdio.h>\n#include <queue>\n#include <iomanip>\n#include <float.h>\n#include <set>\n#include<functional>\n#include <stack>\n#include <time.h>\n#include <climits>\n#include <bitset>\n#include <cmath>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n\tif (a < b) gcd(b, a);\n\tlong long  r;\n\twhile ((r = a%b)) {\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn b;\n}\nlong long lcm(long long a, long long b) {\n\treturn a / gcd(a, b) * b;\n}\nlong long modpow(long long a, long long n, long long mod) {\n\tlong long res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlong long modinv(long long a, long long mod) {\n\tlong long b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\nnamespace NTT {\n\tconst int MOD = 998244353;  // to be set appropriately\n\tconst long long PR = 3;     // to be set appropriately\n\n\tvoid trans(vector<long long> &v, bool inv = false) {\n\t\tint n = (int)v.size();\n\t\tfor (int i = 0, j = 1; j < n - 1; j++) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (i > j) swap(v[i], v[j]);\n\t\t}\n\t\tfor (int t = 2; t <= n; t <<= 1) {\n\t\t\tlong long bw = modpow(PR, (MOD - 1) / t, MOD);\n\t\t\tif (inv) bw = modinv(bw, MOD);\n\t\t\tfor (int i = 0; i < n; i += t) {\n\t\t\t\tlong long w = 1;\n\t\t\t\tfor (int j = 0; j < t / 2; ++j) {\n\t\t\t\t\tint j1 = i + j, j2 = i + j + t / 2;\n\t\t\t\t\tlong long c1 = v[j1], c2 = v[j2] * w % MOD;\n\t\t\t\t\tv[j1] = c1 + c2;\n\t\t\t\t\tv[j2] = c1 - c2 + MOD;\n\t\t\t\t\twhile (v[j1] >= MOD) v[j1] -= MOD;\n\t\t\t\t\twhile (v[j2] >= MOD) v[j2] -= MOD;\n\t\t\t\t\tw = w * bw % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inv) {\n\t\t\tlong long inv_n = modinv(n, MOD);\n\t\t\tfor (int i = 0; i < n; ++i) v[i] = v[i] * inv_n % MOD;\n\t\t}\n\t}\n\n\t// C is A*B\n\tvector<long long> mult(vector<long long> A, vector<long long> B) {\n\t\tint size_a = 1; while (size_a < A.size()) size_a <<= 1;\n\t\tint size_b = 1; while (size_b < B.size()) size_b <<= 1;\n\t\tint size_fft = max(size_a, size_b) << 1;\n\n\t\tvector<long long> cA(size_fft, 0), cB(size_fft, 0), cC(size_fft, 0);\n\t\tfor (int i = 0; i < A.size(); ++i) cA[i] = A[i];\n\t\tfor (int i = 0; i < B.size(); ++i) cB[i] = B[i];\n\n\t\ttrans(cA); trans(cB);\n\t\tfor (int i = 0; i < size_fft; ++i) cC[i] = cA[i] * cB[i] % MOD;\n\t\ttrans(cC, true);\n\n\t\tvector<long long> res((int)A.size() + (int)B.size() - 1);\n\t\tfor (int i = 0; i < res.size(); ++i) res[i] = cC[i];\n\t\treturn res;\n\t}\n};\ntypedef pair<int, int> p;\ntypedef pair<int, p> pai;\nconst int maxn = 1 << 24;\nint n2;\nlong long dat[2 * maxn - 1];\nvoid init(int n_) {\n\tn2 = 1;\n\twhile (n2 < n_)n2 *= 2;\n\tfor (int i = 0; i < 2 * n2 - 1; i++) {\n\t\tdat[i] = LLONG_MIN/2;\n\t}\n}\nvoid update(long long  k, long long a) {\n\tk += n2 - 1;\n\tdat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nlong long query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return LLONG_MIN/2;\n\tif (a <= l&&r <= b)return dat[k];\n\telse {\n\t\tlong long vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tlong long vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n}\nlong long mod = 998244353;\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tvector<int>red;\n\tvector<int>blue;\n\tlong long dp[2003][2003];\n\tint n = s.length();\n\tfor (int i = 0; i < 2003; i++) {\n\t\tfor (int j = 0; j < 2003; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <n; i++) {\n\t\tif (s[i] == '0') {\n\t\t\tred.push_back(i);\n\t\t\tred.push_back(i);\n\t\t}\n\t\tif (s[i] == '1') {\n\t\t\tred.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t\tif (s[i] == '2') {\n\t\t\tblue.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t}\n\tint r = red.size(), b = blue.size();\n\tfor (int i = 0; i <= r; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tif (j < b&&blue[j] <= i + j)dp[i][j + 1] += dp[i][j];\n\t\t\tdp[i][j + 1] %= mod;\n\t\t\tif (i < r&&red[i] <= i + j)dp[i + 1][j] = dp[i][j];\n\t\t\tdp[i + 1][j] %= mod;\n\t\t}\n\t}\n\tcout << dp[r][b];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=2e3;\nstring S;\nll dp[MAX_N*2+1][MAX_N*2+1];\nint rcnt[MAX_N+1],bcnt[MAX_N+1];\nint main(){\n\tcin>>S;\n\tint N=(int)S.size();\n\tREP(i,N){\n\t\tint b=S[i]-'0';\n\t\tbcnt[i+1]=bcnt[i]+b;\n\t\trcnt[i+1]=rcnt[i]+2-b;\n\t}\n\tdp[rcnt[N]][bcnt[N]]=1;\n\tfor(int n=rcnt[N]-1;n>=0;n--){\n\t\tfor(int m=bcnt[N]-1;m>=0;m--){\n\t\t\tint rlb=lower_bound(rcnt,rcnt+N+1,n)-rcnt,blb=lower_bound(bcnt,bcnt+N+1,m)-bcnt;\n\t\t\tif(n+m>rlb){\n\t\t\t\tdp[n][m]+=dp[n+1][m];\n\t\t\t}\n\t\t\tif(n+m>blb){\n\t\t\t\tdp[n][m]+=dp[n][m+1];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\nconst ll MOD = 998244353ll;\n\nint main() {\n  string S;\n  while (cin >> S) {\n    int N = S.size();\n    vector<ll> dp(2 * N + 10, 0ll);\n    dp[0] = 1;\n    int sr = 0, sb = 0;\n    for (int i = 0; i < 2 * N; i++) {\n      if (i < N) {\n        if (S[i] == '0') {\n          sr += 2;\n        } else if (S[i] == '1') {\n          sr += 1;\n          sb += 1;\n        } else {\n          sb += 2;\n        }\n      }\n      vector<ll> ndp(2 * N + 10, 0ll);\n      for (int r = 0; r <= i; r++) {\n        int b = i - r;\n        if (sr - r > 0) {\n          (ndp[r + 1] += dp[r]) %= MOD;\n        }\n        if (sb - b > 0) {\n          (ndp[r] += dp[r]) %= MOD;\n        }\n      }\n      dp.swap(ndp);\n    }\n    cout << dp[sr] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint N;\nchar ball[4010];\nll dp[4010][4010] = {};\nconst ll inf = 998244353;\nint main(){\n    cin >> S;\n    int N = 2*S.size();\n    ll r = 0,b = 0;\n    dp[0][0] = 1;\n    for(int i=0;i<N;i++){\n        if(i<N/2){\n            if(S[i]=='0') r += 2;\n            else if(S[i]=='2') b += 2;\n            else{r++; b++;}\n        }\n        for(ll j=0;j<=r;j++){\n            if(i+1-j<0 || i+1-j>b) continue;\n            (dp[i+1][j] += dp[i][j])%=inf;\n            if(j>0) (dp[i+1][j] += dp[i][j-1])%=inf;\n        }\n    }\n    cout << dp[N][r] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<math.h>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<ULL> VULL;\n\nclass MYCP {\npublic:\n\n\t//数値を区切って文字列にする\n\tstatic string MakeString_LongLong(vector<long long> const& numbers, string const& str) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += str;\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//空白で区切る為のオーバーロード\n\tstatic string MakeString_LongLong(vector<long long> const& numbers) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += \" \";\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\n\n\t//文字列の配列を改行を挟んでまとめる\n\tstatic string MakeString_VectorString(vector<string> const& str) {\n\t\tstring result = \"\";\n\t\tfor (long long i = 0; i < str.size(); i++) {\n\t\t\tresult += str[i] + \"\\n\";\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//文字列を必要な個数だけ読み取る\n\tstatic vector<string> MyReadLineSplit(LL n) {\n\t\tvector<string> str(n);\n\t\tfor (long long i = 0; i < n; i++) {\n\t\t\tstd::cin >> str[i];\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t//数値を必要な個数だけ読み取る\n\tstatic vector<long long> ReadInts(long long number) {\n\t\tvector<long long> a(number);\n\t\tfor (int i = 0; i < number; i++) {\n\t\t\tstd::cin >> a[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t//渡された自然数が素数ならtureを返す\n\tstatic bool PrimeCheck_Int(long long number) {\n\t\tif (number < 2)return false;\n\n\t\tfor (ULL i = 2; i*i <= number; i++) {\n\t\t\tif (number%i == 0)return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t//渡された数値以下の素数表を作る\n\tstatic vector<long long> MakePrimeList(long long n) {\n\t\tvector<long long> list;\n\t\tLL i, j, p;\n\t\tbool flag;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tflag = true;\n\t\t\tfor (j = 0; j < list.size(); j++) {\n\n\t\t\t\tif (!(list[j] * list[j] <= i))break;\n\n\t\t\t\tif (i%list[j] == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)list.push_back(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\n\n\t//文字列の分割\n\tstatic vector<string> split(string const& str, char sep)\n\t{\n\t\tvector<std::string> v;        // 分割結果を格納するベクター\n\t\tauto first = str.begin();              // テキストの最初を指すイテレータ\n\t\twhile (first != str.end()) {         // テキストが残っている間ループ\n\t\t\tauto last = first;                      // 分割文字列末尾へのイテレータ\n\t\t\twhile (last != str.end() && *last != sep)       // 末尾 or セパレータ文字まで進める\n\t\t\t\tlast++;\n\t\t\tv.push_back(string(first, last));       // 分割文字を出力\n\t\t\tif (last != str.end())\n\t\t\t\tlast++;\n\t\t\tfirst = last;          // 次の処理のためにイテレータを設定\n\t\t}\n\t\treturn v;\n\t}\n\n\t//合計を求める\n\tstatic LL Sum(vector<LL> a) {\n\t\tLL i, sum = 0;\n\n\t\tfor (i = 0; i < a.size(); i++) {\n\t\t\tsum += a[i];\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t//小文字ならtrueを返す\n\tstatic bool Komoji(char a) {\n\t\tif (a >= 'a'&&a <= 'z')return true;\n\n\t\treturn false;\n\t}\n\n\t//大文字ならtrueを返す\n\tstatic bool Oomoji(char a) {\n\t\tif (a >= 'A'&&a <= 'Z')return true;\n\n\t\treturn false;\n\t}\n\n\tstatic LL GreatestCommonFactor(LL a, LL b) {\n\t\tLL temp;\n\t\tif (a < b) {\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\twhile (true)\n\t\t{\n\t\t\ttemp = a % b;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\tif (b == 0)break;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\tstatic LL LeastCommonMultiple(LL a, LL b) {\n\t\treturn (a / GreatestCommonFactor(a, b))*b;\n\t}\n\n};\n\n//累積和を求めるクラス\nclass Syakutori {\nprivate:\n\tvector<LL> list;\n\npublic:\n\n\tvoid MakeArray(vector<LL> data) {\n\t\tLL i;\n\t\tlist = data;\n\t\tlist.push_back(0);\n\t\tlist[0] = 0;\n\t\tfor (i = 1; i < list.size(); i++) {\n\t\t\tlist[i] = list[i - 1] + data[i - 1];\n\t\t}\n\n\t}\n\n\tLL Sum(LL start, LL end) {\n\t\tif (end < start) {\n\t\t\tcout << \"startがendより大きいです\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (start < 0 || end >= list.size()) {\n\t\t\tcout << \"範囲が異常\";\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn list[end] - list[start];\n\t}\n\n\n\n\n};\n\nstring strnum = \"0123456789\";\nstring alpS = \"abcdefghijklmnopqrstuvwxyz\";\nstring alpL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nint sizealp = (int)(alpS.size());\nint mod = 1e9 + 7;\n\nint main(void) {\n\tint a[3], b[3];\n\tfor (int i = 0; i < 3; i++)\n\t\tcin >> a[i] >> b[i];\n\tint baketu[5] = {0};\n\tfor (int i = 0; i < 3; i++) {\n\t\tbaketu[a[i]] += a[i] / a[i];\n\t\tbaketu[b[i]] += b[i] / b[i];\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tif (baketu[i] == 3) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\nconst int mod = 998244353;\n\nint n;\nstring s;\nint sumB[N];\nint dp[N * 2][N * 2];\n\nvoid add(int &x, int y) {\n\tx += y; while(x >= mod) x -= mod;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tcin >> s;\n\tn = s.size();\n\ts = ' ' + s;\n\tfor (int i = 1; i <= n; ++i) sumB[i] = sumB[i - 1] + (s[i] - '0');\n\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < 2 * n; ++i) for (int b = 0; b <= i; ++b) {\n\t\tif (!dp[i][b]) continue;\n\t\tint j = min(i + 1, n);\n\t\tint r = i - b;\n\t\t\n\t\tint remB = sumB[j] - b;\n\t\tint remR = 2 * j - sumB[j] - r;\n\t\t//cerr << i << ' ' << b << ' ' << remB << ' ' << remR << endl;\n\t\tassert(remB >= 0 && remR >= 0);\n\t\t\n\t\tif (remB > 0) add(dp[i + 1][b + 1], dp[i][b]);\n\t\tif (remR > 0) add(dp[i + 1][b], dp[i][b]);\n\t}\n\t\n\tint res = 0;\n\tfor (int b = 0; b <= 2 * n; ++b) add(res, dp[2 * n][b]);\n\t\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nusing namespace std;\n\nLL dp[4096][4096];\nstring s;\nvector<int> sum;\nLL mod = 998244353ll;\n\nLL solve(int turn, int b) {\n  if (turn == (int)s.size() * 2) {\n    if(b == sum[(int)s.size() - 1]) return 1;\n    else return 0;\n  }\n  int index = min(turn, (int)s.size() - 1);\n  if(b > sum[index]) return 0;\n  if(b < sum[index] - ((int)s.size() * 2 - turn)) return 0;\n  if(dp[turn][b] != -1) return dp[turn][b];\n  LL answer = 0ll;\n  if((index + 1) * 2 - sum[index] > turn - b) answer += solve(turn + 1, b);\n  if(sum[index] > b) answer += solve(turn + 1, b + 1);\n  answer %= mod;\n  dp[turn][b] = answer;\n  return dp[turn][b];\n}\n\nint main(void)\n{\n  cin >> s;\n  sum.resize(s.size());\n  REP(i,s.size()) sum[i] = s[i] - '0';\n  REP(i,s.size() - 1) sum[i+1] += sum[i];\n  REP(i, 4096) REP(j, 4096) dp[i][j] = -1;\n  cout << solve(0,0) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nV<int> a, b;\nint n;\n\nstd::map<PAIR, int> dp;\nint rec(int i, int j) {\n\tif (dp.count(PAIR(i, j))) return dp[PAIR(i, j)];\n\tint& res = dp[PAIR(i, j)];\n\tres = 0;\n\n\tint rest = i + j;\n\tif (rest < a[i] || rest < b[j]) return res = 0LL;\n\tif (i == 0 && j == 0) return res = 1LL;\n\tif (i == 0) return res = rec(i, j - 1);\n\tif (j == 0) return res = rec(i - 1, j);\n\treturn res = (rec(i, j - 1) + rec(i - 1, j)) % MOD;\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(std::string, s);\n\tn = s.size();\n\n\ta.emplace_back(-1);\n\tb.emplace_back(-1);\n\tREP(i, n) {\n\t\tif (s[i] == '0') {\n\t\t\ta.emplace_back(i + 1);\n\t\t\ta.emplace_back(i + 1);\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\ta.emplace_back(i + 1);\n\t\t\tb.emplace_back(i + 1);\n\t\t}\n\t\telse if (s[i] == '2') {\n\t\t\tb.emplace_back(i + 1);\n\t\t\tb.emplace_back(i + 1);\n\t\t}\n\t}\n\n\tOUT(rec(a.size() - 1, b.size() - 1))BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 4040,mo=998244353;\nchar s[N];int n,f[N][N],qz1[N],qz2[N];\nvoid add(int &x, int y){x=(x+y)%mo;}\nint main() {\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\trep(i,1,n)qz1[i]=qz1[i-1]+(s[i]=='0'?2:(s[i]=='1'?1:0));\n\trep(i,1,n)qz2[i]=qz2[i-1]+(s[i]=='0'?0:(s[i]=='1'?1:2));\n\trep(i,1,n)qz1[n+i]=qz1[n],qz2[n+i]=qz2[n];\n\tf[0][0]=1;\n\trep(i,0,n*2-1)rep(j,0,i)if(f[i][j]){\n\t\tif(i+1-j<=qz2[i+1])add(f[i+1][j],f[i][j]);\n\t\tif(j+1<=qz1[i+1])add(f[i+1][j+1],f[i][j]);\n\t}\n\tcout<<f[n*2][qz1[n]];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(i,1,N){\n\t\t\tif(s[i] == 2){\n\t\t\t\ts[i]--;\n\t\t\t\ts[i-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\nconst int M=998244353;\nchar s[3333]; \nint b[4444][4444],f[4444][4444];\nint sub[5][2]={{'3',0},{'4','3'},{0,'4'}};\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tint R=0,B=0;\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='0')R+=2;\n\t\tif(s[i]=='1')++R,++B;\n\t\tif(s[i]=='2')B+=2;\n\t}\n\tint x=0,y=0;\n\twhile(1)\n\t{\n\t\tint pl=0;\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\tif(s[i]=='0'||s[i]=='2'){pl=i;break;}\n\t\tif(pl==0)break;\n\t\tif(s[pl]=='0')\n\t\t{\n\t\t\tb[x][y+pl]=1;\n\t\t\ts[1]=sub[s[1]-'0'][0];\n\t\t\t++x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[x+pl][y]=1;\n\t\t\ts[1]=sub[s[1]-'0'][1];\n\t\t\t++y;\n\t\t}\n\t\tfor(register int i=1;i<n;++i)\n\t\t{\n\t\t\tif(s[i]=='3')\n\t\t\t{\n\t\t\t\tif(s[i+1]!='0'&&s[i+1]!='3')s[i]='1',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t\t\telse s[i]='0',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(s[i+1]!='2'&&s[i+1]!='4')s[i]='1',s[i+1]=sub[s[i+1]-'0'][0];\n\t\t\t\t\telse s[i]='2',s[i+1]=sub[s[i+1]-'0'][1];\n\t\t\t}\n\t\t}\n\t\tif(!s[n])--n;\n\t}\n\tf[0][0]=1;\n\tfor(register int i=0;i<=R;++i)\n\t\tfor(register int j=0;j<=B;++j)\n\t\t\tif(b[i][j]==0)\n\t\t\t{\n\t\t\t\tif(i)f[i][j]=(f[i][j]+f[i-1][j])%M;\n\t\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1])%M;\n\t\t\t}\n\tprintf(\"%d\\n\",f[R][B]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define inf 0x3f\n#define INF 0x3f3f3f3f\n#define fi first\n#define se second \n#define mp make_pair\n#define pa pair<int,int>\n\nusing namespace std;\n\ninline ll read()\n{\n\tll sum=0,f=1;char c=getchar();\n\twhile (!isdigit(c)) {if (c=='-') f=-1;c=getchar();}\n\twhile (isdigit(c)) {sum=sum*10+c-'0';c=getchar();}\n\treturn sum*f;\n}\nconst int MAXN=4010;\n#define Mod 998244353\nint f[MAXN][MAXN];\nint n;\nchar s[100010];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tint s1=0,s2=0;\n\tf[0][0]=1;\n\tfor(int i=0;i<2*n;i++)\n\t{\t\n\t\tif(i+1<=n)\n\t\t{\n\t\t\tif(s[i+1]=='0') s1+=2;\n\t\t\tif(s[i+1]=='1') s1+=1,s2+=1;\n\t\t\tif(s[i+1]=='2') s2+=2;\n\t\t}\n\t\tfor(int j=0;j<=2*n;j++)\n\t\t{\n\t\t\tif(!f[i][j]) continue;\n\t\t\tif(s1>j)\n\t\t\t\tf[i+1][j+1]+=f[i][j],f[i+1][j+1]%=Mod; \n\t\t\tif(s2>i-j)\n\t\t\t\tf[i+1][j]+=f[i][j],f[i+1][j]%=Mod;\n\t\t}\n\t}\n\tcout<<f[2*n][s1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=2005;\nconst int MOD=998244353;\n\nint n,jc[N],ny[N],f[N][N],s0[N],s1[N];\nchar str[N];\n\nint C(int n,int m)\n{\n\treturn (LL)jc[n]*ny[m]%MOD*ny[n-m]%MOD;\n}\n\nint main()\n{\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);\n\tjc[0]=jc[1]=ny[0]=ny[1]=1;\n\tfor (int i=2;i<=n;i++) jc[i]=(LL)jc[i-1]*i%MOD,ny[i]=(LL)(MOD-MOD/i)*ny[MOD%i]%MOD;\n\tfor (int i=2;i<=n;i++) ny[i]=(LL)ny[i-1]*ny[i]%MOD;\n\tfor (int i=1;i<=n;i++)\n\t\tif (str[i]=='0') s0[i]+=2;\n\t\telse if (str[i]=='1') s0[i]++,s1[i]++;\n\t\telse s1[i]+=2;\n\tfor (int i=1;i<=n;i++) s0[i]+=s0[i-1],s1[i]+=s1[i-1];\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tif (j>s0[i]||i-j>s1[i]) continue;\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (j) (f[i][j]+=f[i-1][j-1])%=MOD;\n\t\t}\n\tint ans=0;\n\tfor (int i=0;i<=n;i++) (ans+=(LL)f[n][i]*C(n,s0[n]-i)%MOD)%=MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\nusing namespace std;\nconst int N=4003,mod=998244353;\nint f[N][N]; \nchar s[N];\nint a[N],b[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tf[0][0]=1;\n\trep(i,1,2*n){\n\t\ta[i]=a[i-1],b[i]=b[i-1];\n\t\tif(s[i]=='0')a[i]+=2;\n\t\tif(s[i]=='1')++a[i],++b[i];\n\t\tif(s[i]=='2')b[i]+=2;\n\t\trep(j,0,a[i-1]){\n\t\t\tif(i-j<=b[i])\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][j])%mod;\n\t\t\tif(j+1<=a[i])\n\t\t\t\tf[i][j+1]=(f[i][j+1]+f[i-1][j])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n+n][a[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nlong long dp[4010][4010];\nint cnt[2010];\nchar s[2010];\nint sum[4010];\n\nint main(){\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tfor (int i = 1; i <= n; i++){\n\t\tcnt[i] = s[i - 1] - '0';\n\t\tsum[i] = sum[i - 1] + cnt[i];\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++){\n\t\tfor (int j = 0; j <= i; j++){\n\t\t\tif (j <= sum[min(i, n)] && i - j <= 2 * min(i, n) - sum[min(i, n)]){\n\t\t\t\tif (j) dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod;\n\t\t\t\telse dp[i][j] = dp[i - 1][j];\n\t\t\t} \n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= 2 * n; i++){\n\t\tans = (ans + dp[2 * n][i]) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//#define int long long\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nvoid solve() {\n\tstring s; cin >> s;\n    int n = (int)s.size();\n    mint dp[4040][2020];\n    rep(i, 4040) {\n        rep(j, 4040) {\n            dp[i][j] = 0;\n        }\n    }\n    vector<int> cntr(n + 1, 0), cntb(n + 1, 0);\n    rep(i, n) {\n        if(s[i] == 0) {\n            cntr[i + 1] = cntr[i] + 2;\n            cntb[i + 1] = cntb[i];\n        } else if(s[i] == 1) {\n            cntr[i + 1] = cntr[i] + 1;\n            cntb[i + 1] = cntb[i] + 1;\n        } else {\n            cntr[i + 1] = cntr[i];\n            cntb[i + 1] = cntb[i] + 2;\n        }\n    }\n    dp[0][0] = (mint)1;\n    rep(i, 2 * n) {\n        rep(j, i + 1) {\n            if(i + 1 >= n || cntr[i + 1] >= j) {\n                if(j > cntr[n]) continue;\n                dp[i + 1][j] += dp[i + 1][j - 1];\n            }\n            if(i + 1 >= n || cntb[i + 1] >= i - j + 1) {\n                if(i - j + 1 > cntb[n]) continue;\n                dp[i + 1][j] += dp[i][j];\n            }\n        }\n    }\n    cout << dp[2 * n][cntr[n]] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = 998244353;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n\nint main() {\n  string S; cin >> S;\n  int N = S.length();\n  int r[2*N] = {}, b[2*N] = {};\n  rep(i,N) {\n    int s = S[i] - '0';\n    r[i] = i==0 ? s : r[i-1] + s;\n    b[i] = i==0 ? 2-s : b[i-1] + (2-s);\n  }\n  repr(i,N,2*N) { r[i] = r[N-1]; b[i] = b[N-1]; }\n  // debug(r,r+2*N); debug(b,b+2*N);\n\n  int dp[2*N+1][2*N+1] = {}; dp[0][0] = 1;\n  rep(i,2*N) {\n    repr(j,max(0,(i+1)-r[i]),b[i]+1) {\n      dp[i+1][j] = 1;\n      dp[i+1][j] = dp[i][j];\n      if (j!=0) dp[i+1][j] += dp[i][j-1];\n      dp[i+1][j] %= MOD;\n    }\n  }\n  // rep(i,2*N+1) debug(dp[i],dp[i]+(2*N+1));\n\n  ll result = 0;\n  rep(i,2*N+1) result = (result + dp[2*N][i])%MOD;\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct mint{\n  static unsigned R, RR, Rinv, W, md, mdninv;\n  unsigned val;\n  mint(){\n  }\n  mint(int a){\n    val = mulR(a);\n  }\n  mint(unsigned a){\n    val = mulR(a);\n  }\n  mint(long long a){\n    val = mulR(a);\n  }\n  mint(unsigned long long a){\n    val = mulR(a);\n  }\n  int get_inv(long long a, int md){\n    long long e, s=md, t=a, u=1, v=0;\n    while(s){\n      e=t/s;\n      t-=e*s;\n      u-=e*v;\n      swap(t,s);\n      swap(u,v);\n    }\n    if(u<0){\n      u+=md;\n    }\n    return u;\n  }\n  void setmod(unsigned m){\n    int i;\n    unsigned t;\n    W = 32;\n    md = m;\n    R = (1ULL << W) % md;\n    RR = (unsigned long long)R*R % md;\n    switch(m){\n      case 104857601:\n      Rinv = 2560000;\n      mdninv = 104857599;\n      break;\n      case 998244353:\n      Rinv = 232013824;\n      mdninv = 998244351;\n      break;\n      case 1000000007:\n      Rinv = 518424770;\n      mdninv = 2226617417U;\n      break;\n      case 1000000009:\n      Rinv = 171601999;\n      mdninv = 737024967;\n      break;\n      case 1004535809:\n      Rinv = 234947584;\n      mdninv = 1004535807;\n      break;\n      case 1007681537:\n      Rinv = 236421376;\n      mdninv = 1007681535;\n      break;\n      case 1012924417:\n      Rinv = 238887936;\n      mdninv = 1012924415;\n      break;\n      case 1045430273:\n      Rinv = 254466304;\n      mdninv = 1045430271;\n      break;\n      case 1051721729:\n      Rinv = 257538304;\n      mdninv = 1051721727;\n      break;\n      default:\n      Rinv = get_inv(R, md);\n      mdninv = 0;\n      t = 0;\n      for(i=0;i<(int)W;i++){\n        if(t%2==0){\n          t+=md;\n          mdninv |= (1U<<i);\n        }\n        t /= 2;\n      }\n    }\n  }\n  unsigned mulR(unsigned a){\n    return (unsigned long long)a*R%md;\n  }\n  unsigned mulR(int a){\n    if(a < 0){\n      a = a%md+md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned mulR(unsigned long long a){\n    return mulR((unsigned)(a%md));\n  }\n  unsigned mulR(long long a){\n    a %= md;\n    if(a < 0){\n      a += md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned reduce(unsigned T){\n    unsigned m=T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned reduce(unsigned long long T){\n    unsigned m=(unsigned)T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned get(){\n    return reduce(val);\n  }\n  mint &operator+=(mint a){\n    val += a.val;\n    if(val >= md){\n      val -= md;\n    }\n    return *this;\n  }\n  mint &operator-=(mint a){\n    if(val < a.val){\n      val = val + md - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  mint &operator*=(mint a){\n    val = reduce((unsigned long long)val*a.val);\n    return *this;\n  }\n  mint &operator/=(mint a){\n    return *this *= a.inverse();\n  }\n  mint operator+(mint a){\n    return mint(*this)+=a;\n  }\n  mint operator-(mint a){\n    return mint(*this)-=a;\n  }\n  mint operator*(mint a){\n    return mint(*this)*=a;\n  }\n  mint operator/(mint a){\n    return mint(*this)/=a;\n  }\n  mint operator+(int a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(int a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(int a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(int a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator+(long long a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(long long a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(long long a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(long long a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator-(void){\n    mint res;\n    if(val){\n      res.val=md-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  operator bool(void){\n    return val!=0;\n  }\n  operator int(void){\n    return get();\n  }\n  operator long long(void){\n    return get();\n  }\n\n  mint inverse(){\n    int a = val, b = md, u = 1, v = 0, t;\n    mint res;\n    while(b){\n      t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    if(u < 0) u += md;\n    res.val = (unsigned long long)u*RR % md;\n    return res;\n  }\n\n  mint pw(unsigned long long b){\n    mint a(*this), res;\n    res.val = R;\n    while(b){\n      if(b&1) res *= a;\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n\n  bool operator==(int a){return mulR(a)==val;}\n  bool operator!=(int a){return mulR(a)!=val;}\n};\nunsigned mint::md, mint::W, mint::R, mint::Rinv, mint::mdninv, mint::RR;\nmint operator+(int a, mint b){return mint(a)+=b;\n}\nmint operator-(int a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(int a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(int a, mint b){\n  return mint(a)/=b;\n}\nmint operator+(long long a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(long long a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(long long a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(long long a, mint b){\n  return mint(a)/=b;\n}\nint rd(char c[]){\n  int i, sz=0;\n  for(;;){\n    i = getchar_unlocked();\n    if(i!=' '&&i!='\\n'&&i!='\\r'&&i!='\\t'&&i!=EOF){\n      break;\n    }\n  }\n  c[sz++] = i;\n  for(;;){\n    i = getchar_unlocked();\n    if(i==' '||i=='\\n'||i=='\\r'||i=='\\t'||i==EOF){\n      break;\n    }\n    c[sz++] = i;\n  }\n  c[sz]='\\0';\n  return sz;\n}\nvoid wt_L(int x){\n  char f[10];\n  int m=0, s=0;\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\nvoid wt_L(mint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\nchar S[2010], vis[4040][4040];\nint N;\nmint bin[4040][4040], dp[4040][4040];\n#define MD 998244353\nmint solve(int a, int b){\n  int i, j;\n  mint res=0;\n  if(vis[a][b]){\n    return dp[a][b];\n  }\n  vis[a][b] = 1;\n  if(a+b==N){\n    return dp[a][b] = bin[N][a];\n  }\n  i = S[a+b];\n  j = 2 - S[a+b];\n  if(a+i > 0){\n    res += solve(a+i-1, b+j);\n  }\n  if(b+j > 0){\n    res += solve(a+i, b+j-1);\n  }\n  return dp[a][b] = res;\n}\nint main(){\n  int i;\n  mint res;\n  {\n    mint x;\n    x.setmod(MD);\n  }\n  for(i=0;i<4040;i++){\n    bin[0][i] = 0;\n  }\n  for(i=0;i<4040;i++){\n    bin[i][0] = 1;\n  }\n  for(i=1;i<4040;i++){\n    int j;\n    for(j=1;j<4040;j++){\n      bin[i][j] = bin[i-1][j-1] + bin[i-1][j];\n    }\n  }\n  N = rd(S);\n  for(i=0;i<N;i++){\n    S[i] -= '0';\n  }\n  res = solve(0,0);\n  wt_L(res);\n  putchar_unlocked('\\n');\n  return 0;\n}\n// cLay varsion 20180730-1\n\n// --- original code ---\n// #define MD 998244353\n// \n// int N;\n// char S[2010];\n// \n// char vis[4040][4040];\n// mint dp[4040][4040];\n// mint bin[4040][4040];\n// \n// mint solve(int a, int b){\n//   int i, j;\n//   mint res = 0;\n// \n//   if(vis[a][b]) return dp[a][b];\n// \n//   vis[a][b] = 1;\n//   if(a+b==N) return dp[a][b] = bin[N][a];\n// \n//   i = S[a+b];\n//   j = 2 - S[a+b];\n// \n//   if(a+i > 0) res += solve(a+i-1, b+j);\n//   if(b+j > 0) res += solve(a+i, b+j-1);\n// \n//   return dp[a][b] = res;\n// }\n// \n// {\n//   int i;\n//   mint res;\n// \n//   rep(i,4040) bin[0][i] = 0;\n//   rep(i,4040) bin[i][0] = 1;\n//   rep(i,1,4040) rep(j,1,4040) bin[i][j] = bin[i-1][j-1] + bin[i-1][j];\n//   \n//   rd(S@N);\n//   rep(i,N) S[i] -= '0';\n// \n//   res = solve(0,0);\n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 998244353;\n\nll dp[4005][4005];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n\n    dp[0][0] = 1;\n    int cntr = 0, cntb = 0;\n    for (int i = 0; i < 2 * n; i++) {\n        if (i < n) {\n            if (s[i] == '0') cntr += 2;\n            else if (s[i] == '2') cntb += 2;\n            else {\n                cntr++;\n                cntb++;\n            }\n        }\n\n        for (int r = 0; r <= cntr; r++) {\n            int b = i - r;\n            if (b < 0) continue;\n            (dp[i+1][r] += dp[i][r] * (cntb>b) % MOD) %= MOD;\n            (dp[i+1][r+1] += dp[i][r] * (cntr>r) % MOD) %= MOD;\n        }\n    }\n    cout << dp[2*n][cntr] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <unistd.h>\n\n#define ll long long\n#define lst(x) x.size()-1\n#define F first\n#define S second\n#define ld long double\n#define pr pair<ll,ll>\n#define loop(i, n) for(int i=0 ; i<n ; ++i)\n#define rep(i, x, n) for(int i=x ; i<=n ; ++i)\n#define iteloop(type, data, name, it) for(type<data>::iterator it=name.begin() ;it!=name.end() ; ++it)\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<typename T>\nusing os = tree<T, null_type, less<T>, rb_tree_tag,\n        tree_order_statistics_node_update>;\n\nconst ll N = 4e3+5,MOD=998244353,MX=1e9+1,MN=0, M = 2e3 + 5;\nint memo[N][N],cntR[N],cntB[N],comR[N],comB[N],n;\nint dp(int i,int r){\n    int b=comB[i]-(i-(comR[i]-r));\n    if(b<0 or r<0)return 0;\n    if(i>=2*n)return 1;\n    int &res=memo[i][r];\n    if(~res)return res;\n    res=0;\n    if(r)\n        res+=dp(i+1,r-1+cntR[i+1]);\n    res%=MOD;\n    if(b)\n        res+=dp(i+1,r+cntR[i+1]);\n    res%=MOD;\n    return res;\n}\nint main() {\n#ifdef CLION\n    freopen(\"std/in.txt\", \"rt\", stdin);\n    // freopen(\"out.txt\", \"wt\", stdout);\n#endif\n    memset(memo,-1,sizeof(memo));\n    string str;\n    cin>>str;\n    n=str.size();\n    loop(i,n){\n        if(str[i]=='0'){\n            comR[i]=2;\n            comB[i]=0;\n            cntR[i]=2;\n            cntB[i]=0;\n        }else if(str[i]=='1'){\n            comR[i]=1;\n            comB[i]=1;\n            cntR[i]=1;\n            cntB[i]=1;\n        }else{\n            comR[i]=0;\n            comB[i]=2;\n            cntR[i]=0;\n            cntB[i]=2;\n        }\n        if(i){\n            comR[i]+=comR[i-1];\n            comB[i]+=comB[i-1];\n        }\n    }\n    rep(i,n,2*n){\n        comR[i]=comR[i-1];\n        comB[i]=comB[i-1];\n    }\n    int res=0;\n    res+=dp(0,cntR[0]);\n    res%=MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//#define int long long\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nvoid solve() {\n\tstring s; cin >> s;\n    int n = (int)s.size();\n    mint dp[4040][4040];\n    rep(i, 4040) {\n        rep(j, 4040) {\n            dp[i][j] = 0;\n        }\n    }\n    vector<int> cntr(n + 1, 0), cntb(n + 1, 0);\n    rep(i, n) {\n        if(s[i] == '0') {\n            cntr[i + 1] = cntr[i] + 2;\n            cntb[i + 1] = cntb[i];\n        } else if(s[i] == '1') {\n            cntr[i + 1] = cntr[i] + 1;\n            cntb[i + 1] = cntb[i] + 1;\n        } else {\n            cntr[i + 1] = cntr[i];\n            cntb[i + 1] = cntb[i] + 2;\n        }\n    }\n    dp[0][0] = (mint)1;\n    rep(i, 2 * n) {\n        rep(j, i + 1) {\n            if(i + 1 >= n || cntr[i + 1] >= j) {\n                if(j > cntr[n]) continue;\n                dp[i + 1][j] += dp[i + 1][j - 1];\n            }\n            if(i + 1 >= n || cntb[i + 1] >= i - j + 1) {\n                if(i - j + 1 > cntb[n]) continue;\n                dp[i + 1][j] += dp[i][j];\n            }\n        }\n    }\n    cout << dp[2 * n][cntr[n]] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\n#define fi first\n#define se second\n\nint dp[2003][2003],r[2003],b[2003];\n\nsigned main(){\n  string s;\n  cin>>s;\n  int n=s.size();\n  r(i,s.size()){\n    if(s[i]=='0')r[i]=2;\n    if(s[i]=='1')r[i]=1,b[i]=1;\n    if(s[i]=='2')b[i]=2;\n  }\n  r(i,s.size()-1){\n    r[i+1]+=r[i];\n    b[i+1]+=b[i];\n  }\n  dp[0][0]=1;\n  r(i,n*2){\n    r(j,n*2)if(j<=i){\n      int x=min(i,n-1);\n      if(r[x]-j>0)dp[i+1][j+1] += dp[i][j];\n      if(b[x]-(i-j)>0)dp[i+1][j] += dp[i][j];\n      dp[i+1][j+1]%=998244353;\n      dp[i+1][j]%=998244353;\n    }\n  }\n  int sum=0;\n  r(i,2003)sum+=dp[n*2][i],sum%=998244353;\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\nusing namespace std;\ntypedef pair<int, int> PP;\ntypedef long long LL;\n#define pb push_back\n#define fr first\n#define sc second\n#define bitcnt __builtin_popcount\n#define all(x) x.begin(), x.end()\ninline LL ri() {LL x; scanf(\"%lld\", &x); return x;}\n#define rep2(i, n, ...) for (int i = 0; i < (n); i ++) \n#define rep3(i, a, b, ...) for (int i = (a); i < (b); i ++)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define drep2(i, n, ...) for (int i = (n) - 1; i >= 0; i --)\n#define drep3(i, a, b) for (int i = (a) - 1; i >= (b); i --)\n#define drep(...) GET_MACRO(__VA_ARGS__, drep3, drep2)(__VA_ARGS__)\ntemplate<typename T>inline bool smax(T&a, T b){if(a<b){a=b;return true;}return false;} \ntemplate<typename T>inline bool smin(T&a, T b){if(a>b){a=b;return true;}return false;} \n/*}}}*/\n\n//mod int\nstruct mint{\n  const static long long mod = 998244353;\n  int x;\n  mint():x(0){}       \n  mint(long long x):x(((x%mod)+mod)%mod){};\n  mint operator+=(const mint&a){if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint operator-=(const mint&a){if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint operator*=(const mint&a){x=((LL)x*a.x)%mod; return *this;}\n  mint operator*(const mint&a){return mint(*this)*=a;}\n  mint operator-(const mint&a){return mint(*this)-=a;}\n  mint operator+(const mint&a){return mint(*this)+=a;}\n  template<typename T>mint operator*(const T&a){return mint(*this)*=a;}\n  template<typename T>mint operator-(const T&a){return mint(*this)-=a;}\n  template<typename T>mint operator+(const T&a){return mint(*this)+=a;}\n  template<typename T>friend mint operator*(T x,const mint&m){return mint(x)*=m;}\n  template<typename T>friend mint operator-(T x,const mint&m){return mint(x)-=m;}\n  template<typename T>friend mint operator+(T x,const mint&m){return mint(x)+=m;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n  operator long long () const {return x;}\n};\nmint pw(mint a, long long b){mint res(1);while(b){if(b&1)res*=a;a*=a;b>>=1;}return res;}\nmint inv(mint a){return pw(a, mint::mod - 2);}\n//mod int\n\nconst int maxn = 5000;\n\nmint p[maxn][maxn], C[maxn][maxn];\n\nint c[maxn];\nint main() {\n  string s;\n  cin >> s;\n  int n = s.length();\n  c[0] = 0;\n  rep(i, n) {\n    //c[i] = (i > 0 ? c[i - 1] : 0) + (s[i] - '0');\n    c[i + 1] = (s[i] - '0') + c[i];\n  }\n  p[0][0] = 1;\n\n  rep(i, maxn) {\n    C[i][0] = C[i][i] = 1;\n    rep(j, 1, i) {\n      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n    }\n  }\n\n  rep(i, n) {\n    rep(j, i + 1) {\n      if (c[i + 1] >= (j + 1)) {\n        p[i + 1][j + 1] += p[i][j];\n      }\n      if (2 * (i + 1) - c[i + 1] >= (i + 1 - j)) {\n        p[i + 1][j] += p[i][j];\n      }\n    }\n  }\n\n  mint res = 0;\n  rep(i, n + 1) {\n    res += p[n][i] * (C[n][c[n] - i]); \n  }\n  cout << res << endl;\n\n\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll mod = 998244353;\n\nll modpower(ll a, ll r){ //a^r\n    ll x = 1;\n    while (r > 0) {\n        if (r & 1) x = x * a % mod;\n        r >>= 1;\n        a = a * a % mod;\n    }\n    return x;\n}\n\nll modinv(ll a){\n    return modpower(a, mod-2);\n}\n\nint main(){\n    ll N;\n    string S;\n    cin >> S;\n    N = S.size();\n    vector<ll> blue(N+1, 0), red(N+1, 0);\n    for (int i = 1; i <= N; i++) {\n        blue[i] = blue[i-1] + (S[i-1] - '0');\n        red[i] = 2*i - blue[i];\n    }\n    \n    vector<ll> fact(2*N+1, 1), invfact(2*N+1, 1);\n    for (int i = 2; i <= 2*N; i++) fact[i] = fact[i-1]*i%mod;\n    invfact[2*N] = modinv(fact[2*N]);\n    for (int i = 2*N-1; i >= 2; i--) invfact[i] = invfact[i+1]*(i+1)%mod;\n    \n    vector<vector<ll>> dp(N+1, vector<ll>(N+1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= i-1; j++) {\n            if (blue[i] >= j+1) dp[i][j+1] = (dp[i][j+1]+dp[i-1][j])%mod;\n            if (red[i] >= i-j) dp[i][j] = (dp[i][j] + dp[i-1][j])%mod;\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        if (i > blue[N] || N-i > red[N]) continue;\n        ll c = fact[N] * invfact[blue[N]-i] % mod * invfact[N - blue[N] + i] % mod;\n        ans = (ans + dp[N][i] * c %mod)%mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <random>\n\nusing namespace std;\n\nconst long long MOD = 998244353;\n\nint dp[4001][4001];\nint reds[4001] = {};\nint blues[4001] = {};\nint main(){\n    for(int i=0;i < 4001; i++){\n        for(int j=0;j < 4001; j++){\n            dp[i][j] = 0;\n        }\n    }\n    string s;\n    cin >> s;\n\n    reds[0] = 0; blues[0] = 0;\n    if(s[0] == '0'){\n        reds[1] = 1 ; reds[2] = 2;\n        blues[1] = 0 ; blues[2] = 0;\n    } else if(s[0] == '1'){\n        reds[1] = 1 ; reds[2] = 1;\n        blues[1] = 1 ; blues[2] = 1;\n    } else {\n        reds[1] = 0 ; reds[2] = 0;\n        blues[1] = 1 ; blues[2] = 2;\n    }\n    for(int i=1;i < (int)s.size()*2;i++){\n        if(i == (int)s.size()){\n            continue;\n        }\n        if(i > (int)s.size()){\n            reds[i+1] = reds[i];\n            blues[i+1] = blues[i];\n            continue;\n        }\n        int c = s[i] - '0';\n        if(c < 2){\n            reds[i+1]++;\n        }\n        if(c > 0){\n            blues[i+1]++;\n        }\n        reds[i+2] = reds[i+1];\n        blues[i+2] = blues[i+1];\n        if(c == 0){\n            reds[i+2]++;\n        }\n        if(c == 2){\n            blues[i+2]++;\n        }\n    }\n\n// for(int i=0;i<=(int)s.size()*2;i++){\n//     printf(\"i=%d, r/b => %d/%d\\n\", i, reds[i], blues[i]);\n// }\n\n    for(int i=0;i<=(int)s.size()*2 + 1;i++){\n        for(int j=0;j<=(int)s.size()*2 + 1;j++){\n            int usableRed = reds[i];\n            int usableBlue = blues[i];\n            int neededBlue = i - j;\n            if(j > usableRed || neededBlue > usableBlue){\n                dp[i][j] = 0;\n                continue;\n            }\n            if(i==0 || j==0){\n                dp[i][j] = 1;\n                continue;\n            }\n            dp[i][j] = 0;\n            if(reds[i-1] > j || usableRed >= j){\n                dp[i][j] += dp[i-1][j-1];\n            }\n            if(blues[i-1] > neededBlue || usableBlue >= neededBlue){\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n            }\n        }\n    }\n\n// for(int i=0;i<=(int)s.size()*2;i++){\n//     for(int j=0;j <=(int)s.size()*2;j++){\n//         printf(\"i/j(%d,%d) => %d\\n\", i, j, dp[i][j]);\n//     }\n// }\n    cout << dp[s.size()*2][reds[s.size()*2]] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define se second\n#define Mod 1000000007\n\nint main(){\n    ll i,j;\n    string s;\n    cin>>s;\n    ll n=s.size();\n\n    ll b=0;\n    ll r=0;\n    vector< vector<ll> > v(2020,vector<ll>(2020,0));\n\n    for(i=0;i<n;i++){\n        if(s[i]=='0'){\n            for(j=0;j<r;j++) v[j][b]=1;\n        }\n        if(s[i]=='2'){\n            for(j=0;j<b;j++) v[r][j]=2;\n        }\n        if(s[i]=='0') r+=2;\n        if(s[i]=='2') b+=2;\n        if(s[i]=='1') {\n            r++;\n            b++;\n        }\n    }\n\n    vector< vector<ll> > ans(2020,vector<ll>(2020,0));\n\n    ans[0][0]=1;\n\n    for(i=0;i<=r;i++){\n        for(j=0;j<=b;j++){\n            if(i!=0||j!=0){\n            ans[i][j]=0;\n            if(i-1>=0){\n                if(v[i-1][j]!=2){\n                ans[i][j]+=ans[i-1][j];\n                }\n            }\n            if(j-1>=0){\n                if(v[i][j-1]!=1){\n                ans[i][j]+=ans[i][j-1];\n                }\n            }\n            \n            }\n        }\n    }\n\n    cout<<ans[r][b]<<endl;\n\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll dp[4444][4444];\n\nvoid modadd(ll &a, ll b){\n\ta += b;\n\ta % MOD;\n}\n\nint main(){\n\t\n\tstring str;\n\tcin >> str;\n\tll n = str.size();\n\tll sum = 0;\n\tdp[0][0] = 1;\n\tREP(i,2 * n){\n\t\tif(i < n)sum += 2;\n\t\tREP(j, 2 * n)if(dp[i][j]){\n\t\t\tll now = j;\n\t\t\tif(i < n)now += str[i] - '0';\n\t\t\tif(now)modadd(dp[i+1][now-1], dp[i][j]);\n\t\t\tif(sum - now - i)modadd(dp[i+1][now], dp[i][j]);\n\t\t}\n\t}\n\t\n\t//cerr << endl << endl;\n\t\n\t/SHOW2d(dp,2*n+1,2*n+1);\n\t\n\tcout << dp[2*n][0] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong mod=998244353,dp[4004][2002];\nstring s;\nmain()\n{\n\tcin>>s;\n\tint cr=0,cb=0;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=s.size()*2;i++)\n\t{\n\t\tif(i<=s.size())\n\t\t{\n\t\t\tif(s[i-1]=='0')cr+=2;\n\t\t\telse if(s[i-1]=='1')cr++,cb++;\n\t\t\telse cb+=2;\n\t\t}\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=((i-j<=cr&&j<=cb?dp[i-1][j]:0)+(j&&i-j<=cr&&j<=cb?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcout<<dp[s.size()*2][cb]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <cstring>\n#include <assert.h>\n#include <utility>\n#include <tuple>\nusing namespace std;\n\nusing int64 = long long;\nusing int128 = __int128;\n\n#define repeat(i, n) for (auto i = decltype(n)(); (i) < (n); (i)++)\n\nconst int64 mod = 998244353;\nint64 dp[4001][4001];\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  string s;\n  cin >> s;\n\n  int N = s.size();\n  vector<int> red_count(2 * N, 0), blue_count(2 * N, 0);\n  for (int i = 0; i < N; i++) {\n    if (s[i] == '0') red_count[i] += 2;\n    else if (s[i] == '1') {\n      red_count[i] += 1;\n      blue_count[i] += 1;\n    } else {\n      blue_count[i] += 2;\n    }\n    if (i > 0) {\n      red_count[i] += red_count[i - 1];\n      blue_count[i] += blue_count[i - 1];\n    }\n  }\n  for (int i = N; i < 2 * N; i++) {\n    red_count[i] = red_count[i - 1];\n    blue_count[i] = blue_count[i - 1];\n  }\n  dp[0][0] = 1;\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= i; j++) {\n      int red = j;\n      int blue = i - j;\n      if (red > red_count[i - 1] or blue > blue_count[i - 1]) continue;\n\n      (dp[i][j] += dp[i - 1][j]) %= mod;\n      if (j > 0) (dp[i][j] += dp[i - 1][j - 1]) %= mod;\n    }\n  }\n\n  cout << dp[2 * N][red_count[2 * N - 1]] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define se second\n#define Mod 998244353 \n\nint main(){\n    ll i,j;\n    string s;\n    cin>>s;\n    ll n=s.size();\n\n    ll b=0;\n    ll r=0;\n    vector< vector<ll> > v(2020,vector<ll>(2020,0));\n\n    for(i=0;i<n;i++){\n        if(s[i]=='0'){\n            for(j=0;j<r;j++) v[j][b]=1;\n        }\n        if(s[i]=='2'){\n            for(j=0;j<b;j++) v[r][j]=2;\n        }\n        if(s[i]=='0') r+=2;\n        if(s[i]=='2') b+=2;\n        if(s[i]=='1') {\n            r++;\n            b++;\n        }\n    }\n\n    vector< vector<ll> > ans(2020,vector<ll>(2020,0));\n\n    ans[0][0]=1;\n\n    for(i=0;i<=r;i++){\n        for(j=0;j<=b;j++){\n            if(i!=0||j!=0){\n            ans[i][j]=0;\n            if(i-1>=0){\n                if(v[i-1][j]!=2){\n                ans[i][j]+=ans[i-1][j];\n                }\n            }\n            if(j-1>=0){\n                if(v[i][j-1]!=1){\n                ans[i][j]+=ans[i][j-1];\n                }\n            }\n            ans[i][j]%=Mod;\n            }\n        }\n    }\n\n    cout<<ans[r][b]<<endl;\n\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 4005;\nconst int P = 998244353;\n\nchar a[maxn];\nint f[maxn][maxn];\nint n, r[maxn], b[maxn];\n\nvoid add(int &x, int y){x += y; if(x>=P) x-=P;}\nint main()\n{\n\t#ifdef MPS\t\n\t\tfp(\"1.in\",\"r\",stdin);\n\t\tfp(\"1.out\",\"w\",stdout);\n\t#endif\n\tsf(\"%s\",a+1);\n\tn = strlen(a+1);\n\tfo(i,1,n)\n\t{\n\t\tif(a[i] == '0') r[i] = 2, b[i] = 0;\n\t\telse if(a[i] == '1') r[i] = 1, b[i] = 1;\n\t\telse r[i] = 0, b[i] = 2;\n\t\tr[i] += r[i-1]; b[i] += b[i-1];\n\t}\n\tf[0][0] = 1;\n\tfo(i,1,n*2) fo(j,0,min(i,n*2))\n\t{\n\t\tif(j >= 1 && r[min(i,n)] >= j) add(f[i][j], f[i-1][j-1]);\t\n\t\tif(b[min(i,n)] >= i-j) add(f[i][j], f[i-1][j]);\n\t\t// cout << i << ' ' << j << ' ' << f[i][j] << endl;\n\t}\n\tpf(\"%d\\n\",f[n*2][r[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nchar str[2005];\nconst int MOD = 998244353;\nint dp[4005], ndp[4005];\nint main() {\n\tscanf(\"%s\", str);\n\tint n = strlen(str);\n\tint blues = 0, reds = 0;\n\tdp[0] = 1;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (i < n) {\n\t\t\tblues += str[i] - '0';\n\t\t\treds += 2 - (str[i] - '0');\n\t\t}\n\t\tmemset(ndp, 0, sizeof(ndp));\n\t\tfor (int j = max(0, i + 1 - reds); j <= min(i + 1, blues); ++j) {\n\t\t\tndp[j] += dp[j]; // red\n\t\t\tndp[j] += dp[j - 1]; // blue\n\t\t\tndp[j] %= MOD;\n\t\t}\n\t\tswap(dp, ndp);\n\t}\n\tprintf(\"%d\\n\", dp[blues]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tstring s_;\n\tcin>>s_;\n\tint n=s_.size();\n\tvector<int> s(n);\n\trep(i,n) s[i]=s_[i]-'0';\n\tusing TP=tuple<int,int,int>;\n\tmap<TP,mint> cur;\n\tcur[make_tuple(0,0,0)]=1;\n\trep(i,2*n){\n\t\tmap<TP,mint> nxt;\n\t\tfor(auto p:cur){\n\t\t\tint id,r,b;\n\t\t\ttie(id,r,b)=p.X;\n\t\t\tif(i<n){\n\t\t\t\tif(s[i]==0){\n\t\t\t\t\tr+=2;\n\t\t\t\t}else if(s[i]==1){\n\t\t\t\t\tr+=1; b+=1;\n\t\t\t\t}else{\n\t\t\t\t\tb+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\t\t\tif\n\t\t\tif(id<n && s[id]!=2,0){\n\t\t\t\tnxt[make_tuple(id+1,r+(s[id]==0),b+(s[id]==1))]+=p.Y;\n\t\t\t}else{\n\t\t\t\tif(r)\tnxt[make_tuple(id,r-1,b)]+=p.Y;\n\t\t\t}\n\t\t\t//B\n\t\t\tif(id<n && s[id]!=0,0){\n\t\t\t\tnxt[make_tuple(id+1,r+(s[id]==1),b+(s[id]==2))]+=p.Y;\n\t\t\t}else{\n\t\t\t\tif(b)\tnxt[make_tuple(id,r,b-1)]+=p.Y;\n\t\t\t}\n\t\t}\n\t\tcur=nxt;\n\t\t// for(auto p:cur) cout<<p<<\",\";cout<<endl;\n\t}\n\tcout<<cur.begin()->Y<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nll n,rnum,bnum;\nbool f[4005][4005],g[4005][4005];\nll dp[4005][4005]={0};\nconst ll mod=1e9+7;\nvoid need_red(vector<ll> vec){\n  vector<ll> need_num(4005,0);\n  ll pos=1,num=0;\n  for(int i=0;i<vec.size();i++){\n    if(vec[i]==0) num++;\n    else if(vec[i]==1){\n      need_num[pos]=num;\n      pos++;\n    }\n    else{\n      need_num[pos]=num;\n      pos++;\n      need_num[pos]=num;\n      pos++;\n    }\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++) f[i][j]=false;\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++){\n      if(j>=need_num[i]) f[i][j]=true;\n    }\n  }\n}\nvoid need_blue(vector<ll> vec){\n  vector<ll> need_num(4005,0);\n  ll pos=1,num=0;\n  for(int i=0;i<vec.size();i++){\n    if(vec[i]==0) num++;\n    else if(vec[i]==1){\n      need_num[pos]=num;\n      pos++;\n    }\n    else{\n      need_num[pos]=num;\n      pos++;\n      need_num[pos]=num;\n      pos++;\n    }\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++) g[i][j]=false;\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++){\n      if(i>=need_num[j]) g[i][j]=true;\n    }\n  }\n}\nint main(){\n  string s;\n  cin>>s;\n  n=s.length();\n  rnum=0;\n  bnum=0;\n  vector<ll> rball,bball;\n  for(int i=0;i<n;i++){\n    if(s[i]=='0') {\n      rball.push_back(2);\n      bball.push_back(0);\n      rnum+=2;\n    }\n    else if(s[i]=='1'){\n      rball.push_back(1);\n      bball.push_back(1);\n      rnum++; bnum++;\n    }\n    else{\n      rball.push_back(0);\n      bball.push_back(2);\n      bnum+=2;\n    }\n  }\n  need_red(rball);\n  need_blue(bball);\n  dp[0][0]=1;\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++){\n      dp[i][j]%=mod;\n      if(i<rnum){\n        if(f[i][j]&&g[i][j]&&f[i+1][j]) dp[i+1][j]+=dp[i][j];\n        dp[i+1][j]%=mod;\n      }\n      if(j<bnum){\n        if(f[i][j]&&g[i][j]&&g[i][j+1]) dp[i][j+1]+=dp[i][j];\n        dp[i][j+1]%=mod;\n      }\n    }\n  }\n  cout<<dp[rnum][bnum]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define mod 998244353\nusing namespace std;\n\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getchar();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getchar();\n    }\n    return x * f;\n}\n\nlong long dp[2][2003];\nchar s[2003];\n\nlong long fsp(long long base, long long p) {\n    long long rt = 1;\n    while (p) {\n        if (p & 1) (rt *= base) %= mod;\n        (base *= base) %= mod;\n        p >>= 1;\n    }\n    return rt;\n}\n\nint main() {\n    scanf(\"%s\", s + 1);\n    int n = strlen(s + 1);\n    dp[0][0] = 1;\n    int t = 0;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= i; ++j) dp[t ^ 1][j] = 0;\n        for (int j = 0; j <= i - 1; ++j) {\n            if (s[i] == '0') {\n                (dp[t ^ 1][j + 1] += dp[t][j]) %= mod;\n                if (j != i - 1) (dp[t ^ 1][j + 2] += dp[t][j]) %= mod;\n            }\n            if (s[i] == '1') {\n                (dp[t ^ 1][j + 1] += dp[t][j]) %= mod;\n                (dp[t ^ 1][j] += dp[t][j]) %= mod;\n            }\n            if (s[i] == '2') {\n                (dp[t ^ 1][j] += dp[t][j]) %= mod;\n                if (j != 0) (dp[t ^ 1][j - 1] += dp[t][j]) %= mod;\n            }\n        }\n        t ^= 1;\n    }\n    long long res = 0, tmp = 1;\n    for (int i = 0; i <= n; ++i) {\n        (res += tmp * dp[t][i] % mod) %= mod;\n        (tmp *= fsp(i + 1, mod - 2) * (long long)(n - i) % mod) %= mod;\n    }\n    printf(\"%lld\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint64_t dp[2005][2005];\nstatic const int64_t mod=998244353;\nint64_t f(int64_t x,int64_t y){\nif(y==0)\n  return 1;\n  else if(y%2==0)\n    return (f(x,y/2)*f(x,y/2))%mod;\n  else\n    return (x*((f(x,y/2)*f(x,y/2))%mod))%mod;\n}\nint main(){\n string s;cin>>s;int N=s.size();\n  vector<int64_t>A(N);\n  for(int i=0;i<N;i++){\n    int64_t a=s.at(i)-'0';\n    A.at(i)=a;\n  }dp[0][0]=1;\n  for(int i=1;i<=N;i++)\n    for(int j=0;j<=i;j++){\n    int64_t d=0;int64_t a=A.at(i-1);\n      if(0<=j-a)\n        d+=dp[i-1][j-a];\n      if(0<=j-a+1)\n        d+=dp[i-1][j-a+1];\n      dp[i][j]=d%mod;\n    }int64_t ans=0;int64_t com=1;\n  for(int j=0;j<=N+1;j++){\n  ans=(ans+dp[N][j]*com)%mod;\n    com=(com*(N-j))%mod;\n    com=(com*f(j+1,mod-2))%mod;\n  }cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n#define int long long\n#define all(a) a.begin(), a.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 998244353;\nconst int INF = 1e18;\n\nint dp[2010][4010];\nint r[2010];\nint b[2010];\n\n\nstruct Combination {\n    vector<int64_t> fact, rfact;\n    Combination(int sz) : fact(sz + 1), rfact(sz + 1) {\n        fact[0] = 1;\n        for(int i = 1; i < fact.size(); i++){\n            fact[i] = fact[i - 1] * i % mod;\n        }\n        rfact[sz] = inv(fact[sz]);\n        for(int i = sz - 1; i >= 0; i--){\n            rfact[i] = rfact[i + 1] * (i + 1) % mod;\n        }\n    }\n    int64_t inv(int x) const {\n        return pow(x, mod - 2);\n    }\n    int64_t pow(int64_t x, int64_t n) const {\n        int64_t ret = 1;\n        while(n > 0){\n            if(n & 1) (ret *= x) %= mod;\n            (x *= x) %= mod;\n            n >>= 1;\n        }\n        return (ret);\n    }\n    int64_t P(int n, int r) const {\n        if(r < 0 || n < r) return (0);\n        return (fact[n] * rfact[n - r] % mod);\n    }\n\n    int64_t C(int p, int q) const {\n        if(q < 0 || p < q) return (0);\n        return (fact[p] * rfact[q] % mod * rfact[p - q] % mod);\n    }\n\n    int64_t H(int n, int r) const {\n        if(n < 0 || r < 0) return (0);\n        return (r == 0 ? 1 : C(n + r - 1, r));\n    }\n};\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    cin >> s;\n    int n = s.size();\n    rep(i, 0, n){\n        if(i){\n            r[i] = r[i - 1];\n            b[i] = b[i - 1];\n        }\n        if(s[i] == '0') r[i] += 2;\n        else if(s[i] == '2') b[i] += 2;\n        else{\n            r[i]++; b[i]++;\n        }\n    }\n    dp[0][0] = 1;\n    rep(i, 0, n){\n        rep(j, 0, 2 * n + 1){\n            if(dp[i][j] == 0) continue;\n            int rr = r[i] - j;\n            int bb = b[i] - (i - j);\n            if(rr != 0) (dp[i + 1][j + 1] += dp[i][j]) %= mod;\n            if(bb != 0) (dp[i + 1][j] += dp[i][j]) %= mod;\n        }\n    }\n    int ans = 0;\n    Combination cb(4010);\n    rep(i, 0, 2 * n + 1){\n        int rr = r[n - 1] - i;\n        int bb = b[n - 1] - (n - i);\n        if(dp[n][i] == 0) continue;\n        int tmp = dp[n][i] * cb.C(n, rr) % mod;\n        (ans += tmp) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long dp[4001][4001],mod=998244353;\nint n;\nstring s;\nlong long ans(int b,int cn)\n{\n\tif(cn==2*n)return 1;\n\tif(dp[b][cn]!=0)return dp[b][cn];\n\tint r;\n\tif(cn>=n)r=2*n-b-cn;\n\telse r=2*(cn+1)-b-cn;\n\tint nb=0;\n\tif(cn<n-1)nb=s[cn+1]-'0';\n\tif(b!=0)dp[b][cn]+=ans(b-1+nb,cn+1);\n\tif(r!=0)dp[b][cn]+=ans(b+nb,cn+1);\n\treturn dp[b][cn];\n}\nint main()\n{\n\tcin>>s;\n\tn=s.size();\n\ts+=s;\n\tcout<<ans(s[0]-'0',0)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\ntypedef double db;\nconst int maxn = 4e3 + 5;\nconst ll mod = 998244353;\n\nint n;\nchar s[maxn];\nll dp[maxn][maxn];\nint a[maxn], b[maxn];\n\ntemplate<class T>\nvoid add(T &x, T &y){ x += y; if(x >= mod) x -= mod; }\n\nint main(){\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    rep(i, 1, n)\n        a[i] = a[i-1] + 2 - (s[i] - '0'), b[i] = b[i-1] + s[i] - '0';\n    dp[0][0] = 1;\n    rep(i, 0, 2 * n)\n        rep(j, 0, i)\n            if(dp[i][j]){\n                if(a[min(i + 1, n)] > j)\n                    add(dp[i+1][j+1], dp[i][j]);\n                if(b[min(i + 1, n)] > i - j)\n                    add(dp[i+1][j], dp[i][j]);\n            }\n    printf(\"%lld\\n\", dp[2*n][a[n]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<ctime>\n#include<set>\n#include<iomanip>\n#define sqr(x) (x)*(x)\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ int\nusing namespace std;\n//struct bit{T_ arr[1000005];int lowbit(int x){return x&(-x);}void add(int x,T_ y){for (int i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(int x){T_ s=0;for (int i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{int l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(int id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(int id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(int id,int l,int r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{int mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(int id,int le,int ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(int id,int le,int ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\n//struct bit_2d{T_ a[2005][2005];int lowbit(int x){return x&(-x);}void add(int x,int y,T_ z){int i,j;for (i=x;i<=2000;i+=lowbit(i)){for (j=y;j<=2000;j+=lowbit(j)){a[i][j]+=z;}}}T_ query(int x,int y){int i,j;T_ s=0;for (i=x;i;i-=lowbit(i)){for (j=y;j;j-=lowbit(j)){s+=a[i][j];}}return s;}T_ query(int x,int y,int xx,int yy){return query(xx,yy)-query(x-1,yy)-query(xx,y-1)+query(x-1,y-1);}};\nlong long rlim[4005],blim[4005],dp[4005][4005],mod=998244353,f1,f2,g1,g2,h1,h2,n,m,i,j;\nstring st;\nint main()\n{\n\tcin>>st;n=st.length();\n\tst=\" \"+st;\n\tmemset(rlim,0,sizeof(rlim));\n\tmemset(blim,0,sizeof(blim));\n\tfz1(i,n)\n\t{\n\t\tg1+=2-(st[i]-'0');\n\t\tg2+=st[i]-'0';\n\t\trlim[max(0ll,f1)]=max(rlim[max(0ll,f1)],g2);\n\t\tblim[max(0ll,f2)]=max(blim[max(0ll,f2)],g1);\n\t\tif (st[i]=='0') {if (h1) h1--; else f1++;h2++;}\n\t\tif (st[i]=='2') {h1++;if (h2) h2--; else f2++;}\n\t}\n\tfz1(i,g1) rlim[i]=max(rlim[i-1],rlim[i]);\n\tfz1(i,g2) blim[i]=max(blim[i-1],blim[i]);\n\tdp[0][0]=1;\n\tfz0g(i,g1)\n\t{\n\t\tfz0g(j,g2)\n\t\t{\n\t\t\tif (rlim[i]<j||blim[j]<i) continue;\n\t\t\t(dp[i+1][j]+=dp[i][j])%=mod;\n\t\t\t(dp[i][j+1]+=dp[i][j])%=mod;\n\t\t}\n\t}\n\tcout<<dp[g1][g2]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\n\nstring str;\nint n;\n\nll dp[4005][4005];\n\nint main(){\n  cin>>str;\n  n=str.size();\n  dp[0][0]=1;\n\n  ll cnt=0;\n  for(int i=0;i<n*2;i++){\n\n    if(i<n)cnt+=2;\n    \n    for(int j=0;j<=4000;j++){\n      if(dp[i][j]==0)continue;\n      ll R=j;\n\n      if(i<n){\n        if(str[i]=='0'){\n          R+=2;\n        }else if(str[i]=='1'){\n          R++;\n        }\n      }\n      \n      ll B=cnt-R;\n      assert(B>=0);\n      \n      if(R>0){\n        int nj=j;\n        if(R==j+2)nj++;\n        if(R==j)nj--;\n        \n        assert(nj>=0);\n        dp[i+1][nj]+=dp[i][j];\n        dp[i+1][nj]%=mod;\n        \n      }\n      \n      if(B>0){\n        int nj=j;\n        if(R==j+2)nj+=2;\n        if(R==j+1)nj++;\n        dp[i+1][nj]+=dp[i][j];\n        dp[i+1][nj]%=mod;\n      }\n    }\n    \n\n    cnt--;\n  }\n  /*\n  for(int i=0;i<=n*2;i++){\n    for(int j=0;j<=n*2;j++){\n      printf(\"%02d \",(int)dp[i][j]);\n    }\n    cout<<endl;\n  }\n*/\n  cout<<dp[2*n][0]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 0xccccccc;\nconst ll LINF = 0xcccccccccccccccLL;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\n//const unsigned int mod = 1000000007;\nconst unsigned int mod = 998244353;\n\nstruct mint {\n\tunsigned int x;\n\tmint():x(0) {}\n\tmint(int64_t x_) {\n\t\tint64_t v = int64_t(x_ % mod);\n\t\tif(v < 0) v += mod;\n\t\tx = (unsigned int)v;\n\t}\n\tstatic mint row(int v) {\n\t\tmint v_;\n\t\tv_.x = v;\n\t\treturn v_;\n\t}\n\tmint operator-() const { return mint(-int64_t(x));}\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += mod-a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) {\n\t\tuint64_t z = x;\n\t\tz *= a.x;\n\t\tx = (unsigned int)(z % mod);\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const { return mint(*this) += a;}\n\tmint operator-(const mint a) const { return mint(*this) -= a;}\n\tmint operator*(const mint a) const { return mint(*this) *= a;}\n\tfriend bool operator==(const mint &a, const mint &b) {return a.x == b.x;}\n\tfriend bool operator!=(const mint &a, const mint &b) {return a.x != b.x;}\n\tmint &operator++() {\n\t\tx++;\n\t\tif(x == mod) x = 0;\n\t\treturn *this;\n\t}\n\tmint &operator--() {\n\t\tif(x == 0) x = mod;\n\t\tx--;\n\t\treturn *this;\n\t}\n\tmint operator++(int) {\n\t\tmint result = *this;\n\t\t++*this;\n\t\treturn result;\n\t}\n\tmint operator--(int) {\n\t\tmint result = *this;\n\t\t--*this;\n\t\treturn result;\n\t}\n\tmint pow(int64_t t) const {\n\t\tmint x_ = *this, r = 1;\n\t\twhile(t) {\n\t\t\tif(t&1) r *= x_;\n\t\t\tx_ *= x_;\n\t\t\tt >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\t//for prime mod\n\tmint inv() const { return pow(mod-2);}\n\tmint& operator/=(const mint a) { return *this *= a.inv();}\n\tmint operator/(const mint a) {return mint(*this) /= a;}\n};\n\nistream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\nstruct combination {\n\tvector<mint> frac, ifrac;\n\tcombination(int n):frac(n+1), ifrac(n+1) {\n\t\tassert((unsigned int)(n) < mod);\n\t\tfrac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) frac[i] = frac[i-1]*i;\n\t\tifrac[n] = frac[n].inv();\n\t\tfor (int i = n; i >= 1; --i) ifrac[i-1] = ifrac[i]*i;\n\t}\n\tmint operator()(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn frac[n]*ifrac[k]*ifrac[n-k];\n\t}\n} c(10000);\n\n//head\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tvector<mint> dp(n+1);\n\tdp[0] = 1;\n\tint cnt = 0;\n\trep(i, n) {\n\t\tint c_t = cnt;\n\t\tcnt += s[i]-'0';\n\t\tfor(int j = min(c_t, i); j >= max(0, c_t-i); j--) {\n\t\t\tif(j < cnt) dp[j+1] += dp[j];\n\t\t\tif(cnt == i+j+2) dp[j] = 0;\n\t\t}\n\t}\n\tmint ans;\n\trep(i, n+1) {\n\t\tans += dp[i] * c(n, cnt-i);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tll dp[4001][4001]={};\n\tdp[0][0]=1;\n\tint ct[3]={};\n\tfor(int i=0; i<2*n; i++){\n\t\tif(i<n) ct[s[i]-'0']++;\n\t\tfor(int j=0; j<=i+1; j++){\n\t\t\tif(j<=2*ct[0]+ct[1] && i+1-j<=2*ct[2]+ct[1]){\n\t\t\t\tif(j) dp[i+1][j]+=dp[i][j-1];\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tdp[i+1][j]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0; i<=2*n; i++) ans=(ans+dp[2*n][i])%MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    auto safeat = [](auto& t, auto i, auto j)->long{\n        if(i < 0 || j < 0 || i >= t.size() || j >= t[0].size())return 0;\n        else return t[i][j];\n    };\n    constexpr long m = 998244353;\n    long N;\n    string s;\n    cin >> s;\n    N = s.size();\n    vector<pair<long, long>> S;\n    for(auto i : s)S.emplace_back((i & 3), 2 - (i & 3));\n    partial_sum(S.begin(), S.end(), S.begin(), [](auto a, auto b){return pair<long, long>(a.first + b.first, a.second + b.second);});\n    vector<vector<long>> dp(S.rbegin()->first + 1, vector<long>(S.rbegin()->second + 1, 0));\n    dp[0][0] = 1;\n    for(int i = 1; i <= 2 * N; ++i){\n        for(int j = 0; j <= i; ++j){\n            if(j > S.rbegin()->first || i - j > S.rbegin()->second)continue;\n            if(i <= N){\n                if(j > S[i - 1].first)continue;\n                if(i - j > S[i - 1].second)continue;\n            }\n            dp[j][i - j] = safeat(dp, j, i - j - 1) + safeat(dp, j - 1, i - j);\n            dp[j][i - j] %= m;\n        }\n    }\n    cout << *(dp.rbegin()->rbegin()) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60;\n\nconst ll Mod=998244353;\n\nint main(){\n  int i,j;\n  string s;\n  cin>>s;\n  int n=s.size();\n  int r=0,b=0;\n  int rban=0,bban=0;\n  vector<int> rr(4020,inf),bb(4020,inf);\n  for(i=0;i<n;i++){\n    rr[i]=b;\n    bb[i]=r;\n    if(s[i]=='1') {\n      r++;\n      b++;\n    }\n    else if(s[i]=='0'){\n      r+=2;\n    }\n    else {\n      b+=2;\n    }\n  }\n\n  VVI dp(r+1,VI(b+1,0));\n  dp[0][0]=1;\n  for(i=0;i<=r;i++){\n    for(j=0;j<=b;j++){\n      if(i==0&&j==0) continue;\n      if(i-1>=0&&rr[i+j]>=j&&bb[i+j]>=i) dp[i][j]+=dp[i-1][j];\n      if(j-1>=0&&bb[i+j]>=i&&rr[i+j]>=j) dp[i][j]+=dp[i][j-1];\n      dp[i][j]%=Mod;\n      //cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n    }\n  }\n  cout<<dp[r][b]<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define md 998244353\nusing namespace std;\nstring s;\nint u, sz, dp[4005] = {1}, a;\nint main(){\n  cin >> s; sz = s.size();\n  for(int i = 1; i <= sz*2; i++){\n   if(i <= sz) u += '2' - s[i-1];\n   for(int j = i; j >= 0; j--){\n     if(j) dp[j] = (dp[j] + dp[j-1]) % md;\n     if(u < j || (i <= sz ? u-i : u+i-2*sz) > j) dp[j] = 0;\n     if(i == sz*2) a = (a + dp[j]) % md;\n   }\n  }\n  printf(\"%d\\n\", a);\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\nint dp[3][4010];\nsigned main() {\n    string s; cin >> s;\n    int N = s.length();\n\n    dp[0][0] = 1;\n    for(int i=0; i<2*N; i++) {\n        int cur = i % 2, nxt = 1 - cur;\n        for(int j=0; j<=2*i; j++) {\n            if(dp[cur][j] == 0) continue;\n            // fprintf(stderr, \"dp[%lld][%lld] = %lld\\n\", i, j, dp[cur][j]);\n            int red = j, blue = i - red;\n            if(i < N) {\n                if(s[i] == '0') red += 2;\n                if(s[i] == '1') red += 1, blue += 1;\n                if(s[i] == '2') blue += 2;\n            }\n\n            if(red) {\n                (dp[nxt][red-1] += dp[cur][j]) %= MOD;\n            }\n            if(blue) {\n                (dp[nxt][red] += dp[cur][j]) %= MOD;\n            }\n        }\n        fill(dp[cur], dp[cur+1], 0);\n    }\n    cout << dp[0][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\nint main(){\n    string S;\n    cin >> S;\n    int N = S.size();\n\n    static int64_t dp[4001][4001];\n    dp[0][0] = 1;\n    int rsum = 0, bsum = 0;\n\n    for(int i=0; i<2*N; i++){\n        if(i < N){\n            rsum += '2' - S[i];\n            bsum += S[i] - '0';\n        }\n        for(int r=0; r<=rsum; r++){\n            int b = i+1 - r;\n            if(b < 0 || b > bsum) continue;\n            add(dp[i+1][r], dp[i][r]);\n            if(r > 0) add(dp[i+1][r], dp[i][r-1]);\n        }\n    }\n    cout << dp[2*N][rsum] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2010,mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nchar str[N];\nint sum[N][2],n;\nll dp[N][N],frac[N],inv[N];\nint main()\n{\n\tscanf(\"%s\",str+1); n=strlen(str+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tsum[i][0]=sum[i-1][0]+(str[i]-'0');\n\t\tsum[i][1]=sum[i-1][1]+2-(str[i]-'0');\n\t}\n\tfrac[0]=1;\n\tfor(int i=1;i<=n;++i) frac[i]=frac[i-1]*i%mod;\n\tinv[n]=Pow(frac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\t\n\tdp[0][0]=1;\n\tfor(int i=0;i<n;++i)\n\tfor(int j=0;j<=i;++j)\n\tif(dp[i][j])\n\t{\n\t\tif(sum[i+1][0]>=j+1) dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t\tif(sum[i+1][1]>=i+1-j) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t}\n//\tfor(int j=0;j<=n;++j) printf(\"%0lld\\n\",dp[n][j]); \n\tll ans=0;\n\tfor(int i=0;i<=n;++i) if(sum[n][0]>=i&&sum[n][1]>=(n-i)) ans=(ans+dp[n][i]*inv[sum[n][0]-i]%mod*inv[sum[n][1]-(n-i)]%mod)%mod;\n\tans=ans*frac[n]%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int mod = 998244353;\n\nint main() {\n    string s; cin >> s;\n    const int n = s.size();\n    vector<int> rcnt(n + 1);\n    for(int i = 0; i < n; ++i) {\n        rcnt[i + 1] = rcnt[i];\n        if(s[i] == '0') rcnt[i + 1] += 2;\n        else if(s[i] == '1') rcnt[i + 1] += 1;\n    }\n\n    vector<vector<ll>> nCr(n + 1, vector<ll>(n + 1));\n    for(int i = 0; i <= n; ++i) {\n        for(int j = 0; j <= i; ++j) {\n            if(j == 0 || i == j) {\n                nCr[i][j] = 1;\n            } else {\n                nCr[i][j] = (nCr[i - 1][j] + nCr[i - 1][j - 1]) % mod;\n            }\n        }\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1));\n    dp[0][0] = 1;\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j <= n; ++j) {\n            if(dp[i][j] == 0) continue;\n            int r = j, b = 2 * i - rcnt[i] - (i - (rcnt[i] - j));\n            if(s[i] == '0') r += 2;\n            if(s[i] == '1') {\n                r += 1;\n                b += 1;\n            }\n            if(s[i] == '2') {\n                b += 2;\n            }\n            if(r > 0) {\n                (dp[i + 1][r - 1] += dp[i][j]) %= mod;\n            }\n            if(b > 0) {\n                //cout << i << ' ' << j << endl;\n                (dp[i + 1][r] += dp[i][j]) %= mod;\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i <= n; ++i) {\n        //cout << dp[n][i] << endl;\n        (ans += dp[n][i] * nCr[n][i]) %= mod;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<stack>\nusing namespace std;\nconst int mod = 998244353;\nchar s[100100];\nint n,m,dp[4010][4010],sum[2010][2];\nint main(){\n    int i,j,k;\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(i=1;i<=n;i++){\n      if(s[i]=='0')sum[i][0]+=2;\n        else if(s[i]=='1')sum[i][0]++,sum[i][1]++;\n        else sum[i][1]+=2;\n      sum[i][0]+=sum[i-1][0],sum[i][1]+=sum[i-1][1];\n\t}\n\tif(sum[1][0])dp[1][0]=1;\n\tif(sum[1][1])dp[1][1]=1;\n\tfor(i=2;i<=2*n;i++)\n\t  for(j=0;j<=i;j++){\n\t    if(j>sum[min(i,n)][1]||i-j>sum[min(i,n)][0])continue;\n\t    dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t    if(j)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n\t  }\n\tcout<<dp[2*n][sum[n][1]];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 998244353\n\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n\n    /**\n     * x ^ -1を求める\n     */\n    template<typename T>\n    ll inv(T x) {\n        return pow(x, MOD - 2);\n    }\n};\n\nCombination cmb(4001);\n\nclass Solve {\npublic:\n    string S;\n    vector<Int> B;\n    vector<Int> C;\n    Int N;\n\n    void solve() {\n        cin >> S;\n        N = S.size();\n        B.resize(N + 1);\n        C.resize(N + 1);\n        for (int i = 0; i < N; ++i) {\n            B[i] = S[i] - '0';\n        }\n        C[0] = B[0];\n        for (int i = 1; i < N; ++i) {\n            C[i] = B[i] + C[i - 1];\n        }\n        vector<vector<Int>> dp(N + 1, vector<Int>(2 * N + 1));\n\n        dp[0][0] = 1;\n\n        for (int i = 0; i < N; ++i) {\n\n            for (int j = 0; j <= i; ++j) {\n                dp[i][j] %= MOD;\n                Int b = 0;\n                Int r = 0;\n\n                if (i > 0) {\n                    b = C[i - 1] - j;\n                    r = (2 * i - C[i - 1]) - b;\n                }\n\n                // あお追加できる場合\n                if (b > 0 || B[i] > 0) {\n                    (dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n                }\n\n                // あか追加できる場合\n                if (r > 0 || B[i] <= 1) {\n                    (dp[i + 1][j] += dp[i][j]) %= MOD;\n                }\n\n            }\n        }\n\n        Int ans = 0;\n\n        for (int i = 0; i <= N; ++i) {\n            Int blue = C[N - 1] - i;\n            Int red = (2 * N - C[N - 1]) - (N - i);\n\n            if (blue >= 0 && red >= 0) {\n                Int left = dp[N][i] % MOD;\n                Int right = cmb.nCk(blue + red, blue);\n                Int tmp = (left * right) % MOD;\n                ans += tmp;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of God\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int , int> pii;\n\nconst int N = 4e3+10 , mod = 998244353;\n\nint dp[N][N] , b[N] , r[N];\n\nint32_t main(){\n   ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n   string s;\n   cin >> s;\n   int n = s.length();\n   for(int i = 0 ; i < n ; i++){\n      b[i] += s[i] - '0' , r[i] += 2 - s[i] + '0';\n      if(s[i] == '2')\n         b[i]-- , b[i + 1]++;\n      else if(s[i] == '0')\n         r[i]-- , r[i + 1]++;\n      if(i) b[i] += b[i - 1] , r[i] += r[i - 1];\n      //cout << r[i] << \" \" << b[i] << endl;\n   }\n   b[n] += b[n - 1];\n   r[n] += r[n - 1];\n   dp[0][0] = 1;\n   for(int i = 1 ; i <= 2 * n ; i++){\n      for(int j = 0 ; j <= i ; j++){\n         if(b[min(i - 1 , n)] >= j && r[min(i - 1 , n)] >= i - j){\n            dp[i][j] = dp[i - 1][j];\n            if(j > 0)\n               (dp[i][j] += dp[i - 1][j - 1]) %= mod;\n         }\n         //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n      }\n   }\n   cout << dp[2 * n][b[n]];\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 4e3 + 10, mod = 998244353;\n\nll b[N], r[N], dp[N][N];\n\nint main() {\n\tfast_cin();\n\tstring s; cin >> s;\n\tint n = s.length();\n\ts = \" \" + s;\n\tb[0] = r[0] = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tb[i] = b[i - 1];\n\t\tr[i] = r[i - 1];\n\t\tif (s[i] == '0') {\n\t\t\tr[i] += 2;\n\t\t} else if (s[i] == '1') {\n\t\t\t++r[i];\n\t\t\t++b[i];\n\t\t} else {\n\t\t\tb[i] += 2;\n\t\t}\n\t}\n\tfor (int i = n + 1; i <= 2 * n; ++i) {\n\t\tb[i] = b[i - 1];\n\t\tr[i] = r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t// cout << i << ' ' << j << ' ' << dp[i][j] << endl;\n\t\t\tif (r[i + 1] > j) {\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tdp[i + 1][j + 1] %= mod;\n\t\t\t}\n\t\t\tif (b[i + 1] > i - j) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int j = 0; j <= 2 * n; ++j) {\n\t\tans += dp[2 * n][j];\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\n#define REP(i, n) for (int i = 0; i < n; i++)\n\nll n, dp[4005][4005];  // dp[i][j]:i回操作して自由に使える青がj個になる通り\n\nint main() {\n    string s;\n    cin >> s;\n    n = s.size();\n    dp[0][0] = 1;\n    REP(i,n*2){\n        REP(j,n*2){\n            ll b=0, r=0;\n            b = j + (i<n ? s[i]-'0' : 0);  // blue\n            r = min((i+1LL)*2, n*2)-b-i;  // red\n            if(r>0){\n                dp[i+1][b] += dp[i][j];\n                dp[i+1][b] %= MOD;\n            }\n            if(b>0){\n                dp[i+1][b-1] += dp[i][j];\n                dp[i+1][b-1] %= MOD;\n            }\n        }\n    }\n    cout << dp[n*2][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=998244353,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n#define P pair<ll,ll> \n#define m_p make_pair\n\nll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x,y,sum,pos,k;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\nll dp[5000][5000];//dp[i][j]:=前からi個数並べて青がj個の時の場合の数\nll bluenum;\nll red_cou,blue_cou;\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>s;\n    rep(i,Size(s)){\n        if(s[i]=='1')bluenum++;\n        else if(s[i]=='2')bluenum+=2;\n    }\n    dp[0][0]=1;\n    rep(i,2*Size(s)){\n        if(i<Size(s)){\n            if(s[i]=='0')red_cou+=2;\n            else if(s[i]=='1')red_cou++,blue_cou++;\n            else blue_cou+=2;\n        }\n        rep(j,2*Size(s)){//青がj個\n            if((i-j)+1<=red_cou)(dp[i+1][j]+=dp[i][j])%=MOD;//赤をadd\n            if(j+1<=blue_cou)(dp[i+1][j+1]+=dp[i][j])%=MOD;\n        }\n    }\n    Cout(dp[2*Size(s)][bluenum]%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nint R[4000], B[4000];\nll dp[4000][4001];\nint main() {\n\tstring S;\n\tcin >> S;\n\tint N = S.size();\n\tfor (int i = 0; i < N; i++) {\n\t\tif (S[i] == '0') R[i] = 2;\n\t\telse if (S[i] == '1') R[i] = B[i] = 1;\n\t\telse B[i] = 2;\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tR[i] += R[i - 1];\n\t\tB[i] += B[i - 1];\n\t}\n\tif (R[0] > 0) dp[0][1] = 1;\n\tif (B[0] > 0) dp[0][0] = 1;\n\tfor (int i = 1; i < 2 * N; i++) {\n\t\tint red = R[min(i, N - 1)];\n\t\tint blue = B[min(i, N - 1)];\n\t\tint m = min(i, R[min(i - 1, N - 1)]);\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (j < red) (dp[i][j + 1] += dp[i - 1][j]) %= MOD;\n\t\t\tif (i - j < blue) (dp[i][j] += dp[i - 1][j]) %= MOD;\n\t\t}\n\t}\n\tcout << dp[2 * N - 1][R[N - 1]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 2022, mod = 998244353;\n\nint n, dp[2 * max_n][2 * max_n], cnt[2][max_n];\nstring s;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> s;\n    n = s.length();\n    for (int i = 0; i < n; ++i) {\n        cnt[0][i] = s[i] - '0';\n        cnt[1][i] = 2 - cnt[0][i];\n        if (i) {\n            cnt[0][i] += cnt[0][i - 1];\n            cnt[1][i] += cnt[1][i - 1];\n        }\n    }\n    cnt[0][n] = cnt[0][n - 1];\n    cnt[1][n] = cnt[1][n - 1];\n    dp[0][0] = 1;\n    for (int i = 0; i < 2 * n; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (!dp[i][j]) {\n                continue;\n            }\n            if (j + 1 <= cnt[0][min(i, n - 1)]) {\n                dp[i + 1][j + 1] += dp[i][j];\n                dp[i + 1][j + 1] %= mod;\n            }\n            if (i - j + 1 <= cnt[1][min(i, n - 1)]) {\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= mod;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[2 * n][cnt[0][n - 1]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ntemplate<int m>\nint modpow(int a, int b){\n\tif (!b)return 1;\n\tif (b & 1)return modpow<mod>(a, b - 1) * a % m;\n\tint memo = modpow<mod>(a, b / 2);\n\treturn memo * memo % m;\n}\ntemplate<int modulo>\nclass modInt {\n\tint value;\npublic:\n\tconstexpr modInt() : value(0) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0) : value(value) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt<mod>& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt<mod> modpow(modInt<mod> a, int b) {\n\tif (!b)return modInt<mod>(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt<mod> memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nmodInt<mod> dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <functional>\n\n\nconst int MOD = 998244353;\nconst int kN = 4000 + 5;\nint f[2][kN];\nchar s[kN];\nint n;\nint most_ball[2][kN];\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= MOD)\n    a -= MOD;\n}\n\nvoid calc_most_ball(int* most_ball, const std::function<int(char)>& func) {\n  for (int i = 0, sum = 0; i < n + n; ++ i) {\n    if (i < n) {\n      sum += func(s[i]);\n    }\n    most_ball[i + 1] = std::min(i + 1, sum);\n  }\n}\n\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  calc_most_ball(most_ball[0], [](char x) { return x - '0'; });\n  calc_most_ball(most_ball[1], [](char x) { return 2 - (x - '0'); });\n  f[0][0] = 1;\n  for (int i = 1; i <= n + n; ++ i) {\n    int cur = i & 1;\n    int pre = cur ^ 1;\n    memset(f[cur], 0, sizeof(f[cur]));\n    for (int j = 0; j <= most_ball[0][i - 1]; ++ j) if (f[pre][j]) {\n      if (j + 1 <= most_ball[0][i])\n        add(f[cur][j + 1], f[pre][j]);\n      if (i - j <= most_ball[1][i])\n        add(f[cur][j], f[pre][j]);\n    }\n  }\n  int result = 0;\n  for (int i = 0; i <= most_ball[0][n + n]; ++ i)\n    add(result, f[0][i]);\n  printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define F(i,j,n) for(register int i=j;i<=n;i++)\n#define D(i,j,n) for(register int i=j;i>=n;i--)\n#define ll long long\n#define P 998244353\nusing namespace std;\nnamespace io{\n\tconst int L=(1<<19)+1;\n\tchar ibuf[L],*iS,*iT,c;int f;\n\tchar gc(){\n\t\tif(iS==iT){\n\t\t\tiT=(iS=ibuf)+fread(ibuf,1,L,stdin);\n\t\t\treturn iS==iT?EOF:*iS++;\n\t\t}\n\t\treturn*iS++;\n\t}\n\ttemplate<class I>void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n};\nusing io::gi;\nusing io::gc;\nchar s[2010];int n,a[4010],b[4010],f[4010][4010];\nvoid add(int&a,int b){a=a+b<P?a+b:a+b-P;}\nint main(){\n\t#ifdef JHR\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tF(i,1,n)a[i]=a[i-1]+s[i]-'0',b[i]=2*i-a[i];\n\tF(i,n+1,n*2)a[i]=a[i-1],b[i]=b[i-1];\n\tF(i,1,n)a[i]-=(s[i]=='2'),b[i]-=(s[i]=='0');\n\tf[0][0]=1;\n//\tF(i,1,n*2)printf(\"%d %d\\n\",a[i],b[i]);\n\tF(i,1,n*2)F(j,max(0,i-b[i]),a[i]){\n\t\tint k=i-j;\n//\t\tprintf(\"%d %d\\n\",j,k);\n\t\tif(j)add(f[j][k],f[j-1][k]);\n\t\tif(k)add(f[j][k],f[j][k-1]); \n\t}\n\tprintf(\"%d\\n\",f[a[n+1]][b[n+1]]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#define REP(i, n) for (int i = 0; i < n; ++i)\n\nint m = 998244353;\nint dp[4010][4010];\nint cs[2010];\nsigned main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  REP(i, n) {\n    cs[i] += s[i] - '0';\n    cs[i + 1] = cs[i];\n  }\n  dp[0][0] = 1;\n  for (int k = 1; k <= 2 * n; ++k) {\n    for (int i = 0; i <= k; ++i) {\n      if (i > 0 && cs[min(k - 1, n - 1)] >= i) {\n        dp[k][i] += dp[k - 1][i - 1];\n      }\n      if (2 * (1 + min(k - 1, n - 1)) - cs[min(k - 1, n - 1)] >= k - i) {\n        dp[k][i] += dp[k - 1][i];\n      }\n      dp[k][i] %= m;\n      // cout << dp[k][i] << \" \";\n    }\n    // cout << \"\\n\";\n  }\n  cout << dp[2 * n][cs[n - 1]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define sp << \" \" <<\n#define mod 998244353\n\nconst int p=998244353;\nint n,f[10005][10005],sumr[5005];\nchar s[5005];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    scanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)sumr[i]=sumr[i-1]+'2'-s[i];\n\tf[0][0]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t\tfor(int j=max(0,i-2*min(i,n)+sumr[min(i,n)]);j<=sumr[min(i,n)];j++)\n\t\t\tf[i][j]=(f[i-1][j-1]+f[i-1][j])%p;\n\tint ans=0;\n\tfor(int i=0;i<=2*n;i++)ans=(ans+f[2*n][i])%p;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll> > P3;\nconst ll MOD = 998244353;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(2e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nll n, dp[4005][4005];\nstring s;\n\nint main() {\n    cin >> s;\n    n = s.size()*2;\n    dp[0][0] = 1;\n    REP(i,n){\n        REP(j,n){\n            ll k=0, t=0;\n            if(i<n/2){\n                t = s[i]-'0';\n                k = ((i+1)*2)-j-t-i;\n            }\n            else{\n                k = n-j-i;\n            }\n            if(k>0){\n                dp[i+1][j+t] += dp[i][j];\n                dp[i+1][j+t] %= MOD;\n            }\n            if(j+t>0){\n                dp[i+1][j-1+t] += dp[i][j];\n                dp[i+1][j-1+t] %= MOD;\n            }\n        }\n    }\n    \n    \n    cout << dp[n][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst ll INF = 1e18;\nconst int N = 2e5 + 5;\nll dp[N][5], a[N];\nint n;\n\nll solve() {\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < 5; j++) {\n            dp[i][j] = INF;\n        }\n    }\n\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (j + 1 < 5) {\n                dp[i][j + 1] = min(dp[i][j + 1], dp[i][j]);\n            }\n\n            ll w = a[i];\n\n            if (j == 1 || j == 3) {\n                w = a[i] - 2;\n                if (w > 0)\n                    w &= 1;\n                else\n                    w = -w;\n            }\n            else if (j == 2) {\n                w = a[i] - 1;\n                if (w > 0)\n                    w &= 1;\n                else\n                    w = -w;\n            }\n\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + w);\n        }\n    }\n\n    ll ans = INF;\n    for (int i = 0; i < 4; i++)\n        ans = min(ans, dp[n][i]);\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    ll ans = solve();\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_f##include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\n#define next asdnext\n#define prev asdprev\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T1, typename T2> bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ >= 0 ? val_ % MOD : (MOD - (-val_) % MOD) % MOD) {}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return mod_int(-val); }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        int a = MOD, b = val, u = 0, v = 1;\n        while (b > 0) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * v, v);\n        }\n        return mod_int(u);\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nstring S;\nint N;\nusing mint=mod_int<998244353>;\nmint dp[2200][2200];\nsigned main() {\n    cin >> S;\n    N = S.length();\n    vint rlim(2 * N), blim(2 * N);\n    rep(i, N) {\n        if (S[i] == '0') { rlim[i + 1] = rlim[i] + 2, blim[i + 1] = blim[i]; }\n        if (S[i] == '1') { rlim[i + 1] = rlim[i] + 1, blim[i + 1] = blim[i] + 1; }\n        if (S[i] == '2') { rlim[i + 1] = rlim[i], blim[i + 1] = blim[i] + 2; }\n    }\n    rep(i, N) { rlim[i + N + 1] = rlim[i + N], blim[i + N + 1] = blim[i + N]; }\n    dp[0][0] = 1;\n    reps(i, 2 * N) {\n        for (int j = 0; j <= 2 * N; j++) {\n            if (j > rlim[i] || i - j > blim[i]) { continue; }\n            dp[i][j] = dp[i - 1][j];\n            if (j != 0) { dp[i][j] += dp[i - 1][j - 1]; }\n        }\n    }\n    cout << dp[2 * N][rlim[2 * N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 100000000\n#define YJ 1145141919\n#define INF_INT_MAX 2147483647\n#define INF_LL 9223372036854775\n#define INF_LL_MAX 9223372036854775807\n#define EPS 1e-10\n#define MOD 998244353\n#define MOD9 998244353\n#define Pi acos(-1)\n#define LL long long\n#define ULL unsigned long long\n#define LD long double\n\n#define int long long\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a)  begin((a)), end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\nconst int MAX_N = 4005;\nint N;\nstring S;\nint sumR[MAX_N];\nint sumB[MAX_N];\n\nint dp[MAX_N][MAX_N];\n\nsigned main()\n{\n  cin >> S; N = S.size()*2;\n  REP(n,S.size()) {\n    sumR[n+1] = sumR[n];\n    sumB[n+1] = sumB[n];\n    if(S[n]=='0') {\n      sumR[n+1]+=2;\n    } else if(S[n]=='1') {\n      sumR[n+1]++;\n      sumB[n+1]++;\n    } else {\n      sumB[n+1]+=2;\n    }\n  }\n\n  dp[0][0] = 1;\n\n  REP(n,N) {\n    REP(red,n+1) {\n      if(dp[n][red] == 0) {\n        continue;\n      }\n\n      if(red<sumR[min((LL)S.size(),n+1)]) {\n        dp[n+1][red+1] += dp[n][red];\n        dp[n+1][red+1] %= MOD;\n      }\n\n      int blue = n-red;\n      if(blue<sumB[min((LL)S.size(),n+1)]) {\n        dp[n+1][red] += dp[n][red];\n        dp[n+1][red] %= MOD;\n      }\n    }\n  }\n\n  cout << dp[N][sumR[S.size()]] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**/\n/*\n * \tMeet me on the battlefield\n*/\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#ifndef rd\n#define endl '\\n'\n#endif\n#define deb cout<<\"Line: \"<<__LINE__<<\" plz \"\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\n#define pii pair<int,int>\n#define sz(x) ((int)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define all(con) con.begin(),con.end()\nconst int inf=1e9;\nconst int mod=998244353;\n#define dpr(x) cout<<#x<<\": \"<<x<<endl\ntypedef vector<int> vi;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint dp[4005][4005];\nint n;\nint a[4005][2];\nstring s;\nvoid solve()\n{\n\tcin>>s;\n\tint n=s.length();\n\tfor(int i=1; i<=n; i++) {\n\t\ta[i][0]=s[i-1]-'0'+a[i-1][0];\n\t\ta[i][1]='2'-s[i-1]+a[i-1][1];\n\t}\n\tfor(int i=n+1; i<=2*n; i++) {\n\t\ta[i][0]+=a[i-1][0];\n\t\ta[i][1]+=a[i-1][1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1; i<=2*n; i++) {\n\t\tfor(int j=0; j<=i; j++) {\n\t\t\tif(j>0&&a[i][0]>=j) {\n\t\t\t\tdp[i][j]+=dp[i-1][j-1];\n\t\t\t}\n\t\t\tif(a[i][1]>=i-j) {\n\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t}\n\t\t\tdp[i][j]%=mod;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0; i<=2*n; i++)\n\t\tans+=dp[2*n][i];\n\tans%=mod;\n\tcout<<ans<<endl;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::steady_clock::now().time_since_epoch().count());\n\tauto clk=clock();\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcout<<endl<<endl<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n/**/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<math.h>\n#include<algorithm>\n#include<numeric>\n#include<list>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<ULL> VULL;\n\ntypedef signed short Hitoketa;\n\nclass MYCP {\npublic:\n\n\tstatic const LL TEISUU = 1000 * 1000 * 1000 + 7;\n\n\tstatic LL DebugFlag;\n\n\t//数値を区切って文字列にする\n\tstatic string MakeString_LongLong(vector<long long> const& numbers, string const& str) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += str;\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//空白で区切る為のオーバーロード\n\tstatic string MakeString_LongLong(vector<long long> const& numbers) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += \" \";\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\n\n\t//文字列の配列を改行を挟んでまとめる\n\tstatic string MakeString_VectorString(vector<string> const& str) {\n\t\tstring result = \"\";\n\t\tfor (long long i = 0; i < str.size(); i++) {\n\t\t\tresult += str[i] + \"\\n\";\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//文字列を必要な個数だけ読み取る\n\tstatic vector<string> MyReadLineSplit(LL n) {\n\t\tvector<string> str(n);\n\t\tfor (long long i = 0; i < n; i++) {\n\t\t\tstd::cin >> str[i];\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t//数値を必要な個数だけ読み取る\n\tstatic vector<long long> ReadInts(long long number) {\n\t\tvector<long long> a(number);\n\t\tfor (int i = 0; i < number; i++) {\n\t\t\tstd::cin >> a[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t//渡された自然数が素数ならtureを返す\n\tstatic bool PrimeCheck_Int(long long number) {\n\t\tif (number < 2)return false;\n\n\t\tfor (ULL i = 2; i*i <= number; i++) {\n\t\t\tif (number%i == 0)return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t//渡された数値以下の素数表を作る\n\tstatic vector<long long> MakePrimeList(long long n) {\n\t\tvector<long long> list;\n\t\tLL i, j, p;\n\t\tbool flag;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tflag = true;\n\t\t\tfor (j = 0; j < list.size(); j++) {\n\n\t\t\t\tif (!(list[j] * list[j] <= i))break;\n\n\t\t\t\tif (i%list[j] == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)list.push_back(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\n\n\t//文字列の分割\n\tstatic vector<string> split(string const& str, char sep)\n\t{\n\t\tvector<std::string> v;        // 分割結果を格納するベクター\n\t\tauto first = str.begin();              // テキストの最初を指すイテレータ\n\t\twhile (first != str.end()) {         // テキストが残っている間ループ\n\t\t\tauto last = first;                      // 分割文字列末尾へのイテレータ\n\t\t\twhile (last != str.end() && *last != sep)       // 末尾 or セパレータ文字まで進める\n\t\t\t\tlast++;\n\t\t\tv.push_back(string(first, last));       // 分割文字を出力\n\t\t\tif (last != str.end())\n\t\t\t\tlast++;\n\t\t\tfirst = last;          // 次の処理のためにイテレータを設定\n\t\t}\n\t\treturn v;\n\t}\n\n\t//合計を求める\n\tstatic LL Sum(vector<LL> a) {\n\t\tLL i, sum = 0;\n\n\t\tfor (i = 0; i < a.size(); i++) {\n\t\t\tsum += a[i];\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t//小文字ならtrueを返す\n\tstatic bool Komoji(char a) {\n\t\tif (a >= 'a'&&a <= 'z')return true;\n\n\t\treturn false;\n\t}\n\n\t//大文字ならtrueを返す\n\tstatic bool Oomoji(char a) {\n\t\tif (a >= 'A'&&a <= 'Z')return true;\n\n\t\treturn false;\n\t}\n\n\t//切り上げの整数値割り算\n\tstatic LL KiriageWarizan(LL a, LL b) {\n\t\tLL result = a / b;\n\n\t\tif (a%b > 0)result++;\n\n\t\treturn result;\n\t}\n\n\t//最大公約数\n\tstatic LL GreatestCommonFactor(LL a, LL b) {\n\t\tLL temp;\n\t\tif (a < b) {\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\twhile (true)\n\t\t{\n\t\t\ttemp = a % b;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\tif (b == 0)break;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t//最小公倍数\n\tstatic LL LeastCommonMultiple(LL a, LL b) {\n\t\treturn (a / GreatestCommonFactor(a, b))*b;\n\t}\n\n\t//素因数分解\n\tstatic vector<VLL> PrimeFactorization(LL n) {\n\t\tVLL p_list, s_list;\n\n\t\tLL i, j, k, count;\n\n\t\tfor (i = 2; n > 1; i++) {\n\t\t\tif (i*i > n) {\n\t\t\t\tp_list.push_back(n);\n\t\t\t\ts_list.push_back(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n%i == 0) {\n\t\t\t\tcount = 0;\n\t\t\t\twhile (n%i==0)\n\t\t\t\t{\n\t\t\t\t\tn /= i;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\tp_list.push_back(i);\n\t\t\t\ts_list.push_back(count);\n\t\t\t}\n\t\t}\n\n\t\tvector<VLL> result;\n\t\tresult.push_back(p_list);\n\t\tresult.push_back(s_list);\n\n\t\treturn result;\n\t}\n\n\t//組み合わせ nCr\n\tstatic LL Combination(LL n, LL r) {\n\t\tr = min(r, n - r);\n\n\t\tVLL p(n + 1, 0);\n\n\t\tLL i, j, k, a, b, c;\n\n\t\tfor (i = 1; i <= r; i++) {\n\t\t\tauto temp = MYCP::PrimeFactorization(i);\n\n\t\t\tfor (j = 0; j < temp[0].size(); j++) {\n\t\t\t\tp[temp[0][j]] -= temp[1][j];\n\t\t\t}\n\n\t\t\ta = i + n - r;\n\t\t\ttemp = MYCP::PrimeFactorization(a);\n\n\t\t\tfor (j = 0; j < temp[0].size(); j++) {\n\t\t\t\tp[temp[0][j]] += temp[1][j];\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tLL result = 1;\n\n\t\tfor (i = 0; i < p.size(); i++) {\n\t\t\tif (p[i] > 0) {\n\n\t\t\t\tfor (j = 0; j < p[i]; j++) {\n\t\t\t\t\tresult *= i;\n\t\t\t\t\tresult %= MYCP::TEISUU;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic LL DebugPrintf(string output) {\n\n\t\tif (MYCP::DebugFlag != 0) {\n\t\t\tstd::cout << output << endl;\n\t\t}\n\n\t\treturn MYCP::DebugFlag;\n\t}\n\n\tstatic  LL DebugCin() {\n\t\tLL a;\n\n\t\tif (MYCP::DebugFlag != 0) {\n\t\t\tcin >> a;\n\t\t}\n\n\t\treturn a;\n\t}\n};\nLL MYCP::DebugFlag = 0;\n\n//累積和を求めるクラス\nclass Syakutori {\nprivate:\n\tvector<LL> list;\n\npublic:\n\n\tvoid MakeArray(vector<LL> data) {\n\t\tLL i;\n\t\tlist = data;\n\t\tlist.push_back(0);\n\t\tlist[0] = 0;\n\t\tfor (i = 1; i < list.size(); i++) {\n\t\t\tlist[i] = list[i - 1] + data[i - 1];\n\t\t}\n\n\t}\n\n\tLL Sum(LL start, LL end) {\n\t\tif (end < start) {\n\t\t\tstd::cout << \"startがendより大きいです\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (start < 0 || end >= list.size()) {\n\t\t\tstd::cout << \"範囲が異常\";\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn list[end] - list[start];\n\t}\n\n};\n\nclass Unlimited_Integer {\nprivate:\n\tHitoketa sign;\n\tvector<Hitoketa> numbers;\n\n\n\n\npublic:\n\n\tUnlimited_Integer(string value) {\n\t\tLL i, j, k;\n\n\t\tthis->sign = 1;\n\t\tk = 0;\n\n\t\tif (value[0] == '-') {\n\t\t\tsign = -1;\n\t\t\tk = 1;\n\t\t}\n\n\t\tvector<Hitoketa> temp(value.size() - k, 100);\n\n\t\tthis->numbers = temp;\n\n\t\tfor (i = value.size() - 1, j = 0; i >= k; i--, j++) {\n\t\t\tthis->numbers[j] = (Hitoketa)(value[i] - '0');\n\t\t}\n\n\t}\n\n\tUnlimited_Integer(LL value) {\n\t\tUnlimited_Integer temp(to_string(value));\n\t\tthis->Copy(temp);\n\t}\n\n\tUnlimited_Integer() {\n\t\tUnlimited_Integer temp(0);\n\t\tthis->Copy(temp);\n\t}\n\n\tstring To_string() {\n\t\tLL i, j, k;\n\n\t\tstring result = \"\";\n\n\t\tif (this->sign == -1) {\n\t\t\tresult += \"-\";\n\t\t}\n\n\t\tfor (i = this->numbers.size() - 1; i >= 0; i--) {\n\t\t\tresult += (char)(this->numbers[i] + '0');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvoid Copy(Unlimited_Integer a) {\n\t\tthis->numbers = a.numbers;\n\t\tthis->sign = a.sign;\n\t}\n\n\tvoid operator =(Unlimited_Integer const& a) {\n\t\tthis->Copy(a);\n\t}\n\n\tUnlimited_Integer operator +(Unlimited_Integer const& a) {\n\t\tUnlimited_Integer result;\n\n\t\tLL max_keta = max(a.numbers.size(), this->numbers.size()) + 1;\n\n\t\tif (true) {\n\t\t\tVLL temp(max_keta, 0);\n\n\n\t\t}\n\t}\n};\n\n\n\n//ここからメイン\nint main(void) {\n\tMYCP::DebugFlag = 0;\n\n\tLL i, j, k, n, m;\n\tLL a, b;\n\tLL x;\n\n\tcin >> k >> a >> b;\n\n\tif (k < a) {\n\t\tcout << k + 1 << endl;\n\t\treturn 0;\n\t}\n\n\tif (b - a <= 2) {\n\t\tcout << k + 1 << endl;\n\t\treturn 0;\n\t}\n\n\tk -= a;\n\tk++;\n\n\tm = k / 2;\n\n\tx = a;\n\n\tx += m * (b - a);\n\n\tx += (k % 2);\n\n\tcout << x << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\ntypedef long long ll;       typedef long double ld;  typedef pair<int,int> pii; typedef pair<ll,ll> pll;  typedef vector<int> vi;   typedef vector<ll> vl;\ntypedef vector<string> vst; typedef vector<bool> vb; typedef vector<ld> vld;    typedef vector<pii> vpii; typedef vector<pll> vpll; typedef vector<vector<int> > vvi;\nconst int INF = (0x7FFFFFFFL); const ll INFF = (0x7FFFFFFFFFFFFFFFL); const string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int MOD = 998244353;            const string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst double PI = acos(-1.0);  const double EPS = 1e-9;               const string Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nint dx[9] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };\nint dy[9] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };\n#define ln '\\n'\n#define scnaf scanf\n#define sacnf scanf\n#define sancf scanf\n#define SS(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t){cin >> t;}template<typename First, typename...Rest> void MACRO_VAR_Scan(First& first, Rest&...rest){cin >> first;MACRO_VAR_Scan(rest...);}\n#define SV(type,c,n) vector<type> c(n);for(auto& i:c)cin >> i;\n#define SVV(type,c,n,m) vector<vector<type>> c(n,vector<type>(m));for(auto& r:c)for(auto& i:r)cin >> i;\ntemplate<class T>ostream &operator<<(ostream &o,const vector<T>&j){o<<\"{\";for(int i=0;i<(int)j.size();++i)o<<(i>0?\", \":\"\")<<j[i];o<<\"}\";return o;}\ntemplate<class T,class U>ostream &operator<<(ostream &o,const pair<T,U>&j){o<<\"{\"<<j.first<<\", \"<<j.second<<\"}\";return o;}\ntemplate<class T,class U>ostream &operator<<(ostream &o,const map<T,U>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}\ntemplate<class T>ostream &operator<<(ostream &o,const set<T>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}\ninline int print(void){cout << endl; return 0;}\ntemplate<class Head> int print(Head&& head){cout << head;print();return 0;} template<class Head,class... Tail> int print(Head&& head,Tail&&... tail){cout<<head<<\" \";print(forward<Tail>(tail)...);return 0;}\ninline int debug(void){cerr << endl; return 0;}\ntemplate<class Head> int debug(Head&& head){cerr << head;debug();return 0;} template<class Head,class... Tail> int debug(Head&& head,Tail&&... tail){cerr<<head<<\" \";debug(forward<Tail>(tail)...);return 0;}\ntemplate<typename T> void PA(T &a){int ASIZE=sizeof(a)/sizeof(a[0]);for(int ii=0;ii<ASIZE;++ii){cout<<a[ii]<<\" \\n\"[ii==ASIZE-1];}}\ntemplate<typename T> void PV(T &v){int VSIZE=v.size();for(int ii=0;ii<VSIZE;++ii){cout<<v[ii]<<\" \\n\"[ii==VSIZE-1];}}\n#define ER(x)  cerr << #x << \" = \" << (x) << endl;\n#define ERV(v) {cerr << #v << \" : \";for(const auto& xxx : v){cerr << xxx << \" \";}cerr << \"\\n\";}\ninline int YES(bool x){cout<<((x)?\"YES\":\"NO\")<<endl;return 0;} inline int Yes(bool x){cout<<((x)?\"Yes\":\"No\")<<endl;return 0;}  inline int yes(bool x){cout<<((x)?\"yes\":\"no\")<<endl;return 0;}\ninline int yES(bool x){cout<<((x)?\"yES\":\"nO\")<<endl;return 0;} inline int Yay(bool x){cout<<((x)?\"Yay!\":\":(\")<<endl;return 0;}\ntemplate<typename A,typename B> void sankou(bool x,A a,B b){cout<<((x)?(a):(b))<<endl;}\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REPI(i,0,n)\n#define REPI(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REPI,_REP,)(__VA_ARGS__)\n#define _RREP(i,n) RREPI(i,n,0)\n#define RREPI(i,a,b) for(ll i=ll(a);i>=ll(b);--i)\n#define RREP(...) _overload3(__VA_ARGS__,RREPI,_RREP,)(__VA_ARGS__)\n#define EACH(e,v) for(auto& e : v)\n#define PERM(v) sort((v).begin(),(v).end());for(bool c##p=1;c##p;c##p=next_permutation((v).begin(),(v).end()))\n#define ADD(a,b) a=(a+ll(b))%MOD\n#define MUL(a,b) a=(a*ll(b))%MOD\ninline ll MOP(ll x,ll n,ll m=MOD){ll r=1;while(n>0){if(n&1)(r*=x)%=m;(x*=x)%=m;n>>=1;}return r;}\ninline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}inline ll lcm(ll a,ll b){return a*b/gcd(a,b);}inline ll POW(ll a,ll b){ll c=1ll;do{if(b&1)c*=1ll*a;a*=1ll*a;}while(b>>=1);return c;}\ntemplate<typename T,typename A,typename B> inline bool between(T x,A a,B b) {return ((a<=x)&&(x<b));}template<class T> inline T sqr(T x){return x*x;}\ntemplate<typename A,typename B> inline bool chmax(A &a,const B &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename A,typename B> inline bool chmin(A &a,const B &b){if(a>b){a=b;return 1;}return 0;}\n#define tmax(x,y,z) max((x),max((y),(z)))\n#define tmin(x,y,z) min((x),min((y),(z)))\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define SORT(v) sort((v).begin(),(v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define EXIST(s,e) (find((s).begin(),(s).end(),(e))!=(s).end())\n#define EXISTST(s,c) (((s).find(c))!=string::npos)\n#define POSL(x,val) (lower_bound(x.begin(),x.end(),val)-x.begin())\n#define POSU(x,val) (upper_bound(x.begin(),x.end(),val)-x.begin())\n#define GEQ(x,val) (int)(x).size() - POSL((x),(val))\n#define GREATER(x,val) (int)(x).size() - POSU((x),(val))\n#define LEQ(x,val) POSU((x),(val))\n#define LESS(x,val) POSL((x),(val))\n#define SZV(a) int((a).size())\n#define SZA(a) sizeof(a)/sizeof(a[0])\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MEMINF(a) memset(a,0x3f,sizeof(a))\n#define FILL(a,b) memset(a,b,sizeof(a))\n#define UNIQUE(v) sort((v).begin(),(v).end());(v).erase(unique((v).begin(),(v).end()),(v).end())\nstruct abracadabra{\n    abracadabra(){\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        cerr << fixed << setprecision(5);\n    };\n} ABRACADABRA;\n\n//---------------8<---------------8<---------------8<---------------8<---------------//\n\n/*\n・ModInt\n[備考] Mod演算のための構造体\n[使用例]\nmodint M;                   // 剰余系1e9+7における演算ができる\nModInt<mod> N;              // 剰余系modにおける演算ができる\n*/\n\ntemplate< int mod > struct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) { if ((x += p.x) >= mod) x -= mod;       return *this; }\n  ModInt &operator-=(const ModInt &p) { if ((x += mod - p.x) >= mod) x -= mod; return *this; }\n  ModInt &operator*=(const ModInt &p) { x = int(1LL * x * p.x % mod);          return *this; }\n  ModInt &operator/=(const ModInt &p) { *this *= p.inverse();                  return *this; }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    long long x; is >> x;\n    a = ModInt< mod >(x);\n    return (is);\n  }\n};\nusing modint = ModInt< MOD >;\n\n/*\n・組み合わせ, 順列, 重複組み合わせ\n  > 前計算 O(MAX_N + logMOD)\n  > クエリ O(1)\n[備考] nが負の際, C(n,r) = (-1)^r * C(-n+r-1,r)\n[使用例]\nCOMinit();                   // MAX_Nまでの前計算\ncout << nCr(n,r) << endl;    // nCr (0 <= (n,r) <= MAX_N)\ncout << nPr(n,r) << endl;    // nPr ( ... )\ncout << nHr(n,r) << endl;    // nHr ( ... )\n*/\n\nconst int MAX_N = 2020202;\nll fac[MAX_N], finv[MAX_N], inv[MAX_N];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    REP(i,2,MAX_N) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll nCr(ll n, ll r) {\n  if (r==0) return 1;\n  if (r<0) return 0;\n  if (n<0) return (r%2 ? -1 : 1) * nCr(-n+r-1,r);\n  if (n==0 || n<r) return 0;\n  return (fac[n]*((finv[n-r]*finv[r])%MOD))%MOD;\n}\nll nPr(ll n, ll r) { if (r<0 || n<r) return 0; else return (fac[n]*finv[n-r])%MOD; }\nll nHr(ll n, ll r) { if (n==0 && r==0) return 1; else return nCr(n+r-1,r); }\n\nmodint dp[2020][4040];\n\nint sumr[2020], sumb[2020];\n\nsigned main() {\n\n  COMinit();\n\n  SS(string, S);\n  int N = S.size();\n\n  REP(i, N) {\n    if (S[i] == '0')      sumr[i + 1] = sumr[i] + 2;\n    else if (S[i] == '1') sumr[i + 1] = sumr[i] + 1;\n    else                  sumr[i + 1] = sumr[i];\n    sumb[i + 1] = 2 * (i + 1) - sumr[i + 1];\n  }\n\n  dp[0][0] = 1;\n\n  REP(n, N) REP(r, N) {\n    if (sumr[n + 1] >= r + 1)     dp[n + 1][r + 1] += dp[n][r];\n    if (sumb[n + 1] >= n + 1 - r) dp[n + 1][r] += dp[n][r];\n  }\n\n  modint res = 0;\n  REP(i, N + 1) {\n    res += dp[N][i] * nCr(N, sumr[N] - i);\n  }\n  print(res);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long mod=998244353LL;\n\nint main(int argc, char const *argv[])\n{\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tint r[2*n+5],b[2*n+5];\n\tr[0]=0,b[0]=0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tr[i+1]=r[i];\n\t\tb[i+1]=b[i];\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tr[i+1]+=2;\n\t\t}\n\t\telse if (s[i]=='1')\n\t\t{\n\t\t\t++r[i+1];\n\t\t\t++b[i+1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[i+1]+=2;\n\t\t}\n\t}\n\tfor (int i = n; i < 2*n+5; ++i)\n\t{\n\t\tr[i]=r[n];b[i]=b[n];\n\t}\n\tlong long dp[2*n+5][2*n+5]={};\n\tdp[0][0]=1LL;\n\tfor (int i = 0; i < 2*n; ++i)\n\t{\n\t\tfor (int j = 0; j < 2*n; ++j)\n\t\t{\n\t\t\tif (r[i+1]>j)\n\t\t\t{\n\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\tdp[i+1][j+1]%=mod;\n\t\t\t}\n\t\t\tif (b[i+1]>i-j)\n\t\t\t{\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tdp[i+1][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[2*n][r[n]]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\n#define NDEBUG\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return ((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T>\nstd::vector<T> read_vec(const std::size_t size)\n{\n    std::vector<T> v(size);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\ntemplate<typename... Types>\nauto read_vals() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#define SHOW(...) static_cast<void>(0)\ntemplate<typename T>\nstd::vector<T> make_v(const std::size_t size, T v) { return std::vector<T>(size, v); }\ntemplate<class... Args>\nauto make_v(const std::size_t size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n\nprivate:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v < 1000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\nint main()\n{\n    using mint   = modint<998244353>;\n    const auto s = read<std::string>();\n    const auto n = s.size();\n    std::vector<mint> dp(2 * n + 1, 0);\n    dp[0] = 1;\n    std::vector<usize> red(2 * n + 1, 0), blue(2 * n + 1, 0);\n    for (usize i = 1; i <= n; i++) { red[i] = red[i - 1] + 2 - (s[i - 1] - '0'), blue[i] = blue[i - 1] + (s[i - 1] - '0'); }\n    for (usize i = n + 1; i <= 2 * n; i++) { red[i] = red[i - 1], blue[i] = blue[i - 1]; }\n    SHOW(red, blue);\n    for (usize i = 1; i <= 2 * n; i++) {\n        std::vector<mint> tmp(2 * n + 1, 0);\n        for (usize j = 0; j <= 2 * n; j++) {\n            for (usize k = 0; k < 2; k++) {\n                const usize r = j + k;\n                if (r > red[i] or r > i) { continue; }\n                const usize b = i - r;\n                if (b > blue[i] or b > i) { continue; }\n                tmp[r] += dp[j];\n            }\n        }\n        dp = tmp;\n    }\n    SHOW(dp);\n    std::cout << dp[red[n]] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n    // 二次元ベクターの基本\n    /*\n    vector<vector<int>> dp; // 宣言\n    dp.resize(n); // 1次元めの要素数決定\n    dp[i].push_back(int); // プッシュバック\n    rep(i,n){\n        sort(dp[i].begin(),dp[i].end()); // 二次元めで昇順ソート\n    }\n    */\n\n    // 整数スキャン（複数）\n    /*\n    int x;\n    scanf(\"%d\",&x);\n    int y;\n    scanf(\"%d\",&y);\n    int z;\n    scanf(\"%d\",&z);\n\n    // n個の整数のスキャン\n    /*\n    ll a[n] = {};\n    rep(i,n){\n        scanf(\"%lld\",&a[i]);\n    }\n    */\n\n    // 文字列スキャン\n    /*\n    string s;\n    cin >> s;\n    */\n\n    // n個の文字列スキャン\n    /*\n    vector<string> slist;\n    rep(i,n){\n        string s;\n        cin >> s;\n        slist.push_back(s);\n    }\n    */\n\nint main() {\n    string s;\n    cin >> s;\n\n    int si = s.size();\n    int snu[si];\n    int t[si*2];\n    int snut[si];\n    int tt[si*2];\n\n    ll two[4100] ={};\n\n    two[0] = 1;\n    srep(i,1,4050){\n        two[i]=two[i-1]*2;\n        if(two[i]>998244353){\n            two[i] %= 998244353;\n        }\n    }\n\n    rep(i,si){\n        if(s[i]=='0'){\n            snu[i]=0;\n            snut[i]=0;\n        }\n        if(s[i]=='1'){\n            snu[i]=1;\n            snut[i]=1;\n        }\n        if(s[i]=='2'){\n            snu[i]=2;\n            snut[i]=2;\n        }\n    }\n\n    // 赤なら0,青なら1\n    // 辞書順最初\n    rep(i,si*2){\n        if(i%2==0){\n            if(snu[0]==2){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)]==0){\n                snu[si-1-(i/2)]=3;\n            }else{\n                snu[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snu[0]==2||snu[0]==4){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)-1]==0&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 1;\n            }else if(snu[si-1-(i/2)-1]==1&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 2;\n            }else if(snu[si-1-(i/2)-1]==2&&snu[si-1-(i/2)]==3){\n                snu[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n\n        rep(j,i+1){\n            cout << t[j];\n        }\n        cout << endl;\n        */\n    }\n    int cm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cm[i]=t[i];\n        }else{\n            cm[i]=t[i]+cm[i-1];\n        }\n        \n    }\n    //cout << endl;\n\n    // 辞書順最後\n    rep(i,si*2){\n        if(i%2==0){\n            if(snut[0]==0){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)]!=2){\n                snut[si-1-(i/2)]=3;\n            }else{\n                snut[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snut[0]==0||snut[0]==3){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)-1]==0&&snut[si-1-(i/2)]==4){\n                snut[si-1-(i/2)-1] = 1;\n            }else if(snut[si-1-(i/2)-1]==1&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 0;\n            }else if(snut[si-1-(i/2)-1]==2&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n        rep(j,i+1){\n            cout << tt[j];\n        }\n        cout << endl;\n        */\n    }\n    int cmm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cmm[i]=tt[i];\n        }else{\n            cmm[i]=tt[i]+cmm[i-1];\n        }\n        \n    }\n\n    ll dp[si*2][si*2+1];\n    rep(i,si*2+1){\n        dp[0][i]=0;\n    }\n    if(cm[0]==0)dp[0][0]=1;\n    dp[0][1]=cmm[0];\n    srep(i,si*2){\n        rep(j,si*2+1){\n            if(j<cm[i]){\n                dp[i][j]=0;\n            }else if(j>cmm[i]){\n                dp[i][j]=0;\n            }else{\n                if(cm[i]<j&&j<cmm[i]){\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n                    if(dp[i][j]>998244353){\n                        dp[i][j] %= 998244353;\n                    }\n                }else if(cm[i]>j){\n\n                }\n            }\n        }\n    }\n    \n\n    return 0;\n}\n \n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst ll MOD = 998244353;\nconst int MAX_N = 4010;\nll dp[MAX_N][MAX_N];\n\n// n choose r\nll C[MAX_N][MAX_N];\n\nint main2() {\n  CLR(dp, 0);\n  string S; cin >> S;\n  int N = S.size();\n  vector<int> NR(N+1), NB(N+1);\n  REP(i, N) {\n    if (S[i] == '0') { NR[i+1] = NR[i] + 2; NB[i+1] = NB[i] + 0; }\n    if (S[i] == '1') { NR[i+1] = NR[i] + 1; NB[i+1] = NB[i] + 1; }\n    if (S[i] == '2') { NR[i+1] = NR[i] + 0; NB[i+1] = NB[i] + 2; }\n  }\n  // pv(ALL(NR));\n  // pv(ALL(NB));\n  dp[0][0] = 1;\n  for (int r = 0; r < N; r++) {\n    for (int b = 0; b < N; b++) {\n      int k = r + b + 1;\n      if (NR[k] >= r+1 && NB[k] >= b) { (dp[r+1][b] += dp[r][b]) %= MOD; }\n      if (NR[k] >= r && NB[k] >= b+1) { (dp[r][b+1] += dp[r][b]) %= MOD; }\n    }\n  }\n\n  ll ans = 0;\n  for (int r = 0; r <= N; r++) {\n    int b = N - r;\n    int x = NR[N] - r;\n    int y = NB[N] - b;\n    ll m = C[x+y][y];\n    ans += dp[r][b] * m % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  \n  for (int i = 0; i < MAX_N; i++) {\n    for (int j = 0; j <= i; j++) {\n      C[i][j] = (j == 0) ? 1 : (C[i-1][j-1] + C[i-1][j]);\n      if (C[i][j] >= MOD) C[i][j] -= MOD;\n    }\n  }\n\n  for (;!cin.eof();cin>>ws)\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(x) sort((x).begin(), (x).end())\n#define ALL(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define reps(i, m, n) for (ll i = m; i < n; i++)\n#define repr(i, m, n) for (ll i = m; i >= n; i--)\n#define de(x) cout << #x << \"=\" << x << endl;\ntemplate <class T> bool maxi(T &a, const T &b) {\n    if (a < b) { a = b; return 1;} return 0;}\ntemplate <class T> bool mini(T &a, const T &b) {\n    if (b < a) { a = b; return 1;} return 0;}\n#define dame {cout<< \"-1\" <<\"\\n\"; return;}\n#define INF2 1000000000000000037\n#define INF  1000000007\n#define MOD  998244353\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P  = pair<ll,ll>;\n//--GLOBAL---------------------------------\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n        if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n    static int get_mod() { return mod; }\n};\nusing mint = ModInt< MOD >;\nconst ll MAX = 202020;\nll fac[MAX], finv[MAX], inv[MAX];\nvoid cinit() { // O(nlogn)\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    reps(i, 2, MAX){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll c(int n, int k){ // 二項係数計算\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nmint dp[4020][2020];\n//--MAIN-----------------------------------\nvoid Main() {\n    string S; cin>>S;\n    ll N=S.size();\n    dp[0][0]=1;\n    rep(i,N){\n        ll x='2'-S[i];\n        rep(j,2010){\n            ll jj=j+x;\n            if(jj<=i+1) dp[i+1][jj]+=dp[i][j];\n            jj-=1;\n            if(jj>=0) dp[i+1][jj]+=dp[i][j];   \n        }\n    }\n    reps(i,N,N*2){\n        rep(j,2010){\n            ll jj=j;\n            dp[i+1][jj]+=dp[i][j];\n            jj-=1;\n            if(jj>=0) dp[i+1][jj]+=dp[i][j];   \n        }\n    }\n    mint ans=dp[N*2][0];\n    cout<< ans <<\"\\n\";\n}\n\n//--START----------------------------------\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n}\n//-----------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define pb(a) push_back\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), n)\n#define ub(v,n) upper_bound(v.begin(), v.end(), n)\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\n#define move(x) ans.push_back(x),c[x]--,now=x;\n \ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\nconst int MOD = 998244353; const int MAX = 200020;\nconst double pi = acos(-1); const double EPS = 1e-12;\nconst ll INF = 2e18;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\n\nint dp[2020][2020];\nint cumR[2020];\nint A[2020],B[2020];\nint sumR,sumB;\nvoid solve() {\n\tstring S;cin>>S;\n\tint N=S.size();\n\tCOMinit();\n\tREP(i,N){\n\t\tint num=S[i]-'0';\n\t\tA[i]+=num;\n\t\tB[i]+=2-num;\n\t\tcumR[i+1]+=cumR[i]+A[i];\n\t\tsumR+=A[i];\n\t\tsumB+=B[i];\n\t}\n\tdp[0][0]=1;\n\tREP(i,N){\n\t\tREP(r,N+1){\n\t\t\tif(r>0&&cumR[i+1]>=r)dp[i+1][r]+=dp[i][r-1];\n\t\t\tint cumB=(i+1)*2-cumR[i+1];\n\t\t\tif(cumB>=i+1-r)dp[i+1][r]+=dp[i][r];\n\t\t\t//pe(i+1);pe(r);print(dp[i+1][r]);\n\t\t}\n\t}\n\tll ans=0;\n\n\tREP(r,N+1){\n\t\tll res=mult(dp[N][r],fac[N]);\n\t\tres=mult(res,mult(finv[sumR-r],finv[sumB-(N-r)]));\n\t\tans=add(ans,res);\n\t}\n\tprint(ans);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define FOR(i,k,n) for(int(i)=(k);(i)<(n);++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v),end(v)\n#define debug(x) std::cerr<<#x<<\": \"<<x<<\"\\n\"\n#define debug2(x,y) std::cerr<<#x<<\": \"<<x<<\", \"<<#y<<\": \"<<y<<\"\\n\"\n#define debug3(x,y,z) std::cerr<<#x<<\": \"<<x<<\", \"<<#y<<\": \"<<y<<\", \"<<#z<<\": \"<<z<<\"\\n\"\n\ntypedef long long ll;\ntypedef std::vector<int> vi;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<ll> vll;\ntypedef std::vector<vll> vvll;\ntemplate<typename T> using vvec=std::vector<std::vector<T>>;\ntemplate<typename T>\nauto make_v(size_t sz){return std::vector<T>(sz);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t sz,Ts...ts){return std::vector<decltype(make_v<T>(ts...))>(sz,make_v<T>(ts...));}\ntemplate<typename T>\nvoid fill_v(T&var,const T&x){var=x;}\ntemplate<typename V,typename T>\nvoid fill_v(V&v,const T&x){for(auto&& w:v){fill_v(w,x);}}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::vector<T>&v){\n  int sz=v.size();s<<\"\\n\";rep(i,sz){s<<v[i];if(i<sz-1){s<<\"\\t\";}}s<<\"\\n\";return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::vector<std::vector<T>>&v){\n  for(auto&& w:v){s<<w;}return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::deque<T>&v){\n  int sz=v.size();s<<\"\\n\";rep(i,sz){s<<v[i];if(i<sz-1){s<<\"\\t\";}}s<<\"\\n\";return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::deque<std::deque<T>>&v){\n  for(auto&& w:v){s<<w;}return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s, const std::set<T>&v){\n  s<<\"\\n\";for(auto&& elm:v){s<<elm<<\"\\t\";}s<<\"\\n\";return s;}\n\ninline void scan(int&a){scanf(\"%d\",&a);}\ninline void scan(ll&a){scanf(\"%lld\",&a);}\ninline void scan(char&a){scanf(\" %c\",&a);}\ninline void scan(double&a){scanf(\"%lf\",&a);}\ntemplate<typename T>\ninline void scan(std::vector<T>&v){for(auto&& sv:v){scan(sv);}}\ntemplate<typename First,typename...Args>\ninline void scan(First&f,Args&...args){scan(f);scan(args...);}\ninline void scan(std::string&s){char BUF[3000000];scanf(\" %s\",BUF);s=std::string(BUF);}\ninline void print(int a){printf(\"%d\\n\",a);}\ninline void print(ll a){printf(\"%lld\\n\",a);}\ninline void print(double a){printf(\"%.12f\\n\",a);}\ninline void print(std::string s){std::cout<<s<<\"\\n\";}\n\nusing namespace std;\n\nint mod = 998244353;\n\nint main() {\n  string s;\n  scan(s);\n  int n = s.length();\n  vi red(n+1, 0);\n  vi blu(n+1, 0);\n  rep (i, n) {\n    red[i+1] = red[i];\n    blu[i+1] = blu[i];\n    if (s[i] == '0') {\n      red[i+1] += 2;\n    } else if (s[i] == '1') {\n      red[i+1] += 1;\n      blu[i+1] += 1;\n    } else {\n      blu[i+1] += 2;\n    }\n  }\n  int nr = red[n];\n  int nb = blu[n];\n\n  vvll dp(nr+2, vll(nb+2, 0));\n  dp[0][0] = 1;\n  rep (i, nr+1) {\n    rep (j, nb+1) {\n      int cr = red[min(n, i+j+1)] - i;\n      int cb = blu[min(n, i+j+1)] - j;\n      if (cr > 0) {\n        dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod;\n      }\n      if (cb > 0) {\n        dp[i][j+1] = (dp[i][j+1] + dp[i][j]) % mod;\n      }\n    }\n  }\n  debug(dp);\n  print(dp[nr][nb]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#define VI vector<int>\n#define G(size_1) vector<vector<int>>(size_1, vector<int>())\n#define SZ(x) ((int)(x).size())\n#define READ ({int t;cin >> t;t;})\n#define PII pair<int, int>\n\n#define FOR(i, _begin, _end) for (__typeof(_end) end = _end, begin = _begin,  i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n#define REP(i, end) for (__typeof(end) i = 0, _len = (end); i < (_len); i += 1)\n#define ALL(x) (x).begin(),(x).end()\n#define F first\n#define S second\n#define y0 y3487465\n#define y1 y8687969\n#define j0 j1347829\n#define j1 j234892\n#define MOD(x, m) ((((x) % (m)) + (m)) % (m))\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define EB emplace_back\n#define PB push_back\n#define fcout cout << fixed << setprecision(12)\n#define fcerr cerr << fixed << setprecision(12)\n#define print(x) cout << (x) << endl\n#define fprint(x) cout << fixed << setprecision(12) << (x) << endl\n# define BYE(a) do { cout << (a) << endl; return ; } while (false)\n\n#ifdef DEBUG\n#define ERR(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(cerr,_it, args); }\n#define DBG(x) cerr << #x << \" is \" << x << endl;\n#else\n#define DBG(x) {};\n#define ERR(args...) {};\n#endif\nvoid _err(std::ostream& cerr,istream_iterator<string> it) {cerr << endl;}\ntemplate<typename T, typename... Args>\nvoid _err(std::ostream& cerr, istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \"  \";\n    _err(cerr,++it, args...);\n}\n\nconst double pi = 2 * acos(.0);\nconst int inf = 0x3f3f3f3f;\nconst ll mod = (ll) (1e9) + 7;\n\ntemplate<class T>bool Chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool Chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\ntemplate <typename T>\nistream& operator >> (istream& is, vector<T>& V) {\n    for(auto&& ele : V)is >> ele;\n    return is;\n}\n\ntemplate <typename T>\nostream& operator << (ostream& os, const vector<T> V) {\n    os << \"[\";\n    int cnt = 0;\n    T curr;\n    if(!V.empty()){\n        for (int i = 0; i < V.size() - 1; ++i) {\n            if(V[i] == curr)cnt ++;\n            else cnt = 0;\n            if(cnt == 4)os << \"... \";\n            if(cnt < 4)\n                os << i << \":\" << V[i] << \" \";\n            curr = V[i];\n        }\n        os << V.size() - 1 << \":\" << V.back();\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator << (ostream& os, const pair<T,U> P) {\n    os << \"(\";\n    os << P.first << \",\" << P.second;\n    os << \")\";\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator << (ostream& os, const set<T,U> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate <typename K, typename H, typename P>\nostream& operator << (ostream& os, const unordered_set<K, H, P> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate <typename K, typename C>\nostream& operator << (ostream& os, const multiset<K, C> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << *it << \" \";\n            it++;\n        }\n        os << *it;\n    }\n    os << \"}\";\n    return os;\n}\n\ntemplate <typename K, typename T, typename C>\nostream& operator << (ostream& os, const map<K,T,C> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << \"(\";\n            os << it->first << \",\" << it->second;\n            os << \") \";\n            it++;\n        }\n        os << \"(\";\n        os << it->first << \",\" << it->second;\n        os << \")\";\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate <typename K, typename T, typename C>\nostream& operator << (ostream& os, const unordered_map<K,T,C> V) {\n    os << \"{\";\n    if(!V.empty()){\n        auto it = V.begin();\n        for (int i = 0; i < V.size() -1; ++i) {\n            os << \"(\";\n            os << it->first << \",\" << it->second;\n            os << \") \";\n            it++;\n        }\n        os << \"(\";\n        os << it->first << \",\" << it->second;\n        os << \")\";\n    }\n    os << \"}\\n\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator << (ostream& os, const deque<T> V) {\n    os << \"[\";\n    if (!V.empty()) {\n        for (int i = 0; i < V.size() - 1; ++i) {\n            os << V[i] << \"->\";\n        }\n        if (!V.empty())os << V.back();\n    }\n    os << \"]\\n\";\n    return os;\n};\n\ntemplate <typename T, typename Cont, typename Comp>\nostream& operator << (ostream& os, const priority_queue<T, Cont, Comp> V) {\n    priority_queue<T, Cont, Comp> _V = V;\n    os << \"[\";\n    if(!_V.empty()){\n        while(_V.size() > 1){\n            os << _V.top() << \"->\";\n            _V.pop();\n        }\n        os << _V.top();\n    }\n    os << \"]\\n\";\n    return os;\n};\n\ntemplate <class F>\nstruct y_combinator {\n    F f; // the lambda will be stored here\n\n    // a forwarding operator():\n    template <class... Args>\n    decltype(auto) operator()(Args&&... args) const {\n        // we pass ourselves to f, then the arguments.\n        // the lambda should take the first argument as `auto&& recurse` or similar.\n        return f(*this, std::forward<Args>(args)...);\n    }\n};\n// helper function that deduces the type of the lambda:\ntemplate <class F>\ny_combinator<std::decay_t<F>> recursive(F&& f){\nreturn {std::forward<F>(f)};\n}\n\nstruct hash_pair {\n    template <class T1, class T2>\n    size_t operator()(const pair<T1, T2>& p) const\n    {\n        auto hash1 = hash<T1>{}(p.first);\n        auto hash2 = hash<T2>{}(p.second);\n        return hash1 ^ hash2;\n    }\n\n};\n\ntemplate <typename T, typename U>\nstd::vector<T> multi_vector(int n, U v) {\n    return std::vector<T>(n, v);\n}\n\ntemplate <typename U, typename... Args>\nauto multi_vector(int n, Args... args) {\n    auto val = multi_vector<U>(std::forward<Args>(args)...);\n    return std::vector<decltype(val)>(n, std::move(val));\n}\ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\n    explicit operator int() const\n    {\n        return x;\n    }\n\n    explicit operator long long() const\n    {\n        return x;\n    }\n\n    explicit operator double() const\n    {\n        return x;\n    }\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 998244353;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nclass FPass {\npublic:\n\nvoid solve(std::istream& cin, std::ostream& cout, std::ostream& cerr) {\n    string s;cin >> s;\n    int N = SZ(s);\n    VI a(N);\n    REP(i,N)a[i] = s[i] - '0';\n    VI sum_l(2*N+1), sum_m(2*N+1);\n    VI t_a = a;\n    ERR(t_a)\n    REP(j,2*N){\n        if(t_a[0] > 0){t_a[0]--, sum_m[j+1] = sum_m[j] + 1;}\n        else sum_m[j+1] = sum_m[j];\n        FOR(i,1,N)if(t_a[i] > 0)t_a[i-1]++, t_a[i]--;\n//        ERR(t_a)\n    }\n    REP(i,N)t_a[i] = 2 - a[i];\n    REP(j,2*N){\n        if(t_a[0] > 0){t_a[0]--, sum_l[j+1] = sum_l[j] + 1;}\n        else sum_l[j+1] = sum_l[j];\n        FOR(i,1,N)if(t_a[i] > 0)t_a[i-1]++, t_a[i]--;\n    }\n    REP(i,2*N+1)sum_l[i] =  i - sum_l[i];\n    ERR(sum_l, sum_m)\n    auto dp = multi_vector<mint>(2*N+1, 2*N+1, 0);\n    dp[0][0] = 1;\n    REP(i,2*N)FOR(n,sum_l[i+1],sum_m[i+1]+1){\n        ERR(i,n)\n        dp[i+1][n] += dp[i][n];\n        if(n-1 >= sum_l[i])dp[i+1][n] += dp[i][n-1];\n    }\n    print(dp[2*N][sum_m[2*N]]);\n\n}\n\n\n};\n\n\n#undef int\nint main() {\n\n\tFPass solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n    std::ostringstream err;\n\tin.tie(0); ios::sync_with_stdio(0);\n    solver.solve(in, out,err);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\nint p = 998244353;\nint M = 0x7777777777777777777777777;\nint N;\nint rok[4096];\nint bok[4096];\nint dp[4096][4096];\n\nint solve(int r, int b) {\n\tif(r+b==0) {\n\t\treturn 1;\n\t}\n\tif(!dp[r][b]) {\n\t\tint ret = 0;\n\t\tif(r<=rok[r+b] && b<=bok[r+b]) {\n\t\t\tif(r) {\n\t\t\t\tret += solve(r-1, b);\n\t\t\t}\n\t\t\tif(b) {\n\t\t\t\tret += solve(r, b-1);\n\t\t\t}\n\t\t\tif(p<=ret) {\n\t\t\t\tret -= p;\n\t\t\t}\n\t\t}\n\t\tdp[r][b] = ret ^ M;\n\t}\n\treturn dp[r][b] ^ M;\n}\n\nint main() {\n\tchar S[2048];\n\tscanf(\"%s\", S);\n\tint halfN = strlen(S);\n\tN = halfN+halfN;\n\tint rsum = 0;\n\tint bsum = 0;\n\t{\n\t\tint lateR = 0;\n\t\tint lateB = 0;\n\t\tfor(int n=0; n<halfN; ++n) {\n\t\t\trok[n] = rsum;\n\t\t\tbok[n] = bsum;\n\t\t\trsum += lateR;\n\t\t\tbsum += lateB;\n\t\t\tif(S[n]=='0') {\n\t\t\t\t++rsum;\n\t\t\t\tlateR = 1;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse if(S[n]=='1') {\n\t\t\t\t++rsum;\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 1;\n\t\t\t}\n\t\t}\n\t\trsum += lateR;\n\t\tbsum += lateB;\n\t\tfor(int n=halfN; n<N+2; ++n) {\n\t\t\trok[n] = rsum;\n\t\t\tbok[n] = bsum;\n\t\t}\n\t}\n\tfor(int n=0; n<N+2; ++n) {\n\t\tprintf(\"%d %d\\n\", rok[n], bok[n]);\n\t}\n\tprintf(\"%d\\n\", solve(rsum, bsum));\n\tfor(int r=0; r<=rsum; ++r) {\n\t\tfor(int b=0; b<=bsum; ++b) {\n\t\t\tprintf(\" %d\", solve(r, b));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\npublic:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr double eps = 1e-9;\n\nvoid solve() {\n    constexpr i64 mod = 998244353;\n\n    string S;\n    cin >> S;\n\n    /*\n    set<string> st;\n    function<void(vector<vector<int>>, int, string)> dfs=[&](vector<vector<int>> v, int i, string res){\n        if(v.empty()){\n            st.insert(res);\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            dfs(v,0,res);\n            return;\n        }\n\n        rep(j,0,v[i].size()){\n            auto nv=v;\n            auto nres=res;\n            if(i==0){\n                nres+='0'+nv[i][j];\n            }else{\n                nv[i-1].emplace_back(nv[i][j]);\n            }\n            nv[i].erase(begin(nv[i])+j);\n            dfs(nv,i+1,nres);\n        }\n    };\n*/\n    const i64 N=S.size();\n\n    vector<vector<int>> v(N);\n    rep(i,0,N){\n        if(S[i]=='0'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(0);\n        }else if(S[i]=='1'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(1);\n        }else{\n            v[i].emplace_back(1);\n            v[i].emplace_back(1);\n        }\n    }\n\n    string mini,maxi;\n\n    function<void(vector<vector<int>>&, int, string&)> find_min=[&](vector<vector<int>> &v, int i, string &res){\n        if(v.empty()){\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            find_min(v,0,res);\n            return;\n        }\n\n        sort(begin(v[i]),end(v[i]));\n        if(i==0){\n            res+='0'+v[i][0];\n        }else{\n            v[i-1].emplace_back(v[i][0]);\n        }\n        v[i].erase(begin(v[i]));\n        find_min(v,i+1,res);\n    };\n\n    function<void(vector<vector<int>>&, int, string&)> find_max=[&](vector<vector<int>> &v, int i, string &res){\n        if(v.empty()){\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            find_max(v,0,res);\n            return;\n        }\n\n        sort(rbegin(v[i]),rend(v[i]));\n        if(i==0){\n            res+='0'+v[i][0];\n        }else{\n            v[i-1].emplace_back(v[i][0]);\n        }\n        v[i].erase(begin(v[i]));\n        find_max(v,i+1,res);\n    };\n\n    {\n        auto tv=v;\n        find_min(tv, 0, mini);\n    }\n    {\n        auto tv=v;\n        find_max(tv, 0, maxi);\n    }\n    print(mini);\n    print(maxi);\n\n    vector<i64> rmin(N),bmin(N);\n    {\n        i64 r=0,b=0;\n        rep(i,0,N){\n            rep(j,0,2){\n                if(v[i][j]==0) ++r;\n                else ++b;\n            }\n            rmin[i]=max(i+1-b,i64(0));\n            bmin[i]=max(i+1-r,i64(0));\n        }\n    }\n\n    print(rmin);\n    print(bmin);\n\n    function<fp<mod>(string)> count=[&](string m) {\n        constexpr i64 maxn = 2000;\n        static fp<mod> dp[maxn * 2][2][maxn + 1]; // 桁, 境界か?, 使用したbの数\n        fill_n((fp<mod> *) dp, maxn * 2 * 2 * (maxn + 1), fp<mod>(0));\n\n        i64 sumb=0;\n        rep(i,0,m.size()) if(m[i]=='1') ++sumb;\n\n        if(m[0]=='0'){\n            dp[0][1][0]=1;\n        }else{\n            dp[0][0][0]=1;\n            dp[0][1][1]=1;\n        }\n\n        rep(i,0,m.size()-1){\n            rep(j,0,2){\n                rep(k, 0, sumb + 1){\n                    if(i<N){\n                        i64 r=i+1-k;\n                        i64 b=k;\n                        if(r<rmin[i] or b<bmin[i]) continue;\n                    }\n\n                    // r=0を置く\n                    if(m[i+1]=='0'){\n                        if(j==0){\n                            // 既に境界より低い\n                            dp[i+1][0][k]+=dp[i][j][k];\n                        }else{\n                            dp[i+1][1][k]+=dp[i][j][k];\n                        }\n                    }else{\n                        dp[i+1][0][k]+=dp[i][j][k];\n                    }\n\n                    // sumb=1を置く\n                    if(k < sumb) {\n                        if (m[i + 1] == '0') {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界を超える\n                            }\n                        } else {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界にいる\n                                dp[i+1][1][k+1]+=dp[i][j][k];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[m.size()-1][0][sumb] + dp[m.size() - 1][1][sumb];\n    };\n\n    const auto ans=count(maxi)-count(mini)+1;\n\n    cout << ans << endl;\n/*\n#ifdef DEBUG\n    dfs(v,0,\"\");\n    print(st.size());\n    for(auto str:st){\n        cout << str << endl;\n    }\n#endif\n */\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 2500;\nconst int K = 19;\nint n, q;\nint mod = 998244353;\nint s1[N], s2[N], a[N], ans[N], f[N], invf[N], dp[N][N];\nvector < pair < int, int > > v;\nint binpow(int x, int y){\n    if (y == 0) return 1;\n    if (y % 2) return x * binpow(x, y - 1) % mod;\n    int z = binpow(x, y / 2);\n    return z * z % mod;\n}\nint c(int n, int k){\n    if (k < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int n = s.length();\n    dp[0][0] = 1;\n    f[0] = invf[0] = 1;\n    for (int i = 1; i <= n + n; i++) f[i] = f[i - 1] * i % mod;\n    for (int i = 1; i <= n + n; i++) invf[i] = binpow(f[i], mod - 2);\n    for (int i = 1; i <= n; i++){\n        for (int j = 0; j <= i; j++){\n            if (s[i - 1] == '0'){\n                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n            } else\n            if (s[i - 1] == '1'){\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;\n            } else\n            if (s[i - 1] == '2'){\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 2]) % mod;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= n; i++){\n        ans = (ans + dp[n][i] * c(n, i)) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a),i##formax=(b);i<i##formax;i++)\n#define FORR(i,a,b) for(int i=(a),i##formax=(b);i>=i##formax;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pcnt __builtin_popcount\n#define sz(x) (int)(x).size()\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define all(a) (a.begin()),(a.end())\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define perm(c) sort(all(c));for(bool c##p=1;c##p;c##p=next_permutation(all(c)))\n#define uniq(v) sort(all(v));v.erase(unique(all(v)), v.end());\n#define bit(n) (1LL<<(n))\n#define randInt(l,r) (uniform_int_distribution<ll>(l,r)(rnd))\n#define randDouble(l,r) (uniform_real_distribution<double>(l,r)(rnd))\n#define dout(d) printf(\"%.12f\\n\",d)\n\ntypedef long long ll;\ntypedef __int128_t lll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T>using V=vector<T>;\ntemplate<class T>using VV=V<V<T>>;\ntemplate<class T,class Y>ostream& operator<<(ostream& o,const pair<T,Y>& p){return o<<\"(\"<<p.fi<<\", \"<<p.se<<\")\";}\ntemplate<typename A,size_t N,typename T>void Fill(A (&array)[N],const T&v){fill((T*)array,(T*)(array+N),v);}\nlll gcd(lll a,lll b,lll &x,lll &y){if(!b){x=1;y=0;return a;}lll d=gcd(b,a%b,y,x);y-=a/b*x;return d;}\nll gcd(ll a,ll b){lll x=0,y=0;return gcd(a,b,x,y);}\nll modPow(lll a,lll n,ll m){if(!a)return a;lll p=1;for(;n>0;n>>=1,a=a*a%m)if(n&1)p=p*a%m;return(ll)p;}\nbool isPrime(ll n){if(n<2||n%2==0)return n==2;lll t=n-1,d=t/(t&-t);for(lll a:{2,325,9375,28178,450775,9780504,1795265022})if(a%n){for(t=d,a=modPow(a,t,n);t!=n-1&&a!=1&&a!=n-1;a=a*a%n,t=t*2%n);if(a!=n-1&&t%2==0)return 0;}return 1;}\nconst int IINF = 1e9+6;\nconst ll LINF = 1e18;\nconst int MOD = 998244353;\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nstatic random_device rd;\nstatic mt19937 rnd(rd());\n\nconst int N = 2001;\nstring s;\nint R[N], B[N], mr[N], mb[N], ar, ab, n;\nll DP[4001], DP2[4001];\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> s;\n  n = sz(s);\n  FOR(i, 0, n){\n    switch(s[i]){\n      case '0':\n        ar += R[i+1] = 2;\n        break;\n      case '1':\n        ar += R[i+1] = 1;\n        ab += B[i+1] = 1;\n        break;\n      case '2':\n        ab += B[i+1] = 2;\n        break;\n      default:\n        break;\n    }\n  }\n  FOR(i, 0, n){\n    mr[i+1] = mr[i];\n    if(R[i] == 2) mr[i+1]++;\n    if(R[i+1] >0) mr[i+1]++;\n    mb[i+1] = mb[i];\n    if(B[i] == 2) mb[i+1]++;\n    if(B[i+1] >0) mb[i+1]++;\n  }\n  DP[0] = 1;\n  FOR(i, 1, n*2+1){\n    FOR(j, 0, i+1){\n      DP2[j] = 0;\n      int r = j, b = i-j;\n      if((i<=n) ? (r<=mr[i] && b<=mb[i]) : (r<=ar && b<=ab)){\n        if(r) DP2[j] += DP[j-1];\n        if(b) DP2[j] += DP[j];\n        DP2[j] %= MOD;\n      }else{\n        DP2[j] = 0;\n      }\n    }\n    swap(DP, DP2);\n  }\n  cout << DP[ar] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nstring s;\nint r, b;\n//i回目のbの個数\nll dp[4001][4001];\nint numb[2001];\nint numr[2001];\n//i個目のbに要求されるrの個数\nint q[2001];\n//i個目のrに要求されるbの個数\nint p[2001];\nint main() {\n\tcin >> s; int n = s.length();\n\trep(i, n) {\n\t\tif (s[i] == '0')r += 2;\n\t\telse if (s[i] == '2')b += 2;\n\t\telse {\n\t\t\tr++; b++;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (s[i] == '0')numr[i]++;\n\t\telse if (s[i] == '2')numb[i]++;\n\t}\n\tint cnt = 0; int cntb = 0;\n\tint cntr = 0;\n\trep(i, n) {\n\t\tint t = cntb;\n\t\tif (s[i] == '2') {\n\t\t\tt += 2;\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tt++;\n\t\t}\n\t\telse {\n\t\t\tcnt++;\n\t\t}\n\t\tRep1(j, cntb + 1, t) {\n\t\t\tq[j-1] = max(i+1-j,0);\n\t\t}\n\t\tcntb = t;\n\t}\n\tcnt = 0;\n\trep(i, n) {\n\t\tint t = cntr;\n\n\t\tif (s[i] == '2') {\n\t\t\tcnt++;\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tt++;\n\t\t}\n\t\telse {\n\t\t\tt += 2;\n\t\t}\n\t\tRep1(j, cntr + 1, t) {\n\t\t\tp[j-1] = max(i+1-j,0);\n\t\t}\n\t\tcntr = t;\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, i + 1) {\n\t\t\t//次にbを追加\n\t\t\tint nb = j, nr = i - j;\n\t\t\tif (q[nb] <= nr) {\n\t\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= mod;\n\t\t\t}\n\t\t\tif (p[nr] <= nb) {\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[2 * n][b] << endl;\n\t/*rep(i, b) {\n\t\tcout << q[i] << endl;\n\t}*/\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size(),r = 0;\n    vector<vector<ll>> dp(2*n+1,vector<ll>(2*n+1,0));\n    dp[0][0] = 1;\n    for (int i = 0;i < 2*n;++i) {\n        if (i < n) {\n            if (s[i] == '0') r += 2;\n            else if (s[i] == '1') r += 1;\n        }\n        for (int j = 0;j <= i+1;++j) {\n            if (j && j <= r) dp[i+1][j] = dp[i][j-1];\n            if (i+1-j <= min(2*i+2,2*n)-r) dp[i+1][j] += dp[i][j];\n            dp[i+1][j] %= mod;\n        }\n    }\n    cout << dp[2*n][r] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/multiprecision/cpp_int.hpp>\n//namespace mp = boost::multiprecision;\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\ndouble equal(double a, double b) {\n    return fabs(a - b) < DBL_EPSILON;\n}\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    int a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n//const ll mod = 1e10;\n\ntypedef priority_queue<ll, vector<ll>, greater<ll> > PQ_ASK;\nconst int mod = 998244353;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n\n    friend std::istream &operator>>(std::istream &in, mint &o) {\n        ll a;\n        in >> a;\n        o = a;\n        return in;\n    }\n\n    friend std::ostream &operator<<(std::ostream &out, const mint &o) {\n        out << o.x;\n        return out;\n    }\n\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n} combination(1000000);\n\nint main() {\n    string s;\n    cin >> s;\n\n    int n = s.size();\n\n    vector<int> sumr(n + 1);\n    sumr[0] = 0;\n    rep(i, n) {\n        int num = [&] {\n            if (s[i] == '0') return 2;\n            else if (s[i] == '1') return 1;\n            return 0;\n        }();\n        sumr[i + 1] = sumr[i] + num;\n    }\n\n    vector<vector<mint>> dp(n + 1, vector<mint>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int r = 0; r <= i; r++) {\n            if (sumr[i + 1] >= r + 1) {\n                dp[i + 1][r + 1] += dp[i][r];\n            }\n            if ((i + 1) * 2 - sumr[i + 1] >= i + 1 - r) {\n                dp[i + 1][r] += dp[i][r];\n            }\n        }\n    }\n\n    mint ans = 0;\n    for (int r = 0; r <= n; r++) {\n        ans += dp[n][r] * combination(n, sumr[n] - r);\n    }\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nstring s;\nll dp[4010][4010];\nint d[2010][2];\n\nvoid solve(){\n    cin >> s;\n    n=s.length();\n    d[0][0]=0;\n    d[0][1]=0;\n    rep(i,2*n){\n        rep(j,2*n) dp[i][j]=0;\n    }\n    rep(i,n) {\n        d[i+1][0]=d[i][0]+2-(s[i]-'0');\n        d[i+1][1]=d[i][1]+(s[i]-'0');\n    }\n    Rep(i,n,2*n) {\n        d[i+1][0]=d[i][0];\n        d[i+1][1]=d[i][1];\n    }\n    rep(i,2*n){\n        //cout << d[i][0] << \" \" << d[i][1] << endl;\n    }\n    dp[0][0]=1;\n    rep(i,2*n){\n        rep(j,2*n){\n            if (d[i+1][0]>j){\n                dp[i+1][j+1]+=dp[i][j];\n                dp[i+1][j+1]%=mod;\n            }\n            if (d[i+1][1]>i-j){\n                dp[i+1][j]+=dp[i][j];\n                dp[i+1][j]%=mod;\n            }\n        }\n    }\n\n    cout << dp[2*n][d[2*n][0]]%mod << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi vector<vector<int> >\n#define vvl vector<vector<ll> >\n#define vll vector<ll>\n#define rep(c, a, b) for(ll c=a;c<b;c++)\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n#define P 998244353\n\n//-------------------------------------------------------------------\n#define N_MAX 2000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n    return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\n\nvoid init(){\n    fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n    for(int i = 2; i <= N_MAX; i++){\n        fac[i] = (fac[i-1]*i)%P;\n        inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n        finv[i] = (finv[i-1]*inv[i])%P;\n    }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n//-------------------------------------------------------------------\nint main(int argc, char const *argv[]) {\n  string s;std::cin >> s;ll n = s.size();\n  ll a = 0, b =0;\n  init();\n  re(i, n){\n    if(s[i]=='0') a+=2;\n    else if(s[i]=='1') a++, b++;\n    else b+=2;\n  }\n  vll blue_limit(n+1, 0), red_limit(n+1, 0);\n  re(i, n){\n    blue_limit[i+1] = blue_limit[i] + (s[i]=='1'?1:s[i]=='2'?2:0);\n    red_limit[i+1] = red_limit[i] + (s[i]=='1'?1:s[i]=='0'?2:0);\n  }\n  vvl dp = vv(n+1, n+1, 0, ll);\n  dp[0][0] = 1;\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<=n;j++){\n      if(j>red_limit[i]||i-j>blue_limit[i]) continue;\n      dp[i][j] = ((j==0?0:dp[i-1][j-1]) + dp[i-1][j])%P;\n    }\n  }\n  ll ans = 0;\n  for(int i=0;i<=n;i++){\n    if(dp[n][i]==0) continue;\n    ans = (ans + pp(dp[n][i], comb(a+b-n, a-i)))%P;\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cout<<a[i]<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst ll p = 998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    \n    string s;\n    cin>>s;\n    int n = s.length();\n    vector<int> blue(2*n);\n    vector<int> red(2*n);\n    for (int i = 0; i<2*n; i++)\n    {\n        if (i!=0) blue[i] = blue[i-1];\n        if (i<n)\n        {\n            if (s[i]=='1') blue[i]++;\n            if (s[i]=='2') blue[i]+=2;\n            red[i] = 2*(i+1) - blue[i];\n        }\n        else red[i] = red[i-1];\n    }\n    \n    vector<vector<int>> cnt(2*n, vector<int>(2*n+1));\n    if (blue[0]>0) cnt[0][1] = 1;\n    if (blue[0]<2) cnt[0][0] = 1;\n    for (int i = 1; i<2*n; i++)\n    {\n        for (int j = max(0, i+1-red[i]); j<=min(i+1, blue[i]); j++)\n        {\n            cnt[i][j] = cnt[i-1][j];\n            if (j>0) cnt[i][j] = add(cnt[i][j], cnt[i-1][j-1]);\n        }\n    }\n    \n    //print(blue);\n    //for (int i = 0; i<2*n; i++) print(cnt[i]);\n    \n    int total = 0;\n    for (int i = 0; i<=2*n; i++) total = add(total, cnt[2*n-1][i]);\n    cout<<total;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\n\nll dp[4020][4020];\nint main(){\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tvector<int>red,blue;\n\trep(i,n){\n\t\tif(s[i]=='0'){\n\t\t\tred.push_back(i);\n\t\t\tred.push_back(i);\n\t\t}\n\t\tif(s[i]=='1'){\n\t\t\tred.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t\tif(s[i]=='2'){\n\t\t\tblue.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tint r=red.size(),b=blue.size();\n\trep(i,r+1)rep(j,b+1){\n\t\tdp[i][j]%=mod;\n\t\tint m=i+j;\n\t\tif(j<b&&blue[j]<=m)dp[i][j+1]+=dp[i][j];\n\t\tif(i<r&&red[i]<=m)dp[i+1][j]+=dp[i][j];\n\t}\n\tcout<<dp[r][b]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<math.h>\n#include<list>\n#include<complex>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\n#define vtype(type) vector<type>\n#define vvtype(type) vector<vector<type>>\n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nll const MOD = 998244353;\nll mod_p(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn (x + y + MOD) % MOD;\n}\n\nll mod_m(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn x * y%MOD;\n}\n\nll mod_pow(ll x, ll t) {\n\tx %= MOD;\n\tif (t == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tll v = mod_pow(x, t / 2);\n\t\tif (t % 2 == 0) {\n\t\t\treturn v * v % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn v * v%MOD * x %MOD;\n\t\t}\n\t}\n}\n\nll mod_inv(ll x) {\n\treturn mod_pow(x, MOD - 2);\n}\n\nstruct edge\n{\n\tlong long to; ll name;\n\tbool operator<(const edge& rhs) const {\n\t\treturn name > rhs.name;\n\t}\n};\n\nll const MAX = 4e3 + 5;\nll dp[MAX][MAX] = {};\n\n\nint main() {\n\tstring s; cin >> s;\n\tll n = s.size();\n\tll bl = 0; ll rd = 0;\n\tdp[0][0] = 1;\n\tREP(i, 0, n * 2 - 1) {\n\t\tif (i < n) {\n\t\t\tbl += s[i] - '0';\n\t\t\trd += -(s[i] - '2');\n\t\t}\n\t\tREP(j, 0, n * 2 - 1) {\n\t\t\tif (j < bl) {\n\t\t\t\tdp[i + 1][j + 1] = mod_p(dp[i + 1][j + 1], dp[i][j]);\n\t\t\t}\n\t\t\tif (i - j < rd) {\n\t\t\t\tdp[i + 1][j] = mod_p(dp[i + 1][j], dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n * 2][bl] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include<algorithm>\n#include<cmath>\n#include<fstream>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<random>\n#include<set>\n#include<sstream>\n#include<sys/time.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\nusing ll = long long;\nint M = 998244353;\n// enum : int { M = (int)1e9 + 7 };\n// enum : ll { MLL = (ll)1e18L + 9 };\nusing namespace std;\n#ifdef LOCAL\n#include\"rprint2.hpp\"\n#else\n#define FUNC(name) template <ostream& out = cout, class... T> void name(T&&...){ }\nFUNC(prints) FUNC(printw) FUNC(printwe) FUNC(printb) FUNC(printbe) FUNC(printd) FUNC(printde) FUNC(printdu);\n#endif\ntemplate <class S, class T>\nistream& operator >> (istream& in, pair<S, T>& p){ return in >> p.first >> p.second; }\ntemplate <class T>\nistream& operator >> (istream& in, vector<T>& v){ for(auto& e : v){ in >> e; } return in; }\n//}}}\n\nll modPow(ll base, ll ex, ll m) {\n\tll ret = 1;\n\twhile(ex){\n\t\tif(ex & 1){\n\t\t\tret = ret * base % m;\n\t\t}\n\t\tex >>= 1;\n\t\tbase = base * base % m;\n\t}\n\treturn ret;\n}\nvector<ll> mFacts, mInvFacts;\nll modFact(int n){ return mFacts[n]; }\nll modInvFact(int n){ return mInvFacts[n]; }\nll modInv(int n, ll m){ return modPow(n, m - 2, m); }\nll modC(int n, int k, ll m){ return modFact(n) * modInvFact(k) % m * modInvFact(n - k) % m; }\nvoid init(int n, ll m){\n    mFacts.resize(n + 1);\n    mInvFacts.resize(n + 1);\n    mFacts[0] = 1;\n    for(int i = 1; i <= n; i++){\n        mFacts[i] = mFacts[i - 1] * i % m;\n    }\n    mInvFacts[n] = modInv(mFacts[n], m);\n    for(int i = n - 1; i >= 0; i--){\n        mInvFacts[i] = mInvFacts[i + 1] * (i + 1) % m;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init(1e6, M);\n    string s; cin >> s;\n    int n = s.size();\n    // blue\n    vector<vector<int>> dp(n + 1, vector<int>(2 * n + 10));\n    dp[0][0] = 1;\n    for(int i = 1; i <= n; i++){\n        char c = s[i - 1];\n        auto blue = [&](int i, int j){ return j; };\n        auto red =  [&](int i, int j){ return j != i * 2; };\n        for(int j = 0; j < i; j++){\n            printde(i, j, c, (blue(i - 1, j) && c == '0'), (red(i - 1, j) && c == '2'));\n            if(c == '1' || (blue(i - 1, j) && c == '0') || (red(i - 1, j) && c == '2')){\n                dp[i][j - 1 + (c - '0')] += dp[i - 1][j];\n                dp[i][j + (c - '0')] += dp[i - 1][j];\n            }else if(c == '0'){\n                dp[i][j + (c - '0')] += dp[i - 1][j];\n            }else{\n                dp[i][j - 1 + (c - '0')] += dp[i - 1][j];\n            }\n        }\n    }\n    printde(dp);\n    ll ans = 0;\n    for(int i = 0; i <= n; i++){\n        ans += dp[n][i] * modC(n, i, M);\n        ans %= M;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n  Int_ inv(){\n    return Int_(mpow(x,mod-2));\n  }\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<998244353> Int;\n\nInt mpow(Int a,lint k){\n  Int res=1;\n  while(k){\n    if(k&1) res=res*a;\n    a=a*a;\n    k>>=1;\n  }\n  return res;\n}\n//const int INF=5e8;\nchar s[2005];\nint n;\nvector<int> calc(int t){\n  vector<int> res(n*2+1),seq;\n\n  int cnt[2005][2];\n  CLR(cnt);\n  REP(i,n){\n    if(s[i]=='0') cnt[i][0]=2;\n    else if(s[i]=='2') cnt[i][1]=2;\n    else cnt[i][0]=cnt[i][1]=1;\n  }\n\n\n  REP(i,n*2){\n    REP(j,n){\n      if(cnt[j][0]+cnt[j][1]==0) continue;\n      int c=(cnt[j][t]>0?t:1-t);\n      --cnt[j][c];\n      if(j==0) seq.pb(c);\n      else{\n        ++cnt[j-1][c];\n      }\n    }\n  }\n  assert(seq.size()==n*2);\n  res[0]=n*2;\n  REP(i,n*2) res[i+1]=res[i]+(seq[i]==0?1:-1);\n  return res;\n}\n\nInt dp[4005][8005];\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  vector<int> A=calc(0),B=calc(1);\n  assert(A.back()==B.back());\n  int n2=n*2;\n\n  dp[0][n2]=1;\n  REP(i,n2) REPN(j,A[i]+1,B[i]) if(dp[i][j].x){\n    dp[i+1][j+1]+=dp[i][j];\n    dp[i+1][j-1]+=dp[i][j];\n  }\n\n  Int res=dp[n2][A.back()];\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll xx=0) : x(xx) { if (xx >= MOD || xx <= -MOD) x = xx % MOD; if (x < 0) x += MOD; }\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\n\n\n// initialization\nconst int F_MAX = int(2e3)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\n// binom mod MOD\nll binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;\n}\n\n\nint main() {\n  binom_init();\n  string s; cin >> s;\n  ll n = s.size();\n  V c(n+1);\n  rep(i, n) c[i+1] = c[i] + (s[i] - '0');\n  \n  VVm dp(n+1, Vm(n+1));\n  dp[0][0] = 1;\n\n  rep(i, n) rep(j, i+1) {\n    int x = c[i] - j;\n    if (x >= c[i+1]-(i+1) && x <= c[i+1])\n      dp[i+1][c[i+1]-x] += dp[i][j];\n    ++x;\n    if (x >= c[i+1]-(i+1) && x <= c[i+1])\n      dp[i+1][c[i+1]-x] += dp[i][j];\n  }\n\n  mint ans = 0;\n  rep(j, n+1) ans += dp[n][j] * binom(n, j);\n\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass mint{\n\tstatic const int MOD=998244353;\n\tint x;\npublic:\n\tmint():x(0){}\n\tmint(long long y){ x=y%MOD; if(x<0) x+=MOD; }\n\n\tmint& operator+=(const mint& m){ x+=m.x; if(x>=MOD) x-=MOD; return *this; }\n\tmint& operator-=(const mint& m){ x-=m.x; if(x<   0) x+=MOD; return *this; }\n\tmint& operator*=(const mint& m){ x=1LL*x*m.x%MOD; return *this; }\n\tmint& operator/=(const mint& m){ return *this*=inverse(m); }\n\tmint operator+(const mint& m)const{ return mint(*this)+=m; }\n\tmint operator-(const mint& m)const{ return mint(*this)-=m; }\n\tmint operator*(const mint& m)const{ return mint(*this)*=m; }\n\tmint operator/(const mint& m)const{ return mint(*this)/=m; }\n\tmint operator-()const{ return mint(-x); }\n\n\tfriend mint inverse(const mint& m){\n\t\tint a=m.x,b=MOD,u=1,v=0;\n\t\twhile(b>0){ int t=a/b; a-=t*b; swap(a,b); u-=t*v; swap(u,v); }\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is,mint& m){ long long t; is>>t; m=mint(t); return is; }\n\tfriend ostream& operator<<(ostream& os,const mint& m){ return os<<m.x; }\n\tint to_int()const{ return x; }\n};\n\nmint operator+(long long x,const mint& m){ return mint(x)+m; }\nmint operator-(long long x,const mint& m){ return mint(x)-m; }\nmint operator*(long long x,const mint& m){ return mint(x)*m; }\nmint operator/(long long x,const mint& m){ return mint(x)/m; }\n\nint main(){\n\tstring s; cin>>s;\n\tint n=s.length();\n\n\tvector<int> nr(n+1),nb(n+1);\n\trep(i,n){\n\t\tif     (s[i]=='0') nr[i+1]=2;\n\t\telse if(s[i]=='1') nr[i+1]=1, nb[i+1]=1;\n\t\telse               nb[i+1]=2;\n\t}\n\trep(i,n){\n\t\tnr[i+1]+=nr[i];\n\t\tnb[i+1]+=nb[i];\n\t}\n\n\tstatic mint dp[4001][4001]; // dp[r][b] = 赤を r 個, 青を b 個並べてできる列の個数\n\tdp[0][0]=1;\n\trep(i,2*n){\n\t\trep(r,i+1){\n\t\t\tint b=i-r;\n\t\t\tif(r<=nr[min(i,n)] && b<=nb[min(i,n)]){\n\t\t\t\tif(r+1<=nr[min(i+1,n)]) dp[r+1][b]+=dp[r][b];\n\t\t\t\tif(b+1<=nb[min(i+1,n)]) dp[r][b+1]+=dp[r][b];\n\t\t\t}\n\t\t}\n\t}\n\n\tmint ans=0;\n\trep(r,2*n+1) ans+=dp[r][2*n-r];\n\tcout<<ans<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 2000, md = 998244353;\nint dp[N + 1 << 1][N + 1 << 1];\nchar s[N + 1];\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\n\nstruct S{\n\tint r, b;\n\tS(){}\n\tS(int a, int y):r(a), b(y) {}\n\tS(char c){\n\t\tif (c == '0')r = 2, b = 0;\n\t\telse if (c == '1')r = 1, b = 1;\n\t\telse r = 0, b = 2;\n\t}\n\tS take(S const &o)const { return S(r - o.r, b - o.b); }\n\tvoid operator +=(S const &o){\n\t\tr += o.r;\n\t\tb += o.b;\n\t}\n\tbool ok(bool rd){\n\t\tif (rd)return r > 0;\n\t\telse return b > 0;\n\t}\n}sn[N];\n\nint main(){\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tf(i, 0, n)sn[i] = S(s[i]);\n\tf(i, 1, n)sn[i] += sn[i - 1];\n\tdp[0][0] = 1;\n\tf(i, 0, n << 1 | 1)f(j, 0, n << 1 | 1)if (dp[i][j]){\n\t\tint z = min(n - 1, i + j);\n\t\tif (sn[z].take(S(i, j)).ok(true))ad(dp[i + 1][j], dp[i][j]);\n\t\tif (sn[z].take(S(i, j)).ok(false))ad(dp[i][j + 1], dp[i][j]);\n\t}\n\tint an = 0;\n\tn <<= 1;\n\tf(i, 0, n + 1)ad(an, dp[i][n - i]);\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#define SIZE 4005\n#define MOD 998244353\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar str[SIZE];\nint dp[SIZE][SIZE];\nint cnt[SIZE][2];\n\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint n=strlen(str);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(str[i]=='0') cnt[i][0]=2;\n\t\telse if(str[i]=='2') cnt[i][1]=2;\n\t\telse cnt[i][0]=cnt[i][1]=1;\n\t\tif(i>0)\n\t\t{\n\t\t\tcnt[i][0]+=cnt[i-1][0];\n\t\t\tcnt[i][1]+=cnt[i-1][1];\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tint zero=cnt[n-1][0],one=cnt[n-1][1];\n\tfor(int i=0;i<=zero;i++)\n\t{\n\t\tfor(int j=0;j<=one;j++)\n\t\t{\n\t\t\tif(dp[i][j]==0) continue;\n\t\t\tint to=min(i+j,n-1);\n\t\t\tint z=cnt[to][0]-i,o=cnt[to][1]-j;\n\t\t\tif(z>0)\n\t\t\t{\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tif(dp[i+1][j]>=MOD) dp[i+1][j]-=MOD;\n\t\t\t}\n\t\t\tif(o>0)\n\t\t\t{\n\t\t\t\tdp[i][j+1]+=dp[i][j];\n\t\t\t\tif(dp[i][j+1]>=MOD) dp[i][j+1]-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[zero][one]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nlong long dp[4009][4009], L[4009], R[4009], mod = 998244353; string S;\n\nint main() {\n\tcin >> S; int a = 0, b = 0;\n\tfor (int i = 1; i <= S.size() * 2; i++) {\n\t\tif (i <= S.size()) {\n\t\t\tif (S[i - 1] == '0') { a += 2; b += 0; }\n\t\t\tif (S[i - 1] == '1') { a += 1; b += 1; }\n\t\t\tif (S[i - 1] == '2') { a += 0; b += 2; }\n\t\t}\n\t\tL[i] = max(0, i - b);\n\t\tR[i] = min(i, a);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2 * S.size(); i++) {\n\t\tfor (int j = L[i]; j <= R[i]; j++) {\n\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\tif (j >= 1) dp[i][j] += dp[i - 1][j - 1];\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t}\n\tcout << dp[2 * S.size()][a] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <utility>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <climits>\n#include <numeric>\n#include<stdio.h>\n#include <queue>\n#include <iomanip>\n#include <float.h>\n#include <set>\n#include<functional>\n#include <stack>\n#include <time.h>\n#include <climits>\n#include <bitset>\n#include <cmath>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n\tif (a < b) gcd(b, a);\n\tlong long  r;\n\twhile ((r = a%b)) {\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn b;\n}\nlong long lcm(long long a, long long b) {\n\treturn a / gcd(a, b) * b;\n}\nlong long modpow(long long a, long long n, long long mod) {\n\tlong long res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlong long modinv(long long a, long long mod) {\n\tlong long b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\nnamespace NTT {\n\tconst int MOD = 998244353;  // to be set appropriately\n\tconst long long PR = 3;     // to be set appropriately\n\n\tvoid trans(vector<long long> &v, bool inv = false) {\n\t\tint n = (int)v.size();\n\t\tfor (int i = 0, j = 1; j < n - 1; j++) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (i > j) swap(v[i], v[j]);\n\t\t}\n\t\tfor (int t = 2; t <= n; t <<= 1) {\n\t\t\tlong long bw = modpow(PR, (MOD - 1) / t, MOD);\n\t\t\tif (inv) bw = modinv(bw, MOD);\n\t\t\tfor (int i = 0; i < n; i += t) {\n\t\t\t\tlong long w = 1;\n\t\t\t\tfor (int j = 0; j < t / 2; ++j) {\n\t\t\t\t\tint j1 = i + j, j2 = i + j + t / 2;\n\t\t\t\t\tlong long c1 = v[j1], c2 = v[j2] * w % MOD;\n\t\t\t\t\tv[j1] = c1 + c2;\n\t\t\t\t\tv[j2] = c1 - c2 + MOD;\n\t\t\t\t\twhile (v[j1] >= MOD) v[j1] -= MOD;\n\t\t\t\t\twhile (v[j2] >= MOD) v[j2] -= MOD;\n\t\t\t\t\tw = w * bw % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inv) {\n\t\t\tlong long inv_n = modinv(n, MOD);\n\t\t\tfor (int i = 0; i < n; ++i) v[i] = v[i] * inv_n % MOD;\n\t\t}\n\t}\n\n\t// C is A*B\n\tvector<long long> mult(vector<long long> A, vector<long long> B) {\n\t\tint size_a = 1; while (size_a < A.size()) size_a <<= 1;\n\t\tint size_b = 1; while (size_b < B.size()) size_b <<= 1;\n\t\tint size_fft = max(size_a, size_b) << 1;\n\n\t\tvector<long long> cA(size_fft, 0), cB(size_fft, 0), cC(size_fft, 0);\n\t\tfor (int i = 0; i < A.size(); ++i) cA[i] = A[i];\n\t\tfor (int i = 0; i < B.size(); ++i) cB[i] = B[i];\n\n\t\ttrans(cA); trans(cB);\n\t\tfor (int i = 0; i < size_fft; ++i) cC[i] = cA[i] * cB[i] % MOD;\n\t\ttrans(cC, true);\n\n\t\tvector<long long> res((int)A.size() + (int)B.size() - 1);\n\t\tfor (int i = 0; i < res.size(); ++i) res[i] = cC[i];\n\t\treturn res;\n\t}\n};\ntypedef pair<int, int> p;\ntypedef pair<int, p> pai;\nconst int maxn = 1 << 24;\nint n2;\nlong long dat[2 * maxn - 1];\nvoid init(int n_) {\n\tn2 = 1;\n\twhile (n2 < n_)n2 *= 2;\n\tfor (int i = 0; i < 2 * n2 - 1; i++) {\n\t\tdat[i] = LLONG_MIN/2;\n\t}\n}\nvoid update(long long  k, long long a) {\n\tk += n2 - 1;\n\tdat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nlong long query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return LLONG_MIN/2;\n\tif (a <= l&&r <= b)return dat[k];\n\telse {\n\t\tlong long vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tlong long vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n}\nlong long mod = 998244353;\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tvector<int>red;\n\tvector<int>blue;\n\tlong long dp[4003][4003];\n\tint n = s.length();\n\tfor (int i = 0; i < 2003; i++) {\n\t\tfor (int j = 0; j < 2003; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <n; i++) {\n\t\tif (s[i] == '0') {\n\t\t\tred.push_back(i);\n\t\t\tred.push_back(i);\n\t\t}\n\t\tif (s[i] == '1') {\n\t\t\tred.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t\tif (s[i] == '2') {\n\t\t\tblue.push_back(i);\n\t\t\tblue.push_back(i);\n\t\t}\n\t}\n\tint r = red.size(), b = blue.size();\n\tfor (int i = 0; i <= r; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tif (j < b&&blue[j] <= i + j)dp[i][j + 1] += dp[i][j];\n\t\t\tdp[i][j + 1] %= mod;\n\t\t\tif (i < r&&red[i] <= i + j)dp[i + 1][j] = dp[i][j];\n\t\t\tdp[i + 1][j] %= mod;\n\t\t}\n\t}\n\tcout << dp[r][b];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconstexpr lint mod = 998244353;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 100010;\n\nint R[4010], B[4010];\nlint dp[4010][4010];\n\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    int curr=0, curb=0;\n    rep(i, n){\n        if(s[i]=='0') {\n            R[curr++]=i; R[curr++]=i;\n        }\n        else if(s[i]=='1'){\n            R[curr++]=i; B[curb++]=i;\n        }\n        else{\n            B[curb++]=i; B[curb++]=i;\n        }\n    }\n\n    rep(i, curr+1)rep(j, curb+1) dp[i][j]=0;\n    dp[0][0]=1;\n    rep(i, curr+1)rep(j, curb+1)if(dp[i][j]){\n                if(i<curr && R[i]<=i+j) (dp[i+1][j]+=dp[i][j])%=mod;\n                if(j<curb && B[j]<=i+j) (dp[i][j+1]+=dp[i][j])%=mod;\n            }\n    printf(\"%lld\\n\", dp[curr][curb]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\nstring s;\n\nll mod = 998244353;\nconst int N = 2010;\nll ret[2*N][2*N];\n\nvoid _main(istream &inp){\n    clr(ret);\n    inp >> s;\n    int n = s.size();\n    int max_r = 0;\n    int max_b = 0;\n    ret[0][0]=1;\n    rep(i,2*n){\n        if(i<n){\n            if(s[i]=='0'){\n                max_r += 2;\n            }\n            if(s[i]=='1'){\n                max_r += 1;\n                max_b += 1;\n            }\n            if(s[i]=='2'){\n                max_b += 2;\n            }\n        }\n        //deb(max_r);deb(max_b);debl;\n        for(int r=0; r<=2*n; r++){\n            int b = i-r;\n            if(r+1<=max_r){\n                ret[r+1][b] += ret[r][b]%mod;\n            }\n            if(b+1<=max_b){\n                ret[r][b+1] += ret[r][b]%mod;\n            }\n        }\n    }\n    rep(r,2*n+1) rep(b,2*n+1){\n        //deb(r);deb(b);deb(ret[r][b]);debl;\n    }\n    ll res = 0;\n    for(ll r=0; r<=2*n; r++){\n        ll b = 2*n-r;\n        res = res + ret[r][b]%mod;\n    }\n    cout << res << endl;\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// Doju 氏.\n// https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4218580\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repx(i, a, b) for(int i = a; i < b; i++)\nconst int MOD = 998244353;\nchar s[2002];\nint dp[2][2002], inv[2002];\n\nvoid add(int &a, int b){\n    a = a + b < MOD ? a + b : a + b - MOD;\n}\nint mul(int a, int b){\n    return 1LL * a * b % MOD;\n}\n\nint main(){\n    scanf(\"%s\", s + 1);\n    int N = strlen(s + 1);\n    inv[1] = 1;\n    repx(i, 2, N + 2) inv[i] = MOD - mul(MOD / i, inv[MOD % i]);\n    dp[0][0] = 1;\n    rep(i, N){\n        int i_ = i & 1, _i = i_ ^ 1;\n        rep(j, i + 2) dp[_i][j] = 0;\n        rep(j, i + 1){\n            int v = dp[i_][j];\n            int r = j + '2' - s[i + 1];\n            int b = i - j + s[i + 1] - '0';\n            if(r > 0) add(dp[_i][r - 1], v);\n            if(b > 0) add(dp[_i][r], v);\n        }\n    }\n    int n = N & 1, ans = 0, bin = 1;\n    rep(i, N + 1){\n        add(ans, mul(dp[n][i], bin));\n        bin = mul(bin, mul(N - i, inv[i + 1]));\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 998244353ll;\nconst ll MAXN = (ll) 4e3 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nll dp[MAXN][MAXN];\nvector<ll> r, b;\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tstr s;\n\tcin >> s;\n\tll n = s.size();\n\ts = '!' + s;\n\t//ll cn = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(s[i] == '2'){\n\t\t\tb.pb(i); b.pb(i);\n\t\t}\n\t\tif(s[i] == '0'){\n\t\t\tr.pb(i); r.pb(i);\n\t\t}\n\t\tif(s[i] == '1'){\n\t\t\tb.pb(i); r.pb(i);\n\t\t}\n\t}\n\tll cnr = r.size();\n\tll cnb = b.size();\n\tdp[0][0] = 1;\n\tll rd, bl;\n\t//debug(n);\n\tfor(int i = 1; i <= n + n;i++){\n\t\tfor(int j = 0; j <= cnr; j++){\n\t\t\trd = j;\n\t\t\tbl = i - j;\n\t\t\tif(bl > cnb){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(rd > 0){\n\t\t\t\tif(r[rd - 1] <= i) dp[i][j] += dp[i - 1][j - 1];\n\t\t\t}\n\t\t\tif(bl > 0){\n\t\t\t\tif(b[bl - 1] <= i) dp[i][j] += dp[i - 1][j];\n\t\t\t}\n\t\t\t//if(dp[i][j]) debug(i), debug(j);\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\tcout << dp[n + n][cnr];\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll solve() {\n    string S;\n    cin >> S;\n    ll N = S.size();\n    const ll MOD = 998244353;\n    auto Add = [&](ll& x, ll y) { x = ( x % MOD + y % MOD ) % MOD; };\n    vector<vector<ll>> dp1(N+2, vector<ll>(N+2)), dp2(N+1, vector<ll>(N+1));\n    dp1[0][0] = 1;\n    for ( int k = 0; k < N; k++ ) {\n        int di, dj;\n        if ( S[k] == '0' ) {\n            di = 0, dj = 2;\n        } else if ( S[k] == '1' ) {\n            di = 1, dj = 1;\n        } else {\n            di = 2, dj = 0;\n        }\n        for ( int i = 0; i <= k; i++ ) {\n            if ( i+di >= 0 && k-i+dj >= 0 ) {\n                Add(dp1[i+di][k-i+dj], dp1[i][k-i]);\n            }\n        }\n        for ( int i = 0; i <= k+1; i++ ) {\n            dp1[i][k+1-i] = 0;\n            Add(dp1[i][k+1-i], dp1[i][k+1-i+1]);\n            Add(dp1[i][k+1-i], dp1[i+1][k+1-i]);\n        }\n    }\n    for ( int i = 0; i <= N; i++ ) {\n        dp2[i][N-i] = dp1[i][N-i];\n    }\n    for ( int k = N-1; k >= 0; k-- ) {\n        for ( int i = 0; i <= k; i++ ) {\n            Add(dp2[i][k-i], dp2[i][k-i+1]);\n            Add(dp2[i][k-i], dp2[i+1][k-i]);\n        }\n    }\n    \n    ll ans = dp2[0][0];\n    return ans;\n}\n\nint main() {\n    auto ans = solve();\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 2200\n\nconst int mod=998244353;\nint n,x,y,ans,f[N][N],a[N],C[N][N];\nchar s[N];\n\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tfor (int i=1;i<=n;++i) a[i]=s[i]-'0';\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;++i){\n\t\tx+=a[i]; y+=2-a[i];\n\t\tfor (int j=0;j<=x;++j){\n\t\t\tif (j) f[i][j]=f[i-1][j-1];\n\t\t\tif (i-j<=y) f[i][j]=(f[i][j]+f[i-1][j])%mod;\n\t\t}\n\t}\n\tfor (int i=0;i<=n;++i){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tfor (int i=0;i<=n;++i)\n\t\tans=(ans+(LL)f[n][i]*C[n][x-i])%mod;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\nint N, lim[2][4001];\nvi dp;\n\nvoid gen(int ind, vi v) {\n    FOR(i,1,2*N+1) {\n        lim[ind][i] = lim[ind][i-1]; \n        F0R(j,N) if (v[j]) {\n            v[j] --;\n            if (j) v[j-1] ++;\n            else lim[ind][i] ++;\n        }\n    }\n}\n\nvoid ins(vi& v, int ind, int x) {\n    while (sz(v) <= ind) v.pb(0);\n    AD(v[ind],x);\n}\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); string s; re(s); N = sz(s);\n    vi v;\n    F0R(i,N) v.pb(s[i]-'0');\n    gen(0,v);\n    F0R(i,N) v[i] = 2-v[i];\n    gen(1,v);\n    dp = {1};\n    FOR(i,1,2*N+1) {\n        vi DP;\n        F0R(j,sz(dp)) if (dp[j]) {\n            // j, i-1-j\n            if (j+1 <= lim[0][i]) ins(DP,j+1,dp[j]);\n            if (i-j <= lim[1][i]) ins(DP,j,dp[j]);\n        }\n        swap(dp,DP);\n    }\n    // FOR(i,1,2*N+1) pr(i,lim[0][i],lim[1][i]);\n    int ans = 0; trav(i,dp) AD(ans,i);\n    pr(ans);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (2006)\nll n, dp[MAXN][MAXN*2], blue[MAXN], ans, mod=998244353, f[MAXN], inv[MAXN];\nstring A;\nint main(){\n\tFAST\n\tcin>>A;\n\tn=siz(A);\n\tFOR(i,1,n) blue[i] = A[i-1] == '0' ? 0 : (A[i-1] == '1' ? 1 : 2);\n\tdp[0][0] = 1;\n\tFOR(i,1,n){\n\t\tFOR(b,0,MAXN*2-1) {\n\t\t\tll r = i * 2 - b - (i-1);\n\t\t\tdp[i][b]=(b >= blue[i] ? dp[i-1][b-blue[i]] : 0) * ll(r>0) + (b+1 >= blue[i] ? dp[i-1][b-blue[i]+1] : 0);\n\t\t\tdp[i][b] %= mod;\n\t\t}\n\t}\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\tfor(;e; e>>=1, x*=x, x%=mod) if(e&1) sum*=x, sum%=mod;\n\t\treturn sum;\n\t};\n\tf[0]=1, inv[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod, inv[i]=qexp(f[i],mod-2);\n\tauto arrange=[&](ll r,ll b){\n\t\treturn f[r+b] * inv[r] % mod * inv[b] % mod;\n\t};\n\tFOR(b,0,n) {\n\t\tll r = n - b;\n\t\tans += dp[n][b] * arrange(r, b) % mod, ans %= mod;\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class U> inline void chmax(T & a, U const & b) { a = max<T>(a, b); }\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;\n    mint() = default;\n    mint(int64_t value_) : value(value_) {}\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline mint<MOD> operator /  (mint<MOD> other) const { return *this *  other.inv(); }\n    inline mint<MOD> operator /= (mint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (mint<MOD> other) const { return value == other.value; }\n    inline bool operator != (mint<MOD> other) const { return value != other.value; }\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\n\nconstexpr int MOD = 998244353;\n\nmint<MOD> solve(string const & s) {\n    int n = s.length();\n\n    vector<int> cnt_r(n + 1);\n    vector<int> cnt_b(n + 1);\n    REP (i, n) {\n        cnt_r[i + 1] = cnt_r[i];\n        cnt_b[i + 1] = cnt_b[i];\n        if (s[i] == '0') {\n            cnt_r[i + 1] += 2;\n        } else if (s[i] == '1') {\n            cnt_r[i + 1] += 1;\n            cnt_b[i + 1] += 1;\n        } else if (s[i] == '2') {\n            cnt_b[i + 1] += 2;\n        }\n    }\n\n    auto dp = vectors(cnt_r[n] + 1, cnt_b[n] + 1, mint<MOD>(0));\n    dp[0][0] = 1;\n    REP (r, cnt_r[n] + 1) {\n        REP (b, cnt_b[n] + 1) {\n            if (r >= 1 and r <= cnt_r[min(n, r + b)]) {\n                dp[r][b] += dp[r - 1][b];\n            }\n            if (b >= 1 and b <= cnt_b[min(n, r + b)]) {\n                dp[r][b] += dp[r][b - 1];\n            }\n        }\n    }\n    return dp[cnt_r[n]][cnt_b[n]];\n}\n\nint main() {\n    string s; cin >> s;\n    cout << solve(s).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size(),r = 0;\n    vector<vector<ll>> dp(2*n+1,vector<ll>(2*n+1,0));\n    dp[0][0] = 1;\n    for (int i = 0;i < 2*n;++i) {\n        if (i < n) {\n            if (s[i] == '0') r += 2;\n            else if (s[i] == '1') r += 1;\n        }\n        for (int j = 0;j < min(2*i+2,2*n);++j) {\n            if (j && j <= r) dp[i+1][j] = dp[i][j-1];\n            if (i+1-j <= 2*(i+1)-r) dp[i+1][j] += dp[i][j];\n            dp[i+1][j] %= mod;\n        }\n    }\n    cout << dp[2*n][r] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint gi(){\n\tint x=0,w=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')w=0,ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\nconst int N=2005;\nconst int mod=998244353;\nint n,sum[N],C[N][N],f[N][N],ans;char s[N];\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;++i)sum[i]=sum[i-1]+s[i]-'0';\n\tfor(int i=C[0][0]=1;i<=n;++i)\n\t\tfor(int j=C[i][0]=1;j<=i;++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tif(j&&j<=sum[i])f[i][j]=(f[i][j]+f[i-1][j-1])%mod;\n\t\t\tif(j<i&&i-j<=2*i-sum[i])f[i][j]=(f[i][j]+f[i-1][j])%mod;\n\t\t}\n\tfor(int i=max(0,sum[n]-n);i<=sum[n]&&i<=n;++i)ans=(ans+1ll*f[n][i]*C[n][sum[n]-i])%mod;\n\tprintf(\"%d\\n\",ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  int mb = 0, mr = 0;\n  rep (i, n) {\n    if (s[i] == '0') mr += 2;\n    else if (s[i] == '1') {mr++; mb++;}\n    else {mb += 2;}\n  }\n  vll dp(mr + 1, vl(mb + 1));\n  dp[0][0] = 1;\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (dp[i][j] == 0) continue;\n      if (i > mr || j > mb) continue;\n      int b = 0, r = 0;\n      if (s[can] == '0') {\n        r = 2;\n      }\n      else if (s[can] == '1') {\n        r = b = 1;\n      }\n      else if (s[can] == '2') {\n        b = 2;\n      }\n      int ni = i + r, nj = j + b;\n      if (ni > 0) {\n        (dp[ni - 1][nj] += dp[i][j]) %= MOD;\n      }\n      if (nj > 0) {\n        (dp[ni][nj - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (i > mr || j > mb) continue;\n      dp[i][j] = 0;\n    }\n  }\n  for (int can = n; can > 0; can--) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (dp[i][j] == 0) continue;\n      if (i > mr || j > mb) continue;\n      if (i > 0) {\n        (dp[i - 1][j] += dp[i][j]) %= MOD;\n      }\n      if (j > 0) {\n        (dp[i][j - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <functional>\n#include <set>\n#define DB cerr<<\"D\"<<endl\n#define pb push_back\nusing namespace std; using ll=long long; using ld=long double; const int INF=1e9; const ll LINF=1e18; const double dINF = 1e18; const ld ldINF = 1e18; const double EPS = 1e-6;\ntemplate<typename T, typename U, typename O> void caut(T a, U b, O c){cout<<\"(\"<<a<<\",\"<<b<<\",\"<<c<<\") \";} template<typename T, typename U> void caut(T a, U b){cout<<\"(\"<<a<<\",\"<<b<<\") \";} template<typename T> void caut(T a){cout<<\"(\"<<a<<\") \";}\nusing P=pair<double,int>;\nconst ll M = 998244353;\nvoid add(ll& x, ll y) {x+=y; x%=M;}\nvoid chmax(ll& x, ll y) {if (x<y) x=y;}\n\nint main() {\n  string s; cin>>s;\n  int n=2*s.size();\n  ll u[n+1][n+1]; fill(u[0],u[n+1],0);\n  u[0][0]=1;\n  int a=0,b=0;\n  for(int i=0;i<n;i++) {\n    if (i<n/2) {\n      if (s[i]=='0') a+=2;\n      else if (s[i]=='1') a++,b++;\n      else b+=2;\n    }\n    for(int c=0;c<=i;c++) {\n      int d=i-c; // (c,d)\n      if (u[c][d]>0) {\n        if (c+1<=a) add(u[c+1][d],u[c][d]);\n        if (d+1<=b) add(u[c][d+1],u[c][d]);\n      }\n    }\n  }\n  cout<<u[a][b]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\n\nchar in[2100];\nvector<int>R;\nvector<int>B;\nlong long dp[2100][2100];\nlong long C[2100][2100];\nint main(){\n\tscanf(\"%s\",in);\n\tint n=strlen(in);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tif(j<in[i]-'0')B.push_back(i);\n\t\t\telse R.push_back(i);\n\t\t}\n\t}\n\tC[0][0]=1;\n\tfor(int i=0;i<2050;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tC[i+1][j]=(C[i+1][j]+C[i][j])%mod;\n\t\t\tC[i+1][j+1]=(C[i+1][j+1]+C[i][j])%mod;\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\tif(j<B.size()&&B[j]<=i){\n\t\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t\t\t}\n\t\t\tif(i-j<R.size()&&R[i-j]<=i){\n\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(dp[n][i]){\n\n\t\t\tint rm=B.size()-i;\n\t\t\tret=(ret+dp[n][i]*C[n][rm])%mod;\n\t//\t\tprintf(\"%d %lld %lld\\n\",i,dp[n][i],C[n][rm]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int maxn=2e3+20;\n\nint jc[maxn],jcn[maxn],inv[maxn];\nint n;\nchar str[maxn];\n\nint dp[maxn][maxn];\n\nconst int mod=998244353;\n\ninline int C(int n,int m){ return (ll)jc[n]*jcn[m]%mod*jcn[n-m]%mod;}\n\nint main()\n{\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);\n\tjc[1]=jc[0]=jcn[0]=jcn[1]=inv[1]=1;\n\tREP(i,2,n)inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod,jc[i]=(ll)i*jc[i-1]%mod,jcn[i]=(ll)inv[i]*jcn[i-1]%mod;\n\tint sum=0;\n\tdp[0][0]=1;\n\tREP(i,1,n)\n\t{\n\t\tsum+=str[i]-'0';\n\t\tREP(j,0,i)if(j<=sum)\n\t\t{\n\t\t\tdp[i][j]=((ll)dp[i-1][j]*((2*i-(i-1)-(sum-j))>0 && j<=sum)+((j>0)?(ll)dp[i-1][j-1]*((sum-j+1)>0):0))%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tREP(i,0,n)ans=(ans+(ll)dp[n][i]*C(n,sum-i))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//using lint = long long;\n\nstruct P\n{\n    int x,y;\n\n    bool operator<(const P &a)const{\n\n        if(y!=a.y) return y>a.y;\n        return x>a.x;\n    }\n\n};\n\nvector<int> v;\n\n//bitset<4001000> b;\nint i,n,d,m,k,a,b,c;\n\nlong long o[5222][4444];\nint l[5111];\nint j[5111];\nint e;\n\n//int dx[10]={2,2,-2,-2,1,1,-1,-1},dy[10]={1,-1,1,-1,2,-2,2,-2};\n\nint dx[10]={0,1,0,-1,1,1,-1,-1},dy[10]={1,0,-1,0,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\nlong long mod=1000000009,mod2=1000000009,mod3=2017;\nlong long x,z,y;\ndouble pi=3.14159265;\nP u[1];\n//stack<int> s;\n//set<int> se;\n//priority_queue<int> q;\n//queue<int> q;\nstring r,r1;\n//char r[1];\n//2147483647\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<int,int> p;\n/*\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\nunordered_map<long long, int, custom_hash> safe_map;\n*/\n//list<int> l;\n\n\n//deque<int> de;\n//srand((int)time(NULL));\n\n\n\n\nbool as(P a,P b)\n{\n    return a.x<b.x;\n}\n\nlong long f(int n,int m)\n{\n    if(m>l[n-1]||((n-1-m)>j[n-1])) return 0;\n    if(n>r.size()*2) return 1;\n    if(o[n][m]>=0) return o[n][m];\n    return o[n][m]=(f(n+1,m)+f(n+1,m+1))%998244353;\n}\n\nint main()\n{\n    memset(o,-1,sizeof(o));\n    cin>>r;\n    for(int t=0;t<r.size();t++)\n    {\n        if(r[t]=='0') l[t+1]=l[t],j[t+1]=j[t]+2;\n        if(r[t]=='1') l[t+1]=l[t]+1,j[t+1]=j[t]+1;\n        if(r[t]=='2') l[t+1]=l[t]+2,j[t+1]=j[t];\n    }\n    for(int t=r.size();t<r.size()*2;t++)\n        l[t+1]=l[t],j[t+1]=j[t];\n    printf(\"%lld\",f(1,0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=2e3;\nconst ll MOD=998244353;\nstring S;\nll dp[MAX_N*2+1][MAX_N*2+1];\nint rcnt[MAX_N+1],bcnt[MAX_N+1];\nint main(){\n\tcin>>S;\n\tint N=(int)S.size();\n\tREP(i,N){\n\t\tint b=S[i]-'0';\n\t\tbcnt[i+1]=bcnt[i]+b;\n\t\trcnt[i+1]=rcnt[i]+2-b;\n\t}\n\tdp[rcnt[N]][bcnt[N]]=1;\n\tfor(int n=rcnt[N];n>=0;n--){\n\t\tfor(int m=bcnt[N];m>=0;m--){\n\t\t\tif(n==rcnt[N] && m==bcnt[N])continue;\n\t\t\tint rlb=upper_bound(rcnt,rcnt+N+1,n)-rcnt-1,blb=upper_bound(bcnt,bcnt+N+1,m)-bcnt-1;\n\t\t\tif(n+m>=rlb){\n\t\t\t\tdp[n][m]+=dp[n+1][m];\n\t\t\t}\n\t\t\tif(n+m>=blb){\n\t\t\t\tdp[n][m]+=dp[n][m+1];\n\t\t\t\tdp[n][m]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\npublic:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr double eps = 1e-9;\n\nvoid solve() {\n    constexpr i64 mod = 998244353;\n\n    string S;\n    cin >> S;\n\n    /*\n    set<string> st;\n    function<void(vector<vector<int>>, int, string)> dfs=[&](vector<vector<int>> v, int i, string res){\n        if(v.empty()){\n            st.insert(res);\n            return;\n        }\n\n        if(i==v.size()){\n            if(v.back().empty()){\n                v.pop_back();\n            }\n            dfs(v,0,res);\n            return;\n        }\n\n        rep(j,0,v[i].size()){\n            auto nv=v;\n            auto nres=res;\n            if(i==0){\n                nres+='0'+nv[i][j];\n            }else{\n                nv[i-1].emplace_back(nv[i][j]);\n            }\n            nv[i].erase(begin(nv[i])+j);\n            dfs(nv,i+1,nres);\n        }\n    };\n*/\n    const i64 N=S.size();\n\n    function<void(vector<vector<int>>&, int, string&)> find_min=[&](vector<vector<int>> &v, int i, string &res){\n        while(!v.empty()) {\n            if (i == v.size()) {\n                if (v.back().empty()) {\n                    v.pop_back();\n                }\n                i=0;\n                continue;\n            }\n\n            sort(begin(v[i]), end(v[i]));\n            if (i == 0) {\n                res += '0' + v[i][0];\n            } else {\n                v[i - 1].emplace_back(v[i][0]);\n            }\n            v[i].erase(begin(v[i]));\n            ++i;\n        }\n    };\n\n    function<void(vector<vector<int>>&, int, string&)> find_max=[&](vector<vector<int>> &v, int i, string &res){\n        while(!v.empty()) {\n            if (i == v.size()) {\n                if (v.back().empty()) {\n                    v.pop_back();\n                }\n                i=0;\n                continue;\n            }\n\n            sort(rbegin(v[i]), rend(v[i]));\n            if (i == 0) {\n                res += '0' + v[i][0];\n            } else {\n                v[i - 1].emplace_back(v[i][0]);\n            }\n            v[i].erase(begin(v[i]));\n            ++i;\n        }\n    };\n\n    vector<vector<int>> v(N);\n    rep(i,0,N){\n        if(S[i]=='0'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(0);\n        }else if(S[i]=='1'){\n            v[i].emplace_back(0);\n            v[i].emplace_back(1);\n        }else{\n            v[i].emplace_back(1);\n            v[i].emplace_back(1);\n        }\n    }\n\n    string mini,maxi;\n    {\n        auto tv=v;\n        find_min(tv, 0, mini);\n    }\n    {\n        auto tv=v;\n        find_max(tv, 0, maxi);\n    }\n    print(mini);\n    print(maxi);\n\n    vector<i64> rmin(N),bmin(N);\n    {\n        i64 r=0,b=0;\n        rep(i,0,N){\n            rep(j,0,2){\n                if(v[i][j]==0) ++r;\n                else ++b;\n            }\n            rmin[i]=max(i+1-b,i64(0));\n            bmin[i]=max(i+1-r,i64(0));\n        }\n    }\n\n    print(rmin);\n    print(bmin);\n\n    function<fp<mod>(string)> count=[&](string m) {\n        constexpr i64 maxn = 2000;\n        static fp<mod> dp[maxn * 2][2][2*maxn + 1]; // 桁, 境界か?, 使用したbの数\n        fill_n((fp<mod> *) dp, maxn * 2 * 2 * (2*maxn + 1), fp<mod>(0));\n\n        i64 sumb=0;\n        rep(i,0,m.size()) if(m[i]=='1') ++sumb;\n\n        if(m[0]=='0'){\n            dp[0][1][0]=1;\n        }else{\n            dp[0][0][0]=1;\n            dp[0][1][1]=1;\n        }\n\n        rep(i,0,m.size()-1){\n            rep(j,0,2){\n                rep(k, 0, sumb + 1){\n                    if(i<N){\n                        i64 r=i+1-k;\n                        i64 b=k;\n                        if(r<rmin[i] or b<bmin[i]) continue;\n                    }\n\n                    // r=0を置く\n                    if(m[i+1]=='0'){\n                        if(j==0){\n                            // 既に境界より低い\n                            dp[i+1][0][k]+=dp[i][j][k];\n                        }else{\n                            dp[i+1][1][k]+=dp[i][j][k];\n                        }\n                    }else{\n                        dp[i+1][0][k]+=dp[i][j][k];\n                    }\n\n                    // sumb=1を置く\n                    if(k < sumb) {\n                        if (m[i + 1] == '0') {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界を超える\n                            }\n                        } else {\n                            if(j==0){\n                                // 既に境界より低い\n                                dp[i+1][0][k+1]+=dp[i][j][k];\n                            }else{\n                                // 境界にいる\n                                dp[i+1][1][k+1]+=dp[i][j][k];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[m.size()-1][0][sumb] + dp[m.size() - 1][1][sumb];\n    };\n\n    const auto ans=count(maxi)-count(mini)+1;\n\n    cout << ans << endl;\n/*\n#ifdef DEBUG\n    dfs(v,0,\"\");\n    print(st.size());\n    for(auto str:st){\n        cout << str << endl;\n    }\n#endif\n */\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//const ull mod = 1e9 + 7;\nconst ll mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n// conversion number to bit\nstring num2bit(ll num, ll len){\n  string bit = \"\";\n  REP(i, len){\n    bit += char('0'+(num>>i & 1));\n  }\n  return bit;\n}\n\nll dp[4020][4020];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string S;\n    cin >> S;\n    ll N = S.size();\n\n    dp[0][0] = 1;\n\n    ll R=0, B=0;\n    REP(i, 2*N){\n    \tif(i<N){\n    \t\tif(S[i] == '0') R += 2;\n    \t\telse if(S[i] == '2') B += 2;\n    \t\telse R++, B++;\n    \t}\n\n\n    \tREP(j, i+1){\n    \t\tll idx = j;\n    \t\tll jdx = i-j;\n    \t\tif(idx<R){\n    \t\t\tdp[idx+1][jdx] += dp[idx][jdx]; \n    \t\t\tdp[idx+1][jdx] %= mod;\n    \t\t}\n    \t\tif(jdx<B){\n    \t\t\tdp[idx][jdx+1] += dp[idx][jdx]; \n    \t\t\tdp[idx][jdx+1] %= mod;\t\n    \t\t}\n    \t}\n    }\n\n    ll res = 0;\n    REP(i, 2*N+1){\n    \tres += dp[i][2*N-i];\n    \tres %= mod;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nll mod = 998244353;\nll dp[4003][4003];\nint nr[4003], nb[4003];\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tnr[i + 1] = nr[i] + 2 * (s[i] == '0') + (s[i] == '1');\n\t\tnb[i + 1] = nb[i] + 2 * (s[i] == '2') + (s[i] == '1');\n\t}\n\tfor (int i = n; i <= 2 * n; i++) {\n\t\tnr[i + 1] = nr[i];\n\t\tnb[i + 1] = nb[i];\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < 2*n; i++) {\n\t\tfor (int j = 0; j <= min(i, nr[i]); j++) {\n\t\t\tif (nr[i + 1] - j > 0) dp[i + 1][j + 1] += dp[i][j], dp[i + 1][j + 1] %= mod;\n\t\t\tif (nb[i + 1] - (i - j) > 0) dp[i + 1][j] += dp[i][j], dp[i + 1][j] %= mod;\n\t\t}\n\t}\n\tcout << dp[2 * n][nr[2 * n]] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  int mb = 0, mr = 0;\n  rep (i, n) {\n    if (s[i] == '0') mr += 2;\n    else if (s[i] == '1') {mr++; mb++;}\n    else {mb += 2;}\n  }\n  vll dp(mr + 1, vl(mb + 1));\n  dp[0][0] = 1;\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (i > mr || j > mb) continue;\n      if (dp[i][j] == 0) continue;\n      int b = 0, r = 0;\n      if (s[can] == '0') {\n        r = 2;\n      }\n      else if (s[can] == '1') {\n        r = b = 1;\n      }\n      else if (s[can] == '2') {\n        b = 2;\n      }\n      int ni = i + r, nj = j + b;\n      if (ni > 0 && ni - 1 <= mr && nj <= mb) {\n        (dp[ni - 1][nj] += dp[i][j]) %= MOD;\n      }\n      if (nj > 0 && ni <= mr && nj - 1 <= mb) {\n        (dp[ni][nj - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  for (int can = 0; can < n; can++) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (i > mr || j > mb) continue;\n      dp[i][j] = 0;\n    }\n  }\n  for (int can = n; can > 0; can--) {\n    for (int i = 0; i <= can; i++) {\n      int j = can - i;\n      if (i > mr || j > mb) continue;\n      if (dp[i][j] == 0) continue;\n      if (i > 0) {\n        (dp[i - 1][j] += dp[i][j]) %= MOD;\n      }\n      if (j > 0) {\n        (dp[i][j - 1] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(j,1,N){\n\t\t\tif(s[j] == 2){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=998244353;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n\texplicit operator uint()const{return val;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfor(string s;cin>>s&&s!=\"#\";){\n\t\tint n=s.size();\n\t\tvi rmaxs(2*n),bmaxs(2*n);\n\t\tfor(int rmax=0,bmax=0,i=0;i<n;i++){\n\t\t\trmax+=2-(s[i]-'0');\n\t\t\tbmax+=s[i]-'0';\n\t\t\trmaxs[i]=rmax;\n\t\t\tbmaxs[i]=bmax;\n\t\t}\n\t\trepi(i,n,2*n){\n\t\t\trmaxs[i]=rmaxs[i-1];\n\t\t\tbmaxs[i]=bmaxs[i-1];\n\t\t}\n\n\t\t// [個数][赤の個数]\n\t\tvector<vector<mint>> dp(2*n+1,vector<mint>(2*n+1));\n\t\tdp[0][0]=1;\n\t\trep(i,2*n) rep(j,2*n){\n\t\t\t// use red\n\t\t\t{\n\t\t\t\tint r=j+1,b=(i+1)-(j+1);\n\t\t\t\tif(r<=rmaxs[i]&&b<=bmaxs[i])\n\t\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t}\n\t\t\t// use blue\n\t\t\t{\n\t\t\t\tint r=j,b=(i+1)-j;\n\t\t\t\tif(r<=rmaxs[i]&&b<=bmaxs[i])\n\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tcout<<dp[2*n][rmaxs.back()]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mem(a,i) memset(a,i,sizeof(a))\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define per(i,a,b) for(int i=a;i>=b;--i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair<int,int> pii;\n\nconst ll mod=998244353ll;\nconst int maxn=2005;\nchar s[maxn];\nint n;\nll dp[maxn*2][maxn];\nll pre[maxn];\n\nint main() {\n    while(~scanf(\"%s\",s+1)) {\n        n=strlen(s+1);\n        mem(dp,0);\n        dp[0][0]=1;\n        pre[0]=0;\n        rep(i,1,n) {\n            ll temp=0;\n            if(s[i]=='0') temp=2;\n            else if(s[i]=='1') temp=1;\n            pre[i]=pre[i-1]+temp;\n        }\n        rep(i,1,2*n) {\n            rep(j,0,i) {\n                if(i<=n) {\n                    if((2*i-pre[i])-(i-1-j)>0&&i-1>=j) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n                    }\n                    if(pre[i]-(j-1)>0&&j>0) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                    }\n                }\n                else {\n                    if((2*n-pre[n])-(i-1-j)>0&&i-1>=j) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n                    }\n                    if(pre[n]-(j-1)>0&&j>0) {\n                        dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                    }\n                }\n                // printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n            }\n        }\n        printf(\"%lld\\n\",dp[2*n][pre[n]]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing ll = long long int;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = 998244353ll;\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll memo[2222][2222];\nbool done[2222][2222];\n\nint m,r[4444],b[4444];\n\nll solve(int i, int j){\n\tif(done[i][j]){\n\t\treturn memo[i][j];\n\t}\n\tdone[i][j] = true;\n\tif(i>r[i+j] || j>b[i+j]){\n\t\treturn memo[i][j] = 0ll;\n\t}\n\tif(i+j==m){\n\t\treturn memo[i][j] = 1ll;\n\t}\n\tmemo[i][j] = solve(i+1,j)+solve(i,j+1);\n\tmemo[i][j] %= MOD;\n\treturn memo[i][j];\n}\n\nint main(void){\n\tint n,i;\n\tstd::string s;\n\tstd::cin >> s;\n\tn = s.l_ength(); m = n*2;\n\tfor(i=0; i<n; ++i){\n\t\tr[i+1] = s[i]-'0';\n\t\tb[i+1] = '2'-s[i];\n\t}\n\tfor(i=1; i<m; ++i){\n\t\tr[i+1] += r[i];\n\t\tb[i+1] += b[i];\n\t}\n\tstd::cout << solve(0,0) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int MD=1e9+7;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,r,s;public:UnionFind(int N){p=r=vi(N);s=vi(N,1);fr(i,N){p[i]=i;}}int find(int i){return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){if(r[a=find(a)]>r[b=find(b)]){swap(a,b);}s[b]+=s[a];r[p[a]=b]+=r[a]==r[b];}bool same(int a,int b){return find(a)==find(b);}int size(int x){return s[find(x)];}};\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tconst int M=998244353;\n\tstr S;cin>>S;\n\tint N=S.size();\n\tint X=0,Y=0;\n\tfr(i,N){\n\t\tX+=S[i]-='0';\n\t\tY+=2-S[i];\n\t}\n\tvvl d(X+1,vl(Y+1));\n\td[0][0]=1;\n\tint x=0,y=0;\n\tfr(i,2*N){\n\t\tif(i<N){\n\t\t\tx+=S[i];\n\t\t\ty+=2-S[i];\n\t\t}\n\t\tfoor(j,0,i){\n\t\t\tif(j<x&&i-j<=y){\n\t\t\t\t(d[j+1][i-j]+=d[j][i-j])%=M;\n\t\t\t}\n\t\t\tif(j<=x&&i-j<y){\n\t\t\t\t(d[j][i-j+1]+=d[j][i-j])%=M;\n\t\t\t}\n\t\t}\n\t}\n\tprint(d[X][Y]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define FOR(i,k,n) for(int(i)=(k);(i)<(n);++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v),end(v)\n#define debug(x) std::cerr<<#x<<\": \"<<x<<\"\\n\"\n#define debug2(x,y) std::cerr<<#x<<\": \"<<x<<\", \"<<#y<<\": \"<<y<<\"\\n\"\n#define debug3(x,y,z) std::cerr<<#x<<\": \"<<x<<\", \"<<#y<<\": \"<<y<<\", \"<<#z<<\": \"<<z<<\"\\n\"\n\ntypedef long long ll;\ntypedef std::vector<int> vi;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<ll> vll;\ntypedef std::vector<vll> vvll;\ntemplate<typename T> using vvec=std::vector<std::vector<T>>;\ntemplate<typename T>\nauto make_v(size_t sz){return std::vector<T>(sz);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t sz,Ts...ts){return std::vector<decltype(make_v<T>(ts...))>(sz,make_v<T>(ts...));}\ntemplate<typename T>\nvoid fill_v(T&var,const T&x){var=x;}\ntemplate<typename V,typename T>\nvoid fill_v(V&v,const T&x){for(auto&& w:v){fill_v(w,x);}}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::vector<T>&v){\n  int sz=v.size();s<<\"\\n\";rep(i,sz){s<<v[i];if(i<sz-1){s<<\"\\t\";}}s<<\"\\n\";return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::vector<std::vector<T>>&v){\n  for(auto&& w:v){s<<w;}return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::deque<T>&v){\n  int sz=v.size();s<<\"\\n\";rep(i,sz){s<<v[i];if(i<sz-1){s<<\"\\t\";}}s<<\"\\n\";return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::deque<std::deque<T>>&v){\n  for(auto&& w:v){s<<w;}return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s, const std::set<T>&v){\n  s<<\"\\n\";for(auto&& elm:v){s<<elm<<\"\\t\";}s<<\"\\n\";return s;}\n\ninline void scan(int&a){scanf(\"%d\",&a);}\ninline void scan(ll&a){scanf(\"%lld\",&a);}\ninline void scan(char&a){scanf(\" %c\",&a);}\ninline void scan(double&a){scanf(\"%lf\",&a);}\ntemplate<typename T>\ninline void scan(std::vector<T>&v){for(auto&& sv:v){scan(sv);}}\ntemplate<typename First,typename...Args>\ninline void scan(First&f,Args&...args){scan(f);scan(args...);}\ninline void scan(std::string&s){char BUF[3000000];scanf(\" %s\",BUF);s=std::string(BUF);}\ninline void print(int a){printf(\"%d\\n\",a);}\ninline void print(ll a){printf(\"%lld\\n\",a);}\ninline void print(double a){printf(\"%.12f\\n\",a);}\ninline void print(std::string s){std::cout<<s<<\"\\n\";}\n\nusing namespace std;\n\nint mod = 998244353;\n\nint main() {\n  string s;\n  scan(s);\n  int n = s.length();\n  vi red(n+1, 0);\n  vi blu(n+1, 0);\n  rep (i, n) {\n    red[i+1] = red[i];\n    blu[i+1] = blu[i];\n    if (s[i] == '0') {\n      red[i+1] += 2;\n    } else if (s[i] == '1') {\n      red[i+1] += 1;\n      blu[i+1] += 1;\n    } else {\n      blu[i+1] += 2;\n    }\n  }\n  int nr = red[n];\n  int nb = blu[n];\n\n  vvll dp(nr+2, vll(nb+2, 0));\n  dp[0][0] = 1;\n  rep (i, nr+1) {\n    rep (j, nb+1) {\n      int cr = red[min(n, i+j+1)] - i;\n      int cb = blu[min(n, i+j+1)] - j;\n      if (cr > 0) {\n        dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod;\n      }\n      if (cb > 0) {\n        dp[i][j+1] = (dp[i][j+1] + dp[i][j]) % mod;\n      }\n    }\n  }\n  print(dp[nr][nb]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 998244353;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  string s; cin >> s;\n  int n = SZ(s);\n  vi r(2*n), b(2*n);\n  if(s[0] == '0') {\n    r[0] = 2;\n  } else if(s[0] == '1') {\n    r[0] = 1;\n    b[0] = 1;\n  } else {\n    b[0] = 2;\n  }\n  for(int i=1;i<n;++i) {\n    if(s[i] == '0') {\n      r[i] = r[i-1] + 2;\n      b[i] = b[i-1];\n    } else if(s[i] == '1') {\n      r[i] = r[i-1] + 1;\n      b[i] = b[i-1] + 1;\n    } else if(s[i] == '2') {\n      r[i] = r[i-1];\n      b[i] = b[i-1] + 2;\n    }\n  }\n\n  for(int i=n;i<2*n;++i) {\n    r[i] = r[n-1];\n    b[i] = b[n-1];\n  }\n  \n\n  vvll dp(2*n+1, vll(2*n+1, 0));\n  dp[0][0] = 1;\n\n  for(int i=1;i<=2*n;++i) {\n    for(int k=0;k<=i;++k) {\n      int j = i-k;\n      //cout << j << \":\" << k << endl;\n      if(j != 0 && r[i-1] - (j-1) > 0) {\n        dp[j][k] += dp[j-1][k];\n        dp[j][k] %= MOD;\n      }\n      if(k != 0 && b[i-1] - (k-1) > 0) {\n        dp[j][k] += dp[j][k-1];\n        dp[j][k] %= MOD;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=0;i<=2*n;++i) {\n    res += dp[i][2*n-i];\n    res %= MOD;\n  }\n  cout << res << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt dp[2160][2160];\nInt res;\nInt n;\nstring str;\nInt fact[1080000];\nInt revfact[1080000];\nInt rev[1080000];\n\nvoid init(){\n  Int m = MOD;\n  fact[0] = 1;\n  revfact[0] = 1;\n  rev[0] = 0;\n  rev[1] = 1;\n  for(int i = 1;i < 1080000;i++){\n    fact[i] = fact[i-1] * i % m;\n    if(i>1)rev[i] = MOD / i * (MOD-rev[MOD % i]) % MOD;\n    revfact[i] = revfact[i-1] * rev[i] % MOD;\n  }\n}\n\nclass Initter{\npublic:\n  Initter(){\n    init();\n  }\n};\nInitter initter;\nInt nCk(Int n, Int k){\n  if(n < k)return 0;\n  if(k < 0)return 0;\n  return fact[n] * revfact[n-k] % MOD * revfact[k] % MOD;\n}\n\nInt cntr, cntb;\n\nint main(){\n  dp[0][0] = 1;\n  cin >> str;\n  n= str.size();\n  for(int i = 1;i <= n;i++){\n    char s = str[i-1];\n    s -= '0';\n    cntr += 2 - s;\n    cntb += s;\n    for(int j = 0;j <= n;j++){\n      if(cntr - j > 0){\n\tdp[i][j+1] += dp[i-1][j];\n\tdp[i][j+1]%=MOD;\n      }\n      if(cntb - (i-j-1) > 0){\n\tdp[i][j] += dp[i-1][j];\n\tdp[i][j] %= MOD;\n      }\n    }\n  }\n  for(int j = 0;j <= n;j++){\n    //    cout << dp[n][j] << endl;\n    res += dp[n][j] *nCk(n, cntr-j) %MOD;\n    res %= MOD;\n  }cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nstring S;\n\nint memo[5000][5000];\nbool visited[5000][5000];\n\nlong long f(int p, int x, int y) {\n\tif (p > 0 && x == 0 && y == 0) return 1;\n\tif (visited[p][x]) return memo[p][x];\n\tvisited[p][x] = true;\n\tint xx = x;\n\tif (p < (int)S.length()) {\n\t\tx += S[p]-'0';\n\t\ty += 2 - (S[p]-'0');\n\t}\n\tauto r = 0;\n\tif (x > 0) r += f(p+1, x-1, y);\n\tif (y > 0) r += f(p+1, x, y-1);\n\t//cerr << p << \" \" << x << \" \" << y << \" \" << r % mod << endl;\n\treturn memo[p][xx] = r % mod;\n}\n\nint main() {\n\tcin >> S;\n\tcout << f(0,0,0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nchar s[2002];\nint dp[2][2002], inv[2002];\n\nvoid add(int &a, int b){ a = a + b < MOD ? a + b : a + b - MOD; }\nint mul(int a, int b){ return 1LL * a * b % MOD; }\n\nint main(){\n  scanf(\"%s\", s + 1); int N = strlen(s + 1);\n\n  inv[1] = 1;\n  for(int i = 2; i <= N + 1; i++) inv[i] = MOD - mul(MOD / i, inv[MOD % i]);\n\n  dp[0][0] = 1;\n\n  for(int i = 0; i < N; i++){\n    int i_ = i & 1, _i = i_ ^ 1;\n    for(int j = 0; j <= i + 1; j++) dp[_i][j] = 0;\n\n    for(int j = 0; j <= i; j++){\n      int v = dp[i_][j];\n\n      int r = j + '2' - s[i + 1];\n      int b = i - j + s[i + 1] - '0';\n\n      if(r > 0) add(dp[_i][r - 1], v);\n      if(b > 0) add(dp[_i][r], v);\n    }\n  }\n\n  int n = N & 1, ans = 0, bin = 1;\n\n  for(int i = 0; i <= N; i++){\n    add(ans, mul(dp[n][i], bin));\n    bin = mul(bin, mul(N - i, inv[i + 1]));\n  }\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\ntypedef long long ll;\nconst int N = 200010;\nconst int mod = 998244353;\nconst int oo = 1e9;\nconst int base = 27;\ntypedef pair<int,int> pii;\n\n\nint dp[4010][4010],f1[4001],f2[4001];\n\nstring s;\n\nll adl(ll a , ll b){\n  return (1ll*a+b)%mod;\n}\nint calc(int r , int b){\n  if(r+b == 2*s.size())return 1;\n  int &ret = dp[r][b];\n  if(ret != -1)return ret;\n  ret = 0;\n  int idx = r+b;\n  if(idx >= s.size()){\n    if(b != f1[s.size()-1])ret = adl(ret,calc(r,b+1));\n    if(r != f2[s.size()-1])ret = adl(ret,calc(r+1,b));\n  }else{\n    if(b != f1[idx])ret = adl(ret,calc(r,b+1));\n    if(r != f2[idx])ret = adl(ret,calc(r+1,b));\n  }\n  return ret;\n}\nint main() {\n  memset(dp,-1,sizeof dp);\n  cin >> s;\n  for (int i = 0; i < s.size(); ++i){\n    if(s[i] == '1')f1[i]++,f2[i]++;\n    if(s[i] == '2')f2[i]+=2;\n    if(s[i] == '0')f1[i]+=2;\n    if(i)\n      f1[i] += f1[i-1];\n    if(i)\n      f2[i] += f2[i-1];\n  }\n  printf(\"%d\\n\",calc(0,0));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n     \nconst int maxn(4005);\nconst int mod(998244353);\n\ninline void Inc(int &x, int y) {\n    x = x + y >= mod ? x + y - mod : x + y;\n}\n\ninline void Dec(int &x, int y) {\n    x = x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Add(int x, int y) {\n    return x + y >= mod ? x + y - mod : x + y;\n}\n\ninline int Sub(int x, int y) {\n    return x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Pow(ll x, int y) {\n    ll ret = 1;\n    for (; y; y >>= 1, x = x * x % mod)\n        if (y & 1) ret = ret * x % mod;\n    return ret;\n}\n\nint n, fac[100000], inv[100000], ans, f[maxn][maxn];\nchar s[maxn];\n\ninline int C(int x, int y) {\n\tif (x < 0 || y < 0 || y > x) return 0;\n\treturn (ll)fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main() {\n\tint i, j, k, cb, cr, mx = 99999;\n\tinv[0] = inv[1] = 1;\n    for (i = 2; i <= mx; ++i) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;\n    for (i = 2; i <= mx; ++i) inv[i] = (ll)inv[i - 1] * inv[i] % mod;\n    for (i = fac[0] = 1; i <= mx; ++i) fac[i] = (ll)fac[i - 1] * i % mod;\n\tscanf(\" %s\", s + 1), n = strlen(s + 1);\n\tf[0][0] = 1, cb = cr = 0;\n\tfor (i = 1; i <= n; ++i) {\n\t\tif (s[i] == '0') cr += 2;\n\t\telse if (s[i] == '1') ++cr, ++cb;\n\t\telse cb += 2;\n\t\tfor (j = 0; j <= cr; ++j) {\n\t\t\tif (j) Inc(f[i][j], f[i - 1][j - 1]);\n\t\t\tInc(f[i][j], f[i - 1][j]);\n\t\t}\n\t}\n\tfor (j = 0; j <= min(cr, n); ++j) Inc(ans, (ll)f[n][j] * C(n, cr - j) % mod);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long dp[4001][4001],mod=998244353;\nint n;\nstring s;\nlong long ans(int b,int cn)\n{\n\tif(cn==2*n)return 1;\n\tif(dp[b][cn]!=0)return dp[b][cn];\n\tint r;\n\tif(cn>=n)r=2*n-b-cn;\n\telse r=2*(cn+1)-b-cn;\n\tint nb=0;\n\tif(cn<n-1)nb=s[cn+1]-'0';\n\tif(b!=0)dp[b][cn]+=ans(b-1+nb,cn+1);\n\tif(r!=0)dp[b][cn]+=ans(b+nb,cn+1);\n\tif(dp[b][cn]>mod)dp[b][cn]-=mod;\n\treturn dp[b][cn];\n}\nint main()\n{\n\tcin>>s;\n\tn=s.size();\n\ts+=s;\n\tcout<<ans(s[0]-'0',0)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2010 \nusing namespace std;\nstring st;\nint n,a[N],b[N],dp[N][N],mo=998244353;\nint main(){\n\tcin>>st;n=st.length();\n\tfor (int i=1;i<=n;i++)a[i]=st[i-1]-'0'+a[i-1],b[i]=b[i-1]+'2'-st[i-1];\n\tdp[0][0]=1;\n\tfor (int i=0;i<=a[n];i++)\n\t\tfor (int j=0;j<=b[n];j++)\n\t\t\tif (i<=a[min(n,i+j)]&&j<=b[min(n,i+j)])dp[i][j]=(dp[i][j]+(j?dp[i][j-1]:0)+(i?dp[i-1][j]:0))%mo;\n\tcout<<dp[a[n]][b[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld; //\ntypedef double db; //\ntypedef string str; //\n//\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl; //\ntypedef pair<ld,ld> pd; //\n#define mp make_pair\n#define f first\n#define s second\n\ntypedef vector<int> vi; \ntypedef vector<bool> vb;\ntypedef vector<ll> vl; //\ntypedef vector<ld> vd; //\ntypedef vector<str> vs; //\ntypedef vector<pi> vpi; //\ntypedef vector<pl> vpl; //\ntypedef vector<pd> vpd; //\ntypedef vector<vi> vvi;\n//\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() //\n#define rsz resize\n#define ins insert //\n#define ft front() //\n#define bk back() //\n#define pf push_front //\n#define pb push_back\n#define eb emplace_back //\n#define lb lower_bound //\n#define ub upper_bound //\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353; // = (119<<23)+1\nconst int MX = 2e5+5; //\nconst ll INF = 1e18; //\nconst ld PI = 4*atan((ld)1); \nconst int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0}; //\n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; }\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T;\n\tT val; \n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(ll v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.val == b.val; }\n\t/**friend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.val < b.val; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend ostream& operator<<(ostream& os, const mi& a) { \n\t\treturn os << a.val; }*/\n   \n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n\t/// mi& operator++() { return *this += 1; }\n\t/// mi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\n\tmi& operator*=(const mi& m) { \n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { \n\t\tassert(!(a == 0)); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n    string S;\n    cin >> S;\n\n    int N = S.size();\n    vi numb(2*N+1, 0);\n    for (int i=1;i<=N;i++) {\n        numb[i] = numb[i-1] + S[i-1] - '0';\n    }\n\n    for (int i=N+1;i<=2*N;i++) numb[i] = numb[i-1];\n\n    // for (int i=0;i<=2*N;i++) cout << numb[i] << \" \";\n    // cout << endl;\n\n    vector<mi> dprow(2*N+1, mi(0));\n    vector<vector<mi>> dp(2*N+1, dprow);\n\n    dp[0][0] = 1;\n    for (int i=1;i<=2*N;i++) {\n        for (int b=0; b<=numb[i];b++) {\n            int numr = 2*i - numb[i];\n            int r = i - b;\n\n            if (r < 0) continue;\n\n            if (r <= numr && b <= numb[i]) {\n                if (r-1 >=0) dp[i][b] += dp[i-1][b];\n                if (b-1 >=0) dp[i][b] += dp[i-1][b-1];\n            }\n        }\n    }\n\n    cout << dp[2*N][numb[2*N]].val << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 1\n\n/**\n * File    : F2.cpp\n * Author  : Kazune Takahashi\n * Created : 2/10/2019, 12:26:47 AM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 998244353;\nconst int MAX_SIZE = 1000010;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = ((MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    factinv[i] = (inv[i] * factinv[i - 1]) % MOD;\n  }\n}\n\nlong long C(int n, int k)\n{\n  if (n >= 0 && k >= 0 && n - k >= 0)\n  {\n    return ((fact[n] * factinv[k]) % MOD * factinv[n - k]) % MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n  else if (n % 2 == 1)\n  {\n    return (x * power(x, n - 1)) % MOD;\n  }\n  else\n  {\n    long long half = power(x, n / 2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcd(long long x, long long y)\n{\n  return y ? gcd(y, x % y) : x;\n}\n\nstring S;\nint N;\nll DP[2010][4010];\nint R[2010];\nint B[2010];\n\nint main()\n{\n  init();\n  cin >> S;\n  N = S.size();\n  for (auto i = 0; i < 4010; i++)\n  {\n    DP[0][i] = 0;\n  }\n  DP[0][0] = 1;\n  R[0] = B[0] = 0;\n  for (auto i = 1; i <= N; i++)\n  {\n    if (S[i - 1] == '0')\n    {\n      R[i] = R[i - 1] + 2;\n      B[i] = B[i - 1];\n    }\n    else if (S[i - 1] == '1')\n    {\n      R[i] = R[i - 1] + 1;\n      B[i] = B[i - 1] + 1;\n    }\n    else\n    {\n      R[i] = R[i - 1];\n      B[i] = B[i - 1] + 2;\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n#if DEBUG == 1\n    cerr << \"R[\" << i + 1 << \"] = \" << R[i + 1] << \", B[\" << i + 1 << \"] = \" << B[i + 1] << endl;\n#endif\n    for (auto j = 0; j <= i; j++)\n    {\n      if (DP[i][j] == 0)\n      {\n        continue;\n      }\n#if DEBUG == 1\n      cerr << \"DP[\" << i << \"][\" << j << \"] = \" << DP[i][j] << endl;\n#endif\n      int r = j;\n      int b = i - r;\n      if (R[i + 1] - r > 0)\n      {\n        DP[i + 1][j + 1] += DP[i][j];\n        DP[i + 1][j + 1] %= MOD;\n      }\n      if (B[i + 1] - b > 0)\n      {\n        DP[i + 1][j] += DP[i][j];\n        DP[i + 1][j] %= MOD;\n      }\n    }\n  }\n  ll ans = 0;\n  for (auto i = 0; i <= N; i++)\n  {\n    if (DP[N][i] == 0)\n    {\n      continue;\n    }\n    int r = i;\n    int b = N - i;\n    int res_r = R[N] - r;\n    int res_b = B[N] - b;\n    ans += (DP[N][i] * C(res_r + res_b, res_r)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\n#define RREP(i, n) for (int i = (int)n - 1; i >= 0; --i)\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define RFOR(i, s, n) for (int i = (int)n - 1; i >= s; --i)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\ntemplate<class T>inline void out(T t){cout << t << \"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout << t << \" \";out(ts...);}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a > b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a < b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\ntemplate<int MOD> struct Fp {\n\tlong long val;\n\tconstexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n\t\tif (val < 0) val += MOD;\n\t}\n\tconstexpr int getmod() { return MOD; }\n\tconstexpr Fp operator - () const noexcept {\n\t\treturn val ? MOD - val : 0;\n\t}\n\tconstexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n\tconstexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n\tconstexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n\tconstexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n\tconstexpr Fp& operator += (const Fp& r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= MOD) val -= MOD;\n\t\treturn *this;\n\t}\n\tconstexpr Fp& operator -= (const Fp& r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tconstexpr Fp& operator *= (const Fp& r) noexcept {\n\t\tval = val * r.val % MOD;\n\t\treturn *this;\n\t}\n\tconstexpr Fp& operator /= (const Fp& r) noexcept {\n\t\tlong long a = r.val, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlong long t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tconstexpr bool operator == (const Fp& r) const noexcept {\n\t\treturn this->val == r.val;\n\t}\n\tconstexpr bool operator != (const Fp& r) const noexcept {\n\t\treturn this->val != r.val;\n\t}\n\tfriend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n\t\treturn os << x.val;\n\t}\n\tfriend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n\t\tif (n == 0) return 1;\n\t\tauto t = modpow(a, n / 2);\n\t\tt = t * t;\n\t\tif (n & 1) t = t * a;\n\t\treturn t;\n\t}\n};\n \n\ntemplate<class T> struct BiCoef {\n\tvector<T> fact_, inv_, finv_;\n\tconstexpr BiCoef() {}\n\tconstexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n\t\tinit(n);\n\t}\n\tconstexpr void init(int n) noexcept {\n\t\tfact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n\t\tint MOD = fact_[0].getmod();\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tfact_[i] = fact_[i-1] * i;\n\t\t\tinv_[i] = -inv_[MOD%i] * (MOD/i);\n\t\t\tfinv_[i] = finv_[i-1] * inv_[i];\n\t\t}\n\t}\n\tconstexpr T com(int n, int k) const noexcept {\n\t\tif (n < k || n < 0 || k < 0) return 0;\n\t\treturn fact_[n] * finv_[k] * finv_[n-k];\n\t}\n\tconstexpr T P(int n, int k) const noexcept {\n\t\tif (n < k || n < 0 || k < 0) return 0;\n\t\treturn fact_[n] * finv_[n-k];\n\t}\n\tconstexpr T fact(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn fact_[n];\n\t}\n\tconstexpr T inv(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn inv_[n];\n\t}\n\tconstexpr T finv(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn finv_[n];\n\t}\n};\n \n//const int MOD = 1000000007;\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n// bc.init(500050);\n\nmint dp[4040][4040];\n\nsigned main(){\n\tstring s;\n\tcin >> s;\n\tvector<vector<int>>r(s.size() * 2 + 1, vector<int>(s.size() + 1));\n\tvector<vector<int>>b(s.size() * 2 + 1, vector<int>(s.size() + 1));\n\tint rs = 0;\n\tREP(i, s.size()) {\n\t\tif(s[i] == '0') {\n\t\t\trs += 2;\n\t\t\tr[0][i + 1] += 2;\n\t\t} else if(s[i] == '1') {\n\t\t\trs += 1;\n\t\t\tr[0][i + 1] += 1;\n\t\t\tb[0][i + 1] += 1;\n\t\t} else {\n\t\t\tb[0][i + 1] += 2;\n\t\t}\n\t}\n\tREP(i, s.size() * 2) {\n\t\tREP(j, s.size() + 1) {\n\t\t\tr[i + 1][j] = r[i][j];\n\t\t\tb[i + 1][j] = b[i][j];\n\t\t}\n\t\tREP(j, s.size()) {\n\t\t\tif(r[i][j + 1]) {\n\t\t\t\tr[i + 1][j] += 1;\n\t\t\t\tr[i + 1][j + 1] -= 1;\n\t\t\t}\n\t\t\tif(b[i][j + 1]) {\n\t\t\t\tb[i + 1][j] += 1;\n\t\t\t\tb[i + 1][j + 1] -= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tREP(i, s.size() * 2) {\n\t\tREP(j, s.size() * 2) {\n\t\t\tint R = j;\n\t\t\tint B = i - j;\n\t\t\tif(r[i + 1][0] >= R + 1)dp[i + 1][j + 1] += dp[i][j];\n\t\t\tif(b[i + 1][0] >= B + 1)dp[i + 1][j]     += dp[i][j];\n\t\t}\n\t}\n\tout(dp[s.size() * 2][rs]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n \nusing tpl = tuple<int, int, int>;\ntypedef pair<int,int> pii;\n\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nconst int mod = 998244353;\nstring S;\n\nll dp[4010][4010][2];\n\nll rec(int b, int r,int fin){\n    if(dp[b][r][fin]>=0) return dp[b][r][fin];\n    ll res = 0;\n    int pos = b + r;\n    if(fin == 1){\n        int cr = r; int cb = b;\n        if(cr + cb == 0){\n            res = 1;\n        }\n        else{\n            if(cr > 0){\n                res = (res + rec(cb, cr - 1, fin)) % mod;\n            }\n            if(cb > 0){\n                res = (res + rec(cb - 1, cr, fin)) % mod;\n            }\n        }        \n    }\n    else if(pos == (int)S.size()){\n        res = rec(b, r, 1);\n    }\n    else{\n        int cb = b;\n        int cr = r;\n        if(S[pos] == '0'){\n            cr += 2;\n        }\n        else if(S[pos] == '2'){\n            cb += 2;\n        }\n        else{\n            cr++;\n            cb++;\n        }\n        if(cr > 0){\n            res = (res + rec(cb, cr - 1, fin)) % mod;\n        }\n        if(cb > 0){\n            res = (res + rec(cb - 1, cr, fin)) % mod;\n        }\n    }\n\n    return dp[b][r][fin] = res;\n}\n\nint main(){\n\n    cin >> S;\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, 0, 0)<< endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : F2.cpp\n * Author  : Kazune Takahashi\n * Created : 2/10/2019, 12:26:47 AM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 998244353;\nconst int MAX_SIZE = 1000010;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = ((MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    factinv[i] = (inv[i] * factinv[i - 1]) % MOD;\n  }\n}\n\nlong long C(int n, int k)\n{\n  if (n >= 0 && k >= 0 && n - k >= 0)\n  {\n    return ((fact[n] * factinv[k]) % MOD * factinv[n - k]) % MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n  else if (n % 2 == 1)\n  {\n    return (x * power(x, n - 1)) % MOD;\n  }\n  else\n  {\n    long long half = power(x, n / 2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcd(long long x, long long y)\n{\n  return y ? gcd(y, x % y) : x;\n}\n\nstring S;\nint N;\nll DP[2010][4010];\nint R[2010];\nint B[2010];\n\nint main()\n{\n  init();\n  cin >> S;\n  N = S.size();\n  for (auto i = 0; i < 4010; i++)\n  {\n    DP[0][i] = 0;\n  }\n  DP[0][0] = 1;\n  R[0] = B[0] = 0;\n  for (auto i = 1; i <= N; i++)\n  {\n    if (S[i - 1] == '0')\n    {\n      R[i] = R[i - 1] + 2;\n      B[i] = B[i - 1];\n    }\n    else if (S[i - 1] == '1')\n    {\n      R[i] = R[i - 1] + 1;\n      B[i] = B[i - 1] + 1;\n    }\n    else\n    {\n      R[i] = R[i - 1];\n      B[i] = B[i - 1] + 2;\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n#if DEBUG == 1\n    cerr << \"R[\" << i + 1 << \"] = \" << R[i + 1] << \", B[\" << i + 1 << \"] = \" << B[i + 1] << endl;\n#endif\n    for (auto j = 0; j <= i; j++)\n    {\n      if (DP[i][j] == 0)\n      {\n        continue;\n      }\n#if DEBUG == 1\n      cerr << \"DP[\" << i << \"][\" << j << \"] = \" << DP[i][j] << endl;\n#endif\n      int r = j;\n      int b = i - r;\n      if (R[i + 1] - r > 0)\n      {\n        DP[i + 1][j + 1] += DP[i][j];\n        DP[i + 1][j + 1] %= MOD;\n      }\n      if (B[i + 1] - b > 0)\n      {\n        DP[i + 1][j] += DP[i][j];\n        DP[i + 1][j] %= MOD;\n      }\n    }\n  }\n  ll ans = 0;\n  for (auto i = 0; i <= N; i++)\n  {\n    if (DP[N][i] == 0)\n    {\n      continue;\n    }\n    int r = i;\n    int b = N - i;\n    int res_r = R[N] - r;\n    int res_b = B[N] - b;\n    ans += (DP[N][i] * C(res_r + res_b, res_r)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nconst ll MOD = 998244353;\nll dp[4010][4010];\nll cntr[4010];\nll cntb[4010];\n\nint main() {\n    string S;\n    cin >> S;\n    dp[0][0] = 1;\n    for(ll i = 0; i < S.size(); i++){\n        char c = S[i];\n        cntr[i + 1] = cntr[i] + 2 * (c == '0') + (c == '1'); \n        cntb[i + 1] = cntb[i] + 2 * (c == '2') + (c == '1');\n    }\n    for(ll i = S.size(); i < 4010; i++){\n        cntr[i + 1] = cntr[i];\n        cntb[i + 1] = cntb[i];\n    }\n    for(ll i = 1; i <= 2 * S.size(); i++){\n        for(ll r = 0; r <= min(i, cntr[i]); r++){\n            ll b = i - r;\n            if(b > cntb[i]) continue;\n            if(r > 0) dp[r][b] += dp[r - 1][b];\n            if(b > 0) dp[r][b] += dp[r][b - 1];\n            dp[r][b] %= MOD;\n        }\n    }\n    cout << dp[cntr[4010 - 1]][cntb[4010 - 1]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,a[2010];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll iv[2010]={};\nll inv(ll x){\n  if(iv[x]<1) iv[x]=pwr(x,MOD-2);\n  return iv[x];\n}\n\nll nC[2010]={1};\nll comb(ll r){\n  if(nC[r]==0) nC[r]=mlt(comb(r-1),mlt(n-r+1,inv(r)));\n  return nC[r];\n}\n\nint main(){\n  n=0;\n  ll R=0,B=0,r=0,b=0;\n  char c;\n  for(;cin>>c;){\n    a[n]=c-'0';\n    if(a[n]<1) R+=2;\n    else if(a[n]<2){R++;B++;}\n    else B+=2;\n    n++;\n  }\n  ll dp[2010][2010]={};\n  fr(i,n+1) dp[0][i]=1;\n  fr(i,n){\n    if(a[i]<1) r+=2;\n    else if(a[i]<2){r++;b++;}\n    else b+=2;\n    fr(j,n+1){\n      ll k=i-j;\n      if(k<0) break;\n      if(r-j>0) dp[i+1][j+1]=ad(dp[i+1][j+1],dp[i][j]);\n      if(b-k>0) dp[i+1][j]=ad(dp[i+1][j],dp[i][j]);\n    }\n  }\n  ll ans=0;\n  fr(j,n+1) ans=ad(ans,mlt(dp[n][j],comb(R-j)));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "c,t,d[4010]={1};char s[4010];i;main(j){for(gets(s);s[i/2];d[j]=0,i++)for(j=c+=s[i]?t+=2,s[i]-48:0;j>i+c-t&&~j;j--)d[j]=(d[j]+d[j-1])%998244353;printf(\"%d\",d[c]);}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,a[2010];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll iv[2010]={};\nll inv(ll x){\n  if(iv[x]<1) iv[x]=pwr(x,MOD-2);\n  return iv[x];\n}\n\nll nC[2010]={1};\nll comb(ll r){\n  if(nC[r]==0) nC[r]=mlt(comb(r-1),mlt(n-r+1,inv(r)));\n  return nC[r];\n}\n\nint main(){\n  n=0;\n  ll R=0,r=0,b=0;\n  char c;\n  for(;cin>>c;){\n    a[n]=c-'0';\n    if(a[n]<1) R++;\n    if(a[n]<2) R++;\n    n++;\n  }\n  ll dp[2010][2010]={};\n  dp[0][0]=1;\n  fr(i,n){\n    if(a[i]<1) r+=2;\n    else if(a[i]<2){r++;b++;}\n    else b+=2;\n    fr(j,n+1){\n      ll k=i-j;\n      if(k<0) break;\n      if(r-j>0) dp[i+1][j+1]=ad(dp[i+1][j+1],dp[i][j]);\n      if(b-k>0) dp[i+1][j]=ad(dp[i+1][j],dp[i][j]);\n    }\n  }\n  ll ans=0;\n  fr(j,n+1) if(R>=j && n+j>=R) ans=ad(ans,mlt(dp[n][j],comb(R-j)));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\ntemplate <class T> inline T &chmin(T &x, const T &y){ return x = min(x, y); }\ntemplate <class T> inline T &chmax(T &x, const T &y){ return x = max(x, y); }\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 998244353LL\n#define EPS 1e-8\n\nint n;\nvector<int> accb;\nvector<int> accr;\nVV(LL) memo;\n\nLL dfs(int i, int b){\n\tLL &r = memo[i][b];\n\tif(r >= 0){ return r; }\n\tr = 0;\n\tif(i == 2 * n){\n\t\tr = 1;\n\t}\n\telse{\n\t\tif(b < accb[i]){\n\t\t\tr += dfs(i + 1, b + 1);\n\t\t}\n\t\tif(i - b < accr[i]){\n\t\t\tr += dfs(i + 1, b);\n\t\t}\n\t\tif(r >= MOD){ r -= MOD; }\n\t}\n\treturn r;\n}\n\nvoid mainmain(){\n\tstring s;\n\tcin >> s;\n\tn = s.size();\n\tint b = 0, r = 0;\n\tfor(int i = 0; i < 2 * n; ++i){\n\t\tif(i < n){\n\t\t\tb += s[i] - '0';\n\t\t\tr += '2' - s[i];\n\t\t}\n\t\taccb.push_back(b);\n\t\taccr.push_back(r);\n\t}\n\t\n\tinitvv(memo, 2 * n + 1, 2 * n + 1, -1LL);\n\t\n\tLL ans = dfs(0, 0);\n\tcout << ans << endl;\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int mod=998244353;\n\nlong C[2001][4001];\n\nlong comb(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=mod;\n\t\t}\n\t\tC[i][i]=1;\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n=s.length();\n\tint red[n]={};\n\tred[0]=(s[0]=='0'?2:s[0]=='1'?1:0);\n\tfor(int i=1;i<n;i++) red[i]+=red[i-1]+(s[i]=='0'?2:s[i]=='1'?1:0);\n\t\n\tlong dp[n+1][2*n+1]={};\n\tdp[1][0]=(s[0]!='0'?1:0);\n\tdp[1][1]=(s[0]!='2'?1:0);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=max(0,red[i-1]-i);j<=min(i,red[i-1]);j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(j!=0?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcomb(n);\n\tlong ans=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(i<=red[n-1]) ans+=dp[n][i]*C[n][red[n-1]-i]%mod;\n\t\tans%=mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef gp_hash_table<long long, long long> umap;\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (long long i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (long long i = (n) - 1; i >= 0; i--)\n#define foreach(it,ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar,val) memset(ar, val, sizeof(ar))\n#define fill0(ar) fill((ar), 0)\n#define fillinf(ar, n) fr(i,0,(n)) ar[i] = INF\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define arr1d(a,n) cout << #a << \" : \"; fr(_,1,n) cout << a[_] << ' '; cout << endl;\n#define arr1d0(a,n) cout << #a << \" : \"; rep(_,n) cout << a[_] << ' '; cout << endl;\n#define arr2d(a,n,m) cout << #a << \" :\" << endl; fr(_,1,n) {fr(__,1,m) cout << a[_][__] << ' '; cout << endl;}\n#define arr2d0(a,n,m) cout << #a << \" :\" << endl; rep(_,n) {rep(__,m) cout << a[_][__] << ' '; cout << endl;}\n/*Author Ritick Goenka || ritick(codechef) ||ritick(codeforces) */\n/*IIT Roorkee = <3 */\n#define ull unsigned long long\n#define ll long long\n#define ld double\n#define ui unsigned int\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define y0 yyyyyy0\n#define y1 yyyyyy1\n#define sot(bello) bello.begin(),bello.end()\n#define BIT(n) (1<<(n))\n#define SQR(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n#define LSOne(S) (S) & (-S)\ninline bool EQ(double a, double b) {return fabs(a - b) < 1e-9;}\n \ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n \n \ntemplate<typename T>inline T gcd(T a, T b){if (b == 0)return a;else return gcd(b, a % b);}\ntemplate<typename T>inline T lcm(T a, T b){return (a * b) / gcd(a, b);}\ntemplate<typename T> string toStr(T x) {stringstream st; st << x; string s; st >> s; return s;}\ntemplate<class T>\nvoid splitStr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n \ninline int two(int n) {return 1 << n;}\ninline int isOnBit(int n, int b) {return (n >> b) & 1;}\ninline void onBit(int & n, int b) {n |= two(b);}\ninline void offBit(int & n, int b) {n &= ~two(b);}\ninline int lastBit(int n) {return n & (-n);}\ninline int cntBit(int n) {int res = 0; while(n && ++res) n -= n &(-n); return res;}\n \nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy8[] = {0, 1, 0, -1, -1, 1, -1, 1};\n \n#define INP \"test.inp\"\n#define OUT \"test.out\"\n \n#define PI 3.1415926535897932385\n#define INF 1000000000000000\n#define EPS 1e-7\n#define MAXN 100000\n#define MOD 998244353\n#define dec decr\n//END OF COMPETITVE PROGRAMMING TEMPLATE\nll gcd(ll a, ll b) \n{ \n    if (a == 0) \n        return b; \n    return gcd(b % a, a); \n} \nll modexp(ll x, ll y, ll p)\n{\n    ll res = 1;   \n    x = x % p;  \n    while (y > 0)\n    {\n        if (y & 1)    \n            res = (res*x) % p;\n        y = y>>1;     \n        x = (x*x) % p; \n    }\n    return res;\n}\nll dp[6005][6005];\nll r[6005];\nll r1[6005];\nll b1[6005];\nll b[6005];\nll n1;\nll fn(ll br,ll bb)\n{\n    // debug(br);\n    // debug(bb);\n    if(br<0||bb<0)\n        return 0;\n    ll n=br+bb;\n    if((br<r[n]||bb<b[n]))\n        return 0;\n    if(br>r1[n]||bb>b1[n])\n        return 0;\n    if(dp[br][bb]!=-1)\n        return dp[br][bb];\n    return dp[br][bb]=(fn(br-1,bb)+fn(br,bb-1))%MOD;\n \n}\n \nint main () \n{\n    ios_base::sync_with_stdio(false);\n            cin.tie(NULL);\n        cout<<setprecision(11);\n            string s;\n            cin>>s;\n            ll x=0;\n            ll rc=0,bc=0;\n            rep(i,3005)\n            {\n                rep(j,3005)\n                    dp[i][j]=-1;\n            }\n            ll n=s.length();\n            // debug(n);\n            n1=n;\n            dp[0][0]=1;\n            rep(i,n)\n            {\n                // debug(i);\n                if(s[i]=='0')\n                {\n                    rc++;\n                    r1[i+1]=r1[i]+2;\n                    b1[i+1]=b1[i];\n\n                }\n                else if(s[i]=='2')\n                {\n                    bc++;\n                    b1[i+1]=b1[i]+2;\n                    r1[i+1]=r1[i];\n\n                }\n                else\n                {\n                    r1[i+1]=r1[i]+1;\n                    b1[i+1]=b1[i]+1;\n                }\n                r[i+1]=max(r[i],rc-bc);\n                b[i+1]=max(b[i],bc-rc);\n                // debug(b1[i+1]);\n                //     debug(r1[i+1]);\n            }\n            rep(i,n)\n            {\n                // debug(r1[i+1]);\n                // debug(b1[i+1]);\n                r1[n+i+1]=r1[n+i];\n                b1[n+i+1]=b1[n+i];\n\n                r[n+i+1]=r[n+i];\n                b[n+i+1]=b[n+i];\n            }\n            // debug(n-bc+rc);\n            // debug(n);\n            cout<<fn(n-bc+rc,n-rc+bc);\n            return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 998244353;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\nmint dp[4010][4010][2];\n\ninline int rest_ball(int i,int n){\n\tconst int total = 2 * min(i,n) - i;\n\treturn total;\n}\n\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\n\tif(s == string(n,'2')){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tdp[0][0][0] = ONE;\n\n\trep(i,2*n)rep(j,2*n+1)rep(k,2){\n\t\tif(dp[i][j][k] == ZERO) continue;\n\t\tconst int all = rest_ball(i, n);\n\t\tint nr = j, nb = all - j;\n\n\t\tif(i < n){\n\t\t\tconst int idx = s[i] - '0';\n\t\t\tnr += 2 - idx;\n\t\t\tnb += idx;\n\t\t}\n\n\t\t// red\n\t\tif(nr > 0){\n\t\t\tint nk = k;\n\t\t\tdp[i+1][nr-1][nk] += dp[i][j][k];\n\t\t}\n\n\t\t// blue\n\t\tif(nb > 0){\n\t\t\tint nk = k;\n\t\t\tdp[i+1][nr][nk] += dp[i][j][k];\n\t\t}\n\t}\n\n\tmint ans = dp[2 * n][0][0];\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n    // 二次元ベクターの基本\n    /*\n    vector<vector<int>> dp; // 宣言\n    dp.resize(n); // 1次元めの要素数決定\n    dp[i].push_back(int); // プッシュバック\n    rep(i,n){\n        sort(dp[i].begin(),dp[i].end()); // 二次元めで昇順ソート\n    }\n    */\n\n    // 整数スキャン（複数）\n    /*\n    int x;\n    scanf(\"%d\",&x);\n    int y;\n    scanf(\"%d\",&y);\n    int z;\n    scanf(\"%d\",&z);\n\n    // n個の整数のスキャン\n    /*\n    ll a[n] = {};\n    rep(i,n){\n        scanf(\"%lld\",&a[i]);\n    }\n    */\n\n    // 文字列スキャン\n    /*\n    string s;\n    cin >> s;\n    */\n\n    // n個の文字列スキャン\n    /*\n    vector<string> slist;\n    rep(i,n){\n        string s;\n        cin >> s;\n        slist.push_back(s);\n    }\n    */\n\nint main() {\n    string s;\n    cin >> s;\n\n    int si = s.size();\n    int snu[si];\n    int t[si*2];\n    int snut[si];\n    int tt[si*2];\n\n    ll two[4100] ={};\n\n    two[0] = 1;\n    srep(i,1,4050){\n        two[i]=two[i-1]*2;\n        if(two[i]>998244353){\n            two[i] %= 998244353;\n        }\n    }\n\n    rep(i,si){\n        if(s[i]=='0'){\n            snu[i]=0;\n            snut[i]=0;\n        }\n        if(s[i]=='1'){\n            snu[i]=1;\n            snut[i]=1;\n        }\n        if(s[i]=='2'){\n            snu[i]=2;\n            snut[i]=2;\n        }\n    }\n\n    // 赤なら0,青なら1\n    // 辞書順最初\n    rep(i,si*2){\n        if(i%2==0){\n            if(snu[0]==2){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)]==0){\n                snu[si-1-(i/2)]=3;\n            }else{\n                snu[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snu[0]==2||snu[0]==4){\n                t[i]=1;\n            }else{\n                t[i]=0;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snu[j]==0&&snu[j+1]<2){\n                    snu[j] = 0;\n                }else if(snu[j]==0&&snu[j+1]==2){\n                    snu[j]=1;\n                }else if(snu[j]==1&&snu[j+1]==2){\n                    snu[j]=2;\n                }else if(snu[j]==2&&snu[j+1]!=2){\n                    snu[j]=1;\n                }\n            }\n            if(snu[si-1-(i/2)-1]==0&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 1;\n            }else if(snu[si-1-(i/2)-1]==1&&snu[si-1-(i/2)]==4){\n                snu[si-1-(i/2)-1] = 2;\n            }else if(snu[si-1-(i/2)-1]==2&&snu[si-1-(i/2)]==3){\n                snu[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n\n        rep(j,i+1){\n            cout << t[j];\n        }\n        cout << endl;\n        */\n    }\n    int cm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cm[i]=t[i];\n        }else{\n            cm[i]=t[i]+cm[i-1];\n        }\n        \n    }\n    //cout << endl;\n\n    // 辞書順最後\n    rep(i,si*2){\n        if(i%2==0){\n            if(snut[0]==0){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)]!=2){\n                snut[si-1-(i/2)]=3;\n            }else{\n                snut[si-1-(i/2)]=4;\n            }\n        }else{\n            if(snut[0]==0||snut[0]==3){\n                tt[i]=0;\n            }else{\n                tt[i]=1;\n            }\n            rep(j,si-1-(i/2)-1){\n                if(snut[j]==0&&snut[j+1]!=0){\n                    snut[j] = 1;\n                }else if(snut[j]==0&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==1&&snut[j+1]==0){\n                    snut[j]=0;\n                }else if(snut[j]==2&&snut[j+1]==0){\n                    snut[j]=1;\n                }\n            }\n            if(snut[si-1-(i/2)-1]==0&&snut[si-1-(i/2)]==4){\n                snut[si-1-(i/2)-1] = 1;\n            }else if(snut[si-1-(i/2)-1]==1&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 0;\n            }else if(snut[si-1-(i/2)-1]==2&&snut[si-1-(i/2)]==3){\n                snut[si-1-(i/2)-1] = 1;\n            }\n        }\n        /*\n        rep(j,i+1){\n            cout << tt[j];\n        }\n        cout << endl;\n        */\n    }\n    int cmm[si*2] = {};\n    rep(i,si*2){\n        //cout << t[i];\n        if(i==0){\n            cmm[i]=tt[i];\n        }else{\n            cmm[i]=tt[i]+cmm[i-1];\n        }\n        \n    }\n\n    ll dp[si*2][si*2+1];\n    rep(i,si*2+1){\n        dp[0][i]=0;\n    }\n    if(cm[0]==0)dp[0][0]=1;\n    dp[0][1]=cmm[0];\n    srep(i,1,si*2){\n        rep(j,si*2+1){\n            if(j<cm[i]){\n                dp[i][j]=0;\n            }else if(j>cmm[i]){\n                dp[i][j]=0;\n            }else{\n                if(cm[i]<=j&&j<=cmm[i]){\n                    if(j==0){\n                        dp[i][j]=dp[i-1][j];\n                    }else{\n                        dp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n                    }\n                    \n                    if(dp[i][j]>998244353){\n                        dp[i][j] %= 998244353;\n                    }\n                }\n            }\n        }\n    }\n    \n    ll ans = 0;\n    rep(i,si*2+1){\n        ans+=dp[si*2][i];\n        if(ans>998244353){\n            ans %= 998244353;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n \n \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<math.h>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<ULL> VULL;\n\nclass MYCP {\npublic:\n\n\t//数値を区切って文字列にする\n\tstatic string MakeString_LongLong(vector<long long> const& numbers, string const& str) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += str;\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//空白で区切る為のオーバーロード\n\tstatic string MakeString_LongLong(vector<long long> const& numbers) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += \" \";\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\n\n\t//文字列の配列を改行を挟んでまとめる\n\tstatic string MakeString_VectorString(vector<string> const& str) {\n\t\tstring result = \"\";\n\t\tfor (long long i = 0; i < str.size(); i++) {\n\t\t\tresult += str[i] + \"\\n\";\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//文字列を必要な個数だけ読み取る\n\tstatic vector<string> MyReadLineSplit(LL n) {\n\t\tvector<string> str(n);\n\t\tfor (long long i = 0; i < n; i++) {\n\t\t\tstd::cin >> str[i];\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t//数値を必要な個数だけ読み取る\n\tstatic vector<long long> ReadInts(long long number) {\n\t\tvector<long long> a(number);\n\t\tfor (int i = 0; i < number; i++) {\n\t\t\tstd::cin >> a[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t//渡された自然数が素数ならtureを返す\n\tstatic bool PrimeCheck_Int(long long number) {\n\t\tif (number < 2)return false;\n\n\t\tfor (ULL i = 2; i*i <= number; i++) {\n\t\t\tif (number%i == 0)return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t//渡された数値以下の素数表を作る\n\tstatic vector<long long> MakePrimeList(long long n) {\n\t\tvector<long long> list;\n\t\tLL i, j, p;\n\t\tbool flag;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tflag = true;\n\t\t\tfor (j = 0; j < list.size(); j++) {\n\n\t\t\t\tif (!(list[j] * list[j] <= i))break;\n\n\t\t\t\tif (i%list[j] == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)list.push_back(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\n\n\t//文字列の分割\n\tstatic vector<string> split(string const& str, char sep)\n\t{\n\t\tvector<std::string> v;        // 分割結果を格納するベクター\n\t\tauto first = str.begin();              // テキストの最初を指すイテレータ\n\t\twhile (first != str.end()) {         // テキストが残っている間ループ\n\t\t\tauto last = first;                      // 分割文字列末尾へのイテレータ\n\t\t\twhile (last != str.end() && *last != sep)       // 末尾 or セパレータ文字まで進める\n\t\t\t\tlast++;\n\t\t\tv.push_back(string(first, last));       // 分割文字を出力\n\t\t\tif (last != str.end())\n\t\t\t\tlast++;\n\t\t\tfirst = last;          // 次の処理のためにイテレータを設定\n\t\t}\n\t\treturn v;\n\t}\n\n\t//合計を求める\n\tstatic LL Sum(vector<LL> a) {\n\t\tLL i, sum = 0;\n\n\t\tfor (i = 0; i < a.size(); i++) {\n\t\t\tsum += a[i];\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t//小文字ならtrueを返す\n\tstatic bool Komoji(char a) {\n\t\tif (a >= 'a'&&a <= 'z')return true;\n\n\t\treturn false;\n\t}\n\n\t//大文字ならtrueを返す\n\tstatic bool Oomoji(char a) {\n\t\tif (a >= 'A'&&a <= 'Z')return true;\n\n\t\treturn false;\n\t}\n\n\tstatic LL GreatestCommonFactor(LL a, LL b) {\n\t\tLL temp;\n\t\tif (a < b) {\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\twhile (true)\n\t\t{\n\t\t\ttemp = a % b;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\tif (b == 0)break;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\tstatic LL LeastCommonMultiple(LL a, LL b) {\n\t\treturn (a / GreatestCommonFactor(a, b))*b;\n\t}\n\n};\n\n//累積和を求めるクラス\nclass Syakutori {\nprivate:\n\tvector<LL> list;\n\npublic:\n\n\tvoid MakeArray(vector<LL> data) {\n\t\tLL i;\n\t\tlist = data;\n\t\tlist.push_back(0);\n\t\tlist[0] = 0;\n\t\tfor (i = 1; i < list.size(); i++) {\n\t\t\tlist[i] = list[i - 1] + data[i - 1];\n\t\t}\n\n\t}\n\n\tLL Sum(LL start, LL end) {\n\t\tif (end < start) {\n\t\t\tcout << \"startがendより大きいです\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (start < 0 || end >= list.size()) {\n\t\t\tcout << \"範囲が異常\";\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn list[end] - list[start];\n\t}\n\n\n\n\n};\n\nstring strnum = \"0123456789\";\nstring alpS = \"abcdefghijklmnopqrstuvwxyz\";\nstring alpL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nint sizealp = (int)(alpS.size());\nint mod = 1e9 + 7;\n\nint main(void) {\n\tint a[3], b[3];\n\tfor (int i = 0; i < 3; i++)\n\t\tcin >> a[i] >> b[i];\n\tint baketu[5] = {0};\n\tfor (int i = 0; i < 3; i++) {\n\t\tbaketu[a[i]] += a[i] / a[i];\n\t\tbaketu[b[i]] += b[i] / b[i];\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tif (baketu[i] == 3) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 998244353 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 4010\n\nll dp[SIZE][SIZE];\n\nint main(){\n  char s[SIZE];\n  int n;\n\n  scanf(\"%s\", s);\n  n = strlen(s);\n\n  int R = 0, B = 0;\n\n  dp[0][0] = 1;\n\n  for(int i=0;i<n*2;i++){\n    if (i < n) {\n      if (s[i] == '0') { R += 2; }\n      if (s[i] == '1') { R += 1; B += 1; }\n      if (s[i] == '2') { B += 2; }\n    }\n\n    for(int j=0;j<=i*2;j++){\n      int r = j, b = i - j;\n\n      if(r < R) (dp[i+1][r+1] += dp[i][r]) %= mod;\n      if(b < B) (dp[i+1][r] += dp[i][r]) %= mod;\n    }\n  }\n\n  cout << dp[n*2][R] << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst lint mod = 998244353;\nconst lint INF = mod*mod;\nconst int MAX = 100010;\n\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    int R[n+1], B[n+1];\n    int curr=0, curb=0;\n    rep(i, n){\n        if(s[i]=='0') {\n            R[curr++]=i; R[curr++]=i;\n        }\n        else if(s[i]=='1'){\n            R[curr++]=i; B[curb++]=i;\n        }\n        else{\n            B[curb++]=i; B[curb++]=i;\n        }\n    }\n\n    lint dp[curr+1][curb+1];\n    rep(i, curr+1)rep(j, curb+1) dp[i][j]=0;\n    dp[0][0]=1;\n    rep(i, curr+1)rep(j, curb+1)if(dp[i][j]){\n        if(i<curr && R[i]<=i+j) (dp[i+1][j]+=dp[i][j])%=mod;\n        if(j<curb && B[j]<=i+j) (dp[i][j+1]+=dp[i][j])%=mod;\n    }\n    printf(\"%lld\\n\", dp[curr][curb]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size(),r = 0;\n    vector<vector<ll>> dp(2*n+1,vector<ll>(2*n+1,0));\n    dp[0][0] = 1;\n    for (int i = 0;i < 2*n;++i) {\n        if (i < n) {\n            if (s[i] == '0') r += 2;\n            else if (s[i] == '1') r += 1;\n        }\n        for (int j = 0;j < min(2*i+2,2*n);++j) {\n            if (j && j <= r) dp[i+1][j] = dp[i][j-1];\n            if (i+1-j <= min(2*i+2,2*n)-r) dp[i+1][j] += dp[i][j];\n            dp[i+1][j] %= mod;\n        }\n    }\n    cout << dp[2*n][r] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=2010;\nconst int inf=2147483647;\nconst int mod=998244353;\nvoid upd(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nchar s[Maxn];int n;\nint C[Maxn][Maxn],f[Maxn][Maxn];\nvoid pre()\n{\n\tC[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tpre();\n\tint s1=0,s0=0;f[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint t=s[i]-'0';\n\t\ts1+=t;//1的个数\n\t\ts0+=2-t;\n\t\tfor(int j=0;j<=min(s1,i);j++)\n\t\t{\n\t\t\tif(j)upd(f[i][j],f[i-1][j-1]);\n\t\t\tif(i-j<=s0)upd(f[i][j],f[i-1][j]);\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,f[i][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=min(s1,n);i++)upd(ans,(LL)f[n][i]*C[n][s1-i]%mod);\n\tprintf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef gp_hash_table<long long, long long> umap;\n#define fr(i,a,b) for (int i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (int i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (long long i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (long long i = (n) - 1; i >= 0; i--)\n#define foreach(it,ar) for ( typeof(ar.begin()) it = ar.begin(); it != ar.end(); it++ )\n#define fill(ar,val) memset(ar, val, sizeof(ar))\n#define fill0(ar) fill((ar), 0)\n#define fillinf(ar, n) fr(i,0,(n)) ar[i] = INF\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define arr1d(a,n) cout << #a << \" : \"; fr(_,1,n) cout << a[_] << ' '; cout << endl;\n#define arr1d0(a,n) cout << #a << \" : \"; rep(_,n) cout << a[_] << ' '; cout << endl;\n#define arr2d(a,n,m) cout << #a << \" :\" << endl; fr(_,1,n) {fr(__,1,m) cout << a[_][__] << ' '; cout << endl;}\n#define arr2d0(a,n,m) cout << #a << \" :\" << endl; rep(_,n) {rep(__,m) cout << a[_][__] << ' '; cout << endl;}\n/*Author Ritick Goenka || ritick(codechef) ||ritick(codeforces) */\n/*IIT Roorkee = <3 */\n#define ull unsigned long long\n#define ll long long\n#define ld double\n#define ui unsigned int\n#define all(ar) ar.begin(), ar.end()\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define y0 yyyyyy0\n#define y1 yyyyyy1\n#define sot(bello) bello.begin(),bello.end()\n#define BIT(n) (1<<(n))\n#define SQR(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n#define LSOne(S) (S) & (-S)\ninline bool EQ(double a, double b) {return fabs(a - b) < 1e-9;}\n \ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n \n \ntemplate<typename T>inline T gcd(T a, T b){if (b == 0)return a;else return gcd(b, a % b);}\ntemplate<typename T>inline T lcm(T a, T b){return (a * b) / gcd(a, b);}\ntemplate<typename T> string toStr(T x) {stringstream st; st << x; string s; st >> s; return s;}\ntemplate<class T>\nvoid splitStr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n \ninline int two(int n) {return 1 << n;}\ninline int isOnBit(int n, int b) {return (n >> b) & 1;}\ninline void onBit(int & n, int b) {n |= two(b);}\ninline void offBit(int & n, int b) {n &= ~two(b);}\ninline int lastBit(int n) {return n & (-n);}\ninline int cntBit(int n) {int res = 0; while(n && ++res) n -= n &(-n); return res;}\n \nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy8[] = {0, 1, 0, -1, -1, 1, -1, 1};\n \n#define INP \"test.inp\"\n#define OUT \"test.out\"\n \n#define PI 3.1415926535897932385\n#define INF 1000000000000000\n#define EPS 1e-7\n#define MAXN 100000\n#define MOD 998244353\n#define dec decr\n//END OF COMPETITVE PROGRAMMING TEMPLATE\nll gcd(ll a, ll b) \n{ \n    if (a == 0) \n        return b; \n    return gcd(b % a, a); \n} \nll modexp(ll x, ll y, ll p)\n{\n    ll res = 1;   \n    x = x % p;  \n    while (y > 0)\n    {\n        if (y & 1)    \n            res = (res*x) % p;\n        y = y>>1;     \n        x = (x*x) % p; \n    }\n    return res;\n}\nll dp[6005][6005];\nll r[6005];\nll r1[6005];\nll b1[6005];\nll b[6005];\nll n1;\nll fn(ll br,ll bb)\n{\n    // debug(br);\n    // debug(bb);\n    if(br<0||bb<0)\n        return 0;\n    ll n=br+bb;\n    if((br<r[n]||bb<b[n]))\n        return 0;\n    // if(br>r1[n]||bb>b1[n])\n    //     return 0;\n    if(dp[br][bb]!=-1)\n        return dp[br][bb];\n    return dp[br][bb]=(fn(br-1,bb)+fn(br,bb-1))%MOD;\n \n}\n \nint main () \n{\n    ios_base::sync_with_stdio(false);\n            cin.tie(NULL);\n        cout<<setprecision(11);\n            string s;\n            cin>>s;\n            ll x=0;\n            ll rc=0,bc=0;\n            rep(i,6005)\n            {\n                rep(j,6005)\n                    dp[i][j]=-1;\n            }\n            ll n=s.length();\n            // debug(n);\n            n1=n;\n            dp[0][0]=1;\n            rep(i,n)\n            {\n                // debug(i);\n                if(s[i]=='0')\n                {\n                    rc++;\n                    r1[i+1]=r1[i]+2;\n                    b1[i+1]=b1[i];\n\n                }\n                else if(s[i]=='2')\n                {\n                    bc++;\n                    b1[i+1]=b1[i]+2;\n                    r1[i+1]=r1[i];\n\n                }\n                else\n                {\n                    r1[i+1]=r1[i]+1;\n                    b1[i+1]=b1[i]+1;\n                }\n                r[i+1]=max(r[i],rc-bc);\n                b[i+1]=max(b[i],bc-rc);\n                // debug(b1[i+1]);\n                //     debug(r1[i+1]);\n            }\n            rep(i,n)\n            {\n                // debug(r1[i+1]);\n                // debug(b1[i+1]);\n                r1[n+i+1]=r1[n+i];\n                b1[n+i+1]=b1[n+i];\n\n                r[n+i+1]=r[n+i];\n                b[n+i+1]=b[n+i];\n            }\n            // debug(n-bc+rc);\n            // debug(n);\n            cout<<fn(n-bc+rc,n-rc+bc);\n            return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 998244353ULL\n#define cINF ((1ull<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\nint main()\n{\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\n\tstring s; cin >> s;\n\tull n = s.size();\n\n\tvector<vector<ll>> dp( 2*n+1, vector<ll>( n+2, 0 ) );\n\tdp[0][0] = 1;\n\n\tREP( i, n )\n\t{\n\t\tint b = s[i] - '0';\n\t\tREP( j, dp[i].size() )\n\t\t{\n\t\t\tif( j+b >= 1 ) dp[i+1][j+b-1] = add( dp[i+1][j+b-1], dp[i][j] );\n\t\t\tif( i+j+b < 2*(i+1) ) dp[i+1][j+b] = add( dp[i+1][j+b], dp[i][j] );\n\t\t}\n\t\t//REP( j, dp[i].size() ) cout << dp[i][j] << \" \"; cout << endl;\n\t}\n\tREP( k, n )\n\t{\n\t\tint i = k + n;\n\t\tREP( j, dp[i].size() )\n\t\t{\n\t\t\tif( j >= 1 ) dp[i+1][j-1] = add( dp[i+1][j-1], dp[i][j] );\n\t\t\tif( i + j < 2 * n ) dp[i+1][j] = add( dp[i+1][j], dp[i][j] );\n\t\t}\n\t\t//REP( j, dp[i].size() ) cout << dp[i][j] << \" \"; cout << endl;\n\t}\n\t\n\tcout << dp[2*n][0] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst int MOD = 998244353;\n\nint dp[4001][4001];\nint N;\nstring s;\nint R[2001], B[2001];\n\nint dfs(int r, int b) {\n  if ( r+b == 2*N ) return 1;\n  if ( dp[r][b] >= 0 ) return dp[r][b];\n\n  int ret = 0;\n  if ( r+b >= N ) {\n    if ( R[N-1] > r ) ret += dfs(r+1, b);\n    if ( B[N-1] > b ) ret += dfs(r, b+1);    \n  } else {\n    if ( R[r+b] > r ) ret += dfs(r+1, b);\n    if ( B[r+b] > b ) ret += dfs(r, b+1);    \n  }\n\n  return dp[r][b] = ret%MOD;  \n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  fill_n(*dp, 4001*4001, -1);\n  cin >> s;\n  N = s.size();\n\n  for ( int i = 0; i < N; i++ ) {\n    if ( i ) {\n      R[i] += R[i-1];\n      B[i] += B[i-1];      \n    }\n    if ( s[i] == '0' ) {\n      R[i] += 2;\n    }\n    if ( s[i] == '1' ) {\n      R[i]++;\n      B[i]++;\n    }\n    if ( s[i] == '2' ) {\n      B[i] += 2;      \n    }\n  }\n\n  cout << dfs(0, 0) << endl;  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <memory>\n#include <complex>\n#include <numeric>\n#include <cstdio>\n#include <iomanip>\n\n#define REP(i,m,n) for(int i=int(m);i<int(n);i++)\n#define RREP(i,m,n) for(int i=int(n)-1;i>=int(m);--i)\n#define EACH(i,c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n#ifdef LOCAL\n#define DEBUG(s) cout << (s) << endl\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define BR cout << endl;\n#else\n#define DEBUG(s) do{}while(0)\n#define dump(x) do{}while(0)\n#define BR \n#endif\nusing namespace std;\n\nusing UI = unsigned int;\nusing UL = unsigned long;\nusing LL = long long int;\nusing ULL = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VLL = vector<LL>;\nusing VVLL = vector<VLL>;\nusing VS = vector<string>;\nusing PII = pair<int,int>;\nusing VP = vector<PII>;\n\n//struct edge {int from, to, cost;};\n\nconstexpr double EPS = 1e-10;\n//constexpr double PI  = acos(-1.0);\n//constexpr int INF = INT_MAX;\nconstexpr LL MOD = 998244353;\n//inline void modAdd(LL &l, LL &r) {l = (l + r) % MOD;}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\nLL dfs(int n, int blue, VI &ru, VVLL &memo) {\n    if (n <= 0 || blue < 0) return 0;\n    //cout << n << \" \" << blue << \" \" << ru[min((int)ru.size()-1,n)] << \" \" << memo[n][blue] << endl;\n    if (memo[n][blue] > -1) return memo[n][blue];\n    if (n <= ru.size()) {\n        if (blue > ru[n-1]) return memo[n][blue] = 0;\n        if (n - blue > 2 * n - ru[n-1]) return memo[n][blue] = 0;\n    } else {\n        int maxb = ru[ru.size()-1];\n        if (blue > maxb) return memo[n][blue] = 0;\n        if (n - blue > 2 * ru.size() - maxb) return memo[n][blue] = 0;\n    }\n    if (n == 1) {\n        if (ru[0] == 0 && blue >= 1) return memo[n][blue] = 0;\n        if (ru[0] == 2 && blue == 0) return memo[n][blue] = 0;\n        return memo[n][blue] = 1;\n    }\n    return memo[n][blue] = (dfs(n-1, blue - 1, ru, memo) + dfs(n-1, blue, ru, memo)) % MOD;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    VI ru(n);\n    ru[0] = s[0] - '0';\n    REP(i,1,n) ru[i] = ru[i-1] + s[i] - '0';\n    VVLL memo(2*n+1, VLL(2*n+1, -1));\n    cout << dfs(2*n,ru[n-1],ru,memo) << endl;\n}\n\nint main() {\n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst long long mod = 998244353;\nchar s[2001];\nlong long f[4001][4001];\nint sum0[4001]; int sum1[4001];\n\nint main(){\n    scanf(\"%s\",s+1);\n    int n = strlen(s+1);\n    for(int i = 1; i <= n; i++){\n        sum0[i] = sum0[i-1], sum1[i] = sum1[i-1];\n        if(s[i]=='0') sum0[i] += 2;\n        else if(s[i]=='1') sum0[i]++, sum1[i]++;\n        else sum1[i] += 2;\n    }\n    for(int i = n+1; i <= 2*n; i++) sum0[i] = sum0[i-1], sum1[i] = sum1[i-1];\n    f[0][0] = 1;\n    for(int i = 1; i <= 2*n; i++){\n        for(int j = 0; j <= 2*n; j++){\n            f[i][j] = 0;\n            int cnt0 = j, cnt1 = i-j;\n            if(cnt0<=sum0[i] && cnt1<=sum1[i]){\n                if(cnt0!=0) f[i][j] = (f[i][j]+f[i-1][j-1])%mod;\n                if(cnt1!=0) f[i][j] = (f[i][j]+f[i-1][j])%mod;\n            } \n        }\n    }\n    printf(\"%lld\\n\",f[2*n][sum0[2*n]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<math.h>\n#include<list>\n#include<complex>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\n#define vtype(type) vector<type>\n#define vvtype(type) vector<vector<type>>\n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nll const MOD = 998244353;\nll mod_p(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn (x + y + MOD) % MOD;\n}\n\nll mod_m(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn x * y%MOD;\n}\n\nll mod_pow(ll x, ll t) {\n\tx %= MOD;\n\tif (t == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tll v = mod_pow(x, t / 2);\n\t\tif (t % 2 == 0) {\n\t\t\treturn v * v % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn v * v%MOD * x %MOD;\n\t\t}\n\t}\n}\n\nll mod_inv(ll x) {\n\treturn mod_pow(x, MOD - 2);\n}\n\nstruct edge\n{\n\tlong long to; ll name;\n\tbool operator<(const edge& rhs) const {\n\t\treturn name > rhs.name;\n\t}\n};\n\nll const MAX = 2e3 + 5;\nll dp[MAX][MAX] = {};\n\n\nint main() {\n\tstring s; cin >> s;\n\tll n = s.size();\n\tll bl = 0; ll rd = 0;\n\tdp[0][0] = 1;\n\tREP(i, 0, n * 2 - 1) {\n\t\tif (i < n) {\n\t\t\tbl += s[i] - '0';\n\t\t\trd += -(s[i] - '2');\n\t\t}\n\t\tREP(j, 0, n * 2 - 1) {\n\t\t\tif (j < bl) {\n\t\t\t\tdp[i + 1][j + 1] = mod_p(dp[i + 1][j + 1], dp[i][j]);\n\t\t\t}\n\t\t\tif (i - j < rd) {\n\t\t\t\tdp[i + 1][j] = mod_p(dp[i + 1][j], dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n * 2][bl] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll Ten(int n){\n\treturn n==0?1:Ten(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n}\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\n//using mint=ModInt<1000000007>;\nusing mint=ModInt<998244353>;\n\nconst int Vmax=2000010;\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tstring s=readString();\n\tint n=s.size();\n\tvector<mint> cur(n+1,0),nx(n+1,0);\n\tcur[0]=1;\n\tREP(i,n){\n\t\tfill(ALL(nx),0);\n\t\tint b=s[i]-'0';\n\t\tREP(j,i+1){\n\t\t\tint x=j+b;\n\t\t\tint y=i-j+2-b;\n\t\t\tif(x>0){\n\t\t\t\tnx[x-1]+=cur[j];\n\t\t\t}\n\t\t\tif(y>0){\n\t\t\t\tnx[x]+=cur[j];\n\t\t\t}\n\t\t}\n\t\tswap(cur,nx);\n\t}\n\tmint ans=0;\n\tREP(i,n+1)\n\t\tans+=cur[i]*Choose(n,i);\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define inf 1e18\n#define mod 998244353\n\nusing namespace std;\n\nstring s;\nllint sumR[2005], sumB[2005];\nllint gateR[2005], gateB[2005];\nllint capR[4005], capB[4005];\nllint dp[4005][4005];\n\nint main(void)\n{\n\tcin >> s;\n\tint n = s.size();\n\ts = \"#\" + s;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tsumR[i] = sumR[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tgateR[i] = gateR[i-1];\n\t\tgateB[i] = gateB[i-1];\n\t\tif(s[i] == '0') sumR[i] += 2, gateR[i]++;\n\t\tif(s[i] == '1') sumR[i]++, sumB[i]++;\n\t\tif(s[i] == '2') sumB[i] += 2, gateB[i]++;\n\t}\n\t\n\tfor(int i = 0; i <= n; i++) capR[i] = capB[i] = inf;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(s[i] == '2') capR[gateB[i]-1] = min(capR[gateB[i]-1], sumR[i]);\n\t\tif(s[i] == '0') capB[gateR[i]-1] = min(capB[gateR[i]-1], sumB[i]);\n\t}\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tfor(int j = 0; j <= 2*n; j++){\n\t\t\tif(i < j) continue;\n\t\t\tdp[i][j] += dp[i-1][j], dp[i][j] %= mod;\n\t\t\tif(j > 0) dp[i][j] += dp[i-1][j-1], dp[i][j] %= mod;\n\t\t\tllint r = j, b = i-j;\n\t\t\tif(r > capR[b] || b > capB[r]) dp[i][j] = 0;\n\t\t}\n\t}\n\t\n\t//for(int i = 0; i <= n; i++) cout << capR[i] << \" \"; cout << endl;\n\t//for(int i = 0; i <= n; i++) cout << capB[i] << \" \"; cout << endl;\n\t\n\t/*for(int i = 0; i <= 2*n; i++){\n\t\tfor(int j = 0; j <= 2*n; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tllint Rsum = sumR[n];\n\tcout << dp[2*n][Rsum] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nlong mo(long n){\n\t\treturn n%998244353;\n\t}\nvoid vl(const char& a,int& r,int& b){\n\tif(a=='0'){r+=2;}\n\telse if(a=='1'){r++;b++;}\n\telse if(a=='2'){b+=2;}\n\telse{}\n}\n\nint main(){//F\n\tstring s;\n\tconst int c=2001;\n\tcin>>s;\n\tint le=s.length();\n\tlong liba[2*c+1][2*c]={};//[i][j]iはi番目の箱jは赤個数\n\tliba[0][0]=1;\n\tint va[c*2][2]={};\n\tfor(int i=0;i<le;i++){\n\t\tvl(s[i],va[i][0],va[i][1]);\n\t\tif(i>0){\n\t\t\tva[i][0]+=va[i-1][0];\n\t\t\tva[i][1]+=va[i-1][1];\n\t\t}\n\t}\n\tfor(int i=0;i<le;i++)\n\t{\n\t\tva[le+i][0]=va[le+i-1][0];\n\t\tva[le+i][1]=va[le+i-1][1];\n\t}\n\tfor(int i=0;i<(2*le);i++)\n\t{\n\t\tfor(int j=0;j<2*le;j++)\n\t\t\t{\t\n\t\t\t\tif((j<=va[i][0])&&(i-j+1<=va[i][1])&&(i-j+1>=0))\n\t\t\t\t{\n\t\t\t\t\tliba[i+1][j]=mo(liba[i][j]+((j>0)?liba[i][j-1]:0));\n\t\t\t\t}\n\t\t\t}\n\t}\n\tlong cnt=0;\n\tfor(int i=0;i<le*2;i++)\n\t{\n\t\tcnt=mo(cnt+liba[le*2][i]);\n\t}\n\tcout<<cnt<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nconst int maxn = 2100;\nconst int mod = 998244353;\nchar z[maxn];\nint n;\nint prer[maxn*2];\nint dp[maxn*2][maxn*2];\nvoid work () {\n\tint i , j;\n\tscanf ( \"%s\" , z + 1 );\n\tn = strlen ( z + 1 );\n\tfor ( i = 1 ; i <= n ; i++ ) prer[i] = prer[i-1] + (2-z[i]+'0');\n\tfor ( i = n + 1 ; i <= n + n ; i++ ) prer[i] = prer[i-1];\n\tdp[0][0] = 1;\n\tfor ( i = 0 ; i < n * 2 ; i++ ) {\n\t\tfor ( j = 0 ; j <= i ; j++ ) {\n\t\t\tif ( j < prer[i+1] ) {\n\t\t\t\tdp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod;\n\t\t\t}\n\t\t\tif ( i - j < i * 2 + 2 - prer[i+1] ) {\n\t\t\t\tdp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod;\n\t\t\t}\n\t\t\t//printf ( \"%d %d %d\\n\" , i , j , dp[i][j] );\n\t\t}\n\t}\n\tprintf ( \"%d\\n\" , dp[n*2][prer[n*2]] );\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,a[2010];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll iv[2010]={};\nll inv(ll x){\n  if(iv[x]<1) iv[x]=pwr(x,MOD-2);\n  return iv[x];\n}\n\nll nC[2010]={1};\nll comb(ll r){\n  if(nC[r]==0) nC[r]=mlt(comb(r-1),mlt(n-r+1,inv(r)));\n  return nC[r];\n}\n\nint main(){\n  n=0;\n  ll R=0,B=0,r=0,b=0;\n  char c;\n  for(;cin>>c;){\n    a[n]=c-'0';\n    if(a[n]<1) R+=2;\n    else if(a[n]<2){R++;B++;}\n    else B+=2;\n    n++;\n  }\n  ll dp[2010][2010]={};\n  fr(i,n+1) dp[0][i]=1;\n  fr(i,n){\n    if(a[i]<1) r+=2;\n    else if(a[i]<2){r++;b++;}\n    else b+=2;\n    fr(j,n+1){\n      ll k=i-j;\n      if(k<0) break;\n      if(r-j>0) dp[i+1][j+1]=ad(dp[i+1][j+1],dp[i][j]);\n      if(b-k>0) dp[i+1][j]=ad(dp[i+1][j],dp[i][j]);\n    }\n  }\n  ll ans=0;\n  fr(j,n+1) if(R>=j) ans=ad(ans,mlt(dp[n][j],comb(R-j)));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1ll << 50;\nconst int MOD = 998244353;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\n#define asn ans\nbool dbg = false;\ntemplate <uint MD>\nstruct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1)\n                r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n    friend istream& operator>>(istream& is, M& r) { return is >> r.v; }\n};\nusing Mint = ModInt<MOD>;\nint N;\nstring S;\nMint dp[4020][4020];\nint b[4040];\nint r[4040];\n\nvoid solve() {\n    dp[0][0] = 1;\n\n    itn cb = 0, cr = 0;\n    FOR(4020) {\n        if (i < N) {\n            if (S[i] == 2) {\n                cb += 2;\n            } else if (S[i] == 1) {\n                cb++;\n                cr++;\n            } else if (S[i] == 0)\n                cr += 2;\n        }\n        if (cb) {\n            b[i + 1] = b[i] + 1;\n            cb--;\n        } else {\n            b[i + 1] = b[i];\n        }\n        if (cr) {\n            r[i + 1] = r[i] + 1;\n            cr--;\n        } else {\n            r[i + 1] = r[i];\n        }\n    }\n\n    FOR(i, 1, N * 2 + 1) {\n        // cerr << i << \" : \" << b[i] << \" \" << r[i] << endl;\n        FOR(cnt_b, 0, i + 1) {\n            if (cnt_b <= b[i] && cnt_b > 0) {\n                dp[i][cnt_b] += dp[i - 1][cnt_b - 1];\n            }\n            if (i - cnt_b <= r[i] && i - cnt_b > 0) {\n                dp[i][cnt_b] += dp[i - 1][cnt_b];\n            }\n            //cerr << i << \" \" << cnt_b << \" : \" << dp[i][cnt_b] << endl;\n        }\n    }\n    Mint ans = 0;\n    FOR(2 * N + 1) {\n        ans += dp[N * 2][i];\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> S;\n    for (auto& c : S)\n        c -= '0';\n    N = S.size();\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=998244353LL;\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    vector<int> r(n);\n    vector<int> b(n);\n    for(int i=0;i<n;i++){\n        if(s[i]=='0') r[i]=2;\n        else if(s[i]=='1') r[i]=b[i]=1;\n        else b[i]=2;\n    }\n\n    vector<ll> sumr(n+1);\n    vector<ll> sumb(n+1);\n    for(int i=0;i<n;i++){\n        sumr[i+1]=sumr[i]+r[i];\n        sumb[i+1]=sumb[i]+b[i];\n    }\n    vector<vector<ll>> dp(2*n+1,vector<ll>(2*n+1));\n    dp[0][0]=1;\n    for(int i=0;i<2*n;i++){\n        for(int j=0;j<2*n;j++){\n            if(sumr[min(i+j+1,n)]>=i+1){\n                dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n            }\n            if(sumb[min(i+j+1,n)]>=j+1){\n                dp[i][j+1]=(dp[i][j+1]+dp[i][j])%MOD;\n            }\n        }\n    }\n    \n    cout<<dp[sumr[n]][sumb[n]]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\t\nint dp[4005][4005]={};\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tint n=s.size();\n\t\n\tint red=0,blue=0;\n\t\n\tdp[0][0]=1;\n\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t\tif(i<=n)\n\t\t{\n\t\t\tblue+=s[i-1]-'0';\n\t\t\tred=i*2-blue;\n\t\t}\n\n\t\tfor(int j=max(0,i-blue);j<=red;j++)\n\t\t{\n\t\t\tdp[i][j]=((j!=0 ? dp[i-1][j-1]:0)+(dp[i-1][j]))%998244353;\n\n\t\t}\n\t\n\t}\n\n\tcout << dp[2*n][red] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nconst LLI mod = 998244353;\n\nLLI dp[4100][4100];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  while(cin >> s){\n    int n = s.size();\n\n    fill_array(dp,0);\n\n    vector<int> r(2*n+1), b(2*n+1);\n    REP(i,n){\n      switch(s[i]){\n      case '0':\n\tr[i+1] = r[i] + 2;\n\tb[i+1] = b[i];\n\tbreak;\n      case '1':\n\tr[i+1] = r[i] + 1;\n\tb[i+1] = b[i] + 1;\n\tbreak;\n      case '2':\n\tr[i+1] = r[i];\n\tb[i+1] = b[i] + 2;\n\tbreak;\n      }\n    }\n    FOR(i,n,2*n){\n      r[i+1] = r[i];\n      b[i+1] = b[i];\n    }\n\n    dp[0][0] = 1;\n\n    REP(i,2*n){\n      REPE(j,2*n){\n\tif(i+1 < j) continue;\n\tif(j <= r[i+1] && i+1-j<=b[i+1]){\n\t  (dp[i+1][j] += dp[i][j-1]) %= mod;\n\t  (dp[i+1][j] += dp[i][j]) %= mod;\n\t}\n      }\n    }\n\n    \n    cout << dp[2*n][r[n]] << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tstatic const ULL M = 998244353;\n\n\tvoid Solve() {\n\t\tstring S; cin >> S;\n\t\tUL N = S.size();\n\t\tdeque<ULL> F = { 1 };\n\t\trep(i, N) {\n\t\t\tif (S[i] == '0') { F.push_front(0); F.push_front(0); }\n\t\t\tif (S[i] == '1') { F.push_front(0); F.push_back(0); }\n\t\t\tif (S[i] == '2') { F.push_back(0); F.push_back(0); }\n\t\t\trep(j, F.size() - 1) F[j] = (F[j] + F[j + 1]) % M;\n\t\t\tF.pop_back();\n\t\t}\n\t\trep(i, N) {\n\t\t\trep(j, F.size() - 1) F[j] = (F[j] + F[j + 1]) % M;\n\t\t\tF.pop_back();\n\t\t}\n\t\tcout << F[0] << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\nbool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\nbool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tmodInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tmodInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\toperator int()const { return value; }\n\tmodInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tmodInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tmodInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tmodInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tmodInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tmodInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tmodInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tmodInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4000+10;\nconst int MOD=998244353;\nint n,r[N],b[N];\nchar s[N];\nint f[N][N];  //前i个球中有 j个蓝球 i-j个红球 \n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor (int i=1;i<=n;i++) {\n\t\tif (s[i]=='0') r[i]=2;\n\t\tif (s[i]=='1') { r[i]=1; b[i]=1; }\n\t\tif (s[i]=='2') b[i]=2;\n\t\tr[i]+=r[i-1]; b[i]+=b[i-1];\n\t}\n\t\n\tmemset(f,0,sizeof(f)); f[0][0]=1; \n\tfor (int i=0;i<2*n;i++)\n\t\tfor (int j=0;j<=i;j++) {\n\t\t\tif (!f[i][j]) continue;\n\t\t\tif (j+1<=b[min(i+1,n)]) f[i+1][j+1]=(f[i+1][j+1]+f[i][j])%MOD;\n\t\t\tif (i-j+1<=r[min(i+1,n)]) f[i+1][j]=(f[i+1][j]+f[i][j])%MOD;\n\t\t}\n\tcout<<f[2*n][b[n]];\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n#define MOD 998244353\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tint n = s.size();\n\t\n\tstd::vector<int> fastest;\n\t{\n\t\tint cnt[n][2];\n\t\tfor (int i = 0; i < n; i++) cnt[i][0] = s[i] - '0', cnt[i][1] = 2 - cnt[i][0];\n\t\tstd::vector<int> res;\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tif (cnt[0][0]) cnt[0][0]--, res.push_back(0);\n\t\t\telse if (cnt[0][1]) cnt[0][1]--, res.push_back(1);\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif (cnt[j][0]) cnt[j][0]--, cnt[j - 1][0]++;\n\t\t\t\telse if (cnt[j][1]) cnt[j][1]--, cnt[j - 1][1]++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; i++) if (res[i] == 0) fastest.push_back(i);\n\t}\n\tstd::vector<int> latest;\n\t{\n\t\tint cnt[n][2];\n\t\tfor (int i = 0; i < n; i++) cnt[i][0] = s[i] - '0', cnt[i][1] = 2 - cnt[i][0];\n\t\tstd::vector<int> res;\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tif (cnt[0][1]) cnt[0][1]--, res.push_back(1);\n\t\t\telse if (cnt[0][0]) cnt[0][0]--, res.push_back(0);\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif (cnt[j][1]) cnt[j][1]--, cnt[j - 1][1]++;\n\t\t\t\telse if (cnt[j][0]) cnt[j][0]--, cnt[j - 1][0]++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; i++) if (res[i] == 0) latest.push_back(i);\n\t}\n\tint sz = fastest.size();\n\tint dp[2 * n + 2];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0] = 1;\n\tfor (int i = 0; i < sz; i++) {\n\t\tint new_dp[2 * n + 2];\n\t\tmemset(new_dp, 0, sizeof(new_dp));\n\t\tfor (int j = 0; j < 2 * n; j++) {\n\t\t\tnew_dp[std::max(j, fastest[i]) + 1] += dp[j];\n\t\t\tif (new_dp[std::max(j, fastest[i]) + 1] >= MOD) new_dp[std::max(j, fastest[i]) + 1] -= MOD;\n\t\t\tnew_dp[latest[i] + 2] += MOD - dp[j];\n\t\t\tif (new_dp[latest[i] + 2] >= MOD) new_dp[latest[i] + 2] -= MOD;\n\t\t}\n\t\tfor (int j = 0; j < 2 * n; j++) {\n\t\t\tnew_dp[j + 1] += new_dp[j];\n\t\t\tif (new_dp[j + 1] >= MOD) new_dp[j + 1] -= MOD;\n\t\t}\n\t\tmemcpy(dp, new_dp, sizeof(dp));\n\t}\n\tstd::cout << std::accumulate(dp, dp + 2 * n + 1, 0LL) % MOD << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\ntypedef unsigned int uint;\nusing namespace std;\n\nconst ll mod = 998244353LL;\nll red[4005], blue[4005], dp[4005][4005];\n\nint main() {\n    string s;\n    cin >> s;\n    int len = s.size();\n    for (int i = 0; i < len; i++) {\n        red[i+1] = red[i] + 2 - (s[i] - '0');\n        blue[i+1] = blue[i] + (s[i] - '0');\n    }\n\n    dp[0][0] = 1;\n    for (int i = 1; i <= 2 * len; i++) {\n        dp[i][0] = dp[i-1][0] * (blue[min(len, i)] >= i);\n        for (int j = 1; j <= i; j++) {\n            // 合計i個並べたときに、赤をj個を使っている場合の数\n            dp[i][j] = (dp[i-1][j] * (blue[min(len, i)] >= i-j) + dp[i-1][j-1] * (red[min(len, i)] >= j)) % mod;\n        }\n    }\n\n    cout << dp[2*len][red[len]] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 4020;\nconst int mod = 998244353;\nchar s[maxn];\nint f[maxn][maxn];\nint red[maxn];\nint blue[maxn];\nint len;\nint solve(int r, int b){\n\tif(r + b == 2*len) return 1;\n\tif(f[r][b] != -1) return f[r][b];\n\tint i = min(r + b, len - 1);\n\tint bb = blue[i], rr = red[i];\n\tbb -= b; rr -= r;\n\tint ans = 0;\n\tif(bb) ans += solve(r, b + 1);\n\tif(rr) ans += solve(r + 1, b);\n\tif(ans >= mod) ans -= mod;\n\treturn f[r][b] = ans;\n}\nint main(){\n\tscanf(\"%s\", s);\n\tlen = strlen(s);\n\tfor(int i = 0; i < len; i++) {\n\t\tif(s[i] == '0') red[i] = 2;\n\t\tif(s[i] == '1') red[i] = 1, blue[i] = 1;\n\t\tif(s[i] == '2') blue[i] = 2;\n\t}\n\tfor(int i = 1; i < len; i++){\n\t\tred[i] += red[i - 1];\n\t\tblue[i] += blue[i - 1];\n\t}\n\tmemset(f, -1, sizeof(f));\n\tprintf(\"%d\\n\", solve(0, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000000\n#define infll 1000000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define mod 998244353\n#define N 2009\nusing namespace std;\n\nint n,dp[N][N],cbn[N][N]; char s[N];\nint read(){\n\tint x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\nll readll(){\n\tll x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (; y; y>>=1,x=(ll)x*x%mod) if (y&1) ans=(ll)ans*x%mod;\n\treturn ans;\n}\nint calc(int x,int y){\n\tif (y==1 || y==5) return x;\n\tif (y==2 || y==4) return x==0?2:(x&1);\t\n\treturn x&1^1;\n}\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tint i,j,x=0,y=0;\n\tdp[0][0]=1;\n\tfor (i=1; i<=n; i++){\n\t\tx+=s[i]-'0'; y+='2'-s[i];\n\t\tfor (j=0; j<=x; j++){\n\t\t\tif (j) ad(dp[i][j],dp[i-1][j-1]);\n\t\t\tif (i-j<=y) ad(dp[i][j],dp[i-1][j]);\t\n\t\t}\n\t}\n\tfor (i=0; i<=n; i++)\n\t\tfor (j=cbn[i][0]=1; j<=i; j++)\n\t\t\tcbn[i][j]=(cbn[i-1][j]+cbn[i-1][j-1])%mod;\n\tint ans=0;\n\tfor (i=0; i<=n; i++)\n\t\tad(ans,(ll)dp[n][i]*cbn[n][x-i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst ll MOD = 998244353;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\nstring s;\nvi can_r, can_b;\nll dp[4444][4444];\n\nll solve(int p, int cntr)\n{\n\tif (dp[p][cntr] >= 0) return dp[p][cntr];\n\tif (p == n * 2) return 1;\n\tll res = 0;\n\tint r = can_r[p] - cntr;\n\tint b = can_b[p] - (p - cntr);\n\tif (r > 0) res += solve(p + 1, cntr + 1);\n\tif (b > 0) res += solve(p + 1, cntr);\n\treturn dp[p][cntr] = res % MOD;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> s;\n\tn = s.size();\n\tMS(dp, -1);\n\tcan_r.resize(n * 2);\n\tcan_b.resize(n * 2);\n\tcan_r[0] = s[0] - '0';\n\tREP(i, n - 1) can_r[i + 1] = can_r[i] + (s[i + 1] - '0');\n\tREP(i, n) can_b[i] = 2 * (i + 1) - can_r[i];\n\tFOR(i, n, n * 2)\n\t{\n\t\tcan_r[i] = can_r[i - 1];\n\t\tcan_b[i] = can_b[i - 1];\n\t}\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type alias\ntypedef long long LL;\ntypedef pair<int,int> II;\ntypedef tuple<int,int,int> III;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef unordered_map<int,int> MAPII;\ntypedef unordered_set<int> SETI;\ntemplate<class T> using VV=vector<vector<T>>;\n// minmax\ntemplate<class T> inline T SMIN(T& a, const T b) { return a=(a>b)?b:a; }\ntemplate<class T> inline T SMAX(T& a, const T b) { return a=(a<b)?b:a; }\n// repetition\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define REPE(i,n)  for(int i=0;i<=(n);++i)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define FORR(x,arr) for(auto& x:arr)\n#define SZ(a) int((a).size())\n// collection\n#define ALL(c) (c).begin(),(c).end()\n// DP\n#define MINUS(dp) memset(dp, -1, sizeof(dp))\n#define ZERO(dp) memset(dp, 0, sizeof(dp))\n// stdout\n#define println(args...) fprintf(stdout, ##args),putchar('\\n');\n// debug cerr\ntemplate<class Iter> void __kumaerrc(Iter begin, Iter end) { for(; begin!=end; ++begin) { cerr<<*begin<<','; } cerr<<endl; }\nvoid __kumaerr(istream_iterator<string> it) { (void)it; cerr<<endl; }\ntemplate<typename T, typename... Args> void __kumaerr(istream_iterator<string> it, T a, Args... args) { cerr<<*it<<\"=\"<<a<<\", \",__kumaerr(++it, args...); }\ntemplate<typename S, typename T> std::ostream& operator<<(std::ostream& _os, const std::pair<S,T>& _p) { return _os<<\"{\"<<_p.first<<','<<_p.second<<\"}\"; }\n#define __KUMATRACE__ true\n#ifdef __KUMATRACE__\n#define dump(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); __kumaerr(_it, args); }\n#define dumpc(ar) { cerr<<#ar<<\": \"; FORR(x,(ar)) { cerr << x << ','; } cerr << endl; }\n#define dumpC(beg,end) { cerr<<\"~\"<<#end<<\": \"; __kumaerrc(beg,end); }\n#else\n#define dump(args...)\n#define dumpc(ar)\n#define dumpC(beg,end)\n#endif\n\nconst int MOD=998244353;\nstruct ModInt {\n  unsigned int val;\n  ModInt(): val(0) {}\n  ModInt(int v) { norm(v%MOD); }\n  ModInt(long long v) { norm(v%MOD); }\n  ModInt& norm(long long v) {\n    v=v<0?v%MOD+MOD:v; // negative\n    v=v>=MOD?v-MOD:v; // mod\n    val=(unsigned int)v;\n    return *this;\n  }\n  explicit operator bool() const { return val!=0; }\n  ModInt operator-() const { return ModInt(0)-*this; }\n  ModInt &operator+=(ModInt that) { return norm((long long)val+that.val); }\n  ModInt &operator-=(ModInt that) { return norm((long long)val-that.val); }\n  ModInt &operator*=(ModInt that) { val=(unsigned long long)val*that.val%MOD; return *this; }\n  ModInt &operator/=(ModInt that) { return *this*=that.inv(); }\n  ModInt operator+(ModInt that) const { return ModInt(*this)+=that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this)-=that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this)*=that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this)/=that; }\n  ModInt pow(long long n) const {\n    ModInt x=*this, res=1;\n    while(n>0) {\n      if(n&1) res*=x;\n      x*=x,n>>=1;\n    }\n    return res;\n  }\n  ModInt inv() const { return (*this).pow(MOD-2); }\n  bool operator==(ModInt that) const { return val==that.val; }\n  bool operator!=(ModInt that) const { return val!=that.val; }\n  friend ostream& operator<<(ostream& os, const ModInt& that) { return os<<that.val; }\n};\n\n// $ cp-batch Pass | diff Pass.out -\n// $ g++ -std=c++14 -Wall -O2 -D_GLIBCXX_DEBUG -fsanitize=address Pass.cpp && ./a.out\n\n/*\n \n 3/4/2019\n \n 9:43-\n \n */\n\nconst int MAX_N=1e4+1;\nstring S;\nint N;\n\nModInt dp[MAX_N][MAX_N];\nint cum[2][MAX_N];\nvoid solve() {\n  N=SZ(S);\n//  dump(S);\n  cum[0][0]=cum[1][0]=0;\n  REP(i,N) {\n    int cnt[2]={0};\n    if(S[i]=='0') cnt[0]=2;\n    if(S[i]=='1') cnt[0]=cnt[1]=1;\n    if(S[i]=='2') cnt[1]=2;\n    REP(c,2) cum[c][i+1]=cum[c][i]+cnt[c];\n//    dump(i,cum[0][i+1],cum[1][i+1]);\n  }\n  REP(i,N)REP(c,2) cum[c][i+N+1]=cum[c][N];\n//  dump(cum[0][2],cum[1][2]);\n  \n  dp[0][0]=1;\n  REP(i,2*N)REP(k,2*N) {\n    int r=cum[0][i+1]-k,b=cum[1][i+1]-(i-k);\n    if(r>0) dp[i+1][k+1]+=dp[i][k];\n    if(b>0) dp[i+1][k]+=dp[i][k];\n  }\n  cout<<dp[2*N][cum[0][N]]<<endl;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout<<setprecision(12)<<fixed;\n  \n  cin>>S;\n  solve();\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 998244353\n\nint n, hv[2005];\nchar x[2005];\nlong long ncr[4005][4005], dp[2005][2005], ans;\n\nint main() {\n\tfor (int i = 0; i < 4005; i++) {\n\t\tncr[i][0] = ncr[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tncr[i][j] = ncr[i - 1][j - 1] + ncr[i - 1][j];\n\t\t\tif (ncr[i][j] >= MOD)\n\t\t\t\tncr[i][j] -= MOD;\n\t\t}\n\t}\n\tscanf(\"%s\", x);\n\tn = strlen(x);\n\tfor (int i = 0; i < n; i++)\n\t\thv[i + 1] = hv[i] + (x[i] - '0');\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = max(0, hv[i + 1] - i - 1); j <= min(i + 1, hv[i + 1]); j++) {\n\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\tif (j) {\n\t\t\t\tdp[i + 1][j] += dp[i][j - 1];\n\t\t\t\tif (dp[i + 1][j] >= MOD)\n\t\t\t\t\tdp[i + 1][j] -= MOD;\n\t\t\t}\n\t\t}\n\tfor (int i = max(0, hv[n] - n); i <= min(n, hv[n]); i++)\n\t\tans = (ans + dp[n][i] * ncr[n][hv[n] - i]) % MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n12001021211100201020\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=4005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=998244353;\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nint dp[maxn]; //idx = count of '1'\nint tmp[maxn];\nint main()\n{\n\tIOS;\n\tstring s;\n\tcin>>s;\n\tdp[0]=1;\n\n\tint cnt1=0,cnt2=0;\n\n\tfor(int i=0;i<SZ(s)+SZ(s);i++){\n\t\tif(i<SZ(s)){\n\t\t\tif(s[i]=='0'){\n\t\t\t\tcnt1+=2;\n\t\t\t}\n\t\t\telse if(s[i]=='1'){\n\t\t\t\t++cnt1;\n\t\t\t\t++cnt2;\n\t\t\t}\n\t\t\telse cnt2+=2;\n\t\t}\n\t\tREP(j,maxn) tmp[j]=0;\n\t\tfor(int j=0;j<maxn;j++){\n\t\t\tif(j<cnt1) tmp[j+1]+=dp[j];\n\n\t\t\tif(i-j<cnt2) tmp[j]+=dp[j];\n\t\t}\n\t\tREP(j,maxn) dp[j]=tmp[j]%MOD;\n\n\t\t//REP(j,10) cout<<dp[j]<<\" \\n\"[j==9];\n\t}\n\tcout<<dp[cnt1]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\nint p = 998244353;\nint M = 0x7777777777777777777777777;\nint N;\nint rok[4096];\nint bok[4096];\nint dp[4096][4096];\n\nint solve(int r, int b) {\n\tif(r+b==0) {\n\t\treturn 1;\n\t}\n\tif(!dp[r][b]) {\n\t\tint ret = 0;\n\t\tif(r<=rok[r+b] && b<=bok[r+b]) {\n\t\t\tif(r) {\n\t\t\t\tret += solve(r-1, b);\n\t\t\t}\n\t\t\tif(b) {\n\t\t\t\tret += solve(r, b-1);\n\t\t\t}\n\t\t\tif(p<=ret) {\n\t\t\t\tret -= p;\n\t\t\t}\n\t\t}\n\t\tdp[r][b] = ret ^ M;\n\t}\n\treturn dp[r][b] ^ M;\n}\n\nint main() {\n\tchar S[2048];\n\tscanf(\"%s\", S);\n\tint halfN = strlen(S);\n\tN = halfN+halfN;\n\tint rsum = 0;\n\tint bsum = 0;\n\t{\n\t\tint lateR = 0;\n\t\tint lateB = 0;\n\t\tfor(int n=0; n<halfN; ++n) {\n\t\t\trok[n] = rsum;\n\t\t\tbok[n] = bsum;\n\t\t\trsum += lateR;\n\t\t\tbsum += lateB;\n\t\t\tif(S[n]=='0') {\n\t\t\t\t++rsum;\n\t\t\t\tlateR = 1;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse if(S[n]=='1') {\n\t\t\t\t++rsum;\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++bsum;\n\t\t\t\tlateR = 0;\n\t\t\t\tlateB = 1;\n\t\t\t}\n\t\t}\n\t\trsum += lateR;\n\t\tbsum += lateB;\n\t\tfor(int n=halfN; n<N+2; ++n) {\n\t\t\trok[n] = rsum;\n\t\t\tbok[n] = bsum;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", solve(rsum, bsum));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\t  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\t  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n  using value_type = ::std::uint_fast64_t;\n  value_type n;\npublic:\n  ModInt() : n(0) {}\n  ModInt(value_type n_) : n(n_ % mod) {}\n  ModInt(const ModInt& m) : n(m.n) {}\n\n  template<typename T>\n  explicit operator T() const { return static_cast<T>(n); }\n  value_type get() const { return n; }\n\n  friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n    return os << a.n;\n  }\n\n  friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n    value_type x;\n    is >> x;\n    a = ModInt<mod>(x);\n    return is;\n  }\n\n  bool operator==(const ModInt& m) const { return n == m.n; }\n  bool operator!=(const ModInt& m) const { return n != m.n; }\n  ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n  ModInt pow(value_type b) const{\n    ModInt ans = 1, m = ModInt(*this);\n    while(b){\n      if(b & 1) ans *= m;\n      m *= m;\n      b >>= 1;\n    }\n    return ans;\n  }\n\n  ModInt inv() const { return (*this).pow(mod-2); }\n  ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n  ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n  ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n  ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n  ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n  ModInt& operator++(){ n += 1; return *this; }\n  ModInt& operator--(){ n -= 1; return *this; }\n  ModInt operator++(int){\n    ModInt old(n);\n    n += 1;\n    return old;\n  }\n  ModInt operator--(int){\n    ModInt old(n);\n    n -= 1;\n    return old;\n  }\n  ModInt operator-() const { return ModInt(mod-n); }\n};\n\ntemplate<::std::size_t size, ::std::uint_fast64_t mod=1000000007>\nclass Factorial{\nprivate:\n  using value_type = ModInt<mod>;\n  ::std::vector<value_type> fact, inv;\npublic:\n  Factorial() : fact(size+1, 1), inv(size+1, 1){\n    for(::std::size_t i = 1; i <= size; ++i){\n      fact[i] = fact[i-1] * value_type(i);\n      inv[i] = fact[i].inv();\n    }\n  }\n\n  value_type comb(::std::int64_t a, ::std::int64_t b){\n    assert(a >= b);\n    assert(b >= 0);\n    return fact[a]*inv[b]*inv[a-b];\n  }\n\n  value_type& operator[](::std::size_t k){ return fact[k]; }\n};\n\nconstexpr int64 mod = 998244353;\nusing Mint = ModInt<mod>;\nFactorial<11234, mod> f;\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string S;\n  cin >> S;\n  auto dp = make_v<Mint>(S.size()+1, S.size()+1); // dp[i][j] := iまで見て赤がj個残っている\n  dp[0][0] = 1;\n\n  int64 N = S.size();\n  REP(i, N) {\n    REP(j, i+1) {\n      int64 r = j, b = i-j;\n      if (S[i] == '0') r += 2;\n      else if (S[i] == '1') {r += 1; b += 1;}\n      else b += 2;\n      if (r > 0)\n        dp[i+1][r-1] += dp[i][j];\n      if (b > 0)\n        dp[i+1][r] += dp[i][j];\n    }\n  }\n  Mint res = 0;\n  REP(i, N+1) {\n    res += dp[N][i] * f.comb(N, i);\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\ntemplate<class Int> constexpr bool is_prime(Int n) {\n  if (n < 2 or n > 2 and ~n & 1) return false;\n  for (Int i = 3; i * i <= n; i += 2) if (n % i == 0) return false;\n  return true;\n}\ntemplate<uint P> struct ModInt {\n  static_assert(is_prime(P), \"template argument must be a prime number\");\n  using M = ModInt;\n  uint v;\n  ModInt() : v(0) {}\n  template<class Int> ModInt(Int x) : v(x >= 0 ? x % P : -x % P ? P - -x % P : 0) {}\n  constexpr ModInt(uint v, int _) : v(v) {} // 直接値を初期化\n  static constexpr uint p() { return P; }\n  M operator++(int) { M t = *this; if (++v == P) v = 0; return t; }\n  M operator--(int) { M t = *this; v = (v ? v : P) - 1; return t; }\n  M& operator++() { if (++v == P) v = 0; return *this; }\n  M& operator--() { v = (v ? v : P) - 1; return *this; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !static_cast<bool>(*this); }\n  M operator*(M rhs) const { return M(*this) *= rhs; }\n  M operator/(M rhs) const { return M(*this) /= rhs; }\n  M operator+(M rhs) const { return M(*this) += rhs; }\n  M operator-(M rhs) const { return M(*this) -= rhs; }\n  bool operator==(M rhs) { return v == rhs.v; }\n  bool operator!=(M rhs) { return !(*this == rhs); }\n  M& operator*=(M rhs) { v = (ulint) v * rhs.v % P; return *this; }\n  M& operator/=(M rhs) { return *this *= rhs.inv(); }\n  M& operator+=(M rhs) { v = rhs.v < P - v ? v + rhs.v : v - (P - rhs.v); return *this; }\n  M& operator-=(M rhs) { v = rhs.v <= v ? v - rhs.v : v + (P - rhs.v); return *this; }\n  M inv() const {\n    assert(v);\n    #ifdef __linux__ // ACとCFで動作を変えるための仮の対処\n      return pow(P - 2);\n    #else\n      int a = v, b = P, x = 1, u = 0;\n      while (b) {\n        int q = a / b;\n        swap(a -= q * b, b);\n        swap(x -= q * u, u);\n      }\n      return x;\n    #endif\n  }\n  template<class Int> M pow(Int n) const {\n    n = n >= 0 ? n % (P - 1) : P - 1 - -n % (P - 1);\n    M res = 1;\n    for (M a = *this; n > 0; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Int> friend M operator*(Int lhs, M rhs) { return M(lhs) *= rhs; }\n  template<class Int> friend M operator/(Int lhs, M rhs) { return M(lhs) /= rhs; }\n  template<class Int> friend M operator+(Int lhs, M rhs) { return M(lhs) += rhs; }\n  template<class Int> friend M operator-(Int lhs, M rhs) { return M(lhs) -= rhs; }\n  friend ostream& operator<<(ostream& os, M rhs) { return os << rhs.v; }\n  friend istream& operator>>(istream& is, M& rhs) { lint x; is >> x; rhs = x; return is; }\n  template<class Int> friend bool operator==(Int lhs, M rhs) { return M(lhs) == rhs; }\n  template<class Int> friend bool operator!=(Int lhs, M rhs) { return !(lhs == rhs); }\n};\nusing Mint = ModInt<998244353>;\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  string s; cin >> s;\n  int n = s.size();\n  V<> cb(n + 1), cr(n + 1);\n  for (int i = 0; i < n; ++i) {\n    cb[i + 1] = cb[i] + (s[i] - '0');\n    cr[i + 1] = cr[i] + ('2' - s[i]);\n  }\n\n  VV<Mint> dp; assign(dp, cb[n] + 1, cr[n] + 1, 0);\n  dp[0][0] = 1;\n  for (int b = 0; b <= cb[n]; ++b) for (int r = 0; r <= cr[n]; ++r) {\n    int i = min(b + r + 1, n);\n    if (cb[i] - b > 0) dp[b + 1][r] += dp[b][r];\n    if (cr[i] - r > 0) dp[b][r + 1] += dp[b][r];\n  }\n\n  cout << dp[cb[n]][cr[n]] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nll MOD = 998244353;\n\nstring S;\n\nint thres[2][2020], N, R, B;\nll dp[4040][4040];\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> S;\n    N = S.size();\n\n    for (int i = 1; i <= N; ++i) {\n        thres[0][i] = thres[0][i-1] + 2 - (S[i-1] - '0');\n        thres[1][i] = thres[1][i-1] + (S[i-1] - '0');\n    }\n    R = thres[0][N]; B = thres[1][N];\n\n    dp[0][0] = 1;\n    for (int w = 1; w <= 2*N; ++w) {\n        int rM = w <= N ? thres[0][w] : R;\n        for (int r = 0; r <= rM; ++r) {\n            int b = w - r;\n            if (b > (w <= N ? thres[1][w] : B)) continue;\n            if (r > 0) (dp[r][b] += dp[r-1][b]) %= MOD;\n            if (b > 0) (dp[r][b] += dp[r][b-1]) %= MOD;\n        }\n    }\n\n    cout << dp[R][B] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\n\nconst int N = 5e3 + 10;\nchar s[N];\nint dp[N][N];\nint A[N], B[N];\nint n;\n\nint solve(int x, int y, int step) {\n  if (x + y == 2 * n) return 1;\n  step = min(step, n);\n  int& ret = dp[x][y];\n  if (ret >= 0) return ret;\n  ret = 0;\n  // trace(x, y, step, A[step], B[step]);\n  if (A[step] > x) ret = (ret + solve(x + 1, y, step + 1)) % MOD;\n  if (B[step] > y) ret = (ret + solve(x, y + 1, step + 1)) % MOD;\n  // trace(x, y, ret);\n  return ret;\n}\n\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '0') {\n      A[i + 1] = A[i] + 2;\n      B[i + 1] = B[i];\n    } else if (s[i] == '1') {\n      A[i + 1] = A[i] + 1;\n      B[i + 1] = B[i] + 1;\n    } else {\n      A[i + 1] = A[i];\n      B[i + 1] = B[i] + 2;\n    }\n  }\n  memset(dp, 255, sizeof(dp));\n  int ret = solve(0, 0, 1);\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nconst int MOD=998244353;\nint dp[5000][5000];\nint sum[5000],sum2[5000];\n\nint main(){\n\tstring s;cin>>s;\n\trep(i,s.size()*2){\n\t\tif(i)sum[i]+=sum[i-1],sum2[i]+=sum2[i-1];\n\t\tif(i<s.size()){\n\t\t\tint d=s[i]-'0';\n\t\t\tsum[i]+=d;sum2[i]+=2-d;\n\t\t}\n\t}\n\tdp[0][0]=1;\n\trep(i,s.size()*2)rep(j,sum[s.size()]+1){\n\t\tif(!dp[i][j])continue;\n\t\tif(j+1<=sum[i]){\n\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t}\n\t\tif(i-j+1<=sum2[i]){\n\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t}\n\t}\n\tcout<<dp[s.size()*2][sum[s.size()]]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 998244353;\n\nll dp[4010][4010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  cin >> s;\n  ll n = s.size();\n\n  vector<ll> r, b;\n  REP(i, n) {\n    if(s[i] == '0') { r.push_back(i); r.push_back(i); }\n    else if(s[i] == '1') { r.push_back(i); b.push_back(i); }\n    else { b.push_back(i); b.push_back(i); }\n  }\n\n  dp[0][0] = 1;\n  REP(i, r.size()+1) REP(j, b.size()+1) {\n    // x回目の操作で取れるのはx人目が持ってるボールまで\n    if(i<r.size() && r[i]<=i+j) (dp[i+1][j] += dp[i][j]) %= MOD;\n    if(j<b.size() && b[j]<=i+j) (dp[i][j+1] += dp[i][j]) %= MOD;\n  }\n  cout << dp[r.size()][b.size()] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nconst int MOD=998244353;\nint dp[5000][5000];\nint sum[5000],sum2[5000];\n\nint main(){\n\tstring s;cin>>s;\n\trep(i,s.size()*2){\n\t\tif(i)sum[i]+=sum[i-1],sum2[i]+=sum2[i-1];\n\t\tif(i<s.size()){\n\t\t\tint d=s[i]-'0';\n\t\t\tsum[i]+=d;sum2[i]+=2-d;\n\t\t}\n\t}\n\tdp[0][0]=1;\n\trep(i,s.size()*2)rep(j,s.size()+1){\n\t\tif(!dp[i][j])continue;\n\t\tif(j+1<=sum[i]){\n\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t}\n\t\tif(i-j+1<=sum2[i]){\n\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t}\n\t}\n\tcout<<dp[s.size()*2][sum[s.size()]]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n//const ll mod = 1000000007;\nconst ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nll dp[4040][4040];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  dp[0][0] = 1;\n\n  string s;\n  cin >> s;\n\n  int n = s.length(), r = 0, b = 0, resr = 0, resb = 0;\n  rep(i, n) {\n    if (s[i] == '0') r += 2;\n    else if (s[i] == '1') r++, b++;\n    else b += 2;\n  }\n  FOR(i, 1, 2 * n + 1) {\n    rep(j, i + 1) {\n      int k = i - j;\n      if (j > r || k > b) continue;\n      if (j) dp[j][k] = (dp[j][k] + dp[j - 1][k]) % mod;\n      if (k) dp[j][k] = (dp[j][k] + dp[j][k - 1]) % mod;\n    }\n    if (i <= n) continue;\n    if (s[2 * n - i] == '0') resr += 2;\n    else if (s[2 * n - i] == '1') resr++, resb++;\n    else resb += 2;\n    rep(j, resr) dp[j][i - j] = 0;\n    rep(j, resb) dp[i - j][j] = 0;\n  }\n  cout << dp[r][b] << '\\n';\n  \n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os;}\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p) {os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\nvector<ll> fact;\nint N;\nconst int mod = 998244353;\n\nll mod_pow(ll x, ll n, ll mod) {\n    ll res = 1;\n    while(n > 0) {\n        if(n & 1) res = res * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n    }\n    return res;\n}\n\nll inv(int k) {\n    return mod_pow(k, mod - 2, mod);\n}\n\nll comb(ll n, ll r) {\n    return ((fact[n] * inv(fact[r]) % mod) * inv(fact[n - r])) % mod;\n}\n\nvoid init() {\n    fact.resize(10000);\n    fact[0] = 1;\n    for (int i = 1; i < 10000; i++) {\n        fact[i] = fact[i - 1] * i;\n        fact[i] %= mod;\n    }\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    N = s.size();\n    init();\n    vector<vector<int>> dp(N + 1, vector<int>(N + 1));\n    dp[0][0] = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (!dp[i][j]) continue;\n            int k = i - j;\n            int pj = 0, pk = 0;\n            if (s[i] == '0') pj = 2;\n            else if (s[i] == '1') {pj = 1; pk = 1;}\n            else {pk = 2;}\n\n            if (j - 1 + pj >= 0) {\n                dp[i + 1][j - 1 + pj] += dp[i][j];\n                dp[i + 1][j - 1 + pj] %= mod;\n            } \n            if (k - 1 + pk >= 0) {\n                dp[i + 1][j + pj] += dp[i][j];\n                dp[i + 1][j + pj] %= mod;\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int j = 0; j <= N; j++) {\n        ans += dp[N][j] * comb(N, j);\n        ans %= mod;\n    }\n    cout << ans << endl;\n    \n}\n\nint main() {\n    #ifdef LOCAL_ENV\n    cin.exceptions(ios::failbit);\n    #endif\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    \n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = (int)4010;\nconst int MOD = 998244353;\nint dp[N][N];\nint c1[N];\nint c2[N];\n\nvoid add(int &a, int b){\n  a += b;\n  if(a >= MOD)\n    a -= MOD;\n}\n\nint main(){\n  fastIO;\n  string t;\n  cin >> t;\n  int n = t.size();\n  for(int i = 0; i < n; i ++ ){\n    if(t[i]=='1')c1[i]=1,c2[i]=1;\n    else if(t[i]=='2')c1[i]=2;\n    else c2[i]=2;\n    if(i>0) c1[i] += c1[i - 1], c2[i] += c2[i - 1];\n  }\n  for(int i = n; i < 2 * n; i ++ )\n    c1[i] += c1[i - 1], c2[i] += c2[i - 1];\n  dp[0][0]=1;\n  for(int i = 0; i < 2 * n; i ++ ){\n    for(int j = 0 ; j <= i; j ++ ){\n      if(dp[i][j]==0)continue;\n      if(j<c1[i]){\n        add(dp[i + 1][j + 1], dp[i][j]);\n      }\n      if(i-j<c2[i]){\n        add(dp[i + 1][j], dp[i][j]);\n      }\n    }\n  }\n  int ans = 0;\n  for(int i = 0 ; i <= 2 * n; i ++ )\n    add(ans, dp[2 * n][i]);\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\n\nconst int N = 2010;\nint cou[2*N + 1][2];\nll dp[2*N + 1][2*N + 1];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring str;\n\tcin >> str;\n\tint n = str.size();\n\n\t// Snuke always picks some ball, at most from layer L, where L is the current turn.\n\t// After L is large enough, he can pick any ball\n\n\t// so we have N conditions, saying\n\t// \"no more than I blue balls can be picked in the first K rounds\" or same for red\n\n\t// DP[N][K]: How many sequences exist where N balls have been picked, K of which\n\t// have been blue\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint v = (str[i] - '0');\n\t\tcou[i+1][0] = cou[i][0] + (2-v);\n\t\tcou[i+1][1] = cou[i][1] + v;\n\t}\n\tfor (int i = n; i < 2*n; ++i) {\n\t\tcou[i+1][0] = cou[i][0];\n\t\tcou[i+1][1] = cou[i][1];\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2*n; ++i) {\n\t\tfor (int j = 0; j <= min(i, cou[i][1]); ++j) {\n\t\t\tint r = i - j;\n\t\t\tif (r > cou[i][0]) continue;\n\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t} else {\n\t\t\t\tdp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;\n\t\t\t}\n\t\t}\n\t\t// cout << i << ' ' << cou[i][0] << ' ' << cou[i][1] << '\\n';\n\t\t// cout << dp[i][0] << ' ' << dp[i][1] << ' ' << dp[i][2] << ' ' << dp[i][3] << '\\n';\n\t}\n\n\tll res = 0;\n\tfor (int i = 0; i <= 2*n; ++i) res += dp[2*n][i];\n\tres %= MOD;\n\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int mod=998244353;\n\nlong C[2001][2001];\n\nlong comb(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tC[i][j]%=mod;\n\t\t}\n\t\tC[i][i]=1;\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tint n=s.length();\n\tint red[n]={};\n\tred[0]=(s[0]=='0'?2:s[0]=='1'?1:0);\n\tfor(int i=1;i<n;i++) red[i]+=red[i-1]+(s[i]=='0'?2:s[i]=='1'?1:0);\n\t\n\tlong dp[2*n+1][2*n+1]={};\n\tdp[1][0]=(s[0]!='0'?1:0);\n\tdp[1][1]=(s[0]!='2'?1:0);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=max(0,red[i-1]-i);j<=min(i,red[i-1]);j++){\n\t\t\tdp[i][j]=(dp[i-1][j]+(j!=0?dp[i-1][j-1]:0))%mod;\n\t\t}\n\t}\n\tcomb(n);\n\tlong ans=0;\n\tfor(int i=0;i<=red[n-1];i++){\n\t\tans+=dp[n][i]*C[n][red[n-1]-i]%mod;\n\t\tans%=mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll mod = 998244353;\n\nconst int N = 4004;\nll dp[N][N];\nint f[N];\nint main(){\n    f[0] = 0;\n    for(int i=1; i<N; ++i) f[i] = f[i-1]+i;\n\n    string s;\n    cin >>s;\n\n    int n = s.size();\n\n    vector<int> r,b;\n    rep(i,n){\n        if(s[i]=='0') rep(j,2) r.pb(i);\n        else if(s[i]=='1'){\n            r.pb(i);\n            b.pb(i);\n        }\n        else rep(j,2) b.pb(i);\n    }\n\n    int R = r.size(), B = b.size();\n\n    rep(i,R-1) r[i+1] = max(r[i+1], r[i]+1);\n    rep(i,B-1) b[i+1] = max(b[i+1], b[i]+1);\n\n    dp[0][0] = 1;\n    rep(i,2*n)rep(rr,R+1)if(dp[i][rr]>0){\n        int bb = i-rr;\n\n        if(rr<R && r[rr]<=i){\n            (dp[i+1][rr+1] += dp[i][rr]) %= mod;\n        }\n        if(bb<B && b[bb]<=i){\n            (dp[i+1][rr] += dp[i][rr]) %= mod;\n        }\n    }\n\n    cout << dp[2*n][R] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\nconst double PI = acos(-1);\n\n\ntemplate<int64_t mod>\nclass modint {\n    int64_t x;\n\npublic:\n    modint(int64_t x = 0) : x(x < 0 ? ((x % mod) + mod) % mod : x % mod) {}\n\n    const modint operator-() const { return x == 0 ? 0 : mod - x; }\n\n    modint& operator+=(const modint& rhs) {\n        if ((x += rhs.x) >= mod) x -= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (x *= rhs.x) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.pow(mod - 2);\n    }\n\n    friend const modint operator+(modint lhs, const modint& rhs) {\n        return lhs += rhs;\n    }\n    friend const modint operator-(modint lhs, const modint& rhs) {\n        return lhs -= rhs;\n    }\n    friend const modint operator*(modint lhs, const modint& rhs) {\n        return lhs *= rhs;\n    }\n    friend const modint operator/(modint lhs, const modint& rhs) {\n        return lhs /= rhs;\n    }\n\n    const modint pow(int64_t n) const {\n        modint ret = 1, tmp = *this;\n        while (n) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.x == rhs.x;\n    }\n    friend bool operator!=(const modint& lhs, const modint& rhs) {\n        return lhs.x != rhs.x;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.x;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        int64_t tmp; is >> tmp; a = tmp;\n        return is;\n    }\n};\n\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    string s; cin >> s;\n    int n = s.size();\n\n    using Int = modint<998244353>;\n\n    vector<vector<Int>> dp(2*n+1, vector<Int>(2*n+1));\n\n    dp[0][0] = 1;\n\n    for (int i = 0; i < n; ++i) {\n        for (int r = 0; r <= 2*n; ++r) {\n            if (dp[i][r] == 0) continue;\n            int b = i - r;\n            if (s[i] == '0') {\n                dp[i+1][r+1] += dp[i][r];\n                if (b > 0) dp[i+1][r+2] += dp[i][r];\n            }\n            if (s[i] == '1') {\n                dp[i+1][r] += dp[i][r];\n                dp[i+1][r+1] += dp[i][r];\n            }\n            if (s[i] == '2') {\n                if (r > 0) dp[i+1][r-1] += dp[i][r];\n                dp[i+1][r] += dp[i][r];\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int r = 0; r <= 2*n; ++r) {\n            if (dp[i+n][r] == 0) continue;\n            int b = n - i - r;\n            if (r > 0) dp[i+1+n][r-1] += dp[i+n][r];\n            if (b > 0) dp[i+1+n][r] += dp[i+n][r];\n        }\n    }\n\n    cout << dp[2*n][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\n\nstring str;\nint n;\n\nll dp[4005][4005];\n\nint main(){\n  cin>>str;\n  n=str.size();\n  dp[0][0]=1;\n\n  ll cnt=0;\n  for(int i=0;i<n*2;i++){\n\n    if(i<n)cnt+=2;\n    \n    for(int j=0;j<=i*2;j++){\n      if(dp[i][j]==0)continue;\n      ll R=j;\n      if(str[i]=='0'){\n        R+=2;\n      }else if(str[i]=='1'){\n        R++;\n      }\n      ll B=cnt-R;\n      if(R>0){\n        int nj=j;\n        if(R==j+2)nj++;\n        if(R==j)nj--;\n        dp[i+1][nj]+=dp[i][j];\n        dp[i+1][nj]%=mod;\n      }\n      \n      if(B>0){\n        int nj=j;\n        if(R==j+2)nj+=2;\n        if(R==j+1)nj++;\n        dp[i+1][nj]+=dp[i][j];\n        dp[i+1][nj]%=mod;\n      }\n    }\n    \n\n    cnt--;\n  }\n  /*\n  for(int i=0;i<=n*2;i++){\n    for(int j=0;j<=n*2;j++){\n      printf(\"%02d \",(int)dp[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  cout<<dp[2*n][0]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(a) (a).begin(), (a).end()\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\n#define RREP(i, n) for(int (i)=(n)-1; (i)>=0; (i)--)\n#define ios() cin.tie(0), ios::sync_with_stdio(false)\ntypedef long long ll;\ntypedef unsigned long long ull;\nll const MOD = 998244353;\nll const INF = 1e18;\nusing namespace std;\n\nclass Combination{\n    private:\n        ll N;\n        ll mod;\n        vector<ll> factorial;\n\n    public:\n        Combination(ll n, ll m) : N(n), mod(m), factorial(n+1){\n            factorial.at(0) = 1;\n            for(ll i=1; i<=N; i++){\n                factorial.at(i) = i * factorial.at(i-1) % mod;\n            }\n        }\n\n        ll POW(ll a, ll b){\n            ll ans = 1;\n            while(b > 0){\n                if(b & 1){\n                    ans = ans*a % mod;\n                }\n                a = a*a % mod;\n                b >>= 1;\n            }\n            return ans;\n        }\n\n        ll combin(ll n, ll k){\n            if(k < 0 || n < k){\n                return 1;\n            }\n            return factorial.at(n) * POW(factorial.at(k)*factorial.at(n-k)%mod, mod-2)%mod;\n        }\n};\n\nint main(){\n    string s;\n    cin >> s;\n\n    int n = s.length();\n    \n    vector<ll> red(n+1, 0);\n    REP(i, n){\n        int c = 2 - (s[i] - '0');\n        red[i+1] = red[i] + c;\n    }\n\n    vector<vector<ll>> dp(n+1, vector<ll>(n+1,0));\n    dp[0][0] = 1;\n\n    REP(i, n){\n        REP(j, n){\n            if(red[i+1] >= j+1){\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= MOD;\n            }\n            if(2*(i+1) - red[i+1] >= i + 1 - j){\n                dp[i+1][j] += dp[i][j];\n                dp[i+1][j] %= MOD;\n            }\n        }\n    }\n\n    Combination C(n, MOD);\n    ll ans = 0;\n\n    REP(i, n+1){\n        ans += dp[n][i] * C.combin(n, red[n] - i) % MOD;\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\nll dp[4001][4001];\nvoid solve(string S){\n    ll r,b;\n    r=b=0;\n    dp[0][0]=1;\n    REP((int)S.size()*2){\n        if(i<(int)S.size()){\n            if(S[i]=='0'){\n                r+=2;\n            }else if(S[i]=='1'){\n                r++;b++;\n            }else{\n                b+=2;\n            }\n        }\n        For(j,i+1){\n            if(j+1<=r&&i-j<=b){\n                dp[j+1][i-j]+=dp[j][i-j];\n                dp[j+1][i-j]%=MOD;\n            }\n            if(j<=r&&i-j+1<=b){\n                dp[j][i-j+1]+=dp[j][i-j];\n                dp[j][i-j+1]%=MOD;\n            }\n        }\n    }\n    cout<<dp[r][b]<<endl;\n}\n\nint main(){\n    string S;\n    cin>>S;\n    solve(S);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nll n,rnum,bnum;\nbool f[4005][4005],g[4005][4005];\nll dp[4005][4005]={0};\nconst ll mod=998244353;\nvoid need_red(vector<ll> vec){\n  vector<ll> need_num(4005,0);\n  ll pos=1,num=0;\n  for(int i=0;i<vec.size();i++){\n    if(vec[i]==0) num++;\n    else if(vec[i]==1){\n      need_num[pos]=num;\n      pos++;\n    }\n    else{\n      need_num[pos]=num;\n      pos++;\n      need_num[pos]=num;\n      pos++;\n    }\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++) f[i][j]=false;\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++){\n      if(j>=need_num[i]) f[i][j]=true;\n    }\n  }\n}\nvoid need_blue(vector<ll> vec){\n  vector<ll> need_num(4005,0);\n  ll pos=1,num=0;\n  for(int i=0;i<vec.size();i++){\n    if(vec[i]==0) num++;\n    else if(vec[i]==1){\n      need_num[pos]=num;\n      pos++;\n    }\n    else{\n      need_num[pos]=num;\n      pos++;\n      need_num[pos]=num;\n      pos++;\n    }\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++) g[i][j]=false;\n  }\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++){\n      if(i>=need_num[j]) g[i][j]=true;\n    }\n  }\n}\nint main(){\n  string s;\n  cin>>s;\n  n=s.length();\n  rnum=0;\n  bnum=0;\n  vector<ll> rball,bball;\n  for(int i=0;i<n;i++){\n    if(s[i]=='0') {\n      rball.push_back(2);\n      bball.push_back(0);\n      rnum+=2;\n    }\n    else if(s[i]=='1'){\n      rball.push_back(1);\n      bball.push_back(1);\n      rnum++; bnum++;\n    }\n    else{\n      rball.push_back(0);\n      bball.push_back(2);\n      bnum+=2;\n    }\n  }\n  need_red(rball);\n  need_blue(bball);\n  dp[0][0]=1;\n  for(int i=0;i<=rnum;i++){\n    for(int j=0;j<=bnum;j++){\n      dp[i][j]%=mod;\n      if(i<rnum){\n        if(f[i][j]&&g[i][j]&&f[i+1][j]) dp[i+1][j]+=dp[i][j];\n        dp[i+1][j]%=mod;\n      }\n      if(j<bnum){\n        if(f[i][j]&&g[i][j]&&g[i][j+1]) dp[i][j+1]+=dp[i][j];\n        dp[i][j+1]%=mod;\n      }\n    }\n  }\n  cout<<dp[rnum][bnum]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[4005][4005];\nint tot[2005][2];\nconst int mod=998244353;\n\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif      \n\n    string a;\n    cin>>a;\n    int n=a.length();\n    dp[0][0]=1;\n    a=\"#\"+a;\n    for(int i=1;i<=n;i++)\n    {\n        tot[i][0]=tot[i-1][0];\n        tot[i][1]=tot[i-1][1];\n        if(a[i]=='0')\n            tot[i][0]+=2;\n        else if(a[i]=='1')\n        {\n            tot[i][0]++;\n            tot[i][1]++;\n        }\n        else\n        {\n            tot[i][1]+=2;\n        }        \n    }\n\n    for(int i=0;i<=tot[n][0];i++)\n    {\n        for(int j=0;j<=tot[n][1];j++)\n        {\n            if(i+j==0)\n                continue;\n            if(i>0)\n            {\n                int z=i+j;\n                z=min(z,n);\n                if(tot[z][0]>=i)\n                {\n                    dp[i][j]+=dp[i-1][j];\n                }\n            }\n            if(j>0)\n            {\n                int z=i+j;\n                z=min(z,n);\n                if(tot[z][1]>=j)\n                {\n                    dp[i][j]+=dp[i][j-1];\n                }\n            }\n            dp[i][j]%=mod;\n        }\n    }\n    cout<<dp[tot[n][0]][tot[n][1]];\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fec(i, x, y) (int i = head[x], y = g[i].to; i; i = g[i].ne, y = g[i].to)\n#define dbg(...) fprintf(stderr, __VA_ARGS__)\n#define File(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n#define fi first\n#define se second\n#define pb push_back\n\ntemplate<typename A, typename B> inline char SMAX(A &a, const B &b) {return a < b ? a = b , 1 : 0;}\ntemplate<typename A, typename B> inline char SMIN(A &a, const B &b) {return b < a ? a = b , 1 : 0;}\n\ntypedef long long ll; typedef unsigned long long ull; typedef std::pair<int, int> pii;\n\ntemplate<typename I>\ninline void read(I &x) {\n\tint f = 0, c;\n\twhile (!isdigit(c = getchar())) c == '-' ? f = 1 : 0;\n\tx = c & 15;\n\twhile (isdigit(c = getchar())) x = (x << 1) + (x << 3) + (c & 15);\n\tf ? x = -x : 0;\n}\n\nconst int N = 1000 + 7;\nconst int P = 998244353;\n\nint n, cntb[N], dp[N << 1][N << 1];\nchar s[N];\n\ninline void Inc(int &x, int y) {x += y; x >= P ? x -= P : 0;}\n\nint main() {\n\t#ifdef hzhkk\n\tfreopen(\"hkk.in\", \"r\", stdin);\n\t#endif\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tfor (int i = 1; i <= n; ++i) cntb[i] = cntb[i - 1] + s[i] - '0';\n\tfor (int i = n + 1; i <= (n << 1); ++i) cntb[i] = cntb[i - 1];\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= (n << 1); ++i) {\n\t\tfor (int j = std::max(cntb[i] - i, 0); j <= std::min(cntb[i], i); ++j) {\n\t\t\tif (j) dp[i][j] = dp[i - 1][j - 1];\n\t\t\tif (i > j) Inc(dp[i][j], dp[i - 1][j]);\n\t\t\t//  dbg(\"dp[%d][%d] = %d\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n << 1][cntb[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<utility>\n\n#define int long long\nusing namespace std;\n#define rep(i, n) for(int i=0;i<(n);++i)\ntypedef pair<int, int> pii;\nconst int INF = 1l << 60;\n#define u_b upper_bound\n#define l_b lower_bound\n\nconst int mod = 998244353;\nconst int FacN = 0;//使わないなら0\n\nconstexpr int power(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1)res *= a;\n        a *= a;\n        res %= mod;\n        a %= mod;\n        b /= 2;\n    }\n    return res;\n}\n\nconstexpr int inv(int x) {\n    return power(x, mod - 2);\n}\n\nconst struct Fac {\n    int val[FacN];\n\n    constexpr Fac() : val() {\n        if (FacN == 0)return;\n        val[0] = 1;\n        for (int i = 1; i < FacN; ++i) val[i] = val[i - 1] * i % mod;\n    }\n\n    const int &operator[](size_t i) const {\n        return val[i];\n    }\n} fac;\n\nconst struct FacInv {\n    int val[FacN];\n\n    constexpr FacInv() : val() {\n        if (FacN == 0)return;\n        val[FacN - 1] = 1;\n        for (int i = 1; i < FacN; ++i)val[FacN - 1] = val[FacN - 1] * i % mod;\n        val[FacN - 1] = inv(val[FacN - 1]);\n        for (int i = FacN - 1; i >= 1; --i)val[i - 1] = val[i] * i % mod;\n    }\n\n    const int &operator[](size_t i) const {\n        return val[i];\n    }\n} fac_inv;\n\nint Perm(int n, int r) {\n    return fac[n] * fac_inv[n - r] % mod;\n}\n\nint Comb(int n, int r) {\n    return Perm(n, r) * fac_inv[r] % mod;\n}\n//mod,Factorial書き換え\n\nint dp[4040][4040];\nstring S;\n\nsigned main() {\n    cin >> S;\n    int red = 0, blue = 0;\n    dp[0][0] = 1;\n    rep(i, 2 * S.size()) {\n        if (i < S.size()) {\n            if (S[i] == '0')red += 2;\n            else if (S[i] == '1') {\n                red += 1;\n                blue += 1;\n            } else blue += 2;\n        }\n        rep(j, 4040) {\n            if (i + 1 < j)break;\n            if (j == 0) {\n                dp[i + 1][j] = (dp[i][j] && blue - (i + 1 - j) >= 0);\n            } else {\n                if (red - j >= 0) {\n                    dp[i + 1][j] += dp[i][j - 1];\n                }\n                if (blue - (i + 1 - j) >= 0) {\n                    dp[i + 1][j] += dp[i][j];\n                }\n                dp[i + 1][j] %= mod;\n            }\n        }\n    }\n    cout << dp[2 * S.size()][red] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nstring s;\nvi a,b;\n\nint main(){\n\tcin>>s;\n\tn=s.size();\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='0'){\n\t\t\ta.push_back(i);\n\t\t\ta.push_back(i);\n\t\t}\n\t\tif(s[i]=='1'){\n\t\t\ta.push_back(i);\n\t\t\tb.push_back(i);\n\t\t}\n\t\tif(s[i]=='2'){\n\t\t\tb.push_back(i);\n\t\t\tb.push_back(i);\n\t\t}\n\t}\n\tint h=a.size(),w=b.size();\n\tvvi dp(h+1,vi(w+1));\n\tdp[0][0]++;\n\tfor(int i=0;i<=h;i++) for(int j=0;j<=w;j++){\n\t\tif(i<h&&a[i]<=(lower_bound(a.begin(),a.end(),a[i])-a.begin())+min(j,(int)(lower_bound(b.begin(),b.end(),a[i])-b.begin()))) (dp[i+1][j]+=dp[i][j])%=mod;\n\t\tif(j<w&&b[j]<=min(i,(int)(lower_bound(a.begin(),a.end(),b[j])-a.begin()))+(lower_bound(b.begin(),b.end(),b[j])-b.begin())) (dp[i][j+1]+=dp[i][j])%=mod;\n\t}\n\tcout<<dp[h][w]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 4010;\nconst int moder = 998244353;\n\nint dp[N][N];\nchar s[N];\nint a[N], idr[N], idb[N];\n\nvoid add(int &a, int b){a += b; a -= a >= moder ? moder : 0;}\n\nint main(){\n    scanf(\"%s\", s);\n    int n = strlen(s);\n    for (int i = 1; i <= n; ++ i){\n        a[i] = s[i - 1] - '0';\n    }\n    int cntr = 0, cntb = 0;\n    memset(idr, -1, sizeof(idr));\n    memset(idb, -1, sizeof(idb));\n    for (int i = 1; i <= n; ++ i){\n        for (int j = 0; j < 2 - a[i]; ++ j){\n            idr[++ cntr] = i;\n        }\n        for (int j = 0; j < a[i]; ++ j){\n            idb[++ cntb] = i;\n        }\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= 2 * n; ++ i){\n        for (int j = 0; j <= i - 1; ++ j){\n            if (!dp[i - 1][j]) continue;\n            int x = j + 1;\n            if (idr[x] != -1 && idr[x] <= i){\n                add(dp[i][j + 1], dp[i - 1][j]);\n            }\n            x = (i - 1 - j) + 1;\n            if (idb[x] != -1 && idb[x] <= i){\n                add(dp[i][j], dp[i - 1][j]);\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[2 * n][cntr]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0) (__VA_ARGS__)\n#define rep_0(i, end) for (int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for (int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg_0, arg_1, arg_2, name, ...) name\n#define all(box) box.begin(), box.end()\n \ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if (lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if (lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\ntemplate <int MODULUS = 1000000007>\nstruct modulo_int {\nprivate:\n\n  long long value;\n  constexpr void normalize() {\n    value %= MODULUS;\n    if (value < 0) value += MODULUS;\n  }\n\npublic:\n\n  constexpr modulo_int(const long long& value_ = 0) : value(value_) { normalize(); }\n  constexpr modulo_int operator - () const { return modulo_int(MODULUS - value); }\n  constexpr modulo_int operator ~ () const { return power(MODULUS - 2); }\n  constexpr const long long& operator () () const { return value; }\n\n  constexpr modulo_int operator + (const modulo_int& rhs) const { return modulo_int(*this) += rhs; }\n  constexpr modulo_int& operator += (const modulo_int& rhs) {\n    if ((value += rhs.value) >= MODULUS) value -= MODULUS;\n    return (*this);\n  }\n\n  constexpr modulo_int operator - (const modulo_int& rhs) const { return modulo_int(*this) -= rhs; }\n  constexpr modulo_int& operator -= (const modulo_int& rhs) {\n    if ((value += MODULUS - rhs.value) >= MODULUS) value -= MODULUS;\n    return (*this);\n  }\n\n  constexpr modulo_int operator * (const modulo_int& rhs) const { return modulo_int(*this) *= rhs; }\n  constexpr modulo_int& operator *= (const modulo_int& rhs) {\n    (value *= rhs.value) %= MODULUS;\n    return (*this);\n  }\n\n  constexpr modulo_int operator / (const modulo_int& rhs) const { return modulo_int(*this) /= rhs; }\n  constexpr modulo_int& operator /= (const modulo_int& rhs) {\n    return (*this) *= ~rhs;\n  }\n\n  constexpr modulo_int power (const long long& pow) const {\n    modulo_int result(1), mult(*this);\n    for (long long t = pow; t > 0; t >>= 1) {\n      if (t & 1) result *= mult;\n      mult *= mult;\n    }\n    return result;\n  }\n\n  friend std::istream& operator >> (std::istream& stream, modulo_int& lhs) {\n    stream >> lhs.value;\n    lhs.normalize();\n    return stream;\n  }\n\n  friend std::ostream& operator << (std::ostream& stream, const modulo_int& rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nconstexpr int mod = 998244353;\nusing modint = modulo_int<mod>;\n\nint N;\nint R[2001], B[2001];\nstd::string S;\nmodint dp[4001][4001];\n\nint main() {\n\n  std::cin >> S;\n  N = S.size();\n\n  rep (i, N) {\n    int r = S[i] - '0';\n    int b = 2 - r;\n    R[i + 1] += R[i] + r;\n    B[i + 1] += B[i] + b;\n  }\n\n  dp[0][0] = 1;\n  rep (i, 2 * N) {\n    int nowr = R[std::min(i + 1, N)];\n    int nowb = B[std::min(i + 1, N)];\n    rep (r, 0, nowr) {\n      int b = i - r;\n      if (nowr >= r + 1) {\n        dp[i + 1][r + 1] += dp[i][r];\n      }\n      if (nowb >= b + 1) {\n        dp[i + 1][r] += dp[i][r];\n      }\n    }\n  }\n\n  std::cout << dp[N * 2][R[N]] << '\\n';\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\nusing ll = long long;\nusing II = pair<int, int>; using VII = vector<II>; using VVII = vector<VII>;\nusing VI = vector<int>; using VVI = vector<VI>; using VVVI = vector<VVI>;\ntemplate <class T> using V = vector<T>; template <class T> using VV = V<V<T>>; template <class T> using VVV = V<VV<T>>;\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream &s, const pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 998244353;\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = (unsigned long long)x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = (unsigned long long)x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return pow(*this, MD - 2); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\nusing mint = ModInt<MOD>;\n\nsigned main() {\n  string s; cin >> s;\n  int n = s.size();\n  VI rs(2 * n + 1);\n  REP (i, 2 * n) {\n    if (i < n) {\n      rs[i + 1] = rs[i] + ('2' - s[i]);\n    } else {\n      rs[i + 1] = rs[i];\n    }\n  }\n  V<V<mint>> dp(2 * n + 1, V<mint>(2 * n + 1, -1));\n  function<mint(int, int)> dfs = [&](int i, int r) {\n    mint& ret = dp[i][r];\n    if (dp[i][r] != -1) return ret;\n    if (r > rs[i] || i - r > 2 * min(n, i) - rs[i]) {\n      ret = 0;\n    } else if (i == 2 * n) {\n      ret = 1;\n    } else {\n      ret = dfs(i + 1, r) + dfs(i + 1, r + 1);\n    }\n    return ret;\n  };\n  cout << dfs(0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int N=2001;\nchar s[N];\nint t[N];\ntypedef long long ll;\nint fac[N],inv[N],finv[N];\ntemplate<class T>inline void Inc(T&x,int y){x+=y;if(x>=mod) x-=mod;}\ninline int C(int n,int m){if(n<m) return 0;return (ll)fac[n]*finv[m]%mod*finv[n-m]%mod;}\nint n;\nint dp[N][N];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tint red=0,blue=0;fac[0]=finv[0]=1;inv[1]=1;\n\tfor(int i=2;i<=n;++i) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod,finv[i]=(ll)finv[i-1]*inv[i]%mod;\n\tfor(int i=1;i<=n;++i) t[i]=s[i]-'0';\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;++i) {\n\t\tif(t[i]==1) ++red,++blue;else if(t[i]==0) red+=2;else blue+=2;\n\t\tfor(int j=0;j<=red;++j){\n\t\t\tif(j>0) Inc(dp[i][j],dp[i-1][j-1]);\n\t\t\tif(i-j<=blue) Inc(dp[i][j],dp[i-1][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=red;++i) {int f=dp[n][i];Inc(ans,(ll)f*C(n,red-i)%mod);}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 2022, mod = 998244353;\n\nint n, dp[max_n][max_n], cnt[2][max_n];\nstring s;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> s;\n    n = s.length();\n    for (int i = 0; i < n; ++i) {\n        cnt[0][i] = s[i] - '0';\n        cnt[1][i] = 2 - cnt[0][i];\n        if (i) {\n            cnt[0][i] += cnt[0][i - 1];\n            cnt[1][i] += cnt[1][i - 1];\n        }\n    }\n    cnt[0][n] = cnt[0][n - 1];\n    cnt[1][n] = cnt[1][n - 1];\n    dp[0][0] = 1;\n    for (int i = 0; i < 2 * n; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (j + 1 <= cnt[0][min(i, n - 1)]) {\n                dp[i + 1][j + 1] += dp[i][j];\n                dp[i + 1][j + 1] %= mod;\n            }\n            if (i - j + 1 <= cnt[1][min(i, n - 1)]) {\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= mod;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[2 * n][cnt[0][n - 1]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\nint main(){\n\tstring s;\n\tcin>>s;\n\tint N = s.size();\n\tV<mint> dp(N+N+1);\n\tV<mint> ndp = dp;\n\tdp[0] = 1;\n\tint num0 = 0, num1 = 0;\n\trep(i,N+N){\n\t\tif(i<N){\n\t\t\tif(s[i]=='0') num0 += 2;\n\t\t\tif(s[i]=='1') num0++,num1++;\n\t\t\tif(s[i]=='2') num1 += 2;\n\t\t}\n\t\trep(i,N+N+1) ndp[i] = 0;\n\t\trep(use0,N+N+1) if(dp[use0]){\n\t\t\tV<int> left = {num0 - use0, num1 - (i-use0)};\n\t\t\trep(t,2) if(left[t]){\n\t\t\t\tndp[use0 + (t==0)] += dp[use0];\n\t\t\t}\n\t\t}\n\t\tdp = ndp;\n\t}\n\tcout << dp[num0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int mod = 998244353;\nchar s[2001];\nint c[4001][2];\nint dp[4001][4001];\n\nint main() {\n    int n, i, j;\n    \n    scanf(\"%s\", s);\n    \n    n = strlen(s);\n    \n    for (i = 0; i < n * 2; i++) {\n        c[i + 1][0] = c[i][0];\n        c[i + 1][1] = c[i][1];\n        \n        if (i >= n) continue;\n        \n        if (s[i] == '0') {\n            c[i + 1][0] += 2;\n        } else if (s[i] == '1') {\n            c[i + 1][0]++;\n            c[i + 1][1]++;\n        } else {\n            c[i + 1][1] += 2;\n        }\n    }\n    \n    dp[0][0] = 1;\n    \n    for (i = 0; i < n * 2; i++) {\n        for (j = 0; j < n * 2; j++) {\n            if (dp[i][j] == 0) continue;\n            \n            if (c[i + 1][0] >= j + 1) {\n                dp[i + 1][j + 1] += dp[i][j];\n                if (dp[i + 1][j + 1] >= mod) dp[i + 1][j + 1] -= mod;\n            }\n            if (c[i + 1][1] >= i - j + 1) {\n                dp[i + 1][j] += dp[i][j];\n                if (dp[i + 1][j] >= mod) dp[i + 1][j] -= mod;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", dp[n * 2][c[n * 2][0]]);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) FOR(i,0,n)\n#define ROF(i,a,b) for(ll i=a;i>=b;i--)\n#define per(i,a) ROF(i,a,0)\n#define pb push_back\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ch=char;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vP;\ntypedef vector<ch> vc;\ntypedef vector<vc> vvc;\nconst ll MOD=1000000007;\nconst ll MOD2=998244353;\nconst ld PI=acos(-1);\nconst ll INF=1e18;\nstruct edge{ll to,cost;};\nstruct edge2{ll from,to,cost;};\n\ntemplate <typename T>\nbool chmax(T &a, const T& b) {\n    if (a < b) {\n      a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T& b) {\n    if (a > b) {\n      a = b;\n      return true;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string S;\n    cin >> S;\n    ll N=S.size();\n    ll dp[2*N+1][2*N+1];//前から、青ボールの数\n    rep(i,2*N+1){\n        rep(j,2*N+1){\n            dp[i][j]=0;\n        }\n    }\n    vl acc(N+1,0),acc1(N+1,0);\n    rep(i,N){\n        acc[i+1]=acc[i]+(S[i]-'0');//青ボールの数\n        acc1[i+1]=acc1[i]+('2'-S[i]);//赤ボールの数\n    }\n    if(S[0]=='0'){\n        dp[1][0]=1;\n    }\n    else if(S[0]=='2'){\n        dp[1][1]=1;\n    }\n    else{\n        dp[1][0]=dp[1][1]=1;\n    }\n    FOR(i,2,N+1){\n        //可能なjは、なるべく赤~青全部取るのパターンがある\n        FOR(j,max((ll)0,i-acc1[i]),min(i+1,acc[i]+1)){\n            //cout << i << ' ' << j << endl;\n            if(j>0){\n                dp[i][j]+=dp[i-1][j-1];\n            }\n            dp[i][j]+=dp[i-1][j];\n            dp[i][j]%=MOD2;\n        }\n    }\n    FOR(i,N+1,2*N+1){\n        rep(j,2*N+1){\n            if(j>0){\n                dp[i][j]+=dp[i-1][j-1];\n            }\n            dp[i][j]+=dp[i-1][j];\n            dp[i][j]%=MOD2;\n        }\n    }\n    cout << dp[2*N][acc[N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 1\n\n/**\n * File    : F2.cpp\n * Author  : Kazune Takahashi\n * Created : 2/10/2019, 12:26:47 AM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 998244353;\nconst int MAX_SIZE = 1000010;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = ((MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    factinv[i] = (inv[i] * factinv[i - 1]) % MOD;\n  }\n}\n\nlong long C(int n, int k)\n{\n  if (n >= 0 && k >= 0 && n - k >= 0)\n  {\n    return ((fact[n] * factinv[k]) % MOD * factinv[n - k]) % MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n  else if (n % 2 == 1)\n  {\n    return (x * power(x, n - 1)) % MOD;\n  }\n  else\n  {\n    long long half = power(x, n / 2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcd(long long x, long long y)\n{\n  return y ? gcd(y, x % y) : x;\n}\n\nstring S;\nint N;\nll DP[2010][4010];\nint R[2010];\nint B[2010];\n\nint main()\n{\n  init();\n  cin >> S;\n  N = S.size();\n  for (auto i = 0; i < 4010; i++)\n  {\n    DP[0][i] = 0;\n  }\n  DP[0][0] = 1;\n  R[0] = B[0] = 0;\n  for (auto i = 1; i <= N; i++)\n  {\n    if (S[i - 1] == '0')\n    {\n      R[i] = R[i - 1] + 2;\n      B[i] = B[i - 1];\n    }\n    else if (S[i - 1] == '1')\n    {\n      R[i] = R[i - 1] + 1;\n      B[i] = B[i - 1] + 1;\n    }\n    else\n    {\n      R[i] = R[i - 1];\n      B[i] = B[i - 1] + 2;\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n#if DEBUG == 1\n    cerr << \"R[\" << i + 1 << \"] = \" << R[i + 1] << \", B[\" << i + 1 << \"] = \" << B[i + 1] << endl;\n#endif\n    for (auto j = 0; j <= i; j++)\n    {\n      if (DP[i][j] == 0)\n      {\n        continue;\n      }\n#if DEBUG == 1\n      cerr << \"DP[\" << i << \"][\" << j << \"] = \" << DP[i][j] << endl;\n#endif\n      int r = j;\n      int b = i - r;\n      if (R[i + 1] - r > 0)\n      {\n        DP[i + 1][j + 1] += DP[i][j];\n        DP[i + 1][j + 1] %= MOD;\n      }\n      if (B[i + 1] - b > 0)\n      {\n        DP[i + 1][j] += DP[i][j];\n        DP[i + 1][j] %= MOD;\n      }\n    }\n  }\n  ll ans = 0;\n  for (auto i = 0; i <= N; i++)\n  {\n    if (DP[N][i] == 0)\n    {\n      continue;\n    }\n    int r = i;\n    int b = N - i;\n    int res_r = R[N] - r;\n    int res_b = B[N] - b;\n    ans += (DP[N][i] * C(res_r + res_b, res_r)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n\n    vector<int> blue(n);\n    vector<int> red(n);\n    for(int i=0; i<n; ++i){\n        blue[i] = s[i] - '0';\n        red[i] = 2 - blue[i];\n    }\n\n    vector<int> dp(1, 1);\n    for(int i=0; i<2*n; ++i){\n        vector<int> nextDp = dp;\n        nextDp.resize(i+2, 0);\n        for(int j=0; j<=i; ++j){\n            nextDp[j+1] += dp[j];\n            nextDp[j+1] %= MOD;\n        }\n        for(int j=0; j<=i+1; ++j){\n            if(!(j <= blue.front() && i - j + 1 <= red.front()))\n                nextDp[j] = 0;\n        }\n        dp = move(nextDp);\n\n        for(int j=1; j<n; ++j){\n            if(blue[j] > 0){\n                -- blue[j];\n                ++ blue[j-1];\n            }\n            if(red[j] > 0){\n                -- red[j];\n                ++ red[j-1];\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<=2*n; ++i){\n        ans += dp[i];\n        ans %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tif(N == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(j,1,N){\n\t\t\tif(s[j] == 2){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t\tif(s[j] == 1 && j == 2*N-i){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\n#include <bitset>\nusing namespace std;\n#define N 4005\n#define ll long long\n#define mod 998244353\nchar s[N];int n,s1[N],s2[N],f[N][N];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ts1[i]=s1[i-1],s2[i]=s2[i-1];\n\t\tif(s[i]=='0')s1[i]+=2;\n\t\telse if(s[i]=='2')s2[i]+=2;\n\t\telse s1[i]++,s2[i]++;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tint t=min(i,n);\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j<=s1[t])(f[i][j]+=f[i-1][j-1])%=mod;\n\t\t\tif((i-j)<=s2[t])(f[i][j]+=f[i-1][j])%=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n*2][s1[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\ntypedef unsigned int uint;\nusing namespace std;\n\nconst ll mod = 998244353LL;\nstring s;\nll red[4005], blue[4005], dp[4005][4005];\n\nint main() {\n    cin >> s;\n    int len = s.size();\n    for (int i = 1; i <= len; i++) {\n        if (s[i-1] == '0') {\n            red[i] = red[i-1] + 2;\n            blue[i] = blue[i-1];\n        } else if (s[i-1] == '1') {\n            red[i] = red[i-1] + 1;\n            blue[i] = blue[i-1] + 1;\n        } else {\n            red[i] = red[i-1];\n            blue[i] = blue[i-1] + 2;\n        }\n    }\n\n    dp[0][0] = 1;\n    for (int i = 1; i <= 2 * len; i++) {\n        dp[i][0] = dp[i-1][0] * (blue[min(len, i)] >= i);\n        for (int j = 1; j <= i; j++) {\n            // 合計i個並べたときに、赤をj個を使っている場合の数\n            dp[i][j] = (dp[i-1][j] * (blue[min(len, i)] >= i-j) + dp[i-1][j-1] * (red[min(len, i)] >= j)) % mod;\n        }\n    }\n\n    ll ans = 0LL;\n    for (int i = 0; i <= 2 * len; i++) {\n        ans = (ans + dp[2 * len][i]) % mod;\n    }\n\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/2/10\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>>\n        vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<double> vd;\ntypedef vector<vector<double>> vvd;\ntypedef vector<vector<vector<double>>> vvvd;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, pair<int, int>> plii;\nconst int bigmod = 998244353;//1000000007;\nconst int INF = 1050000000;\nconst long long INFll = 100000000000000000;\n\n\n//足し算\nint add(int a, int b) {\n    return (int) (((ll) a + b + bigmod) % bigmod);\n}\n\n//引き算\nint sub(int a, int b) {\n    return (int) (((ll) a - b + bigmod) % bigmod);\n}\n\n//掛け算\nint mul(int a, int b) {\n    return (int) (((ll) (a % bigmod) * (b % bigmod)) % bigmod);\n}\n\nint modpow(int a, int b) {\n    if (b == 0) return 1;\n    int temp = modpow(a, b / 2);\n    if (b % 2 == 1) return mul(mul(temp, temp), a);\n    else {\n        return mul(temp, temp);\n    }\n}\n\n//割り算(分母だけ)  -  逆元(求めたい数とbigmodを渡す)\nint divide(int a, int p = bigmod, int b = -1) {\n    if (b < 0) b = p - 2;  //int gyakugen(int a, int p, int b = p - 2とできなかったため。)\n    if (b == 0) return 1;\n    else if (b % 2 == 0) {\n        int d = divide(a, p, b / 2);\n        return mul(d, d);\n    } else {\n        return mul(a, divide(a, p, b - 1));\n    }\n}\n\nvi fact;\n\n\n//nやkが大きな場合nCkをO(1)で求めるようにプログラムを適切に変更する。\nint nCk_gyakugen(int n, int k, int p = bigmod) {\n    if (k == 0) return 1;\n    if (n == 0) 0;\n    if (n < k) return 0;\n    int denominator = fact[n];\n    int molecule1 = fact[k];\n    int molecule2 = fact[n - k];\n    return mul(denominator, mul(divide(molecule1), divide(molecule2)));\n}\n\nint main() {\n    string S;\n    cin >> S;\n    unsigned int N = S.length();\n    fact = vi(N + 1);\n    fact[0] = 1;\n    FOR(i, 1, fact.size()) {\n        fact[i] = mul(fact[i - 1], i);\n    }\n    int R = 0, B = 0;\n    vvi dp(N + 1, vi(N + 1, 0));\n    dp[0][0] = 1;\n    rep(i, N) {\n        switch (S[i]) {\n            case '0':\n                R += 2;\n                break;\n            case '1':\n                R += 1;\n                B += 1;\n                break;\n            case '2':\n                B += 2;\n                break;\n            default:\n                break;\n        }\n        rep(j, N) {\n            if (j + 1 <= R) {\n                dp[i + 1][j + 1] = add(dp[i + 1][j + 1], dp[i][j]);\n            }\n            if ((i + 1) - j <= B) {\n                dp[i + 1][j] = add(dp[i + 1][j], dp[i][j]);\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, N + 1) {\n        ans = add(ans, mul(dp[N][i], nCk_gyakugen(N, R - i)));\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nconstexpr int64 P = 998244353;\n\nstruct FiniteField {\n private:\n  int64 x;\n  static inline int64 Normalize(int64 x) {\n    if (0 <= x && x < P) return x; x %= P; if (x < 0) x += P; return x;\n  }\n public:\n  FiniteField(int64 x) : x(Normalize(x)) {}\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nostream& operator<<(ostream& s, const FiniteField& v) { s << v.Value(); return s; }\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  string s;\n  cin >> s;\n  int n = s.length();\n  int b_sum = 0;\n  int r_sum = 0;\n  vector<FiniteField> current(2 * n + 1);\n  current[0] = 1;\n  for (int k = 0; k < 2 * n; k++) {\n    if (k < n) {\n      b_sum += s[k] - '0';\n      r_sum += 2 - (s[k] - '0');\n    }\n    vector<FiniteField> next(2 * n + 1);\n    for (int i = 0; i <= 2 * n; i++) {\n      int b_used = i;\n      int b_remain = b_sum - b_used;\n      int r_used = k - i;\n      int r_remain = r_sum - r_used;\n      if (b_remain > 0) {\n        next[i + 1] += current[i];\n      }\n      if (r_remain > 0) {\n        next[i] += current[i];\n      }\n    }\n    swap(current, next);\n  }\n  cout << current[b_sum] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint dp[4001][4001];\nint MOD = 998244353;\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s;\n    cin >> s;\n    int n = s.size();\n    for (int i=0; i <= 2*n; i++) for (int j=0; j <= 2*n;j++) dp[i][j] = 0;\n    dp[0][0] = 1;\n    for (int i=0; i < 2*n; i++){\n        for (int j=0; j <= 2*n; j++){\n            if (dp[i][j] == 0) continue;\n            //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n            int blue = min(2*i, 2*n) - i - j, red=j;\n            if (i < n){\n                blue += s[i] - '0';\n                red += 2 - (s[i]-'0');\n            }\n            if (blue > 0){\n                dp[i+1][red] += dp[i][j];\n                dp[i+1][red]%= MOD;\n            }\n            if (red>0){\n                dp[i+1][red-1] += dp[i][j];\n                dp[i+1][red-1] %= MOD;\n            }\n        }\n    }\n    cout << dp[2*n][0];\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n#define ll int\n#define rep(i,n) for(int (i)=0;(i)<(n);++i)\n#define rrep(i,n) for(int (i)=(n)-1;(i)>=0;--i)\n#define rep1(i,n) for(int (i)=1;(i)<=(n);++i)\n#define rrep1(i,n) for(int (i)=(n);(i)>=1;--i)\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> LP;\ntypedef double db;\nusing namespace std;\nstring s;\nll ans;\nll A[2001];\nll dp[4001][4001];\nll cnt=0;\nll mod = 998244353;\nll N,r,b;\nint main()\n{\n  cin>>s;\n  N=s.size();\n  rep(i,N){\n    A[i+1]=0;\n    if(s[i]=='1') A[i+1]=1;\n    else if(s[i]=='2') A[i+1]=2;\n  }\n  //rep1(i,N) cout<<A[i]<<endl;\n  //cout<<\"asd\"<<endl;\n  dp[0][0] = 1;\n  rep1(i,2*N){\n    if(i<=N) cnt+=2;\n    rep(j,2*N){ // dp[i-1][j]\n      r = j+A[i];\n      b = cnt-r;\n      if(b > 0 && r <= 2*N) dp[i][r] = (dp[i][r]+dp[i-1][j])%mod; //青\n      if(r > 0 && r <= 2*N)  dp[i][r-1] = (dp[i][r-1] + dp[i-1][j])%mod;\n    }\n    cnt-=1;\n  }\n  // rep(i,2*N+1){\n  //   rep(j,2*N+1){\n  //     cout<<dp[i][j]<<\"a\"<<i<<\"b\"<<j<<endl;\n  //   }\n  // }\n  cout<<dp[2*N][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long intl;\nint MOD=998244353;\nusing namespace std;\nint main(){\n\tvector <vector<int> > dp(1001,vector <int>(1001,0));\n\tvector <vector<int> > visited(1001,vector <int>(1001,0));\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tvector <pair<int,int> > v;\n\tv.push_back({0,0});\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i-1]=='0'){\n\t\t\tv.push_back({v[i-1].first+2,v[i-1].second});\n\t\t}\n\t\telse if(s[i-1]=='1'){\n\t\t\tv.push_back({v[i-1].first+1,v[i-1].second+1});\n\t\t}\n\t\telse{\n\t\t\tv.push_back({v[i-1].first,v[i-1].second+2});\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tqueue<pair<int,int> > q;\n\tq.push({0,0});\n\twhile(!q.empty()){\n\t\tint a=q.front().first;\n\t\tint b=q.front().second;\n\t\tq.pop();\n\t\tif(visited[a][b]){\n\t\t\tcontinue;\n\t\t}\n\t\tvisited[a][b]=1;\n\t\n\t\tint tot=a+b+1;\n\t\tif(tot>n){\n\t\t\ttot=n;\n\t\t}\n\t\t\n\t\tif(v[tot].second>b){\n\t\t\tdp[a][b+1]+=dp[a][b];\n\t\t\tdp[a][b+1]=dp[a][b+1]%MOD;\n\t\t\tq.push({a,b+1});\n\t\t}\n\t\tif(v[tot].first>a){\n\t\t\tdp[a+1][b]+=dp[a][b];\n\t\t\tdp[a+1][b]=dp[a+1][b]%MOD;\n\t\t\tq.push({a+1,b});\n\t\t}\n\t\t\n\t}\n\tcout<<dp[v[n].first][v[n].second]<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define int long long\n#define mp make_pair\n#define inf 998244353\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[4010][4010];\nint ka[214514],inv[214514];\nvoid setkaijo(int n){\n\tka[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tka[i] = ka[i-1] * i;\n\t\tka[i] %= inf;\n\t}\n}\nint modpow(int x,int k){\n\t// x ^ k mod inf\n\tint p2[55],res=1;\n\tp2[0]=1;p2[1]=x%inf;\n\tfor(int i=2;i<=50;i++){\n\t\tp2[i]=p2[i-1]*p2[i-1];\n\t\tp2[i] %= inf;\n\t}\n\tfor(int i=1;i<=50;i++){\n\t\tif(k%2==1){\n\t\t\tres *= p2[i];\n\t\t\tres %= inf;\n\t\t}\n\t\tk /= 2;\n\t}\n\treturn res;\n}\nvoid setinv(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tinv[i] = modpow(ka[i],(ll)inf-2);\n\t}\n}\nint comb(int n,int k){\n\tif( k<0 || n<0 || k>n)return 0;\n\tif(k==0 || k==n)return 1;\n\tint res = (ka[n] * inv[k]) % inf;\n\tres = (res*inv[n-k]) % inf;\n\treturn res;\n}\nsigned main(){\n\tstring st;\n\tcin>>st;\n\tint n = st.size();\n\tsetkaijo(10000);\n\tsetinv(10000);\n\tdp[0][0] = 1;\n\tint rc = 0, bc = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tchar cur = st[i-1];\n\t\tif( cur == '2'){\n\t\t\trc += 2;\n\t\t}\n\t\telse if( cur == '1' ){\n\t\t\trc++;\n\t\t\tbc++;\n\t\t}\n\t\telse{\n\t\t\tbc += 2;\n\t\t}\n\t\tfor(int j=0;j<=2000;j++){\n\t\t\tif( j <= n && j < rc ){\n\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t}\n\t\t\tif( (i-1-j) >= 0 && (i-1-j) < bc){\n\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\tdp[i][j] %= inf;\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<=n;i++){for(int j=0;j<=i;j++){cout<<\"dp\"<<i<<j<<\" \"<<dp[i][j]<<endl;}}\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tans += dp[n][i] * comb(n,rc-i);\n\t\tans %= inf;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\nll dp[2000][2001];\nint sum[2000];\nconst int MAX_P=2010;\nll extgcd(ll a, ll b, ll& x, ll&y){\n    ll d=a;\n    if(b!=0){\n        d=extgcd(b, a%b, y, x);\n        y-=(a/b)*x;\n    }\n    else {\n        x=1; y=0;\n    }\n    return d;\n}\n\nll mod_inverse(ll a, ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\n//n!modp\nll fact[MAX_P];\n\n//n!=a p＾eとした時のa modpを求める。O(log_p n)\nll mod_fact(ll n, ll p, ll& e){\n    e=0;\n    if(n==0) return 1;\n    \n    //pの倍数の部分を計算\n    ll res=mod_fact(n/p,p,e);\n    e+=n/p;\n    \n    //(p-1)!≡-1なので(p-1)!^(n/p)はn/pの偶奇だけで計算できる\n    if(n/p%2!=0) return res*(p-fact[n%p])%p;\n    return res*fact[n%p]%p;\n}\n\n//nCk modpを求める。O(log_p n)\nll mod_comb(ll n, ll k, ll p){\n    if(n<0||k<0||n<k) return 0;\n    ll e1, e2, e3;\n    ll a1=mod_fact(n,p,e1), a2=mod_fact(k,p,e2), a3=mod_fact(n-k,p,e3);\n    if(e1>e2+e3) return 0;\n    return a1*mod_inverse(a2*a3%p,p)%p;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string S;\n    cin>>S;\n    int N=S.length();\n    sum[0]=2-(S[0]-'0');\n    rep(i,1,N){\n        sum[i]=sum[i-1]+2-(S[i]-'0');\n    }\n    if(S[0]=='0'){\n        dp[0][0]=0;\n        dp[0][1]=1;\n    }\n    if(S[0]=='1'){\n        dp[0][0]=1;\n        dp[0][1]=1;\n    }\n    if(S[0]=='2'){\n        dp[0][0]=1;\n        dp[0][1]=0;\n    }\n    rep(i,1,N){\n        rep(j,0,i+2){\n            if(j==0){\n                dp[i][j]=(dp[i-1][0]&&sum[i]<=i+1?1:0);\n            }\n            else{\n                dp[i][j]=(sum[i]>j-1?dp[i-1][j-1]:0)+(2*i-sum[i-1]>0||sum[i]-sum[i-1]!=2?dp[i-1][j]:0);\n                dp[i][j]%=MOD;\n            }\n        }\n    }\n    fact[1]=1;\n    rep(i,2,MAX_P){\n        fact[i]=fact[i-1]*i;\n        fact[i]%=MOD;\n    }\n    ll ans=0;\n    rep(i,0,sum[N-1]+1){\n        ans+=mod_comb(N, sum[N-1]-i, MOD)*dp[N-1][i]%MOD;\n        ans%=MOD;\n    }\n    cout << ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007LL;\nconstexpr long long MOD = 998244353LL;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\ntemplate <std::uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = std::uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt b = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= b;\n            exp >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    bool operator==(const ModInt &p) const {return a == p.a;}\n    bool operator!=(const ModInt &p) const {return a != p.a;}\n\n};\n\nusing mint = ModInt<MOD>;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    string S; cin >> S;\n    int N = S.size();\n\n    vector<vector<mint>> dp(2*N+1, vector<mint>(2*N+1));\n    dp[0][0] = 1;\n\n    int r = 0, b = 0;\n    rep(i,2*N) {\n        if (i < N) {\n            if (S[i]=='0') r += 2;\n            if (S[i]=='2') b += 2;\n            if (S[i]=='1') {\n                r++;\n                b++;\n            }\n        }\n        rep(j,2*N) {\n            if (b >= i+1-j) dp[i+1][j] += dp[i][j];\n            if (r >= j+1) dp[i+1][j+1] += dp[i][j];\n        }\n    }\n\n    cout << dp[N*2][r].a << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int MD=1e9+7;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,r,s;public:UnionFind(int N){p=r=vi(N);s=vi(N,1);fr(i,N){p[i]=i;}}int find(int i){return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){if(r[a=find(a)]>r[b=find(b)]){swap(a,b);}s[b]+=s[a];r[p[a]=b]+=r[a]==r[b];}bool same(int a,int b){return find(a)==find(b);}int size(int x){return s[find(x)];}};\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tconst int M=998244353;\n\tstr S;cin>>S;\n\tint N=S.size();\n\tvvl d(2*N+1,vl(2*N+1));\n\td[0][0]=1;\n\tint x=0,y;\n\tfr(i,2*N){\n\t\tif(i<N){\n\t\t\tx+=S[i]-'0';\n\t\t\ty=2*(i+1)-x;\n\t\t}\n\t\tfoor(j,0,i){\n\t\t\tif(j<x&&i-j<=y){\n\t\t\t\t(d[j+1][i-j]+=d[j][i-j])%=M;\n\t\t\t}\n\t\t\tif(j<=x&&i-j<y){\n\t\t\t\t(d[j][i-j+1]+=d[j][i-j])%=M;\n\t\t\t}\n\t\t}\n\t}\n\tprint(d[x][y]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<int mod=998244353>\nclass ModInt {\n  int x;\npublic:\n  ModInt() : x(0) {}\n  ModInt(const ModInt &y): x(y.x) {}\n  ModInt(int64_t y){ x = y % mod; if(x < 0) x += mod; }\n  ModInt &operator += (const ModInt &p){ x += p.x; if(x >= mod) x -= mod; return *this; }\n  ModInt &operator -= (const ModInt &p){ x -= p.x; if(x < 0) x += mod; return *this; }\n  ModInt &operator *= (const ModInt &p){ x = (int) (1LL * x * p.x % mod); return *this; }\n  ModInt &operator /= (const ModInt &p){ *this *= p.inverse(); return *this; }\n  ModInt operator -() const { return ModInt(-x); }\n  ModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n  ModInt operator ^ (const int64_t y) const { return pow(y); }\n  bool operator == (const ModInt &p) const { return x == p.x; }\n  bool operator != (const ModInt &p) const { return x != p.x; }\n  ModInt operator = (const int64_t y) { return *this = ModInt(y); }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0){\n      t = a/b; a -= t*b; swap(a, b);\n      u -= t*v; swap(u, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t y) const {\n    if(x==0) return ModInt(0);\n    int64_t r = 1, t = x;\n    while(y > 0){\n      if(y&1) r = r*t%mod;\n      t = t*t%mod; y >>= 1;\n    }\n    return ModInt(r);\n  }\n  friend ostream &operator << (ostream &os, const ModInt<mod> &p) { return os<<p.x; }\n  friend istream &operator >> (istream &is, ModInt<mod> &a) { int64_t x; is>>x; a = ModInt<mod>(x); return is; }\n};\nusing Int = ModInt<>;\n\n\nint main(){\n  string s;\n  cin>>s;\n  int n = s.size();\n\n  vector<int> red,blue;\n  red.push_back(-1);\n  blue.push_back(-1);\n  rep(i,n){\n    if(s[i]=='0'){red.push_back(i); red.push_back(i);}\n    else if(s[i]=='1'){red.push_back(i); blue.push_back(i);}\n    else {blue.push_back(i); blue.push_back(i);}\n  }\n\n  vector<vector<Int>> dp(2*n+1, vector<Int>(red.size()+5, 0));\n  // [result-length][num of red]\n  dp[0][0] = 1;\n\n  rep(i,2*n) rep(j,red.size()+1) if(j<=i){\n    int ir = j;\n    int ib = i-j;\n    if(ib+1 < blue.size() && blue[ib+1] <= i){\n      dbg(i,ib,blue[ib+1]);\n      dp[i+1][j] += dp[i][j];\n    }\n    if(ir+1 < red.size() && red[ir+1] <= i) {\n      dbg(i,ir,red[ir+1]);\n      dp[i+1][j+1] += dp[i][j];\n    }\n  }\n  cout << red[red.size()] << endl;\n\n  cout << dp[2*n][red.size()-1] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int M = 998244353;\n\nint main() {\n    string s; cin >> s;\n    int r[4001] = {}, b[4001] = {};\n    for (int i = 0; i < s.size(); i++) {\n        if (i > 0) { r[i] = r[i-1]; b[i] = b[i-1]; }\n        switch(s[i]) {\n        case '0': r[i] += 2; break;\n        case '1': r[i]++; b[i]++; break;\n        case '2': b[i] += 2;\n        }\n    }\n    for (int i = s.size(); i < 2*s.size(); i++) r[i] = r[i-1], b[i] = b[i-1];\n    long long dp[4001][4001] = {};\n    if (r[0] > 0) dp[0][1] = 1;\n    if (b[0] > 0) dp[0][0] = 1;\n    for (int i = 1; i < 2*s.size(); i++) {\n        if (b[i] >= i+1) dp[i][0] = dp[i-1][0];\n        for (int j = 1; j <= min(i+1, r[i]); j++) {\n            if (r[i] >= j) dp[i][j] += dp[i-1][j-1];\n            if (b[i] >= i+1-j) dp[i][j] += dp[i-1][j];\n            if (dp[i][j] >= M) dp[i][j] -= M;\n        }\n    }\n    cout << dp[2*s.size()-1][r[s.size()]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n    string S;\n    cin>>S;\n    int N = (int)S.size();\n\n    long long M = 998244353;\n    vector<long long> T(2*N+1);\n    T[0] = 1;\n    int B = 0;\n    int R = 0;\n    for (int i=0; i<2*N; i++)\n    {\n        int pB = B;\n        if (i<N)\n        {\n            B += S[i]-'0';\n            R += 2-(S[i]-'0');\n        }\n\n        vector<long long> P = T;\n        T = vector<long long>(2*N+1);\n        for (int b=0; b<=pB; b++)\n        {\n            if (B-b == 0)\n            {\n                T[b] += P[b];\n                T[b] %= M;\n            }\n            else if (R-(i-b)==0)\n            {\n                T[b+1] += P[b];\n                T[b+1] %= M;\n            }\n            else\n            {\n                T[b] += P[b];\n                T[b] %= M;\n                T[b+1] += P[b];\n                T[b+1] %= M;\n            }\n        }\n\n        //for (long long t: T)\n        //    cout<<\" \"<<t;\n        //cout<<endl;\n    }\n    cout<<T[B]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 2005\n#define P 998244353\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, ans, r[MAXN], b[MAXN], c[MAXN*2][MAXN*2], f[MAXN][MAXN];\nchar s[MAXN];\n\nint main()\n{\n    scanf(\"%s\", s+1);\n    n=strlen(s+1);\n    c[0][0]=1;\n    for(rint i=1; i<=n*2; ++i)\n        for(rint j=0; j<=i*2; ++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%P;\n    for(rint i=1; i<=n; ++i)\n    {\n        if(s[i]=='0') r[i]=2;\n        if(s[i]=='1') r[i]=b[i]=1;\n        if(s[i]=='2') b[i]=2;\n        r[i]+=r[i-1], b[i]+=b[i-1];\n    }\n    f[0][0]=1;\n    for(rint i=1; i<=n; ++i)\n        for(rint j=max(0, i-b[i]); j<=min(i, r[i]); ++j)\n        {\n            f[i][j]=(f[i][j]+f[i-1][j])%P;\n            if(j) f[i][j]=(f[i][j]+f[i-1][j-1])%P;\n        }\n    for(rint i=max(0, n-b[n]); i<=min(i, r[n]); ++i) ans=(ans+1LL*c[n][r[n]-i]*f[n][i]%P)%P;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int32_t M=998244353;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\nconst int N=2020;\nmint dp[N+N][N];\nint sr[N+N];\nint sb[N+N];\nint32_t main(){\n    string s;\n    cin>>s;\n    int n=sz(s);\n    forn(i,n){\n        if(i)sr[i]=sr[i-1],sb[i]=sb[i-1];\n        if(s[i]=='0')sr[i]+=2;\n        if(s[i]=='1')sr[i]+=1,sb[i]+=1;\n        if(s[i]=='2')sb[i]+=2;\n    }\n    for(int i=n;i<n+n;++i)sr[i]=sr[i-1],sb[i]=sb[i-1];\n    dp[0][0]=1;\n    forn(i,n+n){\n        forn(r,i+1){\n            int b=i-r;\n            int sk=sr[i]-r;\n            int ss=sb[i]-b;\n            if(sk>0)dp[i+1][r+1]+=dp[i][r];\n            if(ss>0)dp[i+1][r]+=dp[i][r];\n        }\n    }\n    cout<<dp[n+n][sr[n]]<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 998244353;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m,a,b,c,d,e,f,g,h,r,w,l,num,ans,ok,ng,mid;\nll x[500005],y[500005],z[500005];\nll dp[3050][3005];\nll sum[305];\n\nchar s[500005],t[500005],u[500005];\nbool dame,flag;\n//string s;\n\nint main(){\n\tcin >> s;\n\tn = strlen(s);\n\tll r=0,b=0;\n\tll rsum[4000],bsum[4000];\n\tfor(i=0;i<n;i++){\n\t\tif(s[i] == '2'){\n\t\t\tb += 2;\n\t\t}else if(s[i] == '1'){\n\t\t\tr += 1;\n\t\t\tb += 1;\n\t\t}else{\n\t\t\tr += 2;\n\t\t}\n\t\trsum[i+1] = r;\n\t\tbsum[i+1] = b;\n\t}\n\tfor(i=n;i<n*2;i++){\n\t\trsum[i+1] = r;\n\t\tbsum[i+1] = b;\n\t}\n\tdp[0][0] = 1;\n\tfor(i=0;i<=r;i++){\n\t\tfor(j=0;j<=b;j++){\n\t\t\tif(i+j == 0)continue;\n\t\t\tif(rsum[i+j] >= i && i >= 1){\n\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t}\n\t\t\tif(bsum[i+j] >= j && j >= 1){\n\t\t\t\tdp[i][j] += dp[i][j-1];\n\t\t\t}\n\t\t\tdp[i][j] %= mod;\n\t\t\t//pe(dp[i][j]);\n\t\t}\n\t\t//el;\n\t}\n\tp(dp[r][b]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n#define endl '\\n'\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\n\n\nint T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    string s;\n    while(cin >> s){\n        n = s.size();\n        vi mxr(n * 2 + 1), mxb(n * 2 + 1);\n        REP(i, n) {\n            if (s[i] == '0') mxr[i] = 2;\n            if (s[i] == '1') mxr[i] = 1;\n            if (s[i] == '1') mxb[i] = 1;\n            if (s[i] == '2') mxb[i] = 2;\n        }\n        REP(i, 2 * n) {\n            mxr[i + 1] += mxr[i];\n            mxb[i + 1] += mxb[i];\n        }\n        vector<ll> dp(n * 2);\n        dp[0] = 1;\n        REP(i, n * 2) {\n            vector<ll> nxt(n * 2);\n            REP(r, i + 1) {\n                int b = i - r;\n                if (r <= mxr[i] && b + 1 <= mxb[i]) {\n                    (nxt[r] += dp[r]) %= MOD;\n                }\n                if (r + 1 <= mxr[i] && b <= mxb[i]) {\n                    (nxt[r + 1] += dp[r]) %= MOD;\n                }\n            }\n            swap(dp, nxt);\n        }\n        cout << accumulate(ALL(dp), 0ll) % MOD << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);cout.precision(20);}} fast;\n\n/* define */\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) (upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X))\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\n#define pow2(x) ((long long)((long long)1<<x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int,int>;\nusing pl = pair<long long,long long>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1,0,-1,0};\nconst long long dy[] = {0,1,0,-1};\nconst long long dx8[] = {1,1,0,-1,-1,-1,0,1};\nconst long long dy8[] = {0,1,1,1,0,-1,-1,-1};\nconst long long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\nconst long long dy9[] = {0,1,1,1,0,-1,-1,-1,0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\nlong long max(long long x,int y){return max(x,(long long)y);}\nlong long max(int x,long long y){return max((long long)x,y);}\nlong long min(long long x,int y){return min(x,(long long)y);}\nlong long min(int x,long long y){return min((long long)x,y);}\n\n/* liblary */\n\n\n\n/* main */\n\nsigned main(){\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tll s[N] = {0};\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll max[2*N];\n\tFOR(i,0,2*N){\n\t\tmax[i] = (i ? max[i-1] : 0) + (s[0] ? 1 : 0);\n\t\tif(s[0])s[0]--;\n\t\tFOR(j,1,N){\n\t\t\tif(s[j]){\n\t\t\t\ts[j-1]++;\n\t\t\t\ts[j]--;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,N)s[i] = ctoi(S[i]);\n\tll min[2*N];\n\tFOR(i,0,2*N){\n\t\tif(i == 0)min[i] = (s[0]==2 ? 1 : 0);\n\t\telse min[i] = min[i-1] + (s[0]==2 ? 1 : 0);\n\t\tif(s[0]==2){\n\t\t\ts[0] = 1;\n\t\t}\n\t\tFOR(j,1,N){\n\t\t\tif(s[j] == 2){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t\tif(s[j] == 1 && j == 2*N-i){\n\t\t\t\ts[j]--;\n\t\t\t\ts[j-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//DP[i][j] = i回目までの操作でj個使うような場合の数\n\tll DP[2*N+1][2*N+1];\n\tFOR(i,0,2*N)FOR(j,0,2*N+1)DP[i][j] = 0;\n\tDP[0][0] = 1;\n\tif(max[0])DP[0][1] = 1;\n\tFOR(i,1,2*N)FOR(j,0,2*N+1){\n\t\tDP[i][j] += DP[i-1][j];\n\t\tif(j)DP[i][j] += DP[i-1][j-1];\n\t\t//\n\t\tDP[i][j] %= 998244353;\n\t\tif(j > max[i])DP[i][j] = 0;\n\t\tif(j < min[i])DP[i][j] = 0;\n\t}\n\tcout << DP[2*N-1][max[2*N-1]] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 4004; \nmint dp[N][N];\n\nvoid solve() {\n    string s; cin >> s;\n    int n = s.size();\n    \n    int r = 0, b = 0;\n    dp[0][0] = 1;\n    for (int i = 1; i <= 2*n; i++) {\n        if (i <= n) {\n            int x = s[i-1]-'0';\n            r += 2-x;\n            b += x;\n        }\n        for (int j = 0; j <= i; j++) {\n            if (j <= r && i-j <= b) {\n                dp[i][j] += dp[i-1][j];\n                if(j)dp[i][j] += dp[i-1][j-1];\n            }\n        }\n    }\n    cout << dp[2*n][r];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size(),r = 0;\n    vector<vector<ll>> dp(2*n+1,vector<ll>(2*n+1,0));\n    dp[0][0] = 1;\n    for (int i = 0;i < 2*n;++i) {\n        if (i < n) {\n            if (s[i] == '0') r += 2;\n            else if (s[i] == '1') r += 1;\n        }\n        for (int j = 0;j < 2*i+2;++j) {\n            if (j && j <= r) dp[i+1][j] = dp[i][j-1];\n            if (i+1-j <= 2*(i+1)-r) dp[i+1][j] += dp[i][j];\n            dp[i+1][j] %= mod;\n        }\n    }\n    cout << dp[2*n][r] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb push_back\n#define mp std::make_pair\n#define endl \"\\n\"\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\n//const ll MOD=100000;\nconst ll MAX=1e7;\nconst ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nll modpow(ll X,ll Y){\n    ll sum=X,cnt=1;\n    vi A;\n    while(cnt<=Y){\n        A.pb(sum);\n        sum*=sum;\n        sum%=MOD;\n        cnt*=2;\n    }\n    int M=A.size();\n    ll ret=1;\n    REP(i,1,M){\n        if(Y>=(1ll<<M-i)){\n            Y-=(1ll<<M-i);\n            ret*=A[M-i];\n            ret%=MOD;\n        }\n    }\n    return ret;\n}\nll fac[MAX],finv[MAX],inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r];\n}\nsigned main(){\n    string S; cin>>S;\n    ll N=S.size();\n    vi R(1),B(1);\n    rep(i,0,N){\n        if(S[i]=='0'){\n            R.pb(std::max(R[R.size()-1]+1,i+1));\n            R.pb(std::max(R[R.size()-1]+1,i+1));\n        }\n        else if(S[i]=='1'){\n            R.pb(std::max(R[R.size()-1]+1,i+1));\n            B.pb(std::max(B[B.size()-1]+1,i+1));\n        }\n        else{\n            B.pb(std::max(B[B.size()-1]+1,i+1));\n            B.pb(std::max(B[B.size()-1]+1,i+1));\n        }\n    }\n    vii dp(2*N+2,vi(2*N+1));\n    dp[0][0]=1;\n    REP(sum,0,2*N){\n        REP(r,0,sum){\n            ll b=sum-r;\n            if(r+1<R.size()&&R[r+1]<=sum+1){\n                dp[sum+1][r+1]+=dp[sum][r];\n                dp[sum+1][r+1]%=MOD;\n            }\n            if(b+1<B.size()&&B[b+1]<=sum+1){\n                dp[sum+1][r]+=dp[sum][r];\n                dp[sum+1][r]%=MOD;\n            }\n        }\n    }\n    ll ans=0;\n    REP(i,0,2*N){\n        ans+=dp[2*N][i];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===== 2019/02/09 22:07:46 =====\n\n// includes.hpp\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n// cin.cpp\n\ntemplate <typename T, int M, int N> struct tuple_getter {\n  static void get(std::istream &is, T &x) {\n    is >> std::get<M>(x);\n    tuple_getter<T, M + 1, N>::get(is, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_getter<T, N, N> {\n  static void get(std::istream &is, T &x) { is >> std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::istream &operator>>(std::istream &is, std::tuple<Args...> &t) {\n  tuple_getter<std::tuple<Args...>, 0, sizeof...(Args) - 1>::get(is, t);\n  return is;\n}\n\ntemplate <typename T, typename U>\nstd::istream &operator>>(std::istream &is, std::pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate <typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &v) {\n  for (T &x : v) is >> x;\n  return is;\n}\n\n// const_value.hpp\n\nnamespace sub {\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_integral<T>::value, T>::type\ninf_sub() {\n  return std::numeric_limits<T>::max() / 2 - 1000;\n}\n\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_floating_point<T>::value, T>::type\ninf_sub() {\n  return std::min(std::numeric_limits<T>::max() / 2 - 1000, T(1e50));\n}\n}  // namespace sub\n\ntemplate <typename T> constexpr T inf() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return sub::inf_sub<T>();\n}\n\ntemplate <typename T> constexpr T zero() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return T(0);\n}\n\nconst long double pi = acos(-1.0);\n\n// cout.cpp\n\ntemplate <typename T, int M, int N> struct tuple_printer {\n  static void print(std::ostream &os, const T &x) {\n    os << std::get<M>(x) << \" \";\n    tuple_printer<T, M + 1, N>::print(os, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_printer<T, N, N> {\n  static void print(std::ostream &os, const T &x) { os << std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::ostream &operator<<(std::ostream &os, const std::tuple<Args...> &t) {\n  tuple_printer<std::tuple<Args...>, 0, sizeof...(Args) - 1>::print(os, t);\n  return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::set<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\n// macros.hpp\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\n// misc.hpp\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\n\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\n// range.hpp\n\nclass range {\n  class index_type {\n    int x;\n\n  public:\n    index_type(int x_) : x(x_) {}\n    int operator*() const { return x; }\n    bool operator!=(index_type &r) { return x < r.x; }\n    void operator++() { ++x; }\n  };\n  index_type i, n;\n\npublic:\n  range(int n_) : i(0), n(n_) {}\n  range(int i_, int n_) : i(i_), n(n_) {}\n  index_type &begin() { return i; }\n  index_type &end() { return n; }\n};\n\n// typedef.hpp\n\nusing ll = long long;\nusing ld = long double;\n\n// template.cpp\n\nusing namespace std;\n\n// mod.cpp\n\ntemplate <int M, bool IsPrime = false> class Modulo {\n  int n;\n  static typename std::enable_if<IsPrime, ll>::type inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n  }\n\npublic:\n  Modulo() : n(0) { ; }\n  Modulo(int m) : n(m) {\n    if (n >= M)\n      n %= M;\n    else if (n < 0)\n      n = (n % M + M) % M;\n  }\n  Modulo(ll m) {\n    if (m >= M)\n      m %= M;\n    else if (m < 0)\n      m = (m % M + M) % M;\n    n = m;\n  }\n  explicit operator int() const { return n; }\n  explicit operator ll() const { return n; }\n  bool operator==(const Modulo &a) const { return n == a.n; }\n  Modulo &operator+=(const Modulo &a) {\n    n += a.n;\n    if (n >= M) n -= M;\n    return *this;\n  }\n  Modulo &operator-=(const Modulo &a) {\n    n -= a.n;\n    if (n < 0) n += M;\n    return *this;\n  }\n  Modulo &operator*=(const Modulo &a) {\n    n = (ll(n) * a.n) % M;\n    return *this;\n  }\n  Modulo operator+(const Modulo &a) const {\n    Modulo res = *this;\n    return res += a;\n  }\n  Modulo operator-(const Modulo &a) const {\n    Modulo res = *this;\n    return res -= a;\n  }\n  Modulo operator-() const { return Modulo(0) - *this; }\n  Modulo operator*(const Modulo &a) const {\n    Modulo res = *this;\n    return res *= a;\n  }\n\n  Modulo operator^(ll m) const {\n    if (m == 0) return Modulo(1);\n    const Modulo a = *this;\n    Modulo res = (a * a) ^ (m / 2);\n    return m % 2 ? res * a : res;\n  }\n  typename std::enable_if<IsPrime, Modulo>::type\n  operator/(const Modulo &a) const {\n    return *this * inv(ll(a), M);\n  }\n  typename std::enable_if<IsPrime, Modulo>::type operator/=(const Modulo &a) {\n    return *this *= inv(ll(a), M);\n  }\n\n  friend bool is_zero(const Modulo &x) { return int(x) == 0; }\n  friend int abs(const Modulo &x) { return int(x); }\n\n  static Modulo fact(int n, bool sw = true) {\n    static std::vector<Modulo> v1 = { 1 }, v2 = { 1 };\n    if (n >= (int)v1.size()) {\n      const int from = v1.size(), to = n + 1024;\n      v1.reserve(to);\n      v2.reserve(to);\n      for (int i = from; i < to; ++i) {\n        v1.push_back(v1.back() * Modulo<M, true>(i));\n        v2.push_back(v2.back() / Modulo<M, true>(i));\n      }\n    }\n    return sw ? v1[n] : v2[n];\n  }\n  static Modulo comb(int a, int b) {\n    if (b < 0 || b > a) return 0;\n    return Modulo::fact(a, true) * Modulo::fact(b, false) *\n           Modulo::fact(a - b, false);\n  }\n};\n\n// main.cpp\n\ntemplate <typename T> vector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args> auto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nusing Mod = Modulo<998244353, true>;\nMod dp[4096][4096];\n\nint main() {\n  string s;\n  cin >> s;\n  const int n = s.size();\n  dp[0][0] = 1;\n  int red = 0, blue = 0;\n  REP(i,n*2) {\n    if (i < n) {\n      if (s[i] == '0') { red += 2; blue += 0; }\n      if (s[i] == '1') { red += 1; blue += 1; }\n      if (s[i] == '2') { red += 0; blue += 2; }\n    }\n    REP(j,n*2) {\n      // if (int(dp[i][j]) != 0) cout << i << \" \" << j << \" \" << int(dp[i][j]) << endl;\n      int r = red - j;\n      int b = blue - (i - j);\n      // if (i == 0 && j == 0) cout << r << \" \" << b << endl;\n      if (r < 0 || b < 0) continue;\n      if (r > 0) dp[i+1][j+1] += dp[i][j];\n      if (b > 0) dp[i+1][j] += dp[i][j];\n    }\n  }\n  // cout << red << \" \" << blue << endl;\n  cout << int(dp[n*2][red]) << endl;\n}\n\n// ===== 2019/02/09 22:07:46 =====\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define FL \"a\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double dd;\nconst int N=2005;\nconst int inf=2147483647;\nconst dd pi=acos(-1);\nconst ll INF=1ll<<60;\nconst int mod=998244353;\ninline ll read(){\n  ll data=0,w=1;char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\ninline void file(){\n  freopen(FL\".in\",\"r\",stdin);\n  freopen(FL\".out\",\"w\",stdout);\n}\n\nchar s[N];int n,dp[N][N],c[N][N],ans;\ninline void upd(int &a,int b){a+=b;if(a>=mod)a-=mod;}\nint main()\n{\n  scanf(\"%s\",s+1);n=strlen(s+1);\n  for(int i=0;i<=n;i++)\n    for(int j=c[i][0]=1;j<=i;j++)upd(c[i][j]=c[i-1][j],c[i-1][j-1]);\n  dp[0][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=0,c=s[i]-48;j<=i;j++){\n      if(j>=c-1)upd(dp[i][j],dp[i-1][j-c+1]);\n      if(j>=c)upd(dp[i][j],dp[i-1][j-c]);\n    }\n  for(int i=0;i<=n;i++)upd(ans,1ll*dp[n][i]*c[n][i]%mod);\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nconst int MOD=998244353;\nconst int N=2002;\nchar s[N]; int n;\nint dp[N*2][N*2], pre[N], sum[N];\nint main(){\n    scanf(\"%s\",s+1); n=strlen(s+1);\n    for(int i=1;i<=n;i++){\n        if(s[i]=='0') pre[i]=pre[i-1]+2, sum[i]=sum[i-1];\n        if(s[i]=='1') pre[i]=pre[i-1]+1, sum[i]=sum[i-1]+1;\n        if(s[i]=='2') pre[i]=pre[i-1], sum[i]=sum[i-1]+2;\n    }\n\n    dp[0][0]=1;\n    for(int i=0;i<2*n;i++){\n        for(int j=0;j<=2*n;j++){\n            if(pre[min(i+1,n)]>=j && sum[min(i+1,n)]>=i+1-j)\n                (dp[i+1][j] += dp[i][j]) %= MOD;\n            if(pre[min(i+1,n)]>=j+1 && sum[min(i+1,n)]>=i+1-(j+1))\n                (dp[i+1][j+1] += dp[i][j]) %= MOD;\n            \n            //printf(\"dp[%d][%d]=%d\\n\", i,j,dp[i][j]);\n        }\n    }\n    cout<<dp[2*n][pre[n]]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 2/9/2019, 10:35:35 PM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 998244353;\nconst int MAX_SIZE = 1000010;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = ((MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    factinv[i] = (inv[i] * factinv[i - 1]) % MOD;\n  }\n}\n\nlong long C(int n, int k)\n{\n  if (n >= 0 && k >= 0 && n - k >= 0)\n  {\n    return ((fact[n] * factinv[k]) % MOD * factinv[n - k]) % MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n  else if (n % 2 == 1)\n  {\n    return (x * power(x, n - 1)) % MOD;\n  }\n  else\n  {\n    long long half = power(x, n / 2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcd(long long x, long long y)\n{\n  return y ? gcd(y, x % y) : x;\n}\n\nstring S;\nint N;\nll DP[2010][4010];\nint R[2010];\nint B[2010];\n\nint main()\n{\n  init();\n  cin >> S;\n  N = S.size();\n  for (auto i = 0; i < 4010; i++)\n  {\n    DP[0][i] = 0;\n  }\n  DP[0][0] = 1;\n  R[0] = B[0] = 0;\n  for (auto i = 1; i <= N; i++)\n  {\n    if (S[i - 1] == '0')\n    {\n      R[i] = R[i - 1] + 2;\n      B[i] = B[i - 1];\n    }\n    else if (S[i - 1] == '1')\n    {\n      R[i] = R[i - 1] + 1;\n      B[i] = B[i - 1] + 1;\n    }\n    else\n    {\n      R[i] = R[i - 1];\n      B[i] = B[i - 1] + 2;\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    cerr << \"R[\" << i + 1 << \"] = \" << R[i + 1] << \", B[\" << i + 1 << \"] = \" << B[i + 1] << endl;\n    for (auto j = 0; j <= i; j++)\n    {\n      if (DP[i][j] == 0)\n      {\n        continue;\n      }\n      cerr << \"DP[\" << i << \"][\" << j << \"] = \" << DP[i][j] << endl;\n      int r = j;\n      int b = i - r;\n      if (R[i + 1] - r > 0)\n      {\n        DP[i + 1][j + 1] += DP[i][j];\n        DP[i + 1][j + 1] %= MOD;\n      }\n      if (B[i + 1] - b > 0)\n      {\n        DP[i + 1][j] += DP[i][j];\n        DP[i + 1][j] %= MOD;\n      }\n    }\n  }\n  ll ans = 0;\n  for (auto i = 0; i <= N; i++)\n  {\n    if (DP[N][i] == 0)\n    {\n      continue;\n    }\n    int r = i;\n    int b = N - i;\n    int res_r = R[N] - r;\n    int res_b = B[N] - b;\n    ans += (DP[N][i] * C(res_r + res_b, res_r)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\ntypedef long long ll;\nconst int N = 200010;\nconst int mod = 998244353;\nconst int oo = 1e9;\nconst int base = 27;\ntypedef pair<int,int> pii;\n\n\nint dp[2010][2010],f1[4001],f2[4001];\n\nstring s;\n\nll adl(ll a , ll b){\n  return (1ll*a+b)%mod;\n}\nint calc(int r , int b){\n  if(r+b == 2*s.size())return 1;\n  int &ret = dp[r][b];\n  if(ret != -1)return ret;\n  ret = 0;\n  int idx = r+b;\n  if(idx == s.size()){\n    if(b != f1[s.size()-1])ret = adl(ret,calc(r,b+1));\n    if(r != f2[s.size()-1])ret = adl(ret,calc(r+1,b));\n  }else{\n    if(b != f1[idx])ret = adl(ret,calc(r,b+1));\n    if(r != f2[idx])ret = adl(ret,calc(r+1,b));\n  }\n  return ret;\n}\nint main() {\n  memset(dp,-1,sizeof dp);\n  cin >> s;\n  for (int i = 0; i < s.size(); ++i){\n    if(s[i] == '1')f1[i]++,f2[i]++;\n    if(s[i] == '2')f2[i]+=2;\n    if(s[i] == '0')f1[i]+=2;\n    if(i)\n      f1[i] += f1[i-1];\n    if(i)\n      f2[i] += f2[i-1];\n  }\n  for (int i = s.size(); i <= 2*s.size(); ++i){\n    f1[i] = f1[i-1];\n    f2[i] = f2[i-1];\n  }\n  printf(\"%d\\n\",calc(0,0));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\n#define fi first\n#define se second\n\nint dp[4003][4003],r[2003],b[2003];\n\nsigned main(){\n  string s;\n  cin>>s;\n  int n=s.size();\n  r(i,s.size()){\n    if(s[i]=='0')r[i]=2;\n    if(s[i]=='1')r[i]=1,b[i]=1;\n    if(s[i]=='2')b[i]=2;\n  }\n  r(i,s.size()-1){\n    r[i+1]+=r[i];\n    b[i+1]+=b[i];\n  }\n  dp[0][0]=1;\n  r(i,n*2){\n    r(j,n*2)if(j<=i){\n      int x=min(i,n-1);\n      if(r[x]-j>0)dp[i+1][j+1] += dp[i][j];\n      if(b[x]-(i-j)>0)dp[i+1][j] += dp[i][j];\n      dp[i+1][j+1]%=998244353;\n      dp[i+1][j]%=998244353;\n    }\n  }\n  int sum=0;\n  r(i,4003)sum+=dp[n*2][i],sum%=998244353;\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nll mo=998244353;\nll dp[4020][4020];\nint NR[2020],NB[2020];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S;\n\tN=S.size();\n\tFOR(i,N) {\n\t\tNR[i+1]=NR[i]+('2'-S[i]);\n\t\tNB[i+1]=NB[i]+(S[i]-'0');\n\t}\n\tdp[0][0]=1;\n\tfor(int r=0;r<=2*N;r++) {\n\t\tfor(int b=0;b<=2*N;b++) if(dp[r][b]) {\n\t\t\tint nr=NR[min(N,r+b+1)];\n\t\t\tint nb=NB[min(N,r+b+1)];\n\t\t\tif(r+1<=nr&&b<=nb) (dp[r+1][b]+=dp[r][b])%mo;\n\t\t\tif(r<=nr&&b+1<=nb) (dp[r][b+1]+=dp[r][b])%mo;\n\t\t}\n\t}\n\t\n\tcout<<dp[NR[N]][NB[N]]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint s1[3001],s2[3001];\nlong long f[5001][5001];\nlong long s[5001][5001];\nlong long mod=998244353;\nint main()\n{\n\tstring x;\n\tcin>>x;\n\tint len=x.size();\n\tint i,j;\n\tfor(i=1;i<=len;i++)\n\t{\n\t\tif(x[i-1]=='0')\n\t\t{\n\t\t\ts1[i]=s1[i-1]+2;\n\t\t\ts2[i]=s2[i-1];\n\t\t}\n\t\telse if(x[i-1]=='1')\n\t\t{\n\t\t\ts1[i]=s1[i-1]+1;\n\t\t\ts2[i]=s2[i-1]+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts1[i]=s1[i-1];\n\t\t\ts2[i]=s2[i-1]+2;\n\t\t}\n\t}\n\tfor(i=len+1;i<=2*len;i++)\n\t{\n\t\ts1[i]=s1[i-1];\n\t\ts2[i]=s2[i-1];\n\t}\n\tfor(i=1;i<=2*len;i++)\n\t{\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j<=s1[i])\n\t\t\t{\n\t\t\t\tif(j!=0)\n\t\t\t\t\tf[i][j]+=f[i-1][j-1];\n\t\t\t\telse\n\t\t\t\t\tf[i][j]+=1;\n\t\t\t}\n\t\t\tif(i-j<=s2[i])\n\t\t\t\tf[i][j]+=f[i-1][j];\n\t\t\tf[i][j]%=mod;\n\t\t}\n\t}\n\tlong long ans=0;\n/*\tfor(i=1;i<=len*2;i++)\n\t{\n\t\tfor(j=0;j<=i;j++)\n\t\t\tprintf(\"%lld \",f[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(i=0;i<=s1[len*2];i++)\n\t\tans+=f[2*len][i];\n\tprintf(\"%lld\\n\",f[2*len][s1[len*2]]-1ll);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 4010;\nconst long long mod = 998244353;\nlong long dp[maxn][maxn];\nint n;\nint v[maxn][2], h[maxn][2] = {0};\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tn = s.size();\n\tfor(int i = 0; i < s.size(); i ++)\n\t{\n\t\tint a = s[i] - '0';\n\t\tv[i + 1][0] = a;\n\t\tv[i + 1][1] = 2 - a;\n\t\th[i + 1][0] = h[i][0] + v[i + 1][0];\n\t\th[i + 1][1] = h[i][1] + v[i + 1][1];\n\t}\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= 2 * n; i ++)\n\t{\n\t\tint a, b;\n\t\ta = h[min(i, n)][0];\n\t\tb = h[min(i, n)][1];\n\t\tfor(int j = max(0, i - b); j <= a && j <= i; j ++)\n\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod;\n\t}\n\tcout << dp[n * 2][h[n][0]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=4005,INF=1<<30;\nll dp[MAX][MAX];\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b||b<0) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    \n    string S;cin>>S;\n    int N=S.size();\n    int cana=0,canb=0;\n    dp[0][0]=1;\n    if(S[0]=='0'){\n        dp[1][1]=1;\n        cana=2;\n    }else if(S[0]=='1'){\n        dp[1][1]=1;\n        dp[1][0]=1;\n        cana=1;\n        canb=1;\n    }else{\n        dp[1][0]=1;\n        canb=2;\n    }\n    \n    for(int i=1;i<N;i++){\n        if(S[i]=='0') cana++;\n        else if(S[i]=='1'){\n            cana++;\n            canb++;\n        }else canb++;\n        \n        for(int j=0;j<=i+1;j++){\n            if(canb>=i+1-j) dp[i+1][j]+=dp[i][j];\n            if(cana>=j&&j) dp[i+1][j]+=dp[i][j-1];\n            \n            dp[i+1][j]%=mod;\n        }\n        \n        if(S[i]=='0') cana++;\n        if(S[i]=='2') canb++;\n    }\n    \n    ll ans=0;\n    \n    for(int j=0;j<=N;j++){\n        ans+=dp[N][j]*comb(N,cana-j);\n        ans%=mod;\n    }\n    \n    cout<<ans<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\ntypedef double db;\nconst int maxn = 2e3 + 5;\nconst ll mod = 998244353;\n\nint n;\nchar s[maxn];\nll dp[maxn][maxn];\nint a[maxn], b[maxn];\n\nvoid add(ll &x, ll &y){ x += y; if(x >= mod) x -= mod; }\n\nint main(){\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    rep(i, 1, n)\n        a[i] = a[i-1] + 2 - (s[i] - '0'), b[i] = b[i-1] + s[i] - '0';\n    dp[0][0] = 1;\n    rep(i, 0, 2 * n)\n        rep(j, 0, i)\n            if(dp[i][j]){\n                if(a[min(i + 1, n)] > j)\n                    add(dp[i+1][j+1], dp[i][j]);\n                if(b[min(i + 1, n)] > i - j)\n                    add(dp[i+1][j], dp[i][j]);\n            }\n    printf(\"%lld\\n\", dp[2*n][a[n]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)998244353\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nint read() {\n\tint x; cin >> x; return x;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value = value % modulo;\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nclass UnionFind {\nprotected:\n\tint* par, * rank, * size;\npublic:\n\tUnionFind(unsigned int size) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tthis->size = new int[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tthis->size[i] = 1;\n\t\t}\n\t}\n\tint find(int n) {\n\t\tif (par[n] == n)return n;\n\t\treturn par[n] = find(par[n]);\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m)return;\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tsize[m] += size[n];\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tsize[n] += size[m];\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t}\n\tbool same(int n, int m) {\n\t\treturn find(n) == find(m);\n\t}\n\tint getsize(int n) {\n\t\treturn size[find(n)];\n\t}\n};\nclass PerpetualUnionFind :UnionFind {\n\tP* notparent;\n\tvector<P>* sizevec;\n\tint opcount = 0;\npublic:\n\tPerpetualUnionFind(unsigned int size) :UnionFind(size) {\n\t\tthis->sizevec = new vector<P>[size];\n\t\tnotparent = new P[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsizevec[i].push_back(make_pair(-1, 1));\n\t\t\tnotparent[i] = make_pair(INF, i);\n\t\t}\n\t}\n\tint find(int n, int t = INF) {\n\t\tif (opcount <= t) {\n\t\t\tif (par[n] == n)return n;\n\t\t\treturn par[n] = find(par[n]);\n\t\t}\n\t\tif (notparent[n].first <= t)return find(notparent[n].second, t);\n\t\treturn n;\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m) {\n\t\t\topcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tnotparent[n] = make_pair(opcount, m);\n\t\t\tsizevec[m].push_back(make_pair(opcount, sizevec[m].back().second + sizevec[n].back().second));\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tnotparent[m] = make_pair(opcount, n);\n\t\t\tsizevec[n].push_back(make_pair(opcount, sizevec[n].back().second + sizevec[m].back().second));\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t\topcount++;\n\t}\n\tbool same(int n, int m, int t = INF) {\n\t\treturn find(n, t) == find(m, t);\n\t}\n\tint getsize(int n, int t = INF) {\n\t\tn = find(n, t);\n\t\tauto ite = lower_bound(sizevec[n].begin(), sizevec[n].end(), make_pair(t, (int)0));\n\t\tif (ite == sizevec[n].end())ite--;\n\t\tif (t < (*ite).first)ite--;\n\t\treturn (*ite).second;\n\t}\n};\nclass RollingHash {\n\tstring s;\n\tint n, m;\n\tmodInt base;\n\tvector<modInt> has, power;\npublic:\n\tRollingHash(string s, int m, int b) : n(s.size()), m(m), base(b, m) { init(s, m, b); }\n\tvoid init(string s, int m, int b) {\n\t\tn = s.size();\n\t\thas.resize(n);\n\t\tpower.resize(n);\n\t\tbase = modInt(b, m);\n\t\tthis->s = s;\n\t\tthis->m = m;\n\t\trep(i, n) {\n\t\t\thas[i] = modInt(s[i], m);\n\t\t\tif (i) {\n\t\t\t\thas[i] += base * has[i - 1];\n\t\t\t\tpower[i] = power[i - 1] * base;\n\t\t\t}\n\t\t\telse power[i] = 1;\n\t\t}\n\t}\n\toperator int() const {\n\t\treturn has.back();\n\t}\n\tint query(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\treturn has[b - 1] - power[b - a] * (!a ? modInt(0) : has[a - 1]);\n\t}\n\tRollingHash& operator+=(string t) {\n\t\ts += t;\n\t\thas.resize(n + t.size());\n\t\tpower.resize(n + t.size());\n\t\tfor (int i = n; i < n + t.size(); i++) {\n\t\t\thas[i] = modInt(t[i] * base, m);\n\t\t\thas[i] += base * has[i - 1];\n\t\t\tpower[i] = power[i - 1] * base;\n\t\t}\n\t\tn += t.size();\n\t\treturn *this;\n\t}\n};\ntemplate<typename T, typename U>\nclass SegTree {\n\tint n = 1;\n\tT* node = NULL;\n\tU* lazy = NULL;\n\tbool* lazyflag = NULL;\n\tT nodee;\n\tfunction<T(T, T)> nodef;\n\tfunction<U(U, U)> lazyf;\n\tfunction<T(int, T, U)> updf;\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazyflag[k]) {\n\t\t\tnode[k] = updf(r - l, node[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tif (lazyflag[2 * k + 1])lazy[2 * k + 1] = lazyf(lazy[2 * k + 1], lazy[k]);\n\t\t\t\telse lazy[2 * k + 1] = lazy[k];\n\t\t\t\tif (lazyflag[2 * k + 2])lazy[2 * k + 2] = lazyf(lazy[2 * k + 2], lazy[k]);\n\t\t\t\telse lazy[2 * k + 2] = lazy[k];\n\t\t\t\tlazyflag[2 * k + 1] = lazyflag[2 * k + 2] = true;\n\t\t\t}\n\t\t\tlazyflag[k] = false;\n\t\t}\n\t}\npublic:\n\tSegTree(int m, int init, T nodee, function<T(T, T)> nodef, function<U(U, U)> lazyf, function<T(int, T, U)> updf) :nodee(nodee), nodef(nodef), lazyf(lazyf), updf(updf) {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t\twhile (n < m)n *= 2;\n\t\tnode = new T[2 * n], lazy = new U[2 * n], lazyflag = new bool[2 * n];\n\t\trep(i, 2 * n) {\n\t\t\tnode[i] = init;\n\t\t\tlazyflag[i] = false;\n\t\t}\n\t}\n\t~SegTree() {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t}\n\tvoid update(int a, int b, U x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazyflag[k] = true;\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = nodef(node[2 * k + 1], node[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return nodee;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn nodef(vl, vr);\n\t}\n};\ntemplate<typename T>\nclass RAQRSQ :public SegTree<T, T> {\npublic:\n\tRAQRSQ(int size, const T& def = T()) :SegTree<T, T>(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + range * b; }) {};\n};\ntemplate<typename T>\nclass RAQRMiQ :public SegTree<T, T> {\npublic:\n\tRAQRMiQ(int size, const T& def = T()) :SegTree<T, T>(size, def, INF, [](T a, T b) {return min(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RAQRMaQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRAQRMaQ(int size, const T& def = T()) :base(size, def, -INF, [](T a, T b) {return max(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RUQRSQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRSQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return b; }, [](int range, T a, T b) {return range * b; }) {};\n};\ntemplate<typename T>\nclass RUQRMQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRMQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return min(a, b); }, [](T a, T b) {return b; }, [](int range, T a, T b) {return b; }) {};\n};\ntemplate<typename T>\nclass BIT {\n\tint n;\n\tT* bit;\npublic:\n\tBIT(int n) :n(n) {\n\t\tbit = new T[n];\n\t\tfill(bit, bit + n, T());\n\t}\n\tvoid add(int a, T x) {\n\t\twhile (a < n) {\n\t\t\tbit[a] += x;\n\t\t\ta += a & -a;\n\t\t}\n\t}\n\tT query(int a) {\n\t\tint cnt = 0;\n\t\twhile (a > 0) {\n\t\t\tcnt += bit[a];\n\t\t\ta -= a & -a;\n\t\t}\n\t\treturn cnt;\n\t}\n};\nclass ConvexHullTrick {\n\tbool minOrMax, lineMonotone;\n\tclass Line {\n\tpublic:\n\t\tint a, b;\n\t\tbool isquery;\n\t\tmutable std::function<const Line * ()> getSuc;\n\t\tbool operator<(const Line& x) const {\n\t\t\tif (isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return true;\n\t\t\t\treturn (suc->a - x.a) * a + suc->b - x.b > 0;\n\t\t\t}\n\t\t\tif (x.isquery) {\n\t\t\t\tconst Line* suc = next(this);\n\t\t\t\tif (suc == nullptr) return false;\n\t\t\t\treturn (suc->a - a) * x.a + suc->b - b < 0;\n\t\t\t}\n\t\t\treturn a < x.a;\n\t\t}\n\t};\n\tbool isbad(const set<Line>::iterator x) {\n\t\tif (x == st.begin() || next(x) == st.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tbool isbad(const vector<Line>::iterator x) {\n\t\tif (x == vec.begin() || next(x) == vec.end())return false;\n\t\tauto pre = prev(x), nex = next(x);\n\t\tif (((*x).b - (*pre).b) * ((*nex).a - (*x).a) >= ((*nex).b - (*x).b) * ((*x).a - (*pre).a))return true;\n\t\treturn false;\n\t}\n\tset<Line> st;\n\tvector<Line> vec;\npublic:\n\tConvexHullTrick(bool minormax = false, bool lineMonotone = false) :minOrMax(minormax), lineMonotone(lineMonotone) {}\n\tvoid addLine(int a, int b) {\n\t\tif (minOrMax) {\n\t\t\ta = -a; b = -b;\n\t\t}\n\t\tif (!lineMonotone) {\n\t\t\tauto pos = st.lower_bound({ a,-INF,false });\n\t\t\tif (pos != st.end()) {\n\t\t\t\tif ((*pos).a == a) {\n\t\t\t\t\tif ((*pos).b <= b)return;\n\t\t\t\t\tst.erase(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto ite = st.insert({ a,b,false }).first;\n\t\t\tite->getSuc = [=] {return next(ite) == st.end() ? nullptr : &*next(ite); };\n\t\t\tif (isbad(ite)) {\n\t\t\t\tst.erase(ite);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (next(ite) != st.end() && isbad(next(ite)))st.erase(next(ite));\n\t\t\twhile (ite != st.begin() && isbad(prev(ite)))st.erase(prev(ite));\n\t\t}\n\t\telse {\n\t\t\tif (!vec.empty()) {\n\t\t\t\tif (vec.back().a > a) {\n\t\t\t\t\tcerr << \"Line additions are not monotone\" << endl;\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (vec.back().a == a) {\n\t\t\t\t\tif (vec.back().b <= b)return;\n\t\t\t\t\tvec.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec.push_back({ a,b,false });\n\t\t\tauto ite = --vec.end();\n\t\t\tint index = vec.size() - 1;\n\t\t\tite->getSuc = [this, index] {cout << vec.size() << endl; return index == vec.size() - 1 ? nullptr : &*(vec.begin() + index + 1); };\n\t\t\twhile (ite != vec.begin() && isbad(prev(ite))) {\n\t\t\t\t*prev(ite) = vec.back();\n\t\t\t\tvec.pop_back();\n\t\t\t\tite = --vec.end();\n\t\t\t}\n\t\t}\n\t}\n\tint query(int x) {\n\t\tif (!lineMonotone) {\n\t\t\tauto l = *st.lower_bound(Line{ x, 0,true });\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t\telse {\n\t\t\tauto l = *lower_bound(vec.begin(), vec.end() - 1, Line({ x,0,true }));\n\t\t\tif (!minOrMax)return l.a * x + l.b;\n\t\t\telse return -l.a * x - l.b;\n\t\t}\n\t}\n};\ntemplate<typename T>\nclass Matrix {\n\tint n;\n\tT zero, e;\n\tvector<vector<T>> vec;\n\tvoid letmeasure() {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j)vec[i][j] = zero;\n\t\t\t\telse vec[i][j] = e;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tMatrix(int n, T zero, T e) :n(n), zero(zero), e(e) {\n\t\tvec.resize(n, vector<T>(n));\n\t}\n\tMatrix(int n, T zero, T e, vector<int> vec) :n(n), zero(zero), e(e) {\n\t\tif (vec.size() != n * n) {\n\t\t\tcerr << \"Invalid construct of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tthis->vec.resize(n, vector<T>(n));\n\t\trep(i, n) {\n\t\t\trep(j, n)this->vec[i][j] = vec[i * n + j];\n\t\t}\n\t}\n\tT& operator[](int a) {\n\t\treturn vec[a / n][a % n];\n\t}\n\tunsigned int size() { return n; }\n\tMatrix operator*(const Matrix a) {\n\t\tif (this->n != a.n) {\n\t\t\tcerr << \"Invalid multiply of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> memo(n);\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tmemo[j] += vec[i][k] * a.vec[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec[i] = memo;\n\t\t\tmemo.clear();\n\t\t\tmemo.resize(n);\n\t\t}\n\t\treturn *this;\n\t}\n\tstatic Matrix<T> measure(int n, T zero, T e) {\n\t\tMatrix<T> res(n, zero, e);\n\t\tres.letmeasure();\n\t\treturn res;\n\t}\n};\n\nclass mycomplex {\n\tdouble realvalue, imagvalue;\npublic:\n\tmycomplex() :realvalue(0), imagvalue(0) {}\n\tmycomplex(double realvalue, double imagvalue) : realvalue(realvalue), imagvalue(imagvalue) {}\n\tmycomplex(double realvalue) : realvalue(realvalue), imagvalue(0) {}\n\tmycomplex(complex<double> c) :realvalue(c.real()), imagvalue(c.imag()) {}\n\tmycomplex(const mycomplex& rhs) :realvalue(rhs.realvalue), imagvalue(rhs.imagvalue) {}\n\tdouble real()const { return this->realvalue; }\n\tdouble imag()const { return this->imagvalue; }\n\tdouble abs() { return hypot(realvalue, imagvalue); }\n\tmycomplex& operator=(const mycomplex& obj) {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = obj.realvalue;\n\t\t\tthis->imagvalue = obj.imagvalue;\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator=(mycomplex&& obj)noexcept {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = exchange(obj.realvalue, 0);\n\t\t\tthis->imagvalue = exchange(obj.imagvalue, 0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator+=(const mycomplex& rhs) {\n\t\tthis->realvalue += rhs.realvalue;\n\t\tthis->imagvalue += rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator+(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs += rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator-=(const mycomplex& rhs) {\n\t\tthis->realvalue -= rhs.realvalue;\n\t\tthis->imagvalue -= rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tmycomplex& operator-=(const double& rhs) {\n\t\tthis->realvalue -= rhs;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator-(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs -= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator*=(const mycomplex& rhs) {\n\t\tdouble pastreal = this->realvalue;\n\t\tthis->realvalue = this->realvalue * rhs.realvalue - this->imagvalue * rhs.imagvalue;\n\t\tthis->imagvalue = pastreal * rhs.imagvalue + rhs.realvalue * this->imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator*(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs *= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator/=(const mycomplex& rhs) {\n\t\t*this *= mycomplex(rhs.real(), -rhs.imag());\n\t\tdouble dnm = rhs.real() * rhs.real() - rhs.imag() * rhs.imag();\n\t\tthis->realvalue /= dnm;\n\t\tthis->imagvalue /= dnm;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator/(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs /= rhs;\n\t\treturn lhs;\n\t}\n};\nclass FastFourierTransform {\nprivate:\n\tstatic void dft(vector<mycomplex>& func, int inverse) {\n\t\tint sz = func.size();\n\t\tif (sz == 1)return;\n\t\tvector<mycomplex> veca, vecb;\n\t\trep(i, sz / 2) {\n\t\t\tveca.push_back(func[2 * i]);\n\t\t\tvecb.push_back(func[2 * i + 1]);\n\t\t}\n\t\tdft(veca, inverse); dft(vecb, inverse);\n\t\tmycomplex now = 1, zeta = polar(1.0, inverse * 2.0 * acos(-1) / sz);\n\t\trep(i, sz) {\n\t\t\tfunc[i] = veca[i % (sz / 2)] + now * vecb[i % (sz / 2)];\n\t\t\tnow *= zeta;\n\t\t}\n\t}\npublic:\n\ttemplate<typename T>\n\tstatic vector<double> multiply(vector<T> f, vector<T> g) {\n\t\tvector<mycomplex> nf, ng;\n\t\tint sz = 1;\n\t\twhile (sz < f.size() + g.size())sz *= 2;\n\t\tnf.resize(sz); ng.resize(sz);\n\t\trep(i, f.size()) {\n\t\t\tnf[i] = f[i];\n\t\t\tng[i] = g[i];\n\t\t}\n\t\tdft(nf, 1);\n\t\tdft(ng, 1);\n\t\trep(i, sz)nf[i] *= ng[i];\n\t\tdft(nf, -1);\n\t\tvector<double> res;\n\t\trep(i, sz)res.push_back(nf[i].real() / sz);\n\t\treturn res;\n\t}\n};\nint n, r[2010];\nstring s;\nmodInt dp[4010][4010];\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\trep(i, n) {\n\t\tr[i] = 2 - (s[i] - '0');\n\t\tif (i)r[i] += r[i - 1];\n\t}\n\tdp[0][0] = 1;\n\trep(i, 2 * n) {\n\t\trep(j, 2 * n + 1) {\n\t\t\tif (i + 1 - j <= 2 * min(n, i + 1) - r[min(n - 1, i)])dp[i + 1][j] += dp[i][j];\n\t\t\tif (j + 1 <= r[min(n - 1, i)])dp[i + 1][j + 1] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[2 * n][r[n - 1]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<time.h>\n#include<cassert>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define EPS (1e-13)\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rep(i,n) for(int (i) = 0 ; (i) < (n) ; (i)++)\n#define mkp make_pair\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\nconst int Mod = 1e9 + 7;\nconst int mod = 998244353;\nconst ll Inf = 3 * 1e18;\nconst int inf = 15 * 1e8;\nll read() {\n\tll u, k = scanf(\"%lld\", &u);\n\treturn u;\n}\nll gcd(ll i, ll j) {\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcd(j % i, i);\n}\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % p;\n\t\tx = x * x % p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll bcount(ll x) {\n\tint sum = 0;\n\tfor (int i = 0; i < 20; i++)\n\t\tif ((1ll << i) & x) sum++;\n\treturn sum;\n}\n/*const int fn_ = 2000000;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll mod = Mod) {\n\tif (!fact_[0]) {\n\t\tfact_[0] = 1; comp_[0] = 1;\n\t\tfor (int i = 1; i < fn_; i++) {\n\t\t\tfact_[i] = fact_[i - 1] * i % mod;\n\t\t\tcomp_[i] = mod_pow(fact_[i], mod - 2, mod);\n\t\t}\n\t}\n\tif (x < y) return 0;\n\treturn fact_[x] * comp_[x - y] % mod * comp_[y] % mod;\n}*/\n//---------------------------------------------------\nint a[5000], b[5000];\nint dp[5000][5000];\nint n;\nstring s;\nsigned main() {\n\tcin >> s;\n\tn = s.size();\n\t//a[i]=i個の赤い球を入れるために必要な最小操作回数\n\t//a[i]=k  前からi個めの球を入れるまでにk回の操作が必要であった。\n\t//a[i]    i個めのボールが前からa[i-1]番目以降の場所にいる場合、その回数分が必要\n\tfor (int i = 1; i < 5000; i++)\n\t\ta[i] = inf, b[i] = inf;\n\tint t = 1, sum = 0;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\tif (a[t - 1] >= i) {\n\t\t\t\ta[t] = a[t - 1] + 1; t++;\n\t\t\t\ta[t] = a[t - 1] + 1; t++;\n\t\t\t\tsum += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[t++] = i + 1;\n\t\t\t\ta[t++] = i + 2;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (a[t - 1] >= i) {\n\t\t\t\ta[t] = a[t - 1] + 1; t++;\n\t\t\t}\n\t\t\telse a[t++] = i + 1;\n\t\t}\n\t}\n\tt = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == '2') {\n\t\t\tif (b[t - 1] >= i) {\n\t\t\t\tb[t] = b[t - 1] + 1; t++;\n\t\t\t\tb[t] = b[t - 1] + 1; t++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[t++] = i + 1;\n\t\t\t\tb[t++] = i + 2;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '1') {\n\t\t\tif (b[t - 1] >= i) {\n\t\t\t\tb[t] = b[t - 1] + 1;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\telse b[t++] = i + 1;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tfor (int j = 0; j <= 2 * n; j++) {\n\t\t\tif (a[j] <= i && b[i - j] <= i) {\n\t\t\t\tdp[i][j] = ((j == 0 ? 0 : dp[i - 1][j - 1]) + dp[i - 1][j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[2 * n][sum] % mod + mod) % mod << endl;\n}"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE RankNTypes #-}\nimport qualified Data.ByteString.Lazy.Char8 as B\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Vector.Unboxed as VU\n-- import qualified Data.Vector.Unboxed.Mutable as VUM\n-- import Control.Monad\n-- import Control.Monad.ST\nimport Debug.Trace\n-- trace _ = id\n\nsolve :: String -> Int\nsolve spec = VU.foldl' mAdd 0 dp\n  where\n  blues = VU.postscanl' mAdd 0 (VU.fromList (map f spec))\n    where f c = read [c]\n  len = VU.length blues\n  totBlue = blues VU.! (len-1)\n  dp = VU.ifoldl' f initV (blues VU.++ (VU.replicate len totBlue))\n    where\n    initV = VU.fromList [1]\n    -- f vec i nb = traceL \"vect\" (i,x) x\n    --      where x = fX vec i nb\n    f vec i nb = VU.generate (i+2) g\n      where\n      nr | i < len   = (i+1)*2 - nb\n         | otherwise = len*2 - nb\n      g j | nb < j || nr < (i+1 - j) = 0\n          | j == 0                   = vec VU.! 0\n          | j == i+1                 = vec VU.! i\n          | otherwise                = (vec VU.! (j-1)) `mAdd` (vec VU.! j)\n\n----------------------------------------------------------------------\nmPrime = 998244353\n\n-- mAdd x y = (x + y) `mod` mPrime\nmAdd :: Int -> Int -> Int\nmAdd x y = let w = x + y in if w < mPrime then w else w - mPrime\n\n-- mSub x y = (x - y) `mod` mPrime    -- ok even if x < y\nmSub :: Int -> Int -> Int\nmSub x y = let w = x - y in if w >= 0 then w else w + mPrime\n\nmMul :: Int -> Int -> Int\nmMul x y = (x * y) `mod` mPrime\n\nreadBInt :: B.ByteString -> Int\nreadBInt = fst . fromJust . B.readInt\n\ntmain :: B.ByteString -> Int\ntmain cont =\n  let remLines0 = map B.words (B.lines cont)\n      [bs_spec]:remLines1 = remLines0\n      spec = B.unpack bs_spec\n  in solve spec\n\noutAnswer :: Int -> IO ()\noutAnswer = putStrLn . show\n\nmain :: IO ()\nmain = outAnswer . tmain =<< B.getContents\n\ntraceL :: Show a => String -> a -> b -> b\ntraceL label showObj val = trace (label ++ \" \" ++ show showObj) val\n\ntraceLM :: (Monad m, Show a) => String -> (b -> a) -> m b -> m b\ntraceLM label showFn act = do\n  aaa <- act\n  traceL label (showFn aaa) (return ())\n  return aaa\n\n\n-------------------------------------------------------------------------------\n\ninp1 = \"02\\n\"\ninp2 = \"1210\\n\"\ninp3 = \"12001021211100201020\\n\"\ntv1 = tmain $ B.pack inp1\ntv2 = tmain $ B.pack inp2\ntv3 = tmain $ B.pack inp3\ntest1 = tv1 == 3\ntest2 = tv2 == 55\ntest3 = tv3 == 543589959\nalltest = test1 && test2 && test3\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\n\nmain :: IO ()\nmain = do\n  input <- BS.getLine\n  let n = BS.length input\n      blues = VU.map (subtract (fromEnum '0') . fromEnum)\n              $ VU.unfoldrN n BS.uncons input\n      (!vec_aftern,!bleft_aftern,!b,!r) = VU.ifoldl'\n        (\\(!vec_prev,!bleft_prev,!b_prev,!r_prev) !i !b_this ->\n           let !len_prev = VU.length vec_prev\n               !b = b_prev + b_this\n               !r = r_prev + 2 - b_this\n               !bleft = bleft_prev + sl\n               !vec = VU.zipWith plus (VU.cons 0 vec_prev) (VU.snoc vec_prev 0)\n               sl | r <= i - bleft_prev            = 1 | otherwise = 0\n               sr | b <= bleft_prev + len_prev - 1 = 1 | otherwise = 0\n           in (VU.slice sl (len_prev + 1 - sl - sr) vec,bleft,b,r))\n        (VU.singleton 1, 0, 0, 0) blues\n      (!vec_last,!bleft_last) = foldl'\n        (\\(!vec_prev,!bleft_prev) !i ->\n           let !len_prev = VU.length vec_prev\n               !vec = VU.zipWith plus (VU.cons 0 vec_prev) (VU.snoc vec_prev 0)\n               !bleft = bleft_prev + sl\n               sl | r <= i-1 - bleft_prev          = 1 | otherwise = 0\n               sr | b <= bleft_prev + len_prev - 1 = 1 | otherwise = 0\n           in (VU.slice sl (len_prev + 1 - sl - sr) vec, bleft))\n        (vec_aftern,bleft_aftern) [n+1..2*n]\n  print $ vec_last VU.! 0\n        \n\n{-# INLINE plus #-}\nplus :: Int -> Int -> Int\nplus = \\x y -> let xpy = x+y in if xpy >= modulus then xpy - modulus else xpy\n\n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\n\nmain :: IO ()\nmain = do\n  input <- BS.getLine\n  let n = BS.length input\n      blues = VU.map (subtract (fromEnum '0') . fromEnum)\n              $ VU.unfoldrN n BS.uncons input\n      (!vec_aftern,!bleft_aftern,!b,!r) = VU.ifoldl'\n        (\\(!vec_prev,!bleft_prev,!b_prev,!r_prev) !i !b_this ->\n           let !len_prev = VU.length vec_prev\n               !b = b_prev + b_this\n               !r = r_prev + 2 - b_this\n               !bleft | shortenleft = bleft_prev + 1\n                      | otherwise   = bleft_prev\n               !vec = VU.zipWith plus (VU.cons 0 vec_prev) (VU.snoc vec_prev 0)\n               !shortenleft = r <= i - bleft_prev\n               !shortenright = b <= bleft_prev + len_prev - 1\n               sl | shortenleft = 1 | otherwise = 0\n               sr | shortenright = 1 | otherwise = 0\n           in (,bleft,b,r)\n              $! VU.slice sl (len_prev + 1 - sl - sr) vec)\n        (VU.singleton 1,0, 0, 0) blues\n      (!lastvec,!bleft_last) = foldl'\n        (\\ (!vec_prev,!bleft_prev) !i ->\n            let !len_prev = VU.length vec_prev\n                !vec = VU.zipWith plus (VU.cons 0 vec_prev) (VU.snoc vec_prev 0)\n                !bleft = bleft_prev + sl\n                !shortenleft = r <= i-1 - bleft_prev\n                !shortenright = b <= bleft_prev + len_prev - 1\n                sl | shortenleft = 1 | otherwise = 0\n                sr | shortenright = 1 | otherwise = 0\n            in (VU.slice sl (len_prev + 1 - sl - sr) vec, bleft))\n        (vec_aftern,bleft_aftern) [n+1..2*n]\n  print $ lastvec VU.! 0\n        \n\n{-# INLINE plus #-}\nplus :: Int -> Int -> Int\nplus x y\n  | xpy >= modulus = xpy - modulus\n  | otherwise      = xpy\n  where !xpy = x+y\n\n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "C",
    "code": "c,t,d[4010][4010];char s[4010];i;main(j){for(**d=scanf(\"%s\",s);s[i/2];i++)for(j=c+=s[i]?t+=2,s[i]-48:0;j>i+c-t&&~j;j--)d[i+1][j]=(d[i][j]+d[i][j-1])%998244353;printf(\"%d\",d[i][c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[9999]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[c-t--]=0)for(j=c+=j%3;j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};char s[4010];i;main(j){for(gets(s);i<(t+=s[i]?2:0);d[j]=!++i)for(j=c+=s[i]%3;j>i+c-t&&~j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[j]=!t--)for(j=c+=j%3;j>c-t&&~j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "M=998244353;\nchar S[2001];\nd[4001][4001];\nx,y;\ni,j,k;\nmain(){\n\tgets(S);\n\tfor(**d=1;i<2*strlen(S);++i)\n\t\tfor(S[i]?y=2*i+2-(x+=S[i]-48):0,j=0;j<=i;++j)\n\t\t\tfor(k=0;k<2;++k)\n\t\t\t\td[j+!k][i-j+k]+=j-k<x&&i-j+k<=y?d[j][i-j]%M:0;\n\tprintf(\"%d\",d[x][y]%M);\n}\n"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};char s[4010];i;main(j){for(gets(s);s[i/2];d[j]=0,i++)for(j=c+=s[i]?t+=2,s[i]-48:0;j>i+c-t&&~j;j--)d[j]=(d[j]+d[j-1])%998244353;printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null reds[N_MAX], blues[N_MAX];\null dp[4001][4001];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tn = strlen(s);\n\tdp[0][0] = 1;\n\treds[0] = blues[0] = 0;\n\tfor (i = 0; i < n; i++) {\n\t\treds[i + 1] = reds[i];\n\t\tblues[i + 1] = blues[i];\n\t\tif (s[i] == '0') {\n\t\t\treds[i + 1] += 2;\n\t\t} else if (s[i] == '2') {\n\t\t\tblues[i + 1] += 2;\n\t\t} else {\n\t\t\treds[i + 1]++;\n\t\t\tblues[i + 1]++;\n\t\t}\n\t}\n\n\tfor (i = 1; i <= n * 2; i++) {\n\t\tsll red;\n\t\tfor (red = 0; red <= n * 2; red++) {\n\t\t\tsll blue = i - red;\n\t\t\tif (blue < 0) break;\n\t\t\tif (red > reds[umin(i, n)] || blue > blues[umin(i, n)]) {\n\t\t\t\tdp[i][red] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[i][red] = ((red ? dp[i - 1][red - 1] : 0) + dp[i - 1][red]) % FOD;\n\t\t}\n\t}\n\tresult = dp[n * 2][reds[n]];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\tputs(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "c,d[4010]={1};main(t,j){for(;t+=(j=getchar())>10?c+=j%3,1:-1;d[c<t?t:c-t]=0)for(j=c;j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[c<t?-1:c-t]=0,t--)for(j=c+=j%3;j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010][4010];char s[4010];i,j;main(){for(**d=scanf(\"%s\",s);s[i/2];i++)for(j=c+=s[i]?t++,s[i]-48:0;j>i+c-2*t&&~j;j--)d[i+1][j]=(d[i][j]+d[i][j-1])%998244353;printf(\"%d\",d[i][c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[c-t--]=0)for(j=c+=j%3;j>c-t&&j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};char s[4010];i;main(j){for(gets(s);s[i/2];d[j]=!++i)for(j=c+=s[i]?t+=2,s[i]-48:0;j>i+c-t&&~j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[c-t]=0,t--)for(j=c+=j%3;j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[c<t?t:c-t]=!t--)for(j=c+=j%3;j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010][4010];char s[4010];i;main(j){gets(s);for(**d=1;s[i/2];i++)for(j=c+=s[i]?t+=2,s[i]-48:0;j>i+c-t&&~j;j--)d[i+1][j]=(d[i][j]+d[i][j-1])%998244353;printf(\"%d\",d[i][c]);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef long long int int64;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ABS(a) ((a)>(0)?(a):-(a))\n\n#define POS(i,j) ((i)*(n+2)+(j))\n\nvoid run(void){\n  char *s=(char *)calloc(2000+1,sizeof(char));\n  scanf(\"%s\",s);\n  int n=strlen(s);\n  const int mod=998244353;\n  int *dp=(int *)calloc((n+2)*(n+2),sizeof(int));\n  int i=0;\n  dp[POS(1,s[i]=='2'?2:s[i]=='1'?1:0)]=1;\n  for(i=1;i<n;i++){\n    int d=s[i]=='2'?2:s[i]=='1'?1:0;\n    for(int j=0;j<=i+1;j++){\n      if(j>0){\n\tdp[POS(i+1,j-1+d)]+=dp[POS(i,j)];\n\tdp[POS(i+1,j-1+d)]%=mod;\n      }\n      if(j<i+1){\n\tdp[POS(i+1,j+d)]+=dp[POS(i,j)];\n\tdp[POS(i+1,j+d)]%=mod;\n      }\n    }\n  }\n  memcpy(dp,dp+POS(n,0),sizeof(int)*(n+2));\n  memset(dp+POS(1,0),0,sizeof(int)*(n+2)*n);\n  for(i=0;i<=n;i++){\n    for(int j=0;j<=n+1-i;j++){\n      if(j>0){\n\tdp[POS(i+1,j-1)]+=dp[POS(i,j)];\n\tdp[POS(i+1,j-1)]%=mod;\n      }\n      if(j<n+1-i){\n\tdp[POS(i+1,j)]+=dp[POS(i,j)];\n\tdp[POS(i+1,j)]%=mod;\n      }\n    }\n  }\n  printf(\"%d\\n\",dp[POS(n+1,0)]);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "c,t,d[4010][4010]={1};char s[4010];i;main(j){for(gets(s);s[i/2];i++)for(j=c+=s[i]?t+=2,s[i]-48:0;j>i+c-t&&~j;j--)d[i+1][j]=(d[i][j]+d[i][j-1])%998244353;printf(\"%d\",d[i][c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};char s[4010];i;main(j){for(gets(s);s[i/2];d[j]=!++i)for(j=c+=s[i]?t+=2,s[i]-48:0;j>i+c-t&&~j;j--)d[j]=(d[j]+d[j-1])%998244353;printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "int n,c,dp[4010][4010];\nchar s[2010];\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tdp[0][0]=1;\n\tfor(int i=0;i<2*n;i++){\n\t\tif(i<n)c+=s[i]-48;\n\t\tfor(int j=0;j<4005;j++)if(j<=c&i+1-j<=2*(i+1<n?i+1:n)-c){\n\t\t\tif(j)dp[i+1][j]=(dp[i][j]+dp[i][j-1])%998244353;\n\t\t\telse dp[i+1][j]=dp[i][j];\n\t\t}\n\t}\n\tprintf(\"%d\",dp[2*n][c]);\n}"
  },
  {
    "language": "C",
    "code": "c,d[4010]={1};main(t,j){for(;t+=(j=getchar())>10?c+=j%3,1:-1;d[j]=0)for(j=c;j>c-t&&~j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010][4010];char s[4010];i,j;main(){for(**d=scanf(\"%s\",s);s[i/2];i++)for(j=c+=s[i]?t++,s[i]-48:0;j>i+c-2*t&&~j;j--)d[i+1][j]=(d[i][j]+d[i][j-1])%998244353;printf(\"%d\",d[i][c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[c-t--]=0)for(j=c+=j%3;j>c-t;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,p[4010]={1};*d=p;main(t,j){for(;t+=(j=getchar())>10?c+=j%3,1:-1;d[c-t]=0)for(j=c;j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "M=998244353;\nchar S[4000];\nd[4001][4001];\nx,y;\ni,j,k;\nmain(){\n\tgets(S);\n\tfor(**d=1;i<2*strlen(S);++i)\n\t\tfor(S[i]?y=2*i+2-(x+=S[i]-48):0,j=0;j<=i;++j)\n\t\t\tfor(k=0;k<2;++k)\n\t\t\t\td[j+!k][i-j+k]+=j-k<x&&i-j+k<=y?d[j][i-j]%M:0;\n\tprintf(\"%d\",d[x][y]%M);\n}\n"
  },
  {
    "language": "C",
    "code": "M=998244353;char S[4000];d[4001][4001];i,j,k,x;main(y){gets(S);for(**d=1;i<2*strlen(S);++i)for(S[j=i]?y=2*i+2-(x+=S[i]-48):0;~j;--j)for(k=2;k--;)d[j+!k][i-j+k]+=j-k<x&&i-j+k<=y?d[j][i-j]%M:0;printf(\"%d\",d[x][y]%M);}"
  },
  {
    "language": "C",
    "code": "c,t,d[999]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[j]=!t--)for(j=c+=j%3;j>c-t&&~j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 998244353\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nint main(void){\n    long long i,j,n,m,k,a,b,c=0,h,w,r,l,t;\n    long long st,fi;\n    char s[4096];\n    long long dp[4096][4096]={0};\n    dp[0][0]=1;\n    scanf(\"%s\",s);\n    l=strlen(s);\n    r=0;b=0;\n    for(i=1;i<=2*l;i++){\n      if(i<=l){b+=(s[i-1]-'0');r+=(2-(s[i-1]-'0'));}\n      for(j=0;j<i;j++){\n        dp[i][j]+=dp[i-1][j];\n        dp[i][j]%=mod;\n        dp[i][j+1]+=dp[i-1][j];\n        dp[i][j+1]%=mod;\n      }\n      st=llmax(0,i-r);\n      fi=llmin(i,b);\n      for(j=0;j<4096;j++){\n        if(!(st<=j && j<=fi)){\n          dp[i][j]=0;\n        }\n      }\n    }\n    printf(\"%lld\\n\",dp[2*l][b]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())>10?c+=j%3,2:0;d[j]=!t--)for(j=c;j>c-t&&~j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};main(j){for(;t+=(j=getchar())&8?j=0:2;d[c<t?-1:c-t]=!t--)for(j=c+=j%3;j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "M=998244353;\nchar S[2001];\nd[4001][4001];\ni,j,k,x;\nmain(y){\n\tgets(S);\n\tfor(**d=1;i<2*strlen(S);++i)\n\t\tfor(S[i]?y=2*(i+1)-(x+=S[i]-48):0,j=0;j<=i;++j)\n\t\t\tfor(k=0;k<2;++k)\n\t\t\t\td[j+!k][i-j+k]+=j-k<x&&i-j+k<=y?d[j][i-j]%M:0;\n\tprintf(\"%d\",d[x][y]%M);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n;\nchar s[2010];\nll dp[4010][4010];\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\t\n\tdp[0][0]=1;\n\tint c=0;\n\trep(i,1,2*n+1){\n\t\tif(i-1<n)c+=s[i-1]-48;\n\t\trep(j,0,2*i+1)if(j<=c&&i-j<=2*min(i,n)-c){\n\t\t\tif(j)dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%MOD;\n\t\t\telse dp[i][j]=dp[i-1][j];\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[2*n][c]);\n}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010][4010];char s[4010];i;main(j){for(**d=scanf(\"%s\",s);s[i/2];i++)for(j=c+=s[i]?t++,s[i]-48:0;j>i+c-2*t&&~j;j--)d[i+1][j]=(d[i][j]+d[i][j-1])%998244353;printf(\"%d\",d[i][c]);}"
  },
  {
    "language": "C",
    "code": "c,t,d[4010][4010];char s[4010];i,j;main(){for(**d=scanf(\"%s\",s);s[i/2];i++)for(j=c+=s[i]?t++,s[i]-48:0;j>i+c-2*t&&~j;j--)d[i+1][j]=(d[i][j]+d[i][j-1])%998244353;printf(\"%d\",d[i][c]);}"
  },
  {
    "language": "C",
    "code": "M=998244353;\nchar S[2001];\nN;\nd[4001][4001];\nx,y;\ni,j,k;\nmain(){\n\tN=strlen(gets(S));\n\tfor(**d=1;i<2*N;++i){\n\t\tif(i<N)y=2*(i+1)-(x+=S[i]-'0');\n\t\tfor(j=0;j<=i;++j){\n\t\t\tfor(k=0;k<2;++k){\n\t\t\t\tif(j+!k<=x&&i-j+k<=y){\n\t\t\t\t\td[j+!k][i-j+k]+=d[j][i-j]%M;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",d[x][y]%M);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p 998244353\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\nsigned main(){\n\tint N, i, j;\n\tchar *S = (char *)malloc(sizeof(char) * 2002);\n\tscanf(\"%s\", &S[1]);\n\tfor(N = 0; S[N + 1] != '\\0'; N++);\n\tint *R = (int *)malloc(sizeof(int) * (N + 1));\n\tint *B = (int *)malloc(sizeof(int) * (N + 1));\n\tR[0] = 0;\n\tB[0] = 0;\n\tfor(i = 1; i <= N; i++){\n\t\tR[i] = R[i - 1];\n\t\tB[i] = B[i - 1];\n\t\tif(S[i] == '0'){\n\t\t\tR[i] += 2;\n\t\t}\n\t\telse if(S[i] == '1'){\n\t\t\tR[i] += 1;\n\t\t\tB[i] += 1;\n\t\t}\n\t\telse{\n\t\t\tB[i] += 2;\n\t\t}\n\t}\n\tint **dp = (int **)malloc(sizeof(int *) * (2 * N + 1));\n\tfor(i = 0; i <= 2 * N; i++){\n\t\tdp[i] = (int *)malloc(sizeof(int) * (2 * N + 1));\n\t\tfor(j = 0; j <= 2 * N; j++){\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor(i = 1; i <= 2 * N; i++){\n\t\tfor(j = 0; j <= i; j++){\n\t\t\tif(i >= N || (j <= R[i] && i - j <= B[i])){\n\t\t\t\tdp[i][j] = MOD((j > 0 ? dp[i - 1][j - 1] : 0) + dp[i - 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[2 * N][R[N]]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst int Mod = 998244353;\n\nint main()\n{\n\tint N;\n\tchar S[2001];\n\tscanf(\"%s\", S);\n\tfor (N = 0; S[N] != 0; N++);\n\t\n\tint i, j, l = 0, r = 0, tmp[2] = {};\n\tlong long dp[4001] = {1};\n\tfor (i = 0; i < N; i++) {\n\t\tif (S[i] == '0') tmp[0] += 2;\n\t\telse if (S[i] == '2') tmp[1] += 2;\n\t\telse {\n\t\t\ttmp[0]++;\n\t\t\ttmp[1]++;\n\t\t}\n\t\tif (r < tmp[0]) r++;\n\t\tfor (j = r; j > l; j--) dp[j] = (dp[j] + dp[j-1]) % Mod;\n\t\tif (l + tmp[1] <= i) dp[l++] = 0;\n\t}\n\tfor (; i < N * 2; i++) {\n\t\tif (r < tmp[0]) r++;\n\t\tfor (j = r; j > l; j--) dp[j] = (dp[j] + dp[j-1]) % Mod;\n\t\tif (l + tmp[1] <= i) dp[l++] = 0;\n\t}\n\tprintf(\"%lld\\n\", dp[r]);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c,d[4010]={1},j;main(t){t?j--?:(j=getchar(d[c<t?t:c-t]=0),t+=j>10?c+=j%3,1:-1,j=c),d[j]=(d[j]+d[j-1])%998244353,main(t):printf(\"%d\",d[c]);}"
  },
  {
    "language": "C",
    "code": "M=998244353;\nchar S[2001];\nN;\nd[4001][4001];\nx,y;\ni,j,k;\nmain(){\n\tN=strlen(gets(S));\n\tfor(**d=1;i<2*N;++i){\n\t\ti<N?y=2*(i+1)-(x+=S[i]-48):0;\n\t\tfor(j=0;j<=i;++j)\n\t\t\tfor(k=0;k<2;++k)\n\t\t\t\td[j+!k][i-j+k]+=j-k<x&&i-j+k<=y?d[j][i-j]%M:0;\n\t}\n\tprintf(\"%d\",d[x][y]%M);\n}\n"
  },
  {
    "language": "C",
    "code": "c,t,d[4010]={1};char s[4010];i;main(j){for(gets(s);s[i/2];d[j]=!++i)for(j=c+=s[i]?t+=2,s[i]%3:0;j>i+c-t&&~j;d[j--]%=998244353)d[j]+=d[j-1];printf(\"%d\",d[c]);}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            String s = in.readString();\n            int n = s.length();\n\n            List<Integer> redList = new ArrayList<>();\n            List<Integer> blueList = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (s.charAt(i) == '0') {\n                    redList.add(i);\n                    redList.add(i);\n                } else if (s.charAt(i) == '1') {\n                    redList.add(i);\n                    blueList.add(i);\n                } else {\n                    blueList.add(i);\n                    blueList.add(i);\n                }\n            }\n\n            long MOD = 998244353;\n\n            int r = redList.size();\n            int b = blueList.size();\n            long[][] dp = new long[r + 1][b + 1];\n            dp[0][0] = 1;\n            for (int i = 0; i <= r; i++) {\n                for (int j = 0; j <= b; j++) {\n                    if (i > 0 && redList.get(i - 1) + 1 > i + j) continue;\n                    if (j > 0 && blueList.get(j - 1) + 1 > i + j) continue;\n\n                    if (i > 0) dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n                    if (j > 0) dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD;\n                }\n            }\n\n            out.printLine(dp[r][b]);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final long MOD = 998244353;\n\tstatic int N;\n\tstatic int[] blue;\n\n\tpublic static void main(String[] args) {\n\t\tchar[] S = sc.next().toCharArray();\n\t\tN = S.length;\n\t\tblue = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tblue[i] = S[i] - '0';\n\t\t}\n\t\tint[] max = greedy();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tblue[i] = 2 - blue[i];\n\t\t}\n\t\tint[] min = greedy();\n\t\tfor (int i = 1; i <= 2 * N; i++) {\n\t\t\tmin[i] = i - min[i];\n\t\t}\n//\t\tSystem.err.println(Arrays.toString(max));\n//\t\tSystem.err.println(Arrays.toString(min));\n\t\tlong[][] dp = new long[2][2 * N + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 0, t = 0; i < 2 * N; i++, t ^= 1) {\n\t\t\tArrays.fill(dp[t ^ 1], 0);\n\t\t\tfor (int j = min[i]; j <= max[i]; j++) {\n\t\t\t\tdp[t ^ 1][j] += dp[t][j];\n\t\t\t\tif (dp[t ^ 1][j] >= MOD) dp[t ^ 1][j] -= MOD;\n\t\t\t\tdp[t ^ 1][j + 1] += dp[t][j];\n\t\t\t\tif (dp[t ^ 1][j + 1] >= MOD) dp[t ^ 1][j + 1] -= MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[0][max[2 * N]]);\n\t}\n\n\tstatic int[] greedy() {\n\t\tint[] count = blue.clone();\n\t\tint[] ret = new int[2 * N + 1];\n\t\tfor (int i = 0; i < 2 * N; i++) {\n\t\t\tif (count[0] > 0) {\n\t\t\t\tret[i + 1] = ret[i] + 1;\n\t\t\t} else {\n\t\t\t\tret[i + 1] = ret[i];\n\t\t\t}\n\t\t\tif (count[0] > 0) count[0]--;\n\t\t\tfor (int j = 1; j < N; j++) {\n\t\t\t\tif (count[j] > 0) {\n\t\t\t\t\tcount[j - 1]++;\n\t\t\t\t\tcount[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FPass solver = new FPass();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FPass {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            Modular mod = new Modular(998244353);\n            char[] s = in.readString().toCharArray();\n            int n = s.length;\n\n            int[][] dp = new int[n + 1][n + 1];\n            dp[0][0] = 1;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j <= i; j++) {\n                    int b = j;\n                    int r = i - j;\n                    int way = dp[i][j];\n                    if (way == 0) {\n                        continue;\n                    }\n                    if (s[i] == '0') {\n                        //two blue\n                        //this is blue\n                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);\n                        //this is red\n                        if (r > 0) {\n                            dp[i + 1][j + 2] = mod.plus(dp[i + 1][j + 2], way);\n                        }\n                    } else if (s[i] == '1') {\n                        //one blue one red\n                        //this is blue\n                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);\n                        //this is red\n                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);\n                    } else {\n                        //two red\n                        //this is blue\n                        if (j > 0) {\n                            dp[i + 1][j - 1] = mod.plus(dp[i + 1][j - 1], way);\n                        }\n                        //this is red\n                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);\n                    }\n                }\n            }\n\n            int ans = 0;\n            Combination comb = new Combination(n, new Power(mod));\n            for (int i = 0; i <= n; i++) {\n                int way = dp[n][i];\n                way = mod.mul(way, comb.combination(n, i));\n                ans = mod.plus(ans, way);\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        static IntExtGCDObject extGCD = new IntExtGCDObject();\n        final Modular modular;\n\n        public Modular getModular() {\n            return modular;\n        }\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int inverse(int x) {\n            int ans = inverseExtGCD(x);\n//        if(modular.mul(ans, x) != 1){\n//            throw new IllegalStateException();\n//        }\n            return ans;\n        }\n\n        public int inverseExtGCD(int x) {\n            if (extGCD.extgcd(x, modular.getMod()) != 1) {\n                throw new IllegalArgumentException();\n            }\n            return modular.valueOf(extGCD.getX());\n        }\n\n    }\n\n    static class ExtGCD {\n        public static int extGCD(int a, int b, int[] xy) {\n            if (a >= b) {\n                return extGCD0(a, b, xy);\n            }\n            int ans = extGCD0(b, a, xy);\n            SequenceUtils.swap(xy, 0, 1);\n            return ans;\n        }\n\n        private static int extGCD0(int a, int b, int[] xy) {\n            if (b == 0) {\n                xy[0] = 1;\n                xy[1] = 0;\n                return a;\n            }\n            int ans = extGCD0(b, a % b, xy);\n            int x = xy[0];\n            int y = xy[1];\n            xy[0] = y;\n            xy[1] = x - a / b * y;\n            return ans;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static interface IntCombination {\n    }\n\n    static class Combination implements IntCombination {\n        final Factorial factorial;\n        final Modular modular;\n\n        public Combination(Factorial factorial) {\n            this.factorial = factorial;\n            this.modular = factorial.getMod();\n        }\n\n        public Combination(int limit, Power pow) {\n            this(new Factorial(limit, pow));\n        }\n\n        public int combination(int m, int n) {\n            if (n > m || n < 0) {\n                return 0;\n            }\n            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        Modular mod;\n\n        public Modular getMod() {\n            return mod;\n        }\n\n        public Factorial(int[] fact, int[] inv, Power pow) {\n            this.mod = pow.getModular();\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, pow.getModular().getMod());\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = mod.mul(fact[i], fact[i - 1]);\n            }\n            inv[n - 1] = pow.inverse(fact[n - 1]);\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = mod.mul(inv[i + 1], i + 1);\n            }\n        }\n\n        public Factorial(int limit, Power pow) {\n            this(new int[limit + 1], new int[limit + 1], pow);\n        }\n\n        public int fact(int n) {\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            return inv[n];\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static class IntExtGCDObject {\n        private int[] xy = new int[2];\n\n        public int extgcd(int a, int b) {\n            return ExtGCD.extGCD(a, b, xy);\n        }\n\n        public int getX() {\n            return xy[0];\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in) ;\n\tpublic static void main(String[]args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\t\n\tlong MOD = 998244353;\n\t\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint n = s.length();\n\t\t\n\t\tint b[] = new int[n];\n\t\tint r[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tb[i] = s.charAt(i) - '0';\n\t\t\tr[i] = 2 - b[i];\n\t\t}\n\t\t\n\t\t\n\t\tint bb[] = new int[n+1];\n\t\tint rr[] = new int[n+1];\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tbb[i + 1] = bb[i] + b[i];\n\t\t\trr[i + 1] = rr[i] + r[i];\n\t\t}\n\t\t\n\t\t\n\t\tlong dp[][] = new long[n+1][n+1];\n\t\tdp[0][0] = 1;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\n\t\t\tfor(int rc = 0; rc <= i ; rc++) {\n\t\t\t\tint bc = i-rc;\n\t\t\t\t\n\t\t\t\tif(rr[i+1] >= rc+1) {\n\t\t\t\t\tdp[rc+1][bc] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t\tif(bb[i+1] >= bc+1) {\n\t\t\t\t\tdp[rc][bc+1] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\n\t\tlong res = 0;\n\t\tfor(int rc = 0 ; rc <= n ; rc++) {\n\t\t\tint bc = n - rc;\n\t\t\tres = nCr(n, rr[n] - rc)\n\t\t\t\t\t.multiply( BigInteger.valueOf(dp[rc][bc]))\n\t\t\t\t\t.add(BigInteger.valueOf(res))\n\t\t\t\t\t.mod(BigInteger.valueOf(MOD))\n\t\t\t\t\t.longValue();\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tBigInteger[][] ncr = new BigInteger[2001][2001];\n//\tlong[][] ncr = new long[2001][2001];\n\n\tBigInteger nCr(int n, int r) {\n\t\tif(r > n || r < 0) {\n\t\t\treturn BigInteger.ZERO;\n\t\t}\n\t\tif(n == r || r == 0) {\n\t\t\treturn BigInteger.ONE;\n\t\t}\n\t\tif(r == 1 || r == n-1) {\n\t\t\treturn BigInteger.valueOf(n);\n\t\t}\n\t\tif(ncr[n][r] != null) {\n\t\t\treturn ncr[n][r];\n\t\t}\n\t\t\n\t\tncr[n][r] = (nCr(n-1,r).add(nCr(n-1,r-1)));\n\t\treturn ncr[n][r] ;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FPass solver = new FPass();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FPass {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            Modular mod = new Modular(998244353);\n            char[] s = in.readString().toCharArray();\n            int n = s.length;\n\n            int[][] dp = new int[n + 1][n + 1];\n            dp[0][0] = 1;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j <= i; j++) {\n                    int b = j;\n                    int r = i - j;\n                    int way = dp[i][j];\n                    if (way == 0) {\n                        continue;\n                    }\n                    if (s[i] == '0') {\n                        //two blue\n                        //this is blue\n                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);\n                        //this is red\n                        if (r > 0) {\n                            dp[i + 1][j + 2] = mod.plus(dp[i + 1][j + 2], way);\n                        }\n                    } else if (s[i] == '1') {\n                        //one blue one red\n                        //this is blue\n                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);\n                        //this is red\n                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);\n                    } else {\n                        //two red\n                        //this is blue\n                        if (j > 0) {\n                            dp[i + 1][j - 1] = mod.plus(dp[i + 1][j - 1], way);\n                        }\n                        //this is red\n                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);\n                    }\n                }\n            }\n\n            int ans = 0;\n            Combination comb = new Combination(n, new Power(mod));\n            for (int i = 0; i <= n; i++) {\n                int way = dp[n][i];\n                way = mod.mul(way, comb.combination(n, i));\n                ans = mod.plus(ans, way);\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        static IntExtGCDObject extGCD = new IntExtGCDObject();\n        final Modular modular;\n\n        public Modular getModular() {\n            return modular;\n        }\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int inverse(int x) {\n            int ans = inverseExtGCD(x);\n//        if(modular.mul(ans, x) != 1){\n//            throw new IllegalStateException();\n//        }\n            return ans;\n        }\n\n        public int inverseExtGCD(int x) {\n            if (extGCD.extgcd(x, modular.getMod()) != 1) {\n                throw new IllegalArgumentException();\n            }\n            return modular.valueOf(extGCD.getX());\n        }\n\n    }\n\n    static class ExtGCD {\n        public static int extGCD(int a, int b, int[] xy) {\n            if (a >= b) {\n                return extGCD0(a, b, xy);\n            }\n            int ans = extGCD0(b, a, xy);\n            SequenceUtils.swap(xy, 0, 1);\n            return ans;\n        }\n\n        private static int extGCD0(int a, int b, int[] xy) {\n            if (b == 0) {\n                xy[0] = 1;\n                xy[1] = 0;\n                return a;\n            }\n            int ans = extGCD0(b, a % b, xy);\n            int x = xy[0];\n            int y = xy[1];\n            xy[0] = y;\n            xy[1] = x - a / b * y;\n            return ans;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static interface IntCombination {\n    }\n\n    static class Combination implements IntCombination {\n        final Factorial factorial;\n        final Modular modular;\n\n        public Combination(Factorial factorial) {\n            this.factorial = factorial;\n            this.modular = factorial.getMod();\n        }\n\n        public Combination(int limit, Power pow) {\n            this(new Factorial(limit, pow));\n        }\n\n        public int combination(int m, int n) {\n            if (n > m || n < 0) {\n                return 0;\n            }\n            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        Modular mod;\n\n        public Modular getMod() {\n            return mod;\n        }\n\n        public Factorial(int[] fact, int[] inv, Power pow) {\n            this.mod = pow.getModular();\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, pow.getModular().getMod());\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = mod.mul(fact[i], fact[i - 1]);\n            }\n            inv[n - 1] = pow.inverse(fact[n - 1]);\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = mod.mul(inv[i + 1], i + 1);\n            }\n        }\n\n        public Factorial(int limit, Power pow) {\n            this(new int[limit + 1], new int[limit + 1], pow);\n        }\n\n        public int fact(int n) {\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            return inv[n];\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static class IntExtGCDObject {\n        private int[] xy = new int[2];\n\n        public int extgcd(int a, int b) {\n            return ExtGCD.extGCD(a, b, xy);\n        }\n\n        public int getX() {\n            return xy[0];\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FPass solver = new FPass();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FPass {\n        static final int mod = 998244353;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            char[] cs = in.nextChars();\n            int[] r = new int[cs.length];\n            int[] b = new int[cs.length];\n            for (int i = 0; i < r.length; i++) {\n                r[i] = cs[i] == '0' ? 2 : cs[i] == '1' ? 1 : 0;\n                b[i] = cs[i] == '0' ? 0 : cs[i] == '1' ? 1 : 2;\n            }\n            int[][] maxR = new int[cs.length * 2][cs.length + 1];\n            int[][] maxB = new int[cs.length * 2][cs.length + 1];\n            for (int i = 0; i < cs.length; i++) {\n                maxR[0][i] = r[i];\n                maxB[0][i] = b[i];\n            }\n            for (int i = 1; i < maxR.length; i++) {\n                for (int j = 0; j < cs.length; j++) {\n                    maxR[i][j] += r[j] + Math.min(i, maxR[i - 1][j + 1]);\n                    maxB[i][j] += b[j] + Math.min(i, maxB[i - 1][j + 1]);\n                }\n            }\n            long[][] dp = new long[cs.length * 2 + 1][cs.length * 2 + 1];\n            dp[0][0] = 1;\n            for (int i = 1; i < dp.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    final int blue = i - j - 1;\n                    if (maxB[i - 1][0] > blue) {\n//                    dump(\"B\", i, j, dp[i - 1][j]);\n                        dp[i][j] += dp[i - 1][j];   // b\n                        if (dp[i][j] >= mod) dp[i][j] -= mod;\n                    }\n                    if (maxR[i - 1][0] >= j + 1) {\n//                    dump(\"R\", i, j, dp[i - 1][j]);\n                        dp[i][j + 1] += dp[i - 1][j]; // r\n                        if (dp[i][j] >= mod) dp[i][j] -= mod;\n                    }\n                }\n            }\n            out.println(Arrays.stream(dp[dp.length - 1]).sum() % mod);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public char[] nextChars() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            return Arrays.copyOf(str, len);\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tchar[] s = ns().toCharArray();\n\t\tint mod = 998244353;\n\t\tint[][] fif = enumFIF(5000, mod);\n\t\tint n = s.length;\n\t\tlong[] dp = new long[n+1];\n\t\tdp[0] = 1;\n\t\tint all = 0;\n\t\tfor(char c : s){\n\t\t\tall += c-'0';\n\t\t}\n\t\tint ts = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tlong[] ndp = new long[n+1];\n\t\t\tts += s[i]-'0';\n\t\t\tint tall = 2*i+2;\n\t\t\tfor(int j = 0;j <= i;j++){\n\t\t\t\tif(ts-j > 0){\n\t\t\t\t\tndp[j+1] += dp[j];\n\t\t\t\t\tif(ndp[j+1] >= mod)ndp[j+1] -= mod;\n\t\t\t\t}\n\t\t\t\tif((tall-ts)-(i-j) > 0){\n\t\t\t\t\tndp[j] += dp[j];\n\t\t\t\t\tif(ndp[j] >= mod)ndp[j] -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = ndp;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(int i = 0;i <= n;i++){\n\t\t\tans += dp[i]*C(n, all-i, mod, fif);\n\t\t\tans %= mod;\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FPass solver = new FPass();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FPass {\n        int mod = 998244353;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            String s = in.next();\n\n            int n = s.length();\n\n            int[] r = new int[n];\n            int[] b = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                if (s.charAt(i) == '0') {\n                    r[i] += 2;\n                } else if (s.charAt(i) == '1') {\n                    r[i]++;\n                    b[i]++;\n                } else {\n                    b[i] += 2;\n                }\n            }\n\n            int[] pr = in.calculatePrefixSum(r);\n            int[] pb = in.calculatePrefixSum(b);\n\n            int[][] dp = new int[2 * n][2 * n + 1];\n\n            if (r[0] > 0) {\n                dp[0][1] = 1;\n            }\n\n            if (b[0] > 0) {\n                dp[0][0] = 1;\n            }\n\n            for (int i = 1; i < 2 * n; i++) {\n                for (int j = 0; j <= Math.min(i, pr[Math.min(i - 1, n - 1)]); j++) {\n                    int maxi = Math.min(i, n - 1);\n                    if (pr[maxi] > j) {\n                        dp[i][j + 1] += dp[i - 1][j];\n                        dp[i][j + 1] %= mod;\n                    }\n                    int bu = i - j;\n                    int br = pb[maxi] - bu;\n\n                    if (br > 0) {\n                        dp[i][j] += dp[i - 1][j];\n                        dp[i][j] %= mod;\n                    }\n                }\n            }\n\n            long ans = 0;\n\n            for (int i = 0; i <= 2 * n; i++) {\n                ans += dp[2 * n - 1][i];\n                ans %= mod;\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public int[] calculatePrefixSum(int[] a) {\n            int n = a.length;\n\n            int[] prefixSum = new int[n];\n\n            prefixSum[0] = a[0];\n\n            for (int i = 1; i < n; i++) {\n                prefixSum[i] = prefixSum[i - 1] + a[i];\n            }\n\n            return prefixSum;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tString s=in.next();\n\t\tint n=s.length();\n\t\tint[][] dp=new int[n+n+1][n+n+1];\n\t\tint[] c1=new int[n+1];\n\t\tint[] c2=new int[n+1];\n\t\tfor (int i=1;i<=n;++i) {\n\t\t\tc1[i]=c1[i-1];\n\t\t\tc2[i]=c2[i-1];\n\t\t\tif (s.charAt(i-1)=='0') c1[i]+=2;\n\t\t\telse if (s.charAt(i-1)=='2') c2[i]+=2;\n\t\t\telse {\n\t\t\t\t++c1[i];\n\t\t\t\t++c2[i];\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=1;\n\t\tfor (int i=0;i<=c1[n];++i)\n\t\t\tfor (int j=0;j<=c2[n];++j) if (c1[Math.min(n,i+j)]>=i&&c2[Math.min(n,i+j)]>=j) {\n\t\t\t\tif (i>0) dp[i][j]+=dp[i-1][j];\n\t\t\t\tif (dp[i][j]>=998244353) dp[i][j]-=998244353;\n\t\t\t\tif (j>0) dp[i][j]+=dp[i][j-1];\n\t\t\t\tif (dp[i][j]>=998244353) dp[i][j]-=998244353;\n\t\t\t}\n\t\tSystem.out.println(dp[c1[n]][c2[n]]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//package com.company;\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    public static class Task {\n        int mod = 998244353;\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n            char[] cc = sc.next().toCharArray();\n            int n = cc.length;\n            int r = 0, b = 0;\n            long[][] dp = new long[n + 1][n + 1];\n            dp[0][0] = 1;\n            for (int i = 0; i < n; i++) {\n                if (cc[i] == '0') {\n                    r += 2;\n                } else if (cc[i] == '1') {\n                    r += 1;\n                    b += 1;\n                } else {\n                    b += 2;\n                }\n                for (int prevUseRed = 0; prevUseRed <= i; prevUseRed++) {\n                    if (prevUseRed + 1 <= r) {\n                        dp[i + 1][prevUseRed + 1] += dp[i][prevUseRed];\n                        dp[i + 1][prevUseRed + 1] %= mod;\n                    }\n                    int prevUseBlue = i - prevUseRed;\n                    if (prevUseBlue + 1 <= b) {\n                        dp[i + 1][prevUseRed] += dp[i][prevUseRed];\n                        dp[i + 1][prevUseRed] %= mod;\n                    }\n                }\n            }\n            long[][] combin = new long[n + 1][n + 1];\n            for (int i = 0; i <= n; i++) {\n                combin[i][0] = combin[i][i] = 1;\n            }\n            for (int i = 2; i <= n; i++) {\n                for (int j = 1; j < i; j++) {\n                    combin[i][j] = (combin[i - 1][j - 1] + combin[i - 1][j]) % mod;\n                }\n            }\n            long tto = 0;\n            for (int i = 0; i <= Math.min(r, n); i++) {\n                long ways = dp[n][i];\n                int lr = r - i;\n                int lb = b - (n - i);\n                if (lb < 0) continue;\n                ways *= combin[n][lr];\n                ways %= mod;\n                tto = (tto + ways) % mod;\n            }\n            pw.println(tto);\n\n        }\n\n    }\n\n    private static long TIME_START, TIME_END;\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(\"23.in\"));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(\"froggy.out\"));\n\n\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(\"Test.in\"));\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n        System.out.println(\"Memory increased:\" + (usedMemoryAfter-usedMemoryBefore) / 1000000 );\n        System.out.println(\"Time used: \" + (TIME_END - TIME_START) + \".\");\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n        public Scanner(FileReader s) throws FileNotFoundException {br = new BufferedReader(s);}\n\n        public String next() throws IOException\n        {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public String nextLine() throws IOException {return br.readLine();}\n\n        public double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n        public boolean ready() throws IOException {return br.ready();}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solver {\n  final char[] cs;\n  final int n;\n  final ModCalculator mc;\n  final ModCombinationCache mcc;\n  \n  long[][] dpcache;\n  \n  Solver(char[] cs) {\n    this.cs = cs;\n    this.n = cs.length;\n    this.mc = new ModCalculator(998244353L);\n    this.mcc = new ModCombinationCache(mc);\n  }\n  \n  private long solve(int index, int pendingBlue) {\n    if (dpcache[index][pendingBlue] >= 0) {\n      return dpcache[index][pendingBlue];\n    }\n    if (index >= n) {\n//      System.err.printf(\"%d %d\\n\", n, pendingBlue);\n      return mcc.getC(n, pendingBlue);\n    }\n    dpcache[index][pendingBlue] = 0;\n    int nextPendingBlue = pendingBlue + cs[index] - '0';\n    if (nextPendingBlue >= 1) {\n      dpcache[index][pendingBlue] = mc.add(dpcache[index][pendingBlue], solve(index + 1, nextPendingBlue - 1));\n    }\n    if (2 + index - nextPendingBlue >= 1) {\n      dpcache[index][pendingBlue] = mc.add(dpcache[index][pendingBlue], solve(index + 1, nextPendingBlue));\n    }\n    return dpcache[index][pendingBlue];\n  }\n  \n  public long solve() {\n    dpcache = new long[n + 1][n + 1];\n    for (long[] array : dpcache) {\n      Arrays.fill(array, -1);\n    }\n    return solve(0, 0);\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    char[] cs = reader.next().toCharArray();\n    out.println(new Solver(cs).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] nextArray(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextIntArray(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLongArray(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDoubleArray(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public int[][] nextIntMatrix(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLongMatrix(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDoubleMatrix(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n}\n \nclass ModCombinationCache {\n  private final ModCalculator modCalculator;\n  private final List<Long> factorialCache;\n  private final List<Long> factorialInverseCache;\n  \n  public ModCombinationCache(ModCalculator modCalculator) {\n    this.modCalculator = modCalculator;\n    factorialCache = new ArrayList<>();\n    factorialCache.add(1L);\n    factorialInverseCache = new ArrayList<>();\n    factorialInverseCache.add(1L);\n  }\n  \n  private void resize(int n) {\n    for (int i = factorialCache.size() - 1; i < n; i++) {\n      long v = modCalculator.mul(factorialCache.get(i), i + 1);\n      factorialCache.add(v);\n      factorialInverseCache.add(modCalculator.inverse(v));\n    }\n  }\n  \n  public long getF(int n) {\n    resize(n);\n    return factorialCache.get(n);\n  }\n  \n  public long getP(int n, int r) {\n    resize(n);\n    return modCalculator.mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n  }\n  \n  public long getC(int n, int k) {\n    resize(n);\n    return modCalculator.mul(factorialCache.get(n), modCalculator.mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n  }\n}\n\nclass Algorithm {\n  private static void swap(Object[] list, int a, int b) {\n    Object tmp = list[a];\n    list[a] = list[b];\n    list[b] = tmp;\n  }\n  \n  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {\n    int rightMostAscendingOrderIndex = ts.length - 2;\n    while (rightMostAscendingOrderIndex >= 0 &&\n        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {\n      rightMostAscendingOrderIndex--;\n    }\n    if (rightMostAscendingOrderIndex < 0) {\n      return false;\n    }\n    \n    int rightMostGreatorIndex = ts.length - 1;\n    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {\n      rightMostGreatorIndex--;\n    }\n    \n    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);\n    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {\n      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);\n    }\n    return true;\n  }\n  \n  public static void shuffle(int[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      int temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void shuffle(long[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      long temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void sort(int[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n  \n  public static void sort(long[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.regex.Pattern;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        FPass solver = new FPass();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FPass {\n        private static final int MOD = 998244353;\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            Debug.enable(\"src\");\n            String s = in.string();\n            int n = s.length(), n2 = n * 2;\n            int[] sum = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                sum[i + 1] = sum[i] + (s.charAt(i) - '0');\n            }\n\n            long[][] dp = new long[n2 + 1][n2 + 1];\n            dp[0][0] = 1;\n            // 青の個数, ターン, 人\n            for (int i = 0; i < n2; i++) {\n                // i + 1 回使った\n                int bl = sum[Math.min(i + 1, n)];\n                int re = (i + 1) * 2 - bl;\n\n                // 赤を出す\n                for (int j = 0; j <= Math.min(re, i + 1); j++) {\n                    // j個\n                    dp[i + 1][i + 1 - j] += dp[i][i + 1 - j];\n                    dp[i + 1][i + 1 - j] %= MOD;\n                }\n\n                //　青を出す\n                for (int j = Math.max(1, i + 1 - re); j <= Math.min(bl, i + 1); j++) {\n                    // j個今までに使う\n                    dp[i + 1][j] += dp[i][j - 1];\n                    dp[i + 1][j] %= MOD;\n                }\n            }\n            //Debug.debug(dp);\n            out.ans(dp[n2][sum[n]]).ln();\n        }\n\n    }\n\n    static class Debug {\n        private static final String DEBUG_CALL_PATTERN = \"^.+\\\\.debug\\\\((.+)\\\\);.*$\";\n        private static Pattern debugRegex;\n        private static boolean enabled = false;\n        private static String src;\n\n        public static void enable(String s) {\n            enabled = true;\n            src = s;\n            if (debugRegex == null) {\n                debugRegex = Pattern.compile(DEBUG_CALL_PATTERN);\n            }\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FPass solver = new FPass();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FPass {\n        int mod = 998244353;\n\n        int[] getSeq(char[] c, int want) {\n            int n = c.length;\n            int[] a1 = new int[n];\n            int[] a2 = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (c[i] == '0') {\n                    a1[i] = 0;\n                    a2[i] = 0;\n                } else if (c[i] == '1') {\n                    a1[i] = 0;\n                    a2[i] = 1;\n                } else {\n                    a1[i] = 1;\n                    a2[i] = 1;\n                }\n            }\n            int[] seq = new int[2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                if (a1[0] == want) {\n                    seq[i] = want;\n                    a1[0] = -1;\n                } else if (a2[0] == want) {\n                    seq[i] = want;\n                    a2[0] = -1;\n                } else {\n                    seq[i] = 1 - want;\n                    a1[0] = -1;\n                }\n                for (int j = 1; j < n; j++) {\n                    int have = (a1[j] == want || a2[j] == want) ? want : 1 - want;\n                    if (have == want) {\n                        if (a1[j] == want) a1[j] = -1;\n                        else a2[j] = -1;\n                    } else {\n                        if (a1[j] != -1) a1[j] = -1;\n                        else a2[j] = -1;\n                    }\n\n                    if (a1[j - 1] == -1) a1[j - 1] = have;\n                    else a2[j - 1] = have;\n                }\n            }\n            return seq;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            char[] c = in.next().toCharArray();\n            int n = c.length;\n            int[] min = getSeq(c, 0);\n            int[] max = getSeq(c, 1);\n            for (int i = 1; i < 2 * n; i++) {\n                min[i] += min[i - 1];\n                max[i] += max[i - 1];\n            }\n\n            int[] dp = new int[2 * n + 1];\n            dp[0] = 1;\n            for (int i = 0; i < 2 * n; i++) {\n                int[] ndp = new int[2 * n + 1];\n                for (int have = min[i]; have <= max[i]; have++) {\n                    ndp[have] += dp[have];\n                    if (have > 0) ndp[have] += dp[have - 1];\n                    if (ndp[have] >= mod) ndp[have] -= mod;\n                }\n                dp = ndp;\n            }\n            out.println(AUtils.sum(dp));\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class AUtils {\n        public static int sum(int[] arr) {\n            return Arrays.stream(arr).reduce(0, Integer::sum);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public String next() {\n            int c;\n            while (isSpaceChar(c = this.read())) {\n                ;\n            }\n\n            StringBuilder result = new StringBuilder();\n            result.appendCodePoint(c);\n\n            while (!isSpaceChar(c = this.read())) {\n                result.appendCodePoint(c);\n            }\n\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    long MOD = 998244353;\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        String l = sc.next();\n        int n = l.length();\n        int[] rs = new int[n];\n        int[] bs = new int[n];\n        for (int i = 0; i < n; i++) {\n            switch (l.charAt(i)) {\n                case '0':\n                    rs[i] = 2;\n                    bs[i] = 0;\n                    break;\n                case '1':\n                    rs[i] = 1;\n                    bs[i] = 1;\n                    break;\n                case '2':\n                    rs[i] = 0;\n                    bs[i] = 2;\n                    break;\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            rs[i] += rs[i - 1];\n            bs[i] += bs[i - 1];\n        }\n\n//        debug(\"rbs\", rs, bs);\n\n\n        long[][] dp = new long[2 * n + 1][rs[n - 1] + 1];\n\n        dp[0][0] = 1;\n        for (int i = 1; i <= 2 * n; i++) {\n            int reach = Math.min(i - 1, n - 1);\n            if (bs[reach] >= i) {\n                dp[i][0] = dp[i - 1][0];\n            }\n            for (int j = 1;j <= Math.min(i, rs[reach]); j++) if (i - j <= bs[reach]) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n            }\n            for (int j = 1;j <= Math.min(i, rs[reach]); j++) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n            }\n//            debug(dp[i]);\n        }\n        System.out.println(dp[2 * n][rs[n - 1]]);\n    }\n\n    void debug(Object...os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tint ans = 0;\n\t\tScanner sc = new Scanner(System.in);\n\t\tStrint s = sc.next();\n\t\tString[] strs = s.split(\"\");\n\t\tint strnum = strs.length\n\t\tint[][] balls = new int[strnum][2];\n\t\t\n\t\tint r = 0;\n\t\tint b = 0;\n\t\tfor(int i=0; i<strnum; i++){\n\t\t\tif(strs[i].equals(\"0\")){\n\t\t\t\tr += 2;\n\t\t\t}\n\t\t\tif(strs[i].equals(\"1\")){\n\t\t\t\tr += 1;\n\t\t\t\tb += 1;\n\t\t\t}\n\t\t\tif(strs[i].equals(\"2\")){\n\t\t\t\tb += 2;\n\t\t\t}\n\t\t\tballs[i][0] = r;\n\t\t\tballs[i][1] = b;\n\t\t}\n\t\t\n\t\tint[][] pascal = new int[strnum][strnum];\n\t\tpascal[0][0] = 1;\n\t\tpascal[0][1] = 1;\n\t\tint[][] ballpat = new int[strnum][strnum];\n\t\tif(strs[0].equals(\"0\")){\n\t\t\tballpat[0][0] = 1;\n\t\t\tballpat[0][1] = 0;\n\t\t}\n\t\tif(strs[i].equals(\"1\")){\n\t\t\tballpat[0][0] = 1;\n\t\t\tballpat[0][1] = 1;\n\t\t}\n\t\tif(strs[i].equals(\"2\")){\n\t\t\tballpat[0][0] = 0;\n\t\t\tballpat[0][1] = 1;\n\t\t}\n\t\tfor(int i=1; i<strnum; i++){\n\t\t\tpascal[i][0] = 1;\n\t\t\tpascal[i][i+1] = 1;\n\t\t\tfor(int j=1; j<=i; j++){\n\t\t\t\tpascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j];\n\t\t\t}\n\t\t\tint s = 1;\n\t\t\tint e = i;\n\t\t\tif(balls[i][0] < i){\n\t\t\t\tfor(int j=0; j<i-balls[i][0]; j++){\n\t\t\t\t\tballpat[i][j] = 0;\n\t\t\t\t}\n\t\t\t\ts = i-balls[i][0];\n\t\t\t}\n\t\t\tif(balls[i][1] < i){\n\t\t\t\tfor(int j=0; j<i-balls[i][1]; j++){\n\t\t\t\t\tballpat[i][i+1-j] = 0;\n\t\t\t\t}\n\t\t\t\te = balls[i][1] + 1;\n\t\t\t}\n\t\t\tfor(int j=s; j<=e; j++){\n\t\t\t\tballpat[i][j] = ballpat[i-1][j-1] + ballpat[i-1][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<strnum+1; i++){\n\t\t\tans += pascal[strnum-1][i] * ballpat[strnum-1][i];\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 998244353;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tchar[] s = in.nextChars();\n\t\t\tint n = s.length;\n\t\t\tint[] rsum = new int[2*n+1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trsum[i+1] = rsum[i] + '2' - s[i];\n\t\t\t}\n\n\t\t\t// i 回後の操作後に赤いボールが r 個含まれている場合の数\n\t\t\tlong[][] dp = new long[n+1][2*n+1];\n\t\t\tdp[0][0] = 1;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int r = 0; r <= i; r++) {\n\n\t\t\t\t\tif (dp[i][r] == 0) continue;\n\n\t\t\t\t\t// i+1 回後に赤いボールを r+1 個含むことができる場合\n\t\t\t\t\tif (rsum[i+1] >= r+1) {\n\t\t\t\t\t\tdp[i+1][r+1] += dp[i][r];\n\t\t\t\t\t\tdp[i+1][r+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\t// i+1 回後に赤いボールを r 個含むことができる場合\n\t\t\t\t\tif ((i+1)*2 - rsum[i+1] >= i + 1 - r) {\n\t\t\t\t\t\tdp[i+1][r] += dp[i][r];\n\t\t\t\t\t\tdp[i+1][r] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 残りの n 個のボールの並べ方は任意\n\t\t\tlong res = 0;\n\t\t\tfor (int r = 0; r <= n; r++) {\n\t\t\t\tres += dp[n][r] * comb(n, rsum[n] - r) % MOD;\n\t\t\t\tres %= MOD;\n\t\t\t}\n\n\t\t\tout.println(res);\n\n\t\t}\n\t}\n\n\t/**\n\t * 二項係数\n\t * 前提 n < modP\n\t * nCr = n!/(r!*(n-r)!)である。この時分子分母にMODが来る場合は以下のように使用する\n\t * */\n\tpublic static long comb(int n, int r) {\n\t\tif (r < 0 || r > n)\n\t\t\treturn 0L;\n\t\treturn fact[n] % MOD * factInv[r] % MOD * factInv[n - r] % MOD;\n\t}\n\n\tpublic static int MAXN = 200000;\n\n\tstatic long[] fact = factorialArray(MAXN, MOD);\n\tstatic long[] factInv = factorialInverseArray(MAXN, MOD,\n\t\t\tinverseArray(MAXN, MOD));\n\n\tpublic static long[] factorialArray(int maxN, long mod) {\n\t\tlong[] fact = new long[maxN + 1];\n\t\tfact[0] = 1 % mod;\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tfact[i] = fact[i - 1] * i % mod;\n\t\t}\n\t\treturn fact;\n\t}\n\n\tpublic static long[] inverseArray(int maxN, long modP) {\n\t\tlong[] inv = new long[maxN + 1];\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i <= maxN; i++) {\n\t\t\tinv[i] = modP - (modP / i) * inv[(int) (modP % i)] % modP;\n\t\t}\n\t\treturn inv;\n\t}\n\n\tpublic static long[] factorialInverseArray(int maxN, long modP,\n\t\t\tlong[] inverseArray) {\n\t\tlong[] factInv = new long[maxN + 1];\n\t\tfactInv[0] = 1;\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tfactInv[i] = factInv[i - 1] * inverseArray[i] % modP;\n\t\t}\n\t\treturn factInv;\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in) ;\n\tpublic static void main(String[]args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\t\n\tlong MOD = 998244353;\n\t\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint n = s.length();\n\t\t\n\t\tint b[] = new int[n];\n\t\tint r[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tb[i] = s.charAt(i) - '0';\n\t\t\tr[i] = 2 - b[i];\n\t\t}\n\t\t\n\t\t\n\t\tint bb[] = new int[n+1];\n\t\tint rr[] = new int[n+1];\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tbb[i + 1] = bb[i] + b[i];\n\t\t\trr[i + 1] = rr[i] + r[i];\n\t\t}\n\t\t\n\t\t\n\t\tlong dp[][] = new long[n+1][n+1];\n\t\tdp[0][0] = 1;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\n\t\t\tfor(int rc = 0; rc <= i ; rc++) {\n\t\t\t\tint bc = i-rc;\n\t\t\t\t\n\t\t\t\tif(rr[i+1] >= rc+1) {\n\t\t\t\t\tdp[rc+1][bc] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t\tif(bb[i+1] >= bc+1) {\n\t\t\t\t\tdp[rc][bc+1] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n//\t\tSystem.out.println(nCr(2000,1000));\n\n\t\tlong res = 0;\n\t\tfor(int rc = 0 ; rc <= n ; rc++) {\n\t\t\tint bc = n - rc;\n\t\t\tres += dp[rc][bc] * nCr(n, rr[n] - rc);\n\t\t\tres %= MOD;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tlong[][] ncr = new long[2001][2001];\n\n\tlong nCr(int n, int r) {\n\t\tif(r > n ) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(n == r || r == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(r == 1 || r == n-1) {\n\t\t\treturn n;\n\t\t}\n\t\tif(ncr[n][r] != 0) {\n\t\t\treturn ncr[n][r];\n\t\t}\n\t\t\n\t\tncr[n][r] = (nCr(n-1,r) + nCr(n-1,r-1))%MOD;\n\t\treturn ncr[n][r] ;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        char[] s = sc.nextChars();\n        int n = s.length;\n        int[] cr = new int[2 * n + 1];\n        int[] cb = new int[2 * n + 1];\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                cr[i + 1] = cr[i] + 2;\n                cb[i + 1] = cb[i];\n            } else if (s[i] == '1') {\n                cr[i + 1] = cr[i] + 1;\n                cb[i + 1] = cb[i] + 1;\n            } else {\n                cr[i + 1] = cr[i];\n                cb[i + 1] = cb[i] + 2;\n            }\n        }\n        for (int i = n; i < 2 * n; i++) {\n            cr[i + 1] = cr[i];\n            cb[i + 1] = cb[i];\n        }\n        int p = 998244353;\n        long[][] dp = new long[2 * n + 1][2 * n + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= 2 * n; i++) {\n            for (int r = 0; r <= 2 * n; r++) {\n                int b = i - r;\n                if (cr[i] < r || cb[i] < b) continue;\n                dp[i][r] = dp[i - 1][r];\n                if (r > 0 && (dp[i][r] += dp[i - 1][r - 1]) >= p) dp[i][r] -= p;\n            }\n        }\n        out.writeln(dp[2 * n][cr[2 * n]]);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 998244353;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tchar[] s = in.nextChars();\n\t\t\tint n = s.length;\n\t\t\tList<Integer> red = new ArrayList<>(), blue = new ArrayList<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (s[i] == '0') {\n\t\t\t\t\tred.add(i);\n\t\t\t\t\tred.add(i);\n\t\t\t\t} else if (s[i] == '1') {\n\t\t\t\t\tred.add(i);\n\t\t\t\t\tblue.add(i);\n\t\t\t\t} else if (s[i] == '2') {\n\t\t\t\t\tblue.add(i);\n\t\t\t\t\tblue.add(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint r = red.size(), b = blue.size();\n\t\t\tlong[][] dp = new long[r+1][b+1];\n\t\t\tdp[0][0] = 1;\n\t\t\tfor (int i = 0; i <= r; i++) {\n\t\t\t\tfor (int j = 0; j <= b; j++) {\n\t\t\t\t\tint x = i + j;\n\t\t\t\t\tif (i < r && red.get(i) <= x) {\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j < b && blue.get(j) <= x) {\n\t\t\t\t\t\tdp[i][j+1] += dp[i][j];\n\t\t\t\t\t\tdp[i][j+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[r][b]);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final long DIV = 998244353L;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int n = s.length();\n        int num0 = 0, num1 = 0;\n        for(int i=0; i<n; i++){\n            if(s.charAt(i) == '0'){\n                num0+= 2;\n            }else if(s.charAt(i) == '1'){\n                num0++;\n                num1++;\n            }else{\n                num1 += 2;\n            }\n        }\n\n        long[] fac = new long[2100];\n        fac[0] = 1;\n        fac[1] = 1;\n        for(int i=2; i<2100; i++){\n            fac[i] = fac[i-1] * i;\n            fac[i] %= DIV;\n        }\n\n        long[] ifac = new long[2100];\n        for(int i=0; i<2100; i++) ifac[i] = inverseElement(fac[i], DIV);\n\n        long ans = caluComb(num0, num1, DIV, fac, ifac);\n\n        int cnum0 = 0, cnum1 = 0;\n        long p0 = 1, p1 = 1;\n        for(int i=0; i<n; i++){\n            char t = s.charAt(i);\n            if(t == '1'){\n                cnum0++;\n                cnum1++;\n                continue;\n            }\n            if(t == '0'){\n                if(cnum1 >= i+1) continue;\n                ans -= p1 * caluComb(num0-(i-cnum1-1), num1-cnum1, DIV, fac, ifac);\n                if(ans < 0){\n                    ans += DIV*DIV;\n                    ans %= DIV;\n                }\n                cnum0 += 2;\n                p1 *= (i+2);\n            }else{\n                if(cnum0 >= i+1) continue;\n                ans -= p0 * caluComb(num1-(i-cnum0-1), num0-cnum0, DIV, fac, ifac);\n                if(ans < 0){\n                    ans += DIV*DIV;\n                    ans %= DIV;\n                }\n                cnum1 += 2;\n                p0 *= (i+2);\n            }\n        }\n\n        System.out.println(ans);\n    }\n\n    public static long caluComb(int a, int b, long div, long[] fac, long[] ifac){\n        long ret = fac[a+b];\n        ret %= DIV;\n        ret *= ifac[a];\n        ret %= DIV;\n        ret *= ifac[b];\n        ret %= DIV;\n        return ret;\n    }\n\n    public static long inverseElement(long a, long n){\n        long b = n, u=1, v=0;\n        while(b > 0) {\n            long t = a/b;\n            a -= t*b;\n            u -= t*v;\n            //swap\n            t = a;\n            a = b;\n            b = t;\n            t = u;\n            u = v;\n            v = t;\n        }\n        u = u % n;\n        if(u < 0) u += n;\n        return u;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    static long mod = 998244353;\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        char[] s= sc.next().toCharArray();\n        int n = s.length;\n        int[] red = new int[n+1], blue = new int[n+1];\n        for(int i=1;i<=n;i++){\n            int curBlue = s[i-1]-'0';\n            red[i]=red[i-1]+2-curBlue;\n            blue[i]=blue[i-1]+curBlue;\n        }\n        int maxBlue = blue[n];\n        // dp[i][j]: take i balls, among which j are blue (i-j are red);\n        long[][] dp = new long[n*2+1][maxBlue+1];\n        //long all = red[n]+blue[n];\n        dp[0][0]=1;\n        for(int i=1;i<=2*n;i++){\n            for(int j=0;j<=Math.min(i,blue[Math.min(i,n)]);j++){\n                if(red[Math.min(i,n)]<i-j) continue;\n                dp[i][j] = dp[i-1][j];\n                if(j>=1) dp[i][j] = (dp[i][j]+dp[i-1][j-1])%mod;\n            }\n        }\n        System.out.println(dp[2*n][maxBlue]);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in) ;\n\tpublic static void main(String[]args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\t\n\tlong MOD = 998244353;\n\t\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint n = s.length();\n\t\t\n\t\tint b[] = new int[n];\n\t\tint r[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tb[i] = s.charAt(i) - '0';\n\t\t\tr[i] = 2 - b[i];\n\t\t}\n\t\t\n\t\t\n\t\tint bb[] = new int[2*n+1];\n\t\tint rr[] = new int[2*n+1];\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tbb[i + 1] = bb[i] + b[i];\n\t\t\trr[i + 1] = rr[i] + r[i];\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tbb[i+n+1] = bb[i+n];\n\t\t\trr[i+n+1] = rr[i+n];\n\t\t}\n\t\t\n\t\t\n\t\tlong dp[][] = new long[2*n+1][2*n+1];\n\t\tdp[0][0] = 1;\n\t\t\n\t\tfor(int i = 0 ; i < 2*n ; i++) {\n\t\t\tfor(int rc = 0; rc <= i ; rc++) {\n\t\t\t\tint bc = i-rc;\n\t\t\t\t\n\t\t\t\tif(rr[i+1] >= rc+1) {\n\t\t\t\t\tdp[rc+1][bc] += dp[rc][bc];\n\t\t\t\t\tdp[rc+1][bc] %= MOD;\n\t\t\t\t}\n\t\t\t\tif(bb[i+1] >= bc+1) {\n\t\t\t\t\tdp[rc][bc+1] += dp[rc][bc];\n\t\t\t\t\tdp[rc][bc+1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[rr[n]][bb[n]] % MOD);\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.regex.Pattern;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        FPass solver = new FPass();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FPass {\n        private static final int MOD = 998244353;\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            Debug.enable(\"src\");\n            String s = in.string();\n            int n = s.length(), n2 = n * 2;\n            int[] sum = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                sum[i + 1] = sum[i] + (s.charAt(i) - '0');\n            }\n\n            long[][] dp = new long[n2 + 1][n2 + 1];\n            dp[0][0] = 1;\n            // 青の個数, ターン, 人\n            for (int i = 0; i < n2; i++) {\n                // i + 1 回使った\n                int bl = sum[Math.min(i + 1, n)];\n                int re = (i + 1) * 2 - bl;\n\n                // 赤を出す\n                for (int j = Math.max(0, i + 1 - bl); j <= Math.min(re, i + 1); j++) {\n                    // j個\n                    dp[i + 1][i + 1 - j] += dp[i][i + 1 - j];\n                    dp[i + 1][i + 1 - j] %= MOD;\n                }\n\n                //　青を出す\n                for (int j = Math.max(1, i + 1 - re); j <= Math.min(bl, i + 1); j++) {\n                    // j個今までに使う\n                    dp[i + 1][j] += dp[i][j - 1];\n                    dp[i + 1][j] %= MOD;\n                }\n            }\n            //Debug.debug(dp);\n            out.ans(dp[n2][sum[n]]).ln();\n        }\n\n    }\n\n    static class Debug {\n        private static final String DEBUG_CALL_PATTERN = \"^.+\\\\.debug\\\\((.+)\\\\);.*$\";\n        private static Pattern debugRegex;\n        private static boolean enabled = false;\n        private static String src;\n\n        public static void enable(String s) {\n            enabled = true;\n            src = s;\n            if (debugRegex == null) {\n                debugRegex = Pattern.compile(DEBUG_CALL_PATTERN);\n            }\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int MOD = 998244353;\n\n    static long solve() {\n        int N = S.length();\n        int R = 0, B = 0;\n        for (int i = 0; i < N; i++) {\n            if( S.charAt(i) == '0' ) {\n                R+=2;\n            } else if( S.charAt(i) == '1' ) {\n                R++;\n                B++;\n            } else {\n                B+=2;\n            }\n        }\n\n        long[][] dp = new long[R+1][B+1];\n        dp[0][0] = 1;\n        int curR = 0, curB = 0;\n        for (int i = 1; i <= R+B; i++) {\n            if( i <= N ) {\n                if( S.charAt(i-1) == '0' ) {\n                    curR+=2;\n                } else if( S.charAt(i-1) == '1' ) {\n                    curR++;\n                    curB++;\n                } else {\n                    curB+=2;\n                }\n            }\n\n            for (int r = 0; r <= i; r++) {\n                int b = i-r;\n                if( r <= curR && b <= curB ) {\n                    if( inRange(r-1, R) ) {\n                        dp[r][b] += dp[r-1][b];\n                    }\n                    if( inRange(b-1, B) ) {\n                        dp[r][b] += dp[r][b-1];\n                    }\n                    if( dp[r][b] >= MOD ) {\n                        dp[r][b] %= MOD;\n                    }\n                }\n            }\n        }\n        return dp[R][B];\n    }\n\n    static boolean inRange(int a, int A) {\n        return 0 <= a && a <= A;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package other2019.yahoo2019.qual;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    static final int MOD = 998244353;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        char[] s = in.nextToken().toCharArray();\n\n        int n = s.length;\n        int[][] dp = new int[2][2*n+1];\n\n        int red = 0;\n        int blue = 0;\n\n        dp[0][0] = 1;\n        for (int i = 0; i < 2*n ; i++) {\n            int fr = i%2;\n            int to = 1-fr;\n            Arrays.fill(dp[to], 0);\n\n            if (i < n) {\n                if (s[i] == '0') {\n                    red += 2;\n                } else if (s[i] == '1') {\n                    red += 1;\n                    blue += 1;\n                } else {\n                    blue += 2;\n                }\n            }\n            for (int u = 0 ; u <= 2*n ; u++) {\n                int base = dp[fr][u];\n                if (base == 0) {\n                    continue;\n                }\n                int lr = red-u;\n                int lb = blue-(i-u);\n                if (lr >= 1) {\n                    dp[to][u+1] += base;\n                    dp[to][u+1] %= MOD;\n                }\n                if (lb >= 1) {\n                    dp[to][u] += base;\n                    dp[to][u] %= MOD;\n                }\n            }\n        }\n\n        out.println(dp[0][red]);\n        out.flush();\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in) ;\n\tpublic static void main(String[]args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\t\n\tlong MOD = 998244353;\n\t\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint n = s.length();\n\t\t\n\t\tint b[] = new int[n];\n\t\tint r[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tb[i] = s.charAt(i) - '0';\n\t\t\tr[i] = 2 - b[i];\n\t\t}\n\t\t\n\t\t\n\t\tint bb[] = new int[n+1];\n\t\tint rr[] = new int[n+1];\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tbb[i + 1] = bb[i] + b[i];\n\t\t\trr[i + 1] = rr[i] + r[i];\n\t\t}\n\t\t\n\t\t\n\t\tlong dp[][] = new long[n+1][n+1];\n\t\tdp[0][0] = 1;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\n\t\t\tfor(int rc = 0; rc <= i ; rc++) {\n\t\t\t\tint bc = i-rc;\n\t\t\t\t\n\t\t\t\tif(rr[i+1] >= rc+1) {\n\t\t\t\t\tdp[rc+1][bc] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t\tif(bb[i+1] >= bc+1) {\n\t\t\t\t\tdp[rc][bc+1] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\n\t\tlong res = 0;\n\t\tfor(int rc = 0 ; rc <= n ; rc++) {\n\t\t\tint bc = n - rc;\n\t\t\tres += dp[rc][bc] * nCr(n, rr[n] - rc);\n\t\t\tres %= MOD;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tlong[][] ncr = new long[2001][2001];\n\n\tlong nCr(int n, int r) {\n\t\tif(r > n || r < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(n == r || r == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(r == 1 || r == n-1) {\n\t\t\treturn n;\n\t\t}\n\t\tif(ncr[n][r] != 0) {\n\t\t\treturn ncr[n][r];\n\t\t}\n\t\t\n\t\tncr[n][r] = (nCr(n-1,r) + nCr(n-1,r-1))%MOD;\n\t\treturn ncr[n][r] ;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in) ;\n\tpublic static void main(String[]args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\t\n\tlong MOD = 998244353;\n\t\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint n = s.length();\n\t\t\n\t\tint b[] = new int[n];\n\t\tint r[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tb[i] = s.charAt(i) - '0';\n\t\t\tr[i] = 2 - b[i];\n\t\t}\n\t\t\n\t\t\n\t\tint bb[] = new int[2*n+1];\n\t\tint rr[] = new int[2*n+1];\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tbb[i + 1] = bb[i] + b[i];\n\t\t\trr[i + 1] = rr[i] + r[i];\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tbb[i+n+1] = bb[i+n];\n\t\t\trr[i+n+1] = rr[i+n];\n\t\t}\n\t\t\n\t\t\n\t\tlong dp[][] = new long[2*n+1][2*n+1];\n\t\tdp[0][0] = 1;\n\t\t\n\t\tfor(int i = 0 ; i < 2*n ; i++) {\n\t\t\tfor(int rc = 0; rc <= i ; rc++) {\n\t\t\t\tint bc = i-rc;\n\t\t\t\t\n\t\t\t\tif(rr[i+1] >= rc+1) {\n\t\t\t\t\tdp[rc+1][bc] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t\tif(bb[i+1] >= bc+1) {\n\t\t\t\t\tdp[rc][bc+1] += dp[rc][bc];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[rr[n]][bb[n]] % MOD);\n\t\t\n\t}\n\t\n\tBigInteger[][] ncr = new BigInteger[2001][2001];\n\n\tBigInteger nCr(int n, int r) {\n\t\tif(r > n || r < 0) {\n\t\t\treturn BigInteger.ZERO;\n\t\t}\n\t\tif(n == r || r == 0) {\n\t\t\treturn BigInteger.ONE;\n\t\t}\n\t\tif(r == 1 || r == n-1) {\n\t\t\treturn BigInteger.valueOf(n);\n\t\t}\n\t\tif(ncr[n][r] != null) {\n\t\t\treturn ncr[n][r];\n\t\t}\n\t\t\n\t\tncr[n][r] = (nCr(n-1,r).add(nCr(n-1,r-1)));\n\t\treturn ncr[n][r] ;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// package other2019.yahoo2019.qual;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    static final int MOD = 998244353;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        char[] s = in.nextToken().toCharArray();\n\n        int n = s.length;\n        int[][] dp = new int[2][2*n];\n\n        int red = 0;\n        int blue = 0;\n\n        dp[0][0] = 1;\n        for (int i = 0; i < 2*n ; i++) {\n            int fr = i%2;\n            int to = 1-fr;\n            Arrays.fill(dp[to], 0);\n\n            if (i < n) {\n                if (s[i] == '0') {\n                    red += 2;\n                } else if (s[i] == '1') {\n                    red += 1;\n                    blue += 1;\n                } else {\n                    blue += 2;\n                }\n            }\n            for (int u = 0 ; u < 2*n ; u++) {\n                int base = dp[fr][u];\n                if (base == 0) {\n                    continue;\n                }\n                int lr = red-u;\n                int lb = blue-(i-u);\n                if (lr >= 1) {\n                    dp[to][u+1] += base;\n                    dp[to][u+1] %= MOD;\n                }\n                if (lb >= 1) {\n                    dp[to][u] += base;\n                    dp[to][u] %= MOD;\n                }\n            }\n        }\n\n        out.println(dp[0][red]);\n        out.flush();\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\n/*\n   AtCoder contest\n   coder : yoichidon\n */\npublic class Main {\n\n    public  static long[] reverse(long[] array){\n        int N = array.length;\n        long[] ans = new long[N];\n        for(int n=0; n<N; n++) ans[n]=array[N-n-1];\n        return ans;\n    }\n\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n        int N = S.length();\n\n        int[] redMax = new int[N];\n        int[] blueMax = new int[N];\n        for(int n=0; n<N; n++){\n            int b = S.charAt(n)-'0';\n            redMax[n] = (n==0) ? 2-b : 2-b+redMax[n-1];\n            blueMax[n] = (n==0) ? b : b+blueMax[n-1];\n        }\n\n        \n        long[][] dp = new long[redMax[N-1]+1][blueMax[N-1]+1];\n\n        for(int r=0; r<=redMax[N-1]; r++) for(int b=0; b<=blueMax[N-1]; b++){\n            int turn = r+b;\n            if(r==0  && b==0) dp[r][b]=1;\n            else if(turn<=N && (redMax[turn-1]<r || blueMax[turn-1]<b)) dp[r][b]=0;\n            else if(r==0) dp[r][b]=dp[r][b-1];\n            else if(b==0) dp[r][b]=dp[r-1][b];\n            else dp[r][b] = (dp[r][b-1]+dp[r-1][b])%998244353;\n\n        }\n\n        System.out.println(dp[redMax[N-1]][blueMax[N-1]]);\n\n\n\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "//package com.company;\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    public static class Task {\n        int mod = 998244353;\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n            char[] cc = sc.next().toCharArray();\n            int n = cc.length;\n            int r = 0, b = 0;\n            long[][] dp = new long[n + 1][n + 1];\n            dp[0][0] = 1;\n            for (int i = 0; i < n; i++) {\n                if (cc[i] == '0') {\n                    r += 2;\n                } else if (cc[i] == '1') {\n                    r += 1;\n                    b += 1;\n                } else {\n                    b += 2;\n                }\n                for (int prevUseRed = 0; prevUseRed <= i; prevUseRed++) {\n                    if (prevUseRed + 1 <= r) {\n                        dp[i + 1][prevUseRed + 1] += dp[i][prevUseRed];\n                        dp[i + 1][prevUseRed + 1] %= mod;\n                    }\n                    int prevUseBlue = i - prevUseRed;\n                    if (prevUseBlue + 1 <= b) {\n                        dp[i + 1][prevUseRed] += dp[i][prevUseRed];\n                        dp[i + 1][prevUseRed + 1] %= mod;\n                    }\n                }\n            }\n            long[][] combin = new long[n + 1][n + 1];\n            for (int i = 0; i <= n; i++) {\n                combin[i][0] = combin[i][i] = 1;\n            }\n            for (int i = 2; i <= n; i++) {\n                for (int j = 1; j < i; j++) {\n                    combin[i][j] = (combin[i - 1][j - 1] + combin[i - 1][j]) % mod;\n                }\n            }\n            long tto = 0;\n            for (int i = 0; i <= Math.min(r, n); i++) {\n                long ways = dp[n][i];\n                int lr = r - i;\n                int lb = b - (n - i);\n                if (lb < 0) continue;\n                ways *= combin[n][lr];\n                ways %= mod;\n                tto = (tto + ways) % mod;\n            }\n            pw.println(tto);\n\n        }\n\n    }\n\n    private static long TIME_START, TIME_END;\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(\"23.in\"));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(\"froggy.out\"));\n\n\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(\"Test.in\"));\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n        System.out.println(\"Memory increased:\" + (usedMemoryAfter-usedMemoryBefore) / 1000000 );\n        System.out.println(\"Time used: \" + (TIME_END - TIME_START) + \".\");\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n        public Scanner(FileReader s) throws FileNotFoundException {br = new BufferedReader(s);}\n\n        public String next() throws IOException\n        {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public String nextLine() throws IOException {return br.readLine();}\n\n        public double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n        public boolean ready() throws IOException {return br.ready();}\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        var s = sc.Str;\n        int n = s.Length;\n        var dp = new long[n * 2 + 1];\n        dp[0] = 1;\n        int rem = 0;\n        for (int i = 0; i < n * 2; i++)\n        {\n            int c = 0;\n            if (i < n) {\n                c = s[i] - '0';\n                rem += 2;\n            }\n            var nex = new long[n * 2 + 1];\n            for (int j = 0; j < n * 2 + 1; j++)\n            {\n                if (dp[j] == 0) continue;\n                if (rem > j + c)\n                    nex[j + c] = (nex[j + c] + dp[j]) % M2;\n                if (j + c > 0)\n                    nex[j + c - 1] = (nex[j + c - 1] + dp[j]) % M2;\n            }\n            dp = nex;\n            --rem;\n        }\n        Prt(dp[0]);\n\n        sw.Flush();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar t=sc.S;\n\t\tint n=t.Length,r=0,b=0;\n\t\tvar dp=new Mint[n<<1][];\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tr+=2-t[i]+'0';\n\t\t\tb+=t[i]-'0';\n\t\t\tdp[i]=new Mint[r+3];\n\t\t\tif(i==0){\n\t\t\t\tif(b>0){dp[i][0]=1;}\n\t\t\t\tif(r>0){dp[i][1]=1;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b>i){dp[i][0]=dp[i-1][0];}\n\t\t\tfor(int j = 1;j<=r;j++) {\n\t\t\t\tif(r>=j){dp[i][j]+=dp[i-1][j-1];}\n\t\t\t\tif(b>i-j){dp[i][j]+=dp[i-1][j];}\n\t\t\t}\n\t\t}\n\t\tn<<=1;\n\t\tfor(int i = n>>1;i<n;i++) {\n\t\t\tdp[i]=new Mint[r+1];\n\t\t\tif(b>i){dp[i][0]=1;}\n\t\t\tfor(int j = 1;j<=r;j++) {\n\t\t\t\tif(r>=j){dp[i][j]+=dp[i-1][j-1];}\n\t\t\t\tif(b>i-j){dp[i][j]+=dp[i-1][j];}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",dp[n-1][r]);\n\t}\n}\npublic struct Mint{\n\tconst int mod=998244353;\n\tprivate long d;\n\tpublic Mint(long d){this.d=d;}\n\tpublic static implicit operator Mint(long d){return new Mint(d%mod);}\n\tpublic static explicit operator long(Mint d){return d.d;}\n\tpublic override string ToString(){return d.ToString();}\n\tpublic static Mint operator+(Mint a,long b){a.d=(a.d+b)%mod;return a;}\n\tpublic static Mint operator+(Mint a,Mint b){a.d=(a.d+b.d)%mod;return a;}\n\tpublic static Mint operator-(Mint a,long b){a.d=(mod+a.d-b)%mod;return a;}\n\tpublic static Mint operator-(Mint a,Mint b){a.d=(mod+a.d-b.d)%mod;return a;}\n\tpublic static Mint operator*(Mint a,long b){a.d=(a.d*b)%mod;return a;}\n\tpublic static Mint operator*(Mint a,Mint b){a.d=(a.d*b.d)%mod;return a;}\n\tpublic static Mint operator/(Mint a,long b){a.d=(a.d*Mi(b))%mod;return a;}\n\tpublic static Mint operator/(Mint a,Mint b){a.d=(a.d*Mi(b.d))%mod;return a;}\n\tprivate static long Mi(long a){\n\t\ta=(a+mod)%mod;\n\t\tlong b=mod,u=1,v=0;\n\t\twhile(b>0){\n\t\t\tlong t=a/b;\n\t\t\ta-=t*b;a^=b;b^=a;a^=b;\n\t\t\tu-=t*v;u^=v;v^=u;u^=v;\n\t\t}\n\t\tu%=mod;\n\t\tif(u<0){u+=mod;}\n\t\treturn u%mod;\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),double.Parse);}\n\tpublic double[] Da3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n    int F => int.Parse(Str);\n    long FL => long.Parse(Str);\n    int[] G => Strs.Select(int.Parse).ToArray();\n    long[] GL => Strs.Select(long.Parse).ToArray();\n    string Str => ReadLine();\n    string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n    const int MOD = 998244353;\n    public K()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        WriteLine(Solve());\n        Out.Flush();\n    }\n    long Solve()\n    {\n        var S = Str;\n        var N = S.Length;\n        var d = new Dictionary<P, long> { [new P(0, 0)] = 1 };\n        fact = new long[5000];\n        ifact = new long[5000]; fact[0] = ifact[0] = 1;\n        for (var i = 1; i < 5000; i++) fact[i] = i * fact[i - 1] % MOD;\n        for (var i = 1; i < 5000; i++) ifact[i] = Inverse(fact[i], MOD);\n        for (var i = 0; i < N; i++)\n        {\n            int b = S[i] - '0', r = 2 - b;\n            var next = new Dictionary<P, long>();\n            foreach (var s in d.Keys)\n            {\n                var t = new P(s.R + r, s.B + b);\n                if (t.R > 0)\n                {\n                    var x = new P(t.R - 1, t.B);\n                    if (!next.ContainsKey(x)) next[x] = 0;\n                    next[x] += d[s];\n                }\n                if (t.B > 0)\n                {\n                    var x = new P(t.R, t.B - 1);\n                    if (!next.ContainsKey(x)) next[x] = 0;\n                    next[x] += d[s];\n                }\n            }\n            d.Clear();\n            foreach (var s in next.Keys) d[s] = next[s] % MOD;\n        }\n        var ans = 0L;\n        foreach (var t in d) ans = (ans + t.Value * Binomial(t.Key.R + t.Key.B, t.Key.R) % MOD) % MOD;\n        return ans;\n    }\n    long[] fact, ifact;\n    long Binomial(int n, int m) => fact[n] * ifact[m] % MOD * ifact[n - m] % MOD;\n    public static long Inverse(long a, long mod)\n    {\n        if (a < 0) { a %= mod; if (a < 0) a += mod; }\n        var t = SolveLinear(a, mod);\n        return t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n    }\n    public static Tuple<long, long> SolveLinear(long n, long m)\n    {\n        if (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n        if (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n        if (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n        long a = 1, b = 0, c = 0, d = 1;\n        while (m > 0)\n        {\n            var r = n % m;\n            var q = n / m;\n            n = m;\n            m = r;\n            var tmp = a;\n            a = -a * q + b;\n            b = tmp;\n            tmp = c;\n            c = -c * q + d;\n            d = tmp;\n        }\n        return n != 1 ? null : new Tuple<long, long>(d, b);\n    }\n}\nstruct P : IEquatable<P>\n{\n    public readonly int R, B;\n    public P(int r, int b) { R = r; B = b; }\n    public bool Equals(P other) => R == other.R && B == other.B;\n    public override bool Equals(object obj) => Equals((P)obj);\n    public override int GetHashCode() => CombineHashCodes(R.GetHashCode(), B.GetHashCode());\n    static int CombineHashCodes(int h1, int h2) => ((h1 << 5) + h1) ^ h2;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace AtTest.Yahoo2019\n{\n    class F\n    {\n        static void Main(string[] args)\n        {\n            Method(args);\n            Console.ReadLine();\n        }\n\n        static void Method(string[] args)\n        {\n            string s = Read();\n            int[] rCnt = new int[s.Length * 2 + 1];\n            int[] bCnt = new int[s.Length * 2 + 1];\n            for (int i = 0; i < s.Length; i++)\n            {\n                switch (s[i])\n                {\n                    case '0':\n                        rCnt[i+1] = 2;\n                        break;\n                    case '1':\n                        rCnt[i+1] = 1;\n                        bCnt[i+1] = 1;\n                        break;\n                    case '2':\n                        bCnt[i+1] = 2;\n                        break;\n                }\n                if (i > 0)\n                {\n                    rCnt[i+1] += rCnt[i];\n                    bCnt[i+1] += bCnt[i];\n                }\n            }\n            for (int i = s.Length + 1; i <= s.Length * 2; i++)\n            {\n                rCnt[i] = rCnt[i - 1];\n                bCnt[i] = bCnt[i - 1];\n            }\n            /*for (int i = 0; i < rCnt.Length; i++)\n                Console.WriteLine(rCnt[i] + \" \" + bCnt[i]);*/\n            int[,] dp = new int[s.Length * 2 + 1, s.Length * 2 + 1];\n            //i個目まで取り，赤をj個取った時のパターン数\n            int mask = 998244353;\n            dp[0, 0] = 1;\n            for (int i = 1; i <= s.Length * 2; i++)\n            {\n                for (int j = 0; j <= i; j++)\n                {\n                    int red = j;\n                    int blue = i - j;\n                    if (red > rCnt[i] || blue > bCnt[i]) dp[i, j] = 0;\n                    else\n                    {\n                        if (j == 0)\n                        {\n                            dp[i, j] = blue > bCnt[i] ? 0 : dp[i - 1, j];\n                        }\n                        else\n                        {\n                            if (red <= rCnt[i]) dp[i, j] = dp[i - 1, j - 1];\n                            if (blue <= bCnt[i]) dp[i, j] += dp[i - 1, j];\n                        }\n                    }\n                    dp[i, j] %= mask;\n                }\n            }\n            Console.WriteLine(dp[s.Length * 2, rCnt[s.Length * 2]]);\n        }\n\n        private static string Read() { return Console.ReadLine(); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Diagnostics;\n\nclass Program\n{\n    const int MOD = 998244353;\n    public void Slove()\n    {   \n        var input = Console.ReadLine();\n        int len = input.Length;\n\n        int red = 0;\n        int blue = 0;\n        int[] dp = new int[len * 2 + 1];\n        dp[0] = 1;\n        foreach(var i in Enumerable.Range(1, len * 2))\n        {\n            if(i - 1 < len)\n            {\n                if(input[i - 1] == '2')\n                {\n                    red += 1;\n                }\n                else if(input[i - 1] == '1')\n                {\n                    red += 1;\n                    blue ++;\n                }\n                else\n                    blue++;\n            }\n            if(i > 1 && i - 1 <= len)\n            {\n                if(input[i - 2] == '2')\n                {\n                    red += 1;\n                }\n                else if(input[i - 2] == '0')\n                {\n                    blue++;\n                }\n            }\n            foreach(int j in Enumerable.Range(0, red + 1).Reverse())\n            {\n                if(j < i - blue)\n                {\n                    dp[j] = 0;\n                    break;\n                }\n                if(j != 0)\n                    dp[j] += dp[j - 1];\n                if(dp[j] >= MOD)\n                    dp[j] %= MOD;\n            }\n            //Console.WriteLine($\"red:{red} blue:{blue}\");\n            //Console.WriteLine(string.Join(\",\", dp));\n        }\n        Console.WriteLine(dp[red]);\n\n    }\n    static void Main(string[] args)\n    {\n        var p = new Program();\n        p.Slove();\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing static Template;\nusing Pi = Pair<int, int>;\n\nclass Solver\n{\n    public void Solve(Scanner sc)\n    {\n        var S = sc.Str;\n        ModInt.Build(4040);\n        //i回目までの列に赤がj個ある場合の数\n        var dp = new ModInt[2020];\n        var newdp = new ModInt[2020];\n        int r = 0, b = 0;\n        dp[0] = 1;\n        for (int i = 0; i < S.Length; i++)\n        {\n            if (S[i] == '0') r += 2;\n            else if (S[i] == '1') { r++; b++; }\n            else b += 2;\n            for (int j = 0; j < 2020; j++)\n            {\n                newdp[j] = 0;\n                if (b > i - j) newdp[j] += dp[j];//青を取る\n                if (r >= j&&j>0) newdp[j] += dp[j - 1];//赤を取る\n            }\n            swap(ref dp, ref newdp);\n        }\n        ModInt res = 0;\n        for (int i = 0; i < 2020; i++)\n        {\n            res += dp[i] * ModInt.Comb(S.Length, r - i);//先頭N個*末尾N個\n        }\n        WriteLine(res);\n    }\n}\n\npublic struct ModInt\n{\n    //public const long MOD = (int)1e9 + 7;\n    public const long MOD = 998244353;\n    public long Value { get; set; }\n    public ModInt(long n = 0) { Value = n; }\n    private static ModInt[] fac;//階乗\n    private static ModInt[] inv;//逆数\n    private static ModInt[] facinv;//1/(i!)\n    public override string ToString() => Value.ToString();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator +(ModInt l, ModInt r)\n    {\n        l.Value += r.Value;\n        if (l.Value >= MOD) l.Value -= MOD;\n        return l;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator -(ModInt l, ModInt r)\n    {\n        l.Value -= r.Value;\n        if (l.Value < 0) l.Value += MOD;\n        return l;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator *(ModInt l, ModInt r) => new ModInt(l.Value * r.Value % MOD);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator /(ModInt l, ModInt r) => l * Pow(r, MOD - 2);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static implicit operator long(ModInt l) => l.Value;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static implicit operator ModInt(long n)\n    {\n        n %= MOD; if (n < 0) n += MOD;\n        return new ModInt(n);\n    }\n\n    public static ModInt Pow(ModInt m, long n)\n    {\n        if (n == 0) return 1;\n        if (n % 2 == 0) return Pow(m * m, n >> 1);\n        else return Pow(m * m, n >> 1) * m;\n    }\n\n    public static void Build(int n)\n    {\n        fac = new ModInt[n + 1];\n        facinv = new ModInt[n + 1];\n        inv = new ModInt[n + 1];\n        inv[1] = 1;\n        fac[0] = fac[1] = 1;\n        facinv[0] = facinv[1] = 1;\n        for (var i = 2; i <= n; i++)\n        {\n            fac[i] = fac[i - 1] * i;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i);\n            facinv[i] = facinv[i - 1] * inv[i];\n        }\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt Fac(ModInt n) => fac[n];\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt Inv(ModInt n) => inv[n];\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt FacInv(ModInt n) => facinv[n];\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt Comb(ModInt n, ModInt r)\n    {\n        if (n < r) return 0;\n        if (n == r) return 1;\n        var calc = fac[n];\n        calc = calc * facinv[r];\n        calc = calc * facinv[n - r];\n        return calc;\n    }\n}\n#region Template\npublic static class Template\n{\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver().Solve(new Scanner());\n        Console.Out.Flush();\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) == 1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) == -1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b) { var t = b; b = a; a = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(this IList<T> A, int i, int j) { var t = A[i]; A[i] = A[j]; A[j] = t; }\n    public static T[] Shuffle<T>(this IList<T> A) { T[] rt = A.ToArray(); Random rnd = new Random(); for (int i = rt.Length - 1; i >= 1; i--) swap(ref rt[i], ref rt[rnd.Next(i + 1)]); return rt; }\n    public static T[] Create<T>(int n, Func<T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(); return rt; }\n    public static T[] Create<T>(int n, Func<int, T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(i); return rt; }\n    public static int CompareTo<T>(this T[] A, T[] B, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; for (var i = 0; i < Min(A.Length, B.Length); i++) { int c = cmp(A[i], B[i]); if (c > 0) return 1; else if (c < 0) return -1; } if (A.Length == B.Length) return 0; if (A.Length > B.Length) return 1; else return -1; }\n    public static int MaxElement<T>(this IList<T> A, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; T max = A[0]; int rt = 0; for (int i = 1; i < A.Count; i++) if (cmp(max, A[i]) < 0) { max = A[i]; rt = i; } return rt; }\n    public static void PopBack<T>(this List<T> A) => A.RemoveAt(A.Count - 1);\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\npublic class Scanner\n{\n    public string Str => Console.ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n    //public (T1, T2) Make<T1, T2>() { Make(out T1 v1, out T2 v2); return (v1, v2); }\n    //public (T1, T2, T3) Make<T1, T2, T3>() { Make(out T1 v1, out T2 v2, out T3 v3); return (v1, v2, v3); }\n    //public (T1, T2, T3, T4) Make<T1, T2, T3, T4>() { Make(out T1 v1, out T2 v2, out T3 v3, out T4 v4); return (v1, v2, v3, v4); }\n}\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString() => $\"{v1.ToString()} {v2.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b) { a = v1; b = v2; }\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString() => $\"{base.ToString()} {v3.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b, out T3 c) { Deconstruct(out a, out b); c = v3; }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.IO_ShortCut;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        //const int MOD = 1000000007;\n        const int MOD = 998244353;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };Console.SetOut(sw);\n            Solve();\n            Console.Out.Flush();\n        }\n        static void Solve()\n        {\n            var S = Str;\n            int N = S.Length;\n            var dp = new ModInt[2 * N + 1, 2 * N + 1];\n            dp[0, 0] = 1;\n            var red = new long[2 * N + 1];\n            red[0] = 0;\n            for(var i = 0; i < N; i++)\n            {\n                red[i + 1] = red[i] + S[i] - '0';\n            }\n            for (var i = N; i < 2 * N; i++) red[i + 1] = red[i];\n            \n            for(var i = 0; i < 2 * N; i++)\n            {\n                for(var j = 0; j <= i; j++)\n                {\n\n                    if (red[i + 1] - j > 0)\n                    {\n                        dp[i + 1, j + 1] += dp[i, j];\n                    }\n                    if (red[i + 1] - j < i + 2)\n                    {\n                        dp[i + 1, j] += dp[i, j];\n                    }\n                }\n            }\n            OutL(dp[2 * N, red[2 * N]].value);\n        }\n        \n\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n            \n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    struct ModInt\n    {\n        public long value;\n        //private const int MOD = 1000000007;\n        private const int MOD = 998244353;\n\n        public ModInt(long value) { this.value = value; }\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        public static ModInt nCr(long n, long r)\n        {\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class IO_ShortCut\n    {\n        public static string[] _ReadSplit => Console.ReadLine().Split();\n        public static int[] _ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] _ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] _ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = _ReadSplit;a = Conv<T>(q[0]);b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = _ReadSplit;a = Conv<T>(q[0]);b = Conv<U>(q[1]);c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = _ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]);d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = _ReadSplit;a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a,long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar t=sc.S;\n\t\tint n=t.Length,r=0,b=0;\n\t\tvar dp=new Mint[n<<1][];\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tr+=2-t[i]+'0';\n\t\t\tb+=t[i]-'0';\n\t\t\tdp[i]=new Mint[r+3];\n\t\t\tif(i==0){\n\t\t\t\tif(b>0){dp[i][0]=1;}\n\t\t\t\tif(r>0){dp[i][1]=1;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b>i){dp[i][0]=dp[i-1][0];}\n\t\t\tfor(int j = 1;j<=r;j++) {\n\t\t\t\tif(r>=j){dp[i][j]+=dp[i-1][j-1];}\n\t\t\t\tif(b>i-j){dp[i][j]+=dp[i-1][j];}\n\t\t\t}\n\t\t}\n\t\tn<<=1;\n\t\tfor(int i = n>>1;i<n;i++) {\n\t\t\tdp[i]=new Mint[r+1];\n\t\t\tif(b>i){dp[i][0]=dp[i-1][0];}\n\t\t\tfor(int j = 1;j<=r;j++) {\n\t\t\t\tif(r>=j){dp[i][j]+=dp[i-1][j-1];}\n\t\t\t\tif(b>i-j){dp[i][j]+=dp[i-1][j];}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",dp[n-1][r]);\n\t}\n}\npublic struct Mint{\n\tconst int mod=998244353;\n\tprivate long d;\n\tpublic Mint(long d){this.d=d;}\n\tpublic static implicit operator Mint(long d){return new Mint(d%mod);}\n\tpublic static explicit operator long(Mint d){return d.d;}\n\tpublic override string ToString(){return d.ToString();}\n\tpublic static Mint operator+(Mint a,long b){a.d=(a.d+b)%mod;return a;}\n\tpublic static Mint operator+(Mint a,Mint b){a.d=(a.d+b.d)%mod;return a;}\n\tpublic static Mint operator-(Mint a,long b){a.d=(mod+a.d-b)%mod;return a;}\n\tpublic static Mint operator-(Mint a,Mint b){a.d=(mod+a.d-b.d)%mod;return a;}\n\tpublic static Mint operator*(Mint a,long b){a.d=(a.d*b)%mod;return a;}\n\tpublic static Mint operator*(Mint a,Mint b){a.d=(a.d*b.d)%mod;return a;}\n\tpublic static Mint operator/(Mint a,long b){a.d=(a.d*Mi(b))%mod;return a;}\n\tpublic static Mint operator/(Mint a,Mint b){a.d=(a.d*Mi(b.d))%mod;return a;}\n\tprivate static long Mi(long a){\n\t\ta=(a+mod)%mod;\n\t\tlong b=mod,u=1,v=0;\n\t\twhile(b>0){\n\t\t\tlong t=a/b;\n\t\t\ta-=t*b;a^=b;b^=a;a^=b;\n\t\t\tu-=t*v;u^=v;v^=u;u^=v;\n\t\t}\n\t\tu%=mod;\n\t\tif(u<0){u+=mod;}\n\t\treturn u%mod;\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),double.Parse);}\n\tpublic double[] Da3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.UInt32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var s = rs;\n            var n = s.Length;\n            var R = new int[n];\n            var B = new int[n];\n            for (int i = 0; i < s.Length; i++) {\n                if (s[i] == '0') R[i] += 2;\n                else if (s[i] == '1') { R[i]++; B[i]++; }\n                else B[i] += 2;\n            }\n            var CR = new int[n + 1];\n            var CB = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                CR[i + 1] = CR[i] + R[i];\n                CB[i + 1] = CB[i] + B[i];\n            }\n            var N = CR[n];\n            var M = CB[n];\n            var dp = new ModInt[N + 2, M + 2];\n            dp[0, 0] = 1;\n            for (int i = 0; i <= N; i++)\n                for (int j = 0; j <= M; j++) {\n                    if (i == N && j == M) continue;\n                    else if (i == N) dp[i, j + 1] += dp[i, j];\n                    else if (j == M) dp[i + 1, j] += dp[i, j];\n                    else {\n                        var pos = Min(n, i + j + 1);\n                        var u = CR[pos] - i;\n                        var v = CB[pos] - j;\n                        if (u > 0) dp[i + 1, j] += dp[i, j];\n                        if (v > 0) dp[i, j + 1] += dp[i, j];\n                    }\n\n                }\n            Console.WriteLine(dp[N, M]);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\npublic struct ModInt {\n    public const long Mod = 998244353;\n    public long num;\n    public ModInt(long n) { num = n; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<long, long>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        var S = cin.next;\n        int N = S.Length;\n        int M = S.Length * 2;\n\n        var A = new long[2, 2 * M + 1];\n        A[0, 0] = 1;\n\n        int r = 0;\n        int b = 0;\n        long sum = 0;\n        for (int i = 0; i < S.Length; i++)\n        {\n            if (S[i] == '0')\n            {\n                r += 2;\n            }\n            else if (S[i] == '1')\n            {\n                r += 1;\n                b += 1;\n            }\n            else\n            {\n                b += 2;\n            }\n            int u = i % 2;\n            int v = (i + 1) % 2;\n            sum = 0;\n            for (int j = 0; j <= i + 1; j++)\n            {\n                int k = i + 1 - j;\n                if (j <= r && k <= b)\n                {\n                    if (j > 0)\n                    {\n                        A[v, j] += A[u, j - 1];\n                    }\n                    A[v, j] += A[u, j];\n                    A[v, j] %= dom;\n                }\n                sum += A[v, j];\n            }\n\n            for (int j = 0; j < 2 * M + 1; j++)\n            {\n                A[u, j] = 0;\n            }\n\n        }\n\n        WriteLine(sum);\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<long, long>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        var S = cin.next;\n        int N = S.Length;\n\n        var dp = new long[2 * N + 1][];\n        for (int i = 0; i < dp.Length; i++)\n        {\n            dp[i] = new long[2 * N + 1];\n        }\n\n\n        int r = 0;\n        int b = 0;\n        dp[0][0] = 1;\n        for (int i = 0; i < 2 * N; i++)\n        {\n            if (i < N)\n            {\n                if (S[i] == '0')\n                {\n                    r += 2;\n                }\n                else if (S[i] == '1')\n                {\n                    r += 1;\n                    b += 1;\n                }\n                else\n                {\n                    b += 2;\n                }\n\n            }\n\n            //rは0<=r<=i+1の可能性\n            for (int j = 0; j <= i + 1; j++)\n            {\n                int k = i + 1 - j; //bの個数\n\n                if (j <= r && k <= b) //(j-1,k)か(j,k-1)からくる\n                {\n                    if (j > 0) dp[i + 1][j] += dp[i][j - 1];\n                    if (k > 0) dp[i + 1][j] += dp[i][j];\n                }\n                dp[i + 1][j] %= dom;\n            }\n            \n        }\n\n        WriteLine(dp[2 * N].Sum() % dom);\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<long, long>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        var S = cin.next;\n        int N = S.Length;\n        int M = S.Length * 2;\n\n        var A = new long[2, 2 * M + 1];\n        A[0, 0] = 1;\n\n        int r = 0;\n        int b = 0;\n        long sum;\n        for (int i = 0; i < S.Length; i++)\n        {\n            if (S[i] == '0')\n            {\n                r += 2;\n            }\n            else if (S[i] == '1')\n            {\n                r += 1;\n                b += 1;\n            }\n            else\n            {\n                b += 2;\n            }\n            int u = i % 2;\n            int v = (i + 1) % 2;\n            sum = 0;\n            for (int j = 0; j <= i + 1; j++)\n            {\n                int k = i + 1 - j;\n                if (j <= r && k <= b)\n                {\n                    if (j > 0)\n                    {\n                        A[v, j] += A[u, j - 1];\n                    }\n                    A[v, j] += A[u, j];\n                    A[v, j] %= dom;\n                }\n                sum += A[v, j];\n            }\n\n            for (int j = 0; j < 2 * M + 1; j++)\n            {\n                A[u, j] = 0;\n            }\n\n        }\n\n        WriteLine(sum);\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n"
  },
  {
    "language": "Awk",
    "code": "FS=A;d[0]=1{for($0=$0;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353;print d[c]}"
  },
  {
    "language": "Awk",
    "code": "d[FS=A]=1{for($0=$0;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353;print d[c]}"
  },
  {
    "language": "Awk",
    "code": "FS=A;$0=$0{for(d[0]=1;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353;print d[c]}"
  },
  {
    "language": "Awk",
    "code": "FS=A;$0=$0{for(d[0]=1;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j+1]=(d[j]+d[--j])%998244353;print d[c]}"
  },
  {
    "language": "Awk",
    "code": "FS=A;d[0]=1{for($0=$0;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353}$0=d[c]"
  },
  {
    "language": "Awk",
    "code": "FS=A;$0=$0{for(d[0]=1;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353;print+d[c]}"
  },
  {
    "language": "Awk",
    "code": "FS=A;$0=$0{for(d[0]=1;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353;printf\"%.f\",d[c]}"
  },
  {
    "language": "Awk",
    "code": "FS=A;d[0]=1{for($0=$0;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353}1,$0=d[c]"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 998244353)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Binomial coefficient with mod\n;;; build: O(n)\n;;; query: O(1)\n;;;\n\n;; TODO: non-global handling\n\n(defconstant +binom-size+ 10000)\n(defconstant +binom-mod+ +mod+)\n\n(declaim ((simple-array (unsigned-byte 31) (*)) *fact* *fact-inv* *inv*))\n(defparameter *fact* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of factorials\")\n(defparameter *fact-inv* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of inverses of factorials\")\n(defparameter *inv* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of inverses of non-negative integers\")\n\n(defun initialize-binom ()\n  (declare (optimize (speed 3) (safety 0)))\n  (setf (aref *fact* 0) 1\n        (aref *fact* 1) 1\n        (aref *fact-inv* 0) 1\n        (aref *fact-inv* 1) 1\n        (aref *inv* 1) 1)\n  (loop for i from 2 below +binom-size+\n        do (setf (aref *fact* i) (mod (* i (aref *fact* (- i 1))) +binom-mod+)\n                 (aref *inv* i) (- +binom-mod+\n                                   (mod (* (aref *inv* (rem +binom-mod+ i))\n                                           (floor +binom-mod+ i))\n                                        +binom-mod+))\n                 (aref *fact-inv* i) (mod (* (aref *inv* i)\n                                             (aref *fact-inv* (- i 1)))\n                                          +binom-mod+))))\n\n(initialize-binom)\n\n(declaim (inline binom))\n(defun binom (n k)\n  \"Returns nCk.\"\n  (if (or (< n k) (< n 0) (< k 0))\n      0\n      (mod (* (aref *fact* n)\n              (mod (* (aref *fact-inv* k) (aref *fact-inv* (- n k))) +binom-mod+))\n           +binom-mod+)))\n\n(declaim (inline perm))\n(defun perm (n k)\n  \"Returns nPk.\"\n  (if (or (< n k) (< n 0) (< k 0))\n      0\n      (mod (* (aref *fact* n) (aref *fact-inv* (- n k))) +binom-mod+)))\n\n;; TODO: compiler macro or source-transform\n(declaim (inline multinomial))\n(defun multinomial (&rest ks)\n  \"Returns the multinomial coefficient K!/k_1!k_2!...k_n! for K = k_1 + k_2 +\n... + k_n. K must be equal to or smaller than\nMOST-POSITIVE-FIXNUM. (multinomial) returns 1.\"\n  (let ((sum 0)\n        (result 1))\n    (declare ((integer 0 #.most-positive-fixnum) result sum))\n    (dolist (k ks)\n      (incf sum k)\n      (setq result\n            (mod (* result (aref *fact-inv* k)) +binom-mod+)))\n    (mod (* result (aref *fact* sum)) +binom-mod+)))\n\n(declaim (inline stirling2))\n(defun stirling2 (n k)\n  \"Returns the stirling number of the second kind S2(n, k). Time complexity is\nO(klog(n)).\"\n  (declare ((integer 0 #.most-positive-fixnum) n k))\n  (labels ((mod-power (base exp)\n             (declare ((integer 0 #.most-positive-fixnum) base exp))\n             (loop with res of-type (integer 0 #.most-positive-fixnum) = 1\n                   while (> exp 0)\n                   when (oddp exp)\n                   do (setq res (mod (* res base) +binom-mod+))\n                   do (setq base (mod (* base base) +binom-mod+)\n                            exp (ash exp -1))\n                   finally (return res))))\n    (loop with result of-type fixnum = 0\n          for i from 0 to k\n          for delta = (mod (* (binom k i) (mod-power i n)) +binom-mod+)\n          when (evenp (- k i))\n          do (incf result delta)\n             (when (>= result +binom-mod+)\n               (decf result +binom-mod+))\n          else\n          do (decf result delta)\n             (when (< result 0)\n               (incf result +binom-mod+))\n          finally (return (mod (* result (aref *fact-inv* k)) +binom-mod+)))))\n\n(declaim (inline catalan))\n(defun catalan (n)\n  \"Returns the N-th Catalan number.\"\n  (declare ((integer 0 #.most-positive-fixnum) n))\n  (mod (* (aref *fact* (* 2 n))\n          (mod (* (aref *fact-inv* (+ n 1))\n                  (aref *fact-inv* n))\n               +binom-mod+))\n       +binom-mod+))\n\n;;;\n;;; Arithmetic operations with static modulus\n;;;\n\n;; NOTE: Currently MOD* and MOD+ doesn't apply MOD when the number of\n;; parameters is one. For simplicity I won't fix it for now.\n(defmacro define-mod-operations (divisor)\n  `(progn\n     (defun mod* (&rest args)\n       (reduce (lambda (x y) (mod (* x y) ,divisor)) args))\n\n     (defun mod+ (&rest args)\n       (reduce (lambda (x y) (mod (+ x y) ,divisor)) args))\n\n     #+sbcl\n     (eval-when (:compile-toplevel :load-toplevel :execute)\n       (locally (declare (muffle-conditions warning))\n         (sb-c:define-source-transform mod* (&rest args)\n           (if (null args)\n               1\n               (reduce (lambda (x y) `(mod (* ,x ,y) ,',divisor)) args)))\n         (sb-c:define-source-transform mod+ (&rest args)\n           (if (null args)\n               0\n               (reduce (lambda (x y) `(mod (+ ,x ,y) ,',divisor)) args)))))\n\n     (define-modify-macro incfmod (delta)\n       (lambda (x y) (mod (+ x y) ,divisor)))\n\n     (define-modify-macro decfmod (delta)\n       (lambda (x y) (mod (- x y) ,divisor)))\n\n     (define-modify-macro mulfmod (multiplier)\n       (lambda (x y) (mod (* x y) ,divisor)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n\n;;;\n;;; Body\n;;;\n\n;; (defun solve-small (s)\n;;   (let ((n (length s))\n;;         (table (make-hash-table :test #'equal)))\n;;     (sb-int:named-let dfs ((list1 (loop for i below n\n;;                                         collect (ecase (aref s i)\n;;                                                   (#\\0 0) (#\\1 0) (#\\2 1))))\n;;                            (list2 (loop for i below n\n;;                                         collect (ecase (aref s i)\n;;                                                   (#\\0 0) (#\\1 1) (#\\2 1)))))\n;;       (loop for b1 in list1\n;;             for b2 in list2\n;;             collect (cond ((and (= b1 b2 0)) 0)\n;;                           ((and (= b1 b2 1)) 1)\n;;                           (t 0))))))\n\n(define-mod-operations +mod+)\n(defun main ()\n  (declare #.opt)\n  (let* ((s (map '(simple-array uint8 (*)) #'digit-char-p (read-line)))\n         (n (length s))\n         (dp (make-array (list (+ n 1) (+ 1 (* 2 n)))\n                         :element-type 'uint31\n                         :initial-element 0)))\n    (setf (aref dp 0 0) 1)\n    #>s\n    (dotimes (x n)\n      (let ((c (aref s x)))\n        (dotimes (y (+ 1 (* 2 n)))\n          (unless (zerop (aref dp x y))\n            (let ((num0 (+ y (- 2 c)))\n                  (num1 (+ (- x y) c)))\n              (when (> num0 0)\n                (incfmod (aref dp (+ x 1) (- num0 1))\n                         (aref dp x y)))\n              (when (> num1 0)\n                (incfmod (aref dp (+ x 1) num0)\n                         (aref dp x y))))))))\n    (let ((res 0))\n      (loop for y from 0 to n\n            do (incfmod res (mod* (aref dp n y) (binom n y))))\n      (println res))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"3\n\"\n          (run \"02\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"55\n\"\n          (run \"1210\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"543589959\n\"\n          (run \"12001021211100201020\n\" nil))))\n"
  },
  {
    "language": "JavaScript",
    "code": "var GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nvar mod = 998244353;\n\nconsole.log(main());\nfunction main(){\n  var s = o.a(1);\n  var sl = s.length;\n  var r = +s[0], b = 2 - r, l = 0;\n  var ans = [0,0];\n  if(r)ans[1] = 1;\n  if(b)ans[0] = 1, b--;else l = 1;\n  for(var i = 1; i < sl; i++){\n    r += +s[i], b += 2 - s[i];\n    if(b)b--; else l++;\n    var a = Array(r+1).fill(0);\n    var t = Math.min(i+1, r);\n    for(var j = l; j <= t; j++){\n      a[j] = ((ans[j-1]|0) + (ans[j]|0)) % mod;\n    }\n    ans = a;\n  }\n  r++;\n  for(var i = 0; i < sl; i++){\n    if(b)b--; else l++;\n    var a = Array(r).fill(0);\n    for(var j = l; j < r; j++){\n      a[j] = ((ans[j-1]|0) + (ans[j]|0)) % mod;\n    }\n    ans = a;\n  }\n  return ans[r-1];\n}"
  },
  {
    "language": "JavaScript",
    "code": "var GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nvar mod = 998244353;\n\nconsole.log(main());\nfunction main(){\n  var s = o.a(1);\n  var sl = s.length;\n  var r = +s[0], b = 2 - r, l = 0;\n  var ans = [0,0];\n  if(r)ans[1] = 1;\n  if(b)ans[0] = 1, b--;\n  for(var i = 1; i < sl; i++){\n    r += +s[i], b += 2 - s[i];\n    if(b)b--; else l++;\n    var a = Array(r+1).fill(0);\n    var t = Math.min(i+1, r);\n    if(l === 0)a[0] = 1;\n    for(var j = Math.max(l, 1); j <= t; j++){\n      a[j] = (ans[j-1] + (ans[j]|0)) % mod;\n    }\n    ans = a;\n  }\n  r++;\n  for(var i = 0; i < sl; i++){\n    if(b)b--; else l++;\n    var a = Array(r).fill(0);\n    if(l === 0)a[0] = 1;\n    for(var j = Math.max(l, 1); j < r; j++){\n      a[j] = (ans[j-1] + (ans[j]|0)) % mod;\n    }\n    ans = a;\n  }\n  return ans[r-1];\n}"
  },
  {
    "language": "Ruby",
    "code": "S=gets.chop\nN=S.size\nd=(1..4001).map{[0]*4001}\nd[0][0]=1\nx=y=0\n(0..2*N-1).map{|i|\n\tS[i]&&y=2*i+2-x+=S[i].to_i\n\t(0..i).map{|j|\n\t\t[0,1].map{|k|\n\t\t\tj+1-k<=x&&i-j+k<=y&&(\n\t\t\t\td[j+1-k][i-j+k]+=d[j][i-j]\n\t\t\t\td[j+1-k][i-j+k]%=998244353\n\t\t\t)\n\t\t}\n\t}\n}\np d[x][y]\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc NextFloat() float64 {\n  n, _ := strconv.ParseFloat(NextLine(), 64)\n  return n\n}\nfunc NextFloatVec() []float64 {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]float64, len(L))\n  for i := range N {\n    N[i], _ = strconv.ParseFloat(L[i], 64)\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc WriteIntVec(A []int) {\n  S := make([]string, len(A))\n  for i, a := range A {\n    S[i] = strconv.Itoa(a)\n  }\n  Write(strings.Join(S, \" \"))\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MinInt(A ...int) int {\n  min := A[0]\n  for _, a := range A {\n    if a < min { min = a }\n  }\n  return min\n}\nfunc SumInt(A ...int) int {\n  sum := 0\n  for _, a := range A {\n    sum += a\n  }\n  return sum\n}\n\nfunc Factorial(N int) (F, Finv, Inv []int) {\n  F = make([]int, N + 1)\n  Finv = make([]int, N + 1)\n  Inv = make([]int, N + 1)\n  F[0] = 1\n  F[1] = 1\n  Finv[0] = 1\n  Finv[1] = 1\n  Inv[0] = 1\n  Inv[1] = 1\n  for i := 2; i < N + 1; i++ {\n    F[i] = F[i - 1] * i % p\n    Inv[i] = p - Inv[p % i] * (p / i) % p\n    Finv[i] = Finv[i - 1] * Inv[i] % p\n  }\n  return\n}\n\nconst p = 998244353\n\nfunc Solve() {\n  S := NextLine()\n  N := len(S)\n  F, Finv, _ := Factorial(2 * N)\n  B := make([]int, N)\n  for i, s := range S {\n    B[i] = int(s) - int('0')\n  }\n  SB := make([]int, N + 1)\n  for i, b := range B {\n    SB[i + 1] = SB[i] + b\n  }\n  DP := make([][]int, N + 1)\n  for i := range DP {\n    DP[i] = make([]int, N + 1)\n  }\n  DP[0][0] = 1\n  for i := 1; i <= N; i++ {\n    for j := 1; j <= i; j++ {\n      if j <= SB[i] {\n        DP[i][j] += DP[i - 1][j - 1]\n        DP[i][j] %= p\n      }\n      if j <= 2 * i - SB[i] {\n        DP[i][i - j] += DP[i - 1][i - j]\n        DP[i][i - j] %= p\n      }\n    }\n  }\n  cnt := 0\n  for i, dp := range DP[N] {\n    if SB[N] < i || N + i < SB[N] { continue }\n    cnt += ((dp * F[N] % p) * Finv[SB[N] - i] % p) * Finv[N - SB[N] + i] % p\n    cnt %= p\n  }\n  Write(cnt)\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "OCaml",
    "code": "let (+@) a b = (a + b) mod 998244353\nlet () =\n  Scanf.scanf \"%s\" @@ fun s ->\n  let n = String.length s in\n  let thres_b = Array.init (2*n+1) (fun i ->\n    if i = 0 then 0\n    else if i <= n then int_of_char s.[i-1] - int_of_char '0'\n    else 0) in\n  for i = 1 to 2*n do thres_b.(i) <- thres_b.(i) + thres_b.(i-1) done;\n  let thres_r = Array.init (2*n+1) (fun i -> 2 * (min i n) - thres_b.(i)) in\n\n  let r, b = thres_r.(n), thres_b.(n) in\n  let dp = Array.init (r+1) (fun _ -> Array.make (b+1) 0) in\n  dp.(0).(0) <- 1;\n  for w = 1 to 2*n do\n    for r = max 0 (w - thres_b.(w)) to min w thres_r.(w) do\n      let b = w - r in\n      if r > 0 then dp.(r).(b) <- dp.(r).(b) +@ dp.(r-1).(b);\n      if b > 0 then dp.(r).(b) <- dp.(r).(b) +@ dp.(r).(b-1);\n    done;\n  done;\n\n  Printf.printf \"%d\\n\" dp.(r).(b)"
  },
  {
    "language": "Perl",
    "code": "@d=$%=1;for($/=\\1;$%-=<>!~/./||($c+=$&,-1);$c<$%or$d[$c-$%]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$%=1;for($/=\\1;$%-=<>!~/./||($c+=$&,-1);$d[$c-$%]*=$c<$%){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;\n$/=\\1;\nfor(;$t+=($j=ord<>)>10?($c+=$j%3,1):-1;$d[$c<$t?$t:$c-$t]=0){\n\tfor($j=$c;$j;){\n\t\t$d[$j]-=($d[$j]+=$d[--$j])>=998244353&&998244353\n\t}\n}\nprint$d[$c]+0"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=4e3;$%+=getc=~/./&&($c-=$&,2);$d[$%--+$c]=0){($d[$_]+=$d[$_+1])%=998244353for$c..-1}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@S=<>=~/./g;\n@d=[1];\nfor$i(0..2*@S-1){\n\t$y=2*$i+2-($x+=shift@S)if@S;\n\tfor$j(0..$i){\n\t\tfor$k(0,1){\n\t\t\tif($j+!$k<=$x&&$i-$j+$k<=$y){\n\t\t\t\t($d[$j+!$k][$i-$j+$k]+=$d[$j][$i-$j])%=998244353\n\t\t\t}\n\t\t}\n\t}\n}\nprint$d[$x][$y]\n"
  },
  {
    "language": "Perl",
    "code": "@d=map[(0)x4010],1..4010;\n$d[0][0]=1;\nfor(@s=<>=~/./g;defined$s[$i/2];$i++){\n\tfor($j=$c+=defined$s[$i]?($t+=2,$s[$i]):0;$j>$i+$c-$t&&$j!=-1;$j--){\n\t\t$d[$i+1][$j]=($d[$i][$j]+($j>0&&$d[$i][$j-1]))%998244353;\n\t}\n}\nprintf(\"%d\",$d[$i][$c]);\n"
  },
  {
    "language": "Perl",
    "code": "@d=$%=1;for($/=\\1;$%-=<>!~/./||($c+=$&,-1);$c<$%or$d[$c-$%]=0){map+($d[-$_]+=$d[~$_])%=998244353,-$c..-1}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;\n$/=\\1;\nfor(;$t+=($j=ord<>)>10?($c+=$j%3,1):-1;$d[$c<$t?$t:$c-$t]=0){\n\tfor($j=$c;$j;$d[$j--]%=998244353){\n\t\t$d[$j]+=$d[$j-1];\n\t}\n}\nprintf(\"%d\",$d[$c]);\n"
  },
  {
    "language": "Perl",
    "code": "@d=1;$#d=99;for($/=\\1;$%+=<>=~/./&&($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=5e3;$%+=getc=~/./&&($c-=$&,2);$d[$%--+$c]=0){($d[$_]+=$d[$_+1])%=998244353for$c..-1}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=4e3;$%+=getc=~/./&&($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "for(@d=1;$%+=getc=~/./&&($c+=$&,2);$d[$#_=$c-$%--]=0){($d[1-$_]+=$d[-$_])%=998244353for-$c..0}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;for($/=\\1;$t-=($j=ord<>)<11||($c+=$j%3,-1);$d[$c<$t?$t:$c-$t]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=4e3;$%+=getc=~/./&&($c+=$&,2);$d[$c-$%--]=0){($d[-$_]+=$d[-$_-1])%=998244353for-$c..-1}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "for(@d=1;$%+=getc=~/./*($c+=$&,2);$d[$#_=$c-$%--]=0){$j=$c+1;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;\n$/=\\1;\nfor(;$t+=($j=ord<>)>10?($c+=$j%3,1):-1;$d[$c<$t?$t:$c-$t]=0){\n\tfor($j=$c;$j;){\n\t\t($d[$j]+=$d[--$j])%=998244353\n\t}\n}\nprint$d[$c]+0"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=5e3;$%+=getc=~/./&&($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=4e3;$%+=getc=~/./&&($c-=$&,2);$d[$%--+$c]=0){($d[$_]+=$d[$_+1])%=998244353for$c..-1}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=1e5;$%+=getc=~/./&&($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=1e5;$%+=getc=~/./&&($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=[1];\nfor(@s=<>=~/./g;defined$s[$i/2];$i++){\n\tfor($j=$c+=defined$s[$i]?($t+=2,$s[$i]):0;$j>$i+$c-$t&&$j!=-1;$j--){\n\t\t$d[$i+1][$j]=($d[$i][$j]+($j>0&&$d[$i][$j-1]))%998244353;\n\t}\n}\nprintf(\"%d\",$d[$i][$c]);\n"
  },
  {
    "language": "Perl",
    "code": "for(@d=1;$%+=getc=~/./&&($c+=$&,2);$d[$#_=$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=1e5;$%+=getc=~/./*($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;\n$/=\\1;\nfor(;$t+=($j=ord<>)>10?($c+=$j%3,1):-1;$d[$c<$t?$t:$c-$t]=0){\n\tfor($j=$c;$j;$j--){\n\t\tif(($d[$j]+=$d[$j-1])>=998244353){\n\t\t\t$d[$j]-=998244353;\n\t\t}\n\t}\n}\nprintf(\"%d\",$d[$c]);\n"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=$<;$%+=getc=~/./&&($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "for(@d=1;$%+=getc=~/./&&($c+=$&,2);$d[$#_=$c-$%--]=0){$j=$c+1;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;for($/=\\1;$t-=($j=ord<>)<11||($c+=$j%3,-1);$d[$c<$t?$t:$c-$t]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]+0"
  },
  {
    "language": "Perl",
    "code": "@d=1;$#d=1e5;for($/=\\1;$%+=<>=~/./&&($c+=$&,2);$d[$c-$%--]=0){$j=$c;($d[$j]+=$d[--$j])%=998244353while$j}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=1;for($#d=4e3;$%+=getc=~/./&&($c-=$&,2);$d[$%--+$c]=0){($d[$_]+=$d[$_+1])%=998244353for$c..-1}print$d[$c]"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;\n$/=\\1;\nfor(;$t+=($j=ord<>)>10?($c+=$j%3,1):-1;$d[$c<$t?$t:$c-$t]=0){\n\tfor($j=$c;$j;){\n\t\t$d[$j]-=($d[$j]+=$d[--$j])>119<<23&&998244353\n\t}\n}\nprint$d[$c]+0\n"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;\n$/=\\1;\nfor(;$t+=($j=ord<>)>10?($c+=$j%3,1):-1;$d[$c<$t?$t:$c-$t]=0){\n\tfor($j=$c;$j;){\n\t\t$d[$j]-=($d[$j]+=$d[--$j])>119<<23&&998244353\n\t}\n}\nprint$d[$c]+0"
  },
  {
    "language": "Perl",
    "code": "@d=$t=1;\n$/=\\1;\nfor(;$t+=($j=ord<>)>10?($c+=$j%3,1):-1;$d[$c<$t?$t:$c-$t]=0){\n\tfor($j=$c;$j;){\n\t\t$d[$j+1]-=998244353if($d[$j]+=$d[--$j])>119<<23\n\t}\n}\nprint$d[$c]+0"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nimmutable long MOD = 998244353;\n\nvoid main() {\n    auto S = readln.chomp;\n    auto N = S.length.to!int;\n\n    long ans = 1;\n\n    auto dp = new long[][](2, 2*N+1); // これまで何個赤を使っているか？\n    dp[0][0] = 1;\n\n    int red = 0;\n    int blue = 0;\n    int cur = 0;\n    int tar = 1;\n\n    foreach (i; 0..2*N) {\n        dp[tar][] = 0;\n\n        int cand = (i + 1) * 2 - i;\n\n        if (i < N) {\n            red += 2 - (S[i] - '0');\n            blue += S[i] - '0';\n        }\n\n        foreach (used_red; 0..2*N+1) {\n            if (dp[cur][used_red] == 0) continue;\n\n            int used_blue = i - used_red;\n            int rest_red = red - used_red;\n            int rest_blue = blue - used_blue;\n\n            if (rest_red > 0) {\n                (dp[tar][used_red+1] += dp[cur][used_red]) %= MOD;\n            }\n            if (rest_blue > 0) {\n                (dp[tar][used_red] += dp[cur][used_red]) %= MOD;\n            }\n        }\n        swap(cur, tar);\n    }\n\n    dp[cur][red].writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum MO = 998244353L;\n\nint N;\nstring S;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      S = readToken();\n      N = cast(int)(S.length);\n      \n      auto sumA = new int[N + 1];\n      auto sumB = new int[N + 1];\n      foreach (i; 0 .. N) {\n        sumA[i + 1] = sumA[i] + (2 - (S[i] - '0'));\n        sumB[i + 1] = sumB[i] + (S[i] - '0');\n      }\n      \n      auto dp = new long[][](2 * N + 1, 2 * N + 1);\n      dp[0][0] = 1;\n      foreach (a; 0 .. 2 * N + 1) foreach (b; 0 .. 2 * N + 1) {\n        if (a + b > 0) {\n          if (a <= sumA[min(a + b, N)] && b <= sumB[min(a + b, N)]) {\n            if (a > 0) {\n              dp[a][b] += dp[a - 1][b];\n            }\n            if (b > 0) {\n              dp[a][b] += dp[a][b - 1];\n            }\n            dp[a][b] %= MO;\n          }\n        }\n      }\n      long ans;\n      foreach (a; 0 .. 2 * N + 1) foreach (b; 0 .. 2 * N + 1) {\n        if (a + b == 2 * N) {\n          ans += dp[a][b];\n          ans %= MO;\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}"
  },
  {
    "language": "Bash",
    "code": "FS=A;d[0]=1{for($0=$0;X+=i++<NF?2:0;d[c-X--]=0)for(j=c+=$i;j;)d[j]=(d[j]+d[--j])%998244353}1,$0=d[c]"
  },
  {
    "language": "Bash",
    "code": "# #![allow(unused_imports)]\n# #![allow(clippy::style)]\n# use algo::input;\n# use std::cmp::{max, min};\n# use std::collections::{HashMap, HashSet, VecDeque};\n#\n# const MOD: usize = 998244353;\n# const MAX_N: usize = 2010;\n# const MAX_C: usize = MAX_N * 2;\n#\n# fn main() {\n#     input! {\n#         c: chars,\n#     }\n#     let n = c.len();\n#\n#     let mut cnt = vec![(0, 0); 2 * n + 10];\n#     for i in 0..2 * n {\n#         let (a, b) = if i < n {\n#             match c[i] {\n#                 '0' => (2, 0),\n#                 '1' => (1, 1),\n#                 '2' => (0, 2),\n#                 _ => unreachable!(),\n#             }\n#         } else {\n#             (0, 0)\n#         };\n#         let (x, y) = cnt[i];\n#         cnt[i + 1] = (x + a, y + b);\n#     }\n#\n#     let mut dp = vec![0; 2 * n + 1];\n#     dp[0] = 1;\n#     for i in 0..2 * n {\n#         let mut ndp = vec![0; 2 * n + 1];\n#         let (a, b) = cnt[i + 1];\n#         for x in 0..=i {\n#             if dp[x] >= 1 {\n#                 let y = i - x;\n#                 if a > x {\n#                     ndp[x + 1] += dp[x];\n#                     ndp[x + 1] %= MOD;\n#                 }\n#                 if b > y {\n#                     ndp[x] += dp[x];\n#                     ndp[x] %= MOD;\n#                 }\n#             }\n#         }\n#         dp = ndp;\n#     }\n#     let (a, _) = cnt[2 * n];\n#     println!(\"{}\", dp[a]);\n# }\n#\ncat << '_EOF' | base64 -d > /tmp/exec\n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\nIHiA6oTxjhA1BL9mC3gCiNiEqEoHWQsiVpkHkyYIdjbIVZgOftZE5GyE2gTWcREFCyDcbTeLKhiQ\nkhvqMCj4TYtnMCVwiFgQBQrF5U5EGxdBgrkH/wDeVAaKGID7SUG+Mcn3SRT/sAHwD7ANuYzRAVLj\nfuxssFgqk2rH0QFuZweBF9UxSw2lkAMt2WAmmBqFv3DWoFiUP5qLcIsEsFTxCCJk6xRWlx94TVqJ\nHcKIohvpKd0YYidBMUMuK+ySvYZMJQjeykDfWArIddW32beLGw9QPZYzfBiINjsBbXsPZeHUC9iE\nAw8Rrswlzgbs7KASsCW4EsgG7GzAJdAS4CXou0PAzhL4JasSEANuyNllJRgSKCU7G7CzMBJAJUgS\nWCUbsLMBYBJwJXgSsLMBO4glkBKgJbMBOxuoErglwBLbNBuw0CXYEg9DDCXsZc8G8BIABCUIBBLY\nWTdkGCUgEjAl2YCdDTgSSCVQEoCdDdhgJWgSeCWdDdjZgBKQJZgSqA3Y2YAlsBLAJcjY2YCdEtgl\n4BLwJdjLng34EggFJRAFErCzbsggJSgSOCWzATsbQBJQJVgSATsbsGglcBKAJTsbsLOIEpgloBKw\nJRuwswG4Esgl0BKwswE74CXoEvglMiBnHAAGXwYGICcDcgYGBicDcjIGBgYGA3IyIAYGBnIyICcG\nBgYyICcDBgYGkJNDHkVvBgeTATkZBwcHATkZkAcHBzkZkJMHBwcHGZCTAQcHB5CTATkHBweTATkZ\nBwcHATkZkAcHCDkZkJMICAgIGZCTAQgICJCTATkICAiTATkZCAgIATkZkAgICDkZkJMICAgIGZCT\nAQkJCZCTATkJCQmTATkZCQkJATkZkAkJCTkZkJMJCQkJGZCTAQkJCcjJIQ9H0gkKyYCcDAoKCoCc\nDMgKCgqcDMjJCgoKCgzIyYAKCgrIyYCcCgoKyYCcDAoKCoCcDMgKCgucDMjJCwsLCwzIyYALCwvI\nyYCcCwsLyYCcDAsLC1icDMgLCwsS2DBYTJy93pNpnFn8iSZGcN94TIu067REpKBc9qQVfFB8Myx6\nJr2qR1iZM4EQsEDgHK8IkGU+wHZHN1PtgGoPWFFmFwAPgLGzAIA/VYtcDTl5IZssDk08bNIApKmq\nDQ4NeQGyGAgBJO9sqJ4BwcSJUDBa9ocB91KaTCn1exuxxYpheeGvbUvUWAWU6CnEqwhH6EmBxAyN\n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\nDokOSQ5i/1UOFQ4ddQ4197d216H/ZQ4lsbcOhQ5FDlr/3bW7W10dDgr/fQ49sf9tDi033/2twS4O\njQ5NDmr/Uw4TDhtzDjP7W7trwf9jDiPR1w6DDkMOVv/u2t2tWx0OBv97DjvR/2sOK5vv/tbh5w6L\nDksOZv9XDhcOH3cO/a3dtTfh/2cOJ/H3DocORw5ert211v9fHez/fw4/8f///1vhbw4vAQcOjw5P\nDm4SkAKRApICkwKUAv////+VApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAv9vgv6lAqYC\npwKoAQKrAqwCrQKuAq8CsFX8//8CsQKyArMCtAK1ArYCtwK4ArkCugK7////v4K9Ar4CvwLAAsEC\nwgLDAsQCxQLGAscCyALJAsoCy/5bxf8CzALNAs4CzwLQqtIC0wLUAtUC///vKq7YAtkC2gLbAtwC\n3QLeAt8C4ALhAv/////iAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAi9B///yAvMC9AL1\nAvYC9wL4AvkCnQL8Av+3l/r9Av4C/zYIEAgAGAgECBQIDAgcCP8b/40CiggKCBoIBggWwggeCAEI\nEQgJCP7/X/gZCAUIFfoIHQgDCBMICwgbCAcIFwgPCB8IfZeqyD8AljAHdyz///8v1u66UQmZGcRt\nB4/0anA1pWPpo5VknjKI2w6kuP/////ceR7p1eCI2dKXK0y2Cb18sX4HLbjnkR2/kGQQtx3yIP//\n//+wakhxufPeQb6EfdTaGuvk3W1RtdT0x4XTg1aYbBPAqH2p//9rZHr5Yv3syWWKT1wBFNlsBo89\nD/r1//83uJCNyNI7XhBpTORBYNVycWei0eQDPEf/////1ARL/YUN0mu1CqX6qLU1bJiyQtbJu9tA\n+bys42zYMnX/////XN9Fzw3W3Fk90ausMNkmOgDeUYBR18gWYdC/tfS0ISP/v/T/xLNWmZW6zw+l\nvbiecCgIiAVfstkMxiTpC7H/////h3xvLxFMaFirHWHBPS1mtpBB3HYGcdsBvCDSmCoQ1e//////\niYWxcR+1tgal5L+fM9S46KLJB3g0+QAPjqgJlhiYDuH/Bn+Bu19/LT1tCJdvkQFcY+b0Ud/ib9Fr\na/oc2DBlhU6t8u2VBv////9se6UBG8H0CIJXxA/1xtmwZVDptxLquL6LfIi5/N8d3cHC//9iSS3a\n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\n_EOF\nchmod +x /tmp/exec\n/tmp/exec\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\nconst MOD = 998244353\nvar S:string\n\n#{{{ input part\nproc main()\nblock:\n  S = nextString()\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\nproc main() =\n  let N = S.len\n  var red, blue = newSeq[int]()\n  for i,s in S:\n    if s == '0':\n      red.add(i);red.add(i)\n    elif s == '1':\n      red.add(i);blue.add(i)\n    elif s == '2':\n      blue.add(i);blue.add(i)\n    else:\n      doAssert false\n  dp := ndSeq(red.len + 1, blue.len + 1, initMint(0))\n  dp[0][0] = initMint(1)\n  for i in 0..red.len:\n    for j in 0..blue.len:\n      # red\n      if i < red.len and red[i] <= i + j:\n        dp[i + 1][j] += dp[i][j]\n      # blue\n      if j < blue.len and blue[j] <= i + j:\n        dp[i][j + 1] += dp[i][j]\n  print dp[red.len][blue.len]\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readLine*(): string =\n  stdin.readLine()\nproc readSeq*(): seq[string] =\n  readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = readLine().strip()\nproc readInt1*(): int =\n  readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\nproc newSeqWith*[T](n: Natural; e: T): seq[T] =\n  result = newSeq[T](n)\n  for i in 0..<n:\n    result[i] = e\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] =\n  newSeqWith(n1, newSeq[T](n2))\ntype seq3*[T] = seq[seq[seq[T]]]\nproc newSeq3*[T](n1, n2, n3: Natural): seq3[T] =\n  newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\n\n#------------------------------------------------------------------------------#\nconst MOD = int(998244353)\n\ntype Op1[T] = proc(a: T, b: T): T\ntype Op2[T] = proc(a: T, b: T): T\n\nproc repeatedSquares[T](x: T, n: Natural, e: T, f: Op2[T]): T =\n    result = e\n    var xx = f(x, e)\n    var i = n\n    while i > 0:\n        if (i and 1) != 0:\n            result = f(result, xx)\n        xx = f(xx, xx)\n        i = i shr 1\n\nproc addM(a, b: Natural): Natural = (a + b) mod MOD\nproc subM(a, b: Natural): Natural = (a - b + MOD) mod MOD\nproc mulM(a, b: Natural): Natural = a * b mod MOD\nproc powM(a, b: Natural): Natural = repeatedSquares[Natural](a, b, 1, `mulM`)\nproc invM(a: Natural): Natural = a.powM(MOD - 2)\nproc divM(a, b: Natural): Natural = a.mulM(invM(b))\n\nvar memoFactM: seq[Natural] = nil\nvar memoFactInvM: seq[Natural] = nil\n\nproc buildFactTable(n: Natural) =\n  memoFactM = newSeq[Natural](n + 1)\n  memoFactM[0] = 1\n  for i in 1..n:\n    memoFactM[i] = memoFactM[i - 1].mulM(i)\n\n  memoFactInvM = newSeq[Natural](n + 1)\n  memoFactInvM[n] = invM(memoFactM[n])\n  for i in countdown(n - 1, 0):\n    memoFactInvM[i] = memoFactInvM[i + 1].mulM(i + 1)\n\nbuildFactTable(10^6)\n\nproc factM(n: Natural): Natural = memoFactM[n]\n\nproc factInvM(n: Natural): Natural = memoFactInvM[n]\n\nproc combM(n, r: Natural): Natural =\n  if r > n:\n    return 0\n  if r > n div 2:\n    return combM(n, n - r)\n\n  result = factM(n).mulM(factInvM(n - r)).mulM(factInvM(r))\n\nproc multCombM(n, r: Natural): Natural = combM(n + r - 1, r - 1)\n\n#------------------------------------------------------------------------------#\nproc solve(n: int; s: string; a, b: seq[int]; i, j: int; dp:var seq2[int]): int =\n  if dp[i][j] >= 0:\n    return dp[i][j]\n\n  let aused = j\n  let bused = i - j\n\n  var arest = a[i] - aused\n  var brest = b[i] - bused\n\n  var ans = 0\n  if arest < 0:\n    if s[i] == '0':\n      arest += 1\n    if s[i] == '1':\n      arest += 1\n    if arest > 0:\n      ans = ans.addM(solve(n, s, a, b, i + 1, j + 1, dp))\n    if brest > 0:\n      ans = ans.addM(solve(n, s, a, b, i + 1, j, dp))\n    dp[i][j] = ans\n  elif brest < 0:\n    if s[i] == '1':\n      brest += 1\n    if s[i] == '2':\n      brest += 1\n    if arest > 0:\n      ans = ans.addM(solve(n, s, a, b, i + 1, j + 1, dp))\n    if brest > 0:\n      ans = ans.addM(solve(n, s, a, b, i + 1, j, dp))\n    dp[i][j] = ans\n  else:\n    if arest > 0 or (i < n and (s[i] == '0' or s[i] == '1')):\n      ans = ans.addM(solve(n, s, a, b, i + 1, j + 1, dp))\n    if brest > 0 or (i < n and (s[i] == '1' or s[i] == '2')):\n      ans = ans.addM(solve(n, s, a, b, i + 1, j, dp))\n    dp[i][j] = ans\n\n  return ans\n\nproc main() =\n  let s = readLine()\n  let n = s.len()\n\n  var a = newSeq[int](2 * n)\n  var b = newSeq[int](2 * n)\n  a[0] = 0\n  b[0] = 0\n  var cnt = 0\n  for i in 1..n:\n    case s[i - 1]\n    of '0':\n      a[i] = a[i - 1] + 2\n      b[i] = b[i - 1]\n      cnt += 2\n    of '1':\n      a[i] = a[i - 1] + 1\n      b[i] = b[i - 1] + 1\n      cnt += 1\n    of '2':\n      a[i] = a[i - 1]\n      b[i] = b[i - 1] + 2\n    else:\n      assert false\n\n  for i in n + 1..<2 * n:\n    a[i] = a[i - 1]\n    b[i] = b[i - 1]\n\n  var dp = newSeq2[int](2 * n + 1, 2 * n + 1)\n  dp[2 * n][cnt] = 1\n  for i in 0..<2 * n:\n    for j in 0..2 * n:\n      dp[i][j] = -1\n\n  echo solve(n, s, a, b, 0, 0, dp)\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "m = 998244353\nS = map(int, raw_input())\nN = len(S)\npr = [0]*(N*2)\npb = [0]*(N*2)\npr[0] = 2-S[0]\npb[0] = S[0]\nfor i in xrange(1, N):\n  pr[i] = pr[i-1]+(2-S[i])\n  pb[i] = pb[i-1]+S[i]\nfor i in xrange(N, N*2):\n  pr[i] = pr[i-1]\n  pb[i] = pb[i-1]\ndp = []\nfor i in xrange(N*2+1):\n  dp.append([0]*(N*2+1))\ndp[0][0]=1\nfor i in xrange(1, N*2+1):\n  si = 0\n  for b in xrange(i+1):\n    r = i-b\n    if pr[i-1]<r or pb[i-1]<b:\n      continue\n    if r>0:\n      dp[r][b] = (dp[r][b]+dp[r-1][b]) % m\n    if b>0:\n      dp[r][b] = (dp[r][b]+dp[r][b-1]) % m\n    si = (si+dp[r][b]) % m\nprint si"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nS = input()\nN = len(S)\nSum = [0]*(N+1)\nfor i in range(1, N+1):\n    Sum[i] = Sum[i-1]+int(S[i-1])\nfrom functools import lru_cache\n\n@lru_cache(maxsize=1000)\ndef dp(i, j):\n    n = min(i+j+1, N)\n    if i+j == N*2:\n        return 1\n    res = 0\n    s = Sum[n]\n    if i<s:\n        res+=dp(i+1, j)\n    if j<2*n-s:\n        res+=dp(i, j+1)\n    return res%mod\nprint(dp(0, 0))"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nred = [0]\nblue = [0]\nmod = 998244353\nred = [-1]*(2*n)\nblue = [-1]*(2*n)\ncntr = 0\ncntb = 0\nfor i in range(n):\n  cntr = max(cntr,i)\n  cntb = max(cntb,i)\n  if s[i] == \"0\":\n    red[cntr] = 1\n    red[cntr+1] = 1\n    cntr += 2\n  if s[i] == \"1\":\n    red[cntr] = 1\n    cntr += 1\n    blue[cntb] = 1\n    cntb += 1\n  if s[i] == \"2\":\n    blue[cntb] = 1\n    blue[cntb+1] = 1\n    cntb += 2\nfor i in range(1,2*n):\n  red[i] += red[i-1]\n  blue[i] += blue[i-1]\ndp = [[0]*(4*n+5) for i in range(2*n+1)]\ndp[0][0] = 1\nfor i in range(1,2*n+1):\n  for j in range(-blue[i-1],red[i-1]+1,1):\n    dp[i][j] = (dp[i-1][j+1]+dp[i-1][j-1])%mod\n\nprint(dp[-1][red[-1]])"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\n\nMOD = 998244353  # type: int\n\ndef comb(n, k):\n    if k > n:\n        return 0\n    k = min(k, n - k)\n    ret = 1\n    for i in range(k):\n        ret *= n - i\n        ret //= i + 1\n    return ret\n\ndef solve(S: str):\n    n = len(S)\n    b_total = 0\n    b_counts = []\n    for c in S:\n        b_total += ord(c) - ord('0')\n        b_counts.append(b_total)\n    dp = [[0] * (b_total + 1) for _ in range(2 * n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(min(i + 1, b_total + 1)):\n            if b_counts[i] >= j + 1:\n                dp[i + 1][j + 1] += dp[i][j]\n            if (i + 1) * 2 - b_counts[i] >= (i + 1) - j:\n                dp[i + 1][j] += dp[i][j]\n    #    print(dp[i])\n    #print(dp[n])\n    comb = [0] * (n + 1)\n    comb[0] = 1\n    for i in range(n):\n        comb[i + 1] = comb[i] * (n - i) // (i + 1)\n    ret = 0\n    for b, val in enumerate(dp[n]):\n        #ret += val * comb(n, b_total - b)\n        if b_total - b >= 0 and b_total - b <= n:\n            ret += val * comb[b_total - b]\n    print(ret % MOD)\n    return\n\n    ##dp[0][0] = 1\n    ##for i in range(2 * n):\n    ##    for j in range(min(i + 1, b_total + 1)):\n    ##        b_max = b_counts[i] if i < n else b_total\n    ##        r_max = (i + 1) * 2 - b_max if i < n else 2 * n - b_total\n    ##        if b_max >= j + 1:\n    ##            dp[i + 1][j + 1] += dp[i][j]\n    ##        if r_max >= (i + 1) - j:\n    ##            dp[i + 1][j] += dp[i][j]\n    ##ret = sum(dp[2 * n])\n    ##print(ret % MOD)\n    ##return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    S = str(next(tokens))\n    solve(S)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "S = input()\nn = len(S)\nN = n\n# --------------------------------------------------------------------------------\nfrom bisect import bisect_left, bisect_right\n# getred = lambda c: 2 if c == \"0\" else 1 if c == \"1\" else 0\nredidx = []\nblueidx = []\nfor e,c in enumerate(S):\n    if c == \"2\":\n        blueidx.append(e+1)\n        blueidx.append(e+1)\n    elif c == \"1\":\n        blueidx.append(e+1)\n        redidx.append(e +1)\n    elif c == \"0\":\n        redidx.append(e+1)\n        redidx.append(e+1)\ndp = [[0] * (2*N+1) for _ in range(2*N+1)]\ndp[0][0] = 1\n\n# print(\"redidx: \", redidx)\n# print(\"blueidx: \", blueidx)\n\n\nMOD = 998244353\nfor p in range(1,2*N+1): # p\u001b$B2sL\\$N%?!<%s$G!\"\u001b(Br\u001b$B8D@V$$6L$r;H$C$F$$$k\u001b(B\n    for r in range(0,p): # r \u001b$B$OA0$N%?!<%s$N\u001b(B 0<=r<=p, \u001b$BA0$N%?!<%s$G\u001b(Bp\u001b$B;H$C$F$k$N$O$\"$j$($J$$\u001b(B\n\n        if r < bisect_right(redidx, p):\n            dp[p][r+1] += dp[p-1][r]  % MOD\n\n        if p-1-r < bisect_right(blueidx, p):\n            dp[p][r] += dp[p-1][r] % MOD\n\n        # print(\"p: {p}, r: {r} , dp[{p}]: {dp}, r:{r}, bitright redidx,p: {bit} b:{b}: bitright_blueidx,p: {bit2}\".format(p=p, r=r, dp=dp[p], bit=bisect_right(redidx,p), bit2=bisect_right(blueidx,p), b=p-1-r))\n        # print(\"\\tredidx: {red},\\n\\tbluidx: {blu}\".format(red=redidx, blu=blueidx))\n\n# print(sum(dp[2*N][len(redidx)]))\nprint(dp[2*N][len(redidx)] % MOD)\n        \n# print(redidx)\n# print(blueidx)\nexit(0)\n\n\n# --------------------------------------------------------------------------------\n\nsumred = [0] * (n+1)\nsumblu = [0] * (n+1)\ngetred = lambda c: 2 if c == \"0\" else 1 if c == \"1\" else 0\n# getblu = lambda c: 2 - getred(c)\n\nsumred[0] = 0 # getred(S[0])\nsumblu[0] = 0 # getred(S[0])\n# sumred[1] = getred(S[0])\n\nfor i in range(1,n+1): # i \u001b$B?ML\\$^$G8+$?;~$N;H$($k@V$$6L$N9g7W\u001b(B\n    sumred[i] = sumred[i-1] + getred(S[i-1])\n    sumblu[i] = sumblu[i-1] + 2 - getred(S[i-1])\n\ndp = [ [0] * (2*N+1) for _ in range(2*N+1)] \n\ndp[0][0] = 0\ndp[0][1] = 0\n# dp[1][0] = \u001b$B$b$7\u001b(B1\u001b$B?ML\\$,@D$$6L$N$_$@$C$?$i\u001b(B(\u001b$B!\"\u001b(B\n# dp[1][0] = 1\u001b$B2sL\\!\"\u001b(B1\u001b$B?ML\\$,@D$$6L$N$_$@$C$?$i\"*\u001b(B1\u001b$BDL$j\u001b(B\n# dp[1][0] = 1\u001b$B2sL\\!\"\u001b(B1\u001b$B?ML\\$,@D!&@VN>J};}$C$F$?$i\"*\u001b(B1\u001b$BDL$j\u001b(B\n# dp[1][1] = 1\u001b$B2sL\\!\"\u001b(B1\u001b$B?ML\\$,\u001b(B \u001b$BF1>e\u001b(B  1\u001b$BDL$j\u001b(B\n# dp[1][2] = \u001b$B$J$7\u001b(B\ndp[1][0] = 1\ndp[1][1] = 1\n\n\nfor p in range(1,2*N+1):\n    # p\u001b$B%?!<%sL\\$G!\"\u001b(Bp\u001b$B8D$N6L$r;H$C$F$$$k!#\u001b(B\n    # \u001b$B@D$K$h$C$F:GDc?t$K$b@)Ls$r$+$1$kI,MW$,$\"$k!#\u001b(B\n    # \u001b$B;H$($k@D$N6L$N:GBg?t$O!\"\u001b(Bsumblu[p]\u001b$B8D\u001b(B\n    # i\u001b$B?ML\\!!\u001b(B\n\n    if p <= N:\n        for r in range(max(0,p-sumblu[p]), min(sumred[p], p)+1): \n            print(\"p: {}, r: {}\".format(p,r))\n\n            if r > 0:\n                dp[p][r] += dp[p-1][r-1]\n                dp[p][r] += dp[p-1][r]\n            else:\n                dp[p][r] += dp[p-1][r]\n\n            print(\"dp[{p}][{r}] += dp[{a}][{b}]:{d} + dp[{a}][{c}]:{e}\".format(p=p,r=r, a=p-1, b=r-1, c=r, d=dp[p-1][r-1], \n                e=dp[p-1][r]))\n\n            dp[p][r] += dp[p-1][r-1] + dp[p-1][r]\n    else:\n        for r in range(max(0,p-sumblu[N]), min(sumred[N], p)+1): \n            print(\"p: {}, r: {}\".format(p,r))\n\n            if r > 0:\n                dp[p][r] += dp[p-1][r-1]\n                dp[p][r] += dp[p-1][r]\n            else:\n                dp[p][r] += dp[p-1][r]\n\n            print(\"dp[{p}][{r}] += dp[{a}][{b}]:{d} + dp[{a}][{c}]:{e}\".format(p=p,r=r, a=p-1, b=r-1, c=r, d=dp[p-1][r-1], \n                e=dp[p-1][r]))\n\n            dp[p][r] += dp[p-1][r-1] + dp[p-1][r]\n\n    print(\"\\t\",dp[p][r])\nprint(dp[2*N][r])\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\n\"\"\"\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1*a[i][k]\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n\"\"\"\n\n#F\nmod = 998244353\ns = list(sys.stdin.readline().strip())\nn = len(s)\ndp = [[0 for i in range(2*n+1)] for j in range(2*n+1)]\nr = [0 for i in range(n)]\nb = [0 for i in range(n)]\nfor i in range(n):\n    b[i] = int(s[i])\n    r[i] = 2-b[i]\nfor i in range(n-1):\n    r[i+1] += r[i]\n    b[i+1] += b[i]\nr.insert(0,0)\nb.insert(0,0)\nif r[1] > 0:\n    dp[1][1] = 1\nfor i in range(1,n+1):\n    if b[i] < i:break\n    if b[i] >= i:dp[i][0] = 1\nfor i in range(n+1,2*n+1):\n    if b[-1] >= i:dp[i][0] = 1\nfor i in range(2,n+1):\n    for j in range(1,i+1):\n        if r[i] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[i] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\nfor i in range(n+1,2*n+1):\n    for j in range(1,i+1):\n        if r[n] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[n] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\n\nans = 0\nfor i in range(2*n+1):\n    ans += dp[2*n][i]\n    ans %= mod\nprint(ans)\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nmod = 998244353\n\nR = [0] * n\nB = [0] * n\nfor i in range(n):\n    if s[i] == '0':\n        R[i] = 2\n    elif s[i] == '1':\n        R[i] = 1\n        B[i] = 1\n    else:\n        B[i] = 2\n\nfor i in range(n-1):\n    R[i+1] += R[i]\n    B[i+1] += B[i]\n\n\ndp = [[0] * (2*n+10) for _ in range(2*n+10)]\n\nif R[0] > 0:\n    dp[0][1] = 1\nif B[0] > 0:\n    dp[0][0] = 1\n\nfor i in range(n-1):\n    for r in range(2*n+1):\n        if R[i+1] >= r+1:\n            dp[i+1][r+1] += dp[i][r]\n            dp[i+1][r+1] %= mod\n        if i+2-r < 0:\n            break\n        if B[i+1] >= i+2-r:\n            dp[i+1][r] += dp[i][r]\n            dp[i+1][r] %= mod\n\nfor i in range(n-1, 2*n-1):\n    for r in range(2*n+1):\n        if R[n-1] >= r+1:\n            dp[i + 1][r + 1] += dp[i][r]\n            dp[i + 1][r + 1] %= mod\n        if i+2-r < 0:\n            break\n        if B[n-1] >= i+2-r:\n            dp[i+1][r] += dp[i][r]\n            dp[i+1][r] %= mod\n\nans = 0\nfor r in range(2*n+1):\n    ans += dp[2*n-1][r]\n    ans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\ns = list(map(int, list(input())))\nn = len(s)\ndp = [[0]*(sum(s)+1) for _ in range(2*n+1)]\ndp[0][0] = 1\ncurr = curb = 0\nfor i in range(2*n):\n  if i < n:\n    curb += s[i]\n    curr += 2 - s[i]\n  for j in range(min(i, curb)+1):\n    if dp[i][j]:\n      dp[i][j] %= mod\n      if i - j < curr:\n        dp[i+1][j] += dp[i][j]\n      if j < curb:\n        dp[i+1][j+1] += dp[i][j]\nprint(dp[2*n][curb])   "
  },
  {
    "language": "Python",
    "code": "# 数え上げで制約が 2 乗っぽいのでどうせ dp だろという気持ちになる\n# なんで入力が数字で与えられるのかを考えるとちょっと視界が開ける\n\n# よく考えると、できる列の制約は\n# 「赤い/青いボールはできる列の i 個目までに A[i]/B[i] 個使える」\n# と表せることがわかる\n# これに気付けばあとは\n#     dp[i][j] := i 個目まで並べたとき赤いボールを j 個使う場合の数\n# とした dp が自然と思いつく\n\nfrom itertools import accumulate\n\ndef main():\n    mod = 998244353\n    B = list(map(int, input()))\n    N = len(B)\n    A = [2-b for b in B] + [0]*N\n    B += [0] * N\n    a = b = 0\n    for i in range(2*N):\n        b += B[i]\n        if b > 0:\n            b -= 1\n            B[i] = 1\n        a += A[i]\n        if a > 0:\n            a -= 1\n            A[i] = 1\n\n    A = list(accumulate(A))\n    B = list(accumulate(B))\n\n    dp = [[0]*(2*N+2) for _ in range(2*N+1)]\n    dp[0][0] = 1\n    for i, (a, b) in enumerate(zip(A, B), 1):\n        for j in range(2*N+1):\n            if i - b <= j <= a:\n                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % mod\n\n    print(sum(dp[2*N]) % mod)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\n\nMOD = 998244353  # type: int\n\ndef comb(n, k):\n    if k > n:\n        return 0\n    k = min(k, n - k)\n    ret = 1\n    for i in range(k):\n        ret *= n - i\n        ret //= i + 1\n    return ret\n\ndef solve(S: str):\n    n = len(S)\n    b_total = 0\n    b_counts = []\n    for c in S:\n        b_total += ord(c) - ord('0')\n        b_counts.append(b_total)\n    dp = [[0] * (b_total + 1) for _ in range(2 * n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(min(i + 1, b_total + 1)):\n            if b_counts[i] >= j + 1:\n                dp[i + 1][j + 1] += dp[i][j]\n            if (i + 1) * 2 - b_counts[i] >= (i + 1) - j:\n                dp[i + 1][j] += dp[i][j]\n    #    print(dp[i])\n    #print(dp[n])\n    ret = 0\n    for b, val in enumerate(dp[n]):\n        ret += val * comb(n, b_total - b)\n    print(ret % MOD)\n    return\n\n    ##dp[0][0] = 1\n    ##for i in range(2 * n):\n    ##    for j in range(min(i + 1, b_total + 1)):\n    ##        b_max = b_counts[i] if i < n else b_total\n    ##        r_max = (i + 1) * 2 - b_max if i < n else 2 * n - b_total\n    ##        if b_max >= j + 1:\n    ##            dp[i + 1][j + 1] += dp[i][j]\n    ##        if r_max >= (i + 1) - j:\n    ##            dp[i + 1][j] += dp[i][j]\n    ##ret = sum(dp[2 * n])\n    ##print(ret % MOD)\n    ##return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    S = str(next(tokens))\n    solve(S)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nd=[[0]*4001 for _ in range(4001)]\nd[0][0]=1\nx=0\ny=0\nfor i in range(2*N):\n\tif i<N:\n\t\tx+=int(S[i])\n\t\ty=2*i+2-x\n\tfor j in range(i+1):\n\t\tfor k in range(2):\n\t\t\tif j+1-k<=x and i-j+k<=y:\n\t\t\t\td[j+1-k][i-j+k]+=d[j][i-j]\n\t\t\t\td[j+1-k][i-j+k]%=998244353\nprint(d[x][y])\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\nfrom scipy.misc import comb\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\n# MOD = 10 ** 9 + 7\nMOD = 998244353\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param int max:\n    :param int mod:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\ndef factorial_invs(max, mod):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max! の逆元\n    :param int max:\n    :param int mod:\n    \"\"\"\n    ret = []\n    r = 1\n    for inv in mod_invs(max, mod):\n        r = r * inv % mod\n        ret.append(r)\n    return ret\n\n\nclass Combination:\n    def __init__(self, max, mod):\n        \"\"\"\n        :param int max:\n        :param int mod: 3 以上の素数であること\n        \"\"\"\n        self._factorials = get_factorials(max, mod)\n        self._finvs = factorial_invs(max, mod)\n        self._mod = mod\n\n    def ncr(self, n, r):\n        \"\"\"\n        :param int n:\n        :param int r:\n        :rtype: int\n        \"\"\"\n        if n < r:\n            return 0\n        return self._factorials[n] * self._finvs[r] % self._mod * self._finvs[n - r] % self._mod\n\n\nS = list(map(int, list(sys.stdin.readline().rstrip())))\nN = len(S)\n\n# dp[i][c]: i まで決めた、使えるけど使ってない青が j 個余ってるパターン数\ndp = np.zeros((N + 1, N + 10), dtype=int)\ndp[0][0] = 1\n\nfor i in range(N):\n    if S[i] == 2:\n        # 青を使う\n        dp[i + 1][1:] += dp[i][:-1]\n        # 赤を使う\n        dp[i + 1][2:i + 2] += dp[i][:i]\n    if S[i] == 1:\n        # 青を使う\n        dp[i + 1] += dp[i]\n        # 赤を使う\n        dp[i + 1][1:] += dp[i][:-1]\n    if S[i] == 0:\n        # 青を使う\n        dp[i + 1][:-1] += dp[i][1:]\n        # 赤を使う\n        dp[i + 1] += dp[i]\n    dp[i + 1] %= MOD\n\ncomb = Combination(max=N, mod=MOD)\nans = 0\nfor c, cnt in enumerate(dp[-1]):\n    # N から c 個選ぶ\n    ans += comb.ncr(N, c) * cnt\n    ans %= MOD\n    # print(N, c, cnt)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\n\"\"\"\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1*a[i][k]\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n\"\"\"\n\n#F\nmod = 998244353\ns = list(sys.stdin.readline().strip())\nn = len(s)\ndp = [[0 for i in range(2*n+1)] for j in range(2*n+1)]\nr = [0 for i in range(n)]\nb = [0 for i in range(n)]\nfor i in range(n):\n    b[i] = int(s[i])\n    r[i] = 2-b[i]\nfor i in range(n-1):\n    r[i+1] += r[i]\n    b[i+1] += b[i]\nr.insert(0,0)\nb.insert(0,0)\nif r[1] > 0:\n    dp[1][1] = 1\nfor i in range(1,n+1):\n    if b[i] < i:break\n    if b[i] >= i:dp[i][0] = 1\nfor i in range(n+1,2*n+1):\n    if b[-1] < i:break\n    if b[-1] >= i:dp[i][0] = 1\nfor i in range(2,n+1):\n    for j in range(1,i+1):\n        if r[i] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[i] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\nfor i in range(n+1,2*n+1):\n    for j in range(1,i+1):\n        if r[n] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[n] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\n\nprint(dp[2*n][r[-1]])\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nmod = 998244353\n\nrb_use = [[0]*(2*n+1)  for _ in range(2)]\nr = 0\nb = 0\nfor i in range(n):\n    if(s[i]=='0'):\n        r += 2\n    elif(s[i]=='1'):\n        r += 1\n        b += 1\n    else:\n        b += 2\n    rb_use[0][i+1] = rb_use[0][i]\n    rb_use[1][i+1] = rb_use[1][i]\n    if(r>0):\n        rb_use[0][i+1] += 1\n        r -= 1\n    if(b>0):\n        rb_use[1][i+1] += 1\n        b -= 1\n\nfor i in range(n,2*n):\n    rb_use[0][i+1] = rb_use[0][i]\n    rb_use[1][i+1] = rb_use[1][i]\n    if(r>0):\n        rb_use[0][i+1] += 1\n        r -= 1\n    if(b>0):\n        rb_use[1][i+1] += 1\n        b -= 1\n\nr_max = rb_use[0][-1]\nb_max = rb_use[1][-1]\n\ndp = [[0] * (b_max+1) for _ in range(r_max+1)]\ndp[0][0] = 1\n\nfor i in range(r_max+1):\n    for j in range(b_max+1):\n        tot = i+j\n        if(rb_use[0][tot] >= i)&(rb_use[1][tot] >= j):\n            if(i==0)&(j==0):\n                continue\n            elif(i==0):\n                dp[i][j] = dp[i][j-1]\n            elif(j==0):\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod\n\nprint(dp[-1][-1])"
  },
  {
    "language": "Python",
    "code": "s = input()\nMOD = 998244353\ncnt_r = []\ncnt_b = []\nfor i in s:\n    cnt_r.append(2-int(i))\n    cnt_b.append(int(i))\ncursum_cnt_r = [0]*(len(s)+1)\ncursum_cnt_b = [0]*(len(s)+1)\nfor i in range(len(s)):\n    cursum_cnt_r[i+1] = cursum_cnt_r[i] + cnt_r[i]\n    cursum_cnt_b[i+1] = cursum_cnt_b[i] + cnt_b[i]\ncursum_cnt_r = cursum_cnt_r + [cursum_cnt_r[-1]]*len(s)\ncursum_cnt_b = cursum_cnt_b + [cursum_cnt_b[-1]]*len(s)\n\n#dp[ni][ri]:nこのボールを並べたときに赤色のボールがri個含まれるときの並べ方総数\ndp = [[0]*(2*len(s)+1) for i in range(2*len(s)+1)]\ndp[0][0] = 1\nfor ni in range(1,2*len(s)+1):\n    for ri in range(0,ni+1):\n        if ri == 0:\n            if 0 <= ni <= cursum_cnt_b[ni]:\n                #青色を選ぶ\n                dp[ni][ri] = dp[ni-1][ri]\n        elif ri == ni:\n            if 0 <= ri <= cursum_cnt_r[ni]:\n                #赤色を選ぶ\n                dp[ni][ri] = dp[ni-1][ri-1]\n        else:\n            if 0 <= ri <= cursum_cnt_r[ni] and 0 <= ni-ri <= cursum_cnt_b[ni]:\n                dp[ni][ri] += dp[ni-1][ri]\n                dp[ni][ri] += dp[ni-1][ri-1]\n        dp[ni][ri] %= MOD \n\nprint(max(dp[2*len(s)]))"
  },
  {
    "language": "Python",
    "code": "S = input()\nN = len(S)\n\nfrom collections import defaultdict\n\nreddic = defaultdict(int)\nbludic = defaultdict(int)\n\nredarray = [0] * (N+1)\nbluarray = [0] * (N+1)\n\nfor e,c in enumerate(S):\n\n    if c == \"2\":\n        bludic[e+1] += 2\n        bluarray[e+1] += 2\n    elif c == \"1\":\n        reddic[e+1] += 1\n        bludic[e+1] += 1\n\n        redarray[e+1] += 1\n        bluarray[e+1] += 1\n    elif c == \"0\":\n        reddic[e+1] += 2\n        redarray[e+1] += 2\n\nfor i in range(1,N+1):\n    redarray[i] += redarray[i-1]\n    bluarray[i] += bluarray[i-1]\n\n# print(\"redarray: \", redarray)\n# print(\"bluarray: \", bluarray)\n\ndp = [ [0] * (2*N+1) for _ in range(2*N+1)]\ndp[0][0] = 1\nMOD = 998244353\n\nfor p in range(1, 2*N+1):\n    for r in range(0, p):\n        idx = p if p <= N else N\n        if r < redarray[idx]:\n            dp[p][r+1] += dp[p-1][r] % MOD\n        if p-1-r < bluarray[idx]:\n            dp[p][r] += dp[p-1][r] % MOD\n    # print(\"{:3d}\".format(p), dp[p])\n\nprint(dp[2*N][redarray[N]]%MOD)"
  },
  {
    "language": "Python",
    "code": "\ndef main():\n    s = list(map(int, list(input())))\n    n = len(s)\n    dp = [1]\n    mod = 998244353\n    for i, c in enumerate(s):\n        dp2 = [0]*(i+2)\n        for r in range(i+1):\n            if r+c > 0:\n                dp2[r+c-1] = (dp2[r+c-1]+dp[r]) % mod\n            if i+2-r-c > 0:\n                dp2[r+c] += (dp2[r+c]+dp[r]) % mod\n        dp = dp2\n    for i in range(n):\n        dp2 = [0]*(n-i)\n        for r in range(n-i+1):\n            if r > 0:\n                dp2[r-1] = (dp2[r-1]+dp[r]) % mod\n            if n-i-r > 0:\n                dp2[r] = (dp2[r]+dp[r]) % mod\n        dp = dp2\n    print(dp[0] % mod)\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nimport sys\nsys.setrecursionlimit(10**9)\nS = input()\nN = len(S)\nSum = [0]*(N+1)\nfor i in range(1, N+1):\n    Sum[i] = Sum[i-1]+int(S[i-1])\nmemo = [[-1]*(N*2+1) for _ in range(N*2+1)]\ndef dp(i, j):\n    if memo[i][j]>=0:\n        return memo[i][j]\n    n = min(i+j+1, N)\n    if i+j == N*2:\n        return 1\n    res = 0\n    s = Sum[n]\n    if i<s:\n        res+=dp(i+1, j)\n    if j<2*n-s:\n        res+=dp(i, j+1)\n    memo[i][j] = res\n    return res%mod\nprint(dp(0, 0))"
  },
  {
    "language": "Python",
    "code": "s=input()\nn=len(s)\n\nDP=[[0 for i in range(2*n+1)] for j in range(2*n+1)]\nDP[0][0]=1\n\nfor i in range(1,2*n+1):\n    ao=sum(int(s[t]) for t in range(min(i,n)))\n    aka=min(i,n)*2-ao\n    for j in range(0,min(ao+1,i+1)):\n        DP[i][j]+=DP[i-1][j-1]\n    for j in range(max(0,i-aka),i+1):\n        DP[i][j]+=DP[i-1][j]\n\n#print(DP)\nprint(sum(DP[2*n]))\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nMOD = 998244353\ncnt_r = []\ncnt_b = []\nfor i in s:\n    cnt_r.append(2-int(i))\n    cnt_b.append(int(i))\ncursum_cnt_r = [0]*(len(s)+1)\ncursum_cnt_b = [0]*(len(s)+1)\nfor i in range(len(s)):\n    cursum_cnt_r[i+1] = cursum_cnt_r[i] + cnt_r[i]\n    cursum_cnt_b[i+1] = cursum_cnt_b[i] + cnt_b[i]\ncursum_cnt_r = cursum_cnt_r + [cursum_cnt_r[-1]]*len(s)\ncursum_cnt_b = cursum_cnt_b + [cursum_cnt_b[-1]]*len(s)\n\n#dp[ni][ri]:nこのボールを並べたときに赤色のボールがri個含まれるときの並べ方総数\ndp = [[0]*(2*len(s)+1) for i in range(2*len(s)+1)]\ndp[0][0] = 1\nfor ni in range(1,2*len(s)+1):\n    for ri in range(0,ni+1):\n        if ri == 0:\n            if 0 <= ni <= cursum_cnt_b[ni]:\n                #青色を選ぶ\n                dp[ni][ri] = dp[ni-1][ri]\n        elif ri == ni:\n            if 0 <= ri <= cursum_cnt_r[ni]:\n                #赤色を選ぶ\n                dp[ni][ri] = dp[ni-1][ri-1]\n        else:\n            if 0 <= ri <= cursum_cnt_r[ni] and 0 <= ni-ri <= cursum_cnt_b[ni]:\n                dp[ni][ri] += dp[ni-1][ri]\n                dp[ni][ri] += dp[ni-1][ri-1]\n        dp[ni][ri] %= MOD \n\nprint(max(dp[2*len(s)]))"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\ns = input()\nn = len(s)\nR = s.count(\"0\") * 2 + s.count(\"1\")\nB = 2*n - R\nrb = [[R, B] for _ in range(2*n)]\nif s[0] == \"0\":\n\trb[0] = [2, 0]\nelif s[0] == \"1\":\n\trb[0] = [1, 1]\nelse:\n\trb[0] = [0, 2]\nfor i in range(1, n):\n\tif s[i] == \"0\":\n\t\trb[i] = [rb[i-1][0] + 2, rb[i-1][1] + 0]\n\telif s[i] == \"1\":\n\t\trb[i] = [rb[i-1][0] + 1, rb[i-1][1] + 1]\n\telse:\n\t\trb[i] = [rb[i-1][0] + 0, rb[i-1][1] + 2]\n\ndp = [[0 for _ in range(R+1)] for _ in range(2*n)]\nif rb[0][0] >= 1:\n\tdp[0][1] = 1\nif rb[0][1] >= 1:\n\tdp[0][0] = 1\nfor i in range(1, 2*n):\n\tfor j in range(R+1):\n\t\tif j > 0 and rb[i][0] >= j:\n\t\t\tdp[i][j] += dp[i-1][j-1]\n\t\t\tdp[i][j] %= MOD\n\t\tif j != i+1 and rb[i][1] >= i+1 - j:\n\t\t\tdp[i][j] += dp[i-1][j]\n\t\t\tdp[i][j] %= MOD\n\nprint(dp[2*n-1][R])"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nr = [0] * 2 * n\nb = [0] * 2 * n\n\nif s[0] == \"0\":\n    r[0] = 2\nelif s[0] == \"1\":\n    r[0] = 1\n    b[0] = 1\nelse:\n    b[0] = 2\n\nfor i in range(1, n):\n    if s[i] == \"0\":\n        r[i] = r[i - 1] + 2\n        b[i] = b[i - 1]\n    elif s[i] == \"1\":\n        r[i] = r[i - 1] + 1\n        b[i] = b[i - 1] + 1\n    else:\n        r[i] = r[i - 1]\n        b[i] = b[i - 1] + 2\n\nfor i in range(n, 2 * n):\n    r[i] = r[n - 1]\n    b[i] = b[n - 1]\n\ndp = [[0 for i in range(0, 2 * n)] for j in range(0, r[-1] + 1)]\n\nif b[0] > 0:\n    dp[0][0] = 1\n\nif r[0] > 0:\n    dp[1][0] = 1\n\nfor k in range(1, 2 * n):\n    if dp[0][k - 1] == 0:\n        dp[0][k] = 0\n    else:\n        rk = r[k]\n        bk = b[k] - k\n        if bk > 0:\n            dp[0][k] = 1\n            \nfor j in range(1, r[-1] + 1):\n    for k in range(1, 2 * n):\n        if dp[j - 1][k - 1] > 0 and j - 1 < r[k]:\n            dp[j][k] += dp[j - 1][k - 1]\n        if dp[j][k - 1] > 0 and k - j < b[k]:\n            dp[j][k] += dp[j][k - 1]\n        dp[j][k] %= 998244353\n    \nprint(dp[-1][-1])"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\ns = list(map(int, list(input())))\nn = len(s)\ndp = [[0]*(sum(s)+1) for _ in range(2*n+1)]\ndp[0][0] = 1\ncurr = curb = 0\nfor i in range(2*n):\n  if i < n:\n    curb += s[i]\n    curr += 2 - s[i]\n  for j in range(min(i, curb)+1):\n    if dp[i][j]:\n      dp[i][j] %= mod\n      if i - j < curr:\n        dp[i+1][j] += dp[i][j]\n      if j < curb:\n        dp[i+1][j+1] += dp[i][j]\nprint(dp[2*n][curb] % mod)   "
  },
  {
    "language": "Python",
    "code": "S = input()\nN = len(S)\nmod = 998244353\n\nblue = [0] * N\nred = [0] * N\nfor i in range(N):\n    blue[i] = blue[i-1] + int(S[i])\n    red[i] = red[i-1] + 2 - int(S[i])\n\ndp = [[0 for _ in range(blue[-1] + 1)] for _ in range(2*N+1)]\ndp[0][0] = 1\nfor i in range(N):\n    for j in range(blue[-1]+1):\n        if j + 1 <= blue[i]:\n            dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod\n        if i+1-j <= red[i]:\n            dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod\nfor i in range(N, 2*N):\n    for j in range(blue[-1]+1):\n        if j+1 <= blue[-1]:\n            dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % mod\n        dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod\n\nprint(dp[-1][-1])\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\n\nMOD = 998244353  # type: int\n\ndef solve(S: str):\n    n = len(S)\n    b_total = 0\n    b_counts = []\n    for c in S:\n        b_total += ord(c) - ord('0')\n        b_counts.append(b_total)\n    dp = [[0] * (b_total + 1) for _ in range(2 * n + 1)]\n    dp[0][0] = 1\n    for i in range(2 * n):\n        for j in range(min(i + 1, b_total + 1)):\n            b_max = b_counts[i] if i < n else b_total\n            r_max = (i + 1) * 2 - b_max if i < n else 2 * n - b_total\n            if b_max >= j + 1:\n                dp[i + 1][j + 1] += dp[i][j]\n            if r_max >= (i + 1) - j:\n                dp[i + 1][j] += dp[i][j]\n    ret = sum(dp[2 * n])\n    print(ret % MOD)\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    S = str(next(tokens))\n    solve(S)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nmod= 998244353\n\nFACT=[1]\nfor i in range(1,2*10**5+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(2*10**5,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nR=0\nB=0\n\nRB=[[0,0]]*N\n\nfor i in range(N):\n    s=S[i]\n    if s==\"0\":\n        R+=2\n    elif s==\"1\":\n        R+=1\n        B+=1\n    else:\n        B+=2\n    RB[i]=[R,B]\n\nDP=[0]*(R+1)\nDP[0]=1\n\nfor i in range(N):\n    NDP=[0]*(R+1)\n    red,blue=RB[i]\n    for r in range(R+1):\n        if DP[r]==0:\n            continue\n        if r+1<=red:\n            NDP[r+1]+=DP[r]\n        if i-r+1<=blue:\n            NDP[r]+=DP[r]\n    DP=NDP\n\n\nANS=0\nfor r in range(N+1):\n    red=RB[-1][0]-r\n    blue=RB[-1][1]-(N-r)\n\n    ANS=ANS+DP[r]*Combi(red+blue,blue)\n    ANS%=mod\nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef inpl(): return list(map(int, input().split()))\nMOD = 998244353\n\nS = input()\nN = len(S)\nB = [0]*N\nR = [0]*N\n\nfor i in range(N):\n    b = int(S[i])\n    B[i] = b\n    R[i] = 2 - b\n\nDP = defaultdict(int)\nDP[(B[0], R[0])] = 1\n\nfor i in range(1, N):\n    DP2 = defaultdict(int)\n    b1, r1 = B[i], R[i]\n    for (b0, r0), v in DP.items():\n        b2, r2 = b0+b1, r0+r1\n        if b0:\n            DP2[(b2-1, r2)] = (DP2[(b2-1, r2)] + v)%MOD\n        if r0:\n            DP2[(b2, r2-1)] = (DP2[(b2, r2-1)] + v)%MOD\n    DP = DP2\n\nfor _ in range(N+1):\n    DP2 = defaultdict(int)\n    for (b, r), v in DP.items():\n        if b:\n            DP2[(b-1, r)] = (DP2[(b-1, r)] + v)%MOD\n        if r:\n            DP2[(b, r-1)] = (DP2[(b, r-1)] + v)%MOD\n    DP = DP2\n\nprint(sum(DP.values()))"
  },
  {
    "language": "Python",
    "code": "M=998244353\nS=input()\nN=len(S)\nd=[[0]*4001 for _ in range(4001)]\nd[0][0]=1\nx=0\nfor i in range(2*N):\n\tif i<N:\n\t\tx+=int(S[i])\n\t\ty=2*i+2-x\n\tfor j in range(i+1):\n\t\tfor k in range(2):\n\t\t\tif i-y<=j-k<x:d[j+1-k][i-j+k]+=d[j][i-j]%M\nprint(d[x][y]%M)"
  },
  {
    "language": "Python",
    "code": "s=input()\nn=len(s)\n\nDP=[[0 for i in range(2*n+1)] for j in range(2*n+1)]\nDP[0][0]=1\n\nfor i in range(1,2*n+1):\n    ao=sum(int(s[t]) for t in range(min(i,n)))\n    aka=min(i,n)*2-ao\n    for j in range(0,i+1):\n        if ao-j>=0 :\n            DP[i][j]+=DP[i-1][j-1]\n        if aka-(i-j)>=0 :\n            DP[i][j]+=DP[i-1][j]\n\n#print(DP)\nprint(sum(DP[2*n]))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef prepare(n):\n    f = 1\n    for i in range(2, n + 1):\n        f = f * i % MOD\n    inv = [1] * (n + 1)\n    inv[n] = pow(f, MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv[i - 1] = inv[i] * i % MOD\n    return f, inv\n\n\nMOD = 998244353\ns = input()\nn = len(s)\ndp = np.zeros(n + 1, dtype=np.int64)\ndp[0] = 1\nb_all = 0\ni, j = 0, 1\nfor k in range(n):\n    b_all += int(s[k])\n    ball = 2 * (k + 1)\n    dp += np.roll(dp, 1)\n    dp %= MOD\n    if j <= ball - b_all:\n        j += 1\n    else:\n        dp[j] = 0\n    if k - i < b_all:\n        pass\n    else:\n        dp[i] = 0\n        i += 1\nr_all = 2 * n - b_all\nf, inv = prepare(n)\nans = 0\nfor k in range(i, j):\n    r = r_all - k\n    b = n - r\n    ans += dp[k] * f % MOD * inv[r] % MOD * inv[b]\n    ans %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "S = input()\nN = len(S)\n\nredarray = [0] * (N+1)\nbluarray = [0] * (N+1)\n\nfor e,c in enumerate(S):\n\n    if c == \"2\":\n        bluarray[e+1] += 2\n    elif c == \"1\":\n        redarray[e+1] += 1\n        bluarray[e+1] += 1\n    elif c == \"0\":\n        redarray[e+1] += 2\n\nfor i in range(1,N+1):\n    redarray[i] += redarray[i-1]\n    bluarray[i] += bluarray[i-1]\n\ndp = [ [0] * (2*N+1) for _ in range(2*N+1)]\ndp[0][0] = 1\nMOD = 998244353\n\nfor p in range(1, 2*N+1):\n    for r in range(0, p):\n        idx = p if p <= N else N\n        if r < redarray[idx]:\n            dp[p][r+1] += dp[p-1][r] % MOD\n        if p-1-r < bluarray[idx]:\n            dp[p][r] += dp[p-1][r] % MOD\n\nprint(dp[2*N][redarray[N]]%MOD)"
  },
  {
    "language": "Python",
    "code": "# 数え上げで制約が 2 乗っぽいのでどうせ dp だろという気持ちになる\n# なんで入力が数字で与えられるのかを考えるとちょっと視界が開ける\n\n# よく考えると、できる列の制約は\n# 「赤い/青いボールはできる列の i 個目までに A[i]/B[i] 個使える」\n# と表せることがわかる\n# これに気付けばあとは\n#     dp[i][j] := i 個目まで並べたとき赤いボールを j 個使う場合の数\n# とした dp が自然と思いつく\n\nfrom itertools import accumulate\nimport numpy as np\n\ndef main():\n    mod = 998244353\n    B = list(map(int, input()))\n    N = len(B)\n    A = [2-b for b in B] + [0]*N\n    B += [0] * N\n    a = b = 0\n    for i in range(2*N):\n        b += B[i]\n        if b > 0:\n            b -= 1\n            B[i] = 1\n        a += A[i]\n        if a > 0:\n            a -= 1\n            A[i] = 1\n\n    A = list(accumulate(A))\n    B = list(accumulate(B))\n\n    dp = np.zeros((2*N+1, 2*N+1), dtype=np.int64)\n    dp[0, 0] = 1\n    for i, (a, b) in enumerate(zip(A, B), 1):\n        dp[i, :] = dp[i-1, :]\n        dp[i, 1:] = (dp[i, 1:] + dp[i-1, :-1]) % mod\n        dp[i, :i-b] = 0\n        dp[i, a+1:] = 0\n\n    print(dp[2*N].sum() % mod)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\ns = input()\nn = len(s)\nR = s.count(\"0\") * 2 + s.count(\"1\")\nB = 2*n - R\nrb = [[R, B] for _ in range(2*n)]\nif s[0] == \"0\":\n\trb[0] = [2, 0]\nelif s[0] == \"1\":\n\trb[0] = [1, 1]\nelse:\n\trb[0] = [0, 2]\nfor i in range(1, n):\n\tif s[i] == \"0\":\n\t\trb[i] = [rb[i-1][0] + 2, rb[i-1][1] + 0]\n\telif s[i] == \"1\":\n\t\trb[i] = [rb[i-1][0] + 1, rb[i-1][1] + 1]\n\telse:\n\t\trb[i] = [rb[i-1][0] + 0, rb[i-1][1] + 2]\n\ndp = [[0 for _ in range(R+1)] for _ in range(2*n)]\nif rb[0][0] >= 1:\n\tdp[0][1] = 1\nif rb[0][1] >= 1:\n\tdp[0][0] = 1\nfor i in range(1, 2*n):\n\tfor j in range(R+1):\n\t\tif j > 0 and rb[i][0] >= j:\n\t\t\tdp[i][j] += dp[i-1][j-1]\n\t\t\tdp[i][j] %= MOD\n\t\tif j != i+1 and rb[i][1] >= i+1 - j:\n\t\t\tdp[i][j] += dp[i-1][j]\n\t\t\tdp[i][j] %= MOD\n\nprint(dp[2*n-1][R])"
  },
  {
    "language": "Python",
    "code": "# 数え上げで制約が 2 乗っぽいのでどうせ dp だろという気持ちになる\n# なんで入力が数字で与えられるのかを考えるとちょっと視界が開ける\n\n# よく考えると、できる列の制約は\n# 「赤い/青いボールはできる列の i 個目までに A[i]/B[i] 個使える」\n# と表せることがわかる\n# これに気付けばあとは\n#     dp[i][j] := i 個目まで並べたとき赤いボールを j 個使う場合の数\n# とした dp が自然と思いつく\n\nfrom itertools import accumulate\n\ndef main():\n    mod = 998244353\n    B = list(map(int, input()))\n    N = len(B)\n    A = [2-b for b in B] + [0]*N\n    B += [0] * N\n    a = b = 0\n    for i in range(2*N):\n        b += B[i]\n        if b > 0:\n            b -= 1\n            B[i] = 1\n        a += A[i]\n        if a > 0:\n            a -= 1\n            A[i] = 1\n\n    A = list(accumulate(A))\n    B = list(accumulate(B))\n\n    dp = [[0]*(2*N+2) for _ in range(2*N+1)]\n    dp[0][0] = 1\n    for i, (a, b) in enumerate(zip(A, B), 1):\n        for j in range(2*N+1):\n            if i - b <= j <= a:\n                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % mod\n\n    print(sum(dp[2*N]) % mod)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nmod= 998244353\n\nFACT=[1]\nfor i in range(1,2*10**5+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(2*10**5,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nR=0\nB=0\n\nRB=[[0,0]]*N\n\nfor i in range(N):\n    s=S[i]\n    if s==\"0\":\n        R+=2\n    elif s==\"1\":\n        R+=1\n        B+=1\n    else:\n        B+=2\n    RB[i]=[R,B]\n\nDP=[0]*(R+1)\nDP[0]=1\n\nfor i in range(N):\n    NDP=[0]*(R+1)\n    red,blue=RB[i]\n    for r in range(R+1):\n        if DP[r]==0:\n            continue\n        if r+1<=red:\n            NDP[r+1]+=DP[r]\n        if i-r+1<=blue:\n            NDP[r]+=DP[r]\n    DP=NDP\n\n\nANS=0\nfor r in range(R+1):\n    red=R-r\n    blue=B-(N-r)\n\n    ANS=ANS+DP[r]*Combi(red+blue,blue)\n    ANS%=mod\nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "S = input()\nn = len(S)\nmod = 998244353\n# dp[i][j] = i番目まで見てj個青玉をとっているときの場合の数\n# 求めるもの : sum(dp[2*n])\ndp = [[0] * (2 * n + 1) for i in range(2 * n + 1)]\ndp[0][0] = 1\nnow = 0\nfor i, s in enumerate(S):\n    now += int(s)\n    for j in range(i+1):\n        dp[i + 1][j] += ((2 * (i + 1) - now - (i - j)) > 0) * dp[i][j]\n        dp[i + 1][j + 1] += ((now - j) > 0) * dp[i][j]\n        dp[i + 1][j] %= mod\n        dp[i + 1][j + 1] %= mod\nans = 0\nfor i in range(n, 2 * n):\n    for j in range(i+1):\n        dp[i + 1][j] += ((2 * n - now - (i - j)) > 0) * dp[i][j]\n        dp[i + 1][j + 1] += ((now - j) > 0) * dp[i][j]\n        dp[i + 1][j] %= mod\n        dp[i + 1][j + 1] %= mod\nprint(sum(dp[2*n])%mod)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\nfrom scipy.misc import comb\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\n# MOD = 10 ** 9 + 7\nMOD = 998244353\n\nS = list(map(int, list(sys.stdin.readline().rstrip())))\nN = len(S)\n\n# dp[i][c]: i まで決めた、使えるけど使ってない青が j 個余ってるパターン数\ndp = np.zeros((N + 1, N * 2 + 10), dtype=int)\ndp[0][0] = 1\n\nfor i in range(N):\n    if S[i] == 2:\n        # 青を使う\n        dp[i + 1][1:] += dp[i][:-1]\n        # 赤を使う\n        dp[i + 1][2:i + 2] += dp[i][:i]\n    if S[i] == 1:\n        # 青を使う\n        dp[i + 1] += dp[i]\n        # 赤を使う\n        dp[i + 1][1:] += dp[i][:-1]\n    if S[i] == 0:\n        # 青を使う\n        dp[i + 1][:-1] += dp[i][1:]\n        # 赤を使う\n        dp[i + 1] += dp[i]\n    dp[i + 1] %= MOD\n\n# print(dp)\nans = 0\nfor c, cnt in enumerate(dp[-1]):\n    # N から c 個選ぶ\n    ans += comb(N, c, exact=True) * cnt\n    ans %= MOD\n    # print(N, c, cnt)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import accumulate\nS=input()\nl=len(S)\nmod=998244353\nR_cnt,B_cnt=[],[]\nfor i in S:\n    R_cnt.append(2-int(i))\n    B_cnt.append(int(i))\nR_acc=[0]+list(accumulate(R_cnt))\nR_acc+=[R_acc[-1]]*l\nB_acc=[0]+list(accumulate(B_cnt))\nB_acc+=[B_acc[-1]]*l\nDP=[[0]*(2*l+1) for _ in range(2*l+1)]\nDP[0][0]=1\nfor i in range(2*l):\n    for r in range(i+1):\n        if R_acc[i+1]>=r+1:\n            DP[i+1][r+1]+=DP[i][r]\n            DP[i+1][r+1]%=mod\n        if B_acc[i+1]>=i+1-r:\n            DP[i+1][r]+=DP[i][r]\n            DP[i+1][r]%=mod\nprint(max(DP[-1]))"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nmod=998244353\nred=[0]*N\nblue=[0]*N\nfor i in range(N):\n    if S[i]==\"0\":\n        red[i]+=2\n    elif S[i]==\"1\":\n        red[i]+=1\n        blue[i]+=1\n    else:\n        blue[i]+=2\n    if i!=0:\n        red[i]+=red[i-1]\n        blue[i]+=blue[i-1]\nR=red[-1]\nB=blue[-1]\n\ndp=[[0 for i in range(2*N+1)] for i in range(2*N+1)]\n\ndp[2*N][R]=1\n\nfor i in range(2*N-1,-1,-1):\n    for j in range(2*N+1):\n        if i>=N:\n            r=R-j\n            b=B-(i-j)\n            if r and 2*N>=j+1:\n                dp[i][j]+=dp[i+1][j+1]\n                dp[i][j]%=mod\n            if b:\n                dp[i][j]+=dp[i+1][j]\n                dp[i][j]%=mod\n        else:\n            r=red[i]-j\n            b=blue[i]-(i-j)\n            if r and 2*N>=j+1:\n                dp[i][j]+=dp[i+1][j+1]\n                dp[i][j]%=mod\n            if b:\n                dp[i][j]+=dp[i+1][j]\n                dp[i][j]%=mod\n\n\nprint(dp[0][0])"
  },
  {
    "language": "Python",
    "code": "\"\"\"\n\ni回目では前からi人目の持っていた任意のボールを置ける\n赤を何回採用したかでDP\n\n\n\"\"\"\n\nS = input()\nN = len(S)\nmod = 998244353\n\nlis = [0] * (2*N+1)\nlis[0] = 1\nR = 0\nB = 0\n\nc = 0\nfor n in S:\n\n    if n == \"0\":\n        R += 2\n    elif n == \"1\":\n        R += 1\n        B += 1\n    else:\n        B += 2\n\n    nlis = [0] * (2*N+1)\n    \n    for i in range(2*N):\n\n        if i < R:\n            nlis[i+1] += lis[i]\n            nlis[i+1] %= mod\n\n        if c-i < B:\n            nlis[i] += lis[i]\n            nlis[i] %= mod\n\n    lis = nlis\n    c += 1\n\n\nfor loop in range(N):\n    \n    nlis = [0] * (2*N+1)\n    \n    for i in range(2*N):\n\n        if i < R:\n            nlis[i+1] += lis[i]\n            nlis[i+1] %= mod\n\n        if c-i < B:\n            nlis[i] += lis[i]\n            nlis[i] %= mod\n\n    lis = nlis\n    c += 1\n\nprint (sum(lis) % mod)"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nd=[[0]*4001 for _ in range(4001)]\nd[0][0]=1\nx=0\nfor i in range(2*N):\n\tif i<N:\n\t\tx+=int(S[i])\n\t\ty=2*i+2-x\n\tfor j in range(i+1):\n\t\tfor k in range(2):\n\t\t\tif i-y<=j-k<x:d[j+1-k][i-j+k]+=d[j][i-j]%998244353\nprint(d[x][y])"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef nCr(com_n, com_r):\n    if com_n < com_r: return 0\n    return fac[com_n] * ifac[com_r] % md * ifac[com_n - com_r] % md\n\n# combinationの準備\n# md>n_maxの条件\nmd = 998244353\nn_max = 4005\nfac = [1]\nfor i in range(1, n_max + 1): fac.append(fac[-1] * i % md)\nifac = [1] * (n_max + 1)\nifac[n_max] = pow(fac[n_max], md - 2, md)\nfor i in range(n_max - 1, 1, -1): ifac[i] = ifac[i + 1] * (i + 1) % md\n\ndef solve():\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    r = b = 0\n    for i, c in enumerate(s):\n        if c == \"0\": r += 2\n        elif c == \"2\": b += 2\n        else: r, b = r + 1, b + 1\n        for j in range(n):\n            pre = dp[i][j]\n            if pre == 0: continue\n            if j + 1 <= r: dp[i + 1][j + 1] += pre\n            if i + 1 - j <= b: dp[i + 1][j] += pre\n    # p2D(dp)\n    ans = 0\n    for j in range(n + 1):\n        ans += dp[n][j] * nCr(n, r - j)\n        ans %= md\n    print(ans)\n\ns=SI()\nn=len(s)\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\ns = list(map(int, list(input())))\nn = len(s)\ndp = [[0]*(sum(s)+1) for _ in range(2*n+1)]\ndp[0][0] = 1\ncurr = curb = 0\nfor i in range(2*n):\n  if i < n:\n    curb += s[i]\n    curr += 2 - s[i]\n  for j in range(min(i, curb)+1):\n    if dp[i][j]:\n      dp[i][j] %= mod\n      if i - j < curr:\n        dp[i+1][j] += dp[i][j]\n      if j < curb:\n        dp[i+1][j+1] += dp[i][j]\nprint(dp[2*n][curb])   "
  },
  {
    "language": "Python",
    "code": "def main():\n    s = list(map(int, list(input())))\n    n = len(s)\n    dp = [1]\n    mod = 998244353\n    for i, c in enumerate(s):\n        dp2 = [0]*(i+2)\n        for r in range(i+1):\n            if r+c > 0:\n                dp2[r+c-1] = (dp2[r+c-1]+dp[r]) % mod\n            if i+2-r-c > 0:\n                dp2[r+c] += (dp2[r+c]+dp[r]) % mod\n        dp = dp2\n    for i in range(n):\n        dp2 = [0]*(n-i)\n        for r in range(n-i+1):\n            if r > 0:\n                dp2[r-1] = (dp2[r-1]+dp[r]) % mod\n            if n-i-r > 0:\n                dp2[r] = (dp2[r]+dp[r]) % mod\n        dp = dp2\n    print(dp[0] % mod)\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "from itertools import accumulate\nS=input()\nl=len(S)\nmod=998244353\nR_cnt,B_cnt=[],[]\nfor i in S:\n    R_cnt.append(2-int(i))\n    B_cnt.append(int(i))\nR_acc=[0]+list(accumulate(R_cnt))\nR_acc+=[R_acc[-1]]*l\nB_acc=[0]+list(accumulate(B_cnt))\nB_acc+=[B_acc[-1]]*l\nDP=[[0]*(2*l+1) for _ in range(2*l+1)]\nDP[0][0]=1\nfor i in range(2*l):\n    for r in range(i+1):\n        if R_acc[i+1]>=r+1:\n            DP[i+1][r+1]+=DP[i][r]\n            DP[i+1][r+1]%=mod\n        if B_acc[i+1]>=i+1-r:\n            DP[i+1][r]+=DP[i][r]\n            DP[i+1][r]%=mod\nprint(DP[-1][R_acc[-1]])"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nmod= 998244353\n\nFACT=[1]\nfor i in range(1,2*10**5+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(2*10**5,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nR=0\nB=0\n\nRB=[[0,0]]*N\n\nfor i in range(N):\n    s=S[i]\n    if s==\"0\":\n        R+=2\n    elif s==\"1\":\n        R+=1\n        B+=1\n    else:\n        B+=2\n    RB[i]=[R,B]\n\nDP=[0]*(R+1)\nDP[0]=1\n\nfor i in range(N):\n    NDP=[0]*(R+1)\n    red,blue=RB[i]\n    for r in range(R+1):\n        if DP[r]==0:\n            continue\n        if r+1<=red:\n            NDP[r+1]+=DP[r]\n        if i-r+1<=blue:\n            NDP[r]+=DP[r]\n    DP=NDP\n\n\nANS=0\nfor r in range(R+1):\n    red=R-r\n    blue=B-(N-r)\n\n    ANS=ANS+DP[r]*Combi(red+blue,blue)\n    ANS%=mod\nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nS = input()\nN = len(S)\nSum = [0]*(N+1)\nfor i in range(1, N+1):\n    Sum[i] = Sum[i-1]+int(S[i-1])\nfrom functools import lru_cache\n@lru_cache(maxsize=10**8)\ndef dp(i, j):\n    n = min(i+j+1, N)\n    if i+j == N*2:\n        return 1\n    res = 0\n    s = Sum[n]\n    if i<s:\n        res+=dp(i+1, j)\n    if j<2*n-s:\n        res+=dp(i, j+1)\n    return res%mod\nprint(dp(0, 0))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef tqdm(iterable): return iterable\ndef inpl(): return list(map(int, input().split()))\nMOD = 998244353\n\nS = input()\nN = len(S)\nB = [0]*N\nR = [0]*N\n\nfor i in range(N):\n    b = int(S[i])\n    B[i] = b\n    R[i] = 2 - b\n\nDP = defaultdict(int)\nDP[(B[0], R[0])] = 1\n\nfor i in tqdm(range(1, N)):\n    DP2 = defaultdict(int)\n    b1, r1 = B[i], R[i]\n    for (b0, r0), v in DP.items():\n        b2, r2 = b0+b1, r0+r1\n        if b0:\n            DP2[(b2-1, r2)] = (DP2[(b2-1, r2)] + v)%MOD\n        if r0:\n            DP2[(b2, r2-1)] = (DP2[(b2, r2-1)] + v)%MOD\n    DP = DP2\n\nfor _ in tqdm(range(N+1)):\n    DP2 = defaultdict(int)\n    for (b, r), v in DP.items():\n        if b:\n            DP2[(b-1, r)] = (DP2[(b-1, r)] + v)%MOD\n        if r:\n            DP2[(b, r-1)] = (DP2[(b, r-1)] + v)%MOD\n    DP = DP2\n\nprint(sum(DP.values()))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\nMOD = 998244353\n\nS = input().rstrip()\nN = len(S)\n\n# 現時点までで使える個数\nblue = 0\nred = 0\n# 青の個数、通り数\ndp = np.array([1], dtype=np.int64)\nfor i in range(2*N):\n    if i < N:\n        blue += int(S[i])\n        red = 2 * (i+1) - blue\n    prev = dp\n    dp = np.zeros(blue+1, dtype=np.int64)\n    # 青を追加する場合\n    L = min(len(prev), blue)\n    dp[1:L+1] += prev[:L]\n    # 赤を追加する場合\n    dp[:len(prev)] += prev\n    # 赤を選べない場合もある。\n    min_blue = (i+1) - red\n    if min_blue >= 1:\n        dp[:min_blue] = 0\n    dp %= MOD\n\nanswer = dp[-1]\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "\"\"\"\n\ni回目では前からi人目の持っていた任意のボールを置ける\n赤を何回採用したかでDP\n\n\n\"\"\"\n\nS = input()\nN = len(S)\nmod = 998244353\n\nlis = [0] * (2*N+1)\nlis[0] = 1\nR = 0\nB = 0\n\nc = 0\nfor n in S:\n\n    if n == \"0\":\n        R += 2\n    elif n == \"1\":\n        R += 1\n        B += 1\n    else:\n        B += 2\n\n    nlis = [0] * (2*N+1)\n    \n    for i in range(2*N):\n\n        if i < R:\n            nlis[i+1] += lis[i]\n            nlis[i+1] %= mod\n\n        if c-i < B:\n            nlis[i] += lis[i]\n            nlis[i] %= mod\n\n    lis = nlis\n    c += 1\n\n\nfor loop in range(N):\n    \n    nlis = [0] * (2*N+1)\n    \n    for i in range(2*N):\n\n        if i < R:\n            nlis[i+1] += lis[i]\n            nlis[i+1] %= mod\n\n        if c-i < B:\n            nlis[i] += lis[i]\n            nlis[i] %= mod\n\n    lis = nlis\n    c += 1\n\nprint (sum(lis) % mod)"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\n\ndp = [[0 for i in range(0, 2 * n)] for j in range(0, 2 * n)]\n\nrk = 0\nbk = 0\n\nif s[0] == \"0\":\n    rk = 2\nelif s[0] == \"1\":\n    rk = 1\n\nbk = 2 - rk\n\nif bk > 0:\n    dp[0][0] = 1\n\nif rk > 0:\n    dp[1][0] = 1\n    \nfor k in range(1, 2 * n):\n    if k < n:\n        if s[k] == \"0\":\n            rk += 2\n        elif s[k] == \"1\":\n            rk += 1\n        bk = 2 * (k+1) - rk\n    \n    dp[0][k] = dp[0][k - 1] if k < bk else 0\n    \n    for j in range(1, rk + 1):\n        dp[j][k] = ((dp[j - 1][k - 1] if j - 1 < rk else 0) + (dp[j][k - 1] if k - j < bk else 0)) % 998244353\n    \nprint(dp[rk][-1])"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nS = input()[:-1]\nN = len(S)\ndp = [[0]*(2*N+1) for _ in range(2*N+1)]\ndp[0][0] = 1\nMOD = 998244353\nr, b = 0, 0\n\nfor i in range(2*N):\n    if i<N:\n        if S[i]=='0':\n            r += 2\n        elif S[i]=='1':\n            r += 1\n            b += 1\n        else:\n            b += 2\n        \n    for j in range(2*N+1):\n        rc = r-j\n        bc = b-(i-j)\n        \n        if rc>0:\n            dp[i+1][j+1] += dp[i][j]\n            dp[i+1][j+1] %= MOD\n        \n        if bc>0:\n            dp[i+1][j] += dp[i][j]\n            dp[i+1][j] %= MOD\n    \nprint(sum(dp[2*N]))"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nimport sys\nsys.setrecursionlimit(10**9)\nS = input()\nN = len(S)\nSum = [0]*(N+1)\nfor i in range(1, N+1):\n    Sum[i] = Sum[i-1]+int(S[i-1])\nfrom functools import lru_cache\n@lru_cache(maxsize=10**8)\ndef dp(i, j):\n    n = min(i+j+1, N)\n    if i+j == N*2:\n        return 1\n    res = 0\n    s = Sum[n]\n    if i<s:\n        res+=dp(i+1, j)\n    if j<2*n-s:\n        res+=dp(i, j+1)\n    return res%mod\nprint(dp(0, 0))"
  },
  {
    "language": "Python",
    "code": "s=input()\nn=len(s)\nmod=998244353\n\nDP=[[0 for i in range(2*n+1)] for j in range(2*n+1)]\nDP[0][0]=1\n\nao=0\n\nfor i in range(1,2*n+1):\n    if i<=n :\n        ao+=int(s[i-1])\n        aka=i*2-ao\n    #ao=sum(int(s[t]) for t in range(min(n,i)))\n    #aka=min(i,n)*2-ao\n    for j in range(0,min(ao+1,i+1)):\n        DP[i][j]=(DP[i][j]+DP[i-1][j-1])%mod\n    for j in range(max(0,i-aka),i+1):\n        DP[i][j]=(DP[i][j]+DP[i-1][j])%mod\n\n#print(DP)\nprint(sum(DP[2*n])%mod)\n"
  },
  {
    "language": "Python",
    "code": "s=input()\nN=len(s)\ntable=[]\nmod=998244353\n\nif s[0]==\"0\":\n  table.append((2,0))\nelif s[0]==\"1\":\n  table.append((1,1))\nelif s[0]==\"2\":\n  table.append((0,2))\nfor i in range(1,N):\n  r,b=table[-1]\n  if s[i]==\"0\":\n    r,b=table[-1]\n    table.append((r+2,b))\n  elif s[i]==\"1\":\n    r,b=table[-1]\n    table.append((r+1,b+1))\n  elif s[i]==\"2\":\n    r,b=table[-1]\n    table.append((r,b+2))\nfor i in range(N):\n  table.append(table[-1])\ndp=[[0]*(2*N+1) for i in range(2*N+1)]\ndp[0][0]=1\nfor i in range(2*N):\n  for k in range(2*N):\n    if k+1<=table[i][0]:\n      dp[i+1][k+1]=(dp[i+1][k+1]+dp[i][k])%mod\n    if i+1-k<=table[i][1]:\n      dp[i+1][k]=(dp[i+1][k]+dp[i][k])%mod\nans=0\nfor k in range(2*N+1):\n  ans=(ans+dp[2*N][k])%mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\ndef cmb(n, r, mod=mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nNN = 10**5 # 使うデータによって変える\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, NN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\nimport sys\ninput = sys.stdin.readline\n\nS = list(input().rstrip())\n\nL = len(S)\ndp = [[0]*(L+1) for _ in range(L+1)]\ndp[0][0] = 1\nrmax = [0, 0]\nrmin = [0, 0]\nrsum = 0\nfor i, s in enumerate(S):\n    p = int(s)\n    rsum += p\n    if p == 0:\n        rmin[1] += 2\n    elif p == 1:\n        rmax[1] += 1\n        rmin[1] += 1\n    else:\n        rmax[1] += 2\n    if rmax[1] > 0:\n        rmax[0] += 1\n        rmax[1] -= 1\n    if rmin[1] > 0:\n        rmin[0] += 1\n        rmin[1] -= 1\n    for j in range(i+1):\n        if rmax[0] >= j+1:\n            dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod\n        if rmin[0] >= (i+1) - j:\n            dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % mod\n\n\nans = 0\nfor j in range(L+1):\n    ans = (ans + dp[L][j] * cmb(L, rsum-j)) % mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nimport sys\nsys.setrecursionlimit(10**9)\nS = input()\nN = len(S)\nSum = [0]*(N+1)\nfor i in range(1, N+1):\n    Sum[i] = Sum[i-1]+int(S[i-1])\ndp = [[0]*(N*2+1) for _ in range(N*2+1)]\nfor i in range(N*2+1)[::-1]:\n    for j in range(N*2+1)[::-1]:\n        if i+j == N*2:\n            dp[i][j] = 1\n            continue\n        n = min(i+j+1, N)\n        s = Sum[n]\n        if i<s:\n            dp[i][j]+=dp[i+1][j]\n        if 2*n-s>j:\n            dp[i][j]+=dp[i][j+1]\n        dp[i][j]%=mod\nprint(dp[0][0])   "
  },
  {
    "language": "Python",
    "code": "S = input()\nN = len(S)\n\nfrom collections import defaultdict\n\nreddic = defaultdict(int)\nbludic = defaultdict(int)\n\nredarray = [0] * (N+1)\nbluarray = [0] * (N+1)\n\nfor e,c in enumerate(S):\n\n    if c == \"2\":\n        bludic[e+1] += 2\n        bluarray[e+1] += 2\n    elif c == \"1\":\n        reddic[e+1] += 1\n        bludic[e+1] += 1\n\n        redarray[e+1] += 1\n        bluarray[e+1] += 1\n    elif c == \"0\":\n        reddic[e+1] += 2\n        redarray[e+1] += 2\n\nfor i in range(1,N+1):\n    redarray[i] += redarray[i-1]\n    bluarray[i] += bluarray[i-1]\n\n# print(\"redarray: \", redarray)\n# print(\"bluarray: \", bluarray)\n\ndp = [ [0] * (2*N+1) for _ in range(2*N+1)]\ndp[0][0] = 1\nMOD = 998244353\n\nfor p in range(1, 2*N+1):\n    for r in range(0, p):\n        idx = p if p <= N else N\n        if r < redarray[idx]:\n            dp[p][r+1] += dp[p-1][r] % MOD\n        if p-1-r < bluarray[idx]:\n            dp[p][r] += dp[p-1][r] % MOD\n    # print(\"{:3d}\".format(p), dp[p])\n\nprint(dp[2*N][redarray[N]]%MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef prepare(n):\n    f = 1\n    for i in range(2, n + 1):\n        f = f * i % MOD\n    inv = [1] * (n + 1)\n    inv[n] = pow(f, MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv[i - 1] = inv[i] * i % MOD\n    return f, inv\n\n\nMOD = 998244353\ns = input()\nn = len(s)\ndp = np.zeros(n + 1, dtype=np.int64)\ndp[0] = 1\nb_all = 0\ni, j = 0, 1\nfor k in range(n):\n    b_all += int(s[k])\n    ball = 2 * (k + 1)\n    dp[i + 1:j + 1] += dp[i:j]\n    dp %= MOD\n    if j <= ball - b_all:\n        j += 1\n    else:\n        dp[j] = 0\n    if k - i < b_all:\n        pass\n    else:\n        dp[i] = 0\n        i += 1\nr_all = 2 * n - b_all\nf, inv = prepare(n)\nans = 0\nfor k in range(i, j):\n    r = r_all - k\n    b = n - r\n    ans += dp[k] * f % MOD * inv[r] % MOD * inv[b]\n    ans %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "S = input()\nN = len(S)\nMOD = 998244353\n\ndp = [[0]*(N+1) for i in range(N+1)] #dp[r][b]\nif S[0] == '0':\n    dp[0][1] = 1\nelif S[0] == '1':\n    dp[1][0] = 1\n    dp[0][1] = 1\nelse:\n    dp[1][0] = 1\n\nfor k in range(1,N):\n    c = int(S[k])\n    for r in range(k+1):\n        b = k-r\n        if c == 1:\n            dp[r][b+1] += dp[r][b]\n            dp[r][b+1] %= MOD\n            dp[r+1][b] += dp[r][b]\n            dp[r+1][b] %= MOD\n        elif c == 0:\n            dp[r][b+1] += dp[r][b]\n            dp[r][b+1] %= MOD\n            if r > 0:\n                dp[r-1][b+2] += dp[r][b]\n                dp[r-1][b+2] %= MOD\n        else:\n            if b > 0:\n                dp[r+2][b-1] += dp[r][b]\n                dp[r+2][b-1] %= MOD\n            dp[r+1][b] += dp[r][b]\n            dp[r+1][b] %= MOD\n\nM = N+5\nfac = [1,1] + [0]*M\nfinv = [1,1] + [0]*M\ninv = [0,1] + [0]*M\nfor i in range(2,M+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef ncr(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = 0\nfor k in range(N+1):\n    ans += ncr(N,k) * dp[k][N-k]\n\nprint(ans % MOD)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef inpl(): return list(map(int, input().split()))\nMOD = 998244353\n\nS = input()\nN = len(S)\nB = [0]*(2*N+1)\nR = [0]*(2*N+1)\n\nfor i in range(N):\n    b = int(S[i])\n    B[i] = b\n    R[i] = 2 - b\n\nDP = defaultdict(int)\nDP[(B[0], R[0])] = 1\n\nfor i in range(1, 2*N+1):\n    DP2 = defaultdict(int)\n    b1, r1 = B[i], R[i]\n    for (b0, r0), v in DP.items():\n        b2, r2 = b0+b1, r0+r1\n        if b0:\n            DP2[(b2-1, r2)] = (DP2[(b2-1, r2)] + v)%MOD\n        if r0:\n            DP2[(b2, r2-1)] = (DP2[(b2, r2-1)] + v)%MOD\n    DP = DP2\n\nprint(sum(DP.values()))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nS = list(map(int, readline().strip()))\nN = len(S)\nMOD = 998244353\ndp = [[0]*(2*N+1) for _ in range(2*N+1)]\ndp[0][0] = 1\n\nB = [0]*(N+1)\nfor i in range(N):\n    B[i+1] = B[i] + S[i]\nB.extend([B[-1] for _ in range(N)])\nR = [0] + [2*i - B[i] for i in range(1, N+1)]\nR.extend([R[-1] for _ in range(N)])\n\nfor i in range(2*N):\n    for j in range(2*N+1):\n        if not dp[i][j]:\n            continue\n        \n        b = B[i+1] - j\n        r = R[i+1] - (i - j)\n        if b > 0:\n            dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j])%MOD\n        if r > 0:\n            dp[i+1][j] = (dp[i+1][j] + dp[i][j])%MOD\nprint(dp[2*N][sum(S)])"
  },
  {
    "language": "Python",
    "code": "# from : https://twitter.com/tempura_cpp/status/1094238517784326144\n\nS = input()\nN = len(S)\nMOD = 998244353\n\nred = []\nblue = []\n\nfor i in range(N):\n    if S[i] == \"0\": # two red balls \n        red.append(i)\n        red.append(i)\n    if S[i] == \"1\": # red, blue\n        red.append(i)\n        blue.append(i)\n    if S[i] == \"2\": # two blue \n        blue.append(i)\n        blue.append(i)\n\nDP = [ [0]*4020 for _ in range(4020)] # DP[rsize][bsize] : # of patterns for \n                                           # the case red size is i, blue size is j. \n                                                        \nDP[0][0] = 1                          # S = \"\" pattern.\n\nrsize = len(red)\nbsize = len(blue)\n# print(\"red: {}, blue: {}\".format(red, blue))\n\n# S = 12001021211100201020\n# red:  [0, 2, 2, 3, 3, 4, 5, 5, 7, 9, 10, 11, 12, 12, 13, 13, 15, 15, 16, 17, 17, 19, 19], \n# blue: [0, 1, 1, 4, 6, 6, 7, 8, 8, 9, 10, 11, 14, 14, 16, 18, 18]\n\n# sample\n# b r r r r r b\n# b r r r r r b\n# blue : [0,0, 6,6]\n# red  : [1,1,2,2,3,3,4,4,5,5]\n# it is hard to use blue[2] = 6, you have to use red 1-5\n# this constraint is represented with m = i+j\n\n\nfor i in range(rsize+1):\n    for j in range(bsize+1):\n\n        DP[i][j] %= MOD\n\n        m = i+j\n\n        if j < bsize and blue[j] <= m:\n            DP[i][j+1] += DP[i][j]\n\n        if i < rsize and red[i] <= m:\n            DP[i+1][j] += DP[i][j]\n\n\nprint(DP[rsize][bsize] % MOD)\n\n\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nr = [0] * 2 * n\nb = [0] * 2 * n\n\nif s[0] == \"0\":\n    r[0] = 2\nelif s[0] == \"1\":\n    r[0] = 1\n    b[0] = 1\nelse:\n    b[0] = 2\n\nfor i in range(1, n):\n    if s[i] == \"0\":\n        r[i] = r[i - 1] + 2\n        b[i] = b[i - 1]\n    elif s[i] == \"1\":\n        r[i] = r[i - 1] + 1\n        b[i] = b[i - 1] + 1\n    else:\n        r[i] = r[i - 1]\n        b[i] = b[i - 1] + 2\n\nfor i in range(n, 2 * n):\n    r[i] = r[n - 1]\n    b[i] = b[n - 1]\n\ndp = [[0 for i in range(0, 2 * n)] for j in range(0, r[-1] + 1)]\n\nif b[0] > 0:\n    dp[0][0] = 1\n\nif r[0] > 0:\n    dp[1][0] = 1\n\nfor k in range(1, 2 * n):\n    if dp[0][k - 1] == 0:\n        dp[0][k] = 0\n    else:\n        rk = r[k]\n        bk = b[k] - k\n        if bk > 0:\n            dp[0][k] = 1\n            \nfor j in range(1, r[-1] + 1):\n    for k in range(1, 2 * n):\n        if dp[j - 1][k - 1] > 0 and j - 1 < r[k]:\n            dp[j][k] += dp[j - 1][k - 1]\n        if dp[j][k - 1] > 0 and k - j < b[k]:\n            dp[j][k] += dp[j][k - 1]\n    \nprint(dp[-1][-1] % 998244353)"
  },
  {
    "language": "Python",
    "code": "s=input()\nn=len(s)\n\nDP=[[0 for i in range(2*n+1)] for j in range(2*n+1)]\nDP[0][0]=1\n\nao=0\n\nfor i in range(1,2*n+1):\n    if i<=n :\n        ao+=int(s[i-1])\n        aka=min(i,n)*2-ao\n    #ao=sum(int(s[t]) for t in range(min(n,i)))\n    #aka=min(i,n)*2-ao\n    for j in range(0,min(ao+1,i+1)):\n        DP[i][j]+=DP[i-1][j-1]\n    for j in range(max(0,i-aka),i+1):\n        DP[i][j]+=DP[i-1][j]\n\n#print(DP)\nprint(sum(DP[2*n]))\n"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nC=[0]\nfor i in range(N):\n  C.append(C[i]+int(S[i]))\nfor i in range(N):\n  C.append(C[N])\nB=C[N]\nDP=[[0]*(B+1) for i in range(2*N+1)]\nDP[0][0]=1\nmod=998244353\nfor i in range(2*N):\n  for j in range(B+1):\n    if 2*min(i+1,N)-C[i+1]>=i+1-j:\n      DP[i+1][j]=(DP[i+1][j]+DP[i][j])%mod\n    if j<C[i+1]:\n      DP[i+1][j+1]=DP[i][j]\nprint(DP[2*N][B])"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\n\"\"\"\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1*a[i][k]\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n\"\"\"\n\n#F\nmod = 998244353\ns = list(sys.stdin.readline().strip())\nn = len(s)\ndp = [[0 for i in range(2*n+1)] for j in range(2*n+1)]\nr = [0 for i in range(n)]\nb = [0 for i in range(n)]\nfor i in range(n):\n    b[i] = int(s[i])\n    r[i] = 2-b[i]\nfor i in range(n-1):\n    r[i+1] += r[i]\n    b[i+1] += b[i]\nr.insert(0,0)\nb.insert(0,0)\nif r[1] > 0:\n    dp[1][1] = 1\nfor i in range(1,n+1):\n    if b[i] < i:break\n    if b[i] >= i:dp[i][0] = 1\nfor i in range(n+1,2*n+1):\n    if b[-1] >= i:dp[i][0] = 1\nfor i in range(2,n+1):\n    for j in range(1,i+1):\n        if r[i] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[i] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\nfor i in range(n+1,2*n+1):\n    for j in range(1,i+1):\n        if r[n] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[n] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\n\nprint(dp[2*n][r[-1]])\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\n\nMOD = 998244353  # type: int\n\ndef comb(n, k):\n    if k > n:\n        return 0\n    k = min(k, n - k)\n    ret = 1\n    for i in range(k):\n        ret *= n - i\n        ret //= i + 1\n    return ret\n\ndef solve(S: str):\n    n = len(S)\n    b_total = 0\n    b_counts = []\n    for c in S:\n        b_total += ord(c) - ord('0')\n        b_counts.append(b_total)\n    dp = [[0] * (b_total + 1) for _ in range(2 * n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(min(i + 1, b_total + 1)):\n            if b_counts[i] >= j + 1:\n                dp[i + 1][j + 1] += dp[i][j]\n            if (i + 1) * 2 - b_counts[i] >= (i + 1) - j:\n                dp[i + 1][j] += dp[i][j]\n    #    print(dp[i])\n    #print(dp[n])\n    comb = [0] * (n + 1)\n    comb[0] = 1\n    for i in range(n):\n        comb[i + 1] = comb[i] * (n - i) // (i + 1)\n    ret = 0\n    for b, val in enumerate(dp[n]):\n        #ret += val * comb(n, b_total - b)\n        ret += val * comb[b_total - b]\n    print(ret % MOD)\n    return\n\n    ##dp[0][0] = 1\n    ##for i in range(2 * n):\n    ##    for j in range(min(i + 1, b_total + 1)):\n    ##        b_max = b_counts[i] if i < n else b_total\n    ##        r_max = (i + 1) * 2 - b_max if i < n else 2 * n - b_total\n    ##        if b_max >= j + 1:\n    ##            dp[i + 1][j + 1] += dp[i][j]\n    ##        if r_max >= (i + 1) - j:\n    ##            dp[i + 1][j] += dp[i][j]\n    ##ret = sum(dp[2 * n])\n    ##print(ret % MOD)\n    ##return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    S = str(next(tokens))\n    solve(S)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\n\"\"\"\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1*a[i][k]\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n\"\"\"\n\n#F\nmod = 998244353\ns = list(sys.stdin.readline().strip())\nn = len(s)\ndp = [[0 for i in range(2*n+1)] for j in range(2*n+1)]\nr = [0 for i in range(n)]\nb = [0 for i in range(n)]\nfor i in range(n):\n    b[i] = int(s[i])\n    r[i] = 2-b[i]\nfor i in range(n-1):\n    r[i+1] += r[i]\n    b[i+1] += b[i]\nr.insert(0,0)\nb.insert(0,0)\nif r[1] > 0:\n    dp[1][1] = 1\nfor i in range(1,2*n+1):\n    if b[min(i,n)] < i:break\n    if b[min(i,n)] >= i:dp[i][0] = 1\nfor i in range(2,n+1):\n    for j in range(1,2*n+1):\n        if r[i] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[i] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\nfor i in range(n+1,2*n+1):\n    for j in range(1,2*n+1):\n        if r[n] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[n] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\n\nprint(dp[2*n][r[-1]])\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\n\"\"\"\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1*a[i][k]\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n\"\"\"\n\n#F\nmod = 998244353\ns = list(sys.stdin.readline().strip())\nn = len(s)\ndp = [[0 for i in range(2*n+1)] for j in range(2*n+1)]\nr = [0 for i in range(n)]\nb = [0 for i in range(n)]\nfor i in range(n):\n    b[i] = int(s[i])\n    r[i] = 2-b[i]\nfor i in range(n-1):\n    r[i+1] += r[i]\n    b[i+1] += b[i]\nr.insert(0,0)\nb.insert(0,0)\nif r[1] > 0:\n    dp[1][1] = 1\nfor i in range(1,2*n+1):\n    if b[i] < i:break\n    if b[min(i,n)] >= i:dp[i][0] = 1\nfor i in range(2,n+1):\n    for j in range(1,2*n+1):\n        if r[i] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[i] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\nfor i in range(n+1,2*n+1):\n    for j in range(1,2*n+1):\n        if r[n] >= j:\n            dp[i][j] += dp[i-1][j-1]\n            dp[i][j] %= mod\n        if b[n] >= i-j:\n            dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\n\nprint(dp[2*n][r[-1]])\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nmod = 998244353\n\nR = [0] * n\nB = [0] * n\nfor i in range(n):\n    if s[i] == '0':\n        R[i] = 2\n    elif s[i] == '1':\n        R[i] = 1\n        B[i] = 1\n    else:\n        B[i] = 2\n\nfor i in range(n-1):\n    R[i+1] += R[i]\n    B[i+1] += B[i]\n\n\ndp = [[0] * (2*n+10) for _ in range(2*n+10)]\n\nif R[0] > 0:\n    dp[0][1] = 1\nif B[0] > 0:\n    dp[0][0] = 1\n\nfor i in range(n-1):\n    for r in range(2*n+1):\n        if R[i+1] >= r+1:\n            dp[i+1][r+1] += dp[i][r]\n            dp[i+1][r+1] %= mod\n        if i+2-r < 0:\n            break\n        if B[i+1] >= i+2-r:\n            dp[i+1][r] += dp[i][r]\n            dp[i+1][r] %= mod\n\nfor i in range(n-1, 2*n-1):\n    for r in range(2*n+1):\n        if R[n-1] >= r+1:\n            dp[i + 1][r + 1] += dp[i][r]\n            dp[i + 1][r + 1] %= mod\n        if i+2-r < 0:\n            break\n        if B[n-1] >= i+2-r:\n            dp[i+1][r] += dp[i][r]\n            dp[i+1][r] %= mod\n\nans = 0\nfor r in range(2*n+1):\n    ans += dp[2*n-1][r]\n    ans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "M=998244353\nS=input()\nN=len(S)\nd=[[0]*4001 for _ in range(4001)]\nd[0][0]=1\nx=0\nfor i in range(2*N):\n\tif i<N:\n\t\tx+=int(S[i])\n\t\ty=2*i+2-x\n\tfor j in range(i+1):\n\t\tfor k in range(2):d[j+1-k][i-j+k]+=i-y<=j-k<x and d[j][i-j]%M\nprint(d[x][y]%M)"
  },
  {
    "language": "Python",
    "code": "s = input()\nN = len(s)\nP = 998244353\nB = 0\nR = 0\n\nY = [[0] * (2*N+1) for _ in range(2*N+1)] # Block\n\nfor i in range(N):\n    if s[i] == \"0\":\n        R += 2\n    elif s[i] == \"1\":\n        B += 1\n        R += 1\n    else:\n        B += 2\n        \n    # print(i, B, R)\n    if R < i+1:\n        for j in range(i+1-R):\n            Y[R+1][j] = 1\n    \n    if B < i+1:\n        for j in range(i+1-B):\n            Y[j][B+1] = 1\n\nX = [[0] * (B+1) for _ in range(R+1)]\n\nfor i in range(R+1):\n    for j in range(B+1):\n        if i == 0 and j == 0:\n            X[i][j] = 1\n            continue\n        \n        if Y[i][j]:\n            continue\n            \n        if j > 0:\n            X[i][j] += X[i][j-1]\n        \n        if i > 0:\n            X[i][j] += X[i-1][j]\n            \n        X[i][j] %= P\n\nprint(X[-1][-1])"
  },
  {
    "language": "Python",
    "code": "s=input()\nn=len(s)\nmod=998244353\n\nDP=[[0 for i in range(2*n+1)] for j in range(2*n+1)]\nDP[0][0]=1\n\nao=0\n\nfor i in range(1,2*n+1):\n    if i<=n :\n        ao+=int(s[i-1])\n        aka=i*2-ao\n    #ao=sum(int(s[t]) for t in range(min(n,i)))\n    #aka=min(i,n)*2-ao\n    for j in range(0,min(ao+1,i+1)):\n        DP[i][j]=(DP[i][j]+DP[i-1][j-1])%mod\n    for j in range(max(0,i-aka),i+1):\n        DP[i][j]=(DP[i][j]+DP[i-1][j])%mod\n\n#print(DP)\nprint(DP[2*n][ao])\n"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\ns = input()\nn = len(s)\nR = s.count(\"0\") * 2 + s.count(\"1\")\nB = 2*n - R\nrb = [[R, B] for _ in range(2*n)]\nif s[0] == \"0\":\n\trb[0] = [2, 0]\nelif s[0] == \"1\":\n\trb[0] = [1, 1]\nelse:\n\trb[0] = [0, 2]\nfor i in range(1, n):\n\tif s[i] == \"0\":\n\t\trb[i] = [rb[i-1][0] + 2, rb[i-1][1] + 0]\n\telif s[i] == \"1\":\n\t\trb[i] = [rb[i-1][0] + 1, rb[i-1][1] + 1]\n\telse:\n\t\trb[i] = [rb[i-1][0] + 0, rb[i-1][1] + 2]\n\ndp = [[0 for _ in range(R+1)] for _ in range(2*n)]\nif rb[0][0] >= 1:\n\tdp[0][1] = 1\nif rb[0][1] >= 1:\n\tdp[0][0] = 1\nfor i in range(1, 2*n):\n\tfor j in range(R+1):\n\t\tif j > 0 and rb[i][0] >= j:\n\t\t\tdp[i][j] += dp[i-1][j-1]\n\t\t\tdp[i][j] %= MOD\n\t\tif j != i+1 and rb[i][1] >= i+1 - j:\n\t\t\tdp[i][j] += dp[i-1][j]\n\t\t\tdp[i][j] %= MOD\n\nprint(dp[2*n-1][R])"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nS = list(map(int, list(input())[: -1]))\nmod = 998244353\n\nN = len(S)\nS += [0] * N\ndp = [[0] * (N * 2 + 1) for _ in range(2 * N + 1)]\ndp[0][0] = 1\nfor i in range(2 * N):\n  x = S[i]\n  for j in range(N * 2 + 1):\n    if dp[i][j]:\n      if (j + x) in range(N * 2 + 1):\n        if (j + x) <= i + 1:\n          dp[i + 1][j + x] += dp[i][j]\n          dp[i + 1][j + x] %= mod\n      if (j + x - 1) in range(N * 2 + 1):\n        dp[i + 1][j + x - 1] += dp[i][j]\n        dp[i + 1][j + x - 1] %= mod\nprint(dp[-1][0])"
  },
  {
    "language": "Python",
    "code": "S=input()\nN=len(S)\nmod=998244353\nL=[0]*(2*N)\nL[0]=int(S[0])\nfor i in range(1,N):\n    L[i]=L[i-1]+int(S[i])\nfor i in range(N,2*N):\n    L[i]=L[i-1]\ndp=[[0]*(2*N+1) for i in range(2*N+1)]\ndp[0][0]=1\nfor n in range(1,2*N+1):\n    for k in range(min(n,L[n-1])+1):\n        if n-k>2*n-L[n-1]:\n            continue\n        dp[n][k]+=dp[n-1][k]\n        dp[n][k]%=mod\n        if k>=1:\n            dp[n][k]+=dp[n-1][k-1]\n            dp[n][k] %= mod\nans=dp[2*N][L[-1]]\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import accumulate\nimport sys\ninput = sys.stdin.readline\n\nmod = 998244353\nS = list(map(int, input().rstrip()))\nN = len(S)\nfront = [0] * N\nback = [0] * N\ncum = list(accumulate(S))\nfor i in range(N-1):\n    front[i+1] = max(front[i], i + 1 - cum[i])\n    back[i+1] = max(back[i], cum[i] - (i + 1))\ncnt = cum[-1]\ndp = [1] * (2 * N - cnt + 1)\nfor i in range(N - 1, -1, -1):\n    for c in range(S[i]):\n        f = front[i]\n        b = 2 * N - cum[-1]\n        for j in range(N):\n            if back[j] == cnt:\n                b = 2 * j - cum[j-1]\n                break\n        for j in range(b - 1, f - 1, -1):\n            dp[j] = (dp[j] + dp[j+1]) % mod\n        for j in range(f - 1, -1, -1):\n            dp[j] = dp[j+1]\n        cnt -= 1\nprint(dp[0])\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let s = read::<String>()\n        .chars()\n        .map(|x| x.to_digit(10).unwrap() as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![vec![Modulo(0); n + 1]; n + 1];\n    dp[0][0] = Modulo(1);\n    let mut b_count = 0;\n    for i in 0..n {\n        b_count += s[i];\n        let r_count = (i + 1) * 2 - b_count;\n        for bi in 0..i + 1 {\n            if i + 1 - bi <= r_count {\n                dp[i + 1][bi] += dp[i][bi];\n            }\n            if bi + 1 <= b_count {\n                dp[i + 1][bi + 1] += dp[i][bi];\n            }\n        }\n    }\n\n    let big_int = 998244353;\n    let fact = ModFactorial::new(n as i64, big_int);\n    let fact = fact.fact;\n    let inv_fact = (0..fact.len())\n        .map(|x| mod_inverse(fact[x as usize], big_int))\n        .collect::<Vec<_>>();\n    let binom = ModBinominal::new(n as i64, big_int, &fact, &inv_fact).bin;\n\n    let mut ans = Modulo(0);\n    for bi in 0..b_count + 1 {\n        ans += dp[n][bi] * Modulo(binom[b_count - bi]);\n    }\n    println!(\"{}\", ans);\n}\n\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut d = a;\n    if b == 0 {\n        *x = 1;\n        *y = 0;\n    } else {\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * (*x);\n    }\n    return d;\n}\n\nfn mod_inverse(a: i64, m: i64) -> i64 {\n    let mut x: i64 = 0;\n    let mut y: i64 = 0;\n    extgcd(a, m, &mut x, &mut y);\n    (m + x % m) % m\n}\n\nstruct ModFactorial {\n    fact: Vec<i64>,\n}\n\n// returns n! under mod m\nimpl ModFactorial {\n    fn new(n: i64, m: i64) -> ModFactorial {\n        let mut fact = vec![1; n as usize + 1];\n        for i in 2..fact.len() {\n            fact[i] = (i as i64 * fact[i - 1]) % m;\n        }\n        ModFactorial { fact: fact }\n    }\n}\n\n// returns bin[i] = nCi under mod m\nstruct ModBinominal {\n    bin: Vec<i64>,\n}\n\nimpl ModBinominal {\n    fn new(n: i64, m: i64, fact: &Vec<i64>, inv_fact: &Vec<i64>) -> ModBinominal {\n        let mut bin = vec![1; n as usize + 1];\n        if n == 0 {\n            return ModBinominal { bin: bin };\n        }\n        for i in 1..n + 1 {\n            let a2 = inv_fact[i as usize] % m;\n            let a3 = inv_fact[(n - i) as usize] % m;\n            bin[i as usize] = fact[n as usize] * ((a2 * a3) % m) % m;\n        }\n        ModBinominal { bin: bin }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let s = read::<String>()\n        .chars()\n        .map(|x| x.to_digit(10).unwrap() as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![vec![Modulo(0); n + 1]; n + 1];\n    dp[0][0] = Modulo(1);\n    let mut b_count = 0;\n    for i in 0..n {\n        b_count += s[i];\n        let r_count = (i + 1) * 2 - b_count;\n        for bi in 0..i + 1 {\n            if i + 1 - bi <= r_count {\n                dp[i + 1][bi] += dp[i][bi];\n            }\n            if bi + 1 <= b_count {\n                dp[i + 1][bi + 1] += dp[i][bi];\n            }\n        }\n    }\n\n    let big_int = 998244353;\n    let fact = ModFactorial::new(n as i64, big_int);\n    let fact = fact.fact;\n    let inv_fact = (0..fact.len())\n        .map(|x| mod_inverse(fact[x as usize], big_int))\n        .collect::<Vec<_>>();\n    let binom = ModBinominal::new(n as i64, big_int, &fact, &inv_fact).bin;\n\n    let mut ans = Modulo(0);\n    for bi in 0..min(b_count, n) + 1 {\n        let idx = b_count - bi;\n        if n < idx {\n            continue;\n        }\n        ans += dp[n][bi] * Modulo(binom[idx]);\n    }\n    println!(\"{}\", ans);\n}\n\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut d = a;\n    if b == 0 {\n        *x = 1;\n        *y = 0;\n    } else {\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * (*x);\n    }\n    return d;\n}\n\nfn mod_inverse(a: i64, m: i64) -> i64 {\n    let mut x: i64 = 0;\n    let mut y: i64 = 0;\n    extgcd(a, m, &mut x, &mut y);\n    (m + x % m) % m\n}\n\nstruct ModFactorial {\n    fact: Vec<i64>,\n}\n\n// returns n! under mod m\nimpl ModFactorial {\n    fn new(n: i64, m: i64) -> ModFactorial {\n        let mut fact = vec![1; n as usize + 1];\n        for i in 2..fact.len() {\n            fact[i] = (i as i64 * fact[i - 1]) % m;\n        }\n        ModFactorial { fact: fact }\n    }\n}\n\n// returns bin[i] = nCi under mod m\nstruct ModBinominal {\n    bin: Vec<i64>,\n}\n\nimpl ModBinominal {\n    fn new(n: i64, m: i64, fact: &Vec<i64>, inv_fact: &Vec<i64>) -> ModBinominal {\n        let mut bin = vec![1; n as usize + 1];\n        if n == 0 {\n            return ModBinominal { bin: bin };\n        }\n        for i in 1..n + 1 {\n            let a2 = inv_fact[i as usize] % m;\n            let a3 = inv_fact[(n - i) as usize] % m;\n            bin[i as usize] = fact[n as usize] * ((a2 * a3) % m) % m;\n        }\n        ModBinominal { bin: bin }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n"
  },
  {
    "language": "Rust",
    "code": "// SNIPPET read\npub trait Readable {\n    type Output;\n    const WORD_COUNT: usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $t:ty, $words_count:expr, |$words:ident| $read_words:expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            const WORD_COUNT: usize = $words_count;\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\npub struct Bytes();\nimpl Readable for Bytes {\n    type Output = Vec<u8>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<u8>, String> {\n        Ok(words[0].bytes().collect())\n    }\n}\nimpl Readable for i8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i8, String> {\n        use std::str::FromStr;\n        i8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i8\", words[0])\n        })\n    }\n}\nimpl Readable for u8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u8, String> {\n        use std::str::FromStr;\n        u8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u8\", words[0])\n        })\n    }\n}\nimpl Readable for i16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i16, String> {\n        use std::str::FromStr;\n        i16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i16\", words[0])\n        })\n    }\n}\nimpl Readable for u16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u16, String> {\n        use std::str::FromStr;\n        u16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u16\", words[0])\n        })\n    }\n}\nimpl Readable for i32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i32, String> {\n        use std::str::FromStr;\n        i32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i32\", words[0])\n        })\n    }\n}\nimpl Readable for u32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u32, String> {\n        use std::str::FromStr;\n        u32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u32\", words[0])\n        })\n    }\n}\nimpl Readable for i64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i64, String> {\n        use std::str::FromStr;\n        i64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u64, String> {\n        use std::str::FromStr;\n        u64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for i128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i128, String> {\n        use std::str::FromStr;\n        i128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u128, String> {\n        use std::str::FromStr;\n        u128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for isize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<isize, String> {\n        use std::str::FromStr;\n        <isize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as isize\", words[0])\n        })\n    }\n}\nimpl Readable for usize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<usize, String> {\n        use std::str::FromStr;\n        <usize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as usize\", words[0])\n        })\n    }\n}\nimpl Readable for f32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f32, String> {\n        use std::str::FromStr;\n        f32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f32\", words[0])\n        })\n    }\n}\nimpl Readable for f64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f64, String> {\n        use std::str::FromStr;\n        f64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f64\", words[0])\n        })\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u8_;\nimpl Readable for u8_ {\n    type Output = u8;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u8::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u16_;\nimpl Readable for u16_ {\n    type Output = u16;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u16::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u32_;\nimpl Readable for u32_ {\n    type Output = u32;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u32::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u64_;\nimpl Readable for u64_ {\n    type Output = u64;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u64::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct usize_;\nimpl Readable for usize_ {\n    type Output = usize;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        <usize>::read_words(words).map(|n| n-1)\n    }\n}\nimpl<T1: Readable, T2: Readable> Readable for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let val2 = T2::read_words(&words[start..])?;\n        Ok((val1, val2))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable> Readable for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let val3 = T3::read_words(&words[start..])?;\n        Ok((val1, val2, val3))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable> Readable for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let val4 = T4::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable> Readable for (T1, T2, T3, T4, T5) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let val5 = T5::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable, T6: Readable> Readable for (T1, T2, T3, T4, T5, T6) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output, T6::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT + T6::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let count5 = T5::WORD_COUNT;\n        let val5 = T5::read_words(&words[start .. start+count5])?;\n        start += count5;\n        let val6 = T6::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5, val6))\n    }\n}\nimpl<T: Readable> Readable for [T; 2] {\n    type Output = [T::Output; 2];\n    const WORD_COUNT: usize = T::WORD_COUNT * 2;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        Ok([val1, val2])\n    }\n}\nimpl<T: Readable> Readable for [T; 3] {\n    type Output = [T::Output; 3];\n    const WORD_COUNT: usize = T::WORD_COUNT * 3;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        Ok([val1, val2, val3])\n    }\n}\nimpl<T: Readable> Readable for [T; 4] {\n    type Output = [T::Output; 4];\n    const WORD_COUNT: usize = T::WORD_COUNT * 4;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        Ok([val1, val2, val3, val4])\n    }\n}\nimpl<T: Readable> Readable for [T; 5] {\n    type Output = [T::Output; 5];\n    const WORD_COUNT: usize = T::WORD_COUNT * 5;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        Ok([val1, val2, val3, val4, val5])\n    }\n}\nimpl<T: Readable> Readable for [T; 6] {\n    type Output = [T::Output; 6];\n    const WORD_COUNT: usize = T::WORD_COUNT * 6;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        let val6 = T::read_words(&words[T::WORD_COUNT*5 .. T::WORD_COUNT*6])?;\n        Ok([val1, val2, val3, val4, val5, val6])\n    }\n}\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    line.trim_end_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::WORD_COUNT {\n            return Err(format!(\"line `{}` has {} words, expected {}\",\n                               line, words.len(), T::WORD_COUNT));\n        }\n        T::read_words(&words)\n    }\n}\npub fn read_words_into_vec<T: Readable>(words: &[&str], line: &str) -> Result<Vec<T::Output>, String> {\n    let n = T::WORD_COUNT;\n    assert_eq!(words.len() % n, 0);\n    let mut result = Vec::new();\n    for chunk in words.chunks(n) {\n        match T::read_words(chunk) {\n            Ok(v) => result.push(v),\n            Err(msg) => {\n                let fragment_msg = if n == 1 {\n                    format!(\"word {}\", result.len())\n                } else {\n                    let l = result.len();\n                    format!(\"words {}-{}\", n*l + 1, (n+1) * l)\n                };\n                return Err(format!(\n                    \"{} of line `{}`: {}\", fragment_msg, line, msg\n                ));\n            }\n        }\n    }\n    Ok(result)\n}\npub fn split_into_words_for_collection<T: Readable>(\n    line: &str, prefix_words_count: usize\n) -> Result<Vec<&str>, String> {\n    let n = T::WORD_COUNT;\n    let words = split_into_words(line);\n    if words.len() < prefix_words_count {\n        return Err(\n            format!(\"line `{}` has {} words, expected at least {}\",\n                    line, words.len(), prefix_words_count)\n        );\n    }\n    if (words.len() - prefix_words_count) % T::WORD_COUNT != 0 {\n        return Err(\n            format!(\"line `{}` has {} words, expected {} + {}\",\n                    line, words.len(), prefix_words_count, n)\n        );\n    }\n    Ok(words)\n}\n#[macro_export]\nmacro_rules! readable_collection {\n    ($u:ident => $collection_in:ty, $collection_out:ty) => {\n        readable_collection!($u: => $collection_in, $collection_out);\n    };\n    ($u:ident : $( $bound:path ),* => $collection_in:ty, $collection_out:ty) => {\n        impl<$u: Readable> ReadableFromLine for $collection_in\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = $collection_out;\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let words = split_into_words_for_collection::<$u>(line, 0)?;\n                Ok(read_words_into_vec::<$u>(&words, line)?.into_iter().collect())\n            }\n        }\n        impl<T1: Readable, $u: Readable> ReadableFromLine for (T1, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = T1::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let val1 = T1::read_words(&words[..prefix_len])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, $u: Readable> ReadableFromLine for (T1, T2, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, T4, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, T4::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3, T4)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                start += count3;\n                let count4 = T4::WORD_COUNT;\n                let val4 = T4::read_words(&words[start .. start+count4])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, val4, rest.into_iter().collect()))\n            }\n        }\n    };\n}\nreadable_collection!(U => Vec<U>, Vec<U::Output>);\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules! read {\n    () => {\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n    };\n    ( $pat:pat = $t:ty $(,)* ) => {\n        let $pat = read::<$t>();\n    };\n    ( ! $(,)* ) => {\n        let _ = read::<()>();\n    };\n    ( $pat:pat = $t:ty, $( $rest:tt )+ ) => {\n        read_inner!($pat = $t; $($rest)+);\n    };\n    ( !, $( $rest:tt )+ ) => {\n        read_inner!(_ = (); $($rest)+);\n    };\n}\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! read_inner {\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; !, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ;);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; ! ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ;);\n    };\n    ( $( $pat:pat = $t:ty ),+ ; ) => {\n        let ($($pat),+) = read::<($($t),+)>();\n    };\n}\npub trait ReadableFromChunk {\n    type Output;\n    fn lines_count() -> usize;\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String>;\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine> ReadableFromChunk for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    fn lines_count() -> usize { 2 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        Ok((out1, out2))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine> ReadableFromChunk for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    fn lines_count() -> usize { 3 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        Ok((out1, out2, out3))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine, T4: ReadableFromLine> ReadableFromChunk for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    fn lines_count() -> usize { 4 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        let out4 = T4::read_line(&lines[3])?;\n        Ok((out1, out2, out3, out4))\n    }\n}\npub fn read_chunk<T: ReadableFromChunk>() -> T::Output {\n    let stdin = std::io::stdin();\n    let mut handle = stdin.lock();\n    read_chunk_from_handle::<T>(&mut handle).unwrap()\n}\nfn read_chunk_from_handle<T: ReadableFromChunk>(handle: &mut std::io::StdinLock) -> Option<T::Output> {\n    use std::io::BufRead;\n    let mut lines = vec![String::new(); T::lines_count()];\n    let mut first = true;\n    for line in &mut lines {\n        if handle.read_line(line).unwrap() == 0 && first {\n            return None;\n        }\n        first = false;\n    }\n    Some(T::read_chunk(&lines).unwrap())\n}\n#[macro_export]\nmacro_rules! read_chunk {\n    ( $( $pat:pat = $t:ty ),+ ) => {\n        let ($($pat),+) = read_chunk::<($($t),+)>();\n    };\n}\nstatic mut STDIN: Option<std::io::Stdin> = None;\npub struct ReadLines<T: ReadableFromLine> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromLine> Iterator for ReadLines<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        use std::io::BufRead;\n        let mut line = String::new();\n        if self.lock.read_line(&mut line).unwrap() > 0 {\n            Some(T::read_line(&line).unwrap())\n        } else {\n            None\n        }\n    }\n}\npub fn read_lines<T: ReadableFromLine>() -> ReadLines<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadLines {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub struct ReadChunks<T: ReadableFromChunk> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromChunk> Iterator for ReadChunks<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        read_chunk_from_handle::<T>(&mut self.lock)\n    }\n}\npub fn read_chunks<T: ReadableFromChunk>() -> ReadChunks<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadChunks {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\n// SNIPPET utils\n#[macro_export]\nmacro_rules! echo {\n    () => {\n        println!()\n    };\n    ($e: expr $(,)?) => {\n        println!(\"{}\", $e)\n    };\n    ($e: expr, $($es: expr),+ $(,)?) => {\n        {\n            use std::io::Write;\n            let stdout = std::io::stdout();\n            let mut handle = stdout.lock();\n            write!(handle, \"{}\", $e).unwrap();\n            $(\n                write!(handle, \" {}\", $es).unwrap();\n            )+\n            writeln!(handle).unwrap();\n        }\n    };\n}\npub fn yn(result: bool) {\n    if result {\n        println!(\"Yes\");\n    } else {\n        println!(\"No\");\n    }\n}\n#[allow(non_snake_case)]\npub fn YN(result: bool) {\n    if result {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\npub fn exit(msg: impl std::fmt::Display) -> ! {\n    println!(\"{}\", msg);\n    std::process::exit(0)\n}\n#[macro_export]\n#[cfg(local)]\nmacro_rules! dbg {\n    () => {\n        {\n            use std::io::{self, Write};\n            writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n        }\n    };\n    ($e: expr) => {\n        {\n            use std::io::{self, Write};\n            let result = $e;\n            writeln!(io::stderr(), \"{}: {} = {:?}\",\n                     line!(), stringify!($e), result)\n                .unwrap();\n            result\n        }\n    }\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    () => {};\n    ($e: expr) => {\n        { $e }\n    }\n}\n\n// SNIPPET op_macros\nmacro_rules! forward_ref_unop {\n    (impl $op:ident, $method:ident for $t:ty) => {\n        impl std::ops::$op for &$t {\n            type Output = <$t as std::ops::$op>::Output;\n            fn $method(self) -> <$t as std::ops::$op>::Output {\n                std::ops::$op::$method(*self)\n            }\n        }\n    }\n}\nmacro_rules! forward_ref_binop {\n    (impl $op:ident, $method:ident for $t:ty, $u:ty) => {\n        impl<'a> std::ops::$op<$u> for &'a $t {\n            type Output = <$t as std::ops::$op<$u>>::Output;\n            fn $method(self, other: $u) -> <$t as std::ops::$op<$u>>::Output {\n                std::ops::$op::$method(*self, other)\n            }\n        }\n        impl std::ops::$op<&$u> for $t {\n            type Output = <$t as std::ops::$op<$u>>::Output;\n            fn $method(self, other: &$u) -> <$t as std::ops::$op<$u>>::Output {\n                std::ops::$op::$method(self, *other)\n            }\n        }\n        impl std::ops::$op<&$u> for &$t {\n            type Output = <$t as std::ops::$op<$u>>::Output;\n            fn $method(self, other: &$u) -> <$t as std::ops::$op<$u>>::Output {\n                std::ops::$op::$method(*self, *other)\n            }\n        }\n    }\n}\nmacro_rules! forward_ref_op_assign {\n    (impl $op:ident, $method:ident for $t:ty, $u:ty) => {\n        impl std::ops::$op<&$u> for $t {\n            fn $method(&mut self, other: &$u) {\n                std::ops::$op::$method(self, *other);\n            }\n        }\n    }\n}\n\n// SNIPPET modp\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct ModP {\n    base: ModPBase\n}\nimpl ModP {\n    #[cfg(local)]\n    fn assert_mod_already_set() {\n        assert!(unsafe { MODULUS } != 0, \"Call ModP::set_mod before using ModP.\");\n    }\n    #[cfg(not(local))]\n    fn assert_mod_already_set() {}\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        ModP::assert_mod_already_set();\n        ModP { base: n % unsafe { MODULUS } }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP::assert_mod_already_set();\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 { ModP::new(1) } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n    pub fn fact_cache() -> FactCache {\n        FactCache {\n            table: vec![ModP::new(1)]\n        }\n    }\n    pub fn inv_cache() -> InvCache {\n        InvCache {\n            table: vec![ModP::new(0), ModP::new(1)]\n        }\n    }\n    pub fn pow_cache(base: ModPBase) -> PowCache {\n        PowCache {\n            base: base,\n            table: vec![ModP::new(1)]\n        }\n    }\n    pub fn combinatorics_cache() -> CombinatoricsCache {\n        CombinatoricsCache {\n            facts: ModP::fact_cache(),\n            invs: ModP::inv_cache(),\n            finvs: vec![ModP::new(1)],\n        }\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nmacro_rules! impl_from_signed_for_modp {\n    ( $($t: ty)* ) => { $(\n        impl From<$t> for ModP {\n            fn from(num: $t) -> ModP {\n                unsafe { ModP::new_unchecked((num as i64).rem_euclid(MODULUS as i64) as u64) }\n            }\n        }\n    )* }\n}\nimpl_from_signed_for_modp!(i8 i16 i32 i64 isize);\nmacro_rules! impl_from_unsigned_for_modp {\n    ( $($t: ty)* ) => { $(\n        impl From<$t> for ModP {\n            fn from(num: $t) -> ModP {\n                unsafe { ModP::new_unchecked((num as u64).rem_euclid(MODULUS)) }\n            }\n        }\n    )* }\n}\nimpl_from_unsigned_for_modp!(u8 u16 u32 u64 usize);\nimpl From<i128> for ModP {\n    fn from(num: i128) -> ModP {\n        unsafe { ModP::new_unchecked(num.rem_euclid(MODULUS as i128) as u64) }\n    }\n}\nimpl From<u128> for ModP {\n    fn from(num: u128) -> ModP {\n        unsafe { ModP::new_unchecked(num.rem_euclid(MODULUS as u128) as u64) }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP { base: (self.base() + rhs.base() % m) % m }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP { base: self.base() * (rhs.base() % m) % m }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nforward_ref_binop!(impl Add, add for ModP, ModP);\nforward_ref_binop!(impl Add, add for ModP, ModPBase);\nforward_ref_binop!(impl Add, add for ModPBase, ModP);\nforward_ref_op_assign!(impl AddAssign, add_assign for ModP, ModP);\nforward_ref_op_assign!(impl AddAssign, add_assign for ModP, ModPBase);\nforward_ref_unop!(impl Neg, neg for ModP);\nforward_ref_binop!(impl Sub, sub for ModP, ModP);\nforward_ref_binop!(impl Sub, sub for ModP, ModPBase);\nforward_ref_binop!(impl Sub, sub for ModPBase, ModP);\nforward_ref_op_assign!(impl SubAssign, sub_assign for ModP, ModP);\nforward_ref_op_assign!(impl SubAssign, sub_assign for ModP, ModPBase);\nforward_ref_binop!(impl Mul, mul for ModP, ModP);\nforward_ref_binop!(impl Mul, mul for ModP, ModPBase);\nforward_ref_binop!(impl Mul, mul for ModPBase, ModP);\nforward_ref_op_assign!(impl MulAssign, mul_assign for ModP, ModP);\nforward_ref_op_assign!(impl MulAssign, mul_assign for ModP, ModPBase);\nforward_ref_binop!(impl Div, div for ModP, ModP);\nforward_ref_binop!(impl Div, div for ModP, ModPBase);\nforward_ref_binop!(impl Div, div for ModPBase, ModP);\nforward_ref_op_assign!(impl DivAssign, div_assign for ModP, ModP);\nforward_ref_op_assign!(impl DivAssign, div_assign for ModP, ModPBase);\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item=ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item=&'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item=ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item=&'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\npub struct FactCache {\n    table: Vec<ModP>\n}\nimpl FactCache {\n    pub fn get(&mut self, n: ModPBase) -> ModP {\n        self.extend(n as usize);\n        self.table[n as usize]\n    }\n    fn extend(&mut self, max: usize) {\n        for i in self.table.len()..max+1 {\n            let prev = self.table[i-1];\n            self.table.push(prev * i as ModPBase);\n        }\n    }\n}\npub struct InvCache {\n    table: Vec<ModP>\n}\nimpl InvCache {\n    pub fn get(&mut self, n: ModPBase) -> ModP {\n        assert!(n > 0);\n        self.extend(n as usize);\n        self.table[n as usize]\n    }\n    fn extend(&mut self, max: usize) {\n        for i in self.table.len()..max+1 {\n            let m = unsafe { MODULUS };\n            let prev = self.table[m as usize % i];\n            self.table.push(m / i as ModPBase * (-prev));\n        }\n    }\n}\npub struct PowCache {\n    base: ModPBase,\n    table: Vec<ModP>\n}\nimpl PowCache {\n    pub fn get(&mut self, n: ModPBase) -> ModP {\n        self.extend(n as usize);\n        self.table[n as usize]\n    }\n    fn extend(&mut self, max: usize) {\n        for i in self.table.len()..max+1 {\n            let prev = self.table[i-1];\n            self.table.push(prev * self.base);\n        }\n    }\n}\npub struct CombinatoricsCache {\n    facts: FactCache,\n    invs: InvCache,\n    finvs: Vec<ModP>,\n}\nimpl CombinatoricsCache {\n    pub fn choose(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        if n < m {\n            return ModP::new(0);\n        }\n        self.extend_finvs(std::cmp::max(m, n-m) as usize);\n        self.fact(n) * self.finvs[m as usize] * self.finvs[(n-m) as usize]\n    }\n    pub fn permutation(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        if n < m {\n            return ModP::new(0);\n        }\n        self.extend_finvs((n-m) as usize);\n        self.fact(n) * self.finvs[(n-m) as usize]\n    }\n    pub fn multichoose(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        if m == 0 {\n            ModP::new(1)\n        } else {\n            self.choose(n+m-1, m)\n        }\n    }\n    pub fn c(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.choose(n, m)\n    }\n    pub fn p(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.permutation(n, m)\n    }\n    pub fn h(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.multichoose(n, m)\n    }\n    pub fn fact(&mut self, n: ModPBase) -> ModP {\n        self.facts.get(n)\n    }\n    pub fn inv(&mut self, n: ModPBase) -> ModP {\n        self.invs.get(n)\n    }\n    fn extend_finvs(&mut self, max: usize) {\n        for i in self.finvs.len()..max+1 {\n            let prev = self.finvs[i-1];\n            self.finvs.push(prev * self.invs.get(i as ModPBase))\n        }\n    }\n}\n\n// END SNIPPETS\n// Here is the documentation: https://yoshrc.github.io/rust-atcoder-snippets/atcoder_snippets/index.html\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(s = String);\n    let mut reds = Vec::new();\n    let mut blues = Vec::new();\n    for (i, c) in s.chars().enumerate() {\n        if c == '0' {\n            reds.push(i+1);\n            reds.push(i+1);\n        } else if c == '1' {\n            reds.push(i+1);\n            blues.push(i+1);\n        } else {\n            blues.push(i+1);\n            blues.push(i+1);\n        }\n    }\n    let mut dp = vec![vec![ModP::new(0); reds.len()+1]; 2*s.len()+1];\n    dp[0][0] += 1;\n    for i in 1..=2*s.len() {\n        for red in 0..=reds.len() {\n            if red > i {\n                continue;\n            }\n\n            let blue = i - red;\n            if red > 0 && reds[red-1] <= i {\n                let val = dp[i-1][red-1];\n                dp[i][red] += val;\n            }\n            if blue > 0 && blue <= blues.len() && blues[blue-1] <= i {\n                let val = dp[i-1][red];\n                dp[i][red] += val;\n            }\n        }\n    }\n    echo!(dp.last().unwrap().last().unwrap());\n}\n"
  },
  {
    "language": "Rust",
    "code": "use mod_int::ModInt;\nuse std::cmp;\n\nconst MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let s = sc\n        .chars()\n        .into_iter()\n        .map(|c| c as usize - '0' as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n    let mut dp = vec![ModInt::new(0); s.len() * 2 + 1];\n    dp[s[0]] = ModInt::new(1);\n    for i in 1..(2 * n + 1) {\n        let mut next = vec![ModInt::new(0); dp.len()];\n        let total = cmp::min(2 * i, n * 2) - (i - 1);\n        let add = if i < n { s[i] } else { 0 };\n        for red in 0..dp.len() {\n            if total < red {\n                continue;\n            }\n            let blue = total - red;\n            if red > 0 {\n                next[red + add - 1] += dp[red];\n            }\n            if blue > 0 {\n                next[red + add] += dp[red];\n            }\n        }\n        dp = next;\n    }\n\n    println!(\"{}\", dp[0].0);\n}\n\npub mod mod_int {\n    use super::MOD;\n    use std::fmt::Debug;\n    use std::ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct ModInt<T: Copy + Clone + Debug>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn new(value: Num) -> Self {\n            ModInt(value)\n        }\n\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt::new(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\nfn main() {\n    let s: Vec<char> = read::<String>().chars().collect();\n    let mut red: Vec<usize> = Vec::new();\n    let mut blue: Vec<usize> = Vec::new();\n    for i in 0..s.len() {\n        match s[i] {\n            '0' => {\n                red.push(i);\n                red.push(i);\n            },\n            '1' => {\n                red.push(i);\n                blue.push(i);\n            },\n            _ => {\n                blue.push(i);\n                blue.push(i);\n            }\n        }\n    }\n    \n    let mo: i64 = 998244353;\n    let mut dp: Vec<Vec<i64>> = vec![vec![0; 2*s.len()+1]; 2*s.len()+1];\n    dp[0][0] = 1;\n    for i in 0..red.len()+1 {\n        for j in 0..blue.len()+1 {\n            dp[i][j] %= mo;\n            let m = i + j;\n            if i < red.len() && red[i] <= m {\n                dp[i+1][j] += dp[i][j];\n            }\n            if j < blue.len() && blue[j] <= m {\n                dp[i][j+1] += dp[i][j];\n            }\n        }\n    }\n    println!(\"{}\", dp[red.len()][blue.len()] % mo);\n}\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.unwrap() as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().unwrap()\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let s = read::<String>()\n        .chars()\n        .map(|x| x.to_digit(10).unwrap() as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![vec![Modulo(0); n + 1]; n + 1];\n    dp[0][0] = Modulo(1);\n    let mut b_count = 0;\n    for i in 0..n {\n        b_count += s[i];\n        let r_count = (i + 1) * 2 - b_count;\n        for bi in 0..i + 1 {\n            if i + 1 - bi <= r_count {\n                dp[i + 1][bi] += dp[i][bi];\n            }\n            if bi + 1 <= b_count {\n                dp[i + 1][bi + 1] += dp[i][bi];\n            }\n        }\n    }\n\n    let big_int = 998244353;\n    let fact = ModFactorial::new(n as i64, big_int);\n    let fact = fact.fact;\n    let inv_fact = (0..fact.len())\n        .map(|x| mod_inverse(fact[x as usize], big_int))\n        .collect::<Vec<_>>();\n    let binom = ModBinominal::new(n as i64, big_int, &fact, &inv_fact).bin;\n\n    let mut ans = Modulo(0);\n    for bi in 0..min(b_count, 2 * n - b_count) + 1 {\n        let idx = b_count - bi;\n        if n < idx {\n            continue;\n        }\n        ans += dp[n][bi] * Modulo(binom[idx]);\n    }\n    println!(\"{}\", ans);\n}\n\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut d = a;\n    if b == 0 {\n        *x = 1;\n        *y = 0;\n    } else {\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * (*x);\n    }\n    return d;\n}\n\nfn mod_inverse(a: i64, m: i64) -> i64 {\n    let mut x: i64 = 0;\n    let mut y: i64 = 0;\n    extgcd(a, m, &mut x, &mut y);\n    (m + x % m) % m\n}\n\nstruct ModFactorial {\n    fact: Vec<i64>,\n}\n\n// returns n! under mod m\nimpl ModFactorial {\n    fn new(n: i64, m: i64) -> ModFactorial {\n        let mut fact = vec![1; n as usize + 1];\n        for i in 2..fact.len() {\n            fact[i] = (i as i64 * fact[i - 1]) % m;\n        }\n        ModFactorial { fact: fact }\n    }\n}\n\n// returns bin[i] = nCi under mod m\nstruct ModBinominal {\n    bin: Vec<i64>,\n}\n\nimpl ModBinominal {\n    fn new(n: i64, m: i64, fact: &Vec<i64>, inv_fact: &Vec<i64>) -> ModBinominal {\n        let mut bin = vec![1; n as usize + 1];\n        if n == 0 {\n            return ModBinominal { bin: bin };\n        }\n        for i in 1..n + 1 {\n            let a2 = inv_fact[i as usize] % m;\n            let a3 = inv_fact[(n - i) as usize] % m;\n            bin[i as usize] = fact[n as usize] * ((a2 * a3) % m) % m;\n        }\n        ModBinominal { bin: bin }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(unused_variables)]\n#![allow(dead_code)]\n\nfn main() {\n    let S: Vec<char> = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        line.trim().chars().collect()\n    };\n\n    const MOD: i64 = 998244353;\n    fn modinv(x: i64) -> i64 {\n        let mut a = x;\n        let mut b = MOD;\n        let mut u = 1;\n        let mut v = 0;\n        while b != 0 {\n            let t = a / b;\n            a -= t * b;\n            std::mem::swap(&mut a, &mut b);\n            u -= t * v;\n            std::mem::swap(&mut u, &mut v);\n        }\n        u %= MOD;\n        if u >= 0 { u } else { u + MOD }\n    }\n    #[derive(Copy, Clone)]\n    struct ModInt {\n        x: i64\n    }\n    impl ModInt {\n        fn new(x: i64) -> ModInt {\n            let y = if x >= 0 {\n                x % MOD\n            } else {\n                (x + (1 - x / MOD) * MOD) % MOD\n            };\n            ModInt {x: y}\n        }\n    }\n    impl std::ops::Add<ModInt> for ModInt {\n        type Output = ModInt;\n        fn add(self, other: ModInt) -> ModInt {\n            ModInt::new(self.x + other.x)\n        }\n    }\n    impl std::ops::Add<i64> for ModInt {\n        type Output = ModInt;\n        fn add(self, other: i64) -> ModInt {\n            ModInt::new(self.x + other)\n        }\n    }\n    impl std::ops::Add<usize> for ModInt {\n        type Output = ModInt;\n        fn add(self, other: usize) -> ModInt {\n            ModInt::new(self.x + (other as i64))\n        }\n    }\n    impl std::ops::Sub<ModInt> for ModInt {\n        type Output = ModInt;\n        fn sub(self, other: ModInt) -> ModInt {\n            ModInt::new(self.x - other.x)\n        }\n    }\n    impl std::ops::Sub<i64> for ModInt {\n        type Output = ModInt;\n        fn sub(self, other: i64) -> ModInt {\n            ModInt::new(self.x - other)\n        }\n    }\n    impl std::ops::Sub<usize> for ModInt {\n        type Output = ModInt;\n        fn sub(self, other: usize) -> ModInt {\n            ModInt::new(self.x - (other as i64))\n        }\n    }\n    impl std::ops::Mul<ModInt> for ModInt {\n        type Output = ModInt;\n        fn mul(self, other: ModInt) -> ModInt {\n            ModInt::new(self.x * other.x)\n        }\n    }\n    impl std::ops::Mul<i64> for ModInt {\n        type Output = ModInt;\n        fn mul(self, other: i64) -> ModInt {\n            ModInt::new(self.x * other)\n        }\n    }\n    impl std::ops::Mul<usize> for ModInt {\n        type Output = ModInt;\n        fn mul(self, other: usize) -> ModInt {\n            ModInt::new(self.x * (other as i64))\n        }\n    }\n    impl std::ops::Div<ModInt> for ModInt {\n        type Output = ModInt;\n        fn div(self, other: ModInt) -> ModInt {\n            ModInt::new(self.x * modinv(other.x as i64))\n        }\n    }\n    impl std::ops::Div<i64> for ModInt {\n        type Output = ModInt;\n        fn div(self, other: i64) -> ModInt {\n            ModInt::new(self.x * modinv(other))\n        }\n    }\n    impl std::ops::Div<usize> for ModInt {\n        type Output = ModInt;\n        fn div(self, other: usize) -> ModInt {\n            ModInt::new(self.x * modinv(other as i64))\n        }\n    }\n    impl std::fmt::Display for ModInt {\n        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            write!(f, \"{}\", self.x)\n        }\n    }\n\n    let N = S.len();\n    let mut dp = vec![vec![ModInt::new(0); N + 2]; 2 * N + 1];\n    dp[0][0] = ModInt::new(1);\n\n    for i in 1..(N + 1) {\n        let s = S[i - 1].to_digit(10).unwrap() as usize;\n        for j in 0..N {\n            let k = j + s;\n            if k > 0 {\n                dp[i][k - 1] = dp[i][k - 1] + dp[i - 1][j];\n            }\n            if i + 1 > k {\n                dp[i][k] = dp[i][k] + dp[i - 1][j];\n            }\n        }\n    }\n    for i in (N + 1)..(2 * N + 1) {\n        for j in 0..(N + 2) {\n            if j > 0 {\n                dp[i][j - 1] = dp[i][j - 1] + dp[i - 1][j];\n            }\n            if 2 * N - i + 1 > j {\n                dp[i][j] = dp[i][j] + dp[i - 1][j];\n            }\n        }\n    }\n\n    let ans = dp[2 * N][0];\n\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "use mod_int::ModInt;\nconst MOD: usize = 998244353;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    let s: Vec<usize> = sc\n        .read::<String>()\n        .chars()\n        .map(|c| c as usize - '0' as usize)\n        .collect();\n    let n = s.len();\n    let balls = n * 2;\n    let mut dp = vec![ModInt(0); balls + 1];\n    dp[0] = ModInt(1);\n    let mut reachable_red = 0;\n    for i in 0..balls {\n        let new_red = if i < n { s[i] } else { 0 };\n        let new_blue = if i < n { 2 - s[i] } else { 0 };\n        let mut next = vec![ModInt(0); balls + 1];\n        let total = if i < n { 2 * i } else { 2 * n };\n        let reachable_blue = total - reachable_red;\n        for used_red in 0..(reachable_red + 1) {\n            if i >= used_red {\n                let used_blue = i - used_red;\n                if used_blue <= reachable_blue && used_blue + 1 <= reachable_blue + new_blue {\n                    next[used_red] += dp[used_red];\n                }\n            }\n            if used_red + 1 <= reachable_red + new_red {\n                next[used_red + 1] += dp[used_red];\n            }\n        }\n        dp = next;\n        reachable_red += new_red;\n    }\n\n    let r = s[0..n].iter().sum::<usize>();\n    println!(\"{}\", dp[r].0);\n}\n\npub mod mod_int {\n    use super::MOD;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: Num) -> ModInt<Num> {\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nconst MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let s = sc\n        .chars()\n        .into_iter()\n        .map(|c| c as usize - '0' as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![0; 2 * n + 1];\n    dp[s[0]] = 1;\n    for turn in 0..(2 * n) {\n        let mut next = vec![0; 2 * n + 1];\n        let total = 2 * cmp::min(turn + 1, n) - turn;\n        let add = if turn + 1 < n { s[turn + 1] } else { 0 };\n        for red in 0..(total + 1) {\n            let blue = total - red;\n            if red > 0 {\n                next[red + add - 1] += dp[red];\n                next[red + add - 1] %= MOD;\n            }\n            if blue > 0 {\n                next[red + add] += dp[red];\n                next[red + add] %= MOD;\n            }\n        }\n        dp = next;\n    }\n\n    println!(\"{}\", dp[0]);\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new_internal(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 { sum += cur; }\n                cur += cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { self.mul_fast(other.into()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! { s: chars }\n    let n = s.len();\n    let mut dp = vec![vec![ModInt::new(0); 2 * n + 1]; 2 * n + 1];\n    dp[0][0] = ModInt::new(1);\n    for i in 0..n {\n        let (dx, dy) = match s[i] {\n            '0' => (2, 0),\n            '1' => (1, 1),\n            '2' => (0, 2),\n            _ => panic!(),\n        };\n        for j in 0..i + 1 {\n            let k = i - j;\n            dp[j + dx][k + dy] += dp[j][k];\n            dp[j][k] = ModInt::new(0);\n        }\n        for j in 0..min(5, 2 * n + 1) {\n            //eprintln!(\"dp'[{}] = {:?}\", j, &dp[j][0..min(5, n + 1)]);\n        }\n        for j in 0..i + 3 {\n            let k = i + 2 - j;\n            if j > 0 {\n                dp[j - 1][k] += dp[j][k];\n            }\n            if k > 0 {\n                dp[j][k - 1] += dp[j][k];\n            }\n            dp[j][k] = ModInt::new(0);\n        }\n        for j in 0..min(5, 2 * n + 1) {\n           // eprintln!(\"dp[{}] = {:?}\", j, &dp[j][0..min(5, n + 1)]);\n        }\n    }\n    for j in (0..2 * n + 1).rev() {\n        for k in (0..2 * n + 1).rev() {\n            if j > 0 {\n                dp[j - 1][k] += dp[j][k];\n            }\n            if k > 0 {\n                dp[j][k - 1] += dp[j][k];\n            }\n        }\n    }\n    let mut tot = ModInt::new(0);\n    for i in 0..2 * n + 1 {\n        for j in 0.. 2 * n + 1 {\n            tot += dp[i][j];\n        }\n    }\n    puts!(\"{}\\n\", dp[0][0]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\npub mod modular {\n    const M: i64 = 998244353;\n\n    #[derive(Debug, Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]\n    pub struct Mod(i64);\n\n    impl ::std::fmt::Display for Mod {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl Mod {\n        pub fn new(v: i64) -> Mod {\n            Mod(v % M)\n        }\n\n        pub fn pow(self, mut r: i64) -> Mod {\n            let mut k = self;\n            let mut ret = 1.into();\n\n            while r > 0 {\n                if r % 2 != 0 {\n                    ret = ret * k;\n                }\n                r /= 2;\n                k = k * k;\n            }\n\n            ret\n        }\n\n        // This requires M is prime\n        pub fn recip(self) -> Mod {\n            self.pow(M - 2)\n        }\n    }\n\n    use std::ops::*;\n\n    impl<T: Into<Mod>> Add<T> for Mod {\n        type Output = Mod;\n        fn add(self, rhs: T) -> Self::Output {\n            Mod::new(self.0 + rhs.into().0)\n        }\n    }\n    impl<T: Into<Mod>> AddAssign<T> for Mod {\n        fn add_assign(&mut self, rhs: T) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Into<Mod>> Sub<T> for Mod {\n        type Output = Mod;\n        fn sub(self, rhs: T) -> Self::Output {\n            Mod::new(self.0 - rhs.into().0 + M)\n        }\n    }\n    impl<T: Into<Mod>> SubAssign<T> for Mod {\n        fn sub_assign(&mut self, rhs: T) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Into<Mod>> Mul<T> for Mod {\n        type Output = Mod;\n        fn mul(self, rhs: T) -> Self::Output {\n            Mod::new(self.0 * rhs.into().0)\n        }\n    }\n    impl<T: Into<Mod>> MulAssign<T> for Mod {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Into<Mod>> Div<T> for Mod {\n        type Output = Mod;\n        fn div(self, rhs: T) -> Self::Output {\n            self * rhs.into().recip()\n        }\n    }\n    impl<T: Into<Mod>> DivAssign<T> for Mod {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs;\n        }\n    }\n\n    impl Neg for Mod {\n        type Output = Mod;\n        fn neg(self) -> Self::Output {\n            Mod(0) - self\n        }\n    }\n\n    impl<T: ::std::convert::Into<i64>> ::std::convert::From<T> for Mod {\n        fn from(v: T) -> Self {\n            Mod::new(v.into())\n        }\n    }\n}\n\nuse modular::Mod;\n\nfn rec(\n    pos: usize,\n    b: usize,\n    candb: &[usize],\n    candr: &[usize],\n    tbl: &mut Vec<Vec<Option<Mod>>>,\n) -> Mod {\n    if pos >= tbl.len() {\n        return 1.into();\n    }\n\n    if let Some(ret) = tbl[pos][b] {\n        return ret;\n    }\n\n    let cb = candb[pos] - b;\n    let r = pos - b;\n\n    // println!(\"{}, {}\", r, candr[pos]);\n    let cr = candr[pos] - r;\n\n    // println!(\"{}, {}: {} {}\", pos, b, cb, cr);\n\n    let mut ret = Mod::new(0);\n    if cb > 0 {\n        ret += rec(pos + 1, b + 1, candb, candr, tbl);\n    }\n    if cr > 0 {\n        ret += rec(pos + 1, b, candb, candr, tbl);\n    }\n\n    tbl[pos][b] = Some(ret);\n    return ret;\n}\n\nfn main() {\n    input! {\n         s: chars,\n    }\n\n    let mut candb = vec![0; s.len() * 2];\n    let mut candr = vec![0; s.len() * 2];\n\n    for i in 0..candb.len() {\n        if i < s.len() {\n            if s[i] == '0' {\n                candb[i] += 0;\n                candr[i] += 2;\n            } else if s[i] == '1' {\n                candb[i] += 1;\n                candr[i] += 1;\n            } else {\n                candb[i] += 2;\n                candr[i] += 0;\n            }\n        }\n\n        if i > 0 {\n            candb[i] += candb[i - 1];\n            candr[i] += candr[i - 1];\n        }\n    }\n\n    let n = s.len();\n    let mut tbl = vec![vec![None; n * 2]; n * 2];\n    let ans = rec(0, 0, &candb, &candr, &mut tbl);\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let s: Vec<usize> = sc\n        .read::<String>()\n        .chars()\n        .map(|c| c as usize - '0' as usize)\n        .collect();\n    let n = s.len();\n    let mut dp: Vec<usize> = vec![0; 2 * n + 1];\n    dp[s[0]] = 1;\n    for i in 0..(2 * n) {\n        let mut next = vec![0; 2 * n + 1];\n        let add = if i + 1 < n { s[i + 1] } else { 0 };\n        let total = cmp::min((i + 1) * 2, 2 * n) - i;\n        for cur in 0..(2 * n + 1) {\n            if dp[cur] == 0 {\n                continue;\n            }\n            // pop red\n            if cur > 0 {\n                next[cur - 1 + add] += dp[cur];\n                next[cur - 1 + add] %= MOD;\n            }\n            // pop blue\n            if total > cur {\n                next[cur + add] += dp[cur];\n                next[cur + add] %= MOD;\n            }\n        }\n        dp = next;\n    }\n\n    println!(\"{}\", dp[0]);\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let s = sc.chars();\n    let n = s.len();\n    let a = s\n        .into_iter()\n        .map(|c| c as usize - '0' as usize)\n        .collect::<Vec<_>>();\n\n    let mut dp = vec![0; 2 * n + 1];\n    dp[a[0]] = 1;\n    for turn in 1..(2 * n + 1) {\n        let mut next = vec![0; 2 * n + 1];\n        let add = if turn < n { a[turn] } else { 0 };\n        let total = cmp::min(turn * 2, n * 2) - turn + 1;\n\n        for red in 0..(total + 1) {\n            let blue = total - red;\n            if red > 0 {\n                next[red + add - 1] += dp[red];\n            }\n            if blue > 0 {\n                next[red + add] += dp[red];\n            }\n        }\n        dp = next.into_iter().map(|next| next % MOD).collect();\n    }\n    println!(\"{}\", dp[0]);\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        #[cfg(debug_assertions)]\n        writeln!(&mut std::io::stderr(), concat!(\"[DEBUG] \", $(stringify!($a), \"={:?} \"),*), $($a),*);\n    }\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\n#[allow(unused_imports)]\nuse std::io::Write;\n\nfn main() {\n    input!{\n      s: chars,\n    }\n    let n = s.len();\n    let mut dp = vec![vec![0; 2001]; 2001];\n    dp[0][0] = 1;\n    let mut r = 0;\n    let mut b = 0;\n\n    const MOD: usize = 998244353;\n\n    for i in 0..n*2 {\n        if i < n {\n            match s[i] {\n                '0' => {\n                    r += 2;\n                },\n                '1' => {\n                    r += 1;\n                    b += 1;\n                },\n                '2' => {\n                    b += 2;\n                },\n                _ => {}\n            }\n        }\n\n        let k = i+1;\n        for nr in 0..k+1 {\n            let nb = k-nr;\n            if !(nr <= r && nb <= b) {\n                continue;\n            }\n            // debug!(i, nr, nb);\n\n            if nr > 0 {\n                dp[nr][nb] += dp[nr-1][nb];\n            }\n            if nb > 0 {\n                dp[nr][nb] += dp[nr][nb-1];\n            }\n            dp[nr][nb] = dp[nr][nb] % MOD;\n        }\n    }\n\n    let mut ans = 0;\n    for nr in 0..2*n+1 {\n        let nb = 2*n - nr;\n        ans += dp[nr][nb];\n        ans %= MOD;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let red: Vec<usize> = sc.chars().iter().map(|&c| c as usize - '0' as usize).collect();\n    let n = red.len();\n\n    let mut dp = vec![0; 2 * n + 1];\n    dp[red[0]] = 1;\n    for turn in 0..(2 * n) {\n        let mut next = vec![0; 2 * n + 1];\n\n        let cur_balls = 2 * cmp::min(turn + 1, n) - turn;\n        let supplied_red = if turn + 1 < n { red[turn + 1] } else { 0 };\n\n        for cur_red in 0..(cur_balls + 1) {\n            if cur_red > 0 {\n                // pop red\n                next[cur_red + supplied_red - 1] += dp[cur_red];\n                next[cur_red + supplied_red - 1] %= MOD;\n            }\n            if cur_balls - cur_red > 0 {\n                // pop blue\n                next[cur_red + supplied_red] += dp[cur_red];\n                next[cur_red + supplied_red] %= MOD;\n            }\n        }\n\n        dp = next;\n    }\n\n    println!(\"{}\", dp[0]);\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let s = read::<String>()\n        .chars()\n        .map(|x| x.to_digit(10).unwrap() as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![vec![Modulo(0); n + 1]; n + 1];\n    dp[0][0] = Modulo(1);\n    let mut b_count = 0;\n    for i in 0..n {\n        b_count += s[i];\n        let r_count = (i + 1) * 2 - b_count;\n        for bi in 0..i + 1 {\n            if i + 1 - bi <= r_count {\n                dp[i + 1][bi] += dp[i][bi];\n            }\n            if bi + 1 <= b_count {\n                dp[i + 1][bi + 1] += dp[i][bi];\n            }\n        }\n    }\n\n    let big_int = 998244353;\n    let fact = ModFactorial::new(n as i64, big_int);\n    let fact = fact.fact;\n    let inv_fact = (0..fact.len())\n        .map(|x| mod_inverse(fact[x as usize], big_int))\n        .collect::<Vec<_>>();\n    let binom = ModBinominal::new(n as i64, big_int, &fact, &inv_fact).bin;\n\n    let mut ans = Modulo(0);\n    for bi in 0..b_count + 1 {\n        let idx = b_count - bi;\n        if n < idx {\n            continue;\n        }\n        ans += dp[n][bi] * Modulo(binom[idx]);\n    }\n    println!(\"{}\", ans);\n}\n\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut d = a;\n    if b == 0 {\n        *x = 1;\n        *y = 0;\n    } else {\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * (*x);\n    }\n    return d;\n}\n\nfn mod_inverse(a: i64, m: i64) -> i64 {\n    let mut x: i64 = 0;\n    let mut y: i64 = 0;\n    extgcd(a, m, &mut x, &mut y);\n    (m + x % m) % m\n}\n\nstruct ModFactorial {\n    fact: Vec<i64>,\n}\n\n// returns n! under mod m\nimpl ModFactorial {\n    fn new(n: i64, m: i64) -> ModFactorial {\n        let mut fact = vec![1; n as usize + 1];\n        for i in 2..fact.len() {\n            fact[i] = (i as i64 * fact[i - 1]) % m;\n        }\n        ModFactorial { fact: fact }\n    }\n}\n\n// returns bin[i] = nCi under mod m\nstruct ModBinominal {\n    bin: Vec<i64>,\n}\n\nimpl ModBinominal {\n    fn new(n: i64, m: i64, fact: &Vec<i64>, inv_fact: &Vec<i64>) -> ModBinominal {\n        let mut bin = vec![1; n as usize + 1];\n        if n == 0 {\n            return ModBinominal { bin: bin };\n        }\n        for i in 1..n + 1 {\n            let a2 = inv_fact[i as usize] % m;\n            let a3 = inv_fact[(n - i) as usize] % m;\n            bin[i as usize] = fact[n as usize] * ((a2 * a3) % m) % m;\n        }\n        ModBinominal { bin: bin }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input!{\n        s: chars\n    }\n    let d = 998244353;\n    let n = s.len();\n    let mut dp: Vec<Vec<usize>> = vec![vec![0; n + 1]; n + 1];\n    dp[0][0] = 1;\n    for (i, &b) in s.iter().enumerate() {\n        if b == '0' {\n            dp[i + 1][0] = dp[i][0];\n            for j in 1..i + 1 {\n                dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % d;\n                dp[i + 1][j] = dp[i][j];\n            }\n        } else if b == '1' {\n            for j in 0..i + 1 {\n                dp[i + 1][j + 1] = dp[i][j];\n                dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % d;\n            }\n        } else {\n            for j in 0..i {\n                dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % d;\n                dp[i + 1][j + 2] = dp[i][j];\n            }\n            dp[i + 1][i + 1] = (dp[i + 1][i + 1] + dp[i][i]) % d;\n        }\n    }\n    let mut ans = 0;\n    for i in 0..n + 1 {\n        ans += dp[n][i] * comb_m(n, i, d) % d;\n    }\n    println!(\"{}\", ans % d);\n}\n\nfn prod_m(n: usize, m: usize, d: usize) -> usize {\n    (n..m+1).fold(1, |ac, x| ac * x % d)\n}\n\nfn stair_m(n: usize, d: usize) -> usize {\n    (1..n+1).fold(1, |ac, x| ac * x % d)\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n\nfn inv_m(n: usize, d: usize) -> usize {\n    pow_m(n, d - 2, d)\n}\n\nfn comb_m(n: usize, r: usize, d: usize) -> usize {\n    prod_m(n - r + 1, n, d) * inv_m(stair_m(r, d), d) % d\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let s = read::<String>()\n        .chars()\n        .map(|x| x.to_digit(10).unwrap() as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![vec![Modulo(0); n + 1]; n + 1];\n    dp[0][0] = Modulo(1);\n    let mut b_count = 0;\n    for i in 0..n {\n        b_count += s[i];\n        let r_count = (i + 1) * 2 - b_count;\n        for bi in 0..i + 1 {\n            if i + 1 - bi <= r_count {\n                dp[i + 1][bi] += dp[i][bi];\n            }\n            if bi + 1 <= b_count {\n                dp[i + 1][bi + 1] += dp[i][bi];\n            }\n        }\n    }\n\n    let big_int = 998244353;\n    let fact = ModFactorial::new(n as i64, big_int);\n    let fact = fact.fact;\n    let inv_fact = (0..fact.len())\n        .map(|x| mod_inverse(fact[x as usize], big_int))\n        .collect::<Vec<_>>();\n    let binom = ModBinominal::new(n as i64, big_int, &fact, &inv_fact).bin;\n\n    let mut ans = Modulo(0);\n    for bi in 0..min(b_count, 2 * n - b_count) + 1 {\n        let idx = b_count - bi;\n        let idx = min(idx, 2 * n - idx);\n        ans += dp[n][bi] * Modulo(binom[idx]);\n    }\n    println!(\"{}\", ans);\n}\n\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut d = a;\n    if b == 0 {\n        *x = 1;\n        *y = 0;\n    } else {\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * (*x);\n    }\n    return d;\n}\n\nfn mod_inverse(a: i64, m: i64) -> i64 {\n    let mut x: i64 = 0;\n    let mut y: i64 = 0;\n    extgcd(a, m, &mut x, &mut y);\n    (m + x % m) % m\n}\n\nstruct ModFactorial {\n    fact: Vec<i64>,\n}\n\n// returns n! under mod m\nimpl ModFactorial {\n    fn new(n: i64, m: i64) -> ModFactorial {\n        let mut fact = vec![1; n as usize + 1];\n        for i in 2..fact.len() {\n            fact[i] = (i as i64 * fact[i - 1]) % m;\n        }\n        ModFactorial { fact: fact }\n    }\n}\n\n// returns bin[i] = nCi under mod m\nstruct ModBinominal {\n    bin: Vec<i64>,\n}\n\nimpl ModBinominal {\n    fn new(n: i64, m: i64, fact: &Vec<i64>, inv_fact: &Vec<i64>) -> ModBinominal {\n        let mut bin = vec![1; n as usize + 1];\n        if n == 0 {\n            return ModBinominal { bin: bin };\n        }\n        for i in 1..n + 1 {\n            let a2 = inv_fact[i as usize] % m;\n            let a3 = inv_fact[(n - i) as usize] % m;\n            bin[i as usize] = fact[n as usize] * ((a2 * a3) % m) % m;\n        }\n        ModBinominal { bin: bin }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_macros)]\n\nuse kyoproio::*;\nuse std::{\n    collections::*,\n    io::{self, prelude::*},\n    iter,\n    mem::{replace, swap},\n};\n\nfn main() -> io::Result<()> {\n    std::thread::Builder::new()\n        .stack_size(64 * 1024 * 1024)\n        .spawn(|| {\n            let stdin = io::stdin();\n            let stdout = io::stdout();\n            run(KInput::new(stdin.lock()), io::BufWriter::new(stdout.lock()))\n        })?\n        .join()\n        .unwrap();\n    Ok(())\n}\n\nfn run<I: Input, O: Write>(mut kin: I, mut out: O) {\n    macro_rules! output { ($($args:expr),+) => { write!(&mut out, $($args),+).unwrap(); }; }\n    macro_rules! outputln {\n        ($($args:expr),+) => { output!($($args),+); outputln!(); };\n        () => { output!(\"\\n\"); if cfg!(debug_assertions) { out.flush().unwrap(); } }\n    }\n\n    const MOD: i64 = 998244353;\n    let s = kin.str().as_bytes();\n    let n = s.len();\n\n    let mut blue = vec![0; n + 1];\n    for i in 1..=n {\n        blue[i] = blue[i - 1] + (s[i - 1] - b'0') as usize;\n    }\n\n    let bn = blue[n];\n    let rn = 2 * n - bn;\n    let mut dp = vec![[0; 4001]; bn + 1];\n    dp[0][0] = 1;\n    for b in 0..=bn {\n        for r in 0..=rn {\n            let k = (b + r).min(n);\n            if b <= blue[k] && r <= 2 * k - blue[k] {\n                if r > 0 {\n                    dp[b][r] += dp[b][r - 1];\n                }\n                if b > 0 {\n                    dp[b][r] += dp[b - 1][r];\n                }\n                if dp[b][r] >= MOD {\n                    dp[b][r] -= MOD;\n                }\n            }\n        }\n    }\n\n    outputln!(\"{}\", dp[bn][rn]);\n}\n\n// -----------------------------------------------------------------------------\npub mod kyoproio {\n    use std::io::prelude::*;\n    pub trait Input {\n        fn str(&mut self) -> &str;\n        fn input<T: InputParse>(&mut self) -> T {\n            T::input(self)\n        }\n        fn iter<T: InputParse>(&mut self) -> Iter<T, Self> {\n            Iter(self, std::marker::PhantomData)\n        }\n        fn seq<T: InputParse, B: std::iter::FromIterator<T>>(&mut self, n: usize) -> B {\n            self.iter().take(n).collect()\n        }\n    }\n    pub struct KInput<R> {\n        src: R,\n        buf: String,\n        pos: usize,\n    }\n    impl<R: BufRead> KInput<R> {\n        pub fn new(src: R) -> Self {\n            Self {\n                src,\n                buf: String::with_capacity(1024),\n                pos: 0,\n            }\n        }\n        pub fn src(&mut self) -> &mut R {\n            &mut self.src\n        }\n    }\n    impl<R: BufRead> Input for KInput<R> {\n        fn str(&mut self) -> &str {\n            loop {\n                if self.pos >= self.buf.len() {\n                    self.pos = 0;\n                    self.buf.clear();\n                    if self.src.read_line(&mut self.buf).expect(\"io error\") == 0 {\n                        return &self.buf;\n                    }\n                }\n                let range = self.pos\n                    ..self.buf[self.pos..]\n                        .find(|c: char| c.is_ascii_whitespace())\n                        .map(|i| i + self.pos)\n                        .unwrap_or_else(|| self.buf.len());\n                self.pos = range.end + 1;\n                if range.end > range.start {\n                    return &self.buf[range];\n                }\n            }\n        }\n    }\n    pub struct Iter<'a, T, I: ?Sized>(&'a mut I, std::marker::PhantomData<*const T>);\n    impl<'a, T: InputParse, I: Input + ?Sized> Iterator for Iter<'a, T, I> {\n        type Item = T;\n        fn next(&mut self) -> Option<T> {\n            Some(self.0.input())\n        }\n    }\n    pub trait InputParse: Sized {\n        fn input<I: Input + ?Sized>(src: &mut I) -> Self;\n    }\n    impl InputParse for Vec<u8> {\n        fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n            src.str().as_bytes().to_owned()\n        }\n    }\n    macro_rules! from_str_impl {\n        { $($T:ty)* } => {\n            $(impl InputParse for $T {\n                fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n                    src.str().parse::<$T>().expect(\"parse error\")\n                }\n            })*\n        }\n    }\n    from_str_impl! {\n        String char bool f32 f64 isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128\n    }\n    macro_rules! tuple_impl {\n        ($H:ident $($T:ident)*) => {\n            impl<$H: InputParse, $($T: InputParse),*> InputParse for ($H, $($T),*) {\n                fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n                    ($H::input(src), $($T::input(src)),*)\n                }\n            }\n            tuple_impl!($($T)*);\n        };\n        () => {}\n    }\n    tuple_impl!(A B C D E F G);\n    #[macro_export]\n    macro_rules! kdbg {\n        ($($v:expr),*) => {\n            if cfg!(debug_assertions) { dbg!($($v),*) } else { ($($v),*) }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst MOD: u32 = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let red: Vec<usize> = sc.chars().iter().map(|&c| c as usize - '0' as usize).collect();\n    let n = red.len();\n\n    let mut dp: Vec<u32> = vec![0; 2 * n + 1];\n    dp[red[0]] = 1;\n    for turn in 0..(2 * n) {\n        let mut next = vec![0; 2 * n + 1];\n\n        let cur_balls = 2 * cmp::min(turn + 1, n) - turn;\n        let supplied_red = if turn + 1 < n { red[turn + 1] } else { 0 };\n\n        for cur_red in 0..(cur_balls + 1) {\n            if cur_red > 0 {\n                // pop red\n                next[cur_red + supplied_red - 1] += dp[cur_red];\n                next[cur_red + supplied_red - 1] %= MOD;\n            }\n            if cur_balls - cur_red > 0 {\n                // pop blue\n                next[cur_red + supplied_red] += dp[cur_red];\n                next[cur_red + supplied_red] %= MOD;\n            }\n        }\n\n        dp = next;\n    }\n\n    println!(\"{}\", dp[0]);\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let s = read::<String>()\n        .chars()\n        .map(|x| x.to_digit(10).unwrap() as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![vec![Modulo(0); n + 1]; n + 1];\n    dp[0][0] = Modulo(1);\n    let mut b_count = 0;\n    for i in 0..n {\n        b_count += s[i];\n        let r_count = (i + 1) * 2 - b_count;\n        for bi in 0..i + 1 {\n            if i + 1 - bi <= r_count {\n                dp[i + 1][bi] += dp[i][bi];\n            }\n            if bi + 1 <= b_count {\n                dp[i + 1][bi + 1] += dp[i][bi];\n            }\n        }\n    }\n\n    let big_int = 998244353;\n    let fact = ModFactorial::new(n as i64, big_int);\n    let fact = fact.fact;\n    let inv_fact = (0..fact.len())\n        .map(|x| mod_inverse(fact[x as usize], big_int))\n        .collect::<Vec<_>>();\n    let binom = ModBinominal::new(n as i64, big_int, &fact, &inv_fact).bin;\n\n    let mut ans = Modulo(0);\n    /*\n    for bi in 0..b_count + 1 {\n        ans += dp[n][bi] * Modulo(binom[b_count - bi]);\n    }\n    */\n    println!(\"{}\", ans);\n}\n\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut d = a;\n    if b == 0 {\n        *x = 1;\n        *y = 0;\n    } else {\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * (*x);\n    }\n    return d;\n}\n\nfn mod_inverse(a: i64, m: i64) -> i64 {\n    let mut x: i64 = 0;\n    let mut y: i64 = 0;\n    extgcd(a, m, &mut x, &mut y);\n    (m + x % m) % m\n}\n\nstruct ModFactorial {\n    fact: Vec<i64>,\n}\n\n// returns n! under mod m\nimpl ModFactorial {\n    fn new(n: i64, m: i64) -> ModFactorial {\n        let mut fact = vec![1; n as usize + 1];\n        for i in 2..fact.len() {\n            fact[i] = (i as i64 * fact[i - 1]) % m;\n        }\n        ModFactorial { fact: fact }\n    }\n}\n\n// returns bin[i] = nCi under mod m\nstruct ModBinominal {\n    bin: Vec<i64>,\n}\n\nimpl ModBinominal {\n    fn new(n: i64, m: i64, fact: &Vec<i64>, inv_fact: &Vec<i64>) -> ModBinominal {\n        let mut bin = vec![1; n as usize + 1];\n        if n == 0 {\n            return ModBinominal { bin: bin };\n        }\n        for i in 1..n + 1 {\n            let a2 = inv_fact[i as usize] % m;\n            let a3 = inv_fact[(n - i) as usize] % m;\n            bin[i as usize] = fact[n as usize] * ((a2 * a3) % m) % m;\n        }\n        ModBinominal { bin: bin }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n"
  },
  {
    "language": "Rust",
    "code": "use self::mod_int::ModInt;\nuse std::cmp;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    let s = sc\n        .read::<String>()\n        .chars()\n        .map(|c| c as usize - '0' as usize)\n        .collect::<Vec<_>>();\n\n    let total = s.len() * 2;\n    let mut dp = vec![ModInt(0); total + 1];\n    dp[0] = ModInt(1);\n    let mut polled_red = 0;\n    let mut polled_total = 0;\n    for i in 0..total {\n        if i < s.len() {\n            polled_red += s[i];\n            polled_total += 2;\n        }\n        let polled_blue = polled_total - polled_red;\n        let mut next = vec![ModInt(0); total + 1];\n        for cur_red in 0..(total + 1) {\n            if i < cur_red {\n                break;\n            }\n            let cur_blue = i - cur_red;\n            if cur_red + 1 <= polled_red {\n                next[cur_red + 1] += dp[cur_red];\n            }\n            if cur_blue + 1 <= polled_blue {\n                next[cur_red] += dp[cur_red];\n            }\n        }\n        dp = next;\n    }\n    println!(\"{}\", dp[polled_red].0);\n}\n\npub fn extract_convex_hull(points: &Vec<Point>, contain_on_segment: bool) -> Vec<usize> {\n    let n = points.len();\n    if n <= 1 {\n        return vec![0];\n    }\n\n    let mut ps: Vec<usize> = (0..n).collect();\n    ps.sort_by(|&a, &b| {\n        if points[a].x == points[b].x {\n            points[a].y.partial_cmp(&points[b].y).unwrap()\n        } else {\n            points[a].x.partial_cmp(&points[b].x).unwrap()\n        }\n    });\n\n    let mut qs: Vec<usize> = Vec::new();\n    for &i in &ps {\n        while qs.len() > 1 {\n            let k = qs.len();\n            let det = (points[qs[k - 1]] - points[qs[k - 2]]).det(&(points[i] - points[qs[k - 1]]));\n            if det < 0.0 || (det <= 0.0 && !contain_on_segment) {\n                qs.pop();\n            } else {\n                break;\n            }\n        }\n        qs.push(i);\n    }\n\n    let t = qs.len();\n    for i in (0..(n - 1)).rev() {\n        let i = ps[i];\n        while qs.len() > t {\n            let k = qs.len();\n            let det = (points[qs[k - 1]] - points[qs[k - 2]]).det(&(points[i] - points[qs[k - 1]]));\n            if det < 0.0 || (det <= 0.0 && !contain_on_segment) {\n                qs.pop();\n            } else {\n                break;\n            }\n        }\n        qs.push(i);\n    }\n\n    qs.pop();\n    return qs;\n}\n\n#[derive(Debug, Copy, Clone)]\npub struct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl std::ops::Sub for Point {\n    type Output = Point;\n    fn sub(self, other: Point) -> Point {\n        Point {\n            x: self.x - other.x,\n            y: self.y - other.y,\n        }\n    }\n}\n\nimpl Point {\n    pub fn det(&self, other: &Point) -> f64 {\n        self.x * other.y - self.y * other.x\n    }\n}\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    size: usize,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            size: n,\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n        self.size -= 1;\n        return true;\n    }\n}\n\n/// `FenwickTree` is a data structure that can efficiently update elements\n/// and calculate prefix sums in a table of numbers.\n/// [https://en.wikipedia.org/wiki/Fenwick_tree](https://en.wikipedia.org/wiki/Fenwick_tree)\npub struct FenwickTree<T> {\n    n: usize,\n    data: Vec<T>,\n    init: T,\n}\n\nimpl<T: Copy + std::ops::AddAssign + std::ops::Sub<Output = T>> FenwickTree<T> {\n    /// Constructs a new `FenwickTree`. The size of `FenwickTree` should be specified by `size`.\n    pub fn new(size: usize, init: T) -> FenwickTree<T> {\n        FenwickTree {\n            n: size + 1,\n            data: vec![init; size + 1],\n            init: init,\n        }\n    }\n\n    pub fn add(&mut self, k: usize, value: T) {\n        let mut x = k;\n        while x < self.n {\n            self.data[x] += value;\n            x |= x + 1;\n        }\n    }\n\n    /// Returns a sum of range `[l, r)`\n    pub fn sum(&self, l: usize, r: usize) -> T {\n        self.sum_one(r) - self.sum_one(l)\n    }\n\n    /// Returns a sum of range `[0, k)`\n    pub fn sum_one(&self, k: usize) -> T {\n        assert!(k < self.n, \"k={} n={}\", k, self.n);\n\n        let mut result = self.init;\n        let mut x = k as i32 - 1;\n        while x >= 0 {\n            result += self.data[x as usize];\n            x = (x & (x + 1)) - 1;\n        }\n\n        result\n    }\n}\npub mod mod_int {\n    use super::MOD;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: Num) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\nconst MOD: i64 = 998244353;\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Modi64(pub i64);\nimpl Modi64 {\n    #[inline]\n    pub fn new(i: i64) -> Self {\n        Modi64(Self::modulo(i, MOD))\n    }\n    #[inline]\n    pub fn modulo(i: i64, m: i64) -> i64 {\n        let mut x = i % m;\n        if x < 0 {\n            x += m;\n        }\n        x\n    }\n    pub fn pow(self, y: i64) -> Self {\n        let mut y = Self::modulo(y, MOD - 1);\n        let mut x = Self::new(1);\n        let mut base = self;\n        while y > 0 {\n            if y & 1 == 1 {\n                x *= base;\n            }\n            base *= base;\n            y = y >> 1;\n        }\n        x\n    }\n    #[inline]\n    pub fn inv(self) -> Self {\n        let (mut x, mut s, mut t, mut u) = (1, self.0, MOD, 0);\n        while t != 0 {\n            let k = s / t;\n            s -= k * t;\n            std::mem::swap(&mut s, &mut t);\n            x -= k * u;\n            std::mem::swap(&mut x, &mut u);\n        }\n        Modi64::new(x)\n    }\n}\nimpl std::ops::Add for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        Modi64((self.0 + rhs.0) % MOD)\n    }\n}\nimpl<'a> std::ops::Add<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Modi64) -> Self::Output {\n        *self + rhs\n    }\n}\nimpl<'a> std::ops::Add<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: &'a Modi64) -> Self::Output {\n        self + *rhs\n    }\n}\nimpl<'a> std::ops::Add for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        *self + *rhs\n    }\n}\nimpl std::ops::AddAssign for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs;\n    }\n}\nimpl<'a> std::ops::AddAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: &'a Modi64) {\n        *self += *rhs;\n    }\n}\nimpl std::ops::Sub for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        Self::new(self.0 - rhs.0)\n    }\n}\nimpl<'a> std::ops::Sub<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Modi64) -> Self::Output {\n        *self - rhs\n    }\n}\nimpl<'a> std::ops::Sub<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: &'a Modi64) -> Self::Output {\n        self - *rhs\n    }\n}\nimpl<'a> std::ops::Sub for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        *self - *rhs\n    }\n}\nimpl std::ops::SubAssign for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}\nimpl<'a> std::ops::SubAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: &'a Modi64) {\n        *self -= *rhs;\n    }\n}\nimpl std::ops::Mul for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        Modi64(self.0 * rhs.0 % MOD)\n    }\n}\nimpl<'a> std::ops::Mul<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Modi64) -> Self::Output {\n        *self * rhs\n    }\n}\nimpl<'a> std::ops::Mul<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: &'a Modi64) -> Self::Output {\n        self * *rhs\n    }\n}\nimpl<'a> std::ops::Mul for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        *self * *rhs\n    }\n}\nimpl std::ops::MulAssign for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs;\n    }\n}\nimpl<'a> std::ops::MulAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: &'a Modi64) {\n        *self *= *rhs;\n    }\n}\nimpl std::ops::Div for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Modi64) -> Self::Output {\n        *self / rhs\n    }\n}\nimpl<'a> std::ops::Div<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: &'a Modi64) -> Self::Output {\n        self / *rhs\n    }\n}\nimpl<'a> std::ops::Div for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        *self / *rhs\n    }\n}\nimpl std::ops::DivAssign for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: Self) {\n        *self = *self / rhs;\n    }\n}\nimpl<'a> std::ops::DivAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: &'a Modi64) {\n        *self /= *rhs;\n    }\n}\nimpl std::ops::Neg for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        Self::new(-self.0)\n    }\n}\nimpl<'a> std::ops::Neg for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        -*self\n    }\n}\nimpl std::iter::Sum for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), std::ops::Add::add)\n    }\n}\nimpl<'a> std::iter::Sum<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), |x, &y| x + y)\n    }\n}\nimpl std::fmt::Display for Modi64 {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> Result<(), std::fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\nfn main() {\n    input! { s: {chars: '0'} };\n    let n = s.len();\n    let mut b = s.clone();\n    let mut t = vec![2; n];\n    for i in 0..n - 1 {\n        b[i + 1] += b[i];\n        t[i + 1] += t[i];\n    }\n    let m = b[n - 1];\n    b.extend(vec![m; n]);\n    let m = t[n - 1];\n    t.extend(vec![m; n]);\n    let mut dp = vec![vec![Modi64(0); 2 * n + 1]; 2 * n + 1];\n    dp[0][0] = Modi64(1);\n    for i in 0..2 * n {\n        for j in 0..2 * n + 1 {\n            let ni = i + 1;\n            let d = dp[i][j];\n            if i >= j && t[i] - b[i] > i - j {\n                dp[ni][j] += d;\n            }\n            if b[i] > j {\n                dp[ni][j + 1] += d;\n            }\n        }\n    }\n    println!(\"{}\", dp[2 * n].iter().sum::<Modi64>());\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        #[cfg(debug_assertions)]\n        writeln!(&mut std::io::stderr(), concat!(\"[DEBUG] \", $(stringify!($a), \"={:?} \"),*), $($a),*);\n    }\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\n#[allow(unused_imports)]\nuse std::io::Write;\n\nfn main() {\n    input!{\n      s: chars,\n    }\n    let n = s.len();\n    let mut dp = vec![vec![0; 4001]; 4001];\n    dp[0][0] = 1;\n    let mut r = 0;\n    let mut b = 0;\n\n    const MOD: usize = 998244353;\n\n    for i in 0..n*2 {\n        if i < n {\n            match s[i] {\n                '0' => {\n                    r += 2;\n                },\n                '1' => {\n                    r += 1;\n                    b += 1;\n                },\n                '2' => {\n                    b += 2;\n                },\n                _ => {}\n            }\n        }\n\n        let k = i+1;\n        for nr in 0..k+1 {\n            let nb = k-nr;\n            if !(nr <= r && nb <= b) {\n                continue;\n            }\n            // debug!(i, nr, nb);\n\n            if nr > 0 {\n                dp[nr][nb] += dp[nr-1][nb];\n            }\n            if nb > 0 {\n                dp[nr][nb] += dp[nr][nb-1];\n            }\n            dp[nr][nb] = dp[nr][nb] % MOD;\n        }\n    }\n\n    let mut ans = 0;\n    for nr in 0..2*n+1 {\n        let nb = 2*n - nr;\n        ans += dp[nr][nb];\n        ans %= MOD;\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nimpl<'a> Scanner<'a> {\n    #[inline]\n    pub fn new(s: &'a str) -> Self {\n        let iter = s.split_ascii_whitespace();\n        Self { iter }\n    }\n    #[inline]\n    pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n        T::scan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n        marker.mscan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n        (0..size)\n            .map(|_| T::scan(&mut self.iter).unwrap())\n            .collect()\n    }\n    #[inline]\n    pub fn scan_chars(&mut self) -> Vec<char> {\n        self.iter.next().unwrap().chars().collect::<Vec<char>>()\n    }\n    #[inline]\n    pub fn scan_chars_with(&mut self, base: char) -> Vec<usize> {\n        self.iter\n            .next()\n            .unwrap()\n            .chars()\n            .map(|c| (c as u8 - base as u8) as usize)\n            .collect::<Vec<usize>>()\n    }\n}\nmod scanner_impls {\n    use super::*;\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($($T ::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        fn next(&mut self) -> Option<Self::Item> {\n            T::scan(&mut self.inner.iter)\n        }\n    }\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            usize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n    pub struct Isize1;\n    impl IterScan for Isize1 {\n        type Output = isize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            isize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\npub trait Modulus {\n    fn get_modulus() -> u32;\n    #[inline]\n    fn modulo(x: u32) -> u32 {\n        x % Self::get_modulus()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules! make_modulus {\n    ($t :ident ,$e :expr ) => {\n        pub struct $t {}\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                const MODULUS: u32 = $e;\n                MODULUS\n            }\n        }\n    };\n}\n#[allow(unused_macros)]\nmacro_rules! make_dynamic_modulus {\n    ($t :ident ,$m :ident ,$e :expr ) => {\n        pub struct $t {}\n        static mut $m: u32 = $e;\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                unsafe { $m }\n            }\n        }\n    };\n}\npub mod modulus {\n    use super::*;\n    pub struct Modulo1000000007 {}\n    impl Modulus for Modulo1000000007 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_007;\n            MODULUS\n        }\n    }\n    pub struct Modulo1000000009 {}\n    impl Modulus for Modulo1000000009 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_009;\n            MODULUS\n        }\n    }\n    pub struct Modulo998244353 {}\n    impl Modulus for Modulo998244353 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 998_244_353;\n            MODULUS\n        }\n    }\n    pub struct DynModulo {}\n    static mut DYN_MODULUS: u32 = 1_000_000_007;\n    impl Modulus for DynModulo {\n        #[inline]\n        fn get_modulus() -> u32 {\n            unsafe { DYN_MODULUS }\n        }\n    }\n    pub fn set_dyn_modulus(m: u32) {\n        unsafe {\n            DYN_MODULUS = m;\n        }\n    }\n}\npub struct MInt<M>\nwhere\n    M: Modulus,\n{\n    x: u32,\n    _marker: std::marker::PhantomData<fn() -> M>,\n}\nimpl<M: Modulus> MInt<M> {\n    #[inline]\n    pub fn new(x: u32) -> Self {\n        Self {\n            x: M::modulo(x),\n            _marker: std::marker::PhantomData,\n        }\n    }\n    #[inline]\n    pub fn new_unchecked(x: u32) -> Self {\n        Self {\n            x,\n            _marker: std::marker::PhantomData,\n        }\n    }\n    #[inline]\n    pub fn inner(self) -> u32 {\n        self.x\n    }\n    #[inline]\n    pub fn one() -> Self {\n        Self::new_unchecked(1)\n    }\n    #[inline]\n    pub fn zero() -> Self {\n        Self::new_unchecked(0)\n    }\n    #[inline]\n    pub fn get_mod() -> u32 {\n        M::get_modulus()\n    }\n    #[inline]\n    pub fn pow(mut self, mut y: usize) -> Self {\n        let mut x = Self::one();\n        while y > 0 {\n            if y & 1 == 1 {\n                x *= self;\n            }\n            self *= self;\n            y >>= 1;\n        }\n        x\n    }\n    #[inline]\n    /// only prime modulus\n    pub fn inv(self) -> Self {\n        let mut a = self.x;\n        let (mut b, mut u, mut s) = (M::get_modulus(), 1, 0);\n        let k = a.trailing_zeros();\n        a >>= k;\n        for _ in 0..k {\n            if u & 1 == 1 {\n                u += M::get_modulus();\n            }\n            u /= 2;\n        }\n        while a != b {\n            if b < a {\n                std::mem::swap(&mut a, &mut b);\n                std::mem::swap(&mut u, &mut s);\n            }\n            b -= a;\n            if s < u {\n                s += M::get_modulus();\n            }\n            s -= u;\n            let k = b.trailing_zeros();\n            b >>= k;\n            for _ in 0..k {\n                if s & 1 == 1 {\n                    s += M::get_modulus();\n                }\n                s /= 2;\n            }\n        }\n        Self::new_unchecked(s)\n    }\n}\nmod mint_impls {\n    use super::*;\n    use std::{\n        cmp::Ordering,\n        fmt::{self, Debug},\n        hash::{Hash, Hasher},\n        iter::{Product, Sum},\n        marker::PhantomData,\n        num::ParseIntError,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n        str::FromStr,\n    };\n    impl<M: Modulus> Clone for MInt<M> {\n        #[inline]\n        fn clone(&self) -> Self {\n            Self {\n                x: Clone::clone(&self.x),\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<M: Modulus> Copy for MInt<M> {}\n    impl<M: Modulus> Debug for MInt<M> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            Debug::fmt(&self.x, f)\n        }\n    }\n    impl<M: Modulus> Default for MInt<M> {\n        #[inline]\n        fn default() -> Self {\n            Self::zero()\n        }\n    }\n    impl<M: Modulus> PartialEq for MInt<M> {\n        #[inline]\n        fn eq(&self, other: &Self) -> bool {\n            PartialEq::eq(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> PartialOrd for MInt<M> {\n        #[inline]\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            PartialOrd::partial_cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Eq for MInt<M> {}\n    impl<M: Modulus> Ord for MInt<M> {\n        #[inline]\n        fn cmp(&self, other: &Self) -> Ordering {\n            Ord::cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Hash for MInt<M> {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            Hash::hash(&self.x, state)\n        }\n    }\n    impl<M: Modulus> From<u32> for MInt<M> {\n        #[inline]\n        fn from(x: u32) -> Self {\n            Self::new(x)\n        }\n    }\n    impl<M: Modulus> From<u64> for MInt<M> {\n        #[inline]\n        fn from(x: u64) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> From<i32> for MInt<M> {\n        #[inline]\n        fn from(x: i32) -> Self {\n            let x = x % M::get_modulus() as i32;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i32) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<i64> for MInt<M> {\n        #[inline]\n        fn from(x: i64) -> Self {\n            let x = x % M::get_modulus() as i64;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i64) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> Add for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut x = self.x + rhs.x;\n            if x >= M::get_modulus() {\n                x -= M::get_modulus();\n            }\n            Self::new_unchecked(x)\n        }\n    }\n    impl<M: Modulus> Sub for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn sub(self, rhs: Self) -> Self::Output {\n            if self.x < rhs.x {\n                Self::new_unchecked(self.x + M::get_modulus() - rhs.x)\n            } else {\n                Self::new_unchecked(self.x - rhs.x)\n            }\n        }\n    }\n    impl<M: Modulus> Mul for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn mul(self, rhs: Self) -> Self::Output {\n            Self::new_unchecked((self.x as u64 * rhs.x as u64 % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> Div for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn div(self, rhs: Self) -> Self::Output {\n            self * rhs.inv()\n        }\n    }\n    impl<M: Modulus> Neg for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn neg(self) -> Self::Output {\n            if self.x == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(M::get_modulus() - self.x)\n            }\n        }\n    }\n    impl<M: Modulus> Sum for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<M: Modulus> Product for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Sum<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Product<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<M: Modulus> fmt::Display for MInt<M> {\n        fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> Result<(), fmt::Error> {\n            write!(f, \"{}\", self.x)\n        }\n    }\n    impl<M: Modulus> FromStr for MInt<M> {\n        type Err = ParseIntError;\n        #[inline]\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            s.parse::<u32>().map(Self::new)\n        }\n    }\n    macro_rules! mint_ref_binop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp<$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: $t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(self, *other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, *other)\n                }\n            }\n        };\n    }\n    mint_ref_binop!(Add, add, MInt<M>);\n    mint_ref_binop!(Sub, sub, MInt<M>);\n    mint_ref_binop!(Mul, mul, MInt<M>);\n    mint_ref_binop!(Div, div, MInt<M>);\n    macro_rules! mint_ref_unop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp for &$t {\n                type Output = <$t as $imp>::Output;\n                #[inline]\n                fn $method(self) -> <$t as $imp>::Output {\n                    $imp::$method(*self)\n                }\n            }\n        };\n    }\n    mint_ref_unop!(Neg, neg, MInt<M>);\n    macro_rules! mint_ref_op_assign {\n        ($imp :ident ,$method :ident ,$t :ty ,$fromimp :ident ,$frommethod :ident ) => {\n            impl<M: Modulus> $imp<$t> for $t {\n                #[inline]\n                fn $method(&mut self, rhs: $t) {\n                    *self = $fromimp::$frommethod(*self, rhs);\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                #[inline]\n                fn $method(&mut self, other: &$t) {\n                    $imp::$method(self, *other);\n                }\n            }\n        };\n    }\n    mint_ref_op_assign!(AddAssign, add_assign, MInt<M>, Add, add);\n    mint_ref_op_assign!(SubAssign, sub_assign, MInt<M>, Sub, sub);\n    mint_ref_op_assign!(MulAssign, mul_assign, MInt<M>, Mul, mul);\n    mint_ref_op_assign!(DivAssign, div_assign, MInt<M>, Div, div);\n}\nimpl<M: Modulus> IterScan for MInt<M> {\n    type Output = Self;\n    #[inline]\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n        iter.next()?.parse::<MInt<M>>().ok()\n    }\n}\ntype M = MInt<modulus::Modulo998244353>;\nfn main() {\n    #[allow(unused_imports)]\n    use std::io::{Read as _, Write as _};\n    let __out = std::io::stdout();\n    let mut __in_buf = String::new();\n    std::io::stdin().read_to_string(&mut __in_buf).unwrap();\n    let mut scanner = Scanner::new(&__in_buf);\n    #[allow(unused_macros)]\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;({chars :$b :expr } ) =>{scanner .scan_chars_with ($b ) } ;({$t :tt =>$f :expr } ) =>{$f (scan !($t ) ) } ;(chars ) =>{scanner .scan_chars () } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let mut __out = std::io::BufWriter::new(__out.lock());\n    #[allow(unused_macros)]\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, \"\\n\")\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter;\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let s = scan!({chars: '0'});\n    let n = s.len();\n    let mut t = s.clone();\n    for i in 0..n - 1 {\n        t[i + 1] += t[i];\n    }\n    let mut dp = vec![vec![M::zero(); 2 * n + 1]; 2 * n + 1];\n    dp[0][0] = M::one();\n    for i in 0..n * 2 {\n        for j in 0..=i {\n            let d = dp[i][j];\n            if d == M::zero() {\n                continue;\n            }\n            let ni = i + 1;\n            let b = if i < n { t[i] } else { t[n - 1] };\n            let r = if i < n {\n                (i + 1) * 2 - t[i]\n            } else {\n                2 * n - t[n - 1]\n            };\n            if b >= j + 1 {\n                dp[ni][j + 1] += d;\n            }\n            if r >= ni - j {\n                dp[ni][j] += d;\n            }\n        }\n    }\n    println!(\"{}\", dp[2 * n][t[n - 1]]);\n}"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let s = read::<String>()\n        .chars()\n        .map(|x| x.to_digit(10).unwrap() as usize)\n        .collect::<Vec<_>>();\n    let n = s.len();\n\n    let mut dp = vec![vec![Modulo(0); n + 1]; n + 1];\n    dp[0][0] = Modulo(1);\n    let mut b_count = 0;\n    for i in 0..n {\n        b_count += s[i];\n        let r_count = (i + 1) * 2 - b_count;\n        for bi in 0..i + 1 {\n            if i + 1 - bi <= r_count {\n                dp[i + 1][bi] += dp[i][bi];\n            }\n            if bi + 1 <= b_count {\n                dp[i + 1][bi + 1] += dp[i][bi];\n            }\n        }\n    }\n\n    let big_int = 998244353;\n    let fact = ModFactorial::new(n as i64, big_int);\n    let fact = fact.fact;\n    let inv_fact = (0..fact.len())\n        .map(|x| mod_inverse(fact[x as usize], big_int))\n        .collect::<Vec<_>>();\n    let binom = ModBinominal::new(n as i64, big_int, &fact, &inv_fact).bin;\n\n    let mut ans = Modulo(0);\n    for bi in 0..min(b_count, n) + 1 {\n        ans += dp[n][bi] * Modulo(binom[b_count - bi]);\n    }\n    println!(\"{}\", ans);\n}\n\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut d = a;\n    if b == 0 {\n        *x = 1;\n        *y = 0;\n    } else {\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * (*x);\n    }\n    return d;\n}\n\nfn mod_inverse(a: i64, m: i64) -> i64 {\n    let mut x: i64 = 0;\n    let mut y: i64 = 0;\n    extgcd(a, m, &mut x, &mut y);\n    (m + x % m) % m\n}\n\nstruct ModFactorial {\n    fact: Vec<i64>,\n}\n\n// returns n! under mod m\nimpl ModFactorial {\n    fn new(n: i64, m: i64) -> ModFactorial {\n        let mut fact = vec![1; n as usize + 1];\n        for i in 2..fact.len() {\n            fact[i] = (i as i64 * fact[i - 1]) % m;\n        }\n        ModFactorial { fact: fact }\n    }\n}\n\n// returns bin[i] = nCi under mod m\nstruct ModBinominal {\n    bin: Vec<i64>,\n}\n\nimpl ModBinominal {\n    fn new(n: i64, m: i64, fact: &Vec<i64>, inv_fact: &Vec<i64>) -> ModBinominal {\n        let mut bin = vec![1; n as usize + 1];\n        if n == 0 {\n            return ModBinominal { bin: bin };\n        }\n        for i in 1..n + 1 {\n            let a2 = inv_fact[i as usize] % m;\n            let a3 = inv_fact[(n - i) as usize] % m;\n            bin[i as usize] = fact[n as usize] * ((a2 * a3) % m) % m;\n        }\n        ModBinominal { bin: bin }\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\nconst MOD: i64 = 998244353;\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Modi64(pub i64);\nimpl Modi64 {\n    #[inline]\n    pub fn new(i: i64) -> Self {\n        Modi64(Self::modulo(i, MOD))\n    }\n    #[inline]\n    pub fn modulo(i: i64, m: i64) -> i64 {\n        let mut x = i % m;\n        if x < 0 {\n            x += m;\n        }\n        x\n    }\n    pub fn pow(self, y: i64) -> Self {\n        let mut y = Self::modulo(y, MOD - 1);\n        let mut x = Self::new(1);\n        let mut base = self;\n        while y > 0 {\n            if y & 1 == 1 {\n                x *= base;\n            }\n            base *= base;\n            y = y >> 1;\n        }\n        x\n    }\n    #[inline]\n    pub fn inv(self) -> Self {\n        let (mut x, mut s, mut t, mut u) = (1, self.0, MOD, 0);\n        while t != 0 {\n            let k = s / t;\n            s -= k * t;\n            std::mem::swap(&mut s, &mut t);\n            x -= k * u;\n            std::mem::swap(&mut x, &mut u);\n        }\n        Modi64::new(x)\n    }\n}\nimpl std::ops::Add for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        Modi64((self.0 + rhs.0) % MOD)\n    }\n}\nimpl<'a> std::ops::Add<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Modi64) -> Self::Output {\n        *self + rhs\n    }\n}\nimpl<'a> std::ops::Add<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: &'a Modi64) -> Self::Output {\n        self + *rhs\n    }\n}\nimpl<'a> std::ops::Add for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        *self + *rhs\n    }\n}\nimpl std::ops::AddAssign for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs;\n    }\n}\nimpl<'a> std::ops::AddAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: &'a Modi64) {\n        *self += *rhs;\n    }\n}\nimpl std::ops::Sub for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        Self::new(self.0 - rhs.0)\n    }\n}\nimpl<'a> std::ops::Sub<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Modi64) -> Self::Output {\n        *self - rhs\n    }\n}\nimpl<'a> std::ops::Sub<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: &'a Modi64) -> Self::Output {\n        self - *rhs\n    }\n}\nimpl<'a> std::ops::Sub for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        *self - *rhs\n    }\n}\nimpl std::ops::SubAssign for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}\nimpl<'a> std::ops::SubAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: &'a Modi64) {\n        *self -= *rhs;\n    }\n}\nimpl std::ops::Mul for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        Modi64(self.0 * rhs.0 % MOD)\n    }\n}\nimpl<'a> std::ops::Mul<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Modi64) -> Self::Output {\n        *self * rhs\n    }\n}\nimpl<'a> std::ops::Mul<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: &'a Modi64) -> Self::Output {\n        self * *rhs\n    }\n}\nimpl<'a> std::ops::Mul for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        *self * *rhs\n    }\n}\nimpl std::ops::MulAssign for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs;\n    }\n}\nimpl<'a> std::ops::MulAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: &'a Modi64) {\n        *self *= *rhs;\n    }\n}\nimpl std::ops::Div for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Modi64) -> Self::Output {\n        *self / rhs\n    }\n}\nimpl<'a> std::ops::Div<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: &'a Modi64) -> Self::Output {\n        self / *rhs\n    }\n}\nimpl<'a> std::ops::Div for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        *self / *rhs\n    }\n}\nimpl std::ops::DivAssign for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: Self) {\n        *self = *self / rhs;\n    }\n}\nimpl<'a> std::ops::DivAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: &'a Modi64) {\n        *self /= *rhs;\n    }\n}\nimpl std::ops::Neg for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        Self::new(-self.0)\n    }\n}\nimpl<'a> std::ops::Neg for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        -*self\n    }\n}\nimpl std::iter::Sum for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), std::ops::Add::add)\n    }\n}\nimpl<'a> std::iter::Sum<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), |x, &y| x + y)\n    }\n}\nimpl std::fmt::Display for Modi64 {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> Result<(), std::fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\nfn main() {\n    input! { s: {chars: '0'} };\n    let n = s.len();\n    let mut b = s.clone();\n    let mut t = vec![2; n];\n    for i in 0..n - 1 {\n        b[i + 1] += b[i];\n        t[i + 1] += t[i];\n    }\n    b.extend(vec![b[n - 1]; n]);\n    t.extend(vec![t[n - 1]; n]);\n    let mut dp = vec![vec![Modi64(0); 2 * n + 1]; 2 * n + 1];\n    dp[0][0] = Modi64(1);\n    for i in 0..2 * n {\n        for j in 0..2 * n + 1 {\n            let ni = i + 1;\n            let d = dp[i][j];\n            if i >= j && t[i] - b[i] > i - j {\n                dp[ni][j] += d;\n            }\n            if b[i] > j {\n                dp[ni][j + 1] += d;\n            }\n        }\n    }\n    println!(\"{}\", dp[2 * n].iter().sum::<Modi64>());\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn ctou(c: char) -> usize {\n    match c {\n        '0' => 0,\n        '1' => 1,\n        '2' => 2,\n        _ => panic!(\"no\"),\n    }\n}\n\nconst MOD: i64 = 998244353;\n\nfn main() {\n    input! {\n        s: chars\n    };\n\n    let n = s.len();\n    let mut dp = dvec![0; 2*n+1, 2*n+1];\n\n    dp[0][0] = 1;\n    let mut blue = 0;\n    let mut red = 0;\n    for i in 0..2*n {\n        if i < n {\n            blue += ctou(s[i]);\n            red += 2-ctou(s[i]);\n        }\n        for j in 0..2*n+1 {\n            let base = dp[i][j];\n            if base == 0 {\n                continue;\n            }\n\n            if j < blue {\n                dp[i+1][j+1] += base;\n                dp[i+1][j+1] %= MOD;\n            }\n            if (i-j) < red {\n                dp[i+1][j] += base;\n                dp[i+1][j] %= MOD;\n            }\n        }\n    }\n\n    println!(\"{}\", dp[2*n][blue]);\n}\n"
  }
]