[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_USERS 100001\n\nint parent[MAX_USERS];\nbool friends[MAX_USERS][MAX_USERS];\nbool blocked[MAX_USERS][MAX_USERS];\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px != py) \n        parent[px] = py;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    // Initialize parent array\n    for (int i = 1; i <= N; i++) \n        parent[i] = i;\n\n    // Process friendships\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        friends[a][b] = friends[b][a] = true;\n        unionSet(a, b);\n    }\n\n    // Process blockships\n    for (int i = 0; i < K; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        blocked[a][b] = blocked[b][a] = true;\n    }\n\n    // Count friend candidates for each user\n    for (int i = 1; i <= N; i++) {\n        int candidates = 0;\n        for (int j = 1; j <= N; j++) {\n            if (i == j) continue;\n            if (friends[i][j]) continue;\n            if (blocked[i][j]) continue;\n            if (find(i) != find(j)) continue;\n            candidates++;\n        }\n        printf(\"%d \", candidates);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:36:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int parent;\n    int rank;\n} DisjointSet;\n\nDisjointSet* createSet(int N) {\n    DisjointSet* set = (DisjointSet*)malloc((N + 1) * sizeof(DisjointSet));\n    for (int i = 1; i <= N; i++) {\n        set[i].parent = i;\n        set[i].rank = 0;\n    }\n    return set;\n}\n\nint find(DisjointSet* set, int x) {\n    if (set[x].parent != x) {\n        set[x].parent = find(set, set[x].parent);\n    }\n    return set[x].parent;\n}\n\nvoid unionSets(DisjointSet* set, int x, int y) {\n    int xRoot = find(set, x);\n    int yRoot = find(set, y);\n    if (xRoot == yRoot) return;\n    if (set[xRoot].rank < set[yRoot].rank) {\n        set[xRoot].parent = yRoot;\n    } else if (set[xRoot].rank > set[yRoot].rank) {\n        set[yRoot].parent = xRoot;\n    } else {\n        set[yRoot].parent = xRoot;\n        set[xRoot].rank++;\n    }\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    DisjointSet* set = createSet(N);\n    int* friendsCount = (int*)calloc(N + 1, sizeof(int));\n    int* blocksCount = (int*)calloc(N + 1, sizeof(int));\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        unionSets(set, a, b);\n        friendsCount[a]++;\n        friendsCount[b]++;\n    }\n\n    for (int i = 0; i < K; i++) {\n        int c, d;\n        scanf(\"%d %d\", &c, &d);\n        if (find(set, c) == find(set, d)) {\n            blocksCount[c]++;\n            blocksCount[d]++;\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        int root = find(set, i);\n        int total = 0;\n        for (int j = 1; j <= N; j++) {\n            if (i != j && find(set, j) == root) {\n                total++;\n            }\n        }\n        printf(\"%d \", total - friendsCount[i] - blocksCount[i]);\n    }\n\n    free(set);\n    free(friendsCount);\n    free(blocksCount);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:37:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent;\n    UnionFind(int n) : parent(n) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) parent[y] = x;\n    }\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<unordered_set<int>> friends(N), blocks(N);\n    UnionFind uf(N);\n\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        friends[a].insert(b);\n        friends[b].insert(a);\n        uf.unite(a, b);\n    }\n\n    for (int i = 0; i < K; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        blocks[c].insert(d);\n        blocks[d].insert(c);\n    }\n\n    vector<int> component_size(N, 0);\n    for (int i = 0; i < N; ++i) {\n        component_size[uf.find(i)]++;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int cnt = component_size[uf.find(i)] - 1 - friends[i].size();\n        for (int b : blocks[i]) {\n            if (uf.find(i) == uf.find(b)) --cnt;\n        }\n        cout << cnt << (i == N - 1 ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:37:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FriendCandidates {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int K = sc.nextInt();\n        \n        List<Set<Integer>> friends = new ArrayList<>();\n        List<Set<Integer>> blocks = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            friends.add(new HashSet<>());\n            blocks.add(new HashSet<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            friends.get(a).add(b);\n            friends.get(b).add(a);\n        }\n        \n        for (int i = 0; i < K; i++) {\n            int c = sc.nextInt() - 1;\n            int d = sc.nextInt() - 1;\n            blocks.get(c).add(d);\n            blocks.get(d).add(c);\n        }\n        \n        int[] parent = new int[N];\n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            for (int j : friends.get(i)) {\n                union(parent, i, j);\n            }\n        }\n        \n        int[] size = new int[N];\n        for (int i = 0; i < N; i++) {\n            size[find(parent, i)]++;\n        }\n        \n        int[] res = new int[N];\n        for (int i = 0; i < N; i++) {\n            int cnt = size[find(parent, i)] - 1 - friends.get(i).size();\n            for (int j : blocks.get(i)) {\n                if (find(parent, i) == find(parent, j)) {\n                    cnt--;\n                }\n            }\n            res[i] = cnt;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            System.out.print(res[i] + \" \");\n        }\n    }\n    \n    private static int find(int[] parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n    \n    private static void union(int[] parent, int x, int y) {\n        int rootX = find(parent, x);\n        int rootY = find(parent, y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:37:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SocialNetworkFriendCandidates {\n    public static int[] findFriendCandidates(int N, int[][] friendships, int[][] blockships) {\n        // Create adjacency lists for friendships and blockships\n        List<Set<Integer>> friendGraph = new ArrayList<>(N + 1);\n        List<Set<Integer>> blockGraph = new ArrayList<>(N + 1);\n        \n        for (int i = 0; i <= N; i++) {\n            friendGraph.add(new HashSet<>());\n            blockGraph.add(new HashSet<>());\n        }\n        \n        // Populate friendship graph\n        for (int[] friendship : friendships) {\n            friendGraph.get(friendship[0]).add(friendship[1]);\n            friendGraph.get(friendship[1]).add(friendship[0]);\n        }\n        \n        // Populate block graph\n        for (int[] blockship : blockships) {\n            blockGraph.get(blockship[0]).add(blockship[1]);\n            blockGraph.get(blockship[1]).add(blockship[0]);\n        }\n        \n        int[] friendCandidates = new int[N + 1];\n        \n        // For each user\n        for (int user = 1; user <= N; user++) {\n            Set<Integer> visited = new HashSet<>();\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(user);\n            visited.add(user);\n            \n            // BFS to find connected users\n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                \n                // Check direct friends and their friends\n                for (int friend : friendGraph.get(current)) {\n                    if (!visited.contains(friend)) {\n                        queue.add(friend);\n                        visited.add(friend);\n                    }\n                }\n            }\n            \n            // Count friend candidates\n            for (int candidate = 1; candidate <= N; candidate++) {\n                if (candidate != user \n                    && !friendGraph.get(user).contains(candidate) \n                    && !blockGraph.get(user).contains(candidate) \n                    && visited.contains(candidate)) {\n                    friendCandidates[user]++;\n                }\n            }\n        }\n        \n        return friendCandidates;\n    }\n}",
    "timestamp": "2025-08-05 22:37:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findFriendCandidates(int N, vector<pair<int, int>>& friendships, vector<pair<int, int>>& blockships) {\n        vector<vector<int>> graph(N + 1);\n        unordered_set<int> blockedUsers[N + 1];\n        vector<int> friendCandidates(N + 1, 0);\n\n        // Build friendship graph\n        for (auto& friendship : friendships) {\n            graph[friendship.first].push_back(friendship.second);\n            graph[friendship.second].push_back(friendship.first);\n        }\n\n        // Store blocked users\n        for (auto& blockship : blockships) {\n            blockedUsers[blockship.first].insert(blockship.second);\n            blockedUsers[blockship.second].insert(blockship.first);\n        }\n\n        // Calculate friend candidates for each user\n        for (int user = 1; user <= N; user++) {\n            vector<bool> visited(N + 1, false);\n            queue<int> q;\n            q.push(user);\n            visited[user] = true;\n\n            while (!q.empty()) {\n                int current = q.front();\n                q.pop();\n\n                for (int neighbor : graph[current]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        q.push(neighbor);\n                    }\n                }\n            }\n\n            // Count friend candidates\n            for (int candidate = 1; candidate <= N; candidate++) {\n                if (candidate != user && \n                    !visited[candidate] && \n                    blockedUsers[user].count(candidate) == 0) {\n                    friendCandidates[user]++;\n                }\n            }\n        }\n\n        return friendCandidates;\n    }\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    vector<pair<int, int>> friendships(M);\n    vector<pair<int, int>> blockships(K);\n\n    for (int i = 0; i < M; i++) {\n        cin >> friendships[i].first >> friendships[i].second;\n    }\n\n    for (int i = 0; i < K; i++) {\n        cin >> blockships[i].first >> blockships[i].second;\n    }\n\n    Solution solution;\n    vector<int> result = solution.findFriendCandidates(N, friendships, blockships);\n\n    for (int i = 1; i <= N; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def friend_candidates(N, friendships, blockships):\n    from collections import defaultdict\n    \n    friend_graph = defaultdict(set)\n    block_graph = defaultdict(set)\n    \n    for a, b in friendships:\n        friend_graph[a].add(b)\n        friend_graph[b].add(a)\n        \n    for a, b in blockships:\n        block_graph[a].add(b)\n        block_graph[b].add(a)\n    \n    def bfs_connected_component(start):\n        connected_component = set()\n        queue = [start]\n        connected_component.add(start)\n        while queue:\n            node = queue.pop(0)\n            for neighbor in friend_graph[node]:\n                if neighbor not in connected_component:\n                    connected_component.add(neighbor)\n                    queue.append(neighbor)\n        return connected_component\n    \n    all_connected_components = []\n    visited = set()\n\n    for user in range(1, N + 1):\n        if user not in visited:\n            component = bfs_connected_component(user)\n            all_connected_components.append(component)\n            visited.update(component)\n    \n    friend_candidate_counts = [0] * N\n    \n    for component in all_connected_components:\n        for user in component:\n            candidates = component - friend_graph[user] - block_graph[user] - {user}\n            friend_candidate_counts[user - 1] = len(candidates)\n            \n    return friend_candidate_counts\n\n# Example usage:\nN = 5\nfriendships = [(1, 2), (2, 3)]\nblockships = [(1, 3)]\nprint(friend_candidates(N, friendships, blockships))  # Output: [1, 0, 1, 0, 0]",
    "timestamp": "2025-08-13 11:43:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FriendCandidates {\n    public static void main(String[] args) {\n        int N = 5; // Number of users\n        int M = 3; // Number of friendships\n        int K = 1; // Number of blockships\n\n        int[][] friendships = {{1, 2}, {2, 3}, {4, 5}};\n        int[][] blockships = {{1, 4}};\n\n        List<Set<Integer>> friendList = new ArrayList<>(N + 1);\n        List<Set<Integer>> blockList = new ArrayList<>(N + 1);\n\n        for (int i = 0; i <= N; i++) {\n            friendList.add(new HashSet<>());\n            blockList.add(new HashSet<>());\n        }\n\n        for (int[] friendship : friendships) {\n            int u = friendship[0];\n            int v = friendship[1];\n            friendList.get(u).add(v);\n            friendList.get(v).add(u);\n        }\n\n        for (int[] blockship : blockships) {\n            int u = blockship[0];\n            int v = blockship[1];\n            blockList.get(u).add(v);\n            blockList.get(v).add(u);\n        }\n\n        DisjointSetUnion dsu = new DisjointSetUnion(N);\n\n        for (int[] friendship : friendships) {\n            int u = friendship[0];\n            int v = friendship[1];\n            dsu.union(u, v);\n        }\n\n        int[] candidateCounts = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            int root = dsu.find(i);\n            candidateCounts[i] = dsu.size[root] - 1 - friendList.get(i).size() - blockList.get(i).size();\n        }\n\n        for (int i = 1; i <= N; i++) {\n            System.out.println(candidateCounts[i]);\n        }\n    }\n\n    static class DisjointSetUnion {\n        int[] parent;\n        int[] size;\n\n        DisjointSetUnion(int n) {\n            parent = new int[n + 1];\n            size = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                parent[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        int find(int a) {\n            if (parent[a] != a) {\n                parent[a] = find(parent[a]);\n            }\n            return parent[a];\n        }\n\n        void union(int a, int b) {\n            int rootA = find(a);\n            int rootB = find(b);\n            if (rootA != rootB) {\n                if (size[rootA] < size[rootB]) {\n                    parent[rootA] = rootB;\n                    size[rootB] += size[rootA];\n                } else {\n                    parent[rootB] = rootA;\n                    size[rootA] += size[rootB];\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 11:43:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_USERS 1000\n\nint N;  // Number of users\nint M;  // Number of friendships\nint K;  // Number of blockships\n\nbool friendship[MAX_USERS][MAX_USERS];\nbool blockship[MAX_USERS][MAX_USERS];\nbool visited[MAX_USERS];\n\nvoid dfs(int user, bool connected[]) {\n    visited[user] = true;\n    connected[user] = true;\n    \n    for (int i = 0; i < N; i++) {\n        if (!visited[i] && friendship[user][i]) {\n            dfs(i, connected);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        friendship[u - 1][v - 1] = true;\n        friendship[v - 1][u - 1] = true;\n    }\n    \n    for (int i = 0; i < K; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        blockship[u - 1][v - 1] = true;\n        blockship[v - 1][u - 1] = true;\n    }\n    \n    for (int i = 0; i < N; i++) {\n        bool connected[MAX_USERS] = {false};\n        \n        for (int j = 0; j < N; j++) {\n            visited[j] = false;\n        }\n        \n        dfs(i, connected);\n        \n        int friendCandidates = 0;\n        \n        for (int j = 0; j < N; j++) {\n            if (i != j && connected[j] && !friendship[i][j] && !blockship[i][j]) {\n                friendCandidates++;\n            }\n        }\n        \n        printf(\"%d\\n\", friendCandidates);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:44:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findFriendCandidates(N, M, friendships, K, blockships) {\n    const adjList = Array.from({ length: N + 1 }, () => []);\n    const blocked = Array.from({ length: N + 1 }, () => new Set());\n\n    friendships.forEach(([u, v]) => {\n        adjList[u].push(v);\n        adjList[v].push(u);\n    });\n\n    blockships.forEach(([u, v]) => {\n        blocked[u].add(v);\n        blocked[v].add(u);\n    });\n\n    function bfs(start) {\n        const queue = [start];\n        const visited = new Array(N + 1).fill(false);\n        visited[start] = true;\n        let connectedUsers = 0;\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n            connectedUsers++;\n\n            for (const neighbor of adjList[current]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.push(neighbor);\n                }\n            }\n        }\n\n        return visited;\n    }\n\n    const friendCandidates = Array(N + 1).fill(0);\n\n    for (let user = 1; user <= N; user++) {\n        const visited = bfs(user);\n\n        for (let otherUser = 1; otherUser <= N; otherUser++) {\n            if (user !== otherUser && visited[otherUser] && !adjList[user].includes(otherUser) && !blocked[user].has(otherUser)) {\n                friendCandidates[user]++;\n            }\n        }\n    }\n\n    return friendCandidates.slice(1);\n}\n\n// Example Usage:\n// N = number of users\n// M = number of friendships\n// friendships = array of friend pairs\n// K = number of blockships\n// blockships = array of block pairs\n// console.log(findFriendCandidates(N, M, friendships, K, blockships));",
    "timestamp": "2025-08-13 11:44:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solution(N, M, friendships, blockships):\n    # Create adjacency lists for friendships and blockships\n    friend_graph = [set() for _ in range(N+1)]\n    block_graph = [set() for _ in range(N+1)]\n    \n    # Populate friendship graph\n    for u, v in friendships:\n        friend_graph[u].add(v)\n        friend_graph[v].add(u)\n    \n    # Populate blockship graph\n    for u, v in blockships:\n        block_graph[u].add(v)\n        block_graph[v].add(u)\n    \n    # Store friend candidate count for each user\n    friend_candidates = [0] * (N+1)\n    \n    # Check friend candidates for each user\n    for user in range(1, N+1):\n        # Find reachable users through friendship graph\n        visited = set()\n        queue = [user]\n        visited.add(user)\n        \n        while queue:\n            current = queue.pop(0)\n            \n            # Check all potential candidates \n            for candidate in range(1, N+1):\n                # Skip if candidate is the same user or already a friend/blocked\n                if (candidate == current or \n                    candidate in friend_graph[user] or \n                    candidate in block_graph[user]):\n                    continue\n                \n                # If candidate is connected through friendship graph\n                if candidate in friend_graph[current]:\n                    friend_candidates[user] += 1\n                    \n                # Add unvisited friends to queue\n                for next_friend in friend_graph[current]:\n                    if next_friend not in visited:\n                        queue.append(next_friend)\n                        visited.add(next_friend)\n    \n    # Return friend candidates starting from index 1\n    return friend_candidates[1:]",
    "timestamp": "2025-08-13 11:44:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findFriendCandidates(N, friendships, blockships) {\n    // Create adjacency lists for friendships and blockships\n    const friendGraph = Array.from({ length: N + 1 }, () => new Set());\n    const blockGraph = Array.from({ length: N + 1 }, () => new Set());\n\n    // Populate friendship and blockship graphs\n    for (const [a, b] of friendships) {\n        friendGraph[a].add(b);\n        friendGraph[b].add(a);\n    }\n\n    for (const [a, b] of blockships) {\n        blockGraph[a].add(b);\n        blockGraph[b].add(a);\n    }\n\n    // Result array to store friend candidates for each user\n    const result = new Array(N + 1).fill(0);\n\n    // Check friend candidates for each user\n    for (let user = 1; user <= N; user++) {\n        const candidates = new Set();\n\n        // BFS to find connected users\n        const visited = new Array(N + 1).fill(false);\n        const queue = [user];\n        visited[user] = true;\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n\n            for (const neighbor of friendGraph[current]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.push(neighbor);\n                }\n            }\n        }\n\n        // Find potential candidates\n        for (let potentialCandidate = 1; potentialCandidate <= N; potentialCandidate++) {\n            if (\n                potentialCandidate !== user &&\n                visited[potentialCandidate] &&\n                !friendGraph[user].has(potentialCandidate) &&\n                !blockGraph[user].has(potentialCandidate)\n            ) {\n                candidates.add(potentialCandidate);\n            }\n        }\n\n        result[user] = candidates.size;\n    }\n\n    return result.slice(1);\n}",
    "timestamp": "2025-08-13 11:44:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    K = int(input[ptr])\n    ptr += 1\n\n    friend = defaultdict(set)\n    block = defaultdict(set)\n    parent = [i for i in range(N+1)]\n    size = [1]*(N+1)\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return\n        if size[u_root] > size[v_root]:\n            parent[v_root] = u_root\n            size[u_root] += size[v_root]\n        else:\n            parent[u_root] = v_root\n            size[v_root] += size[u_root]\n\n    for _ in range(M):\n        a = int(input[ptr])\n        b = int(input[ptr+1])\n        ptr += 2\n        friend[a].add(b)\n        friend[b].add(a)\n        union(a, b)\n\n    for _ in range(K):\n        c = int(input[ptr])\n        d = int(input[ptr+1])\n        ptr += 2\n        block[c].add(d)\n        block[d].add(c)\n\n    res = [0]*(N+1)\n    for u in range(1, N+1):\n        root = find(u)\n        total = size[root] - 1 - len(friend[u])\n        blocked = 0\n        for v in block[u]:\n            if find(v) == root:\n                blocked += 1\n        res[u] = total - blocked\n\n    print(' '.join(map(str, res[1:])))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 11:44:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M, K] = input[0].split(' ').map(Number);\n    const friendships = Array.from({ length: N + 1 }, () => []);\n    const blockships = Array.from({ length: N + 1 }, () => []);\n    const parent = Array(N + 1).fill().map((_, i) => i);\n    const size = Array(N + 1).fill(1);\n\n    function find(u) {\n        if (parent[u] !== u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    function union(u, v) {\n        const rootU = find(u);\n        const rootV = find(v);\n        if (rootU !== rootV) {\n            if (size[rootU] > size[rootV]) {\n                parent[rootV] = rootU;\n                size[rootU] += size[rootV];\n            } else {\n                parent[rootU] = rootV;\n                size[rootV] += size[rootU];\n            }\n        }\n    }\n\n    for (let i = 1; i <= M; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        friendships[a].push(b);\n        friendships[b].push(a);\n        union(a, b);\n    }\n\n    for (let i = M + 1; i < M + 1 + K; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        blockships[a].push(b);\n        blockships[b].push(a);\n    }\n\n    const result = [];\n    for (let i = 1; i <= N; i++) {\n        const root = find(i);\n        let count = size[root] - 1 - friendships[i].length;\n        for (const blocked of blockships[i]) {\n            if (find(blocked) === root) {\n                count--;\n            }\n        }\n        result.push(count);\n    }\n\n    console.log(result.join(' '));\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:44:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nint N, M, K;\n\nvector<vector<int>> friendships;\nvector<vector<bool>> blockships;\nvector<set<int>> friendCandidates;\n\nvoid bfs(int start)\n{\n    vector<bool> visited(N, false);\n    queue<int> q;\n    q.push(start);\n\n    while (!q.empty())\n    {\n        int curr = q.front();\n        q.pop();\n\n        for (int neighbor : friendships[curr])\n        {\n            if (!visited[neighbor] && !blockships[start][neighbor])\n            {\n                visited[neighbor] = true;\n                q.push(neighbor);\n\n                if (start != neighbor && !friendCandidates[start].count(neighbor))\n                {\n                    friendCandidates[start].insert(neighbor);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    // Input reading\n    cin >> N >> M >> K;\n\n    friendships.resize(N);\n    blockships.assign(N, vector<bool>(N, false));\n    friendCandidates.resize(N);\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        friendships[u].push_back(v);\n        friendships[v].push_back(u);\n    }\n\n    for (int i = 0; i < K; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        blockships[u][v] = true;\n        blockships[v][u] = true;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        bfs(i);\n    }\n\n    // Output the number of friend candidates for each user\n    for (int i = 0; i < N; ++i) {\n        cout << friendCandidates[i].size() << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:04:46"
  }
]