[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char top[3][3];\n    char front[3][3];\n    char bottom[3][3];\n    char back[3][3];\n    char left[3][3];\n    char right[3][3];\n} Cube;\n\nvoid rotateFront(Cube *cube) {\n    char temp[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            temp[i][j] = cube->top[i][j];\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        cube->top[2][i] = cube->left[2 - i][2];\n        cube->left[2 - i][2] = cube->bottom[0][2 - i];\n        cube->bottom[0][2 - i] = cube->right[i][0];\n        cube->right[i][0] = temp[2][i];\n    }\n    char tempFace[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            tempFace[i][j] = cube->front[2 - j][i];\n        }\n    }\n    memcpy(cube->front, tempFace, sizeof(tempFace));\n}\n\nvoid rotateBack(Cube *cube) {\n    char temp[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            temp[i][j] = cube->top[i][j];\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        cube->top[0][i] = cube->right[i][2];\n        cube->right[i][2] = cube->bottom[2][2 - i];\n        cube->bottom[2][2 - i] = cube->left[2 - i][0];\n        cube->left[2 - i][0] = temp[0][i];\n    }\n    char tempFace[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            tempFace[i][j] = cube->back[2 - j][i];\n        }\n    }\n    memcpy(cube->back, tempFace, sizeof(tempFace));\n}\n\nvoid rotateLeft(Cube *cube) {\n    char temp[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            temp[i][j] = cube->top[i][j];\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        cube->top[i][0] = cube->back[i][0];\n        cube->back[i][0] = cube->bottom[i][0];\n        cube->bottom[i][0] = cube->front[i][0];\n        cube->front[i][0] = temp[i][0];\n    }\n    char tempFace[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            tempFace[i][j] = cube->left[2 - j][i];\n        }\n    }\n    memcpy(cube->left, tempFace, sizeof(tempFace));\n}\n\nvoid rotateRight(Cube *cube) {\n    char temp[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            temp[i][j] = cube->top[i][j];\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        cube->top[i][2] = cube->front[i][2];\n        cube->front[i][2] = cube->bottom[i][2];\n        cube->bottom[i][2] = cube->back[i][2];\n        cube->back[i][2] = temp[i][2];\n    }\n    char tempFace[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            tempFace[i][j] = cube->right[2 - j][i];\n        }\n    }\n    memcpy(cube->right, tempFace, sizeof(tempFace));\n}\n\nint canPass(const Cube *cube) {\n    for (int i = 0; i < 3; i++) {\n        if (cube->front[2][i] == '1' || cube->back[2][i] == '1') {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint minRotations(Cube cube) {\n    if (canPass(&cube)) {\n        return 0;\n    }\n    int visited[6] = {0};\n    int queue[1000];\n    int front = 0, rear = 0;\n    queue[rear++] = 0;\n    visited[0] = 1;\n    int rotations = 0;\n    int currentLevel = 1;\n    int nextLevel = 0;\n    \n    while (front < rear) {\n        int current = queue[front++];\n        currentLevel--;\n        \n        Cube temp = cube;\n        for (int i = 0; i < current % 4; i++) {\n            switch (current / 4) {\n                case 0: rotateFront(&temp); break;\n                case 1: rotateBack(&temp); break;\n                case 2: rotateLeft(&temp); break;\n                case 3: rotateRight(&temp); break;\n            }\n        }\n        \n        if (canPass(&temp)) {\n            return rotations;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            int next = i * 4 + ((current % 4) + 1) % 4;\n            if (!visited[next]) {\n                visited[next] = 1;\n                queue[rear++] = next;\n                nextLevel++;\n            }\n        }\n        \n        if (currentLevel == 0) {\n            currentLevel = nextLevel;\n            nextLevel = 0;\n            rotations++;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    Cube cube;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\" %c\", &cube.top[i][j]);\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\" %c\", &cube.front[i][j]);\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\" %c\", &cube.bottom[i][j]);\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\" %c\", &cube.back[i][j]);\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\" %c\", &cube.left[i][j]);\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\" %c\", &cube.right[i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\", minRotations(cube));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<vector<char>>> faces;\n    int rotations;\n};\n\nint hashState(const vector<vector<vector<char>>>& faces) {\n    int hash = 0;\n    for (const auto& face : faces) {\n        for (const auto& row : face) {\n            for (char c : row) {\n                hash = hash * 31 + c;\n            }\n        }\n    }\n    return hash;\n}\n\nvector<vector<vector<char>>> rotateRight(const vector<vector<vector<char>>>& faces, int faceIndex) {\n    vector<vector<vector<char>>> newFaces = faces;\n    vector<vector<char>>& face = newFaces[faceIndex];\n    vector<vector<char>> rotated(3, vector<char>(3));\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            rotated[j][2 - i] = face[i][j];\n        }\n    }\n    face = rotated;\n    return newFaces;\n}\n\nbool canPass(const vector<vector<vector<char>>>& faces) {\n    const vector<vector<char>>& front = faces[0];\n    const vector<vector<char>>& back = faces[1];\n    for (int i = 0; i < 3; ++i) {\n        if (front[2][i] == '0' || back[2][i] == '0') {\n            return true;\n        }\n    }\n    return false;\n}\n\nint minRotations(vector<vector<vector<char>>> initialFaces) {\n    if (canPass(initialFaces)) {\n        return 0;\n    }\n\n    queue<State> q;\n    q.push({initialFaces, 0});\n    unordered_set<int> visited;\n    visited.insert(hashState(initialFaces));\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        for (int faceIndex = 0; faceIndex < 6; ++faceIndex) {\n            vector<vector<vector<char>>> newFaces = rotateRight(current.faces, faceIndex);\n            int newHash = hashState(newFaces);\n            if (visited.find(newHash) == visited.end()) {\n                if (canPass(newFaces)) {\n                    return current.rotations + 1;\n                }\n                visited.insert(newHash);\n                q.push({newFaces, current.rotations + 1});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    vector<vector<vector<char>>> faces(6, vector<vector<char>>(3, vector<char>(3)));\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            for (int k = 0; k < 3; ++k) {\n                cin >> faces[i][j][k];\n            }\n        }\n    }\n    cout << minRotations(faces) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DiceRoom {\n    static class Cube {\n        int[] faces; // top, front, right, back, left, bottom\n\n        public Cube(int[] faces) {\n            this.faces = faces.clone();\n        }\n\n        public Cube rotateRight() {\n            int[] newFaces = new int[]{\n                faces[3], faces[1], faces[0],\n                faces[5], faces[4], faces[2]\n            };\n            return new Cube(newFaces);\n        }\n\n        public Cube rotateLeft() {\n            int[] newFaces = new int[]{\n                faces[2], faces[1], faces[5],\n                faces[0], faces[4], faces[3]\n            };\n            return new Cube(newFaces);\n        }\n\n        public Cube rotateUp() {\n            int[] newFaces = new int[]{\n                faces[4], faces[0], faces[2],\n                faces[1], faces[5], faces[3]\n            };\n            return new Cube(newFaces);\n        }\n\n        public Cube rotateDown() {\n            int[] newFaces = new int[]{\n                faces[1], faces[5], faces[2],\n                faces[0], faces[4], faces[3]\n            };\n            return new Cube(newFaces);\n        }\n\n        public boolean canPass() {\n            return (faces[1] & 0b111000) != 0 || (faces[3] & 0b111000) != 0;\n        }\n    }\n\n    public static int minRotations(int[] cubeFaces) {\n        Queue<Cube> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        Cube initial = new Cube(cubeFaces);\n        queue.add(initial);\n        visited.add(Arrays.toString(initial.faces));\n\n        int rotations = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                Cube current = queue.poll();\n                if (current.canPass()) {\n                    return rotations;\n                }\n                Cube[] nextStates = new Cube[]{\n                    current.rotateRight(),\n                    current.rotateLeft(),\n                    current.rotateUp(),\n                    current.rotateDown()\n                };\n                for (Cube next : nextStates) {\n                    String key = Arrays.toString(next.faces);\n                    if (!visited.contains(key)) {\n                        visited.add(key);\n                        queue.add(next);\n                    }\n                }\n            }\n            rotations++;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[] cubeFaces = new int[6];\n        for (int i = 0; i < 6; i++) {\n            cubeFaces[i] = scanner.nextInt();\n        }\n        System.out.println(minRotations(cubeFaces));\n    }\n}",
    "timestamp": "2025-08-05 21:19:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass DiceRoomSolution {\n    static class State {\n        int[][] cube;\n        int rotations;\n\n        State(int[][] cube, int rotations) {\n            this.cube = cube;\n            this.rotations = rotations;\n        }\n    }\n\n    public static int minRotationsToEscape(int[][] initialCube) {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        queue.offer(new State(initialCube, 0));\n        visited.add(Arrays.deepToString(initialCube));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (canEscape(current.cube)) {\n                return current.rotations;\n            }\n\n            for (int[] rotation : getRotations()) {\n                int[][] newCube = rotate(current.cube, rotation);\n                String cubeState = Arrays.deepToString(newCube);\n\n                if (!visited.contains(cubeState)) {\n                    visited.add(cubeState);\n                    queue.offer(new State(newCube, current.rotations + 1));\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean canEscape(int[][] cube) {\n        return cube[2][0] == 1 || cube[2][1] == 1 || cube[2][2] == 1 ||\n               cube[5][0] == 1 || cube[5][1] == 1 || cube[5][2] == 1;\n    }\n\n    private static int[][] rotate(int[][] cube, int[] rotation) {\n        int[][] newCube = new int[6][3];\n        for (int i = 0; i < 6; i++) {\n            System.arraycopy(cube[i], 0, newCube[i], 0, 3);\n        }\n\n        if (rotation[0] == 1) {  // rotate front clockwise\n            rotateFace(newCube, 0);\n            int temp = newCube[4][0];\n            newCube[4][0] = newCube[2][2];\n            newCube[2][2] = newCube[5][2];\n            newCube[5][2] = newCube[3][0];\n            newCube[3][0] = temp;\n        }\n        // Add other rotation logic similarly\n\n        return newCube;\n    }\n\n    private static void rotateFace(int[][] cube, int face) {\n        int[] temp = {cube[face][0], cube[face][1], cube[face][2]};\n        cube[face][0] = temp[2];\n        cube[face][1] = temp[1];\n        cube[face][2] = temp[0];\n    }\n\n    private static int[][] getRotations() {\n        return new int[][]{\n            {1, 0, 0, 0, 0, 0},  // front clockwise\n            {0, 1, 0, 0, 0, 0},  // right clockwise\n            // Add other rotation possibilities\n        };\n    }\n}",
    "timestamp": "2025-08-05 21:19:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define SIDE 3\n#define MAXROT 4\n\ntypedef struct {\n    int grid[SIDE][SIDE];\n    int front, top, right;\n} Cube;\n\nint bfs(Cube start) {\n    Cube queue[10000];\n    int visited[6][6][6][6] = {0};\n    int front = 0, rear = 0;\n    int steps[10000];\n\n    queue[rear] = start;\n    steps[rear] = 0;\n    rear++;\n\n    while (front < rear) {\n        Cube current = queue[front];\n        int currentSteps = steps[front];\n\n        if (current.grid[2][0] == 0 || current.grid[2][1] == 0 || current.grid[2][2] == 0 ||\n            current.grid[0][0] == 0 || current.grid[0][1] == 0 || current.grid[0][2] == 0) {\n            return currentSteps;\n        }\n\n        int dirs[4][3] = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}};\n        for (int d = 0; d < 4; d++) {\n            Cube next = current;\n            \n            if (dirs[d][0] == 1) {\n                int temp = next.top;\n                next.top = next.front;\n                next.front = 7 - temp;\n            } else if (dirs[d][0] == -1) {\n                int temp = next.top;\n                next.top = 7 - next.front;\n                next.front = temp;\n            } else if (dirs[d][1] == 1) {\n                int temp = next.top;\n                next.top = next.right;\n                next.right = 7 - temp;\n            } else {\n                int temp = next.top;\n                next.top = 7 - next.right;\n                next.right = temp;\n            }\n\n            if (!visited[next.front][next.top][next.right][0]) {\n                queue[rear] = next;\n                steps[rear] = currentSteps + 1;\n                visited[next.front][next.top][next.right][0] = 1;\n                rear++;\n            }\n        }\n        front++;\n    }\n    return -1;\n}\n\nint main() {\n    Cube start;\n    for (int i = 0; i < SIDE; i++) {\n        for (int j = 0; j < SIDE; j++) {\n            scanf(\"%d\", &start.grid[i][j]);\n        }\n    }\n    start.front = 1;\n    start.top = 2;\n    start.right = 3;\n\n    int result = bfs(start);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:19:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass DiceState {\npublic:\n    vector<vector<int>> grid;\n    int rotations;\n    int top, front, right;\n\n    DiceState(vector<vector<int>> g, int r, int t, int f, int rt) : \n        grid(g), rotations(r), top(t), front(f), right(rt) {}\n\n    bool canPass() {\n        return grid[2][0] == 0 || grid[2][1] == 0 || grid[2][2] == 0 ||\n               grid[0][0] == 0 || grid[0][1] == 0 || grid[0][2] == 0;\n    }\n\n    vector<DiceState> getNextStates() {\n        vector<DiceState> states;\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n        for (auto [dx, dy] : dirs) {\n            vector<vector<int>> newGrid = grid;\n            int newTop = top, newFront = front, newRight = right;\n\n            // Rotation logic\n            if (dx == 1) {  // Down rotation\n                newTop = 7 - front;\n                newFront = top;\n            } else if (dx == -1) {  // Up rotation\n                newTop = front;\n                newFront = 7 - top;\n            } else if (dy == 1) {  // Right rotation\n                newTop = 7 - right;\n                newRight = top;\n            } else {  // Left rotation\n                newTop = right;\n                newRight = 7 - top;\n            }\n\n            states.push_back(DiceState(newGrid, rotations + 1, newTop, newFront, newRight));\n        }\n        return states;\n    }\n};\n\nint solveDiceRoom(vector<vector<int>> grid) {\n    queue<DiceState> q;\n    q.push(DiceState(grid, 0, 1, 2, 3));\n    \n    while (!q.empty()) {\n        DiceState current = q.front();\n        q.pop();\n\n        if (current.canPass()) {\n            return current.rotations;\n        }\n\n        for (DiceState nextState : current.getNextStates()) {\n            q.push(nextState);\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    vector<vector<int>> grid = {{1,1,1},{1,0,1},{1,1,1}};\n    cout << solveDiceRoom(grid) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:19:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_rotations_to_enable_passage(front, back):\n    # Check the lower three squares of the front and back for holes.\n    def has_hole(squares):\n        return any(squares[i] == 'hole' for i in range(6, 9))\n\n    rotations = 0\n    # Check if the initial orientation has holes in the lower part\n    if has_hole(front) or has_hole(back):\n        return rotations\n\n    # Rotate the cube 4 times along x-axis (Front <-> Bottom <-> Back <-> Top)\n    for _ in range(3):\n        front, back = back[:3][::-1] + back[3:6][::-1] + back[6:9][::-1], front[:3][::-1] + front[3:6][::-1] + front[6:9][::-1]\n        rotations += 1\n        if has_hole(front) or has_hole(back):\n            return rotations\n\n    # Rotate the cube 4 times along y-axis (Left <-> Front <-> Right <-> Back)\n    front, back = back, front  # parallel configuration\n    for _ in range(3):\n        front, back = back[:3][::-1] + back[3:6][::-1] + back[6:9][::-1], front[:3][::-1] + front[3:6][::-1] + front[6:9][::-1]\n        rotations += 1\n        if has_hole(front) or has_hole(back):\n            return rotations\n\n    return -1\n\n# Example usage\nfront_surface = ['solid', 'solid', 'solid', 'solid', 'solid', 'solid', 'solid', 'solid', 'hole']\nback_surface = ['solid', 'solid', 'solid', 'solid', 'solid', 'solid', 'solid', 'solid', 'solid']\n\nprint(min_rotations_to_enable_passage(front_surface, back_surface))",
    "timestamp": "2025-08-13 05:51:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DiceRoomEscape {\n    \n    // A class to represent the 3x3 face of the cube\n    private static class Face {\n        int[][] grid;\n        \n        Face(int[][] grid) {\n            this.grid = grid;\n        }\n        \n        boolean hasBottomHole() {\n            for (int i = 0; i < 3; i++) {\n                if (grid[2][i] == 1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        void rotateClockwise() {\n            int[][] newGrid = new int[3][3];\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    newGrid[j][2 - i] = grid[i][j];\n                }\n            }\n            grid = newGrid;\n        }\n    }\n    \n    // A function to find if any rotation gives the needed condition\n    private static boolean isPassable(Face front, Face back) {\n        for (int i = 0; i < 4; i++) {\n            if (front.hasBottomHole() || back.hasBottomHole()) {\n                return true;\n            }\n            front.rotateClockwise();\n            back.rotateClockwise();\n        }\n        return false;\n    }\n    \n    public static int minRotationsToPass(int[][] frontGrid, int[][] backGrid) {\n        Face front = new Face(frontGrid);\n        Face back = new Face(backGrid);\n        \n        if (front.hasBottomHole() || back.hasBottomHole()) {\n            return 0;\n        }\n        \n        for (int rotations = 1; rotations <= 3; rotations++) {\n            front.rotateClockwise();\n            back.rotateClockwise();\n            if (isPassable(front, back)) {\n                return rotations;\n            }\n        }\n        \n        return -1; // Impossible to pass\n    }\n    \n    public static void main(String[] args) {\n        int[][] frontGrid = {\n            {0, 0, 0},\n            {0, 1, 0},\n            {0, 0, 0}\n        };\n        int[][] backGrid = {\n            {1, 0, 1},\n            {0, 0, 0},\n            {1, 0, 0}\n        };\n\n        int rotations = minRotationsToPass(frontGrid, backGrid);\n        System.out.println(rotations);\n    }\n}",
    "timestamp": "2025-08-13 05:51:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define FRONT 0\n#define BACK 1\n#define NUM_FACES 6\n\ntypedef struct {\n    bool squares[3][3];\n} Face;\n\nbool checkLower(Face faces[NUM_FACES], int faceIndex) {\n    return faces[faceIndex].squares[2][0] || faces[faceIndex].squares[2][1] || faces[faceIndex].squares[2][2];\n}\n\nbool canPass(Face faces[NUM_FACES]) {\n    return checkLower(faces, FRONT) || checkLower(faces, BACK);\n}\n\nvoid rotateClockwise(Face* face) {\n    bool temp[3][3];\n    for(int i = 0; i < 3; ++i)\n        for(int j = 0; j < 3; ++j)\n            temp[j][2 - i] = face->squares[i][j];\n    \n    for(int i = 0; i < 3; ++i)\n        for(int j = 0; j < 3; ++j)\n            face->squares[i][j] = temp[i][j];\n}\n\nvoid rotateCube(Face faces[NUM_FACES]) {\n    Face temp[NUM_FACES];\n    for (int i = 0; i < NUM_FACES; ++i) temp[i] = faces[i];\n\n    // Rotate front face to right\n    faces[FRONT] = temp[2];\n    faces[2] = temp[4];\n    faces[4] = temp[5];\n    faces[5] = temp[FRONT];\n\n    // Rotate left and right faces\n    rotateClockwise(&faces[1]);\n    for (int i = 0; i < 3; i++) rotateClockwise(&faces[3]);\n}\n\nint minRotationsToPass(Face faces[NUM_FACES]) {\n    int minRotations = 4;\n    for (int i = 0; i < 4; ++i) {\n        if (canPass(faces)) {\n            minRotations = i;\n            break;\n        }\n        rotateCube(faces);\n    }\n    return minRotations;\n}\n\nint main() {\n    Face faces[NUM_FACES];\n\n    // Example Input: Initialize faces with some data\n    for (int i = 0; i < NUM_FACES; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            for (int k = 0; k < 3; ++k) {\n                faces[i].squares[j][k] = (i == FRONT || i == BACK) && (j == 2);  // Sample input where back or front lower row is open\n            }\n        }\n    }\n\n    int result = minRotationsToPass(faces);\n    printf(\"Minimum rotations needed: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:51:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_dice_room(grid):\n    # Represent the cube's orientation using a tuple\n    # (front, top, right, left, bottom, back)\n    initial_state = ('front', 'top', 'right', 'left', 'bottom', 'back')\n    \n    # Possible rotations\n    rotations = {\n        'front': {\n            'clockwise': ('left', 'top', 'front', 'back', 'bottom', 'right'),\n            'counterclockwise': ('right', 'top', 'front', 'back', 'bottom', 'left')\n        },\n        'back': {\n            'clockwise': ['right', 'top', 'front', 'back', 'bottom', 'left'],\n            'counterclockwise': ['left', 'top', 'front', 'back', 'bottom', 'right']\n        }\n    }\n    \n    def can_pass(orientation):\n        front_idx = orientation.index('front')\n        back_idx = orientation.index('back')\n        \n        for i in range(3):\n            if grid[front_idx][i] == 1 or grid[back_idx][i] == 1:\n                return True\n        return False\n    \n    visited = set()\n    queue = deque([(initial_state, 0)])\n    \n    while queue:\n        current_orientation, rotations_count = queue.popleft()\n        \n        if can_pass(current_orientation):\n            return rotations_count\n        \n        if current_orientation in visited:\n            continue\n        \n        visited.add(current_orientation)\n        \n        for face in ['front', 'back']:\n            for direction in ['clockwise', 'counterclockwise']:\n                new_orientation = rotations[face][direction]\n                if new_orientation not in visited:\n                    queue.append((new_orientation, rotations_count + 1))\n    \n    return -1  # No passage possible",
    "timestamp": "2025-08-13 05:51:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    from collections import deque\n\n    # Read input\n    cube = []\n    for _ in range(6):\n        face = [list(sys.stdin.readline().strip()) for _ in range(3)]\n        cube.append(face)\n\n    # Define rotations: up, down, left, right\n    # Each rotation affects specific faces in a specific order\n    rotations = [\n        # Rotate up (front, top, back, bottom)\n        ([0, 1, 2, 3], [(2, 0), (2, 1), (2, 2)], [(0, 0), (0, 1), (0, 2)], [(0, 0), (0, 1), (0, 2)], [(2, 0), (2, 1), (2, 2)]),\n        # Rotate down (front, bottom, back, top)\n        ([0, 3, 2, 1], [(0, 0), (0, 1), (0, 2)], [(2, 0), (2, 1), (2, 2)], [(2, 0), (2, 1), (2, 2)], [(0, 0), (0, 1), (0, 2)]),\n        # Rotate left (front, left, back, right)\n        ([0, 4, 2, 5], [(0, 0), (1, 0), (2, 0)], [(0, 0), (1, 0), (2, 0)], [(2, 2), (1, 2), (0, 2)], [(0, 0), (1, 0), (2, 0)]),\n        # Rotate right (front, right, back, left)\n        ([0, 5, 2, 4], [(2, 2), (1, 2), (0, 2)], [(0, 2), (1, 2), (2, 2)], [(0, 0), (1, 0), (2, 0)], [(2, 2), (1, 2), (0, 2)])\n    ]\n\n    # Check if current cube state is valid\n    def is_valid(cube):\n        front = cube[0]\n        back = cube[2]\n        # Check lower three squares on front and back\n        for i in [1, 2]:\n            for j in [0, 1, 2]:\n                if front[i][j] == '0' or back[i][j] == '0':\n                    return True\n        return False\n\n    # Perform a rotation\n    def rotate(cube, rot):\n        faces, src1, src2, src3, src4 = rot\n        new_cube = [face.copy() for face in cube]\n        f1, f2, f3, f4 = faces\n        # Copy the edges\n        temp = [cube[f1][i][j] for (i, j) in src1]\n        for idx, (i, j) in enumerate(src1):\n            new_cube[f1][i][j] = cube[f4][src4[idx][0]][src4[idx][1]]\n        for idx, (i, j) in enumerate(src2):\n            new_cube[f2][i][j] = cube[f1][src1[idx][0]][src1[idx][1]]\n        for idx, (i, j) in enumerate(src3):\n            new_cube[f3][i][j] = cube[f2][src2[idx][0]][src2[idx][1]]\n        for idx, (i, j) in enumerate(src4):\n            new_cube[f4][i][j] = temp[idx]\n        return new_cube\n\n    # BFS setup\n    visited = set()\n    queue = deque()\n    initial_state = tuple(tuple(tuple(row) for row in face) for face in cube)\n    queue.append((initial_state, 0))\n    visited.add(initial_state)\n\n    while queue:\n        current_state, steps = queue.popleft()\n        current_cube = [ [list(row) for row in face] for face in current_state ]\n        if is_valid(current_cube):\n            print(steps)\n            return\n        for rot in rotations:\n            new_cube = rotate(current_cube, rot)\n            new_state = tuple(tuple(tuple(row) for row in face) for face in new_cube)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, steps + 1))\n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 05:52:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Cube {\n    int front, back, left, right, top, bottom;\n    \n    Cube(int f, int b, int l, int r, int t, int bo): \n        front(f), back(b), left(l), right(r), top(t), bottom(bo) {}\n    \n    Cube rotateX() const { return Cube(top, bottom, left, right, back, front); }\n    Cube rotateY() const { return Cube(left, right, bottom, top, back, front); }\n    Cube rotateZ() const { return Cube(front, back, top, bottom, right, left); }\n};\n\nbool checkPassage(const vector<vector<int>>& holes, int f, int b) {\n    for (int i = 3; i <= 5; ++i) {\n        if (holes[f][i] || holes[b][i]) return true;\n    }\n    return false;\n}\n\nint minRotationsToPassage(const vector<vector<int>>& holes) {\n    queue<pair<Cube, int>> q;\n    set<Cube> visited;\n\n    Cube initial(0, 1, 2, 3, 4, 5);\n    q.push({initial, 0});\n    visited.insert(initial);\n\n    while (!q.empty()) {\n        auto [current, steps] = q.front(); q.pop();\n        if (checkPassage(holes, current.front, current.back)) return steps;\n        \n        Cube x = current.rotateX();\n        Cube y = current.rotateY();\n        Cube z = current.rotateZ();\n\n        if (visited.find(x) == visited.end()) {\n            q.push({x, steps + 1});\n            visited.insert(x);\n        }\n        if (visited.find(y) == visited.end()) {\n            q.push({y, steps + 1});\n            visited.insert(y);\n        }\n        if (visited.find(z) == visited.end()) {\n            q.push({z, steps + 1});\n            visited.insert(z);\n        }\n    }\n    return -1; // If no valid configuration is found\n}\n\nint main() {\n    vector<vector<int>> holes(6, vector<int>(9, 0));\n    \n    // Read input configuration of holes\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            cin >> holes[i][j];\n        }\n    }\n    \n    int result = minRotationsToPassage(holes);\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:28:48"
  }
]