[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// z軸を中心に右回転\nint rotateRight[]={0,1,3,5,2,4,6};\n// z軸を中心に左回転\nint rotateLeft[]={0,1,4,2,5,3,6};\n// 回転させてマッチするfaceを探す\n// curFaceに結果を代入\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // 左へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // 前へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)nfield[l][2-k]=field[i-1][j][k][l];\n        // fieldを回転させる\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)field[i][j][k][l]=nfield[l][k];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      int cnt2=0;\n      if(label[front]>=1&&label[front]<=4){\n        if(ang==0||ang==2){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n      }\n      else{\n        for(int j=0;j<3;j++)cnt1+=(field[(ang+2)%4][label[front]][2][j]=='*');\n        for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n      }\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // 面を四方向に回転\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // 前\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // 後ろ\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\n/*\n 4\n 0 1 2 3\n 5\n ????????????????±????????????§????????????????¨?????????§????????????\n */\n\nbitset<4> cw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+1)%4] = b[i];\n  return nb;\n}\n\nbitset<4> ccw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+3)%4] = b[i];\n  return nb;\n}\n\nstruct state{\n  vector<bitset<4>> b;\n  state(){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n  }\n  state(const state &s){\n    b = s.b; // copy\n  }\n  state(int hash){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n    rep(i,6) rep(j,4){\n      b[5-i][3-j] = hash%2;\n      hash/=2;\n    }\n  }\n  int hash(){\n    int h = 0;\n    rep(i,6) rep(j,4) h = (h<<1) + b[i][j];\n    return h;\n  }\n  bitset<4>& operator[](int i){ return b[i]; }\n\n  void front(){ // ???????????????\n    vector<bitset<4>> nb(6);\n    nb[0] = b[4];\n    nb[1] = ccw(b[1]);\n    nb[2] = cw(cw(b[5]));\n    nb[3] = cw(b[3]);\n    nb[4] = cw(cw(b[2]));\n    nb[5] = b[0];\n    swap(nb, b);\n  }\n  void right(){\n    vector<bitset<4>> nb(6);\n    nb[0] = cw(b[0]);\n    nb[1] = cw(b[4]);\n    nb[2] = ccw(b[2]);\n    nb[3] = cw(b[5]);\n    nb[4] = cw(b[3]);\n    nb[5] = cw(b[1]);\n    swap(nb,b);\n  }\n\n  bool ok(){\n    return b[0][2] & b[2][2];\n  }\n};\n\nint d[1<<24];\n\nint main(){\n  while(true){\n    state st;\n    rep(i,6){\n      string t[3];\n      rep(j,3){\n        cin>>t[j];\n        if(t[0]==\"#\") return 0;\n      }\n      st[i][0] = t[0][0]=='*' || t[0][1]=='*' || t[0][2]=='*';\n      st[i][1] = t[0][2]=='*' || t[1][2]=='*' || t[2][2]=='*';\n      st[i][2] = t[2][0]=='*' || t[2][1]=='*' || t[2][2]=='*';\n      st[i][3] = t[0][0]=='*' || t[1][0]=='*' || t[2][0]=='*';\n    }\n\n    fill(d, d+(1<<24), INF);\n    queue<int> q;\n    q.push(st.hash());\n    d[st.hash()] = 0;\n    int ans;\n    bool flg = true;\n    while(flg){ assert(!q.empty());\n      int h = q.front(); q.pop();\n      state s(h);\n      if(s.ok()){\n        ans = d[h];\n        break;\n      }\n      int nd = d[h]+1;\n      auto exec = [&](state &S){\n        if(S.ok()){\n          ans = nd;\n          flg=false;\n          return;\n        }\n        int hs = S.hash();\n        if(d[hs] > nd){\n          q.push(hs);\n          d[hs] = nd;\n        }\n      };\n\n      state s1(s);\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.front();\n      exec(s1);\n      s1.front();\n      s1.front();\n      exec(s1);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 6\nusing namespace std;\ntypedef pair<int,string> P;\n\nstring rot_N(string s){\n  \n  string t=s;\n  \n  t[9*4+0]=s[0];\n  t[9*4+1]=s[1];\n  t[9*4+2]=s[2];\n  t[9*4+3]=s[3];\n  t[9*4+4]=s[4];\n  t[9*4+5]=s[5];\n  t[9*4+6]=s[6];\n  t[9*4+7]=s[7];\n  t[9*4+8]=s[8];\n  \n  t[9*2+0]=s[9*4+8];\n  t[9*2+1]=s[9*4+7];\n  t[9*2+2]=s[9*4+6];\n  t[9*2+3]=s[9*4+5];\n  t[9*2+4]=s[9*4+4];\n  t[9*2+5]=s[9*4+3];\n  t[9*2+6]=s[9*4+2];\n  t[9*2+7]=s[9*4+1];\n  t[9*2+8]=s[9*4+0];\n  \n  t[9*5+0]=s[9*2+8];\n  t[9*5+1]=s[9*2+7];\n  t[9*5+2]=s[9*2+6];\n  t[9*5+3]=s[9*2+5];\n  t[9*5+4]=s[9*2+4];\n  t[9*5+5]=s[9*2+3];\n  t[9*5+6]=s[9*2+2];\n  t[9*5+7]=s[9*2+1];\n  t[9*5+8]=s[9*2+0];\n\n  t[0]=s[9*5+0];\n  t[1]=s[9*5+1];\n  t[2]=s[9*5+2];\n  t[3]=s[9*5+3];\n  t[4]=s[9*5+4];\n  t[5]=s[9*5+5];\n  t[6]=s[9*5+6];\n  t[7]=s[9*5+7];\n  t[8]=s[9*5+8];\n  \n  t[9+0]=s[9+6];\n  t[9+1]=s[9+3];\n  t[9+2]=s[9+0];\n  t[9+3]=s[9+7];\n  t[9+4]=s[9+4];\n  t[9+5]=s[9+1];\n  t[9+6]=s[9+8];\n  t[9+7]=s[9+5];\n  t[9+8]=s[9+2];\n  \n  t[9*3+0]=s[9*3+2];\n  t[9*3+1]=s[9*3+5];\n  t[9*3+2]=s[9*3+8];\n  t[9*3+3]=s[9*3+1];\n  t[9*3+4]=s[9*3+4];\n  t[9*3+5]=s[9*3+7];\n  t[9*3+6]=s[9*3+0];\n  t[9*3+7]=s[9*3+3];\n  t[9*3+8]=s[9*3+6];\n  \n  return t;\n}\n\nstring rot_E(string s){\n  \n  string t=s;\n  \n  t[9+0]=s[9*4+6];\n  t[9+1]=s[9*4+3];\n  t[9+2]=s[9*4+0];\n  t[9+3]=s[9*4+7];\n  t[9+4]=s[9*4+4];\n  t[9+5]=s[9*4+1];\n  t[9+6]=s[9*4+8];\n  t[9+7]=s[9*4+5];\n  t[9+8]=s[9*4+2];\n  \n  t[9*5+0]=s[9+6];\n  t[9*5+1]=s[9+3];\n  t[9*5+2]=s[9+0];\n  t[9*5+3]=s[9+7];\n  t[9*5+4]=s[9+4];\n  t[9*5+5]=s[9+1];\n  t[9*5+6]=s[9+8];\n  t[9*5+7]=s[9+5];\n  t[9*5+8]=s[9+2];\n  \n  t[9*3+0]=s[9*5+6];\n  t[9*3+1]=s[9*5+3];\n  t[9*3+2]=s[9*5+0];\n  t[9*3+3]=s[9*5+7];\n  t[9*3+4]=s[9*5+4];\n  t[9*3+5]=s[9*5+1];\n  t[9*3+6]=s[9*5+8];\n  t[9*3+7]=s[9*5+5];\n  t[9*3+8]=s[9*5+2];\n  \n  t[9*4+0]=s[9*3+6];\n  t[9*4+1]=s[9*3+3];\n  t[9*4+2]=s[9*3+0];\n  t[9*4+3]=s[9*3+7];\n  t[9*4+4]=s[9*3+4];\n  t[9*4+5]=s[9*3+1];\n  t[9*4+6]=s[9*3+8];\n  t[9*4+7]=s[9*3+5];\n  t[9*4+8]=s[9*3+2];\n  \n  t[0]=s[6];\n  t[1]=s[3];\n  t[2]=s[0];\n  t[3]=s[7];\n  t[4]=s[4];\n  t[5]=s[1];\n  t[6]=s[8];\n  t[7]=s[5];\n  t[8]=s[2];\n\n  t[9*2+0]=s[9*2+2];\n  t[9*2+1]=s[9*2+5];\n  t[9*2+2]=s[9*2+8];\n  t[9*2+3]=s[9*2+1];\n  t[9*2+4]=s[9*2+4];\n  t[9*2+5]=s[9*2+7];\n  t[9*2+6]=s[9*2+0];\n  t[9*2+7]=s[9*2+3];\n  t[9*2+8]=s[9*2+6];\n  \n  return t;\n}\n\n\nstring rot_S(string s){\n  s=rot_N(s); s=rot_N(s); s=rot_N(s);\n  return s;\n}\n\nstring rot_W(string s){\n  s=rot_E(s); s=rot_E(s); s=rot_E(s);\n  return s;\n}\n\nbool check(string s){\n  return (s[6]=='*'||s[7]=='*'||s[8]=='*')&&(s[9*2+6]=='*'||s[9*2+7]=='*'||s[9*2+8]=='*');\n}\n\n/*\n  \n  012\n  345\n  678\n  [4]\n  \n  012 012 012 012\n  345 345 345 345\n  678 678 678 678\n  [0] [1] [2] [3]\n  \n  012\n  345\n  678\n  [5]\n  \n*/\n\nqueue<P> q;\nset<string> memo;\n\nint bfs(){\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    string s=t.second;\n\n    if(memo.count(s)) continue;\n    memo.insert(s);\n    \n    int cnt=t.first;\n    \n    if(check(s)) return cnt;\n    \n    string ns;\n    \n    ns=rot_N(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_E(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_S(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_W(s);\n    q.push(P(cnt+1,ns));\n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    string s,t;\n\n    cin>>t;\n    if(t==\"#\") break;\n    \n    s+=t;\n    \n    for(int i=0;i<17;i++){\n      cin>>t;\n      s+=t;\n    }\n\n    q.push(P(0,s));\n    \n    cout<<bfs()<<endl;\n\n    while(!q.empty())  q.pop();\n  }\n  \n  return 0;\n}\n\n/*\n\n  L(???,R(?,????????))\n\n  L(R(?,R(?,????)),?))\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\nstruct Dice{\n\tchar t[3][3],s[3][3],e[3][3],w[3][3],n[3][3],b[3][3];\n};\n\nvoid rotx(Dice &d){\n\tDice t=d;\n\td.t[0][0]=t.w[2][0];\td.t[0][1]=t.w[1][0];\td.t[0][2]=t.w[0][0];\n\td.t[1][0]=t.w[2][1];\td.t[1][1]=t.w[1][1];\td.t[1][2]=t.w[0][1];\n\td.t[2][0]=t.w[2][2];\td.t[2][1]=t.w[1][2];\td.t[2][2]=t.w[0][2];\n\td.s[0][0]=t.s[2][0];\td.s[0][1]=t.s[1][0];\td.s[0][2]=t.s[0][0];\n\td.s[1][0]=t.s[2][1];\td.s[1][1]=t.s[1][1];\td.s[1][2]=t.s[0][1];\n\td.s[2][0]=t.s[2][2];\td.s[2][1]=t.s[1][2];\td.s[2][2]=t.s[0][2];\n\td.e[0][0]=t.t[2][0];\td.e[0][1]=t.t[1][0];\td.e[0][2]=t.t[0][0];\n\td.e[1][0]=t.t[2][1];\td.e[1][1]=t.t[1][1];\td.e[1][2]=t.t[0][1];\n\td.e[2][0]=t.t[2][2];\td.e[2][1]=t.t[1][2];\td.e[2][2]=t.t[0][2];\n\td.w[0][0]=t.b[2][0];\td.w[0][1]=t.b[1][0];\td.w[0][2]=t.b[0][0];\n\td.w[1][0]=t.b[2][1];\td.w[1][1]=t.b[1][1];\td.w[1][2]=t.b[0][1];\n\td.w[2][0]=t.b[2][2];\td.w[2][1]=t.b[1][2];\td.w[2][2]=t.b[0][2];\n\td.n[0][0]=t.n[0][2];\td.n[0][1]=t.n[1][2];\td.n[0][2]=t.n[2][2];\n\td.n[1][0]=t.n[0][1];\td.n[1][1]=t.n[1][1];\td.n[1][2]=t.n[2][1];\n\td.n[2][0]=t.n[0][0];\td.n[2][1]=t.n[1][0];\td.n[2][2]=t.n[2][0];\n\td.b[0][0]=t.e[2][0];\td.b[0][1]=t.e[1][0];\td.b[0][2]=t.e[0][0];\n\td.b[1][0]=t.e[2][1];\td.b[1][1]=t.e[1][1];\td.b[1][2]=t.e[0][1];\n\td.b[2][0]=t.e[2][2];\td.b[2][1]=t.e[1][2];\td.b[2][2]=t.e[0][2];\n}\n\nvoid roty(Dice &d){\n\tDice t=d;\n\td.t[0][0]=t.s[0][0];\td.t[0][1]=t.s[0][1];\td.t[0][2]=t.s[0][2];\n\td.t[1][0]=t.s[1][0];\td.t[1][1]=t.s[1][1];\td.t[1][2]=t.s[1][2];\n\td.t[2][0]=t.s[2][0];\td.t[2][1]=t.s[2][1];\td.t[2][2]=t.s[2][2];\n\td.s[0][0]=t.b[0][0];\td.s[0][1]=t.b[0][1];\td.s[0][2]=t.b[0][2];\n\td.s[1][0]=t.b[1][0];\td.s[1][1]=t.b[1][1];\td.s[1][2]=t.b[1][2];\n\td.s[2][0]=t.b[2][0];\td.s[2][1]=t.b[2][1];\td.s[2][2]=t.b[2][2];\n\td.e[0][0]=t.e[2][0];\td.e[0][1]=t.e[1][0];\td.e[0][2]=t.e[0][0];\n\td.e[1][0]=t.e[2][1];\td.e[1][1]=t.e[1][1];\td.e[1][2]=t.e[0][1];\n\td.e[2][0]=t.e[2][2];\td.e[2][1]=t.e[1][2];\td.e[2][2]=t.e[0][2];\n\td.w[0][0]=t.w[0][2];\td.w[0][1]=t.w[1][2];\td.w[0][2]=t.w[2][2];\n\td.w[1][0]=t.w[0][1];\td.w[1][1]=t.w[1][1];\td.w[1][2]=t.w[2][1];\n\td.w[2][0]=t.w[0][0];\td.w[2][1]=t.w[1][0];\td.w[2][2]=t.w[2][0];\n\td.n[0][0]=t.t[2][2];\td.n[0][1]=t.t[2][1];\td.n[0][2]=t.t[2][0];\n\td.n[1][0]=t.t[1][2];\td.n[1][1]=t.t[1][1];\td.n[1][2]=t.t[1][0];\n\td.n[2][0]=t.t[0][2];\td.n[2][1]=t.t[0][1];\td.n[2][2]=t.t[0][0];\n\td.b[0][0]=t.n[2][2];\td.b[0][1]=t.n[2][1];\td.b[0][2]=t.n[2][0];\n\td.b[1][0]=t.n[1][2];\td.b[1][1]=t.n[1][1];\td.b[1][2]=t.n[1][0];\n\td.b[2][0]=t.n[0][2];\td.b[2][1]=t.n[0][1];\td.b[2][2]=t.n[0][0];\n}\n\nbool canThrough(const Dice &d){\n\treturn (d.s[2][0]=='*' || d.s[2][1]=='*' || d.s[2][2]=='*')&&(d.n[2][0]=='*' || d.n[2][1]=='*' || d.n[2][2]=='*');\n}\n\nint main(){\n\twhile(1){\n\t\tDice dice;\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)\tscanf(\"%c \",&dice.s[i][j]);\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)\tscanf(\"%c \",&dice.e[i][j]);\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)\tscanf(\"%c \",&dice.n[i][j]);\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)\tscanf(\"%c \",&dice.w[i][j]);\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)\tscanf(\"%c \",&dice.t[i][j]);\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)\tscanf(\"%c \",&dice.b[i][j]);\n\t\tif(dice.s[0][0]=='#')\tbreak;\n\n\t\tint ans;\n\t\tqueue< pair<int,Dice> > qu;\tqu.push(mp(0,dice));\n\t\twhile(1){\n\t\t\tpair<int,Dice> a=qu.front();\tqu.pop();\n\t\t\tint cnt=a.first;\n\t\t\tDice dice=a.second;\n\t\t\tif(canThrough(dice)){ ans=cnt; break; }\n\n\t\t\tDice nextdice=dice;\n\t\t\trotx(nextdice);\n\t\t\tqu.push(mp(cnt+1,nextdice));\n\t\t\tnextdice=dice;\n\t\t\troty(nextdice);\n\t\t\tqu.push(mp(cnt+1,nextdice));\n\t\t\tnextdice=dice;\n\t\t\trotx(nextdice),rotx(nextdice),rotx(nextdice);\n\t\t\tqu.push(mp(cnt+1,nextdice));\n\t\t\tnextdice=dice;\n\t\t\troty(nextdice),roty(nextdice),roty(nextdice);\n\t\t\tqu.push(mp(cnt+1,nextdice));\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int p[4][3] = {{0, 1, 2}, {0, 3, 6}, {2, 5, 8}, {6, 7, 8}};\n\nbool check(int front, int back, int k, vector<string>& s) {\n    bool f = false, b = false;\n    for(int i=0; i<3; ++i) {\n        f |= s[front][p[k][i]] == '*';\n        b |= s[back][p[k][i]] == '*';\n    }\n    return f && b;\n}\n\nint main() {\n    string t;\n    while(cin >> t, t != \"#\") {\n        vector<string> v(6);\n        v[0] += t;\n        for(int i=0; i<6; ++i) {\n            for(int j=0; j<3 - (i == 0); ++j) {\n                string s;\n                cin >> s;\n                v[i] += s;\n            }\n        }\n        for(int i=0; i<9; i += 3) {\n            reverse(v[1].begin()+i, v[1].begin()+i+3);\n            reverse(v[2].begin()+i, v[2].begin()+i+3);\n        }\n        for(int i=0; i<3; ++i) {\n            swap(v[5][i], v[5][i+6]);\n        }\n        int res = 4;\n        if(check(0, 2, 0, v)) {\n            res = min(res, 2);\n        }\n        if(check(0, 2, 1, v)) {\n            res = min(res, 1);\n        }\n        if(check(0, 2, 2, v)) {\n            res = min(res, 1);\n        }\n        if(check(0, 2, 3, v)) {\n            res = min(res, 0);\n        }\n        if(check(1, 3, 0, v)) {\n            res = min(res, 3);\n        }\n        if(check(1, 3, 1, v)) {\n            res = min(res, 2);\n        }\n        if(check(1, 3, 2, v)) {\n            res = min(res, 2);\n        }\n        if(check(1, 3, 3, v)) {\n            res = min(res, 3);\n        }\n        if(check(4, 5, 0, v)) {\n            res = min(res, 1);\n        }\n        if(check(4, 5, 1, v)) {\n            res = min(res, 2);\n        }\n        if(check(4, 5, 2, v)) {\n            res = min(res, 2);\n        }\n        if(check(4, 5, 3, v)) {\n            res = min(res, 1);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvector<vs>in(6,vs(3));\nint main(){\n\twhile(1){\n\t\tstring t;cin>>t;\n\t\tif(t==\"#\")return 0;\n\t\trep(i,6)rep(j,3){\n\t\t\tif(i+j==0)in[i][j]=t;\n\t\t\telse cin>>in[i][j];\n\t\t}\n\t\trep(i,3){\n\t\t\treverse(all(in[2][i]));\n\t\t\treverse(all(in[3][i]));\n\t\t}\n\t\trep(i,3)\n\t\t\tswap(in[5][0][i],in[5][2][i]);\n\n\t\tint out=inf;\n\t\tif((in[0][0][0]=='*'||in[0][0][1]=='*'||in[0][0][2]=='*')&&\n\t\t   (in[2][0][0]=='*'||in[2][0][1]=='*'||in[2][0][2]=='*'))out=min(out,2);\n\t\tif((in[0][2][0]=='*'||in[0][2][1]=='*'||in[0][2][2]=='*')&&\n\t\t   (in[2][2][0]=='*'||in[2][2][1]=='*'||in[2][2][2]=='*'))out=min(out,0);\n\t\tif((in[0][0][0]=='*'||in[0][1][0]=='*'||in[0][2][0]=='*')&&\n\t\t   (in[2][0][0]=='*'||in[2][1][0]=='*'||in[2][2][0]=='*'))out=min(out,1);\n\t\tif((in[0][0][2]=='*'||in[0][1][2]=='*'||in[0][2][2]=='*')&&\n\t\t   (in[2][0][2]=='*'||in[2][1][2]=='*'||in[2][2][2]=='*'))out=min(out,1);\n\n\t\tif((in[1][0][0]=='*'||in[1][0][1]=='*'||in[1][0][2]=='*')&&\n\t\t   (in[3][0][0]=='*'||in[3][0][1]=='*'||in[3][0][2]=='*'))out=min(out,3);\n\t\tif((in[1][2][0]=='*'||in[1][2][1]=='*'||in[1][2][2]=='*')&&\n\t\t   (in[3][2][0]=='*'||in[3][2][1]=='*'||in[3][2][2]=='*'))out=min(out,3);\n\t\tif((in[1][0][0]=='*'||in[1][1][0]=='*'||in[1][2][0]=='*')&&\n\t\t   (in[3][0][0]=='*'||in[3][1][0]=='*'||in[3][2][0]=='*'))out=min(out,2);\n\t\tif((in[1][0][2]=='*'||in[1][1][2]=='*'||in[1][2][2]=='*')&&\n\t\t   (in[3][0][2]=='*'||in[3][1][2]=='*'||in[3][2][2]=='*'))out=min(out,2);\n\n\t\tif((in[4][0][0]=='*'||in[4][0][1]=='*'||in[4][0][2]=='*')&&\n\t\t   (in[5][0][0]=='*'||in[5][0][1]=='*'||in[5][0][2]=='*'))out=min(out,3);\n\t\tif((in[4][2][0]=='*'||in[4][2][1]=='*'||in[4][2][2]=='*')&&\n\t\t   (in[5][2][0]=='*'||in[5][2][1]=='*'||in[5][2][2]=='*'))out=min(out,1);\n\t\tif((in[4][0][0]=='*'||in[4][1][0]=='*'||in[4][2][0]=='*')&&\n\t\t   (in[5][0][0]=='*'||in[5][1][0]=='*'||in[5][2][0]=='*'))out=min(out,2);\n\t\tif((in[4][0][2]=='*'||in[4][1][2]=='*'||in[4][2][2]=='*')&&\n\t\t   (in[5][0][2]=='*'||in[5][1][2]=='*'||in[5][2][2]=='*'))out=min(out,2);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\nstring dice[6][3];\n\ninline bool ok(char c){\n  return c == '*';\n}\n\nbool check(int f, int x, int y){\n  if (x == -1) {\n    REP(i, 3) if (ok(dice[f][i][y])) return true;\n    return false;\n  }\n  \n  if (y == -1) {\n    REP(i, 3) if (ok(dice[f][x][i])) return true;\n    return false;\n  }\n  assert(false);\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  \n  while (cin >> dice[0][0] && dice[0][0] != \"#\"){\n    cin >> dice[0][1] >> dice[0][2];\n    REP2(i, 1, 6) REP(j, 3){\n      cin >> dice[i][j];\n    }\n\n    int res = 3;\n    \n    if (check(0, 2, -1) && check(2, 2, -1)) res = min(res, 0);\n    if (check(0, -1, 2) && check(2, -1, 0)) res = min(res, 1);\n    if (check(0, -1, 0) && check(2, -1, 2)) res = min(res, 1);\n    if (check(0, 0, -1) && check(2, 0, -1)) res = min(res, 2);\n\n    if (check(4, 0, -1) && check(5, 2, -1)) res = min(res, 1);\n    if (check(5, 0, -1) && check(4, 2, -1)) res = min(res, 1);\n    if (check(4, -1, 0) && check(5, -1, 0)) res = min(res, 2);\n    if (check(4, -1, 2) && check(5, -1, 2)) res = min(res, 2);\n\n    if (check(1, -1, 0) && check(3, -1, 2)) res = min(res, 2);\n    if (check(3, -1, 0) && check(1, -1, 2)) res = min(res, 2);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nvector<vector<int>>rotate_l(vector<vector<int>>vs) {\n\tvector<vector<int>>afvs(vs.size(),vector<int>(vs.size()));\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tafvs[2 - j][i] = vs[i][j];\n\t\t}\n\t}\n\treturn afvs;\n}\nvector<vector<int>>rotate_r(vector<vector<int>>vs) {\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\treturn vs;\n}\nvector<vector<int>>flip_ud(vector<vector<int>>vs) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tswap(vs[0][i], vs[2][i]);\n\t}\n\treturn vs;\n}\nvector<vector<int>>flip_lr(vector<vector<int>>vs) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tswap(vs[i][0], vs[i][2]);\n\t}\n\treturn vs;\n}\nstruct Dice {\n\tvector<vector<int>> tp;\n\tvector<vector<int>> bo;\n\tvector<vector<int>> no;\n\tvector<vector<int>> so;\n\tvector<vector<int>> ea;\n\tvector<vector<int>> we;\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice():tp(3,vector<int>(3)),\n\t\tbo(3, vector<int>(3)),\n\t\tno(3, vector<int>(3)),\n\t\tso(3, vector<int>(3)),\n\t\tea(3, vector<int>(3)),\n\t\twe(3, vector<int>(3))\n\t{\n\t}\n\tenum R_Way {\n\t\tR_Left,\n\t\tR_Front,\n\t\tR_Right,\n\t\tR_Back,\n\n\t\tR_Dummy,\n\t};\n\tbool check()const  {\n\t\tbool sook = false;\n\t\tbool nook = false;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (so[2][i])sook = true;\n\t\t\tif (no[2][i])nook = true;\n\t\t}\n\t\treturn sook&&nook;\n\t}\n\tvoid rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tso = rotate_l(so);\n\t\t\tno = rotate_r(no);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = we;\n\t\t\t\ttp = rotate_l(tp);\n\t\t\t\twe = bo;\n\t\t\t\twe = rotate_l(we);\n\t\t\t\tbo = ea;\n\t\t\t\tbo = rotate_l(bo);\n\t\t\t\tea = tmp;\n\t\t\t\tea = rotate_l(ea);\n\t\t\t}\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tea = rotate_l(ea);\n\t\t\twe = rotate_r(we);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = no;\n\t\t\t\ttp = flip_ud(tp);\n\t\t\t\tno = bo;\n\t\t\t\tno = flip_ud(no);\n\t\t\t\tbo = so;\n\t\t\t\tso = tmp;\n\t\t\t}\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid rotate(const int way) {\n\t\trotate(static_cast<R_Way>(way));\n\t}\n\tlong long int hash()const {\n\t\tlong long int hash = 0;\n\t\tlong long int num = 1;\n\t\tfor (int y = 0; y < 3; ++y) {\n\t\t\tfor (int x = 0; x < 3; ++x) {\n\t\t\t\tif (tp[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (bo[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (no[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (we[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (so[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (ea[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t}\n\t\t}\n\t\treturn hash;\n\t}\n};\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\nint main() {\n\twhile (1) {\n\t\tDice di;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tvector<vector<int>>vs;\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tvector<int>v(3);\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (st == \"#\")return 0;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (st[k] == '*')v[k] = 1;\n\t\t\t\t}\n\t\t\t\tvs.emplace_back(v);\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tdi.so = vs;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdi.ea = vs;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdi.no = vs;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdi.we = vs;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdi.tp = vs;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdi.bo = vs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans = 9999;\n\t\tqueue<pair<int, Dice>>que;\n\t\tmap<long long int, int>mp;\n\t\tmp[di.hash()] = 0;\n\t\tque.push(make_pair(0, di));\n\t\twhile (!que.empty()) {\n\t\t\tauto p = que.front();\n\t\t\tque.pop();\n\t\t\tconst int nexttime = p.first + 1;\n\t\t\tconst Dice ori = p.second;\n\t\t\tif (ori.check()) {\n\t\t\t\tans = nexttime - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tDice now(ori);\n\t\t\t\tnow.rotate(i);\n\t\t\t\tauto it = mp.find(now.hash());\n\t\t\t\tif (it == mp.end()) {\n\t\t\t\t\tmp[now.hash()] = nexttime;\n\t\t\t\t\tque.emplace(nexttime, now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Face=array<array<char,3>,3>;\nvoid flip(Face& s){\n    Face tmp;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            tmp[i][j]=s[2-i][j];\n        }\n    }\n    s=tmp;\n}\n\nvoid flipL(Face& s){\n    Face tmp;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            tmp[2-j][i]=s[i][j];\n        }\n    }\n    s=tmp;\n}\nvoid flipR(Face& s){\n    Face tmp;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            tmp[i][j]=s[2-j][i];\n        }\n    }\n    s=tmp;\n}\nconst int FRONT=0;\nconst int BACK=2;\nstruct Dice{\n    array<Face,6> face;\n    void rotate0(){\n        array<Face,6> tmp;\n        tmp[5]=face[0];\n        tmp[0]=face[4];\n        tmp[4]=face[2]; flipL(tmp[4]),flipL(tmp[4]);\n        tmp[2]=face[5]; flipL(tmp[2]),flipL(tmp[2]);\n        tmp[1]=face[1]; flipL(tmp[1]);\n        tmp[3]=face[1]; flipR(tmp[3]);\n        face=tmp;\n    }\n    void rotate1(){\n        array<Face,6> tmp;\n        tmp[0]=face[5];\n        tmp[4]=face[0];\n        tmp[2]=face[4]; flipL(tmp[2]),flipL(tmp[2]);\n        tmp[5]=face[2]; flipL(tmp[5]),flipL(tmp[5]);\n        tmp[1]=face[1]; flipR(tmp[1]);\n        tmp[3]=face[3]; flipL(tmp[3]);\n        face=tmp;\n    }\n    void rotate2(){\n        array<Face,6> tmp;\n        flipR(face[1]);\n        flipR(face[4]);\n        flipR(face[3]);\n        flipR(face[5]);\n        tmp[1]=face[4];\n        tmp[4]=face[3];\n        tmp[3]=face[5];\n        tmp[5]=face[1];\n        tmp[0]=face[0]; flipR(tmp[0]);\n        tmp[2]=face[2]; flipL(tmp[2]);\n        face=tmp;\n    }\n    void rotate3(){\n        array<Face,6> tmp;\n        flipL(face[1]);\n        flipL(face[4]);\n        flipL(face[3]);\n        flipL(face[5]);\n        tmp[4]=face[1];\n        tmp[3]=face[4];\n        tmp[5]=face[3];\n        tmp[1]=face[5];\n        tmp[0]=face[0]; flipL(tmp[0]);\n        tmp[2]=face[2]; flipR(tmp[2]);\n        face=tmp;\n    }\n    void rotate(int i){\n        if(i==0) rotate0();\n        if(i==1) rotate1();\n        if(i==2) rotate2();\n        if(i==3) rotate3();\n    }\n    bool isGoal(){\n        bool fb=count(face[FRONT][2].begin(),face[FRONT][2].end(),'*');\n        bool bb=count(face[BACK][2].begin(),face[BACK][2].end(),'*');\n        return fb&&bb;\n    }\n    void input(){\n        for(int i=0;i<6;i++){\n            for(int j=0;j<3;j++){\n                string buf; cin>>buf;\n                if(buf==\"#\") exit(0);\n                for(int k=0;k<3;k++){\n                    face[i][j][k]=buf[k];\n                }\n            }\n        }\n    }\n    void print(){\n        for(int i=0;i<6;i++){\n            cerr<<\"#\"<<i<<endl;\n            for(int j=0;j<3;j++){\n                for(int k=0;k<3;k++){\n                    cerr<<face[i][j][k];\n                }\n                cerr<<endl;\n            }\n        }\n    }\n};\n\nint solve(){\n    Dice dice;\n    dice.input();\n    queue<pair<int,Dice>> que;\n    que.push(make_pair(0,dice));\n    // dice.rotate(3);\n    // dice.print();\n    // dice.rotate(0);\n    \n    // string buf;\n    // cin>>buf; \n    \n    set<array<Face,6>> s;\n    while(!que.empty()){\n        auto tmp=que.front(); que.pop();\n        Dice dice=tmp.second;\n        if(s.count(dice.face)) continue;\n        s.insert(dice.face);\n        int cnt=tmp.first;\n        if(dice.isGoal()){\n            cout<<cnt<<endl;\n            return 0;\n        }\n        for(int i=0;i<4;i++){\n            Dice tmp=dice;\n            tmp.rotate(i);\n            que.push(make_pair(cnt+1,tmp));\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(true){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\n/*\n 4\n 0 1 2 3\n 5\n ????????????????±????????????§????????????????¨?????????§????????????\n */\n\nbitset<4> cw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+1)%4] = b[i];\n  return nb;\n}\n\nbitset<4> ccw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+3)%4] = b[i];\n  return nb;\n}\n\nstruct state{\n  vector<bitset<4>> b;\n  state(){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n  }\n  state(const state &s){\n    b = s.b; // copy\n  }\n  int hash(){\n    int h = 0;\n    rep(i,6) rep(j,4) h = (h<<1) + b[i][j];\n    return h;\n  }\n  bitset<4>& operator[](int i){ return b[i]; }\n\n  void front(){ // ???????????????\n    vector<bitset<4>> nb(6);\n    nb[0] = b[4];\n    nb[1] = ccw(b[1]);\n    nb[2] = cw(cw(b[5]));\n    nb[3] = cw(b[3]);\n    nb[4] = cw(cw(b[2]));\n    nb[5] = b[0];\n    swap(nb, b);\n  }\n  void right(){\n    vector<bitset<4>> nb(6);\n    nb[0] = cw(b[0]);\n    nb[1] = cw(b[4]);\n    nb[2] = ccw(b[2]);\n    nb[3] = cw(b[5]);\n    nb[4] = cw(b[3]);\n    nb[5] = cw(b[1]);\n    swap(nb,b);\n  }\n\n  bool ok(){\n    return b[0][2] & b[2][2];\n  }\n};\n\nint main(){\n  while(true){\n    state st;\n    rep(i,6){\n      string t[3];\n      rep(j,3){\n        cin>>t[j];\n        if(t[0]==\"#\") return 0;\n      }\n      st[i][0] = t[0][0]=='*' || t[0][1]=='*' || t[0][2]=='*';\n      st[i][1] = t[0][2]=='*' || t[1][2]=='*' || t[2][2]=='*';\n      st[i][2] = t[2][0]=='*' || t[2][1]=='*' || t[2][2]=='*';\n      st[i][3] = t[0][0]=='*' || t[1][0]=='*' || t[2][0]=='*';\n    }\n\n    vector<int> d(1<<24, INF);\n    queue<state> q;\n    q.push(st);\n    d[st.hash()] = 0;\n    int ans;\n    bool flg = true;\n    while(flg){ assert(!q.empty());\n      state s = q.front(); q.pop();\n      if(s.ok()){\n        ans = d[s.hash()];\n        break;\n      }\n      int nd = d[s.hash()]+1;\n      auto exec = [&](state &S){\n        if(S.ok()){\n          ans = nd;\n          flg=false;\n          return;\n        }\n        if(d[S.hash()] > nd){\n          q.push(S);\n          d[S.hash()] = nd;\n        }\n      };\n\n      state s1(s);\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.front();\n      exec(s1);\n      s1.front();\n      s1.front();\n      exec(s1);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring rR(string s) {\n  swap(s[0],s[2]);\n  swap(s[0],s[6]);\n  swap(s[6],s[8]);\n  swap(s[1],s[5]);\n  swap(s[1],s[3]);\n  swap(s[3],s[7]);\n  return s;\n}\nstring rL(string s) {\n  swap(s[0],s[2]);\n  swap(s[2],s[8]);\n  swap(s[6],s[8]);\n  swap(s[1],s[5]);\n  swap(s[5],s[7]);\n  swap(s[3],s[7]);\n  return s;\n}\n\nvector<string> U(vector<string> s) {\n  swap(s[0],s[4]);\n  swap(s[0],s[5]);\n  swap(s[2],s[5]);\n  for(int i=0; i<4; i++) swap(s[2][i],s[2][8-i]);\n  for(int i=0; i<4; i++) swap(s[5][i],s[5][8-i]);\n  s[1]=rR(s[1]);\n  s[3]=rL(s[3]);\n  return s;\n}\nvector<string> D(vector<string> s) {\n  swap(s[0],s[5]);\n  swap(s[0],s[4]);\n  swap(s[2],s[4]);\n  for(int i=0; i<4; i++) swap(s[2][i],s[2][8-i]);\n  for(int i=0; i<4; i++) swap(s[4][i],s[4][8-i]);\n  s[1]=rL(s[1]);\n  s[3]=rR(s[3]);\n  return s;\n}\nvector<string> R(vector<string> s) {\n  swap(s[1],s[4]);\n  swap(s[3],s[4]);\n  swap(s[3],s[5]);\n  s[0]=rR(s[0]);\n  s[1]=rR(s[1]);\n  s[2]=rL(s[2]);\n  s[3]=rR(s[3]);\n  s[4]=rR(s[4]);\n  s[5]=rR(s[5]);\n  return s;\n}\nvector<string> L(vector<string> s) {\n  swap(s[1],s[5]);\n  swap(s[3],s[5]);\n  swap(s[3],s[4]);\n  s[0]=rL(s[0]);\n  s[1]=rL(s[1]);\n  s[2]=rR(s[2]);\n  s[3]=rL(s[3]);\n  s[4]=rL(s[4]);\n  s[5]=rL(s[5]);\n  return s;\n}\n\n\nint main() {\n  string t;\n  while(cin >> t&&t!=\"#\") {\n    vector<string> s;\n    map<vector<string>, int> m;\n    string r=t;\n    for(int j=1; j<3; j++) {\n      cin >> t;\n      r+=t;\n    }\n    s.push_back(r);\n    for(int i=1; i<6; i++) {\n      r=\"\";\n      for(int j=0; j<3; j++) {\n        cin >> t;\n        r+=t;\n      }\n      s.push_back(r);\n    }\n    m[s]=0;\n    queue<vector<string> > que;\n    que.push(s);\n    while(!que.empty()) {\n      s=que.front();que.pop();\n      bool f1=0,f2=0;\n      for(int i=0; i<3; i++) {\n        if(s[0][i+6]=='*') f1|=1;\n        if(s[2][i+6]=='*') f2|=1;\n      }\n      int c=m[s];\n      if(f1&&f2) {\n        cout << c << endl;\n        break;\n      }\n      vector<string> t=U(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n      t=D(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n      t=R(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n      t=L(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid turnccw(int n, vector<char> &a){\n\tfor(int i=0; i<n; i++){\n\t\tswap(a[0], a[1]);\n\t\tswap(a[1], a[2]);\n\t\tswap(a[2], a[5]);\n\t\tswap(a[5], a[8]);\n\t\tswap(a[8], a[7]);\n\t\tswap(a[7], a[6]);\n\t\tswap(a[6], a[3]);\n\t}\n}\nvoid moveright(vector<vector<char> > &a){\n\tswap(a[4], a[3]);\n\tswap(a[3], a[5]);\n\tswap(a[5], a[1]);\n\tturnccw(3, a[0]);\n\tturnccw(1, a[2]);\n\tturnccw(1, a[4]);\n\tturnccw(1, a[3]);\n\tturnccw(1, a[5]);\n\tturnccw(1, a[1]);\n}\nvoid moveleft(vector<vector<char> > &a){\n\tfor(int i=0; i<3; i++) moveright(a);\n}\nvoid movefront(vector<vector<char> > &a){\n\tswap(a[0], a[4]);\n\tswap(a[4], a[2]);\n\tswap(a[2], a[5]);\n\tturnccw(1, a[1]);\n\tturnccw(3, a[3]);\n\tturnccw(2, a[4]);\n\tturnccw(2, a[2]);\n}\nvoid moveback(vector<vector<char> > &a){\n\tfor(int i=0; i<3; i++) movefront(a);\n}\n\nvector<vector<char> > move(int dir, vector<vector<char> > &a){\n\tvector<vector<char> > ret = a;\n\tif(dir==0) moveleft(ret);\n\tif(dir==1) moveright(ret);\n\tif(dir==2) movefront(ret);\n\tif(dir==3) moveback(ret);\n\treturn ret;\n}\n\nint solve(int step, vector<vector<char> > a){\n\tif(step==5) return 5;\n\tif((a[0][6]=='*' || a[0][7]=='*' || a[0][8]=='*') && (a[2][6]=='*' || a[2][7]=='*' || a[2][8]=='*')){\n\t\treturn step;\n\t}\n\tint ret = 5;\n\tfor(int i=0; i<4; i++){\n\t\tret = min(ret, solve(step+1, move(i, a)));\n\t}\n\treturn ret;\n}\n\nint main(){\n\tvector<vector<char> > a(6, vector<char>(9));\n\twhile(1){\n\t\tcin >> a[0][0];\n\t\tif(a[0][0]=='#') break;\n\t\t\n\t\tfor(int i=0; i<6; i++){\n\t\t\tfor(int j=(i==0)?1:0; j<9; j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve(0, a) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct face{\n  string c[3];\n  face(){}\n  face(string s[3]){\n    for(int i=0;i<3;i++) c[i]=s[i];\n  }\n};\nstruct dice{\n  face f[6];\n  int d;\n  dice(){}\n  dice(string s[6][3]){\n    d=0;\n    for(int i=0;i<6;i++)\n      f[i]=face(s[i]);\n  }\n};\n \nbool check(dice d){\n  bool res=1,f;\n  f=0;\n  for(int i=0;i<3;i++) f|=d.f[0].c[2][i]=='*';\n  res&=f;\n  f=0;\n  for(int i=0;i<3;i++) f|=d.f[2].c[2][i]=='*';\n  res&=f;\n  return res;\n}\nface sr(face f){\n  face p=f;\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      p.c[i][j]=f.c[2-j][i];\n  return p;\n}\nface sl(face f){\n  face p=f;\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      p.c[i][j]=f.c[j][2-i];\n  return p;\n}\nface re(face f){\n  return sr(sr(f));\n}\ndice rotate1(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=d.f[5];\n  b.f[1]=sr(d.f[1]);\n  b.f[2]=re(d.f[4]);\n  b.f[3]=sl(d.f[3]);\n  b.f[4]=d.f[0];\n  b.f[5]=re(d.f[2]);\n  return b;\n}\ndice rotate2(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=d.f[4];\n  b.f[1]=sl(d.f[1]);\n  b.f[2]=re(d.f[5]);\n  b.f[3]=sr(d.f[3]);\n  b.f[4]=re(d.f[2]);\n  b.f[5]=d.f[0];\n  return b;\n}\ndice rotate3(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=sl(d.f[0]);\n  b.f[1]=sl(d.f[5]);\n  b.f[2]=sr(d.f[2]);\n  b.f[3]=sl(d.f[4]);\n  b.f[4]=sl(d.f[1]);\n  b.f[5]=sl(d.f[3]);\n  return b;\n}\ndice rotate4(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=sr(d.f[0]);\n  b.f[1]=sr(d.f[4]);\n  b.f[2]=sl(d.f[2]);\n  b.f[3]=sr(d.f[5]);\n  b.f[4]=sr(d.f[3]);\n  b.f[5]=sr(d.f[1]);\n  return b;\n}\nsigned main(){\n  string tmp;\n  while(cin>>tmp,tmp!=\"#\"){\n    string s[6][3];\n    s[0][0]=tmp;\n    for(int i=0;i<6;i++){\n      for(int j=0;j<3;j++){\n\tif((i||j)==0) continue;\n\tcin>>s[i][j];\n      }\n    }\n    dice d(s);\n    queue<dice> q;\n    q.push(d);\n    int ans=-1;\n    while(!q.empty()){\n      d=q.front();q.pop();\n      if(check(d)){\n\tans=d.d;\n\tbreak;\n      }\n      q.push(rotate1(d));\n      q.push(rotate2(d));\n      q.push(rotate3(d));\n      q.push(rotate4(d));\n    }\n    assert(~ans);\n    cout<<ans<<endl;\n  }\n  assert(tmp==\"#\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<string> rotate(int n, const vector<string>& s)\n{\n    if(n == 0)\n        return s;\n\n    vector<string> t(3, string(3, ' '));\n    for(int i=0; i<3; ++i){\n        for(int j=0; j<3; ++j){\n            t[j][2-i] = s[i][j];\n        }\n    }\n    return rotate(n-1, t);\n}\n\nclass Dice\n{\npublic:\n    vector<vector<string> > pip; // 東南西北上下の目\n    Dice(){\n        pip.assign(6, vector<string>(3, string(3, ' ')));\n    }\n    void roll(int d){ // 東南西北右左に回転\n        int dir[][4] = {{4,2,5,0},{4,3,5,1},{4,0,5,2},{4,1,5,3},{0,3,2,1},{0,1,2,3}};\n        vector<string> tmp = pip[dir[d][0]];\n        for(int i=0; i<3; ++i)\n            pip[dir[d][i]] = pip[dir[d][i+1]];\n        pip[dir[d][3]] = tmp;\n\n        if(d == 0){\n            pip[1] = rotate(3, pip[1]);\n            pip[2] = rotate(2, pip[2]);\n            pip[3] = rotate(1, pip[3]);\n            pip[5] = rotate(2, pip[5]);\n        }else if(d == 1){\n            pip[0] = rotate(1, pip[0]);\n            pip[2] = rotate(3, pip[2]);\n        }else if(d == 2){\n            pip[0] = rotate(2, pip[0]);\n            pip[1] = rotate(1, pip[1]);\n            pip[3] = rotate(3, pip[3]);\n            pip[5] = rotate(2, pip[5]);\n        }else{\n            pip[0] = rotate(3, pip[0]);\n            pip[2] = rotate(1, pip[2]);\n        }\n    }\n    bool operator==(const Dice& d) const{\n        return pip == d.pip;\n    }\n};\n\nint solve(Dice d0)\n{\n    set<vector<vector<string> > > s;\n    queue<vector<vector<string> > > q;\n    s.insert(d0.pip);\n    q.push(d0.pip);\n\n    int ret = 0;\n    for(;;){\n        int n = q.size();\n        while(--n >= 0){\n            Dice d;\n            d.pip= q.front();\n            q.pop();\n\n            int tmp = 0;\n            for(int i=0; i<3; ++i){\n                if(d.pip[1][2][i] == '*')\n                    tmp |= 1;\n                if(d.pip[3][0][i] == '*')\n                    tmp |= 2;\n            }\n            if(tmp == 3)\n                return ret;\n\n            for(int i=0; i<4; ++i){\n                Dice d2 = d;\n                d2.roll(i);\n                if(s.find(d2.pip) == s.end()){\n                    s.insert(d2.pip);\n                    q.push(d2.pip);\n                }\n            }\n        }\n        ++ ret;\n    }\n}\n\nint main()\n{\n    int to[] = {1, 0, 3, 2, 4, 5};\n\n    for(;;){\n        Dice d;\n        for(int i=0; i<6; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> d.pip[to[i]][j];\n                if(d.pip[to[i]][j] == \"#\")\n                    return 0;\n            }\n        }\n        d.pip[0] = rotate(1, d.pip[0]);\n        d.pip[2] = rotate(3, d.pip[2]);\n        d.pip[3] = rotate(2, d.pip[3]);\n        d.pip[5] = rotate(2, d.pip[5]);\n\n        cout << solve(d) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n\nclass Cube{\npublic:\n  char G[7][3][3]; // 6 for temp\n  int cost;\n  Cube(){ cost = 0;}\n  bool operator < ( const Cube &c) const{\n    rep(k, 6) rep(i, 3) rep(j, 3){\n      if ( G[k][i][j] == c.G[k][i][j] ) continue;\n      return G[k][i][j] < c.G[k][i][j];\n    }\n    return false;\n  }\n\n  void clock90(int k){\n    char T[3][3];\n    rep(i, 3) rep(j, 3) T[i][j] = G[k][i][j];\n    rep(i, 3) rep(j, 3) G[k][i][j] = T[3-j-1][i];\n  }\n  void assign(int s, int t){\n    rep(i, 3) rep(j, 3) G[t][i][j] = G[s][i][j];\n  }\n  void clock180(int k){ rep(i, 2) clock90(k); }\n  void rotateF(){\n    assign(5, 6);\n    assign(0, 5);\n    assign(4, 0);\n    clock180(2);\n    assign(2, 4);    \n    clock180(6);\n    assign(6, 2);    \n    clock90(1);\n    rep(i, 3) clock90(3);\n  }\n\n  void rotateR(){\n    assign(1, 6);\n    clock90(4);\n    assign(4, 1);\n    clock90(3);\n    assign(3, 4);\n    clock90(5);\n    assign(5, 3);\n    clock90(6);\n    assign(6, 5);\n    clock90(2);\n    rep(i, 3) clock90(0);\n  }\n\n  void rotateB(){ rep(i, 3) rotateF(); }\n  void rotateL(){ rep(i, 3) rotateR(); }\n\n  bool isGoal(){\n    bool f = false;\n    bool b = false;\n    rep(j, 3) if ( G[0][2][j] == '*' ) f = true;\n    rep(j, 3) if ( G[2][2][j] == '*' ) b = true;\n    return f && b;\n  }\n};\n\nvoid update(queue<Cube> &Q, set<Cube> &V, Cube &u, Cube &v){\n  if ( V.find(v) == V.end() ){\n    V.insert(v);\n    v.cost = u.cost + 1;\n    Q.push(v);\n  }\n}\n\nint bfs(Cube C){\n  queue<Cube> Q;\n  set<Cube> V;\n  C.cost = 0;\n  Q.push(C);\n  V.insert(C);\n  Cube u, v;\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if ( u.isGoal() ) return u.cost;\n    v = u;\n    v.rotateF();\n    update(Q, V, u, v);\n    v = u;\n    v.rotateB();\n    update(Q, V, u, v);\n    v = u;\n    v.rotateL();\n    update(Q, V, u, v);\n    v = u;\n    v.rotateR();\n    update(Q, V, u, v);\n  }\n}\n\nbool input(Cube &C){\n  rep(k, 6) rep(i, 3) rep(j, 3){\n    cin >> C.G[k][i][j];\n    if ( C.G[k][i][j] == '#' ) return false;\n  }\n  return true;\n}\n\nmain(){\n  Cube C;\n  while(input(C)) cout << bfs(C) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int N = 6, M = 3;\n\nchar cube[N*2][M*2][M*2];\nchar buf[M*2];\n\nvoid read(){\n    scanf(\"%s\", buf);\n    strcpy(cube[0][1], buf);\n    scanf(\"%s\", buf);\n    strcpy(cube[0][2], buf);\n    for(int i = 1; i < N; i++)\n        for(int j = 0; j < M; j++){\n            scanf(\"%s\", buf);\n            strcpy(cube[i][j], buf);\n        }\n    getchar();\n}\n\n// i-th cube j-th row\nint check_row(int i, int j){\n    for(int k = 0; k < M; k++)\n        if(cube[i][j][k] == '*')\n            return true;\n    return false;\n}\n\n// i-th cube k-th colum\nint check_colum(int i, int k){\n    for(int j = 0; j < M; j++)\n        if(cube[i][j][k] == '*')\n            return true;\n    return false;\n}\n\nint solve(){\n\n    int ans = 0x7fff;\n\n    if(check_row(0,2) && check_row(2,2))\n        ans = min(ans,0);\n    if(check_row(0,0) && check_row(2,0))\n        ans = min(ans,2);\n    if(check_colum(0,0) && check_colum(2,0))\n        ans = min(ans,1);\n    if(check_colum(0,2) && check_colum(2,2))\n        ans = min(ans,1);\n    if(check_row(1,0) && check_row(3,0))\n        ans = min(ans,3);\n    if(check_row(1,2) && check_row(3,2))\n        ans = min(ans,3);\n    if(check_colum(1,0) && check_colum(3,2))\n        ans = min(ans,2);\n    if(check_colum(1,2) && check_colum(3,0))\n        ans = min(ans,2);\n    if(check_row(4,0) && check_row(5,2))\n        ans = min(ans,1);\n    if(check_row(4,2) && check_row(5,0))\n       ans = min(ans,1);\n    if(check_colum(4,0) && check_colum(5,0))\n       ans = min(ans,2);\n    if(check_colum(4,2) && check_colum(5,2))\n        ans = min(ans,2);\n    return ans;\n}\n\nint main()\n{\n//    freopen(\"in\", \"r\", stdin);\n\n    while(scanf(\"%s\", buf), buf[0] != '#'){\n\n        strcpy(cube[0][0], buf);\n        read();\n\n//        for(int i = 0; i < N; i++){\n//            for(int j = 0; j < M; j++)\n//                puts(cube[i][j]);\n//            puts(\"\");\n//        }\n\n\n        printf(\"%d\\n\", solve());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  string beet;\n  while(cin >> beet, beet != \"#\") {\n    string S[6][3];\n    S[0][0] = beet;\n    for(int i = 0; i < 6; i++) {\n      for(int j = i == 0; j < 3; j++) {\n        cin >> S[i][j];\n      }\n    }\n\n    int ret = 114514;\n    bool l = 0, r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[0][2][i] == '*') l = true;\n      if(S[2][2][i] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 0);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[0][i][0] == '*') l = true;\n      if(S[2][i][2] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 1);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[0][i][2] == '*') l = true;\n      if(S[2][i][0] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 1);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[4][2][i] == '*') l = true;\n      if(S[5][0][i] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 1);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[4][0][i] == '*') l = true;\n      if(S[5][2][i] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 1);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[0][0][i] == '*') l = true;\n      if(S[2][0][i] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 2);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[1][i][0] == '*') l = true;\n      if(S[3][i][2] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 2);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[1][i][2] == '*') l = true;\n      if(S[3][i][0] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 2);\n\n    for(int i = 0; i < 3; i++) {\n      if(S[4][i][0] == '*') l = true;\n      if(S[5][i][0] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 2);\n\n    for(int i = 0; i < 3; i++) {\n      if(S[4][i][2] == '*') l = true;\n      if(S[5][i][2] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 2);\n\n    l = r = 0;\n    for(int i = 0; i < 3; i++) {\n      if(S[1][0][i] == '*') l = true;\n      if(S[3][0][i] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 3);\n\n    for(int i = 0; i < 3; i++) {\n      if(S[1][2][i] == '*') l = true;\n      if(S[3][2][i] == '*') r = true;\n    }\n    if(l & r) ret = min(ret, 3);\n\n\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nvector<vector<int>>rotate_l(vector<vector<int>>vs) {\n\tvector<vector<int>>afvs(vs.size(),vector<int>(vs.size()));\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tafvs[2 - j][i] = vs[i][j];\n\t\t}\n\t}\n\treturn afvs;\n}\nvector<vector<int>>rotate_r(vector<vector<int>>vs) {\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\treturn vs;\n}\nvector<vector<int>>flip_ud(vector<vector<int>>vs) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tswap(vs[0][i], vs[2][i]);\n\t}\n\treturn vs;\n}\nvector<vector<int>>flip_lr(vector<vector<int>>vs) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tswap(vs[i][0], vs[i][2]);\n\t}\n\treturn vs;\n}\nstruct Dice {\n\tvector<vector<int>> tp;\n\tvector<vector<int>> bo;\n\tvector<vector<int>> no;\n\tvector<vector<int>> so;\n\tvector<vector<int>> ea;\n\tvector<vector<int>> we;\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice():tp(3,vector<int>(3)),\n\t\tbo(3, vector<int>(3)),\n\t\tno(3, vector<int>(3)),\n\t\tso(3, vector<int>(3)),\n\t\tea(3, vector<int>(3)),\n\t\twe(3, vector<int>(3))\n\t{\n\t}\n\tenum R_Way {\n\t\tR_Left,\n\t\tR_Front,\n\t\tR_Right,\n\t\tR_Back,\n\n\t\tR_Dummy,\n\t};\n\tbool check()const  {\n\t\tbool sook = false;\n\t\tbool nook = false;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (so[2][i])sook = true;\n\t\t\tif (no[2][i])nook = true;\n\t\t}\n\t\treturn sook&&nook;\n\t}\n\tvoid rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tso = rotate_l(so);\n\t\t\tno = rotate_l(no);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = we;\n\t\t\t\ttp = rotate_l(tp);\n\t\t\t\twe = bo;\n\t\t\t\twe = rotate_l(we);\n\t\t\t\tbo = ea;\n\t\t\t\tbo = rotate_l(bo);\n\t\t\t\tea = tmp;\n\t\t\t\tea = rotate_l(ea);\n\t\t\t}\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tea = rotate_l(ea);\n\t\t\twe = rotate_r(we);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = no;\n\t\t\t\ttp = flip_ud(tp);\n\t\t\t\tno = bo;\n\t\t\t\tno = flip_ud(no);\n\t\t\t\tbo = so;\n\t\t\t\tso = tmp;\n\t\t\t}\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid rotate(const int way) {\n\t\trotate(static_cast<R_Way>(way));\n\t}\n\tlong long int hash()const {\n\t\tlong long int hash = 0;\n\t\tlong long int num = 1;\n\t\tfor (int y = 0; y < 3; ++y) {\n\t\t\tfor (int x = 0; x < 3; ++x) {\n\t\t\t\tif (tp[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (bo[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (no[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (we[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (so[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (ea[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t}\n\t\t}\n\t\treturn hash;\n\t}\n};\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\nint main() {\n\twhile (1) {\n\t\tDice di;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tvector<vector<int>>vs;\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tvector<int>v(3);\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (st == \"#\")return 0;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (st[k] == '*')v[k] = 1;\n\t\t\t\t}\n\t\t\t\tvs.emplace_back(v);\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tdi.so = vs;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdi.ea = vs;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdi.no = vs;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdi.we = vs;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdi.tp = vs;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdi.bo = vs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans = 9999;\n\t\tqueue<pair<int, Dice>>que;\n\t\tmap<long long int, int>mp;\n\t\tmp[di.hash()] = 0;\n\t\tque.push(make_pair(0, di));\n\t\twhile (!que.empty()) {\n\t\t\tauto p = que.front();\n\t\t\tque.pop();\n\t\t\tconst int nexttime = p.first + 1;\n\t\t\tconst Dice ori = p.second;\n\t\t\tif (ori.check()) {\n\t\t\t\tans = nexttime - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tDice now(ori);\n\t\t\t\tnow.rotate(i);\n\t\t\t\tauto it = mp.find(now.hash());\n\t\t\t\tif (it == mp.end()) {\n\t\t\t\t\tmp[now.hash()] = nexttime;\n\t\t\t\t\tque.emplace(nexttime, now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <set>\n#include <queue>\nusing namespace std;\n\nclass Dice\n{\npublic:\n\tbool st[6][3][3];\n\tDice()\t{}\n\n\tDice(bool* t)\n\t{\n\t\tfor (int i=0; i<54; i++)\n\t\t\tst[i/9][(i%9)/3][(i%9)%3]=t[i];\n\t}\n\n\tvoid RotU()\n\t{\n\t\tbool n[6][3][3];\n\t\tmemcpy(n[0], st[5], sizeof(st[5]));\n\t\tmemcpy(n[4], st[0], sizeof(st[0]));\n\t\tfor (int i=0; i<3; i++)\n\t\tfor (int j=0; j<3; j++)\n\t\t{\n\t\t\tn[2][i][j] = st[4][2-i][2-j];\n\t\t\tn[5][i][j] = st[2][2-i][2-j];\n\t\t\tn[1][i][j] = st[1][2-j][i];\n\t\t\tn[3][i][j] = st[3][j][2-i];\n\t\t}\n\t\tmemcpy(st, n, sizeof(n));\n\t}\n\n\tvoid RotD()\n\t{\n\t\tbool n[6][3][3];\n\t\tmemcpy(n[0], st[4], sizeof(st[4]));\n\t\tmemcpy(n[5], st[0], sizeof(st[0]));\n\t\tfor (int i=0; i<3; i++)\n\t\tfor (int j=0; j<3; j++)\n\t\t{\n\t\t\tn[2][i][j] = st[5][2-i][2-j];\n\t\t\tn[4][i][j] = st[2][2-i][2-j];\n\t\t\tn[1][i][j] = st[1][j][2-i];\n\t\t\tn[3][i][j] = st[3][2-j][i];\n\t\t}\n\t\tmemcpy(st, n, sizeof(n));\n\t}\n\n\tvoid RotL()\n\t{\n\t\tbool n[6][3][3];\n\t\tfor (int i=0; i<3; i++)\n\t\tfor (int j=0; j<3; j++)\n\t\t{\n\t\t\tn[2][i][j] = st[2][2-j][i];\n\t\t\tn[3][i][j] = st[4][2-j][i];\n\t\t\tn[0][i][j] = st[0][j][2-i];\n\t\t\tn[1][i][j] = st[5][j][2-i];\n\t\t\tn[4][i][j] = st[1][j][2-i];\n\t\t\tn[5][i][j] = st[3][j][2-i];\n\t\t}\n\t\tmemcpy(st, n, sizeof(n));\n\t}\n\n\tvoid RotR()\n\t{\n\t\tbool n[6][3][3];\n\t\tfor (int i=0; i<3; i++)\n\t\tfor (int j=0; j<3; j++)\n\t\t{\n\t\t\tn[2][i][j] = st[2][j][2-i];\n\t\t\tn[0][i][j] = st[0][2-j][i];\n\t\t\tn[1][i][j] = st[4][2-j][i];\n\t\t\tn[3][i][j] = st[5][2-j][i];\n\t\t\tn[4][i][j] = st[3][2-j][i];\n\t\t\tn[5][i][j] = st[1][2-j][i];\n\t\t}\n\t\tmemcpy(st, n, sizeof(n));\n\t}\n\n\tbool isGoal()\n\t{\n\t\tbool f = false;\n\t\tfor (int i=0; i<3; i++)\n\t\t\tif (st[0][2][i]) { f = true; break; }\n\n\t\tif (!f) return f;\n\t\tf = false;\n\t\tfor (int i=0; i<3; i++)\n\t\t\tif (st[2][2][i]) { f = true; break; }\n\n\t\treturn f;\n\t}\n\n\tbool operator<(const Dice& d) const {\n\t\tfor (int k=0; k<6; k++)\n\t\tfor (int i=0; i<3; i++)\n\t\tfor (int j=0; j<3; j++)\n\t\t{\n\t\t\tif (st[k][i][j] != d.st[k][i][j]) return st[k][i][j] < d.st[k][i][j];\n\t\t}\n\n\t\treturn false;\n\n\t}\n};\n\nclass Trl\n{\npublic:\n\tDice d;\n\tint n;\n\tTrl(Dice d, int n): d(d), n(n) {}\n};\n\nint main()\n{\n\tchar in[6][3][3];\n\twhile (cin >> in[0][0][0], in[0][0][0]!='#')\n\t{\n\t\tbool b[54];\n\t\tb[0] = (in[0][0][0]=='*');\n\t\tfor (int i=1; i<54; i++)\n\t\t{\n\t\t\tcin >> in[i/9][(i%9)/3][(i%9)%3];\n\t\t\tb[i] = (in[i/9][(i%9)/3][(i%9)%3]=='*');\n\t\t}\n\t\tDice init(b);\n\t\tqueue<Trl> q;\n\t\tq.push(Trl(init, 0));\n\t\tset<Dice> v;\n\t\tv.insert(init);\n\n\t\t\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tTrl t = q.front(); q.pop();\n\t\t\t\n\t\t\tif (t.d.isGoal())\n\t\t\t{\n\t\t\t\tcout << t.n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.n++;\n\n\t\t\tDice d;\n\t\t\td = t.d;\n\t\t\td.RotD();\n\t\t\tif (v.insert(d).second)\n\t\t\t\tq.push(Trl(d, t.n));\n\n\t\t\td = t.d;\n\t\t\td.RotU();\n\t\t\tif (v.insert(d).second)\n\t\t\t\tq.push(Trl(d, t.n));\n\n\t\t\td = t.d;\n\t\t\td.RotR();\n\t\t\tif (v.insert(d).second)\n\t\t\t\tq.push(Trl(d, t.n));\n\n\t\t\td = t.d;\n\t\t\td.RotL();\n\t\t\tif (v.insert(d).second)\n\t\t\t\tq.push(Trl(d, t.n));\n\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Face {\n  char face[3][3];\n  bool operator<(const Face &rhs) const {\n    REP(y, 3) REP(x, 3) {\n      if (face[y][x] != rhs.face[y][x]) {\n        return face[y][x] < rhs.face[y][x];\n      }\n    }\n    return false;\n  }\n  bool operator!=(const Face &rhs) const {\n    return *this < rhs || rhs < *this;\n  }\n};\n\nvoid rotation(Face &f, int x) {\n  if (x == 0) { return; }\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - x][y];\n  }\n  f = ret;\n  rotation(f, x - 1);\n}\n\nvoid reverse(Face &f) {\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - y][x];\n  }\n  f = ret;\n}\n\nstruct Dice {\n  Face face[6];\n  bool operator<(const Dice &rhs) const {\n    REP(i, 6) { if (face[i] != rhs.face[i]) { return face[i] < rhs.face[i]; } }\n    return false;\n  }\n};\n\nDice rotation(const Dice &d, int dir, int x) {\n  if (x == 0) { return d; }\n  Dice ret = d;\n  if (dir >= 2) { return rotation(ret, dir - 2, 4 - x); }\n  if (dir == 0) {\n    ret.face[0] = d.face[5];\n    rotation(ret.face[0], 0);\n    ret.face[1] = d.face[1];\n    rotation(ret.face[1], 1);\n    ret.face[2] = d.face[4];\n    rotation(ret.face[2], 2);\n    ret.face[3] = d.face[3];\n    rotation(ret.face[3], 3);\n    ret.face[4] = d.face[0];\n    rotation(ret.face[4], 0);\n    ret.face[5] = d.face[2];\n    rotation(ret.face[5], 2);\n  } else {\n    ret.face[0] = d.face[0];\n    rotation(ret.face[0], 1);\n    ret.face[1] = d.face[4];\n    rotation(ret.face[1], 3);\n    ret.face[2] = d.face[2];\n    rotation(ret.face[2], 3);\n    ret.face[3] = d.face[5];\n    rotation(ret.face[3], 3);\n    ret.face[4] = d.face[3];\n    rotation(ret.face[4], 3);\n    ret.face[5] = d.face[1];\n    rotation(ret.face[5], 1);\n  }\n  return rotation(ret, dir, x - 1);\n}\n\nbool ok(const Dice &d) {\n  bool ret1 = false;\n  bool ret2 = false;\n  REP(x, 3) {\n    ret1 |= d.face[0].face[2][x] == '*';\n    ret2 |= d.face[2].face[2][x] == '*';\n  }\n  return ret1 && ret2;\n}\n\nvoid print(const Dice &d) {\n  REP(iter, 6) {\n    REP(y, 3) {\n      REP(x, 3) {\n        putchar(d.face[iter].face[y][x]);\n      }\n      puts(\"\");\n    }\n  }\n  puts(\"\");\n}\n\nset<Dice> visit;\n\nint calc(Dice d) {\n  queue<pair<Dice, int> > que;\n  que.push(make_pair(d, 0));\n  int ret = 10000;\n  while (!que.empty()) {\n    d = que.front().first;\n    int c = que.front().second;\n    que.pop();\n    if (visit.count(d)) { continue; }\n    visit.insert(d);\n    if (ok(d)) { ret = c; break; }\n    REP(dir, 4) {\n      Dice nd = rotation(d, dir, 1);\n      que.push(make_pair(nd, c + 1));\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  while (true) {\n    visit.clear();\n    Dice d;\n    REP(iter, 6) {\n      REP(y, 3) REP(x, 3) {\n        char c;\n        scanf(\" %c \", &c);\n        if (c == '#') { return 0; }\n        d.face[iter].face[y][x] = c;\n      }\n    }\n    printf(\"%d\\n\", calc(d));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n#define inf 2147480000\nchar box[7][4][4];\nint main(int argc, char *argv[])\n{\n    char a;\n    while(cin>>a)\n    {\n        if(a=='#') break;\n        box[1][1][1]=a;\n        for(int i=1;i<=6;i++)\n        {\n           for(int j=1;j<=3;j++)\n           {\n             for(int u=1;u<=3;u++)\n             {\n               if(i!=1 || j!=1 || u!=1)\n               {\n                 cin>>box[i][j][u];\n               }\n             }\n           }\n        }\n        int minn=inf;\n        if(box[1][3][1]=='*' || box[1][3][2]=='*' || box[1][3][3]=='*')\n        {\n           if(box[3][3][1]=='*' || box[3][3][2]=='*' || box[3][3][3]=='*')\n           {\n              minn=min(minn,0);\n           }\n        }\n        if(box[1][1][1]=='*' || box[1][2][1]=='*' || box[1][3][1]=='*')\n        {\n           if(box[3][1][1]=='*' || box[3][2][1]=='*' || box[3][3][1]=='*')\n           {\n              minn=min(minn,1);\n           }\n        }\n        if(box[1][1][1]=='*' || box[1][1][2]=='*' || box[1][1][3]=='*')\n        {\n           if(box[3][1][1]=='*' || box[3][1][2]=='*' || box[3][1][3]=='*')\n           {\n              minn=min(minn,2);\n           }\n        }\n        if(box[1][1][3]=='*' || box[1][2][3]=='*' || box[1][3][3]=='*')\n        {\n           if(box[3][1][3]=='*' || box[3][2][3]=='*' || box[3][3][3]=='*')\n           {\n              minn=min(minn,1);\n           }\n        }\n\n\n        if(box[2][3][1]=='*' || box[2][3][2]=='*' || box[2][3][3]=='*')\n        {\n           if(box[4][3][1]=='*' || box[4][3][2]=='*' || box[4][3][3]=='*')\n           {\n              minn=min(minn,3);\n           }\n        }\n        if(box[2][1][1]=='*' || box[2][2][1]=='*' || box[2][3][1]=='*')\n        {\n           if(box[4][1][1]=='*' || box[4][2][1]=='*' || box[4][3][1]=='*')\n           {\n              minn=min(minn,2);\n           }\n        }\n        if(box[2][1][1]=='*' || box[2][1][2]=='*' || box[2][1][3]=='*')\n        {\n           if(box[4][1][1]=='*' || box[4][1][2]=='*' || box[4][1][3]=='*')\n           {\n              minn=min(minn,3);\n           }\n        }\n        if(box[2][1][3]=='*' || box[2][2][3]=='*' || box[2][3][3]=='*')\n        {\n           if(box[4][1][3]=='*' || box[4][2][3]=='*' || box[4][3][3]=='*')\n           {\n              minn=min(minn,2);\n           }\n        }\n        \n        if(box[5][3][1]=='*' || box[5][3][2]=='*' || box[5][3][3]=='*')\n        {\n           if(box[6][1][1]=='*' || box[6][1][2]=='*' || box[6][1][3]=='*')\n           {\n              minn=min(minn,1);\n           }\n        }\n        if(box[5][1][1]=='*' || box[5][2][1]=='*' || box[5][3][1]=='*')\n        {\n           if(box[6][1][1]=='*' || box[6][2][1]=='*' || box[6][3][1]=='*')\n           {\n              minn=min(minn,2);\n           }\n        }\n        if(box[5][1][1]=='*' || box[5][1][2]=='*' || box[5][1][3]=='*')\n        {\n           if(box[6][3][1]=='*' || box[6][3][2]=='*' || box[6][3][3]=='*')\n           {\n              minn=min(minn,1);\n           }\n        }\n        if(box[5][1][3]=='*' || box[5][2][3]=='*' || box[5][3][3]=='*')\n        {\n           if(box[6][3][3]=='*' || box[6][2][3]=='*' || box[6][3][3]=='*')\n           {\n              minn=min(minn,2);\n           }\n        }\n        cout<<minn<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  string s[6][3];\n  while(cin>>s[0][0],s[0][0]!=\"#\"){\n\n    for(int i=1;i<18;i++)cin>>s[i/3][i%3];\n\n    if((s[0][2][0]=='*'||s[0][2][1]=='*'||s[0][2][2]=='*')&&(s[2][2][0]=='*'||s[2][2][1]=='*'||s[2][2][2]=='*'))cout<<0<<endl;\n\n    else if((s[0][0][0]=='*'||s[0][1][0]=='*'||s[0][2][0]=='*')&&(s[2][0][2]=='*'||s[2][1][2]=='*'||s[2][2][2]=='*')||\n            (s[0][0][2]=='*'||s[0][1][2]=='*'||s[0][2][2]=='*')&&(s[2][0][0]=='*'||s[2][1][0]=='*'||s[2][2][0]=='*')||\n            (s[4][0][0]=='*'||s[4][0][1]=='*'||s[4][0][2]=='*')&&(s[5][2][0]=='*'||s[5][2][1]=='*'||s[5][2][2]=='*')||\n            (s[4][2][0]=='*'||s[4][2][1]=='*'||s[4][2][2]=='*')&&(s[5][0][0]=='*'||s[5][0][1]=='*'||s[5][0][2]=='*'))cout<<1<<endl;\n\n    else if((s[1][2][0]=='*'||s[1][2][1]=='*'||s[1][2][2]=='*')&&(s[3][2][0]=='*'||s[3][2][1]=='*'||s[3][2][2]=='*')||\n            (s[1][0][0]=='*'||s[1][0][1]=='*'||s[1][0][2]=='*')&&(s[3][0][0]=='*'||s[3][0][1]=='*'||s[3][0][2]=='*'))cout<<3<<endl;\n\n    else cout<<2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nvoid mirror(char m[3][3]){\n  rep(i,3)swap(m[i][0],m[i][2]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_f(){//to->ba, ba->bo, bo->fr, fr -> to\n    upsideDown(m[d[TO]]);\n    mirror(m[d[TO]]);\n   \n    //upsideDown(m[d[BA]]);\n    mirror(m[d[BA]]);\n    \n    upsideDown(m[d[BO]]);\n\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_b(){rep(i,3)rotate_f();}\n  void rotate_l(){\n    rotate_swap(d,LE,FR,RI,BA);\n    rotate_f();\n    rotate_swap(d,LE,BA,RI,FR);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][2][0] =='*' || \n\t m[d[BA]][2][1] =='*' || \t\n\t m[d[BA]][2][2] =='*' ))return true;\n    //rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      /*\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n      */\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct panel{\n  char t[3][3];\n};\n\npanel ra(panel p){\n  char u[3][3];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)u[i][j]=p.t[i][j];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)p.t[i][j]=u[2-j][i];\n  return p;\n}\n\npanel rb(panel p){\n  char u[3][3];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)u[i][j]=p.t[i][j];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)p.t[i][j]=u[2-i][j];\n  return p;\n}\n\nstruct die{\n  panel t[6];\n  bool operator < (const die &p)const{\n    for(int i=0;i<6;i++)\n      for(int j=0;j<3;j++)\n        for(int k=0;k<3;k++)\n          if(t[i].t[j][k]!=p.t[i].t[j][k])\n            return (t[i].t[j][k]<p.t[i].t[j][k]);\n    return false;\n  }\n};\n\ndie ra(die p){\n  panel tmp=p.t[0];\n  p.t[0]=p.t[4];\n  p.t[4]=rb(p.t[2]);\n  p.t[2]=rb(p.t[5]);\n  p.t[5]=tmp;\n  p.t[1]=ra(p.t[1]);\n  p.t[3]=ra(ra(ra(p.t[3])));\n  return p;\n}\n\ndie rb(die p){\n  panel tmp=p.t[1];\n  p.t[1]=ra(ra(ra(p.t[4])));\n  p.t[4]=ra(ra(ra(p.t[3])));\n  p.t[3]=ra(ra(ra(p.t[5])));\n  p.t[5]=ra(ra(ra(tmp)));\n  p.t[0]=ra(ra(ra(p.t[0])));\n  p.t[2]=ra(p.t[2]);\n  return p;\n}\n\nchar str[100];\n\nbool input(panel &p){\n  for(int i=0;i<3;i++){\n    scanf(\"%s\",str);\n    if(str[0]=='#')return false;\n    for(int j=0;j<3;j++)p.t[i][j]=str[j];\n  }\n  return true;\n}\n\nbool check(panel &p){\n  for(int i=0;i<3;i++)\n    if(p.t[2][i]=='*')return true;\n  return false;\n}\n\nint main(){\n  die A;\n  while(input(A.t[0])){\n    for(int i=1;i<6;i++)input(A.t[i]);\n    map< die , int > d;\n    queue< die > Q;\n    d[A]=0;\n    Q.push(A);\n    while(!Q.empty()){\n      die s=Q.front();Q.pop();\n      int cost=d[s];\n      if( check(s.t[0]) && check(s.t[2]) ){\n        cout<<cost<<endl;\n        break;\n      }\n      die next=ra(s);\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n\n      next=ra(ra(ra(s)));\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n\n      next=rb(s);\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n      \n      next=rb(rb(rb(s)));\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * main.cpp\n *\n *  Created on: 2013-7-28\n *      Author: whd\n */\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef long long big;\nstring q[2000];\nmap<string,int>f;\nchar str[300];\nstring a[10],b[10];\nint get(int x,int y,int z)\n{\n\treturn 9*x+3*y+z;\n}\nstring get(const string &s,int k)\n{\n\treturn s.substr(k*9,9);\n}\nbool check(const string &s)\n{\n\tint i;\n\tbool f=false;\n\tfor(i=0;i<3;i++)\n\t\tf|=s[get(0,2,i)]=='*';\n\tif(!f)return false;\n\tf=false;\n\tfor(i=0;i<3;i++)\n\t\tf|=s[get(2,2,i)]=='*';\n\treturn f;\n}\nstring rotl(const string &s)\n{\n\tstring v=s;\n\tv[0]=s[2];\n\tv[1]=s[5];\n\tv[2]=s[8];\n\tv[3]=s[1];\n\tv[4]=s[4];\n\tv[5]=s[7];\n\tv[6]=s[0];\n\tv[7]=s[3];\n\tv[8]=s[6];\n\treturn v;\n}\nstring rotr(const string &s)\n{\n\tstring v=s;\n\tv[0]=s[6];\n\tv[1]=s[3];\n\tv[2]=s[0];\n\tv[3]=s[7];\n\tv[4]=s[4];\n\tv[5]=s[1];\n\tv[6]=s[8];\n\tv[7]=s[5];\n\tv[8]=s[2];\n\treturn v;\n}\nstring c1(const string &s)\n{\n\tstring v=s;\n\tint i;\n\tfor(i=0;i<6;i++)\n\t\ta[i]=get(s,i);\n\tb[0]=rotl(a[0]);\n\tb[1]=rotl(a[5]);\n\tb[2]=rotr(a[2]);\n\tb[3]=rotl(a[4]);\n\tb[4]=rotl(a[1]);\n\tb[5]=rotr(a[3]);\n\tv=\"\";\n\tfor(i=0;i<6;i++)\n\t\tv+=b[i];\n\treturn v;\n}\nstring ud(const string &s)\n{\n\tstring v=s;\n\tv[0]=s[6];\n\tv[1]=s[7];\n\tv[2]=s[8];\n\tv[6]=s[0];\n\tv[7]=s[1];\n\tv[8]=s[2];\n\treturn v;\n}\nstring c2(const string &s)\n{\n\tstring v;\n\tint i;\n\tfor(i=0;i<6;i++)\n\t\ta[i]=get(s,i);\n\tb[4]=a[0];\n\tb[1]=rotr(a[1]);\n\tb[5]=ud(a[2]);\n\tb[3]=rotl(a[3]);\n\tb[2]=ud(a[4]);\n\tb[0]=a[5];\n\tv=\"\";\n\tfor(i=0;i<6;i++)\n\t\tv+=b[i];\n\treturn v;\n}\nstring c3(const string &s)\n{\n\treturn c1(c1(c1(s)));\n}\nstring c4(const string &s)\n{\n\treturn c2(c2(c2(s)));\n}\nint bfs(const string &S)\n{\n\tint h,tail,i;\n\tstring s,v;\n\tq[h=tail=1]=S;\n\tf.clear();\n\tf[S]=0;\n\tif(check(S))return 0;\n\twhile(h<=tail)\n\t{\n\t\ts=q[h++];\n\t\tif(check(s))return f[s];\n\t\tv=c1(s);\n\t\tif(!f.count(v))q[++tail]=v,f[v]=f[s]+1;\n\t\tv=c2(s);\n\t\tif(!f.count(v))q[++tail]=v,f[v]=f[s]+1;\n\t\tv=c3(s);\n\t\tif(!f.count(v))q[++tail]=v,f[v]=f[s]+1;\n\t\tv=c4(s);\n\t\tif(!f.count(v))q[++tail]=v,f[v]=f[s]+1;\n\t}\n\twhile(1);\n}\nint main()\n{\n\tint i;\n\tstring tmp;\n\twhile(scanf(\"%s\",str),str[0]!='#')\n\t{\n\t\ttmp=str;\n\t\tfor(i=0;i<17;i++)\n\t\t\tscanf(\"%s\",str),tmp+=str;\n\t\tprintf(\"%d\\n\",bfs(tmp));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nvoid mirror(char m[3][3]){\n  rep(i,3)swap(m[i][0],m[i][2]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_b(){\n    upsideDown(m[d[TO]]);\n    mirror(m[d[TO]]);\n\n    upsideDown(m[d[BO]]);\n    mirror(m[d[BO]]);\n\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_f(){rep(i,3)rotate_b();}\n  void rotate_l(){\n    rotate_swap(d,LE,FR,RI,BA);\n    rotate_b();\n    rotate_swap(d,LE,BA,RI,FR);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][2][0] =='*' || \n\t m[d[BA]][2][1] =='*' || \t\n\t m[d[BA]][2][2] =='*' ))return true;\n    //rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      /*\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n      */\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  int r=3,c=3;\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,c)rep(j,r)m[i][j]=buf[j][c-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_f(){\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_b(){\n    rep(i,3)rotate_f();\n  }\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n    upsideDown(m[d[LE]]);\n    upsideDown(m[d[BO]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    /*\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][0][0] =='*' || \n\t m[d[BA]][0][1] =='*' || \t\n\t m[d[BA]][0][2] =='*' ))return true;\n    */\n    rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    /*\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][0][0] =='*' || \n\t m[d[BA]][0][1] =='*' || \t\n\t m[d[BA]][0][2] =='*' ))return true;\n    */\n    return false;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n\tif (i == RI || i == LE){\n\t  rep(k,3)rotate_ccw(ini.m[i]);\n\t}else if (i == BA || i == BO){\n\t  upsideDown(ini.m[i]);\n\t}\n      }\n    }\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n \nint main()\n{\n  string in;\n  while(cin>>in){\n    int n = in.length();    \n    int exist[n];\n    long long dp[n][n];\n    bool invalid = false;\n     \n    for(int i = 0; i < n; ++i){\n      if(in[i] == '?'){\n    exist[i] = -1;\n      }else{\n    exist[i] = (in[i]>='A'?in[i]-'A'+10:in[i] - '0') - 1;\n    if( exist[i] >= n ) exist[i] = -1;//invalid = true;\n      }\n    }\n     \n    //cout << \"exist fill\" << endl;\n \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n    dp[i][j] = 0;\n      }\n    }\n \n \n    if( exist[0] < 0 ){\n      for(int j = 0; j < n; ++j){\n    if( n >= 2 &&\n        exist[1] >= 0 &&\n        exist[1] - 1 <= j &&\n        j <= exist[1] + 1 ) continue;\n    dp[0][j] = 1;\n      }\n    }else{\n      if( !(n >= 2 &&\n      exist[1] >= 0 &&\n      exist[1] - 1 <= exist[0] &&\n        exist[0] <= exist[1]+1 )  ){\n    dp[0][exist[0]] = 1;\n      }\n    }\n     \n    //cout << \"dp init\" << endl;\n     \n    for(int i=0;i<n-1;++i){\n      for(int j=0;j<n;++j){\n    if( exist[i+1] >= 0 && j != exist[i+1] ){\n      continue;\n    }\n    if( exist[i] >= 0 &&\n        exist[i]-1 <= j &&\n        j <= exist[i]+1 )\n      continue;\n    if( i < n-2 && exist[i+2] >= 0 &&\n        exist[i+2]-1 <= j &&\n        j <= exist[i+2] + 1 ){\n      continue;\n    }\n    for(int k=-2;j+k>=0;--k){\n      dp[i+1][j]+=dp[i][j+k];\n    }\n    for(int k=2;j+k<n;++k){\n      dp[i+1][j]+=dp[i][j+k];\n    }\n      }\n    }\n \n    long long res = 0;\n    for(int j=0;j<n;++j){\n      res += dp[n-1][j];\n    }\n \n    if( invalid ){\n      res = 0;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Men{\n\tSyoumen,\n\tMigi,\n\tHaimen,\n\tHidari,\n\tUe,\n\tShita,\n};\n\nMen men_array[6] = {Syoumen,Migi,Haimen,Hidari,Ue,Shita};\n\nenum Loc{\n\tTop,\n\tRight,\n\tLeft,\n\tBottom,\n};\n\nchar buf[4];\n\nvoid func(){\n\n\tbool table[6][4];\n\tfor(int i = 0; i < 6; i++){\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\ttable[i][k] = false;\n\t\t}\n\t}\n\n\tfor(int col = 0; col < 3; col++){\n\t\tif(buf[col] == '*'){\n\t\t\ttable[Syoumen][Top] = true;\n\t\t\tif(col == 0){\n\t\t\t\ttable[Syoumen][Left] = true;\n\t\t\t}\n\t\t\tif(col == 2){\n\t\t\t\ttable[Syoumen][Right] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%s\",buf);\n\tfor(int col = 0; col < 3; col++){\n\t\tif(buf[col] == '*'){\n\t\t\tif(col == 0){\n\t\t\t\ttable[Syoumen][Left] = true;\n\t\t\t}\n\t\t\tif(col == 2){\n\t\t\t\ttable[Syoumen][Right] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%s\",buf);\n\tfor(int col = 0; col < 3; col++){\n\t\tif(buf[col] == '*'){\n\t\t\ttable[Syoumen][Bottom] = true;\n\t\t\tif(col == 0){\n\t\t\t\ttable[Syoumen][Left] = true;\n\t\t\t}\n\t\t\tif(col == 2){\n\t\t\t\ttable[Syoumen][Right] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= 5; i++){\n\n\t\tscanf(\"%s\",buf);\n\t\tfor(int col = 0; col < 3; col++){\n\t\t\tif(buf[col] == '*'){\n\t\t\t\ttable[men_array[i]][Top] = true;\n\t\t\t\tif(col == 0){\n\t\t\t\t\ttable[men_array[i]][Left] = true;\n\t\t\t\t}\n\t\t\t\tif(col == 2){\n\t\t\t\t\ttable[men_array[i]][Right] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\",buf);\n\t\tfor(int col = 0; col < 3; col++){\n\t\t\tif(buf[col] == '*'){\n\t\t\t\tif(col == 0){\n\t\t\t\t\ttable[men_array[i]][Left] = true;\n\t\t\t\t}\n\t\t\t\tif(col == 2){\n\t\t\t\t\ttable[men_array[i]][Right] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\",buf);\n\t\tfor(int col = 0; col < 3; col++){\n\t\t\tif(buf[col] == '*'){\n\t\t\t\ttable[men_array[i]][Bottom] = true;\n\t\t\t\tif(col == 0){\n\t\t\t\t\ttable[men_array[i]][Left] = true;\n\t\t\t\t}\n\t\t\t\tif(col == 2){\n\t\t\t\t\ttable[men_array[i]][Right] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\n\t//{Syoumen,Migi,Haimen,Hidari,Ue,Shita};\n\n\tif(table[Syoumen][Bottom] == true && table[Haimen][Bottom] == true){\n\t\tans = 0;\n\t}\n\n\tif((table[Syoumen][Right] == true && table[Haimen][Left] == true) || (table[Syoumen][Left] == true && table[Haimen][Right] == true)){\n\t\tans = min(ans,1);\n\t}\n\n\tif(table[Syoumen][Top] == true && table[Haimen][Top] == true){\n\t\tans = min(ans,2);\n\t}\n\n\tif((table[Ue][Bottom] == true && table[Shita][Top] == true) || (table[Ue][Top] == true && table[Shita][Bottom] == true)){\n\t\tans = min(ans,1);\n\t}\n\n\tif((table[Ue][Right] == true && table[Shita][Right] == true) || (table[Ue][Left] == true && table[Shita][Left] == true)){\n\t\tans = min(ans,2);\n\t}\n\n\tif((table[Migi][Left] == true && table[Hidari][Right] == true) || (table[Migi][Right] == true && table[Hidari][Left] == true)){\n\t\tans = min(ans,2);\n\t}\n\n\tif((table[Migi][Top] == true && table[Hidari][Top] == true) || (table[Migi][Bottom] == true && table[Hidari][Bottom] == true)){\n\t\tans = min(ans,3);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%s\",buf);\n\t\tif(buf[0] == '#')break;\n\n\t\tfunc();\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Face {\n  char face[3][3];\n  bool operator<(const Face &rhs) const {\n    REP(y, 3) REP(x, 3) {\n      if (face[y][x] != rhs.face[y][x]) {\n        return face[y][x] < rhs.face[y][x];\n      }\n    }\n    return false;\n  }\n  bool operator!=(const Face &rhs) const {\n    return *this < rhs || rhs < *this;\n  }\n};\n\nvoid rotation(Face &f, int x) {\n  if (x == 0) { return; }\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - x][y];\n  }\n  f = ret;\n  rotation(f, x - 1);\n}\n\nvoid reverse(Face &f) {\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - y][x];\n  }\n  f = ret;\n}\n\nstruct Dice {\n  Face face[6];\n  bool operator<(const Dice &rhs) const {\n    REP(i, 6) { if (face[i] != rhs.face[i]) { return face[i] < rhs.face[i]; } }\n    return false;\n  }\n};\n\nDice rotation(const Dice &d, int dir, int x) {\n  if (x == 0) { return d; }\n  Dice ret = d;\n  if (dir >= 2) { return rotation(ret, dir - 2, 4 - x); }\n  if (dir == 0) {\n    ret.face[0] = d.face[5];\n    rotation(ret.face[0], 0);\n    ret.face[1] = d.face[1];\n    rotation(ret.face[1], 1);\n    ret.face[2] = d.face[4];\n    rotation(ret.face[2], 2);\n    ret.face[3] = d.face[3];\n    rotation(ret.face[3], 1);\n    ret.face[4] = d.face[0];\n    rotation(ret.face[4], 0);\n    ret.face[5] = d.face[2];\n    rotation(ret.face[5], 2);\n  } else {\n    ret.face[0] = d.face[0];\n    rotation(ret.face[0], 1);\n    ret.face[1] = d.face[4];\n    rotation(ret.face[1], 3);\n    ret.face[2] = d.face[2];\n    rotation(ret.face[2], 1);\n    ret.face[3] = d.face[5];\n    rotation(ret.face[3], 1);\n    ret.face[4] = d.face[3];\n    rotation(ret.face[4], 3);\n    ret.face[5] = d.face[1];\n    rotation(ret.face[5], 1);\n  }\n  return rotation(ret, dir, x - 1);\n}\n\nbool ok(const Dice &d) {\n  bool ret1 = false;\n  bool ret2 = false;\n  REP(x, 3) {\n    ret1 |= d.face[0].face[2][x] == '*';\n    ret2 |= d.face[2].face[2][x] == '*';\n  }\n  return ret1 && ret2;\n}\n\nvoid print(const Dice &d) {\n  REP(iter, 6) {\n    REP(y, 3) {\n      REP(x, 3) {\n        putchar(d.face[iter].face[y][x]);\n      }\n      puts(\"\");\n    }\n  }\n  puts(\"\");\n}\n\nset<Dice> visit;\n\nint calc(Dice d) {\n  queue<pair<Dice, int> > que;\n  que.push(make_pair(d, 0));\n  int ret = 0;\n  while (!que.empty()) {\n    d = que.front().first;\n    int c = que.front().second;\n    que.pop();\n    if (visit.count(d)) { continue; }\n    visit.insert(d);\n    if (ok(d)) { ret = c; break; }\n    REP(dir, 4) {\n      Dice nd = rotation(d, dir, 1);\n      que.push(make_pair(nd, c + 1));\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  while (true) {\n    visit.clear();\n    Dice d;\n    REP(iter, 6) {\n      REP(y, 3) REP(x, 3) {\n        char c;\n        scanf(\" %c \", &c);\n        if (c == '#') { return 0; }\n        d.face[iter].face[y][x] = c;\n      }\n    }\n    printf(\"%d\\n\", calc(d));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nbool input(vs& v)\n{\n\tv.resize(18);\n\tREP(i, 18)\n\t{\n\t\tcin >> v[i];\n\t\tif (v[i] == \"#\") return false;\n\t}\n\treturn true;\n}\n\nvs to_clock(vs& v)\n{\n\tvs res(3, string(\"@@@\"));\n\tREP(i, 3)REP(j,3)res[i][j] = v[2-j][i];\n\treturn res;\n}\n\nvs to_cclock(vs& v)\n{\n\tvs res = v;\n\tREP(i, 3) res = to_clock(res);\n\treturn res;\n}\n\nvs reverse(vs& v)\n{\n\tvs res = v;\n\tswap(res[0], res[2]);\n\treturn res;\n}\n\nstruct Room\n{\n\tvs front, right, back, left, top, bottom;\n\tRoom(vs v)\n\t{\n\t\tFOR(i, 0, 3) front.push_back(v[i]);\n\t\tFOR(i, 3, 6) right.push_back(v[i]);\n\t\tFOR(i, 6, 9) back.push_back(v[i]);\n\t\tFOR(i, 9, 12) left.push_back(v[i]);\n\t\tFOR(i, 12, 15) top.push_back(v[i]);\n\t\tFOR(i, 15, 18) bottom.push_back(v[i]);\n\t}\n\tvoid to_front()\n\t{\n\t\tvs nfront, nright, nback, nleft, ntop, nbottom;\n\t\tnfront = bottom;\n\t\tntop = front;\n\t\tnback = reverse(top);\n\t\tnbottom = reverse(back);\n\t\tnleft = to_cclock(left);\n\t\tnright = to_clock(right);\n\t\tfront = nfront;\n\t\tright = nright;\n\t\tback = nback;\n\t\tleft = nleft;\n\t\ttop = ntop;\n\t\tbottom = nbottom;\n\t}\n\tvoid to_back() \n\t{\n\t\tREP(i, 3) to_front();\n\t}\n\tvoid to_right()\n\t{\n\t\tvs nfront, nright, nback, nleft, ntop, nbottom;\n\t\tntop = to_clock(left);\n\t\tnleft = to_clock(bottom);\n\t\tnbottom = to_clock(right);\n\t\tnright = to_clock(top);\n\t\tnfront = to_clock(front);\n\t\tnback = to_cclock(back);\n\t\tfront = nfront;\n\t\tright = nright;\n\t\tback = nback;\n\t\tleft = nleft;\n\t\ttop = ntop;\n\t\tbottom = nbottom;\n\t}\n\tvoid to_left()\n\t{\n\t\tREP(i, 3) to_right();\n\t}\n};\n\nbool check(Room& room)\n{\n\tvs a = room.front, b = room.back;\n\tbool f1 = false, f2 = false;\n\tREP(i, 3)\n\t{\n\t\tif (a[2][i] == '*') f1 = true;\n\t\tif (b[2][i] == '*') f2 = true;\n\t}\n\treturn f1 && f2;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tvs v;\n\twhile (input(v))\n\t{\n\t\tRoom room(v);\n\t\tqueue<pair<Room, int>> que;\n\t\tque.emplace(room, 0);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tRoom tmp = que.front().first; int t = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (check(tmp))\n\t\t\t{\n\t\t\t\tcout << t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRoom nx = tmp;\n\t\t\tnx.to_front();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_back();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_right();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_left();\n\t\t\tque.emplace(nx, t + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n// ツサツイツコツδ債づ個姪環づ個遷ツ暗堋表ツ．ツ姪環氾板債づ債，ツ湘」ツ，ツ債カツ，ツ青ウツ姪環，ツ可コツ，ツ右ツ，ツ背ツ姪環づ個渉．\nchar dice[6][4] = {\n\t{5,2,1,4}, {1,1,3,0}, {0,3,2,2},\n\t{2,5,4,1}, {4,4,0,3}, {3,0,5,5}\n};\n\nint main(){\n\tint step[6][6];\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<pair<int, int>, int> > qu;\n\tqu.push(make_pair(make_pair(0, 2), 0));\n\tqu.push(make_pair(make_pair(0, 5), 0));\n\twhile(!qu.empty()){\n\t\tpair< pair<int,int>, int > p = qu.front(); qu.pop();\n\t\tint a = p.first.first, b = p.first.second, c = p.second;\n\t\tif(step[a][b] != -1) continue;\n\t\tstep[a][b] = c;\n\t\tfor(int i=0;i<4;i++)\n\t\t\tqu.push(make_pair(make_pair(dice[a][i], dice[b][i]), c+1));\n\t}\n\tstring str[6][3];\n\tint conv[6] = {2, 4, 5, 1, 0, 3};\n\tint mask[3][3] = {\n\t\t{ 9, 1, 3},\n\t\t{ 8, 0, 2},\n\t\t{12, 4, 6}\n\t};\n\tint front[3] = {0, 1, 4};\n\tint back[3]  = {2, 3, 5};\n\tint up[3][4] = {\n\t\t{5, 1, 4, 3},\n\t\t{5, 2, 4, 0},\n\t\t{2, 1, 0, 3}\n\t};\n\twhile(cin >> str[0][0]){\n\t\tif(str[0][0] == \"#\") break;\n\t\tcin >> str[0][1] >> str[0][2];\n\t\tfor(int i=1;i<6;i++)\n\t\t\tfor(int j=0;j<3;j++) cin >> str[i][i==5 ? 2-j : j];\n\t\tfor(int i=0;i<2;i++)\n\t\t\tfor(int j=0;j<3;j++) reverse(str[i][j].begin(), str[i][j].end());\n\t\tint ans = 1000000000;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint mf = 0, mb = 0;\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(str[front[i]][j][k] == '*') mf |= mask[j][k];\n\t\t\t\t\tif(str[back[i]][j][k]  == '*') mb |= mask[j][k];\n\t\t\t\t}\n\t\t\tint m = (mf&mb);\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(m&(1<<j)){\n\t\t\t\t\tans = min(ans, step[conv[up[i][j]]][conv[front[i]]]);\n\t\t\t\t\tans = min(ans, step[conv[up[i][j]]][conv[back[i]]]);\n\t\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\n\n\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「\nint rotateRight[]={0,1,3,5,2,4,6};\n// zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツキツヲテ・ツ崢榲ィツサツ「\nint rotateLeft[]={0,1,4,2,5,3,6};\n// テ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツ?ヲテ」ツδ榲」ツδε」ツδ?」ツ?凖」ツつ鞠aceテ」ツつ津ヲツ篠「テ」ツ??\n// curFaceテ」ツ?ォテァツオツ静ヲツ楪愿」ツつ津、ツサツ」テ・ツ?・\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // テ」ツ?禿」ツ?禿」ツ?ァテ・ツ按、テ・ツョツ?\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // テ・ツキツヲテ」ツ?クテ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツつ津・ツ?津」ツ??\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // テ・ツ可催」ツ?クテ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツつ津・ツ?津」ツ??\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // テ」ツ?禿」ツ?禿」ツ?ァテ・ツ按、テ・ツョツ?\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)nfield[l][2-k]=field[i-1][j][k][l];\n        // fieldテ」ツつ津・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)field[i][j][k][l]=nfield[l][k];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      int cnt2=0;\n      if(label[front]>=1&&label[front]<=4){\n        if(ang==0||ang==3){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n      }\n      else{\n        for(int j=0;j<3;j++)cnt1+=(field[(ang+2)%4][label[front]][2][j]=='*');\n        for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n      }\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // テゥツ敖「テ」ツつ津・ツ崢崚ヲツ鳴ケテ・ツ青妥」ツ?ォテ・ツ崢榲ィツサツ「\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // テ・ツ可?\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // テ・ツセツ古」ツつ?\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\n/*\n 4\n 0 1 2 3\n 5\n ????????????????±????????????§????????????????¨?????????§????????????\n */\n\nbitset<4> cw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+1)%4] = b[i];\n  return nb;\n}\n\nbitset<4> ccw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+3)%4] = b[i];\n  return nb;\n}\n\nstruct state{\n  vector<bitset<4>> b;\n  state(){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n  }\n  state(const state &s){\n    b = s.b; // copy\n  }\n  state(int hash){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n    rep(i,6) rep(j,4){\n      b[5-i][3-j] = hash%2;\n      hash/=2;\n    }\n  }\n  int hash(){\n    int h = 0;\n    rep(i,6) rep(j,4) h = (h<<1) + b[i][j];\n    return h;\n  }\n  bitset<4>& operator[](int i){ return b[i]; }\n\n  void front(){ // ???????????????\n    vector<bitset<4>> nb(6);\n    nb[0] = b[4];\n    nb[1] = ccw(b[1]);\n    nb[2] = cw(cw(b[5]));\n    nb[3] = cw(b[3]);\n    nb[4] = cw(cw(b[2]));\n    nb[5] = b[0];\n    swap(nb, b);\n  }\n  void right(){\n    vector<bitset<4>> nb(6);\n    nb[0] = cw(b[0]);\n    nb[1] = cw(b[4]);\n    nb[2] = ccw(b[2]);\n    nb[3] = cw(b[5]);\n    nb[4] = cw(b[3]);\n    nb[5] = cw(b[1]);\n    swap(nb,b);\n  }\n\n  bool ok(){\n    return b[0][2] & b[2][2];\n  }\n};\n\nint main(){\n  while(true){\n    state st;\n    rep(i,6){\n      string t[3];\n      rep(j,3){\n        cin>>t[j];\n        if(t[0]==\"#\") return 0;\n      }\n      st[i][0] = t[0][0]=='*' || t[0][1]=='*' || t[0][2]=='*';\n      st[i][1] = t[0][2]=='*' || t[1][2]=='*' || t[2][2]=='*';\n      st[i][2] = t[2][0]=='*' || t[2][1]=='*' || t[2][2]=='*';\n      st[i][3] = t[0][0]=='*' || t[1][0]=='*' || t[2][0]=='*';\n    }\n\n    vector<int> d(1<<24, INF);\n    queue<int> q;\n    q.push(st.hash());\n    d[st.hash()] = 0;\n    int ans;\n    bool flg = true;\n    while(flg){ assert(!q.empty());\n      int h = q.front(); q.pop();\n      state s(h);\n      if(s.ok()){\n        ans = d[h];\n        break;\n      }\n      int nd = d[h]+1;\n      auto exec = [&](state &S){\n        if(S.ok()){\n          ans = nd;\n          flg=false;\n          return;\n        }\n        int hs = S.hash();\n        if(d[hs] > nd){\n          q.push(hs);\n          d[hs] = nd;\n        }\n      };\n\n      state s1(s);\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.front();\n      exec(s1);\n      s1.front();\n      s1.front();\n      exec(s1);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nchar a[100010][8][5][5],h[100010];\nint ck_goal(int f){\n    if((a[f][1][3][1]==0||a[f][1][3][2]==0||a[f][1][3][3]==0)&&(a[f][3][3][1]==0||a[f][3][3][2]==0||a[f][3][3][3]==0))return 1;return 0;\n}\nvoid ts(int f,int e,int u,int v){\n    int i,j;\n    for(i=1;i<=3;i++)\n        for(j=1;j<=3;j++)\n        a[e][v][i][j]=a[f][u][4-j][i];\n    return;\n}\nvoid tn(int f,int e,int u,int v){\n    int i,j;\n    for(i=1;i<=3;i++)\n        for(j=1;j<=3;j++)\n        a[e][v][i][j]=a[f][u][j][4-i];\n    return;\n}\nvoid od(int f,int e,int u,int v){\n    int i,j;\n    for(i=1;i<=3;i++)\n        for(j=1;j<=3;j++)\n        a[e][v][i][j]=a[f][u][i][j];\n    return;\n}\nvoid add(int f,int e,int i){\n    if(i==1){od(f,e,1,5);od(f,e,5,3);od(f,e,3,6);od(f,e,6,1);ts(f,e,4,4);ts(f,e,2,2);}\n    if(i==2){tn(f,0,5,0);od(0,e,0,2);tn(f,0,2,0);od(0,e,0,6);ts(f,0,6,0);od(0,e,0,4);tn(f,0,4,0);od(0,e,0,5);ts(f,e,1,1);ts(f,e,3,3);}\n    if(i==3){od(f,e,1,6);od(f,e,6,3);od(f,e,3,5);od(f,e,5,1);tn(f,e,4,4);tn(f,e,2,2);}\n    if(i==4){tn(f,0,2,0);od(0,e,0,5);ts(f,0,6,0);od(0,e,0,2);ts(f,0,4,0);od(0,e,0,6);ts(f,0,5,0);od(0,e,0,4);tn(f,e,1,1);tn(f,e,3,3);}\n    return;\n}\nint ck_re(int f){\n    int i,j,k,l;\n    for(l=1;l<=f-1;l++){\n        for(i=1;i<=6;i++)\n            for(j=1;j<=3;j++)\n                for(k=1;k<=3;k++)\n                    if(a[f][i][j][k]!=a[l][i][j][k])goto x;\n        return 0;\n        x:;\n    }\n    return 1;\n}\nint main()\n{\n    int i,j,k,l,f,e;\n    char c;\n    //freopen(\"test.txt\",\"r\",stdin);\n    while(scanf(\"%c\",&c)&&c!='#'){\n        memset(a,0,sizeof(a));\n        for(i=1;i<=6;i++)\n            for(j=1;j<=3;j++){\n                for(k=1;k<=3;k++)\n                {if(c=='.')a[1][i][j][k]=1;c=getchar();}\n                c=getchar();\n            }\n        h[1]=0;\n        if(ck_goal(1)==1){printf(\"0\\n\");goto x2;}\n        f=0;e=1;\n        while(e<100000&&f<=e){\n            f++;\n            for(i=1;i<=4;i++)\n                {\n                    //printf(\"%d\\n\",e+1);\n                    add(f,e+1,i);\n                    //for(l=1;l<=6;l++)for(j=1;j<=3;j++){for(k=1;k<=3;k++)printf(\"%d\",a[e+1][l][j][k]);printf(\"\\n\");}printf(\"\\n\");//e++;\n                    if(ck_re(e+1)==1){\n                        e++;\n                        h[e]=h[f]+1;\n                        if(ck_goal(e)==1){printf(\"%d\\n\",h[e]);\n                            goto x2;}\n                    }\n                }\n        }\n        x2:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <set>\n#define X first\n#define Y second\n#define sqr(x) (x)*(x)\nusing namespace std;\nconst double PI = acos(-1.0);\nmap<int,int>::iterator it;\ntypedef long long LL ;\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\nstruct face\n{\n    int p[3][3];\n    face rotate_left()\n    {\n        face ret;\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                ret.p[2-j][i]=p[i][j];\n            }\n        }\n        return ret;\n    }\n    face rotate_right()\n    {\n        face ret = rotate_left();\n        ret = ret.rotate_left();\n        ret = ret.rotate_left();\n        return ret;\n    }\n    void input()\n    {\n        char s[5][5];\n        for(int i=0;i<3;++i)\n        {\n            scanf(\"%s\",s[i]);\n        }\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                p[i][j]=(s[i][j]=='.')?0:1;\n            }\n        }\n    }\n    void pf()\n    {\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                printf(\"%d\",p[i][j]);\n            }\n            puts(\"\");\n        }\n    }\n};\n\n\n\n\nstruct cube\n{\n    face f[8];\n    int dis;\n    cube left()\n    {\n        cube ret ;\n        ret.f[0] = (*this).f[0].rotate_left();\n        ret.f[1] = (*this).f[5].rotate_right();\n        ret.f[2] = (*this).f[2].rotate_right();\n        ret.f[3] = (*this).f[4].rotate_right();\n        ret.f[4] = (*this).f[1].rotate_right();\n        ret.f[5] = (*this).f[3].rotate_right();\n        return ret;\n    }\n    cube right()\n    {\n        cube ret;\n        ret.f[0] = (*this).f[0].rotate_right();\n        ret.f[1] = (*this).f[4].rotate_left();\n        ret.f[2] = (*this).f[2].rotate_left();\n        ret.f[3] = (*this).f[5].rotate_left();\n        ret.f[4] = (*this).f[1].rotate_left();\n        ret.f[5] = (*this).f[3].rotate_left();\n        return ret;\n    }\n    cube forward()\n    {\n        cube ret;\n        ret.f[0] = (*this).f[5];\n        ret.f[1] = (*this).f[1].rotate_right();\n        ret.f[2] = (*this).f[4].rotate_left();\n        ret.f[2] = ret.f[2].rotate_left();\n        ret.f[3] = (*this).f[3].rotate_left();\n        ret.f[4] = (*this).f[0];\n        ret.f[5] = (*this).f[2].rotate_left();\n        ret.f[5] = ret.f[5].rotate_left();\n        return ret;\n    }\n    cube back()\n    {\n        cube ret = (*this).forward();\n        ret = ret.forward();\n        ret = ret.forward();\n        return ret;\n    }\n    bool good()\n    {\n        bool ok1=0,ok2=0;\n        for(int i=0;i<3;++i)\n        {\n            if(f[0].p[2][i]==1)ok1=1;\n            if(f[2].p[2][i]==1)ok2=1;\n        }\n        return ok1&&ok2;\n    }\n    void pf()\n    {\n        for(int i=0;i<6;++i)\n        {\n            f[i].pf();\n        }\n    }\n};\ncube C;\nint res;\nvoid dfs(cube u,int depth)\n{\n    if(depth>9)return ;\n    if(u.good())\n    {\n        //printf(\"d = %d\\n\",depth);\n        res = min(res,depth);\n    }\n    else\n    {\n        cube v = u.back();\n        dfs(v,depth+1);\n        v = u.forward();\n        dfs(v,depth+1);\n        v = u.left();\n        dfs(v,depth+1);\n        v = u.right();\n        dfs(v,depth+1);\n    }\n}\nint main()\n{\n    char s[8][8];\n//    face ff;\n//    ff.input();\n//    ff.pf();\n//    ff=ff.rotate_left();\n//    ff.pf();\n//    ff=ff.rotate_left();\n//    ff.pf();\n\n    while(1)\n    {\n        scanf(\"%s\",s[0]);\n        if(s[0][0]=='#')break;\n        for(int i=1;i<3;++i)scanf(\"%s\",s[i]);\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                C.f[0].p[i][j]=(s[i][j]=='.')?0:1;\n            }\n        }\n        for(int i=1;i<6;++i)C.f[i].input();\n        //puts(\"OK\");\n        res=10000;\n        //C.f[0].pf();\n        //C.f[2].pf();\n//        C.pf();\n//        C = C.left();\n//        puts(\"\");\n//        C.pf();\n//        C = C.right();\n//        puts(\"\");\n//        C.pf();\n        dfs(C,0);\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 6\nusing namespace std;\ntypedef pair<int,string> P;\n\nstring rot_N(string s){\n  \n  string t=s;\n  \n  t[9*4+0]=s[0];\n  t[9*4+1]=s[1];\n  t[9*4+2]=s[2];\n  t[9*4+3]=s[3];\n  t[9*4+4]=s[4];\n  t[9*4+5]=s[5];\n  t[9*4+6]=s[6];\n  t[9*4+7]=s[7];\n  t[9*4+8]=s[8];\n  \n  t[9*2+0]=s[9*4+8];\n  t[9*2+1]=s[9*4+7];\n  t[9*2+2]=s[9*4+6];\n  t[9*2+3]=s[9*4+5];\n  t[9*2+4]=s[9*4+4];\n  t[9*2+5]=s[9*4+3];\n  t[9*2+6]=s[9*4+2];\n  t[9*2+7]=s[9*4+1];\n  t[9*2+8]=s[9*4+0];\n  \n  t[9*5+0]=s[9*2+8];\n  t[9*5+1]=s[9*2+7];\n  t[9*5+2]=s[9*2+6];\n  t[9*5+3]=s[9*2+5];\n  t[9*5+4]=s[9*2+4];\n  t[9*5+5]=s[9*2+3];\n  t[9*5+6]=s[9*2+2];\n  t[9*5+7]=s[9*2+1];\n  t[9*5+8]=s[9*2+0];\n\n  t[0]=s[9*5+0];\n  t[1]=s[9*5+1];\n  t[2]=s[9*5+2];\n  t[3]=s[9*5+3];\n  t[4]=s[9*5+4];\n  t[5]=s[9*5+5];\n  t[6]=s[9*5+6];\n  t[7]=s[9*5+7];\n  t[8]=s[9*5+8];\n  \n  t[9+0]=s[9+6];\n  t[9+1]=s[9+3];\n  t[9+2]=s[9+0];\n  t[9+3]=s[9+7];\n  t[9+4]=s[9+4];\n  t[9+5]=s[9+1];\n  t[9+6]=s[9+8];\n  t[9+7]=s[9+5];\n  t[9+8]=s[9+2];\n  \n  t[9*3+0]=s[9*3+2];\n  t[9*3+1]=s[9*3+5];\n  t[9*3+2]=s[9*3+8];\n  t[9*3+3]=s[9*3+1];\n  t[9*3+4]=s[9*3+4];\n  t[9*3+5]=s[9*3+7];\n  t[9*3+6]=s[9*3+0];\n  t[9*3+7]=s[9*3+3];\n  t[9*3+8]=s[9*3+6];\n  \n  return t;\n}\n\nstring rot_E(string s){\n  \n  string t=s;\n  \n  t[9+0]=s[9*4+6];\n  t[9+1]=s[9*4+3];\n  t[9+2]=s[9*4+0];\n  t[9+3]=s[9*4+7];\n  t[9+4]=s[9*4+4];\n  t[9+5]=s[9*4+1];\n  t[9+6]=s[9*4+8];\n  t[9+7]=s[9*4+5];\n  t[9+8]=s[9*4+2];\n  \n  t[9*5+0]=s[9+6];\n  t[9*5+1]=s[9+3];\n  t[9*5+2]=s[9+0];\n  t[9*5+3]=s[9+7];\n  t[9*5+4]=s[9+4];\n  t[9*5+5]=s[9+1];\n  t[9*5+6]=s[9+8];\n  t[9*5+7]=s[9+5];\n  t[9*5+8]=s[9+2];\n  \n  t[9*3+0]=s[9*5+6];\n  t[9*3+1]=s[9*5+3];\n  t[9*3+2]=s[9*5+0];\n  t[9*3+3]=s[9*5+7];\n  t[9*3+4]=s[9*5+4];\n  t[9*3+5]=s[9*5+1];\n  t[9*3+6]=s[9*5+8];\n  t[9*3+7]=s[9*5+5];\n  t[9*3+8]=s[9*5+2];\n  \n  t[9*4+0]=s[9*3+6];\n  t[9*4+1]=s[9*3+3];\n  t[9*4+2]=s[9*3+0];\n  t[9*4+3]=s[9*3+7];\n  t[9*4+4]=s[9*3+4];\n  t[9*4+5]=s[9*3+1];\n  t[9*4+6]=s[9*3+8];\n  t[9*4+7]=s[9*3+5];\n  t[9*4+8]=s[9*3+2];\n  \n  t[0]=s[6];\n  t[1]=s[3];\n  t[2]=s[0];\n  t[3]=s[7];\n  t[4]=s[4];\n  t[5]=s[1];\n  t[6]=s[8];\n  t[7]=s[5];\n  t[8]=s[2];\n\n  t[9*2+0]=s[9*2+2];\n  t[9*2+1]=s[9*2+5];\n  t[9*2+2]=s[9*2+8];\n  t[9*2+3]=s[9*2+1];\n  t[9*2+4]=s[9*2+4];\n  t[9*2+5]=s[9*2+7];\n  t[9*2+6]=s[9*2+0];\n  t[9*2+7]=s[9*2+3];\n  t[9*2+8]=s[9*2+6];\n  \n  return t;\n}\n\n\nstring rot_S(string s){\n  s=rot_N(s); s=rot_N(s); s=rot_N(s);\n  return s;\n}\n\nstring rot_W(string s){\n  s=rot_E(s); s=rot_E(s); s=rot_E(s);\n  return s;\n}\n\nbool check(string s){\n  return (s[6]=='*'||s[7]=='*'||s[8]=='*')&&(s[9*2+6]=='*'||s[9*2+7]=='*'||s[9*2+8]=='*');\n}\n\n/*\n  \n  012\n  345\n  678\n  [4]\n  \n  012 012 012 012\n  345 345 345 345\n  678 678 678 678\n  [0] [1] [2] [3]\n  \n  012\n  345\n  678\n  [5]\n  \n*/\n\nqueue<P> q;\nset<string> memo;\n\nint bfs(){\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    string s=t.second;\n\n    if(memo.count(s)) continue;\n    memo.insert(s);\n    \n    int cnt=t.first;\n    \n    if(check(s)) return cnt;\n    \n    string ns;\n    \n    ns=rot_N(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_E(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_S(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_W(s);\n    q.push(P(cnt+1,ns));\n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    string s,t;\n\n    cin>>t;\n    if(t==\"#\") break;\n    \n    s+=t;\n    \n    for(int i=0;i<17;i++){\n      cin>>t;\n      s+=t;\n    }\n\n    q.push(P(0,s));\n    \n    cout<<bfs()<<endl;\n\n    while(!q.empty())  q.pop();\n  }\n  \n  return 0;\n}\n\n/*\n\n  L(???,R(?,????????))\n\n  L(R(?,R(?,????)),?))\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nint Max(int &a,int b){return a=max(a,b);}\nint Min(int &a,int b){return a=min(a,b);}\n\n/*?????¬??????TOP?????????????????¢?????????*/\n/*TOP??¨BOTTOM???FRONT?????????????????¢?????????*/\n/************/\n/*  0       */\n/*  1 3 4 2 */\n/*  5       */\n/************/\nclass Cube{\npublic:\n  struct cdat{char num[3][3];};\n  const int TOP = 0, FRONT = 1, LEFT = 2;\n  const int RIGHT = 3, BACK = 4, BOTTOM = 5;\n  cdat cube[6];\n\n  void rot(string cmd){\n    if(cmd == \"N\") rotN();\n    else if(cmd == \"E\") rotE();\n    else if(cmd == \"S\") rotS();\n    else if(cmd == \"W\") rotW();\n    else if(cmd == \"CW\") rotCW();\n    else if(cmd == \"CCW\") rotCCW();\n    else exit(1);\n  }\n\n  void pr(){\n    map<int,string> M;\n    M[0] = \"TOP\",M[1] = \"FRONT\",M[2] = \"LEFT\";\n    M[3] = \"RIGHT\", M[4] = \"BACK\", M[5] = \"BOTTOM\";\n    for(int i=0;i<6;i++){\n      cout<<M[i]<<endl;\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++)cout<<cube[i].num[j][k];\n        cout<<endl;\n      }\n    }\n  }\n\n  void rot90(cdat &a){\n    cdat b = a;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++) a.num[i][j] = b.num[2-j][i];\n  }\n  void reverseX(cdat &a){for(int i=0;i<3;i++) reverse(a.num[i],a.num[i]+3);}\n  void reverseY(cdat &a){rot90(a),reverseX(a),rot90(a),rot90(a),rot90(a);}\n  \n\n  void rotN(){  //?\\\\?????¢??????\n    swap(cube[TOP],cube[FRONT]);\n    swap(cube[FRONT],cube[BOTTOM]);\n    swap(cube[BOTTOM],cube[BACK]);\n    rot90(cube[TOP]),rot90(cube[TOP]);\n    rot90(cube[BOTTOM]),rot90(cube[BOTTOM]);\n    rot90(cube[LEFT]),rot90(cube[LEFT]),rot90(cube[LEFT]);\n    rot90(cube[RIGHT]);\n  }\n\n\n  void rotCCW(){  //??????????????????????¨???????????????????\n    swap(cube[FRONT],cube[LEFT]);\n    swap(cube[LEFT],cube[BACK]);\n    swap(cube[BACK],cube[RIGHT]);\n    rot90(cube[TOP]),rot90(cube[TOP]),rot90(cube[TOP]);\n    rot90(cube[BOTTOM]);\n  }\n  \n  void rotE(){rotCCW();rotN();rotCW();}//????????¢??????\n  void rotS(){rotN(),rotN(),rotN();}//???????????¢??????\n  void rotW(){rotE(),rotE(),rotE();}//????????¢??????\n  void rotCW(){rotCCW(),rotCCW(),rotCCW();}//???????????????????¨????????????????\n};\n\nCube C;\nconst int TOP = 0, FRONT = 1, LEFT = 2;\nconst int RIGHT = 3, BACK = 4, BOTTOM = 5;\n\n\nbool check(const Cube &c){\n  bool front=0,back=0;\n  for(int i=0;i<3;i++) front |= c.cube[FRONT].num[2][i] == '*';\n  for(int i=0;i<3;i++) back |= c.cube[BACK].num[2][i] == '*';\n  return front && back;\n}\n\nstring dir[] = {\"N\",\"E\",\"S\",\"W\"};\nint ans;\nvoid dfs(int dep){\n  if(check(C)) ans = dep;\n  if(ans <= dep) return;\n  for(int i=0;i<4;i++){\n    C.rot(dir[i]);\n    dfs(dep+1);\n    C.rot(dir[(i+2)%4]);\n  }\n}\n\nsigned main(){\n  while(1){\n    int ord[]={FRONT,RIGHT,BACK,LEFT,TOP,BOTTOM};\n    for(int i=0;i<6;i++)\n      for(int j=0;j<3;j++)\n        for(int k=0;k<3;k++){\n          char ch;\n          cin>>ch;\n          if(ch == '#') return 0;\n          C.cube[ord[i]].num[j][k] = ch;\n        }\n\n    \n    C.rot90(C.cube[TOP]);\n    C.rot90(C.cube[TOP]);\n\n    ans = 10;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstring dice[6][3];\n\nint main()\n{\n    while(true){\n\tcin >> dice[0][0];\n\tif(dice[0][0] == \"#\") break;\n\tcin >> dice[0][1] >> dice[0][2];\n\trep(i,5)rep(j,3)cin >> dice[i+1][j];\n\tint ans = INF;\n\tbool exist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 0);\n\t\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 3);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nvector<vector<int>>rotate_l(vector<vector<int>>vs) {\n\tvector<vector<int>>afvs(vs.size(),vector<int>(vs.size()));\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tafvs[2 - j][i] = vs[i][j];\n\t\t}\n\t}\n\treturn afvs;\n}\nvector<vector<int>>rotate_r(vector<vector<int>>vs) {\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\treturn vs;\n}\nvector<vector<int>>flip_ud(vector<vector<int>>vs) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tswap(vs[0][i], vs[2][i]);\n\t}\n\treturn vs;\n}\nvector<vector<int>>flip_lr(vector<vector<int>>vs) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tswap(vs[i][0], vs[i][2]);\n\t}\n\treturn vs;\n}\nstruct Dice {\n\tvector<vector<int>> tp;\n\tvector<vector<int>> bo;\n\tvector<vector<int>> no;\n\tvector<vector<int>> so;\n\tvector<vector<int>> ea;\n\tvector<vector<int>> we;\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice():tp(3,vector<int>(3)),\n\t\tbo(3, vector<int>(3)),\n\t\tno(3, vector<int>(3)),\n\t\tso(3, vector<int>(3)),\n\t\tea(3, vector<int>(3)),\n\t\twe(3, vector<int>(3))\n\t{\n\t}\n\tenum R_Way {\n\t\tR_Left,\n\t\tR_Front,\n\t\tR_Right,\n\t\tR_Back,\n\n\t\tR_Dummy,\n\t};\n\tbool check()const  {\n\t\tbool sook = false;\n\t\tbool nook = false;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (so[2][i])sook = true;\n\t\t\tif (no[2][i])nook = true;\n\t\t}\n\t\treturn sook&&nook;\n\t}\n\tvoid rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tso = rotate_l(so);\n\t\t\tno = rotate_l(no);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = we;\n\t\t\t\ttp = rotate_l(tp);\n\t\t\t\twe = bo;\n\t\t\t\twe = rotate_l(we);\n\t\t\t\tbo = ea;\n\t\t\t\tbo = rotate_l(bo);\n\t\t\t\tea = tmp;\n\t\t\t\tea = rotate_l(ea);\n\t\t\t}\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tea = rotate_l(ea);\n\t\t\twe = rotate_r(we);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = no;\n\t\t\t\ttp = flip_ud(tp);\n\t\t\t\tno = bo;\n\t\t\t\tno = flip_ud(no);\n\t\t\t\tbo = so;\n\t\t\t\tso = tmp;\n\t\t\t}\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid rotate(const int way) {\n\t\trotate(static_cast<R_Way>(way));\n\t}\n\tlong long int hash()const {\n\t\tlong long int hash = 0;\n\t\tlong long int num = 1;\n\t\tfor (int y = 0; y < 3; ++y) {\n\t\t\tfor (int x = 0; x < 3; ++x) {\n\t\t\t\tif (tp[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (bo[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (no[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (we[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (so[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (ea[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t}\n\t\t}\n\t\treturn hash;\n\t}\n};\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\nint main() {\n\twhile (1) {\n\t\tDice di;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tvector<vector<int>>vs;\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tvector<int>v(3);\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (st == \"#\")return 0;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (st[k] == '*')v[k] = 1;\n\t\t\t\t}\n\t\t\t\tvs.emplace_back(v);\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tdi.so = vs;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdi.ea = vs;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdi.no = vs;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdi.we = vs;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdi.tp = vs;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdi.bo = vs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans = 9999;\n\t\tqueue<pair<int, Dice>>que;\n\t\tmap<long long int, int>mp;\n\t\tmp[di.hash()] = 0;\n\t\tque.push(make_pair(0, di));\n\t\twhile (!que.empty()) {\n\t\t\tauto p = que.front();\n\t\t\tque.pop();\n\t\t\tconst int nexttime = p.first + 1;\n\t\t\tconst Dice ori = p.second;\n\t\t\tif (ori.check()) {\n\t\t\t\tans = nexttime - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tDice now(ori);\n\t\t\t\tnow.rotate(i);\n\t\t\t\tauto it = mp.find(now.hash());\n\t\t\t\tif (it == mp.end()) {\n\t\t\t\t\tmp[now.hash()] = nexttime;\n\t\t\t\t\tque.emplace(nexttime, now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_b(){\n    upsideDown(m[d[TO]]);\n    upsideDown(m[d[BO]]);\n   \n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_f(){rep(i,3)rotate_b();}\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n\n    rep(i,3)rotate_ccw(m[d[TO]]);\n    rotate_ccw(m[d[BO]]);\n\n    rep(i,3)rotate_ccw(m[d[LE]]);\n    rep(i,3)rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][2][0] =='*' || \n\t m[d[BA]][2][1] =='*' || \t\n\t m[d[BA]][2][2] =='*' ))return true;\n    //rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      /*\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n      */\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// z軸を中心に右回転\nint rotateRight[]={0,1,3,5,2,4,6};\n// z軸を中心に左回転\nint rotateLeft[]={0,1,4,2,5,3,6};\n// 回転させてマッチするfaceを探す\n// curFaceに結果を代入\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // 左へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // 前へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)nfield[l][2-k]=field[i-1][j][k][l];\n        // fieldを回転させる\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)field[i][j][k][l]=nfield[k][l];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      int cnt2=0;\n      if(label[front]>=1&&label[front]<=4){\n        if(ang==0||ang==2){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n      }\n      else{\n        if(ang==0||ang==2){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n      }\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // 面を四方向に回転\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // 前\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // 後ろ\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=305,INF=1<<30;\n\nbool check(char a,char b){\n    if(a=='*'&&b=='*') return 1;\n    return 0;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        vector<vector<string>> S(6,vector<string>(3));\n        for(int i=0;i<6;i++){\n            for(int j=0;j<3;j++){\n                cin>>S[i][j];\n                if(S[i][j]==\"#\") return 0;\n            }\n        }\n        \n        int ans=INF;\n        \n        if(check(S[0][2][0],S[2][2][2])) chmin(ans,0);\n        if(check(S[0][2][1],S[2][2][2])) chmin(ans,0);\n        if(check(S[0][2][2],S[2][2][2])) chmin(ans,0);\n        if(check(S[0][2][1],S[2][2][1])) chmin(ans,0);\n        if(check(S[0][2][2],S[2][2][1])) chmin(ans,0);\n        if(check(S[0][2][0],S[2][2][1])) chmin(ans,0);\n        if(check(S[0][2][2],S[2][2][0])) chmin(ans,0);\n        if(check(S[0][2][0],S[2][2][0])) chmin(ans,0);\n        if(check(S[0][2][1],S[2][2][0])) chmin(ans,0);\n        \n        if(check(S[0][0][0],S[2][0][2])) chmin(ans,1);\n        if(check(S[0][0][1],S[2][0][2])) chmin(ans,1);\n        if(check(S[0][0][2],S[2][0][2])) chmin(ans,1);\n        if(check(S[0][1][0],S[2][1][2])) chmin(ans,1);\n        if(check(S[0][1][1],S[2][1][2])) chmin(ans,1);\n        if(check(S[0][1][2],S[2][1][2])) chmin(ans,1);\n        if(check(S[0][2][0],S[2][2][2])) chmin(ans,1);\n        if(check(S[0][2][1],S[2][2][2])) chmin(ans,1);\n        if(check(S[0][2][2],S[2][2][2])) chmin(ans,1);\n        \n        if(check(S[0][0][2],S[2][0][0])) chmin(ans,1);\n        if(check(S[0][0][0],S[2][0][0])) chmin(ans,1);\n        if(check(S[0][0][1],S[2][0][0])) chmin(ans,1);\n        if(check(S[0][1][2],S[2][1][0])) chmin(ans,1);\n        if(check(S[0][1][0],S[2][1][0])) chmin(ans,1);\n        if(check(S[0][1][1],S[2][1][0])) chmin(ans,1);\n        if(check(S[0][2][2],S[2][2][0])) chmin(ans,1);\n        if(check(S[0][2][0],S[2][2][0])) chmin(ans,1);\n        if(check(S[0][2][1],S[2][2][0])) chmin(ans,1);\n        \n        if(check(S[0][0][0],S[2][0][2])) chmin(ans,2);\n        if(check(S[0][0][1],S[2][0][2])) chmin(ans,2);\n        if(check(S[0][0][2],S[2][0][2])) chmin(ans,2);\n        if(check(S[0][0][1],S[2][0][1])) chmin(ans,2);\n        if(check(S[0][0][2],S[2][0][1])) chmin(ans,2);\n        if(check(S[0][0][0],S[2][0][1])) chmin(ans,2);\n        if(check(S[0][0][2],S[2][0][0])) chmin(ans,2);\n        if(check(S[0][0][0],S[2][0][0])) chmin(ans,2);\n        if(check(S[0][0][1],S[2][0][0])) chmin(ans,2);\n        \n        if(check(S[1][2][0],S[3][2][2])) chmin(ans,3);\n        if(check(S[1][2][1],S[3][2][2])) chmin(ans,3);\n        if(check(S[1][2][2],S[3][2][2])) chmin(ans,3);\n        if(check(S[1][2][1],S[3][2][1])) chmin(ans,3);\n        if(check(S[1][2][2],S[3][2][1])) chmin(ans,3);\n        if(check(S[1][2][0],S[3][2][1])) chmin(ans,3);\n        if(check(S[1][2][2],S[3][2][0])) chmin(ans,3);\n        if(check(S[1][2][0],S[3][2][0])) chmin(ans,3);\n        if(check(S[1][2][1],S[3][2][0])) chmin(ans,3);\n        \n        if(check(S[1][0][0],S[3][0][2])) chmin(ans,2);\n        if(check(S[1][0][1],S[3][0][2])) chmin(ans,2);\n        if(check(S[1][0][2],S[3][0][2])) chmin(ans,2);\n        if(check(S[1][1][0],S[3][1][2])) chmin(ans,2);\n        if(check(S[1][1][1],S[3][1][2])) chmin(ans,2);\n        if(check(S[1][1][2],S[3][1][2])) chmin(ans,2);\n        if(check(S[1][2][0],S[3][2][2])) chmin(ans,2);\n        if(check(S[1][2][1],S[3][2][2])) chmin(ans,2);\n        if(check(S[1][2][2],S[3][2][2])) chmin(ans,2);\n        \n        if(check(S[1][0][2],S[3][0][0])) chmin(ans,2);\n        if(check(S[1][0][0],S[3][0][0])) chmin(ans,2);\n        if(check(S[1][0][1],S[3][0][0])) chmin(ans,2);\n        if(check(S[1][1][2],S[3][1][0])) chmin(ans,2);\n        if(check(S[1][1][0],S[3][1][0])) chmin(ans,2);\n        if(check(S[1][1][1],S[3][1][0])) chmin(ans,2);\n        if(check(S[1][2][2],S[3][2][0])) chmin(ans,2);\n        if(check(S[1][2][0],S[3][2][0])) chmin(ans,2);\n        if(check(S[1][2][1],S[3][2][0])) chmin(ans,2);\n        \n        if(check(S[1][0][0],S[3][0][2])) chmin(ans,3);\n        if(check(S[1][0][1],S[3][0][2])) chmin(ans,3);\n        if(check(S[1][0][2],S[3][0][2])) chmin(ans,3);\n        if(check(S[1][0][1],S[3][0][1])) chmin(ans,3);\n        if(check(S[1][0][2],S[3][0][1])) chmin(ans,3);\n        if(check(S[1][0][0],S[3][0][1])) chmin(ans,3);\n        if(check(S[1][0][2],S[3][0][0])) chmin(ans,3);\n        if(check(S[1][0][0],S[3][0][0])) chmin(ans,3);\n        if(check(S[1][0][1],S[3][0][0])) chmin(ans,3);\n        \n        if(check(S[4][2][0],S[5][0][0])) chmin(ans,1);\n        if(check(S[4][2][1],S[5][0][0])) chmin(ans,1);\n        if(check(S[4][2][2],S[5][0][0])) chmin(ans,1);\n        if(check(S[4][2][1],S[5][0][1])) chmin(ans,1);\n        if(check(S[4][2][2],S[5][0][1])) chmin(ans,1);\n        if(check(S[4][2][0],S[5][0][1])) chmin(ans,1);\n        if(check(S[4][2][2],S[5][0][2])) chmin(ans,1);\n        if(check(S[4][2][0],S[5][0][2])) chmin(ans,1);\n        if(check(S[4][2][1],S[5][0][2])) chmin(ans,1);\n        \n        if(check(S[4][0][0],S[5][2][0])) chmin(ans,2);\n        if(check(S[4][0][1],S[5][2][0])) chmin(ans,2);\n        if(check(S[4][0][2],S[5][2][0])) chmin(ans,2);\n        if(check(S[4][1][0],S[5][1][0])) chmin(ans,2);\n        if(check(S[4][1][1],S[5][1][0])) chmin(ans,2);\n        if(check(S[4][1][2],S[5][1][0])) chmin(ans,2);\n        if(check(S[4][2][0],S[5][0][0])) chmin(ans,2);\n        if(check(S[4][2][1],S[5][0][0])) chmin(ans,2);\n        if(check(S[4][2][2],S[5][0][0])) chmin(ans,2);\n        \n        if(check(S[4][0][2],S[5][2][2])) chmin(ans,2);\n        if(check(S[4][0][0],S[5][2][2])) chmin(ans,2);\n        if(check(S[4][0][1],S[5][2][2])) chmin(ans,2);\n        if(check(S[4][1][2],S[5][1][2])) chmin(ans,2);\n        if(check(S[4][1][0],S[5][1][2])) chmin(ans,2);\n        if(check(S[4][1][1],S[5][1][2])) chmin(ans,2);\n        if(check(S[4][2][2],S[5][0][2])) chmin(ans,2);\n        if(check(S[4][2][0],S[5][0][2])) chmin(ans,2);\n        if(check(S[4][2][1],S[5][0][2])) chmin(ans,2);\n        \n        if(check(S[4][0][0],S[5][2][0])) chmin(ans,1);\n        if(check(S[4][0][1],S[5][2][0])) chmin(ans,1);\n        if(check(S[4][0][2],S[5][2][0])) chmin(ans,1);\n        if(check(S[4][0][1],S[5][2][1])) chmin(ans,1);\n        if(check(S[4][0][2],S[5][2][1])) chmin(ans,1);\n        if(check(S[4][0][0],S[5][2][1])) chmin(ans,1);\n        if(check(S[4][0][2],S[5][2][2])) chmin(ans,1);\n        if(check(S[4][0][0],S[5][2][2])) chmin(ans,1);\n        if(check(S[4][0][1],S[5][2][2])) chmin(ans,1);\n        \n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nvoid mirror(char m[3][3]){\n  rep(i,3)swap(m[i][0],m[i][2]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_b(){\n    upsideDown(m[d[TO]]);\n    mirror(m[d[TO]]);\n\n    upsideDown(m[d[BO]]);\n\n    mirror(m[d[BA]]);\n\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_f(){rep(i,3)rotate_b();}\n  void rotate_l(){\n    rotate_swap(d,LE,FR,RI,BA);\n    rotate_f();\n    rotate_swap(d,LE,BA,RI,FR);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][2][0] =='*' || \n\t m[d[BA]][2][1] =='*' || \t\n\t m[d[BA]][2][2] =='*' ))return true;\n    //rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      /*\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n      */\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  string s[6][3];\n  while(cin>>s[0][0],s[0][0]!=\"#\"){\n\n    for(int i=1;i<18;i++)cin>>s[i/3][i%3];\n\n    if((s[0][2][0]=='*'||s[0][2][1]=='*'||s[0][2][2]=='*')&&(s[2][2][0]=='*'||s[2][2][1]=='*'||s[2][2][2]=='*'))cout<<0<<endl;\n\n    else if((s[0][0][0]=='*'||s[0][1][0]=='*'||s[0][2][0]=='*')&&(s[2][0][2]=='*'||s[2][1][2]=='*'||s[2][2][2]=='*')||\n            (s[0][0][2]=='*'||s[0][1][2]=='*'||s[0][2][2]=='*')&&(s[2][0][0]=='*'||s[2][1][0]=='*'||s[2][2][0]=='*')||\n            (s[4][0][0]=='*'||s[4][0][1]=='*'||s[4][0][2]=='*')&&(s[5][2][0]=='*'||s[5][2][1]=='*'||s[5][2][2]=='*')||\n            (s[4][2][0]=='*'||s[4][2][1]=='*'||s[4][2][2]=='*')&&(s[5][0][0]=='*'||s[5][0][1]=='*'||s[5][0][2]=='*'))cout<<1<<endl;\n\n    else if((s[0][0][0]=='*'||s[0][0][1]=='*'||s[0][0][2]=='*')&&(s[2][0][0]=='*'||s[2][0][1]=='*'||s[2][0][2]=='*')||\n            (s[1][0][0]=='*'||s[1][1][0]=='*'||s[1][2][0]=='*')&&(s[3][0][2]=='*'||s[3][1][2]=='*'||s[3][2][2]=='*')||\n            (s[1][0][2]=='*'||s[1][1][2]=='*'||s[1][2][2]=='*')&&(s[3][0][0]=='*'||s[3][1][0]=='*'||s[3][2][0]=='*')||\n            (s[4][0][0]=='*'||s[4][1][0]=='*'||s[4][2][0]=='*')&&(s[5][0][2]=='*'||s[5][1][2]=='*'||s[5][2][2]=='*')||\n            (s[4][0][2]=='*'||s[4][1][2]=='*'||s[4][2][2]=='*')&&(s[5][0][0]=='*'||s[5][1][0]=='*'||s[5][2][0]=='*'))cout<<2<<endl;\n\n    else cout<<3<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntemplate <class T>\nstruct dice {\n  T t,b,n,s,e,w;              // top bottom north south east west\n  int dir[6];                 // directions of each face\n  dice() {}\n  dice(T t, T b, T n, T s, T e, T w) : t(t),b(b),n(n),s(s),e(e),w(w) {\n    REP(i,6) dir[i] = 0;\n  }\n  void roll(T &a, T &b, T &c, T &d) { swap(a,b); swap(b,c); swap(c,d); }\n  void roll_x() {\n    roll(t, n, b, s);\n    int tmp[6];\n    tmp[0] = dir[4];\n    tmp[1] = (dir[1] + 1) % 4;\n    tmp[2] = (dir[5] + 2) % 4;\n    tmp[3] = (dir[3] + 3) % 4;\n    tmp[4] = (dir[2] + 2) % 4;\n    tmp[5] = dir[0];\n    REP(i,6) dir[i] = tmp[i];\n  }\n  void roll_y() {\n    roll(t, w, b, e);\n    int tmp[6];\n    tmp[0] = (dir[0] + 3) % 4;\n    tmp[1] = (dir[4] + 3) % 4;\n    tmp[2] = (dir[2] + 1) % 4;\n    tmp[3] = (dir[5] + 3) % 4;\n    tmp[4] = (dir[3] + 3) % 4;\n    tmp[5] = (dir[1] + 3) % 4;\n    REP(i,6) dir[i] = tmp[i];\n  }\n  void roll_z() { roll(s, e, n, w); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k=0; k<6; (k&1?roll_y():roll_x()),++k)\n      for (int i=0; i<4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  void toTable(int *res) {\n    res[0]=t;res[1]=b;res[2]=n;\n    res[3]=s;res[4]=e;res[5]=w;\n  }\n};\n\nstring face_str[6][3];\nbool face[6][3][3];\ndice<int> dicemp[6][6];\nint dist[6][6];\n\nbool func(int f, int d) {\n  if (d == 0) {\n    return face[f][2][0]||face[f][2][1]||face[f][2][2];\n  } else if (d == 1) {\n    return face[f][0][0]||face[f][1][0]||face[f][2][0];\n  } else if (d == 2) {\n    return face[f][0][0]||face[f][0][1]||face[f][0][2];\n  } else {\n    return face[f][0][2]||face[f][1][2]||face[f][2][2];\n  }\n}\n\n\nint main() {\n  dice<int> di(4,5,2,0,1,3);\n  FOR(it, di.all_rolls()) {\n    dicemp[it->t][it->s] = *it;\n  }\n  \n  while(cin >> face_str[0][0], face_str[0][0]!=\"#\") {\n    REP(i,2)cin>>face_str[0][i+1];\n    REP(i,5) REP(j,3) cin>>face_str[i+1][j];\n    REP(i,6)REP(j,3)REP(k,3) {\n      face[i][j][k] = (face_str[i][j][k] == '*');\n    }\n    \n    queue<pii> Q;\n    Q.push(pii(di.t, di.s));\n    memset(dist,-1,sizeof(dist));\n    dist[di.t][di.s] = 0;\n    int ans = -1;\n    while(!Q.empty()) {\n      pii p = Q.front(); Q.pop();\n      dice<int> now = dicemp[p.first][p.second];\n      int d = dist[now.t][now.s];\n\n      if (func(now.s, now.dir[0]) &&\n          func(now.n, now.dir[2])) {\n        ans = d;\n        break;\n      }\n      \n      dice<int> tmp = now;\n      REP(i,2) {\n        tmp.roll_x();\n        if (dist[tmp.t][tmp.s] == -1) {\n          dist[tmp.t][tmp.s] = d+1;\n          Q.push(pii(tmp.t,tmp.s));\n        }\n        tmp.roll_x();\n      }\n      tmp = now;\n      REP(i,2) {\n        tmp.roll_y();\n        if (dist[tmp.t][tmp.s] == -1) {\n          dist[tmp.t][tmp.s] = d+1;\n          Q.push(pii(tmp.t,tmp.s));\n        }\n        tmp.roll_y();\n      }\n    }\n    assert(ans!=-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_f(){\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_b(){\n    rep(i,3)rotate_f();\n  }\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n    upsideDown(m[d[LE]]);\n    upsideDown(m[d[BO]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    /*\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][0][0] =='*' || \n\t m[d[BA]][0][1] =='*' || \t\n\t m[d[BA]][0][2] =='*' ))return true;\n    */\n    rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    /*\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][0][0] =='*' || \n\t m[d[BA]][0][1] =='*' || \t\n\t m[d[BA]][0][2] =='*' ))return true;\n    */\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nbool input(vs& v)\n{\n\tv.resize(18);\n\tREP(i, 18)\n\t{\n\t\tcin >> v[i];\n\t\tif (v[i] == \"#\") return false;\n\t}\n\treturn true;\n}\n\nvs to_clock(vs& v)\n{\n\tvs res(3, string(\"@@@\"));\n\tREP(i, 3)REP(j,3)res[i][j] = v[2-j][i];\n\treturn res;\n}\n\nvs to_cclock(vs& v)\n{\n\tvs res = v;\n\tREP(i, 3) res = to_clock(res);\n\treturn res;\n}\n\nvs reverse(vs& v)\n{\n\tvs res = v;\n\tREP(i, 3)REP(j, 3) res[i][j] = v[2 - i][2 - j];\n\treturn res;\n}\n\nstruct Room\n{\n\tvs front, right, back, left, top, bottom;\n\tRoom(vs v)\n\t{\n\t\tFOR(i, 0, 3) front.push_back(v[i]);\n\t\tFOR(i, 3, 6) right.push_back(v[i]);\n\t\tFOR(i, 6, 9) back.push_back(v[i]);\n\t\tFOR(i, 9, 12) left.push_back(v[i]);\n\t\tFOR(i, 12, 15) top.push_back(v[i]);\n\t\tFOR(i, 15, 18) bottom.push_back(v[i]);\n\t}\n\tvoid to_front()\n\t{\n\t\tvs nfront, nright, nback, nleft, ntop, nbottom;\n\t\tnfront = bottom;\n\t\tntop = front;\n\t\tnback = reverse(top);\n\t\tnbottom = reverse(back);\n\t\tnleft = to_cclock(left);\n\t\tnright = to_clock(right);\n\t\tfront = nfront;\n\t\tright = nright;\n\t\tback = nback;\n\t\tleft = nleft;\n\t\ttop = ntop;\n\t\tbottom = nbottom;\n\t}\n\tvoid to_back() \n\t{\n\t\tREP(i, 3) to_front();\n\t}\n\tvoid to_right()\n\t{\n\t\tvs nfront, nright, nback, nleft, ntop, nbottom;\n\t\tntop = to_clock(left);\n\t\tnleft = to_clock(bottom);\n\t\tnbottom = to_clock(right);\n\t\tnright = to_clock(top);\n\t\tnfront = to_clock(front);\n\t\tnback = to_cclock(back);\n\t\tfront = nfront;\n\t\tright = nright;\n\t\tback = nback;\n\t\tleft = nleft;\n\t\ttop = ntop;\n\t\tbottom = nbottom;\n\t}\n\tvoid to_left()\n\t{\n\t\tREP(i, 3) to_right();\n\t}\n};\n\nbool check(Room& room)\n{\n\tvs a = room.front, b = room.back;\n\tbool f1 = false, f2 = false;\n\tREP(i, 3)\n\t{\n\t\tif (a[2][i] == '*') f1 = true;\n\t\tif (b[2][i] == '*') f2 = true;\n\t}\n\treturn f1 && f2;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tvs v;\n\twhile (input(v))\n\t{\n\t\tRoom room(v);\n\t\tqueue<pair<Room, int>> que;\n\t\tque.emplace(room, 0);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tRoom tmp = que.front().first; int t = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (check(tmp))\n\t\t\t{\n\t\t\t\tcout << t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRoom nx = tmp;\n\t\t\tnx.to_front();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_back();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_right();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_left();\n\t\t\tque.emplace(nx, t + 1);\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\n/*\n 4\n 0 1 2 3\n 5\n ????????????????±????????????§????????????????¨?????????§????????????\n */\n\nbitset<4> cw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+1)%4] = b[i];\n  return nb;\n}\n\nbitset<4> ccw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+3)%4] = b[i];\n  return nb;\n}\n\nstruct state{\n  vector<bitset<4>> b;\n  state(){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n  }\n  state(const state &s){\n    b = s.b; // copy\n  }\n  int hash(){\n    int h = 0;\n    rep(i,6) rep(j,4) h = (h<<1) + b[i][j];\n    return h;\n  }\n  bitset<4>& operator[](int i){ return b[i]; }\n\n  void front(){ // ???????????????\n    vector<bitset<4>> nb(6);\n    nb[0] = b[4];\n    nb[1] = ccw(b[1]);\n    nb[2] = cw(cw(b[5]));\n    nb[3] = cw(b[3]);\n    nb[4] = cw(cw(b[2]));\n    nb[5] = b[0];\n    swap(nb, b);\n  }\n  void right(){\n    vector<bitset<4>> nb(6);\n    nb[0] = cw(b[0]);\n    nb[1] = cw(b[4]);\n    nb[2] = ccw(b[2]);\n    nb[3] = cw(b[5]);\n    nb[4] = cw(b[3]);\n    nb[5] = cw(b[1]);\n    swap(nb,b);\n  }\n\n  bool ok(){\n    return b[0][2] & b[2][2];\n  }\n};\n\nint main(){\n  while(true){\n    state st;\n    rep(i,6){\n      string t[3];\n      rep(j,3){\n        cin>>t[j];\n        if(t[0]==\"#\") return 0;\n      }\n      st[i][0] = t[0][0]=='*' || t[0][1]=='*' || t[0][2]=='*';\n      st[i][1] = t[0][2]=='*' || t[1][2]=='*' || t[2][2]=='*';\n      st[i][2] = t[2][0]=='*' || t[2][1]=='*' || t[2][2]=='*';\n      st[i][3] = t[0][0]=='*' || t[1][0]=='*' || t[2][0]=='*';\n    }\n\n    vector<int> d(1<<24, INF);\n    queue<state> q;\n    q.push(st);\n    d[st.hash()] = 0;\n    int ans;\n    while(true){ assert(!q.empty());\n      state s = q.front(); q.pop();\n      if(s.ok()){\n        ans = d[s.hash()];\n        break;\n      }\n      auto exec = [&](state &S){\n        if(d[S.hash()] > d[s.hash()]+1){\n          q.push(S);\n          d[S.hash()] = d[s.hash()]+1;\n        }\n      };\n\n      state s1(s);\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.front();\n      exec(s1);\n      s1.front();\n      s1.front();\n      exec(s1);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\n/*\n 4\n 0 1 2 3\n 5\n ????????????????±????????????§????????????????¨?????????§????????????\n */\n\nbitset<4> cw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+1)%4] = b[i];\n  return nb;\n}\n\nbitset<4> ccw(const bitset<4> &b){\n  bitset<4> nb(4);\n  rep(i,4) nb[(i+3)%4] = b[i];\n  return nb;\n}\n\nstruct state{\n  vector<bitset<4>> b;\n  state(){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n  }\n  state(const state &s){\n    b = s.b; // copy\n  }\n  state(int hash){\n    b = vector<bitset<4>>(6,bitset<4>(false));\n    rep(i,6) rep(j,4){\n      b[5-i][3-j] = hash%2;\n      hash/=2;\n    }\n  }\n  int hash(){\n    int h = 0;\n    rep(i,6) rep(j,4) h = (h<<1) + b[i][j];\n    return h;\n  }\n  bitset<4>& operator[](int i){ return b[i]; }\n\n  void front(){ // ???????????????\n    vector<bitset<4>> nb(6);\n    nb[0] = b[4];\n    nb[1] = ccw(b[1]);\n    nb[2] = cw(cw(b[5]));\n    nb[3] = cw(b[3]);\n    nb[4] = cw(cw(b[2]));\n    nb[5] = b[0];\n    swap(nb, b);\n  }\n  void right(){\n    vector<bitset<4>> nb(6);\n    nb[0] = cw(b[0]);\n    nb[1] = cw(b[4]);\n    nb[2] = ccw(b[2]);\n    nb[3] = cw(b[5]);\n    nb[4] = cw(b[3]);\n    nb[5] = cw(b[1]);\n    swap(nb,b);\n  }\n\n  bool ok(){\n    return b[0][2] & b[2][2];\n  }\n};\n\nint main(){\n  while(true){\n    state st;\n    rep(i,6){\n      string t[3];\n      rep(j,3){\n        cin>>t[j];\n        if(t[0]==\"#\") return 0;\n      }\n      st[i][0] = t[0][0]=='*' || t[0][1]=='*' || t[0][2]=='*';\n      st[i][1] = t[0][2]=='*' || t[1][2]=='*' || t[2][2]=='*';\n      st[i][2] = t[2][0]=='*' || t[2][1]=='*' || t[2][2]=='*';\n      st[i][3] = t[0][0]=='*' || t[1][0]=='*' || t[2][0]=='*';\n    }\n\n    map<int,int> d;\n    queue<int> q;\n    q.push(st.hash());\n    d[st.hash()] = 0;\n    int ans;\n    bool flg = true;\n    while(flg){ assert(!q.empty());\n      int h = q.front(); q.pop();\n      state s(h);\n      if(s.ok()){\n        ans = d[h];\n        break;\n      }\n      int nd = d[h]+1;\n      auto exec = [&](state &S){\n        if(S.ok()){\n          ans = nd;\n          flg=false;\n          return;\n        }\n        int hs = S.hash();\n        if(d.count(hs)==0){\n          q.push(hs);\n          d[hs] = nd;\n        }\n      };\n\n      state s1(s);\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.right();\n      exec(s1);\n      s1.right();\n      s1.front();\n      exec(s1);\n      s1.front();\n      s1.front();\n      exec(s1);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Face {\n  char face[3][3];\n  bool operator<(const Face &rhs) const {\n    REP(y, 3) REP(x, 3) {\n      if (face[y][x] != rhs.face[y][x]) {\n        return face[y][x] < rhs.face[y][x];\n      }\n    }\n    return false;\n  }\n  bool operator!=(const Face &rhs) const {\n    return *this < rhs || rhs < *this;\n  }\n};\n\nvoid rotation(Face &f, int x) {\n  if (x == 0) { return; }\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - x][y];\n  }\n  f = ret;\n  rotation(f, x - 1);\n}\n\nvoid reverse(Face &f) {\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - y][x];\n  }\n  f = ret;\n}\n\nstruct Dice {\n  Face face[6];\n  bool operator<(const Dice &rhs) const {\n    REP(i, 6) { if (face[i] != rhs.face[i]) { return face[i] < rhs.face[i]; } }\n    return false;\n  }\n};\n\nDice rotation(const Dice &d, int dir, int x) {\n  if (x == 0) { return d; }\n  Dice ret = d;\n  if (dir >= 2) { return rotation(ret, dir - 2, 4 - x); }\n  if (dir == 0) {\n    ret.face[0] = d.face[5];\n    rotation(ret.face[0], 0);\n    ret.face[1] = d.face[1];\n    rotation(ret.face[1], 1);\n    ret.face[2] = d.face[4];\n    rotation(ret.face[2], 2);\n    ret.face[3] = d.face[3];\n    rotation(ret.face[3], 1);\n    ret.face[4] = d.face[0];\n    rotation(ret.face[4], 0);\n    ret.face[5] = d.face[2];\n    rotation(ret.face[5], 2);\n  } else {\n    ret.face[0] = d.face[0];\n    rotation(ret.face[0], 1);\n    ret.face[1] = d.face[4];\n    rotation(ret.face[1], 3);\n    ret.face[2] = d.face[2];\n    rotation(ret.face[2], 1);\n    ret.face[3] = d.face[5];\n    rotation(ret.face[3], 1);\n    ret.face[4] = d.face[3];\n    rotation(ret.face[4], 3);\n    ret.face[5] = d.face[1];\n    rotation(ret.face[5], 1);\n  }\n  return rotation(ret, dir, x - 1);\n}\n\nbool ok(const Dice &d) {\n  bool ret1 = false;\n  bool ret2 = false;\n  REP(x, 3) {\n    ret1 |= d.face[0].face[2][x] == '*';\n    ret2 |= d.face[2].face[2][x] == '*';\n  }\n  return ret1 && ret2;\n}\n\nvoid print(const Dice &d) {\n  REP(iter, 6) {\n    REP(y, 3) {\n      REP(x, 3) {\n        putchar(d.face[iter].face[y][x]);\n      }\n      puts(\"\");\n    }\n  }\n  puts(\"\");\n}\n\nset<Dice> visit;\n\nint calc(Dice d) {\n  queue<pair<Dice, int> > que;\n  que.push(make_pair(d, 0));\n  int ret = 0;\n  while (!que.empty()) {\n    d = que.front().first;\n    int c = que.front().second;\n    que.pop();\n    if (visit.count(d)) { continue; }\n    if (ok(d)) { ret = c; break; }\n    REP(dir, 4) {\n      Dice nd = rotation(d, dir, 1);\n      que.push(make_pair(nd, c + 1));\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  while (true) {\n    visit.clear();\n    Dice d;\n    REP(iter, 6) {\n      REP(y, 3) REP(x, 3) {\n        char c;\n        scanf(\" %c \", &c);\n        if (c == '#') { return 0; }\n        d.face[iter].face[y][x] = c;\n      }\n    }\n    printf(\"%d\\n\", calc(d));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstring dice[6][3];\n\nint main()\n{\n    while(true){\n\tcin >> dice[0][0];\n\tif(dice[0][0] == \"#\") break;\n\tcin >> dice[0][1] >> dice[0][2];\n\trep(i,5)rep(j,3)cin >> dice[i+1][j];\n\tint ans = INF;\n\tbool exist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 0);\n\t\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 3);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 3);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nchar s[4], ju[6];\n\nint judge()\n{\n    if (ju[0]&1 && ju[2]&1) return 0;\n    if (ju[0]&2 && ju[2]&8) return 1;\n    if (ju[0]&8 && ju[2]&2) return 1;\n    if (ju[4]&1 && ju[5]&4) return 1;\n    if (ju[4]&4 && ju[5]&1) return 1;\n    if (ju[4]&2 && ju[5]&2) return 2;\n    if (ju[4]&8 && ju[5]&8) return 2;\n    if (ju[0]&4 && ju[2]&4) return 2;\n    if (ju[1]&2 && ju[3]&8) return 2;\n    if (ju[1]&8 && ju[3]&2) return 2;\n    return 3;\n}\n\nint main()\n{\n    char i, j, k;\n    for(;;)\n    {\n        memset(ju, 0, sizeof(ju));\n        for (i = 0; i < 6; i++)\n        {\n            for (j = 0; j < 3; j++)\n            {\n                scanf(\"%s\", s);\n                if (s[0] == '#') return 0;\n                for (k = 0; k < 3; k++)\n                {\n                    if (s[k] == '*')\n                    {\n                        if (j == 0) ju[i] |= 4;\n                        if (j == 2) ju[i] |= 1;\n                        if (k == 0) ju[i] |= 8;\n                        if (k == 2) ju[i] |= 2;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", judge());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef vector<string> S;\n\n//3*3ツづ個配ツ療アツづーツ篠楪計ツ嘉アツづィ90ツ度ツ嘉アツ転\nS rot90(S s){\n\tS res = s;\n\trep(i,3) rep(j,3) res[j][2-i] = s[i][j];\n\treturn res;\n}\nS rot180(S s){return rot90(rot90(s));}\nS rot270(S s){return rot90(rot180(s));}\n\nclass Dice{\npublic:\n\tvector<string> t,b,w,e,n,s;\n\n\tDice(S _t,S _b,S _w,S _e,S _n,S _s){\n\t\tt = _t;\n\t\tb = _b;\n\t\tw = _w;\n\t\te = _e;\n\t\tn = _n;\n\t\ts = _s;\n\t}\n\n\tDice move(int d){\n\t\tif(d == 0)\n\t\t\treturn Dice(s,rot180(n),rot90(w),rot270(e),rot180(t),b);\n\t\telse\n\t\t\treturn Dice(rot270(w),rot270(e),rot270(b),rot270(t),rot90(n),rot270(s));\n\t}\n\n\tbool isAns(void){\n\t\treturn\n\t\t\t(s[2][0]=='*' || s[2][1]=='*' || s[2][2]=='*') &&\n\t\t\t(n[2][0]=='*' || n[2][1]=='*' || n[2][2]=='*');\n\t}\n};\n\nint solve(Dice d){\n\ttypedef pair<Dice,int> P;\n\tqueue<P> open;\n\topen.push(P(d,0));\n\n\twhile(!open.empty()){\n\t\tP p = open.front(); open.pop();\n\n\t\tif(p.first.isAns()){\n\t\t\treturn p.second;\n\t\t}\n\n\t\topen.push(P(p.first.move(0),p.second+1));\n\t\topen.push(P(p.first.move(1),p.second+1));\n\t\topen.push(P(p.first.move(0).move(0).move(0),p.second+1));\n\t\topen.push(P(p.first.move(1).move(1).move(1),p.second+1));\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tS s[6];\n\t\trep(i,6) rep(j,3){\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\ts[i].push_back(str);\n\t\t\tif(s[i][j] == \"#\") return 0;\n\t\t}\n\n\t\tDice d(s[4],s[5],s[3],s[1],s[2],s[0]);\n\t\tcout<<solve(d)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define chmin(x,y) x=min(x,y)\nusing namespace std;\nstring s[6][3];\nbool r(int a,int b){\n\trep(i,3) if(s[a][b][i]=='*') return 1;\n\treturn 0;\n}\nbool c(int a,int b){\n\trep(i,3) if(s[a][i][b]=='*') return 1;\n\treturn 0;\n}\nint main(){\n\twhile(true){\n\t\tint ans=10;\n\t\tcin>>s[0][0];\n\t\tif(s[0][0][0]=='#') break;\n\t\trep(i,6) rep(j,3){\n\t\t\tif(i==0&&j==0) continue;\n\t\t\tcin>>s[i][j];\n\t\t}\n\t\tif(r(0,2)&&r(2,2)) chmin(ans,0);\n\t\tif(r(0,0)&&r(2,0)) chmin(ans,2);\n\t\tif(c(0,0)&&c(2,2)) chmin(ans,1);\n\t\tif(c(0,2)&&c(2,0)) chmin(ans,1);\n\t\tif(r(1,2)&&r(3,2)) chmin(ans,3);\n\t\tif(r(1,0)&&r(3,0)) chmin(ans,3);\n\t\tif(c(1,0)&&c(3,2)) chmin(ans,2);\n\t\tif(c(1,2)&&c(3,0)) chmin(ans,2);\n\t\tif(r(4,0)&&r(5,2)) chmin(ans,1);\n\t\tif(r(4,2)&&r(5,0)) chmin(ans,1);\n\t\tif(c(4,0)&&c(5,0)) chmin(ans,2);\n\t\tif(c(4,2)&&c(5,2)) chmin(ans,2);\n\t\tcout<<ans<<endl;\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<string> rotate(int n, const vector<string>& s)\n{\n    if(n == 0)\n        return s;\n\n    vector<string> t(3, string(3, ' '));\n    for(int i=0; i<3; ++i){\n        for(int j=0; j<3; ++j){\n            t[j][2-i] = s[i][j];\n        }\n    }\n    return rotate(n-1, t);\n}\n\nclass Dice\n{\npublic:\n    vector<vector<string> > pip; // 東南西北上下の目\n    Dice(){\n        pip.assign(6, vector<string>(3, string(3, ' ')));\n    }\n    void roll(int d){ // 東南西北右左に回転\n        int dir[][4] = {{4,2,5,0},{4,3,5,1},{4,0,5,2},{4,1,5,3},{0,3,2,1},{0,1,2,3}};\n        vector<string> tmp = pip[dir[d][0]];\n        for(int i=0; i<3; ++i)\n            pip[dir[d][i]] = pip[dir[d][i+1]];\n        pip[dir[d][3]] = tmp;\n\n        if(d == 0){\n            pip[1] = rotate(3, pip[1]);\n            pip[2] = rotate(2, pip[2]);\n            pip[3] = rotate(1, pip[3]);\n            pip[5] = rotate(2, pip[5]);\n        }else if(d == 1){\n            pip[0] = rotate(1, pip[0]);\n            pip[2] = rotate(3, pip[2]);\n        }else if(d == 2){\n            pip[0] = rotate(2, pip[0]);\n            pip[1] = rotate(1, pip[1]);\n            pip[3] = rotate(3, pip[3]);\n            pip[5] = rotate(2, pip[5]);\n        }else{\n            pip[0] = rotate(3, pip[0]);\n            pip[2] = rotate(1, pip[2]);\n        }\n    }\n    bool operator==(const Dice& d) const{\n        return pip == d.pip;\n    }\n};\n\nint solve(Dice d0)\n{\n    set<vector<vector<string> > > s;\n    queue<vector<vector<string> > > q;\n    s.insert(d0.pip);\n    q.push(d0.pip);\n\n    int ret = 0;\n    for(;;){\n        int n = q.size();\n        while(--n >= 0){\n            Dice d;\n            d.pip= q.front();\n            q.pop();\n\n            int tmp = 0;\n            for(int i=0; i<3; ++i){\n                if(d.pip[1][2][i] == '*')\n                    tmp |= 1;\n                if(d.pip[3][0][i] == '*')\n                    tmp |= 2;\n            }\n            if(tmp == 3)\n                return ret;\n\n            for(int i=0; i<4; ++i){\n                Dice d2 = d;\n                d2.roll(i);\n                if(s.find(d2.pip) == s.end()){\n                    s.insert(d2.pip);\n                    q.push(d2.pip);\n                }\n            }\n        }\n        ++ ret;\n    }\n}\n\nint main()\n{\n    int to[] = {1, 0, 3, 2, 4, 5};\n\n    for(;;){\n        Dice d;\n        for(int i=0; i<6; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> d.pip[to[i]][j];\n                if(d.pip[to[i]][j] == \"#\")\n                    return 0;\n            }\n        }\n        d.pip[0] = rotate(3, d.pip[0]);\n        d.pip[2] = rotate(1, d.pip[2]);\n        d.pip[3] = rotate(2, d.pip[3]);\n\n        cout << solve(d) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n#define MAXN 3\n#define MAXM 120000\n#define FI first\n#define SE second\nconst int INF =1000000007;\nchar dice[6][MAXN][MAXN];\nint ans=0,now[6];\nint ty[6][3][3];\nconst int rcmp[6][4]={{0,2,5,2},{0,2,4,0},{1,3,5,2},{1,3,4,0},{4,5,0,2},{4,5,2,0}};\nconst int ccmp[6][4]={{0,2,1,2},{0,2,3,0},{1,3,2,2},{1,3,0,0},{4,5,1,2},{4,5,3,0}};\nconst int from[4][6]={{4,1,5,3,2,0},{0,4,2,5,3,1},{5,1,4,3,0,2},{0,5,2,4,1,3}};\nvoid dfs(int dep)\n{\n    if(dep>=ans)    return ;\n    int flag=0;\n    for(int k=0;k<6;++k)\n        if((rcmp[k][0]==now[0]&&rcmp[k][1]==now[2]||rcmp[k][0]==now[2]&&rcmp[k][1]==now[0])&&rcmp[k][2]==now[5])\n        {\n            int a=rcmp[k][0],c=rcmp[k][3];\n            for(int i=0;i<3;++i)\n                flag|=ty[a][c][i];\n        }\n    for(int k=0;k<6;++k)\n        if((ccmp[k][0]==now[0]&&ccmp[k][1]==now[2]||ccmp[k][0]==now[2]&&ccmp[k][1]==now[0])&&ccmp[k][2]==now[5])\n        {\n            int a=ccmp[k][0],c=ccmp[k][3];\n            for(int i=0;i<3;++i)\n                flag|=ty[a][i][c];\n        }\n    if(flag==3)\n    {\n        ans=min(ans,dep);\n        return ;\n    }\n    int tnow[6];\n    memcpy(tnow,now,sizeof(now));\n    for(int i=0;i<4;++i)\n    {\n        for(int j=0;j<6;++j)    now[j]=tnow[from[i][j]];\n        dfs(dep+1);\n    }\n}\nint main()\n{\n    //freopen(\"J:\\\\Mydocument\\\\Code\\\\input.txt\",\"r\",stdin);\n    char tmp[4];\n    while(1)\n    {\n        for(int i=0;i<6;++i)\n            for(int j=0;j<3;++j)\n            {\n                scanf(\"%s\",tmp);\n                for(int k=0;k<3;++k)    dice[i][j][k]=tmp[k];\n            }\n        if(dice[0][0][0]=='#')   break;\n        ans=4;\n        for(int i=0;i<2;++i)\n            for(int j=0;j<3;++j)\n                for(int k=0;k<3;++k)\n                    ty[i][j][k]=(dice[i][j][k]=='*')+(dice[i+2][j][2-k]=='*')*2;\n        for(int j=0;j<3;++j)\n            for(int k=0;k<3;++k)\n                ty[4][j][k]=(dice[4][j][k]=='*')+(dice[5][2-j][k]=='*')*2;\n        for(int i=0;i<6;++i)    now[i]=i;\n        dfs(0);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntemplate <class T>\nstruct dice {\n  T t,b,n,s,e,w;              // top bottom north south east west\n  int dir[6];                 // directions of each face\n  dice() {}\n  dice(T t, T b, T n, T s, T e, T w) : t(t),b(b),n(n),s(s),e(e),w(w) {\n    REP(i,6) dir[i] = 0;\n  }\n  void roll(T &a, T &b, T &c, T &d) { swap(a,b); swap(b,c); swap(c,d); }\n  void roll_x() {\n    roll(t, n, b, s);\n    int tmp[6];\n    tmp[0] = dir[4];\n    tmp[1] = (dir[1] + 1) % 4;\n    tmp[2] = (dir[5] + 2) % 4;\n    tmp[3] = (dir[3] + 3) % 4;\n    tmp[4] = (dir[2] + 2) % 4;\n    tmp[5] = dir[0];\n    REP(i,6) dir[i] = tmp[i];\n  }\n  void roll_y() {\n    roll(t, w, b, e);\n    int tmp[6];\n    tmp[0] = (dir[0] + 3) % 4;\n    tmp[1] = (dir[4] + 3) % 4;\n    tmp[2] = (dir[2] + 1) % 4;\n    tmp[3] = (dir[5] + 3) % 4;\n    tmp[4] = (dir[3] + 3) % 4;\n    tmp[5] = (dir[1] + 3) % 4;\n    REP(i,6) dir[i] = tmp[i];\n  }\n  void roll_z() {\n    roll(s, e, n, w);\n    roll(dir[0],dir[1],dir[2],dir[3]);\n    dir[4] = (dir[4] + 3) % 4;\n    dir[5] = (dir[5] + 1) % 4;\n  }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k=0; k<6; (k&1?roll_y():roll_x()),++k)\n      for (int i=0; i<4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  void toTable(int *res) {\n    res[0]=t;res[1]=b;res[2]=n;\n    res[3]=s;res[4]=e;res[5]=w;\n  }\n};\n\nstring face_str[6][3];\nbool face[6][3][3];\ndice<int> dicemp[6][6];\nint dist[6][6];\n\nbool func(int f, int d) {\n  if (d == 0) {\n    return face[f][2][0]||face[f][2][1]||face[f][2][2];\n  } else if (d == 1) {\n    return face[f][0][0]||face[f][1][0]||face[f][2][0];\n  } else if (d == 2) {\n    return face[f][0][0]||face[f][0][1]||face[f][0][2];\n  } else {\n    return face[f][0][2]||face[f][1][2]||face[f][2][2];\n  }\n}\n\n\nint main() {\n  dice<int> di(4,5,2,0,1,3);\n  FOR(it, di.all_rolls()) {\n    dicemp[it->t][it->s] = *it;\n  }\n  \n  while(cin >> face_str[0][0], face_str[0][0]!=\"#\") {\n    REP(i,2)cin>>face_str[0][i+1];\n    REP(i,5) REP(j,3) cin>>face_str[i+1][j];\n    REP(i,6)REP(j,3)REP(k,3) {\n      face[i][j][k] = (face_str[i][j][k] == '*');\n    }\n    \n    queue<pii> Q;\n    Q.push(pii(di.t, di.s));\n    memset(dist,-1,sizeof(dist));\n    dist[di.t][di.s] = 0;\n    int ans = -1;\n    while(!Q.empty()) {\n      pii p = Q.front(); Q.pop();\n      dice<int> now = dicemp[p.first][p.second];\n      int d = dist[now.t][now.s];\n\n      if (func(now.s, now.dir[0]) &&\n          func(now.n, now.dir[2])) {\n        ans = d;\n        break;\n      }\n      \n      dice<int> tmp = now;\n      REP(i,2) {\n        tmp.roll_x();\n        if (dist[tmp.t][tmp.s] == -1) {\n          dist[tmp.t][tmp.s] = d+1;\n          Q.push(pii(tmp.t,tmp.s));\n        }\n        tmp.roll_x();\n      }\n      tmp = now;\n      REP(i,2) {\n        tmp.roll_y();\n        if (dist[tmp.t][tmp.s] == -1) {\n          dist[tmp.t][tmp.s] = d+1;\n          Q.push(pii(tmp.t,tmp.s));\n        }\n        tmp.roll_y();\n      }\n    }\n    assert(ans!=-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define MAXN 3\n#define MAXM 120000\n#define FI first\n#define SE second\nconst int INF =1000000007;\nchar dice[6][MAXN][MAXN],tdice[6][MAXN][MAXN];\nint ans=0,now[6];\nbool vi[MAXM];\nvoid no(int h,int ori)\n{\n    memcpy(dice[h],tdice[ori],sizeof(tdice[ori]));\n}\nvoid rl(int h,int ori)\n{\n    for(int i=0;i<3;++i)\n        for(int j=0;j<3;++j)\n            dice[h][2-j][i]=tdice[ori][i][j];\n}\nvoid rr(int h,int ori)\n{\n    for(int i=0;i<3;++i)\n        for(int j=0;j<3;++j)\n            dice[h][j][2-i]=tdice[ori][i][j];\n}\nvoid rev(int h)\n{\n    for(int i=0;i<3;++i)\n        swap(dice[h][i][0],dice[h][i][2]);\n}\nvoid (*fun[4][6])(int ,int )={{no,rl,no,rr,no,no},{rr,rr,rl,rr,rr,rr},{no,rr,no,rl,no,no},\n                                {rl,rl,rr,rl,rl,rl}};\nint from[4][6]={{4,1,5,3,2,0},{0,4,2,5,3,1},{5,1,4,3,0,2},{0,5,2,4,1,3}};\nbool check()\n{\n    int t=0;\n    for(int i=0;i<6;++i)    t=t*6+now[i];\n    if(vi[t]) return    false;\n    return vi[t]=true;\n}\nvoid dfs(int dep)\n{\n    if(dep>=ans)    return ;\n    bool flag=false;\n    for(int i=0;i<3;++i)\n        flag|=dice[0][2][i]=='*'&&dice[2][0][i]=='*';\n    if(flag)\n    {\n        ans=min(ans,dep);\n        return ;\n    }\n    if(!check())    return ;\n    char tmp[6][MAXN][MAXN];\n    int tnow[6];\n    memcpy(tmp,dice,sizeof(dice));\n    memcpy(tnow,now,sizeof(now));\n    for(int i=0;i<4;++i)\n    {\n        memcpy(tdice,tmp,sizeof(dice));\n        for(int j=0;j<6;++j)\n            fun[i][j](j,from[i][j]),now[j]=tnow[from[i][j]];\n        dfs(dep+1);\n    }\n}\nint main()\n{\n    //freopen(\"J:\\\\Mydocument\\\\Code\\\\input.txt\",\"r\",stdin);\n    char tmp[4];\n    while(scanf(\"%s\",tmp)&&tmp[0]!='#')\n    {\n        memset(vi,0,sizeof(vi));\n        for(int i=0;i<3;++i)    dice[0][0][i]=tmp[i];\n        for(int i=1;i<3;++i)\n        {\n            scanf(\"%s\",tmp);\n            for(int j=0;j<3;++j)    dice[0][i][j]=tmp[j];\n        }\n        for(int i=1;i<6;++i)\n            for(int j=0;j<3;++j)\n            {\n                scanf(\"%s\",tmp);\n                for(int k=0;k<3;++k)    dice[i][j][k]=tmp[k];\n            }\n        memcpy(tdice[2],dice[2],sizeof(dice[2]));\n        for(int i=0;i<3;++i)    swap(dice[2][0][i],dice[2][2][i]);\n        rev(2);\n        ans=INF;\n        for(int i=0;i<6;++i)    now[i]=i;\n        dfs(0);\n        while(ans==INF);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#define LL long long\n#define INF 0x7fffffff\n#define clr(x,y) memset(x,y,sizeof(x))\nusing namespace std;\n\nstruct State\n{\n    char mat[6][3][4];\n    int step;\n};\n\nqueue<State> q;\n\nbool judge(State &state)\n{\n    int cnt=0;\n    for(int i=0;i<3;i++)\n        if(state.mat[0][2][i]=='*')\n        {\n            cnt++;\n            break;\n        }\n    for(int i=0;i<3;i++)\n        if(state.mat[2][2][i]=='*')\n        {\n            cnt++;\n            break;\n        }\n    //printf(\"%d\\n\",cnt);\n    return (cnt==2);\n}\nvoid clock(char mat[][4])\n{\n    char mat2[3][4];\n    for(int j=0;j<3;j++)\n        for(int i=0;i<3;i++)\n            mat2[i][j]=mat[3-j][i];\n    for(int j=0;j<3;j++)\n        for(int i=0;i<3;i++)\n            mat[i][j]=mat2[i][j];\n}\nvoid unclock(char mat[][4])\n{\n    char mat2[3][4];\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            mat2[i][j]=mat[j][i];\n    for(int j=0;j<3;j++)\n        for(int i=0;i<3;i++)\n            mat[i][j]=mat2[i][j];\n}\nvoid assign(char mat1[][4],char mat2[][4])\n{\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            mat1[i][j]=mat2[i][j];\n}\nint bfs(State &start)\n{\n    while(!q.empty())\n        q.pop();\n    q.push(start);\n    while(!q.empty())\n    {\n        State cur=q.front();\n        q.pop();\n        if(judge(cur))\n            return cur.step;\n        State next;\n        next.step=cur.step+1;\n\n        //left\n        assign(next.mat[0],cur.mat[0]);\n        unclock(next.mat[0]);\n        assign(next.mat[2],cur.mat[2]);\n        clock(next.mat[2]);\n\n        assign(next.mat[3],cur.mat[4]);\n        clock(next.mat[3]);\n        assign(next.mat[4],cur.mat[1]);\n        clock(next.mat[4]);\n        assign(next.mat[1],cur.mat[5]);\n        clock(next.mat[1]);\n        assign(next.mat[5],cur.mat[3]);\n        clock(next.mat[5]);\n        q.push(next);\n\n        //right\n        assign(next.mat[0],cur.mat[0]);\n        clock(next.mat[0]);\n        assign(next.mat[2],cur.mat[2]);\n        unclock(next.mat[2]);\n\n        assign(next.mat[4],cur.mat[3]);\n        unclock(next.mat[4]);\n        assign(next.mat[1],cur.mat[4]);\n        unclock(next.mat[1]);\n        assign(next.mat[5],cur.mat[1]);\n        unclock(next.mat[5]);\n        assign(next.mat[3],cur.mat[5]);\n        unclock(next.mat[3]);\n        q.push(next);\n\n        //up\n        assign(next.mat[3],cur.mat[3]);\n        unclock(next.mat[3]);\n        assign(next.mat[1],cur.mat[1]);\n        clock(next.mat[1]);\n\n        assign(next.mat[4],cur.mat[0]);\n        assign(next.mat[0],cur.mat[5]);\n\n        assign(next.mat[2],cur.mat[4]);\n        clock(next.mat[2]);\n        clock(next.mat[2]);\n        assign(next.mat[5],cur.mat[2]);\n        clock(next.mat[5]);\n        clock(next.mat[5]);\n        q.push(next);\n\n        //down\n        assign(next.mat[3],cur.mat[3]);\n        clock(next.mat[3]);\n        assign(next.mat[1],cur.mat[1]);\n        unclock(next.mat[1]);\n\n        assign(next.mat[0],cur.mat[4]);\n        assign(next.mat[5],cur.mat[0]);\n\n        assign(next.mat[4],cur.mat[2]);\n        clock(next.mat[4]);\n        clock(next.mat[4]);\n        assign(next.mat[2],cur.mat[5]);\n        clock(next.mat[2]);\n        clock(next.mat[2]);\n        q.push(next);\n    }\n    return -1;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    while(1)\n    {\n        char tmp[4];\n        scanf(\"%s\",tmp);\n        if(tmp[0]=='#')\n            break;\n        State start;\n        strcpy(start.mat[0][0],tmp);\n        for(int i=1;i<3;i++)\n            scanf(\"%s\",start.mat[0][i]);\n        for(int i=1;i<6;i++)\n            for(int j=0;j<3;j++)\n                scanf(\"%s\",start.mat[i][j]);\n        start.step=0;\n        printf(\"%d\\n\",bfs(start));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool is_goal(const string& c)\n{\n    bool front = 0, back = 0;\n    if (c[6] == '*' || c[7] == '*' || c[8] == '*') {\n        front = 1;\n    }\n\n    if (c[24] == '*' || c[25] == '*' || c[26] == '*') {\n        back = 1;\n    }\n    \n    return front & back;\n}\n\nstring rotate(const string& c, int dir)\n{\n    string nc = c;\n    char tmp;\n    vector<int> d, e, id;\n    \n    switch (dir) {\n        case 0: // left\n            d  = {-3, +1, +3, -1};\n            e  = {+1, +3, -1, -3};            \n            id = {33, 36, 11, 53};\n            \n            tmp   = nc[0];\n            nc[0] = nc[2];\n            nc[2] = nc[8];\n            nc[8] = nc[6];\n            nc[6] = tmp;\n            \n            tmp   = nc[1];\n            nc[1] = nc[5];\n            nc[5] = nc[7];\n            nc[7] = nc[3];\n            nc[3] = tmp;\n\n            tmp    = nc[18];\n            nc[18] = nc[24];\n            nc[24] = nc[26];\n            nc[26] = nc[20];\n            nc[20] = tmp;\n\n            tmp    = nc[19];\n            nc[19] = nc[21];\n            nc[21] = nc[25];\n            nc[25] = nc[23];\n            nc[23] = tmp;            \n            break;\n        case 1: // back\n            d  = {-3, +3, +3, +3};\n            e  = {+1, -1, -1, -1};\n            id = {24, 38, 2, 47};\n\n            tmp    = nc[9];\n            nc[9]  = nc[15];\n            nc[15] = nc[17];\n            nc[17] = nc[11];\n            nc[11] = tmp;\n\n            tmp    = nc[10];\n            nc[10] = nc[12];\n            nc[12] = nc[16];\n            nc[16] = nc[14];\n            nc[14] = tmp;\n\n            tmp    = nc[27];\n            nc[27] = nc[29];\n            nc[29] = nc[35];\n            nc[35] = nc[33];\n            nc[33] = tmp;\n\n            tmp    = nc[28];\n            nc[28] = nc[32];\n            nc[32] = nc[34];\n            nc[34] = nc[30];\n            nc[30] = tmp;            \n            break;\n        case 2: // right\n            d  = {-3, -1, +3, +1};\n            e  = {+1, -3, -1, +3};\n            id = {15, 44, 29, 45};\n\n            tmp   = nc[0];\n            nc[0] = nc[6];\n            nc[6] = nc[8];\n            nc[8] = nc[2];\n            nc[2] = tmp;\n\n            tmp   = nc[1];\n            nc[1] = nc[3];\n            nc[3] = nc[7];\n            nc[7] = nc[5];\n            nc[5] = tmp;\n\n            tmp    = nc[18];\n            nc[18] = nc[20];\n            nc[20] = nc[26];\n            nc[26] = nc[24];\n            nc[24] = tmp;\n\n            tmp    = nc[19];\n            nc[19] = nc[23];\n            nc[23] = nc[25];\n            nc[25] = nc[21];\n            nc[21] = tmp;            \n            break;\n        case 3: // front            \n            d  = {-3, -3, +3, -3};\n            e  = {+1, +1, -1, +1};\n            id = {6, 42, 20, 51};\n            \n            tmp    = nc[9];\n            nc[9]  = nc[11];\n            nc[11] = nc[17];\n            nc[17] = nc[15];\n            nc[15] = tmp;\n\n            tmp    = nc[10];\n            nc[10] = nc[14];\n            nc[14] = nc[16];\n            nc[16] = nc[12];\n            nc[12] = tmp;\n\n            tmp    = nc[27];\n            nc[27] = nc[33];\n            nc[33] = nc[35];\n            nc[35] = nc[29];\n            nc[29] = tmp;\n\n            tmp    = nc[28];\n            nc[28] = nc[30];\n            nc[30] = nc[34];\n            nc[34] = nc[32];\n            nc[32] = tmp;            \n            break;\n    }\n    \n    for (int i = 0; i < 3; i++) {\n        auto nid = id;\n        for (int j = 0; j < 3; j++) {\n            tmp        = nc[nid[0]];\n            nc[nid[0]] = nc[nid[1]];\n            nc[nid[1]] = nc[nid[2]];\n            nc[nid[2]] = nc[nid[3]];\n            nc[nid[3]] = tmp;\n            for (int k = 0; k < 4; k++) {\n                nid[k] += d[k];\n            }\n        }\n        for (int j = 0; j < 4; j++) {\n            id[j] += e[j];\n        }\n    }\n                 \n    return nc;\n}\n\nint bfs(const string& cube)\n{\n    queue<string> que;\n    que.push(cube);\n\n    map<string, int> d;\n    d[cube] = 0;\n\n    while (!que.empty()) {\n        auto c = que.front(); que.pop();\n        if (is_goal(c)) {\n            return d[c];\n        }\n\n        for (int i = 0; i < 4; i++) {\n            auto nc = rotate(c, i);\n            if (d.count(nc) == 0) {\n                d[nc] = d[c] + 1;\n                que.push(nc);\n            }               \n        }\n    }   \n    return -1;\n}\n\nint main()\n{\n    string s[3];\n    while (cin >> s[0], s[0] != \"#\") {\n        string cube;\n        for (int i = 0; i < 6; i++) {\n            for (int j = (i == 0); j < 3; j++) {\n                cin >> s[j];\n            }\n            for (int j = 0; j < 3; j++) {\n                cube += s[j];\n            }\n        }\n        cout << bfs(cube) << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nchar s[4], ju[6];\n\nint judge()\n{\n    if (ju[0]&1 && ju[2]&1) return 0;\n    if (ju[0]&2 && ju[2]&8) return 1;\n    if (ju[0]&8 && ju[2]&2) return 1;\n    if (ju[4]&1 && ju[5]&4) return 1;\n    if (ju[4]&4 && ju[5]&1) return 1;\n    if (ju[4]&2 && ju[5]&2) return 2;\n    if (ju[4]&8 && ju[5]&8) return 2;\n    if (ju[0]&4 && ju[2]&4) return 2;\n    if (ju[1]&2 && ju[3]&8) return 2;\n    if (ju[1]&8 && ju[3]&2) return 2;\n    return 3;\n}\n\nint main()\n{\n    for(;;)\n    {\n        memset(ju, 0, sizeof(ju));\n        for (int i = 0; i < 6; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                scanf(\"%s\", s);\n                if (s[0] == '#') return 0;\n                for (int k = 0; k < 3; k++)\n                {\n                    if (s[k] == '*')\n                    {\n                        if (j == 0) ju[i] |= 4;\n                        if (j == 2) ju[i] |= 1;\n                        if (k == 0) ju[i] |= 8;\n                        if (k == 2) ju[i] |= 2;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", judge());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_b(){\n    upsideDown(m[d[TO]]);\n    upsideDown(m[d[BO]]);\n   \n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_f(){rep(i,3)rotate_b();}\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n\n    rep(i,3)rotate_ccw(m[d[TO]]);\n    rotate_ccw(m[d[BO]]);\n\n    rep(i,3)rotate_ccw(m[d[LE]]);\n    rep(i,3)rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n  \n\n    rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      /*\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n      */\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 6\nusing namespace std;\ntypedef pair<int,string> P;\n\nstring rot_N(string s){\n  \n  string t=s;\n  \n  t[9*4+0]=s[0];\n  t[9*4+1]=s[1];\n  t[9*4+2]=s[2];\n  t[9*4+3]=s[3];\n  t[9*4+4]=s[4];\n  t[9*4+5]=s[5];\n  t[9*4+6]=s[6];\n  t[9*4+7]=s[7];\n  t[9*4+8]=s[8];\n  \n  t[9*2+0]=s[9*4+8];\n  t[9*2+1]=s[9*4+7];\n  t[9*2+2]=s[9*4+6];\n  t[9*2+3]=s[9*4+5];\n  t[9*2+4]=s[9*4+4];\n  t[9*2+5]=s[9*4+3];\n  t[9*2+6]=s[9*4+2];\n  t[9*2+7]=s[9*4+1];\n  t[9*2+8]=s[9*4+0];\n  \n  t[9*5+0]=s[9*2+8];\n  t[9*5+1]=s[9*2+7];\n  t[9*5+2]=s[9*2+6];\n  t[9*5+3]=s[9*2+5];\n  t[9*5+4]=s[9*2+4];\n  t[9*5+5]=s[9*2+3];\n  t[9*5+6]=s[9*2+2];\n  t[9*5+7]=s[9*2+1];\n  t[9*5+8]=s[9*2+0];\n\n  t[0]=s[9*5+0];\n  t[1]=s[9*5+1];\n  t[2]=s[9*5+2];\n  t[3]=s[9*5+3];\n  t[4]=s[9*5+4];\n  t[5]=s[9*5+5];\n  t[6]=s[9*5+6];\n  t[7]=s[9*5+7];\n  t[8]=s[9*5+8];\n  \n  t[9+0]=s[9+6];\n  t[9+1]=s[9+3];\n  t[9+2]=s[9+0];\n  t[9+3]=s[9+7];\n  t[9+4]=s[9+4];\n  t[9+5]=s[9+1];\n  t[9+6]=s[9+8];\n  t[9+7]=s[9+5];\n  t[9+8]=s[9+2];\n  \n  t[9*3+0]=s[9*3+2];\n  t[9*3+1]=s[9*3+5];\n  t[9*3+2]=s[9*3+8];\n  t[9*3+3]=s[9*3+1];\n  t[9*3+4]=s[9*3+4];\n  t[9*3+5]=s[9*3+7];\n  t[9*3+6]=s[9*3+0];\n  t[9*3+7]=s[9*3+3];\n  t[9*3+8]=s[9*3+6];\n  \n  return t;\n}\n\nstring rot_E(string s){\n  \n  string t=s;\n  \n  t[9+0]=s[9*4+6];\n  t[9+1]=s[9*4+3];\n  t[9+2]=s[9*4+0];\n  t[9+3]=s[9*4+7];\n  t[9+4]=s[9*4+4];\n  t[9+5]=s[9*4+1];\n  t[9+6]=s[9*4+8];\n  t[9+7]=s[9*4+5];\n  t[9+8]=s[9*4+2];\n  \n  t[9*5+0]=s[9+6];\n  t[9*5+1]=s[9+3];\n  t[9*5+2]=s[9+0];\n  t[9*5+3]=s[9+7];\n  t[9*5+4]=s[9+4];\n  t[9*5+5]=s[9+1];\n  t[9*5+6]=s[9+8];\n  t[9*5+7]=s[9+5];\n  t[9*5+8]=s[9+2];\n  \n  t[9*3+0]=s[9*5+6];\n  t[9*3+1]=s[9*5+3];\n  t[9*3+2]=s[9*5+0];\n  t[9*3+3]=s[9*5+7];\n  t[9*3+4]=s[9*5+4];\n  t[9*3+5]=s[9*5+1];\n  t[9*3+6]=s[9*5+8];\n  t[9*3+7]=s[9*5+5];\n  t[9*3+8]=s[9*5+2];\n  \n  t[9*4+0]=s[9*3+6];\n  t[9*4+1]=s[9*3+3];\n  t[9*4+2]=s[9*3+0];\n  t[9*4+3]=s[9*3+7];\n  t[9*4+4]=s[9*3+4];\n  t[9*4+5]=s[9*3+1];\n  t[9*4+6]=s[9*3+8];\n  t[9*4+7]=s[9*3+5];\n  t[9*4+8]=s[9*3+2];\n  \n  t[0]=s[6];\n  t[1]=s[3];\n  t[2]=s[0];\n  t[3]=s[7];\n  t[4]=s[4];\n  t[5]=s[1];\n  t[6]=s[8];\n  t[7]=s[5];\n  t[8]=s[2];\n\n  t[9*2+0]=s[9*2+2];\n  t[9*2+1]=s[9*2+5];\n  t[9*2+2]=s[9*2+8];\n  t[9*2+3]=s[9*2+1];\n  t[9*2+4]=s[9*2+4];\n  t[9*2+5]=s[9*2+7];\n  t[9*2+6]=s[9*2+0];\n  t[9*2+7]=s[9*2+3];\n  t[9*2+8]=s[9*2+6];\n  \n  return t;\n}\n\nstring rot_S(string s){\n  s=rot_N(s); s=rot_N(s); s=rot_N(s);\n  return s;\n}\n\nstring rot_W(string s){\n  s=rot_E(s); s=rot_E(s); s=rot_E(s);\n  return s;\n}\n\nbool check(string s){\n  return (s[6]=='*'||s[7]=='*'||s[8]=='*')&&(s[9*2+6]=='*'||s[9*2+7]=='*'||s[9*2+8]=='*');\n}\n\nqueue<P> q;\nset<string> memo;\n\nint bfs(){\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n    \n    string s=t.second;\n\n    if(memo.count(s)) continue;\n    memo.insert(s);\n    \n    int cnt=t.first;\n    \n    if(check(s)) return cnt;\n    \n    string ns;\n    \n    ns=rot_N(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_E(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_S(s);\n    q.push(P(cnt+1,ns));\n    \n    ns=rot_W(s);\n    q.push(P(cnt+1,ns));\n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    string s,t;\n\n    cin>>t;\n    if(t==\"#\") break;\n    \n    s+=t;\n    \n    for(int i=0;i<17;i++){\n      cin>>t;\n      s+=t;\n    }\n\n    q.push(P(0,s));\n    \n    cout<<bfs()<<endl;\n\n    while(!q.empty())  q.pop();\n    memo.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_f(){\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_b(){\n    rep(i,3)rotate_f();\n  }\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n    upsideDown(m[d[LE]]);\n    upsideDown(m[d[BO]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][0][0] =='*' || \n\t m[d[BA]][0][1] =='*' || \t\n\t m[d[BA]][0][2] =='*' ))return true;\n\n    //rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\n\n\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// z軸を中心に右回転\nint rotateRight[]={0,1,3,5,2,4,6};\n// z軸を中心に左回転\nint rotateLeft[]={0,1,4,2,5,3,6};\n// 回転させてマッチするfaceを探す\n// curFaceに結果を代入\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // 左へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // 前へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++){\n          for(int l=0;l<3;l++){\n            nfield[l][2-k]=field[i-1][j][k][l];\n          }\n        }\n        // fieldを回転させる\n        for(int k=0;k<3;k++)\n          for(int l=0;l<3;l++)\n            field[i][j][k][l]=nfield[l][k];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    //cout<<\"a\"<<endl;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      //cout<<front<<\" \"<<top<<endl;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n      int cnt2=0;\n      for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // 面を四方向に回転\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // 前\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // 後ろ\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n    //cout<<\"end\"<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_b(){\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_f(){rep(i,3)rotate_b();}\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n    upsideDown(m[d[LE]]);\n    upsideDown(m[d[BO]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    /*\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][0][0] =='*' || \n\t m[d[BA]][0][1] =='*' || \t\n\t m[d[BA]][0][2] =='*' ))return true;\n    */\n    rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstring dice[6][3];\n\nint main()\n{\n    while(true){\n\tcin >> dice[0][0];\n\tif(dice[0][0] == \"#\") break;\n\tcin >> dice[0][1] >> dice[0][2];\n\trep(i,5)rep(j,3)cin >> dice[i+1][j];\n\tint ans = INF;\n\tbool exist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 0);\n\t\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[0][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[2][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 3);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[1][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[3][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 3);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][2][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][0][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][0][i] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][2][i] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 1);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][i][0] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][i][0] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\n\texist1 = false, exist2 = false;\n\trep(i,3)if(dice[4][i][2] == '*'){\n\t    exist1 = true;\n\t    break;\n\t}\n\trep(i,3)if(dice[5][i][2] == '*'){\n\t    exist2 = true;\n\t    break;\n\t}\n\tif(exist1 && exist2) ans = min(ans, 2);\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  string s[6][3];\n  while(cin>>s[0][0],s[0][0]!=\"#\"){\n\n    for(int i=1;i<18;i++)cin>>s[i/3][i%3];\n\n    if((s[0][2][0]=='*'||s[0][2][1]=='*'||s[0][2][2]=='*')&&(s[2][2][0]=='*'||s[2][2][1]=='*'||s[2][2][2]=='*'))cout<<0<<endl;\n\n    else if((s[0][0][0]=='*'||s[0][1][0]=='*'||s[0][2][0]=='*')&&(s[2][0][2]=='*'||s[2][1][2]=='*'||s[2][2][2]=='*')||\n            (s[0][0][2]=='*'||s[0][1][2]=='*'||s[0][2][2]=='*')&&(s[2][0][0]=='*'||s[2][1][0]=='*'||s[2][2][0]=='*')||\n            (s[4][0][0]=='*'||s[4][0][1]=='*'||s[4][0][2]=='*')&&(s[5][2][0]=='*'||s[5][2][1]=='*'||s[5][2][2]=='*')||\n            (s[4][2][0]=='*'||s[4][2][1]=='*'||s[4][2][2]=='*')&&(s[5][0][0]=='*'||s[5][0][1]=='*'||s[5][0][2]=='*'))cout<<1<<endl;\n\n    else if((s[0][0][0]=='*'||s[0][0][1]=='*'||s[0][0][2]=='*')&&(s[2][0][0]=='*'||s[2][0][1]=='*'||s[2][0][2]=='*')||\n            (s[1][0][0]=='*'||s[1][1][0]=='*'||s[1][2][0]=='*')&&(s[3][0][2]=='*'||s[3][1][2]=='*'||s[3][2][2]=='*')||\n            (s[1][0][2]=='*'||s[1][1][2]=='*'||s[1][2][2]=='*')&&(s[3][0][0]=='*'||s[3][1][0]=='*'||s[3][2][0]=='*')||\n            (s[4][0][0]=='*'||s[4][1][0]=='*'||s[4][2][0]=='*')&&(s[5][0][0]=='*'||s[5][1][0]=='*'||s[5][2][0]=='*')||\n            (s[4][0][2]=='*'||s[4][1][2]=='*'||s[4][2][2]=='*')&&(s[5][0][2]=='*'||s[5][1][2]=='*'||s[5][2][2]=='*'))cout<<2<<endl;\n\n    else cout<<3<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nint Max(int &a,int b){return a=max(a,b);}\nint Min(int &a,int b){return a=min(a,b);}\n\n/*?????¬??????TOP?????????????????¢?????????*/\n/*TOP??¨BOTTOM???FRONT?????????????????¢?????????*/\n/************/\n/*  0       */\n/*  1 3 4 2 */\n/*  5       */\n/************/\nclass Cube{\npublic:\n  struct cdat{char num[3][3];};\n  const int TOP = 0, FRONT = 1, LEFT = 2;\n  const int RIGHT = 3, BACK = 4, BOTTOM = 5;\n  cdat cube[6];\n\n  void rot(string cmd){\n    if(cmd == \"N\") rotN();\n    else if(cmd == \"E\") rotE();\n    else if(cmd == \"S\") rotS();\n    else if(cmd == \"W\") rotW();\n    else if(cmd == \"CW\") rotCW();\n    else if(cmd == \"CCW\") rotCCW();\n    else exit(1);\n  }\n\n  void pr(){\n    map<int,string> M;\n    M[0] = \"TOP\",M[1] = \"FRONT\",M[2] = \"LEFT\";\n    M[3] = \"RIGHT\", M[4] = \"BACK\", M[5] = \"BOTTOM\";\n    for(int i=0;i<6;i++){\n      cout<<M[i]<<endl;\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++)cout<<cube[i].num[j][k];\n        cout<<endl;\n      }\n    }\n  }\n\n  void rot90(cdat &a){\n    cdat b = a;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++) a.num[i][j] = b.num[2-j][i];\n  }\n  void reverseX(cdat &a){for(int i=0;i<3;i++) reverse(a.num[i],a.num[i]+3);}\n  void reverseY(cdat &a){rot90(a),reverseX(a),rot90(a),rot90(a),rot90(a);}\n  \n\n  void rotN(){  //?\\\\?????¢??????\n    swap(cube[TOP],cube[FRONT]);\n    swap(cube[FRONT],cube[BOTTOM]);\n    swap(cube[BOTTOM],cube[BACK]);\n    rot90(cube[TOP]),rot90(cube[TOP]);\n    rot90(cube[BOTTOM]),rot90(cube[BOTTOM]);\n    rot90(cube[LEFT]),rot90(cube[LEFT]),rot90(cube[LEFT]);\n    rot90(cube[RIGHT]);\n  }\n\n\n  void rotCCW(){  //??????????????????????¨???????????????????\n    swap(cube[FRONT],cube[LEFT]);\n    swap(cube[LEFT],cube[BACK]);\n    swap(cube[BACK],cube[RIGHT]);\n    rot90(cube[TOP]),rot90(cube[TOP]),rot90(cube[TOP]);\n    rot90(cube[BOTTOM]);\n  }\n  \n  void rotE(){rotCCW();rotN();rotCW();}//????????¢??????\n  void rotS(){rotN(),rotN(),rotN();}//???????????¢??????\n  void rotW(){rotE(),rotE(),rotE();}//????????¢??????\n  void rotCW(){rotCCW(),rotCCW(),rotCCW();}//???????????????????¨????????????????\n};\n\nCube C;\nconst int TOP = 0, FRONT = 1, LEFT = 2;\nconst int RIGHT = 3, BACK = 4, BOTTOM = 5;\n\n\nbool check(const Cube &c){\n  bool front=0,back=0;\n  for(int i=0;i<3;i++) front |= c.cube[FRONT].num[2][i] == '*';\n  for(int i=0;i<3;i++) back |= c.cube[BACK].num[2][i] == '*';\n  return front && back;\n}\n\nstring dir[] = {\"N\",\"E\",\"S\",\"W\"};\nint ans;\nvoid dfs(int dep){\n  if(check(C)) ans = dep;\n  if(ans <= dep) return;\n  for(int i=0;i<4;i++){\n    C.rot(dir[i]);\n    dfs(dep+1);\n    C.rot(dir[(i+2)%4]);\n  }\n}\n\nsigned main(){\n  while(1){\n    int ord[]={FRONT,RIGHT,BACK,LEFT,TOP,BOTTOM};\n    for(int i=0;i<6;i++)\n      for(int j=0;j<3;j++)\n        for(int k=0;k<3;k++){\n          char ch;\n          cin>>ch;\n          if(ch == '#') return 0;\n          C.cube[ord[i]].num[j][k] = ch;\n        }\n\n    \n    C.rot90(C.cube[TOP]);\n    C.rot90(C.cube[TOP]);\n\n    ans = 10;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring tmp[6];\n\nvoid rotN() {\n  string t = tmp[0];\n  tmp[0] = tmp[5];\n  tmp[5] = tmp[2];\n  tmp[2] = tmp[4];\n  tmp[4] = tmp[0];\n\n  t = tmp[2];\n  tmp[2][0] = t[6];\n  tmp[2][1] = t[7];\n  tmp[2][2] = t[8];\n  tmp[2][6] = t[0];\n  tmp[2][7] = t[1];\n  tmp[2][8] = t[2];\n  \n  t = tmp[5];\n  tmp[5][0] = t[6];\n  tmp[5][1] = t[7];\n  tmp[5][2] = t[8];\n  tmp[5][6] = t[0];\n  tmp[5][7] = t[1];\n  tmp[5][8] = t[2];\n  \n  t = tmp[1];\n  tmp[1][0] = t[2];\n  tmp[1][1] = t[5];\n  tmp[1][2] = t[8];\n  tmp[1][3] = t[1];\n  tmp[1][4] = t[4];\n  tmp[1][5] = t[7];\n  tmp[1][6] = t[0];\n  tmp[1][7] = t[3];\n  tmp[1][8] = t[6];\n\n  t = tmp[3];\n  tmp[3][0] = t[6];\n  tmp[3][1] = t[3];\n  tmp[3][2] = t[0];\n  tmp[3][3] = t[7];\n  tmp[3][4] = t[4];\n  tmp[3][5] = t[1];\n  tmp[3][6] = t[6];\n  tmp[3][7] = t[3];\n  tmp[3][8] = t[0];\n}\n\nvoid rotE() {\n\n  string t = tmp[4];\n  tmp[4][0] = t[6];\n  tmp[4][1] = t[3];\n  tmp[4][2] = t[0];\n  tmp[4][3] = t[7];\n  tmp[4][4] = t[4];\n  tmp[4][5] = t[1];\n  tmp[4][6] = t[6];\n  tmp[4][7] = t[3];\n  tmp[4][8] = t[0];\n\n  t = tmp[1];\n  tmp[1][0] = t[6];\n  tmp[1][1] = t[3];\n  tmp[1][2] = t[0];\n  tmp[1][3] = t[7];\n  tmp[1][4] = t[4];\n  tmp[1][5] = t[1];\n  tmp[1][6] = t[6];\n  tmp[1][7] = t[3];\n  tmp[1][8] = t[0];\n  \n  t = tmp[5];\n  tmp[5][0] = t[6];\n  tmp[5][1] = t[3];\n  tmp[5][2] = t[0];\n  tmp[5][3] = t[7];\n  tmp[5][4] = t[4];\n  tmp[5][5] = t[1];\n  tmp[5][6] = t[6];\n  tmp[5][7] = t[3];\n  tmp[5][8] = t[0];\n\n  t = tmp[3];\n  tmp[3][0] = t[6];\n  tmp[3][1] = t[3];\n  tmp[3][2] = t[0];\n  tmp[3][3] = t[7];\n  tmp[3][4] = t[4];\n  tmp[3][5] = t[1];\n  tmp[3][6] = t[6];\n  tmp[3][7] = t[3];\n  tmp[3][8] = t[0];\n  \n  t = tmp[1];\n  tmp[1] = tmp[4];\n  tmp[4] = tmp[3];\n  tmp[3] = tmp[5];\n  tmp[5] = t;\n\n   t = tmp[2];\n  tmp[2][0] = t[2];\n  tmp[2][1] = t[5];\n  tmp[2][2] = t[8];\n  tmp[2][3] = t[1];\n  tmp[2][4] = t[4];\n  tmp[2][5] = t[7];\n  tmp[2][6] = t[0];\n  tmp[2][7] = t[3];\n  tmp[2][8] = t[6];\n\n  t = tmp[0];\n  tmp[0][0] = t[6];\n  tmp[0][1] = t[3];\n  tmp[0][2] = t[0];\n  tmp[0][3] = t[7];\n  tmp[0][4] = t[4];\n  tmp[0][5] = t[1];\n  tmp[0][6] = t[6];\n  tmp[0][7] = t[3];\n  tmp[0][8] = t[0];\n}\n\nint main()\n{\n  string s[18];\n  while( 1 ) {\n    cin >> s[0];\n    if( s[0][0] == '#' ) break;\n    for(int i=1; i<18; i++) cin >> s[i];\n\n    \n    string dice[6];\n    \n    for(int i=0; i<6; i++) dice[i] = \"\";\n    \n    for(int i=0; i<6; i++) {\n      \n      dice[i] = s[i*3] + s[i*3+1] + s[i*3+2];\n      \n    }\n\n    \n    int mn = 1e9;\n    for(int i=0; i<4; i++) {\n      for(int j=0; j<4; j++) {\n\t  \n\t  for(int k=0; k<6; k++) tmp[k] = dice[k];\n\t  \n\t  for(int k=0; k<i; k++) rotN();\n\t  \n\t  for(int k=0; k<j; k++) rotE();\n\t  \n\t  if( (dice[0][6] == '*' || dice[0][7] == '*' || dice[0][8] == '*') &&  (dice[2][6] == '*' || dice[2][7] == '*' || dice[2][8] == '*') ) {\n\t    int sum = 0;\n\t    if( i > 2 ) sum += 4 - i;\n\t    else sum += i;#include<bits/stdc++.h>\nusing namespace std;\n\nstring tmp[6];\n\nvoid rotN() {\n  string t = tmp[0];\n  tmp[0] = tmp[5];\n  tmp[5] = tmp[2];\n  tmp[2] = tmp[4];\n  tmp[4] = tmp[0];\n\n  t = tmp[2];\n  tmp[2][0] = t[6];\n  tmp[2][1] = t[7];\n  tmp[2][2] = t[8];\n  tmp[2][6] = t[0];\n  tmp[2][7] = t[1];\n  tmp[2][8] = t[2];\n  \n  t = tmp[5];\n  tmp[5][0] = t[6];\n  tmp[5][1] = t[7];\n  tmp[5][2] = t[8];\n  tmp[5][6] = t[0];\n  tmp[5][7] = t[1];\n  tmp[5][8] = t[2];\n  \n  t = tmp[1];\n  tmp[1][0] = t[2];\n  tmp[1][1] = t[5];\n  tmp[1][2] = t[8];\n  tmp[1][3] = t[1];\n  tmp[1][4] = t[4];\n  tmp[1][5] = t[7];\n  tmp[1][6] = t[0];\n  tmp[1][7] = t[3];\n  tmp[1][8] = t[6];\n\n  t = tmp[3];\n  tmp[3][0] = t[6];\n  tmp[3][1] = t[3];\n  tmp[3][2] = t[0];\n  tmp[3][3] = t[7];\n  tmp[3][4] = t[4];\n  tmp[3][5] = t[1];\n  tmp[3][6] = t[6];\n  tmp[3][7] = t[3];\n  tmp[3][8] = t[0];\n}\n\nvoid rotE() {\n\n  string t = tmp[4];\n  tmp[4][0] = t[6];\n  tmp[4][1] = t[3];\n  tmp[4][2] = t[0];\n  tmp[4][3] = t[7];\n  tmp[4][4] = t[4];\n  tmp[4][5] = t[1];\n  tmp[4][6] = t[6];\n  tmp[4][7] = t[3];\n  tmp[4][8] = t[0];\n\n  t = tmp[1];\n  tmp[1][0] = t[6];\n  tmp[1][1] = t[3];\n  tmp[1][2] = t[0];\n  tmp[1][3] = t[7];\n  tmp[1][4] = t[4];\n  tmp[1][5] = t[1];\n  tmp[1][6] = t[6];\n  tmp[1][7] = t[3];\n  tmp[1][8] = t[0];\n  \n  t = tmp[5];\n  tmp[5][0] = t[6];\n  tmp[5][1] = t[3];\n  tmp[5][2] = t[0];\n  tmp[5][3] = t[7];\n  tmp[5][4] = t[4];\n  tmp[5][5] = t[1];\n  tmp[5][6] = t[6];\n  tmp[5][7] = t[3];\n  tmp[5][8] = t[0];\n\n  t = tmp[3];\n  tmp[3][0] = t[6];\n  tmp[3][1] = t[3];\n  tmp[3][2] = t[0];\n  tmp[3][3] = t[7];\n  tmp[3][4] = t[4];\n  tmp[3][5] = t[1];\n  tmp[3][6] = t[6];\n  tmp[3][7] = t[3];\n  tmp[3][8] = t[0];\n  \n  t = tmp[1];\n  tmp[1] = tmp[4];\n  tmp[4] = tmp[3];\n  tmp[3] = tmp[5];\n  tmp[5] = t;\n\n   t = tmp[2];\n  tmp[2][0] = t[2];\n  tmp[2][1] = t[5];\n  tmp[2][2] = t[8];\n  tmp[2][3] = t[1];\n  tmp[2][4] = t[4];\n  tmp[2][5] = t[7];\n  tmp[2][6] = t[0];\n  tmp[2][7] = t[3];\n  tmp[2][8] = t[6];\n\n  t = tmp[0];\n  tmp[0][0] = t[6];\n  tmp[0][1] = t[3];\n  tmp[0][2] = t[0];\n  tmp[0][3] = t[7];\n  tmp[0][4] = t[4];\n  tmp[0][5] = t[1];\n  tmp[0][6] = t[6];\n  tmp[0][7] = t[3];\n  tmp[0][8] = t[0];\n}\n\nint main()\n{\n  string s[18];\n  while( 1 ) {\n    cin >> s[0];\n    if( s[0][0] == '#' ) break;\n    for(int i=1; i<18; i++) cin >> s[i];\n\n    \n    string dice[6];\n    \n    for(int i=0; i<6; i++) dice[i] = \"\";\n    \n    for(int i=0; i<6; i++) {\n      \n      dice[i] = s[i*3] + s[i*3+1] + s[i*3+2];\n      \n    }\n\n    \n    int mn = 1e9;\n    for(int i=0; i<4; i++) {\n      for(int j=0; j<4; j++) {\n\t  \n\t  for(int k=0; k<6; k++) tmp[k] = dice[k];\n\t  \n\t  for(int k=0; k<i; k++) rotN();\n\t  \n\t  for(int k=0; k<j; k++) rotE();\n\t  \n\t  if( (dice[0][6] == '*' || dice[0][7] == '*' || dice[0][8] == '*') &&  (dice[2][6] == '*' || dice[2][7] == '*' || dice[2][8] == '*') ) {\n\t    int sum = 0;\n\t    if( i > 2 ) sum += 4 - i;\n\t    else sum += i;\n\t    if( j > 2 ) sum += 4 - j;\n\t    else sum += j;\n\t    \n\t    mn = min(mn, sum);\n\t  }\n      }\n    }\n    cout<<'b'<<endl;\n    cout << mn << endl;\n  }\n}\n\n\t    if( j > 2 ) sum += 4 - j;\n\t    else sum += j;\n\t    \n\t    mn = min(mn, sum);\n\t  }\n      }\n    }\n    cout<<'b'<<endl;\n    cout << mn << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvector<vs>in(6,vs(3));\nint main(){\n\twhile(1){\n\t\tstring t;cin>>t;\n\t\tif(t==\"#\")return 0;\n\t\trep(i,6)rep(j,3){\n\t\t\tif(i+j==0)in[i][j]=t;\n\t\t\telse cin>>in[i][j];\n\t\t}\n\t\trep(i,3){\n\t\t\treverse(all(in[2][i]));\n\t\t\treverse(all(in[3][i]));\n\t\t}\n\t\trep(i,3)\n\t\t\tswap(in[5][0][i],in[5][2][i]);\n\n\t\tint out=inf;\n\t\tif((in[0][0][0]=='*'||in[0][0][1]=='*'||in[0][0][2]=='*')&&\n\t\t   (in[2][0][0]=='*'||in[2][0][1]=='*'||in[2][0][2]=='*'))out=min(out,2);\n\t\tif((in[0][2][0]=='*'||in[0][2][1]=='*'||in[0][2][2]=='*')&&\n\t\t   (in[2][2][0]=='*'||in[2][2][1]=='*'||in[2][2][2]=='*'))out=min(out,0);\n\t\tif((in[0][0][0]=='*'||in[0][1][0]=='*'||in[0][2][0]=='*')&&\n\t\t   (in[2][0][0]=='*'||in[2][1][0]=='*'||in[2][2][0]=='*'))out=min(out,1);\n\t\tif((in[0][0][2]=='*'||in[0][1][2]=='*'||in[0][2][2]=='*')&&\n\t\t   (in[2][0][2]=='*'||in[2][1][2]=='*'||in[2][2][2]=='*'))out=min(out,1);\n\n\t\tif((in[1][0][0]=='*'||in[1][0][1]=='*'||in[1][0][2]=='*')&&\n\t\t   (in[3][0][0]=='*'||in[3][0][1]=='*'||in[3][0][2]=='*'))out=min(out,3);\n\t\tif((in[1][2][0]=='*'||in[1][2][1]=='*'||in[1][2][2]=='*')&&\n\t\t   (in[3][2][0]=='*'||in[3][2][1]=='*'||in[3][2][2]=='*'))out=min(out,3);\n\t\tif((in[1][0][0]=='*'||in[1][1][0]=='*'||in[1][2][0]=='*')&&\n\t\t   (in[3][0][0]=='*'||in[3][1][0]=='*'||in[3][2][0]=='*'))out=min(out,2);\n\t\tif((in[1][0][2]=='*'||in[1][1][2]=='*'||in[1][2][2]=='*')&&\n\t\t   (in[3][0][2]=='*'||in[3][1][2]=='*'||in[3][2][2]=='*'))out=min(out,2);\n\n\t\tif((in[4][0][0]=='*'||in[4][0][1]=='*'||in[4][0][2]=='*')&&\n\t\t   (in[5][0][0]=='*'||in[5][0][1]=='*'||in[5][0][2]=='*'))out=min(out,1);\n\t\tif((in[4][2][0]=='*'||in[4][2][1]=='*'||in[4][2][2]=='*')&&\n\t\t   (in[5][2][0]=='*'||in[5][2][1]=='*'||in[5][2][2]=='*'))out=min(out,1);\n\t\tif((in[4][0][0]=='*'||in[4][1][0]=='*'||in[4][2][0]=='*')&&\n\t\t   (in[5][0][0]=='*'||in[5][1][0]=='*'||in[5][2][0]=='*'))out=min(out,2);\n\t\tif((in[4][0][2]=='*'||in[4][1][2]=='*'||in[4][2][2]=='*')&&\n\t\t   (in[5][0][2]=='*'||in[5][1][2]=='*'||in[5][2][2]=='*'))out=min(out,2);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct panel{\n  char t[3][3];\n};\n\npanel ra(panel p){\n  char u[3][3];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)u[i][j]=p.t[i][j];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)p.t[i][j]=u[j][2-i];\n  return p;\n}\n\npanel rb(panel p){\n  char u[3][3];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)u[i][j]=p.t[i][j];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)p.t[i][j]=u[2-i][j];\n  return p;\n}\n\nstruct die{\n  panel t[6];\n  bool operator < (const die &p)const{\n    for(int i=0;i<6;i++)\n      for(int j=0;j<3;j++)\n        for(int k=0;k<3;k++)\n          if(t[i].t[j][k]!=p.t[i].t[j][k])\n            return (t[i].t[j][k]<p.t[i].t[j][k]);\n    return false;\n  }\n};\n\ndie ra(die p){\n  panel tmp=p.t[0];\n  p.t[0]=p.t[4];\n  p.t[4]=ra(ra(p.t[2]));\n  p.t[2]=ra(ra(p.t[5]));\n  p.t[5]=tmp;\n  p.t[1]=ra(p.t[1]);\n  p.t[3]=ra(ra(ra(p.t[3])));\n  return p;\n}\n\ndie rb(die p){\n  panel tmp=p.t[1];\n  p.t[1]=ra(ra(ra(p.t[4])));\n  p.t[4]=ra(ra(ra(p.t[3])));\n  p.t[3]=ra(ra(ra(p.t[5])));\n  p.t[5]=ra(ra(ra(tmp)));\n  p.t[0]=ra(ra(ra(p.t[0])));\n  p.t[2]=ra(p.t[2]);\n  return p;\n}\n\nchar str[100];\n\nbool input(panel &p){\n  for(int i=0;i<3;i++){\n    scanf(\"%s\",str);\n    if(str[0]=='#')return false;\n    for(int j=0;j<3;j++)p.t[i][j]=str[j];\n  }\n  return true;\n}\n\nbool check(panel &p){\n  for(int i=0;i<3;i++)\n    if(p.t[2][i]=='*')return true;\n  return false;\n}\n\nint main(){\n  die A;\n  while(input(A.t[0])){\n    for(int i=1;i<6;i++)input(A.t[i]);\n    map< die , int > d;\n    queue< die > Q;\n    d[A]=0;\n    Q.push(A);\n    while(!Q.empty()){\n      die s=Q.front();Q.pop();\n      int cost=d[s];\n      if( check(s.t[0]) && check(s.t[2]) ){\n        cout<<cost<<endl;\n        break;\n      }\n      die next=ra(s);\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n\n      next=ra(ra(ra(s)));\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n\n      next=rb(s);\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n      \n      next=rb(rb(rb(s)));\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n\n#define maxn 36\n\nusing namespace std;\n\nchar map[6][3][3], tmp[maxn];\nint hole[6][4], hpair[6][4];\n\nvoid clean()\n{\n    memset(map, 0, sizeof(map));\n    memset(hole, 0, sizeof(hole));\n    memset(hpair, 0, sizeof(hpair));\n}\n\nvoid read()\n{\n    char tmp2[maxn];\n\n    for(int i = 0; i < 6; i++){\n        for(int j = 0; j < 3; j++){\n            if(i == 0 && j == 0)\n                strcpy(tmp2, tmp);\n            else scanf(\"%s\", tmp2);\n            for(int k = 0; k < 3; k++)\n                map[i][j][k] = tmp2[k];\n        }\n    }\n}\n\nvoid signp()\n{\n    hpair[0][0] = hole[0][0] & hole[2][0];//1-3-0\n    hpair[0][1] = hole[0][1] & hole[2][3];//1-3-1\n    hpair[0][2] = hole[0][2] & hole[2][2];//1-3-2\n    hpair[0][3] = hole[0][3] & hole[2][1];//1-3-3\n\n    hpair[1][0] = hole[1][0] & hole[3][0];\n    hpair[1][1] = hole[1][1] & hole[3][3];\n    hpair[1][2] = hole[1][2] & hole[3][2];\n    hpair[1][3] = hole[1][3] & hole[3][1];\n\n    hpair[4][0] = hole[4][0] & hole[5][2];\n    hpair[4][1] = hole[4][1] & hole[5][1];\n    hpair[4][2] = hole[4][2] & hole[5][0];\n    hpair[4][3] = hole[4][3] & hole[5][3];\n}\n\nvoid sign()\n{\n    for(int i = 0; i < 6; i++)\n        for(int j = 0; j < 3; j++)\n            for(int k = 0; k < 3; k++)\n                if(map[i][j][k] == '*'){\n                    if(j == 0) hole[i][0] = 1;//up\n                    if(k == 2) hole[i][1] = 1;//right\n                    if(j == 2) hole[i][2] = 1;//down\n                    if(k == 0) hole[i][3] = 1;\n                }\n\n    signp();\n}\n\nint chk()\n{\n    if(hpair[0][2]) return 0;\n    if(hpair[0][1]) return 1;\n    if(hpair[0][3]) return 1;\n    if(hpair[4][0]) return 1;\n    if(hpair[4][2]) return 1;\n    if(hpair[4][1]) return 2;\n    if(hpair[4][3]) return 2;\n    if(hpair[0][0]) return 2;\n    if(hpair[1][1]) return 2;\n    if(hpair[1][3]) return 2;\n    if(hpair[1][0]) return 3;\n    if(hpair[1][2]) return 3;\n\n    return -1;\n}\n\nvoid solve()\n{\n    clean();\n    read();\n    sign();\n    cout << chk() << endl;\n}\n\nint main(void)\n{\n    while(scanf(\"%s\", tmp), tmp[0] !='#')\n        solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct face{\n  string c[3];\n  face(){}\n  face(string s[3]){\n    for(int i=0;i<3;i++) c[i]=s[i];\n  }\n};\nstruct dice{\n  face f[6];\n  int d;\n  dice(){}\n  dice(string s[6][3]){\n    d=0;\n    for(int i=0;i<6;i++)\n      f[i]=face(s[i]);\n  }\n};\n\nbool check(dice d){\n  bool res=1,f;\n  f=0;\n  for(int i=0;i<3;i++) f|=d.f[0].c[2][i]=='*';\n  res&=f;\n  f=0;\n  for(int i=0;i<3;i++) f|=d.f[2].c[2][i]=='*';\n  res&=f;\n  return res;\n}\nface sr(face f){\n  face p=f;\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      p.c[i][j]=f.c[2-j][i];\n  return p;\n}\nface sl(face f){\n  face p=f;\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      p.c[i][j]=f.c[j][2-i];\n  return p;\n}\nface re(face f){\n  face p=f;\n  for(int i=0;i<3;i++)\n    p.c[i]=f.c[2-i];\n  return p;\n}\ndice rotate1(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=d.f[5];\n  b.f[1]=sr(d.f[1]);\n  b.f[2]=re(d.f[4]);\n  b.f[3]=sl(d.f[3]);\n  b.f[4]=d.f[0];\n  b.f[5]=re(d.f[2]);\n  return b;\n}\ndice rotate2(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=d.f[4];\n  b.f[1]=sl(d.f[1]);\n  b.f[2]=re(d.f[5]);\n  b.f[3]=sr(d.f[3]);\n  b.f[4]=re(d.f[2]);\n  b.f[5]=d.f[0];\n  return b;\n}\ndice rotate3(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=sl(d.f[0]);\n  b.f[1]=sl(d.f[5]);\n  b.f[2]=sr(d.f[2]);\n  b.f[3]=sl(d.f[4]);\n  b.f[4]=sl(d.f[1]);\n  b.f[5]=sl(d.f[3]);\n  return b;\n}\ndice rotate4(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=sr(d.f[0]);\n  b.f[1]=sr(d.f[4]);\n  b.f[2]=sl(d.f[2]);\n  b.f[3]=sr(d.f[5]);\n  b.f[4]=sr(d.f[3]);\n  b.f[5]=sr(d.f[1]);\n  return b;\n}\nsigned main(){\n  string tmp;\n  while(cin>>tmp,tmp!=\"#\"){\n    string s[6][3];\n    s[0][0]=tmp;\n    for(int i=0;i<6;i++)\n      for(int j=0;j<3;j++){\n\tif((i||j)==0) continue;\n\tcin>>s[i][j];\n      }\n    dice d(s);\n    if(0){\n      d=rotate1(d);\n      d=rotate3(d);\n      d=rotate2(d);\n      cout<<check(d)<<endl;\n      for(int i=0;i<6;i++){\n\tfor(int j=0;j<3;j++) cout<<d.f[i].c[j]<<endl;\n\tcout<<endl;\n      }\n      return 0;\n    }\n    queue<dice> q;\n    q.push(d);\n    int ans=-1;\n    while(!q.empty()){\n      d=q.front();q.pop();\n      if(check(d)){\n\tans=d.d;\n\tbreak;\n      }\n      //cout<<d.d<<endl;\n\n      //if(d.d>1) break;\n      \n      //cout<<d.d<<endl;\n      /*//\n      for(int i=0;i<6;i++){\n\tfor(int j=0;j<3;j++) cout<<d.f[i].c[j]<<endl;\n\tcout<<endl;\n      }\n      //*/\n      q.push(rotate1(d));\n      q.push(rotate2(d));\n      q.push(rotate3(d));\n      q.push(rotate4(d));\n    }\n    cout<<ans<<endl;\n  }\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nchar d[6][3][3];\nint c[6][3][3];\nvoid solve() {\n\twhile (true) {\n\t\trep(i, 6) {\n\t\t\trep(j, 3) {\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tcin >> d[i][j][k];\n\t\t\t\t\tif (d[i][j][k] == '#')return;\n\t\t\t\t\tif (d[i][j][k] == '*')c[i][j][k] = 1;\n\t\t\t\t\telse c[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = mod;\n\t\tif (c[0][2][0] + c[0][2][1] + c[0][2][2] && c[2][2][0] + c[2][2][1] + c[2][2][2]) {\n\t\t\tans = 0;\n\t\t}\n\t\tif (c[0][0][0] + c[0][1][0] + c[0][2][0] && c[2][0][2] + c[2][1][2] + c[2][2][2]) {\n\t\t\tans = min(ans, 1);\n\t\t}\n\t\tif (c[0][0][2] + c[0][1][2] + c[0][2][2] && c[2][0][0] + c[2][1][0] + c[2][2][0]) {\n\t\t\tans = min(ans, 1);\n\t\t}\n\t\tif (c[0][0][0] + c[0][0][1] + c[0][0][2] && c[2][0][0] + c[2][0][1] + c[2][0][2]) {\n\t\t\tans = min(ans, 2);\n\t\t}\n\t\tif (c[1][2][0] + c[1][2][1] + c[1][2][2] && c[3][2][0] + c[3][2][1] + c[3][2][2]) {\n\t\t\tans = min(ans, 3);\n\t\t}\n\t\tif (c[1][2][0] + c[1][1][0] + c[1][0][0] && c[3][0][2] + c[3][1][2] + c[3][2][2]) {\n\t\t\tans = min(ans, 2);\n\t\t}\n\t\tif (c[1][0][2] + c[1][1][2] + c[1][2][2] && c[3][0][0] + c[3][1][0] + c[3][2][0]) {\n\t\t\tans = min(ans, 2);\n\t\t}\n\t\tif (c[1][0][0] + c[1][0][1] + c[1][0][2] && c[3][0][0] + c[3][0][1] + c[3][0][2]) {\n\t\t\tans = min(ans, 3);\n\t\t}\n\t\tif (c[4][2][0] + c[4][2][1] + c[4][2][2] && c[5][0][0] + c[5][0][1] + c[5][0][2]) {\n\t\t\tans = min(ans, 1);\n\t\t}\n\t\tif (c[4][0][0] + c[4][0][1] + c[4][0][2] && c[5][2][0] + c[5][2][1] + c[5][2][2]) {\n\t\t\tans = min(ans, 1);\n\t\t}\n\t\tif (c[4][0][0] + c[4][1][0] + c[4][2][0] && c[5][0][0] + c[5][1][0] + c[5][2][0]) {\n\t\t\tans = min(ans, 2);\n\t\t}\n\t\tif (c[4][0][2] + c[4][1][2] + c[4][2][2] && c[5][0][2] + c[5][1][2] + c[5][2][2]) {\n\t\t\tans = min(ans, 2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<utility>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef array<char,9> P;\n\nvoid cw(P &p){\n  P n;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      n[j*3+2-i]=p[i*3+j];\n    }\n  }\n  p=n;\n}\n\nvoid ccw(P &p){\n  cw(p);\n  cw(p);\n  cw(p);\n}\n\nP lr(P p){\n  P n=p;\n  for(int i=0;i<3;i++){\n    swap(n[0+i*3],n[2+i*3]);\n  }\n  return n;\n}\n\nP inv(P p){\n  ccw(p);\n  ccw(p);\n  return p;\n}\n\nP nccw(P p){\n  ccw(p);\n  return p;\n}\n\nstruct Dice{\n  P p[6];\n  Dice(){\n    for(int i=0;i<6;i++){\n      for(int j=0;j<9;j++){\n\tcin>>p[i][j];\n      }\n    }\n  }\n  bool operator<(Dice d)const{\n    return lexicographical_compare(begin(p),end(p),begin(d.p),end(d.p));\n  }\n  Dice &u(){\n    auto t=p[4];\n    p[4]=p[0];\n    p[0]=p[5];\n    p[5]=inv(p[2]);\n    p[2]=inv(t);\n    cw(p[1]);\n    ccw(p[3]);\n    return *this;\n  }\n  Dice &d(){\n    u();\n    u();\n    u();\n    return *this;\n  }\n  Dice &l(){\n    auto t=p[4];\n    p[4]=nccw(p[1]);\n    p[1]=nccw(p[5]);\n    p[5]=nccw(lr(p[3]));\n    p[3]=lr(nccw(t));\n    cw(p[2]);\n    ccw(p[0]);\n    return *this;\n  }\n  Dice &r(){\n    l();\n    l();\n    l();\n    return *this;\n  }\n};\n\nint main(){\n  for(;;){\n    Dice d;\n    if(!cin)break;\n    set<pair<int,Dice> >s{{0,d}};\n    for(auto e:s){\n      auto cd=e.second;\n      if(count(begin(cd.p[0])+6,begin(cd.p[0])+9,'*')&&count(begin(cd.p[2])+6,begin(cd.p[2])+9,'*')){\n\tcout<<e.first<<endl;\n\tgoto next;\n      }\n      s.insert({e.first+1,Dice(cd).u()});\n      s.insert({e.first+1,Dice(cd).r()});\n      s.insert({e.first+1,Dice(cd).d()});\n      s.insert({e.first+1,Dice(cd).l()});\n    }\n  next:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vl vector<ll>\n#define vs vector<string>\n\n#define vc vector<char>\n#define C vector<vc>\n\nC c;\n\nvc r90(vc v){\n\tvc r;\n\trep(i,3)for(int j=2;j>=0;j--)r.pb(v[j*3+i]);\n\treturn r;\n}\n\nvc l90(vc v){\n\tvc r;\n\tfor(int i=2;i>=0;i--)rep(j,3)r.pb(v[j*3+i]);\n\treturn r;\n}\n\nvc r180(vc v){\n\tvc r;\n\tfor(int i=2;i>=0;i--)for(int j=2;j>=0;j--)r.pb(v[i*3+j]);\n\treturn r;\n}\n\nC rotf(C c){\n\tC r;\n\tr.pb(c[5]);\n\tr.pb(r90(c[1]));\n\tr.pb(r180(c[4]));\n\tr.pb(l90(c[3]));\n\tr.pb(c[0]);\n\tr.pb(r180(c[2]));\n\treturn r;\n}\n\nC rotr(C c){\n\tC r;\n\tr.pb(r90(c[0]));\n\tr.pb(r90(c[4]));\n\tr.pb(l90(c[2]));\n\tr.pb(r90(c[5]));\n\tr.pb(r90(c[3]));\n\tr.pb(r90(c[1]));\n\treturn r;\n}\n\nC rotba(C c){\n\tC r;\n\tr.pb(c[4]);\n\tr.pb(l90(c[1]));\n\tr.pb(r180(c[5]));\n\tr.pb(r90(c[3]));\n\tr.pb(r180(c[2]));\n\tr.pb(c[0]);\n\treturn r;\n}\n\nC rotl(C c){\n\tC r;\n\tr.pb(l90(c[0]));\n\tr.pb(l90(c[5]));\n\tr.pb(r90(c[2]));\n\tr.pb(l90(c[4]));\n\tr.pb(l90(c[1]));\n\tr.pb(l90(c[3]));\n\treturn r;\n}\n\nint main(){\n\tc.resize(6);\n\trep(i,6)c[i].resize(9);\n\twhile(cin>>c[0][0]){\n\t\tif(c[0][0]=='#')break;\n\t\trep(i,8)cin>>c[0][i+1];\n\t\trep(i,5)rep(j,9)cin>>c[i+1][j];\n\t\tmap<C,int> M;\n\t\tqueue<C> Q;\n\t\tM[c]=0;\n\t\tQ.push(c);\n\t\twhile(1){\n\t\t\tC c=Q.front();Q.pop();\n\t\t\tint s=M[c];\n\t\t\tif((c[0][6]=='*'||c[0][7]=='*'||c[0][8]=='*')&&(c[2][6]=='*'||c[2][7]=='*'||c[2][8]=='*')){\n\t\t\t\tcout<<s<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tC c0=rotf(c),c1=rotr(c),c2=rotba(c),c3=rotl(c);\n\t\t\tif(M.find(c0)==M.end())M[c0]=s+1,Q.push(c0);\n\t\t\tif(M.find(c1)==M.end())M[c1]=s+1,Q.push(c1);\n\t\t\tif(M.find(c2)==M.end())M[c2]=s+1,Q.push(c2);\n\t\t\tif(M.find(c3)==M.end())M[c3]=s+1,Q.push(c3);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nchar ch[25][10];\nchar s[20];\nvoid done()\n{   for(int i=0;i<3;i++)\n    if(ch[2][i]=='*'&&ch[8][i]=='*') {cout<<\"0\"<<endl;return;}\n     for(int i=0;i<3;i++)\n    if(ch[i][0]=='*'&&ch[i+6][0]=='*'||ch[i][2]=='*'&&ch[i+6][2]=='*') {cout<<\"1\"<<endl;return;}\n\n    for(int i=0;i<3;i++)\n    if(ch[14][i]=='*'&&ch[15][i]=='*'||ch[12][i]=='*'&&ch[17][i]=='*') {cout<<\"1\"<<endl;return;}\n\n    for(int i=0;i<3;i++)\n    if(ch[0][i]=='*'&&ch[6][i]=='*') {cout<<\"2\"<<endl;return;}\n\n\n\n    if(ch[12][0]=='*'&&ch[17][0]=='*'||ch[12][2]=='*'&&ch[17][2]=='*') {cout<<\"2\"<<endl;return;}\n    if(ch[13][0]=='*'&&ch[16][0]=='*'||ch[13][2]=='*'&&ch[16][2]=='*') {cout<<\"2\"<<endl;return;}\n    if(ch[14][0]=='*'&&ch[15][0]=='*'||ch[14][2]=='*'&&ch[15][2]=='*') {cout<<\"2\"<<endl;return;}\n     for(int i=0;i<3;i++)\n    if(ch[i+3][0]=='*'&&ch[i+9][0]=='*'||ch[i+3][2]=='*'&&ch[i+9][2]=='*') {cout<<\"2\"<<endl;return;}\n\n    cout<<\"3\"<<endl;\n    return;\n\n}\nint main()\n{  int k=0;\n//freopen(\"in\",\"r\",stdin);\n    while(scanf(\"%s\",s)>0)\n    { //cout<<s<<endl;\n\n        if(s[0]=='#') break;\n//cout<<s<<endl;\n        for(int i=0;i<5;i++)\n          ch[k][i]=s[i];\n        k++;\n\n\n        if(k==18)\n        {\n        k=0;\n        done();\n        }\n\n\n//cout<<\"k=\"<<k<<endl;\n\n\n\n\n    }\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nstruct State{\n  string grid[6][3];\n  bool operator < (const State& s) const {\n    REP(i, 6) REP(j, 3) if(grid[i][j] != s.grid[i][j]) return grid[i][j] < s.grid[i][j];\n    return false;\n  }\n};\nbool is_goal(State& s){\n  return s.grid[0][2].find(\"*\") != string::npos && s.grid[2][2].find(\"*\") != string::npos;\n}\n\nvoid copy(string src[3], string dst[3]){\n  REP(i, 3) dst[i] = src[i];\n}\n\nvoid rotate(string s[6][3], int a, int b, int c, int d){\n  a--; b--; c--; d--;\n  // a -> b -> c -> d\n  string tmp[3];\n  copy(s[d], tmp);\n  copy(s[c], s[d]);\n  copy(s[b], s[c]);\n  copy(s[a], s[b]);\n  copy(tmp, s[a]);\n}\n\nvoid revolve90(string s[3]){\n  string tmp[3];\n  copy(s, tmp);\n  REP(y, 3) REP(x, 3){\n    s[y][x] = tmp[2 - x][y];\n  }\n}\n\nvoid revolve(string s[6][3], int k, int t){\n  REP(_, t) revolve90(s[k - 1]);\n}\n\nState rotate(State s, int r){\n  if(r >= 2){\n    return rotate(rotate(rotate(s, r - 2), r - 2), r - 2);\n  }\n  State next;\n  REP(i, 6) copy(s.grid[i], next.grid[i]);\n  if(r == 0) rotate(next.grid, 1, 5, 3, 6);\n  if(r == 1) rotate(next.grid, 2, 5, 4, 6);\n  if(r == 0) {\n    revolve(next.grid, 3, 2);\n    revolve(next.grid, 6, 2);\n\n    revolve(next.grid, 2, 1);\n    revolve(next.grid, 4, 3);\n  }\n  if(r == 1){\n    revolve(next.grid, 5, 1);\n    revolve(next.grid, 4, 1);\n    revolve(next.grid, 6, 1);\n    revolve(next.grid, 2, 1);\n\n    revolve(next.grid, 1, 3);\n    revolve(next.grid, 3, 1);\n  }\n  return next;\n}\n\nvoid print(State s){\n  REP(i, 6){\n    printf(\"--- %d ---\\n\", i + 1);\n    REP(j, 3) cout << s.grid[i][j] << endl;\n  }\n}\n\nint main(){\n  while(true){\n    State start;\n    REP(i, 6) REP(j, 3) cin >> start.grid[i][j];\n    if(cin.eof()) break;\n    map<State, int> dist;\n    queue<State> que;\n    dist[start] = 0;\n    que.push(start);\n    while(!que.empty()){\n      State s = que.front(); que.pop();\n      if(is_goal(s)){\n        cout << dist[s] << endl;\n        break;\n      }\n      REP(r, 4){\n        State next = rotate(s, r);\n        if(!dist.count(next)){\n          dist[next] = dist[s] + 1;\n          que.push(next);\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int r[][6] ={\n\t{1, 2, 3, 0, 4, 5},\n\t{5, 1, 4, 3, 0, 2},\n\t{0, 4, 2, 5, 3, 1}\n};\nvector<vector<string> >in;\nvoid rot(int it, vector<string> &f){\n\twhile(it--){\n\t\tvector<string> nx(3, string(\"...\"));\n\t\trep(i, 3) rep(j, 3) nx[i][j] = f[2 - j][i];\n\t\tswap(nx, f);\n\t}\n}\nvector<vector<string> > rot(int d, const vector<vector<string> > &in){\n\tvector<vector<string> > res;\n\trep(i, 6) res.pb(in[r[d][i]]);\n\tif(d == 0){\n\t\trot(1, res[4]); rot(3, res[5]);\n\t}\n\tif(d == 1){\n\t\trot(1, res[1]); rot(3, res[3]); rot(2, res[5]); rot(2, res[2]);\n\t}\n\tif(d == 2){\n\t\trot(1, res[0]); rot(3, res[2]); rot(1, res[1]); rot(1, res[4]); rot(1, res[3]); rot(1, res[5]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tin = vector<vector<string> >(6, vector<string>(3, \"...\"));\n\twhile(1){\n\t\trep(i, 6) rep(j, 3){\n\t\t\tcin >> in[i][j];\n\t\t\tif(in[i][j] == \"#\") exit(0);\n\t\t}\n\t\t\n\t\tset<vector<vector<string> > > s;\n\t\tqueue<pair<int, vector<vector<string> > > > q;\n\t\tq.push(mp(0, in));\n\t\twhile(!q.empty()){\n\t\t\tin = q.front().second;\n\t\t\tint c = q.front().first; q.pop();\n\t\t\tif(s.count(in)) continue;\n\t\t\ts.insert(in);\n\t\t\t\n\t\t\tbool ok1 = 0, ok2 = 0;\n\t\t\trep(i, 3){\n\t\t\t\tok1 |= in[0][2][i] == '*';\n\t\t\t\tok2 |= in[2][2][i] == '*';\n\t\t\t}\n\t\t\tif(ok1 && ok2){\n\t\t\t\tcout << c << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int d = 1; d < 3; d++) rep(it, 4){\n\t\t\t\tin = rot(d, in);\n\t\t\t\tif(it == 0 || it == 2) q.push(mp(c + 1, in));\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// ??????????????¢??£\nenum FACE { FRONT,RIGHT,BACK,LEFT,TOP,BOTTOM };\n\n\nstruct state{\n  char fie[3][3];\n  bool operator!=(const state& a) const {\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        if( fie[j][i] != a.fie[j][i] ) return true;\n    return false; \n  }\n  bool operator==(const state& a) const {\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        if( fie[j][i] != a.fie[j][i] ) return false;\n    return true; \n  }\n  bool operator<(const state& a) const {\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n        if( fie[j][i] > a.fie[j][i] ) return false;\n        if( fie[j][i] < a.fie[j][i] ) return true;\n      }\n    }\n    return false; \n  }\n\n  void rev(){\n    char bf[3][3];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        bf[j][i] = fie[2-j][2-i];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        fie[j][i] = bf[j][i];\n  }\n\n  void rot(){\n    char bf[3][3];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        bf[j][i] = fie[2-i][j];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        fie[j][i] = bf[j][i];    \n  }\n\n  void ro2(){\n    char bf[3][3];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        bf[j][i] = fie[i][2-j];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        fie[j][i] = bf[j][i];    \n  }\n\n  void view(){\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++)\n        cout << fie[j][i];\n      cout << endl;\n    }\n    cout << endl;\n  }\n};\n\nstruct dice{\npublic:\n  dice(){\n    id[0] = FRONT;\n    id[1] = RIGHT;\n    id[2] = BACK;\n    id[3] = LEFT;\n    id[4] = TOP;\n    id[5] = BOTTOM;\n  }\n  \n  state& operator[] (FACE f){return var[id[f]];}\n  const state& operator[] (FACE f)const {return var[id[f]];}\n\n  bool operator==(const dice &a)const {\n    const dice &b = *this;\n    for(int i=0;i<6;i++){\n      if(a[(FACE)i] != b[(FACE)i]) return false;\n    }\n    return true;\n  }\n  bool operator<(const dice &a) const {\n    const dice &b = *this;\n    for(int i=0;i<6;i++){\n      if( b[(FACE)i] < a[(FACE)i] ) return true;\n      if( b[(FACE)i] == a[(FACE)i] ) continue;\n      return false;\n    }\n    return false;\n  }\n\n  void roll_x(){\n    roll(TOP,BACK,BOTTOM,FRONT);\n    var[TOP].rev(); var[BACK].rev();\n    var[LEFT].ro2(); var[RIGHT].rot();\n  } // X?????????????????¢ (FRONT -> BOTTOM)\n  void roll_y(){\n    roll(TOP,LEFT,BOTTOM,RIGHT);\n    var[FRONT].ro2(); var[TOP].ro2();\n    var[BACK].rot(); var[BOTTOM].ro2();\n    var[LEFT].ro2(); var[RIGHT].ro2();\n  } // Y?????????????????¢ (TOP -> RIGHT)\n  void roll_z(){roll(FRONT,RIGHT,BACK,LEFT);} // Z?????????????????¢ (FRONT -> LEFT)\n\n  state var[6]; // ????????????????¨???¶\n  int id[6]; // ?????¢????¨???¶\n  void roll(FACE a,FACE b,FACE c,FACE d){//a b c d ???b c d a\n    state tmc = var[a];\n    var[a] = var[b];\n    var[b] = var[c];\n    var[c] = var[d];\n    var[d] = tmc;\n  }\n\n  void view(){\n\n    /*    cout << endl;\n    var[FRONT].view();\n    var[RIGHT].view();\n    var[BACK].view();\n    var[LEFT].view();\n    var[TOP].view();\n    var[BOTTOM].view();\n    */\n    for(int i=0;i<6;i++){\n      var[id[i]].view();\n      cout << endl;\n    }\n  }\n};\n\ndice d;\nmap<dice,int> M;\nint solve(){\n  queue<dice> q;\n  M.clear();\n  q.push( d );\n  M[d] = 0;\n  while(!q.empty()){\n    dice p = q.front(); q.pop();\n    //    p.view();\n    //cout << M[p] << endl;\n    bool f1 = false,f2 = false;\n    for(int i=0;i<3;i++){\n      //  cout << p[FRONT].fie[i][2] << \" \"<< p[BACK].fie[i][2] << endl;\n      if( p[FRONT].fie[i][2] == '*' ) f1 = true;\n      if( p[BACK].fie[i][2] == '*' ) f2 = true;\n    }\n    // cout << f1 << \" \"<< f2 << \" \"<< M[p] << endl;\n    if( f1 && f2 ){\n      //      p.view();\n      return M[p];\n    }\n    dice tmp = p;\n    tmp.roll_x();\n    if( M.count(tmp) == 0 ) {\n      q.push( tmp );\n      //  tmp.view();\n      //  cout << M[p]+1 << endl;\n      M[tmp] = M[p] + 1;\n    }\n    tmp.roll_x();tmp.roll_x();\n    if( M.count(tmp) == 0 ) {\n      q.push( tmp );\n      M[tmp] = M[p] + 1;\n    }\n    \n    tmp = p;\n    tmp.roll_y();\n    if( M.count(tmp) == 0 ) {\n      q.push( tmp );\n      M[tmp] = M[p] + 1;\n    }\n    tmp.roll_y();    tmp.roll_y();\n    if( M.count(tmp) == 0 ) {\n      q.push( tmp );\n      M[tmp] = M[p] + 1;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  try {\n    while(1){\n      d = dice();\n      for(int i=0;i<6;i++){\n        for(int j=0;j<3;j++){\n          for(int k=0;k<3;k++){\n          cin >> d.var[i].fie[k][j];\n          if( d.var[i].fie[k][j] == '#' ) throw 0;\n          }\n        }      \n      }    \n      cout << solve() << endl;\n    }\n    \n  } catch(...){};\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define INF 0x3f3f3f3f\n\nstruct map{\n\tchar a[3][4];\n\tvoid show(){ for(int i = 0 ; i < 3; i++) puts(a[i]); }\n};\nstruct dice{\n\tmap m[7];\n\tvoid show(){ puts(\"----------------------\"); for(int i = 1; i <= 6; i++) m[i].show(); }\n}D;\n\nbool check1(int p,int q){\n\tfor(int j = 0; j < 3; j++)\n\t\tif(D.m[p].a[0][j] == D.m[q].a[0][j] && D.m[p].a[0][j] == '*')\n\t\t\treturn true;\n\treturn false;\n}\nbool check2(int p,int q){\n\tfor(int i = 0; i < 3; i++)\n\t\tif(D.m[p].a[i][2] == D.m[q].a[i][2] && D.m[p].a[i][2] == '*')\n\t\t\treturn true;\n\treturn false;\n}\nbool check3(int p,int q){\n\tfor(int j = 0; j < 3; j++)\n\t\tif(D.m[p].a[2][j] == D.m[q].a[2][j] && D.m[p].a[2][j] == '*')\n\t\t\treturn true;\n\treturn false;\n}\nbool check4(int p,int q){\n\tfor(int i = 0; i < 3; i++)\n\t\tif(D.m[p].a[i][0] == D.m[q].a[i][0] && D.m[p].a[i][0] == '*')\n\t\t\treturn true;\n\treturn false;\n}\n\nint func131(){ return check1(1,3) ? 2 : INF; }\nint func132(){ return check2(1,3) ? 1 : INF; }\nint func133(){ return check3(1,3) ? 0 : INF; }\nint func134(){ return check4(1,3) ? 1 : INF; }\n\nint func241(){ return check1(2,4) ? 3 : INF; }\nint func242(){ return check2(2,4) ? 2 : INF; }\nint func243(){ return check3(2,4) ? 3 : INF; }\nint func244(){ return check4(2,4) ? 2 : INF; }\n\nint func561(){ return check1(5,6) ? 3 : INF; }\nint func562(){ return check2(5,6) ? 2 : INF; }\nint func563(){ return check3(5,6) ? 1 : INF; }\nint func564(){ return check4(5,6) ? 2 : INF; }\n\nint solve(){\n\tint ans = INF;\n\tans = min(func131(),ans);\n\tans = min(func132(),ans);\n\tans = min(func133(),ans);\n\tans = min(func134(),ans);\n\n\tans = min(func241(),ans);\n\tans = min(func242(),ans);\n\tans = min(func243(),ans);\n\tans = min(func244(),ans);\n\n\tans = min(func561(),ans);\n\tans = min(func562(),ans);\n\tans = min(func563(),ans);\n\tans = min(func564(),ans);\n\n\treturn ans;\n}\n\nint main(){\n\tchar str[5];\n\twhile(scanf(\"%s\",str)!=EOF){\n\t\tif(!strcmp(str,\"#\")) break;\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tD.m[1].a[0][i] = str[i];\n\t\tD.m[1].a[0][3] = '\\0';\n\t\tfor(int ith = 1; ith < 18; ith++){\n\t\t\tint idm = ith / 3 + 1;\n\t\t\tint idr = ith % 3;\n\t\t\tscanf(\"%s\",str);\n\t\t\tfor(int i = 0; i < 3; i++)\n\t\t\t\tD.m[idm].a[idr][i] = str[i];\n\t\t\tD.m[idm].a[idr][3] = '\\0';\n\t\t}\n\n\t\t//m[3]\n\t\t//for(int i = 0; i < 3; i++) swap(D.m[3].a[i][0] , D.m[3].a[i][2]);\n\t\t//m[4]\n\t\t//for(int i = 0; i < 3; i++) swap(D.m[3].a[i][0] , D.m[3].a[i][2]);\n\t\t//m[6]\n\t\t//for(int j = 0; j < 3; j++) swap(D.m[6].a[0][j] , D.m[6].a[2][j]);\n\n\t\t//D.show();\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  int r=3,c=3;\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,c)rep(j,r)m[i][j]=buf[j][c-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_f(){\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_b(){\n    rep(i,3)rotate_f();\n  }\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n    upsideDown(m[d[RI]]);\n    upsideDown(m[d[BO]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    if ((m[d[FR]][2][0] =='*' || \n\tm[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n      &&\n      (m[d[BA]][0][0] =='*' || \n       m[d[BA]][0][1] =='*' || \t\n       m[d[BA]][0][2] =='*' ))return true;\n    return false;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n\tif (i == RI || i == LE){\n\t  rep(k,3)rotate_ccw(ini.m[i]);\n\t}else if (i == BA || i == BO){\n\t  upsideDown(ini.m[i]);\n\t}\n      }\n    }\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int INF = 393939;\n\nusing pi = pair<int,int>;\n\nconst int ura[7]={0,3,4,1,2,6,5};\n\nstruct Dice{\n    int F,R,BK,L,T,BT;\n    Dice(){}\n    Dice(int f, int t, int r){\n        F = f;\n        T = t;\n        R = r;\n        BK = ura[f];\n        BT = ura[t];\n        L = ura[r];\n    }\n\n    void rot(int dir){\n        if(dir==0){\n            // 前\n            int tmp = F;\n            F = T;\n            T = BK;\n            BK = BT;\n            BT = tmp;\n        }\n        else if(dir==1){\n            // 後ろ\n            int tmp = F;\n            F = BT;\n            BT = BK;\n            BK = T;\n            T = tmp;\n        }\n        else if(dir==2){\n            // 左\n            int tmp = T;\n            T = R;\n            R = BT;\n            BT = L;\n            L = tmp;\n        }\n        else{\n            // 右\n            int tmp = T;\n            T = L;\n            L = BT;\n            BT = R;\n            R = tmp;\n        }\n    }\n};\n\nvector<string> rotate_ccw(const vector<string> &v){\n    vector<string> ret(3,string(3,' '));\n    rep(i,3)rep(j,3) ret[2-j][i] = v[i][j];\n    return ret;\n}\n\nvector<string> rotate_cw(const vector<string> &v){\n    vector<string> ret(v);\n    rep(i,3) ret = rotate_ccw(ret);\n    return ret;\n}\n\nint d[7][4]={\n    {0,0,0,0},\n    {5,2,6,4},\n    {5,3,6,1},\n    {5,4,6,2},\n    {5,1,6,3},\n    {3,2,1,4},\n    {1,2,3,4}\n};\n\nint main(){\n    string s;\n    while(cin >>s,(s!=\"#\")){\n        vector<vector<string>> surface(7,vector<string>(3));\n        for(int i=1; i<=6; ++i){\n            rep(j,3){\n                if(i==1 && j==0){\n                    surface[i][j] = s;\n                    continue;\n                }\n                cin >>surface[i][j];\n            }\n        }\n\n        auto check = [&](int f, int t){\n            vector<string> front = surface[f], back = surface[ura[f]];\n            if(f==5 || f==6){\n                rep(_,2) back = rotate_ccw(back);\n            }\n\n            rep(i,4){\n                if(d[f][i] == t) break;\n                front = rotate_ccw(front);\n                back = rotate_cw(back);\n            }\n\n\n            int fv=0, bv=0;\n            rep(i,3){\n                fv |= (front[2][i]=='*');\n                bv |= (back[2][i]=='*');\n            }\n            return fv&bv;\n        };\n\n        int ans = INF;\n\n        vector<vector<int>> dp(7,vector<int>(7,INF));\n        queue<pi> que;\n        dp[1][5] = 0;\n        que.push({1,5});\n        while(!que.empty()){\n            pi now = que.front();\n            que.pop();\n\n            int f=now.fi, t=now.se;\n            // dbg(now);\n            // dbg(dp[f][t]);\n            if(check(f,t)){\n                ans = dp[f][t];\n                break;\n            }\n\n            int r = 0;\n            rep(i,4){\n                if(d[f][i]==t){\n                    r = d[f][(i+1)%4];\n                    break;\n                }\n            }\n            assert(r>0);\n\n            rep(dir,4){\n                Dice dd(f,t,r);\n                dd.rot(dir);\n                if(dp[dd.F][dd.T] > dp[f][t]+1){\n                    dp[dd.F][dd.T] = dp[f][t]+1;\n                    que.push({dd.F,dd.T});\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// ??????????????¢??£\nenum FACE { FRONT,RIGHT,BACK,LEFT,TOP,BOTTOM };\n\n\nstruct state{\n  char fie[3][3];\n  bool operator!=(const state& a) const {\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        if( fie[j][i] != a.fie[j][i] ) return true;\n    return false; \n  }\n  bool operator==(const state& a) const {\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        if( fie[j][i] != a.fie[j][i] ) return false;\n    return true; \n  }\n  bool operator<(const state& a) const {\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n        if( fie[j][i] > a.fie[j][i] ) return false;\n        if( fie[j][i] < a.fie[j][i] ) return true;\n      }\n    }\n    return false; \n  }\n  void rev(){\n    char bf[3][3];\n    for(int i=2,k=0;i>=0;i--,k++)\n      for(int j=0,l=2;j<3;j++,l--)\n        bf[j][i] = fie[l][k];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        fie[j][i] = bf[j][i];\n  }\n  void rot(){\n    char bf[3][3];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        bf[j][i] = fie[i][2-j];\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        fie[j][i] = bf[j][i];    \n  }\n  void view(){\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++)\n        cout << fie[j][i];\n      cout << endl;\n    }\n  }\n};\n\nstruct dice{\npublic:\n  dice(){\n    id[0] = FRONT;\n    id[1] = RIGHT;\n    id[2] = BACK;\n    id[3] = LEFT;\n    id[4] = TOP;\n    id[5] = BOTTOM;\n  }\n  \n  state& operator[] (FACE f){return var[id[f]];}\n  const state& operator[] (FACE f)const {return var[id[f]];}\n\n  bool operator==(const dice &a)const {\n    const dice &b = *this;\n    for(int i=0;i<6;i++){\n      if(a[(FACE)i] != b[(FACE)i]) return false;\n    }\n    return true;\n  }\n  bool operator<(const dice &a) const {\n    const dice &b = *this;\n    for(int i=0;i<6;i++){\n      if( b[(FACE)i] < a[(FACE)i] ) return true;\n      if( b[(FACE)i] == a[(FACE)i] ) continue;\n      return false;\n    }\n    return false;\n  }\n\n  void roll_x(){\n    roll(TOP,BACK,BOTTOM,FRONT);\n    var[BACK].rev(); var[BOTTOM].rev();\n    var[LEFT].rot(); var[RIGHT].rot();\n  } // X?????????????????¢ (FRONT -> BOTTOM)\n  void roll_y(){\n    roll(TOP,LEFT,BOTTOM,RIGHT);\n    var[BACK].rot(); var[FRONT].rot();\n  } // Y?????????????????¢ (TOP -> RIGHT)\n  void roll_z(){roll(FRONT,RIGHT,BACK,LEFT);} // Z?????????????????¢ (FRONT -> LEFT)\n\n  // ??¨?????????24?????????????????¢\n  vector<dice> all_rolls(){\n    vector<dice> res;\n    for(int k=0; k<6; (k&1 ? roll_y() : roll_x()), k++){\n      for(int i=0; i<4; roll_z(),i++){\n        res.push_back(*this);\n      }\n    }\n    return res;\n  }\n\n  // ???????????????????????????equal\n  bool equivalent_to(const dice &di){\n    for(int k=0; k<6; (k&1 ? roll_y() : roll_x()), k++){\n      for(int i=0; i<4; roll_z(),i++){\n        if(*this == di)return true;\n      }\n    }\n    return false;\n  }\n\n  state var[6]; // ????????????????¨???¶\n  int id[6]; // ?????¢????¨???¶\n  void roll(FACE a,FACE b,FACE c,FACE d){//a b c d ???b c d a\n    int tmp = id[a];\n    id[a] = id[b];\n    id[b] = id[c];\n    id[c] = id[d];\n    id[d] = tmp;\n  }\n\n  void view(){\n    for(int i=0;i<6;i++){\n      var[id[i]].view();\n      cout << endl;\n    }\n  }\n};\n\ndice d;\nmap<dice,int> M;\nint solve(){\n  queue<dice> q;\n  M.clear();\n  q.push( d );\n  M[d] = 0;\n  while(!q.empty()){\n    dice p = q.front(); q.pop();\n    // p.view();\n    bool f1 = false,f2 = false;\n    for(int i=0;i<3;i++){\n      //xcout << p[FRONT].fie[i][2] << \" \"<< p[BACK].fie[i][2] << endl;\n      if( p[FRONT].fie[i][2] == '*' ) f1 = true;\n      if( p[BACK].fie[i][2] == '*' ) f2 = true;\n    }\n    //  cout << f1 << \" \"<< f2 << \" \"<< M[p] << endl;\n    if( f1 && f2 ){\n      //p.view();\n      return M[p];\n    }\n    dice tmp = p;\n    tmp.roll_x();\n    if( M.count(tmp) == 0 ) {\n      q.push( tmp );\n      M[tmp] = M[p] + 1;\n    }\n    tmp.roll_x();tmp.roll_x();\n    if( M.count(tmp) == 0 ) {\n      q.push( tmp );\n      M[tmp] = M[p] + 1;\n    }\n    \n    tmp = p;\n    tmp.roll_y();\n    if( M.count(tmp) == 0 ) {\n      q.push( tmp );\n      M[tmp] = M[p] + 1;\n    }\n    tmp.roll_y();    tmp.roll_y();\n    if( M.count(tmp) == 0 ){\n      q.push( tmp );\n      M[tmp] = M[p] + 1;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  try {\n    while(1){\n      d = dice();\n      for(int i=0;i<6;i++){\n        for(int j=0;j<3;j++){\n          for(int k=0;k<3;k++){\n          cin >> d.var[i].fie[k][j];\n          if( d.var[i].fie[k][j] == '#' ) throw 0;\n          }\n        }      \n      }    \n      cout << solve() << endl;\n    }\n    \n  } catch(...){};\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define MAXN 3\n#define MAXM 120000\n#define FI first\n#define SE second\nconst int INF =1000000007;\nchar dice[6][MAXN][MAXN],tdice[6][MAXN][MAXN];\nint ans=0,now[6];\nbool vi[MAXM];\nvoid no(int h,int ori)\n{\n    memcpy(dice[h],tdice[ori],sizeof(tdice[ori]));\n}\nvoid rl(int h,int ori)\n{\n    for(int i=0;i<3;++i)\n        for(int j=0;j<3;++j)\n            dice[h][2-j][i]=tdice[ori][i][j];\n}\nvoid rr(int h,int ori)\n{\n    for(int i=0;i<3;++i)\n        for(int j=0;j<3;++j)\n            dice[h][j][2-i]=tdice[ori][i][j];\n}\nvoid rev(int h)\n{\n    for(int i=0;i<3;++i)\n        swap(dice[h][i][0],dice[h][i][2]);\n}\nvoid (*fun[4][6])(int ,int )={{no,rl,no,rr,no,no},{rr,rr,rl,rr,rr,rr},{no,rr,no,rl,no,no},\n                                {rl,rl,rr,rl,rl,rl}};\nint from[4][6]={{4,1,5,3,2,0},{0,4,2,5,3,1},{5,1,4,3,0,2},{0,5,2,4,1,3}};\nbool check()\n{\n    int t=0;\n    for(int i=0;i<6;++i)    t=t*6+now[i];\n    if(vi[t]) return    false;\n    return vi[t]=true;\n}\nvoid dfs(int dep)\n{\n    if(dep>=ans)    return ;\n    bool flag=false;\n    for(int i=0;i<3;++i)\n        flag|=dice[0][2][i]=='*'||dice[2][0][i]=='*';\n    if(flag)\n    {\n        ans=min(ans,dep);\n        return ;\n    }\n    if(!check())    return ;\n    char tmp[6][MAXN][MAXN];\n    int tnow[6];\n    memcpy(tmp,dice,sizeof(dice));\n    memcpy(tnow,now,sizeof(now));\n    for(int i=0;i<4;++i)\n    {\n        memcpy(tdice,tmp,sizeof(dice));\n        for(int j=0;j<6;++j)\n            fun[i][j](j,from[i][j]),now[j]=tnow[from[i][j]];\n        dfs(dep+1);\n    }\n}\nint main()\n{\n    //freopen(\"J:\\\\Mydocument\\\\Code\\\\input.txt\",\"r\",stdin);\n    char tmp[4];\n    while(scanf(\"%s\",tmp)&&tmp[0]!='#')\n    {\n        memset(vi,0,sizeof(vi));\n        for(int i=0;i<3;++i)    dice[0][0][i]=tmp[i];\n        for(int i=1;i<3;++i)\n        {\n            scanf(\"%s\",tmp);\n            for(int j=0;j<3;++j)    dice[0][i][j]=tmp[j];\n        }\n        for(int i=1;i<6;++i)\n            for(int j=0;j<3;++j)\n            {\n                scanf(\"%s\",tmp);\n                for(int k=0;k<3;++k)    dice[i][j][k]=tmp[k];\n            }\n        memcpy(tdice[2],dice[2],sizeof(dice[2]));\n        for(int i=0;i<3;++i)    swap(dice[2][0][i],dice[2][2][i]);\n        rev(2);\n        ans=INF;\n        for(int i=0;i<6;++i)    now[i]=i;\n        dfs(0);\n        while(ans==INF);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid turnccw(int n, vector<char> &a){\n\tfor(int i=0; i<2*n; i++){\n\t\tswap(a[0], a[1]);\n\t\tswap(a[1], a[2]);\n\t\tswap(a[2], a[5]);\n\t\tswap(a[5], a[8]);\n\t\tswap(a[8], a[7]);\n\t\tswap(a[7], a[6]);\n\t\tswap(a[6], a[3]);\n\t}\n}\nvoid moveleft(vector<vector<char> > &a){\n\tswap(a[4], a[1]);\n\tswap(a[1], a[5]);\n\tswap(a[5], a[3]);\n\tturnccw(1, a[0]);\n\tturnccw(3, a[2]);\n\tturnccw(1, a[4]);\n\tturnccw(1, a[1]);\n\tturnccw(1, a[5]);\n\tturnccw(1, a[3]);\n}\nvoid moveright(vector<vector<char> > &a){\n\tfor(int i=0; i<3; i++) moveleft(a);\n}\nvoid movefront(vector<vector<char> > &a){\n\tswap(a[0], a[4]);\n\tswap(a[4], a[2]);\n\tswap(a[2], a[5]);\n\tturnccw(1, a[1]);\n\tturnccw(3, a[3]);\n\tturnccw(2, a[4]);\n\tturnccw(2, a[2]);\n}\nvoid moveback(vector<vector<char> > &a){\n\tfor(int i=0; i<3; i++) movefront(a);\n}\n\nvector<vector<char> > move(int dir, vector<vector<char> > &a){\n\tvector<vector<char> > ret = a;\n\tif(dir==0) moveleft(ret);\n\tif(dir==1) moveright(ret);\n\tif(dir==2) movefront(ret);\n\tif(dir==3) moveback(ret);\n\treturn ret;\n}\n\nint solve(int step, vector<vector<char> > a){\n\tif((a[0][6]=='*' || a[0][7]=='*' || a[0][8]=='*') && (a[2][6]=='*' || a[2][7]=='*' || a[2][8]=='*')){\n\t\treturn step;\n\t}\n\tif(step == 2) return 3;\n\tint ret = 3;\n\tfor(int i=0; i<4; i++){\n\t\tret = min(ret, solve(step+1, move(i, a)));\n\t}\n\treturn ret;\n}\n\nint main(){\n\tvector<vector<char> > a(6, vector<char>(9));\n\twhile(1){\n\t\tcin >> a[0][0];\n\t\tif(a[0][0]=='#') break;\n\t\t\n\t\tfor(int i=0; i<6; i++){\n\t\t\tfor(int j=(i==0)?1:0; j<9; j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve(0, a) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstring rR(string s) {\n  swap(s[0],s[2]);\n  swap(s[0],s[6]);\n  swap(s[6],s[8]);\n  swap(s[1],s[5]);\n  swap(s[1],s[3]);\n  swap(s[3],s[7]);\n  return s;\n}\nstring rL(string s) {\n  swap(s[0],s[2]);\n  swap(s[2],s[8]);\n  swap(s[6],s[8]);\n  swap(s[1],s[5]);\n  swap(s[5],s[7]);\n  swap(s[3],s[7]);\n  return s;\n}\n \nvector<string> U(vector<string> s) {\n  swap(s[0],s[4]);\n  swap(s[0],s[5]);\n  swap(s[2],s[5]);\n  for(int i=0; i<4; i++) swap(s[2][i],s[2][8-i]);\n  for(int i=0; i<4; i++) swap(s[5][i],s[5][8-i]);\n  s[1]=rR(s[1]);\n  s[3]=rL(s[3]);\n  return s;\n}\nvector<string> D(vector<string> s) {\n  swap(s[0],s[5]);\n  swap(s[0],s[4]);\n  swap(s[2],s[4]);\n  for(int i=0; i<4; i++) swap(s[2][i],s[2][8-i]);\n  for(int i=0; i<4; i++) swap(s[4][i],s[4][8-i]);\n  s[1]=rL(s[1]);\n  s[3]=rR(s[3]);\n  return s;\n}\nvector<string> R(vector<string> s) {\n  swap(s[1],s[4]);\n  swap(s[3],s[4]);\n  swap(s[3],s[5]);\n  s[0]=rR(s[0]);\n  s[1]=rR(s[1]);\n  s[2]=rL(s[2]);\n  s[3]=rR(s[3]);\n  s[4]=rR(s[4]);\n  s[5]=rR(s[5]);\n  return s;\n}\nvector<string> L(vector<string> s) {\n  swap(s[1],s[5]);\n  swap(s[3],s[5]);\n  swap(s[3],s[4]);\n  s[0]=rL(s[0]);\n  s[1]=rL(s[1]);\n  s[2]=rR(s[2]);\n  s[3]=rL(s[3]);\n  s[4]=rL(s[4]);\n  s[5]=rL(s[5]);\n  return s;\n}\n \n \nint main() {\n  string t;\n  while(cin >> t&&t!=\"#\") {\n    vector<string> s;\n    map<vector<string>, int> m;\n    string r=t;\n    for(int j=1; j<3; j++) {\n      cin >> t;\n      r+=t;\n    }\n    s.push_back(r);\n    for(int i=1; i<6; i++) {\n      r=\"\";\n      for(int j=0; j<3; j++) {\n        cin >> t;\n        r+=t;\n      }\n      s.push_back(r);\n    }\n    m[s]=0;\n    queue<vector<string> > que;\n    que.push(s);\n    while(!que.empty()) {\n      s=que.front();que.pop();\n      bool f1=0,f2=0;\n      for(int i=0; i<3; i++) {\n        if(s[0][i+6]=='*') f1|=1;\n        if(s[2][i+6]=='*') f2|=1;\n      }\n      int c=m[s];\n      if(f1&&f2) {\n        cout << c << endl;\n        break;\n      }\n      vector<string> t=U(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n      t=D(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n      t=R(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n      t=L(s);\n      if(!m.count(t)) {\n        m[t]=c+1;\n        que.push(t);\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct face{\n  string c[3];\n  face(){}\n  face(string s[3]){\n    for(int i=0;i<3;i++) c[i]=s[i];\n  }\n};\nstruct dice{\n  face f[6];\n  int d;\n  dice(){}\n  dice(string s[6][3]){\n    d=0;\n    for(int i=0;i<6;i++)\n      f[i]=face(s[i]);\n  }\n};\n\nbool check(dice d){\n  bool res=1,f;\n  f=0;\n  for(int i=0;i<3;i++) f|=d.f[0].c[2][i]=='*';\n  res&=f;\n  f=0;\n  for(int i=0;i<3;i++) f|=d.f[2].c[2][i]=='*';\n  res&=f;\n  return res;\n}\nface sr(face f){\n  face p=f;\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      p.c[i][j]=f.c[2-j][i];\n  return p;\n}\nface sl(face f){\n  face p=f;\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      p.c[i][j]=f.c[j][2-i];\n  return p;\n}\nface re(face f){\n  face p=sr(f);\n  /*\n  for(int i=0;i<3;i++)\n    p.c[i]=f.c[2-i];\n  */\n  return sr(p);\n}\ndice rotate1(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=d.f[5];\n  b.f[1]=sr(d.f[1]);\n  b.f[2]=re(d.f[4]);\n  b.f[3]=sl(d.f[3]);\n  b.f[4]=d.f[0];\n  b.f[5]=re(d.f[2]);\n  return b;\n}\ndice rotate2(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=d.f[4];\n  b.f[1]=sl(d.f[1]);\n  b.f[2]=re(d.f[5]);\n  b.f[3]=sr(d.f[3]);\n  b.f[4]=re(d.f[2]);\n  b.f[5]=d.f[0];\n  return b;\n}\ndice rotate3(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=sl(d.f[0]);\n  b.f[1]=sl(d.f[5]);\n  b.f[2]=sr(d.f[2]);\n  b.f[3]=sl(d.f[4]);\n  b.f[4]=sl(d.f[1]);\n  b.f[5]=sl(d.f[3]);\n  return b;\n}\ndice rotate4(dice d){\n  dice b=d;\n  b.d++;\n  b.f[0]=sr(d.f[0]);\n  b.f[1]=sr(d.f[4]);\n  b.f[2]=sl(d.f[2]);\n  b.f[3]=sr(d.f[5]);\n  b.f[4]=sr(d.f[3]);\n  b.f[5]=sr(d.f[1]);\n  return b;\n}\nsigned main(){\n  string tmp;\n  while(cin>>tmp,tmp!=\"#\"){\n    string s[6][3];\n    s[0][0]=tmp;\n    for(int i=0;i<6;i++){\n      for(int j=0;j<3;j++){\n\tif((i||j)==0) continue;\n\tcin>>s[i][j];\n      }\n    }\n    dice d(s);\n    queue<dice> q;\n    q.push(d);\n    int ans=-1;\n    while(!q.empty()){\n      d=q.front();q.pop();\n      if(check(d)){\n\tans=d.d;\n\tbreak;\n      }\n      //if(d.d>1) break;\n      /*//\n      cout<<d.d<<endl;\n      for(int i=0;i<6;i++){\n\tfor(int j=0;j<3;j++) cout<<d.f[i].c[j]<<endl;\n\tcout<<endl;\n      }\n      //*/\n      q.push(rotate1(d));\n      q.push(rotate2(d));\n      q.push(rotate3(d));\n      q.push(rotate4(d));\n    }\n    assert(~ans);\n    cout<<ans<<endl;\n  }\n  assert(tmp==\"#\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<array>\nusing namespace std;\narray<string,6>s;\nbool check(string s)\n{\n\treturn s[6]=='*'||s[7]=='*'||s[8]=='*';\n}\nstring rotate(string s,int dir)\n{\n\tstring ret=\"\";\n\tif(dir==0)ret=s;\n\telse if(dir==1)\n\t{\n\t\tret+=s[6];\n\t\tret+=s[3];\n\t\tret+=s[0];\n\t\tret+=s[7];\n\t\tret+=s[4];\n\t\tret+=s[1];\n\t\tret+=s[8];\n\t\tret+=s[5];\n\t\tret+=s[2];\n\t}\n\telse if(dir==2)\n\t{\n\t\tfor(int i=9;i--;)ret+=s[i];\n\t}\n\telse if(dir==3)\n\t{\n\t\tret+=s[2];\n\t\tret+=s[5];\n\t\tret+=s[8];\n\t\tret+=s[1];\n\t\tret+=s[4];\n\t\tret+=s[7];\n\t\tret+=s[0];\n\t\tret+=s[3];\n\t\tret+=s[6];\n\t}\n\treturn ret;\n}\nmain()\n{\n\tstring input;\n\twhile(cin>>input,input!=\"#\")\n\t{\n\t\tstring input2,input3;\n\t\tcin>>input2>>input3;\n\t\ts[0]=input+input2+input3;\n\t\tfor(int i=1;i<6;i++)\n\t\t{\n\t\t\tcin>>input>>input2>>input3;\n\t\t\ts[i]=input+input2+input3;\n\t\t}\n\t\tmap<array<string,6>,int>M;\n\t\tM[s]=0;\n\t\tqueue<array<string,6> >P;\n\t\tP.push(s);\n\t\twhile(true)\n\t\t{\n\t\t\tarray<string,6>t=P.front();P.pop();\n\t\t\tint now=M[t];\n\t\t\tif(check(t[0])&&check(t[2]))\n\t\t\t{\n\t\t\t\tcout<<now<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t{\n\t\t\t\tarray<string,6>nxt;\n\t\t\t\tnxt[0]=rotate(t[5],0);\n\t\t\t\tnxt[1]=rotate(t[1],1);\n\t\t\t\tnxt[2]=rotate(t[4],2);\n\t\t\t\tnxt[3]=rotate(t[3],3);\n\t\t\t\tnxt[4]=rotate(t[0],0);\n\t\t\t\tnxt[5]=rotate(t[2],2);\n\t\t\t\tif(M.find(nxt)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[nxt]=now+1;\n\t\t\t\t\tP.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tarray<string,6>nxt;\n\t\t\t\tnxt[0]=rotate(t[4],0);\n\t\t\t\tnxt[1]=rotate(t[1],3);\n\t\t\t\tnxt[2]=rotate(t[5],2);\n\t\t\t\tnxt[3]=rotate(t[3],1);\n\t\t\t\tnxt[4]=rotate(t[2],2);\n\t\t\t\tnxt[5]=rotate(t[0],0);\n\t\t\t\tif(M.find(nxt)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[nxt]=now+1;\n\t\t\t\t\tP.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tarray<string,6>nxt;\n\t\t\t\tnxt[0]=rotate(t[0],1);\n\t\t\t\tnxt[1]=rotate(t[4],1);\n\t\t\t\tnxt[2]=rotate(t[2],3);\n\t\t\t\tnxt[3]=rotate(t[5],1);\n\t\t\t\tnxt[4]=rotate(t[3],1);\n\t\t\t\tnxt[5]=rotate(t[1],1);\n\t\t\t\tif(M.find(nxt)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[nxt]=now+1;\n\t\t\t\t\tP.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tarray<string,6>nxt;\n\t\t\t\tnxt[0]=rotate(t[0],3);\n\t\t\t\tnxt[1]=rotate(t[5],3);\n\t\t\t\tnxt[2]=rotate(t[2],1);\n\t\t\t\tnxt[3]=rotate(t[4],3);\n\t\t\t\tnxt[4]=rotate(t[1],3);\n\t\t\t\tnxt[5]=rotate(t[3],3);\n\t\t\t\tif(M.find(nxt)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[nxt]=now+1;\n\t\t\t\t\tP.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「\nint rotateRight[]={0,1,3,5,2,4,6};\n// zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツキツヲテ・ツ崢榲ィツサツ「\nint rotateLeft[]={0,1,4,2,5,3,6};\n// テ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツ?ヲテ」ツδ榲」ツδε」ツδ?」ツ?凖」ツつ鞠aceテ」ツつ津ヲツ篠「テ」ツ??\n// curFaceテ」ツ?ォテァツオツ静ヲツ楪愿」ツつ津、ツサツ」テ・ツ?・\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // テ」ツ?禿」ツ?禿」ツ?ァテ・ツ按、テ・ツョツ?\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // テ・ツキツヲテ」ツ?クテ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツつ津・ツ?津」ツ??\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // テ・ツ可催」ツ?クテ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツつ津・ツ?津」ツ??\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // テ」ツ?禿」ツ?禿」ツ?ァテ・ツ按、テ・ツョツ?\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)nfield[l][2-k]=field[i-1][j][k][l];\n        // fieldテ」ツつ津・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)field[i][j][k][l]=nfield[l][k];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      int cnt2=0;\n      if(label[front]>=1&&label[front]<=4){\n        if(ang==0||ang==3){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n      }\n      else{\n        for(int j=0;j<3;j++)cnt1+=(field[(ang+2)%4][label[front]][2][j]=='*');\n        for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n      }\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // テゥツ敖「テ」ツつ津・ツ崢崚ヲツ鳴ケテ・ツ青妥」ツ?ォテ・ツ崢榲ィツサツ「\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // テ・ツ可?\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // テ・ツセツ古」ツつ?\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<string> >v;\n\n\nclass Cube{\npublic:\n  char field[6][3][3];\n  int cnt;\n  void insert(int from, int to, Cube &tmp){\n    for(int i=0; i<3; i++)\n      for(int j=0; j<3; j++) field[to][i][j] = tmp.field[from][i][j];\n  }\n\n  void copy(Cube &tmp){\n    for(int k=0; k<6; k++)\n      for(int i=0; i<3; i++)\n\tfor(int j=0; j<3; j++) tmp.field[k][i][j] = field[k][i][j];\n  }\n  \n  void rotate90(int num){\n    char field2[3][3];\n\n    for(int i=0; i<3; i++){\n      for(int j=0; j<3; j++){\n\tfield2[i][j] = field[num][3-j-1][i];\n      }\n    }\n\n    for(int i=0; i<3; i++)\n      for(int j=0; j<3; j++) field[num][i][j] = field2[i][j];\n\n  }\n  void front(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(1);\n    for(int i=0; i<3; i++) rotate90(3);\n\n    //top -> front\n    insert(4,0,tmp);\n    //    for(int i=0; i<2; i++) rotate90(0);\n\n    //front->bottom\n    insert(0,5,tmp);\n    //    for(int i=0; i<2; i++) rotate90(5);\n\n    //bottom->back\n    insert(5,2,tmp);\n    //    for(int i=0; i<2; i++) rotate90(2);\n\n    //back->top\n    insert(2,4,tmp);\n    //    for(int i=0; i<2; i++) rotate90(2);\n  }\n\n  void back(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(3);\n    for(int i=0; i<3; i++) rotate90(1);\n\n    //top->back\n    insert(4,2,tmp);\n\n    //back->bottom\n    insert(2,5,tmp);\n\n    //bottom->front\n    insert(5,0,tmp);\n\n    //front->top\n    insert(0,4,tmp);\n\n  }\n\n  void left(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(0);\n    for(int i=0; i<3; i++) rotate90(2);\n\n    //top->left\n    insert(4,3,tmp);\n\n    //left->bottom\n    insert(3,5,tmp);\n\n    //bottom->right\n    insert(5,1,tmp);\n\n    //right->top\n    insert(1,4,tmp);\n\n  }\n\n  void right(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(2);\n    for(int i=0; i<3; i++) rotate90(0);\n\n\n    //top->right\n    insert(4,1,tmp);\n\n    //right->bottom\n    insert(1,5,tmp);\n\n    //bottom->left\n    insert(5,3,tmp);\n\n    //left->top\n    insert(3,4,tmp);\n  }\n\n};\n\nbool check(Cube a){\n  bool front = false;\n  bool back = false;\n\n  for(int i=0; i<3; i++)\n    if(a.field[0][2][i] == '*') front = true;\n\n  for(int i=0; i<3; i++)\n    if(a.field[2][2][i] == '*') back = true;\n\n  return front && back;\n\n}\n\n\nint bfs(Cube a){\n  queue<Cube>que;\n  que.push(a);\n\n  while(!que.empty()){\n    Cube tmp = que.front();\n    que.pop();\n\n    if(check(tmp)) return a.cnt;\n\n    for(int i=0; i<4; i++){\n      Cube t = tmp;\n      if(i == 0) t.front();\n      if(i == 1) t.right();\n      if(i == 2) t.back();\n      if(i == 3) t.left();\n      t.cnt++;\n      que.push(t);\n    }\n  }\n}\n\nint main(){\n  string s;\n  int cnt = 0;\n  Cube c;\n\n  while(cin >> s){\n    if(s == \"#\")break;\n    c.cnt = 0;\n    for(int i=0; i<s.size(); i++)\n      c.field[cnt/3][cnt%3][i] = s[i];\n    cnt++;\n\n\n\n    if(cnt == 18){\n      cout << bfs(c) << endl;\n      cnt = 0;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,3)rep(j,3)m[i][j]=buf[j][3-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_b(){\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_f(){\n    rep(i,3)rotate_b();\n  }\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n    upsideDown(m[d[LE]]);\n    upsideDown(m[d[BO]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n\n    if ((m[d[FR]][2][0] =='*' || \n\t m[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n\t&&\n\t(m[d[BA]][0][0] =='*' || \n\t m[d[BA]][0][1] =='*' || \t\n\t m[d[BA]][0][2] =='*' ))return true;\n\n    //rep(i,3)if (m[d[FR]][2][i] == '*' && m[d[BA]][0][i] == '*')return true;\n    //rep(i,3)cout << (m[d[FR]][2][i]) <<\" \" << (m[d[BA]][0][i]) << endl;\n    return false;\n  }\n  void op(int a){\n    rep(i,3){\n      rep(j,3){\n\tcout << m[d[a]][i][j];\n      }\n      cout << endl;\n    }\n    cout <<\"Op end\" << endl;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n      }\n      if (i == RI || i == LE){\n\trep(k,3)rotate_ccw(ini.m[i]);\n      }else if (i == BA || i == BO){\n\tupsideDown(ini.m[i]);\n      }\n    }\n    /*\n    ini.rotate_l();\n    ini.op(TO);\n    ini.rotate_f();\n    ini.op(FR);\n    ini.op(BA);\n    */\n    //cout << ini.isok() << endl;\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  string s[6][3];\n  while(cin>>s[0][0],s[0][0]!=\"#\"){\n\n    for(int i=1;i<18;i++)cin>>s[i/3][i%3];\n\n    if((s[0][2][0]=='*'||s[0][2][1]=='*'||s[0][2][2]=='*')&&(s[2][2][0]=='*'||s[2][2][1]=='*'||s[2][2][2]=='*'))cout<<0<<endl;\n\n    else if((s[0][0][0]=='*'||s[0][1][0]=='*'||s[0][2][0]=='*')&&(s[2][0][2]=='*'||s[2][1][2]=='*'||s[2][2][2]=='*')||\n            (s[0][0][2]=='*'||s[0][1][2]=='*'||s[0][2][2]=='*')&&(s[2][0][0]=='*'||s[2][1][0]=='*'||s[2][2][0]=='*')||\n            (s[4][0][0]=='*'||s[4][0][1]=='*'||s[4][0][2]=='*')&&(s[5][2][0]=='*'||s[5][2][1]=='*'||s[5][2][2]=='*')||\n            (s[4][2][0]=='*'||s[4][2][1]=='*'||s[4][2][2]=='*')&&(s[5][0][0]=='*'||s[5][0][1]=='*'||s[5][0][2]=='*'))cout<<1<<endl;\n\n    else if(!((s[1][2][0]=='*'||s[1][2][1]=='*'||s[1][2][2]=='*')&&(s[3][2][0]=='*'||s[3][2][1]=='*'||s[3][2][2]=='*'))&&\n            !((s[1][0][0]=='*'||s[1][0][1]=='*'||s[1][0][2]=='*')&&(s[3][0][0]=='*'||s[3][0][1]=='*'||s[3][0][2]=='*')))cout<<2<<endl;\n\n    else cout<<3<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\nint a[6][3][3];\nvoid run()\n{\n    int mina=10,i,j;\n    if((a[0][2][0]|a[0][2][1]|a[0][2][2])&(a[2][2][2]|a[2][2][1]|a[2][2][0]))\n        mina=min(0,mina);\n    if((a[0][0][0]|a[0][1][0])&(a[2][0][2]|a[2][1][2]))\n        mina=min(1,mina);\n    if((a[0][0][2]|a[0][1][2])&(a[2][0][0]|a[2][1][0]))\n        mina=min(1,mina);\n    if((a[4][0][0]|a[4][0][1]|a[4][0][2])&(a[5][2][0]|a[5][2][1]|a[5][2][2]))\n        mina=min(1,mina);\n    if((a[4][2][0]|a[4][2][1]|a[4][2][2])&(a[5][0][0]|a[5][0][1]|a[5][0][2]))\n        mina=min(1,mina);\n\n    if((a[1][0][0]|a[1][1][0]|a[1][2][0])&(a[3][0][2]|a[3][1][2]|a[3][2][2]))\n        mina=min(2,mina);\n    if((a[1][0][2]|a[1][1][2]|a[1][2][2])&(a[3][0][0]|a[3][1][0]|a[3][2][0]))\n        mina=min(2,mina);\n\n    if(a[4][0][1]&a[5][2][1])\n        mina=min(mina,2);\n    if(a[4][2][1]&a[5][0][1])\n        mina=min(mina,2);\n\n    if(a[0][0][1]&a[2][0][1])\n        mina=min(mina,3);\n    if(a[1][0][1]&a[3][0][1])\n        mina=min(mina,3);\n    if(a[1][2][1]&a[3][2][1])\n        mina=min(mina,3);\n    cout<<mina<<endl;\n\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    char x;\n    int i,j,r;\n    while(x=getchar())\n    {\n        memset(a,0,sizeof(a));\n        if(x=='#')break;\n        for(i=0; i<6; i++)\n        {\n            for(j=0; j<3; j++)\n            {\n                for(r=0; r<3; r++)\n                {\n                    if(j||i||r)\n                        x=getchar();\n                    if(x=='*')\n                        a[i][j][r]=1;\n                }\n                x=getchar();\n            }\n        }\n        x=getchar();\n        run();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Dice {\n  int id[6], cnt, label[6];\n  const static int f[3][3];\n\n  Dice() { init(); }\n\n  void init() {\n    for(int i = 0; i < 6; ++i) {\n      id[i] = i;\n    }\n    cnt = 0;\n    label[0] = 1;\n    label[1] = 2;\n    label[2] = 5;\n    label[3] = 6;\n    label[4] = 4;\n    label[5] = 3;\n  }\n\n  void rotate(int type, int dir = 1) {\n    const int *v = f[type];\n    int a,b,c,t; a=v[0]; b=v[1]; c=v[2]; t=id[type];\n    if(dir < 0) swap(a,c);\n    id[type]=id[a]; id[a]=id[b]; id[b]=id[c]; id[c]=t;\n  }\n\n  bool next() {\n    ++cnt;\n    if(cnt == 24) {\n      rotate(0,-1);\n      rotate(1,-1);\n      cnt = 0;\n      return false;\n    }\n    if(cnt == 4*3) {\n      rotate(2,-1);\n      rotate(0,-1);\n    } else if(cnt%4 == 0) {\n      rotate(2);\n    } else {\n      rotate(0);\n    }\n    return true;\n  }\n\n  void roll(int dir) {\n    switch(dir) {\n      case 0: rotate(1,-1); break;\n      case 1: rotate(2, 1); break;\n      case 2: rotate(1, 1); break;\n      case 3: rotate(2,-1); break;\n    }\n  }\n\n  bool operator < (const Dice &d) const {\n    for(int i = 0; i < 3; ++i) {\n      if(id[i] != d.id[i]) return id[i] < d.id[i];\n    }\n    return false;\n  }\n\n  void show() {\n    cout << label[id[4]] << \" / \\\\ \"<< label[id[5]] << endl;\n    cout << \" /   \\\\\" << endl;\n    cout << \"|\\\\ \" << label[id[2]] << \" /|\" << endl;\n    cout << \"|\" << label[id[0]] << \"\\\\ /\" << label[id[1]] << \"|\" << endl;\n    cout << \" \\\\ | /\" << endl;\n    cout << \"  \\\\|/\" << endl;\n    cout << \"   \" << label[id[3]] << endl;\n  }\n\n  int getLabel(int faceNum) {\n    if(faceNum == 0) {\n      return label[id[0]];\n    } else if(faceNum == 1) {\n      return label[id[5]];\n    }\n    return -1;\n  }\n};\nconst int Dice::f[3][3] = {{4,5,1},{3,4,2},{5,3,0}};\n\n#include <vector>\n#include <map>\n#include <queue>\n\nconst int V = 24;\nconst int INF = 1<<28;\nvector<int> E[V];\nvector<pair<int, int> > ps;\nvector<pair<int, int> > A[4];\nvector<int> cost;\nmap<Dice, int> id;\nmap<int, Dice> rid;\n\nchar G[6][3][3];\n\nvoid bfs(int v) {\n  cost = vector<int>(V, INF);\n  cost[v] = 0;\n  queue<int> que;\n  que.push(v);\n  while(!que.empty()) {\n    v = que.front();\n    que.pop();\n    for(int i = 0; i < E[v].size(); ++i) {\n      int to = E[v][i];\n      if(cost[to] != INF) continue;\n      cost[to] = cost[v] + 1;\n      que.push(to);\n    }\n  }\n}\n\nvoid init() {\n  Dice d;\n  do {\n    id[d] = id.size()-1;\n    rid[id[d]] = d;\n  } while(d.next());\n\n  do {\n    for(int i = 0; i < 4; ++i) {\n      Dice t = d;\n      t.roll(i);\n      E[id[d]].push_back(id[t]);\n    }\n  } while(d.next());\n\n  A[0].push_back(make_pair(2,0));\n  A[0].push_back(make_pair(2,1));\n  A[0].push_back(make_pair(2,2));\n\n  A[1].push_back(make_pair(0,0));\n  A[1].push_back(make_pair(1,0));\n  A[1].push_back(make_pair(2,0));\n\n  A[2].push_back(make_pair(0,0));\n  A[2].push_back(make_pair(0,1));\n  A[2].push_back(make_pair(0,2));\n\n  A[3].push_back(make_pair(0,2));\n  A[3].push_back(make_pair(1,2));\n  A[3].push_back(make_pair(2,2));\n\n  ps.push_back(make_pair(0,0));\n  ps.push_back(make_pair(0,0));\n  ps.push_back(make_pair(0,0));\n  ps.push_back(make_pair(0,0));\n\n  ps.push_back(make_pair(3,3));\n  ps.push_back(make_pair(3,1));\n  ps.push_back(make_pair(3,3));\n  ps.push_back(make_pair(1,3));\n\n  ps.push_back(make_pair(1,3));\n  ps.push_back(make_pair(2,0));\n  ps.push_back(make_pair(3,1));\n  ps.push_back(make_pair(0,2));\n\n  ps.push_back(make_pair(2,2));\n  ps.push_back(make_pair(2,2));\n  ps.push_back(make_pair(2,2));\n  ps.push_back(make_pair(2,2));\n\n  ps.push_back(make_pair(2,0));\n  ps.push_back(make_pair(1,3));\n  ps.push_back(make_pair(0,2));\n  ps.push_back(make_pair(3,1));\n\n  ps.push_back(make_pair(3,1));\n  ps.push_back(make_pair(1,1));\n  ps.push_back(make_pair(1,3));\n  ps.push_back(make_pair(1,1));\n\n  bfs(0);\n}\n\nbool isValid(int d) {\n  {\n    int f = rid[d].getLabel(0) - 1;\n    vector<pair<int,int> > &a = A[ps[d].first];\n    int cnt = 0;\n    for(int i = 0; i < a.size(); ++i) {\n      cnt += G[f][a[i].first][a[i].second] == '*';\n    }\n    if(cnt == 0) return false;\n  }\n  {\n    int f = rid[d].getLabel(1) - 1;\n    vector<pair<int,int> > &a = A[ps[d].second];\n    int cnt = 0;\n    for(int i = 0; i < a.size(); ++i) {\n      cnt += G[f][a[i].first][a[i].second] == '*';\n    }\n    if(cnt == 0) return false;\n  }\n  return true;\n}\n\nint main() {\n  init();\n  while(1) {\n    for(int k = 0; k < 6; ++k) {\n      for(int i = 0; i < 3; ++i) {\n        for(int j = 0; j < 3; ++j) {\n          cin >> G[k][i][j];\n          if(G[k][i][j] == '#') return 0;\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int d = 0; d < V; ++d) {\n      if(isValid(d)) {\n        ans = min(ans, cost[d]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nstring Message[] = {\"Front\",\"Right\",\"Back\",\"Left\",\"Top\",\"Bottom\"};\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nclass Box\n{\npublic:\n  vector<vector<string> > box;\n  int used;  \n\n  Box(){\n    used = 0;\n    box.resize(6);\n    for(int i=0;i<6;i++)box[i].resize(3);\n  }\n\n  vector<string> rotate90(vector<string> &x)\n  {\n    vector<string> ret = x;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tret[j][2-i] = x[i][j];\n\n    return ret;\n  }\n\n  vector<string> rotate270(vector<string> &x)\n  {\n    vector<string> ret = x;\n    for(int i=0;i<3;i++)\n      ret = rotate90(ret);\n    return ret;\n  }\n\n  vector<vector<string> > R1(vector<vector<string> > &x)\n  {\n    vector<vector<string> > r = x;\n    string pre[3];\n    for(int i=0;i<3;i++)pre[i] = r[2][i];\n\n    //2 <- 4\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[2][2-i][2-j] = r[4][i][j];\n\n    //4 <- 0\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[4][i][j] = r[0][i][j];\n\n    //0 <- 5\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[0][i][j] = r[5][i][j];\n\n    //5 <- 2\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[5][2-i][2-j] = pre[i][j];\n\n    r[1] = rotate90(r[1]);\n    r[3] = rotate270(r[3]);\n\n    return r;\n  }\n\n  vector<vector<string> > R2(vector<vector<string> > &x)\n  {\n    vector<vector<string> > r = x;\n    for(int i=0;i<3;i++)\n      r = R1(r);\n    return r;\n  }\n\n  vector<vector<string> > R3(vector<vector<string> > &x)\n  {\n    vector<vector<string> > r = x;\n    string pre[3];\n    for(int i=0;i<3;i++)pre[i] = r[4][i];\n\n    //4 <- 1\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[4][2-j][i] = r[1][i][j];\n\n    //1 <- 5\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[1][2-j][i] = r[5][i][j];\n\n\n    //5 <- 3\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[5][2-j][i] = r[3][i][j];\n\n\n    //3 <- 4\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tr[3][2-j][i] = pre[i][j];\n\n\n    r[0] = rotate270(r[0]);\n    r[2] = rotate90(r[2]);\n    return r;\n  }\n\n  vector<vector<string> > R4(vector<vector<string> > &x)\n  {\n    vector<vector<string> > ret = x;\n    for(int i=0;i<3;i++)\n      ret = R3(ret);\n    return ret;\n  }\n\n\n  void print()\n  {\n    cout << \"print--------------\" << endl;\n    for(int k=0;k<6;k++)\n      {\n\tcout << Message[k] << \"*************\" << endl;\n\tfor(int i=0;i<3;i++)\n\t  {\n\t    for(int j=0;j<3;j++)\n\t      {\n\t\tcout << box[k][i][j];\n\t      }\n\t    cout << endl;\n\t  }\n      }\n    cout << endl;\n  }\n\n  bool isOK(int x)\n  {\n    queue<pair<int,int> > que;\n    bool used[3][3];\n    for(int i=0;i<3;i++)for(int j=0;j<3;j++)used[i][j] = false;\n    if(box[x][0][0] != '*')\n      que.push(pair<int,int>(0,0)),used[0][0] = true;\n    if(box[x][0][1] != '*')\n      que.push(pair<int,int>(1,0)),used[0][1] = true;\n    if(box[x][0][2] != '*')\n      que.push(pair<int,int>(2,0)),used[0][2] = true;\n\n    while(!que.empty())\n      {\n\tpair<int,int> p = que.front(); que.pop();\n\tif(p.second == 2)return true;\n\tfor(int i=0;i<4;i++)\n\t  {\n\t    int nx = p.first + dx[i];\n\t    int ny = p.second + dy[i];\n\t    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t    if(used[ny][nx])continue;\n\t    used[ny][nx] = true;\n\t    que.push(pair<int,int>(nx,ny));\n\t  }\n\n      }\n    return false;\n  }\n\n  bool isFin()\n  {\n    bool p1 = false;\n    bool p2 = false;\n    if(box[0][2][0] == '*')p1 = true;\n    if(box[0][2][1] == '*')p1 = true;\n    if(box[0][2][2] == '*')p1 = true;\n    if(box[2][2][0] == '*')p2 = true;\n    if(box[2][2][1] == '*')p2 = true;\n    if(box[2][2][2] == '*')p2 = true;\n\n    return p1 & p2;\n  }\n\n};\n\ntypedef pair<Box,int> P;\n\nint main()\n{\n  while(true)\n    {\n      Box box;\n      rep(k,6)\n\t{\n\t  rep(i,3)\n\t    {\n\t      string line;\n\t      cin >> line;\t\n\t      box.box[k][i] = line;\n\t      if(line == \"#\")\n\t\t{\n\t\t  assert(i == 0 && k == 0);\n\t\t  goto F;\t\t\n\t\t}\n\t    }\n\t}\n\n      bool found = false;\n\t  queue<P> que;\n\t  que.push(P(box,0));\n\t  while(!que.empty())\n\t    {\n\t      P p = que.front(); que.pop();\n\t      if(p.first.isFin())\n\t\t{\n\t\t  found = true;\n\t\t  cout << p.second << endl;\n\t\t  break;\n\t\t}\n\n\t      for(int i=0;i<4;i++)\n\t\t{\n\t\t  if((p.first.used >> i) & 1)continue;\n\t\t  Box bx = p.first;\n\t\t  if(i == 0)\n\t\t    bx.box = bx.R1(bx.box),p.first.used <<= (1<<i);\n\t\t  else if(i == 1)\n\t\t    bx.box = bx.R2(bx.box),p.first.used <<= (1<<i);\n\t\t  else if(i == 2)\n\t\t    bx.box = bx.R3(bx.box),p.first.used <<= (1<<i);\n\t\t  else if(i == 3)\n\t\t    bx.box = bx.R4(bx.box),p.first.used <<= (1<<i);\n\t\t  que.push(P(bx,p.second+1));\n\t\t}\n\t    }\n\t  assert(found);\n\n    }\n F:;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nvector<vector<int>>rotate_l(vector<vector<int>>vs) {\n\tvector<vector<int>>afvs(vs.size(),vector<int>(vs.size()));\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tafvs[2 - j][i] = vs[i][j];\n\t\t}\n\t}\n\treturn afvs;\n}\nvector<vector<int>>rotate_r(vector<vector<int>>vs) {\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\treturn vs;\n}\nvector<vector<int>>rotate_2(vector<vector<int>>vs) {\n\tvs = rotate_l(vs);\n\tvs = rotate_l(vs);\n\treturn vs;\n}\n\nstruct Dice {\n\tvector<vector<int>> tp;\n\tvector<vector<int>> bo;\n\tvector<vector<int>> no;\n\tvector<vector<int>> so;\n\tvector<vector<int>> ea;\n\tvector<vector<int>> we;\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice():tp(3,vector<int>(3)),\n\t\tbo(3, vector<int>(3)),\n\t\tno(3, vector<int>(3)),\n\t\tso(3, vector<int>(3)),\n\t\tea(3, vector<int>(3)),\n\t\twe(3, vector<int>(3))\n\t{\n\t}\n\tenum R_Way {\n\t\tR_Left,\n\t\tR_Front,\n\t\tR_Right,\n\t\tR_Back,\n\n\t\tR_Dummy,\n\t};\n\tbool check()const  {\n\t\tbool sook = false;\n\t\tbool nook = false;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (so[2][i])sook = true;\n\t\t\tif (no[2][i])nook = true;\n\t\t}\n\t\treturn sook&&nook;\n\t}\n\tvoid rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tso = rotate_l(so);\n\t\t\tno = rotate_r(no);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = we;\n\t\t\t\ttp = rotate_l(tp);\n\t\t\t\twe = bo;\n\t\t\t\twe = rotate_l(we);\n\t\t\t\tbo = ea;\n\t\t\t\tbo = rotate_l(bo);\n\t\t\t\tea = tmp;\n\t\t\t\tea = rotate_l(ea);\n\t\t\t}\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tea = rotate_l(ea);\n\t\t\twe = rotate_r(we);\n\t\t\t{\n\t\t\t\tvector<vector<int>>tmp = tp;\n\t\t\t\ttp = no;\n\t\t\t\ttp = rotate_2(tp);\n\t\t\t\tno = bo;\n\t\t\t\tno = rotate_2(no);\n\t\t\t\tbo = so;\n\t\t\t\tso = tmp;\n\t\t\t}\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t\trotate(R_Right);\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t\trotate(R_Back);\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid rotate(const int way) {\n\t\trotate(static_cast<R_Way>(way));\n\t}\n\tlong long int hash()const {\n\t\tlong long int hash = 0;\n\t\tlong long int num = 1;\n\t\tfor (int y = 0; y < 3; ++y) {\n\t\t\tfor (int x = 0; x < 3; ++x) {\n\t\t\t\tif (tp[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (bo[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (no[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (we[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (so[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t\tif (ea[y][x])hash += num;\n\t\t\t\tnum *= 2;\n\t\t\t}\n\t\t}\n\t\treturn hash;\n\t}\n};\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\nint main() {\n\twhile (1) {\n\t\tDice di;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tvector<vector<int>>vs;\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tvector<int>v(3);\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (st == \"#\")return 0;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (st[k] == '*')v[k] = 1;\n\t\t\t\t}\n\t\t\t\tvs.emplace_back(v);\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tdi.so = vs;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdi.ea = vs;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdi.no = vs;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdi.we = vs;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdi.tp = vs;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdi.bo = vs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans = 9999;\n\t\tqueue<pair<int, Dice>>que;\n\t\tmap<long long int, int>mp;\n\t\tmp[di.hash()] = 0;\n\t\tque.push(make_pair(0, di));\n\t\twhile (!que.empty()) {\n\t\t\tauto p = que.front();\n\t\t\tque.pop();\n\t\t\tconst int nexttime = p.first + 1;\n\t\t\tconst Dice ori = p.second;\n\t\t\tif (ori.check()) {\n\t\t\t\tans = nexttime - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tDice now(ori);\n\t\t\t\tnow.rotate(i);\n\t\t\t\tauto it = mp.find(now.hash());\n\t\t\t\tif (it == mp.end()) {\n\t\t\t\t\tmp[now.hash()] = nexttime;\n\t\t\t\t\tque.emplace(nexttime, now);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct panel{\n  char t[3][3];\n};\n\npanel ra(panel p){\n  char u[3][3];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)u[i][j]=p.t[i][j];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)p.t[i][j]=u[j][2-i];\n  return p;\n}\n\npanel rb(panel p){\n  char u[3][3];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)u[i][j]=p.t[i][j];\n  for(int i=0;i<3;i++)for(int j=0;j<3;j++)p.t[i][j]=u[2-i][j];\n  return p;\n}\n\nstruct die{\n  panel t[6];\n  bool operator < (const die &p)const{\n    for(int i=0;i<6;i++)\n      for(int j=0;j<3;j++)\n        for(int k=0;k<3;k++)\n          if(t[i].t[j][k]!=p.t[i].t[j][k])\n            return (t[i].t[j][k]<p.t[i].t[j][k]);\n    return false;\n  }\n};\n\ndie ra(die p){\n  panel tmp=p.t[0];\n  p.t[0]=p.t[4];\n  p.t[4]=rb(p.t[2]);\n  p.t[2]=rb(p.t[5]);\n  p.t[5]=tmp;\n  p.t[1]=ra(p.t[1]);\n  p.t[3]=ra(ra(ra(p.t[3])));\n  return p;\n}\n\ndie rb(die p){\n  panel tmp=p.t[1];\n  p.t[1]=ra(ra(ra(p.t[4])));\n  p.t[4]=ra(ra(ra(p.t[3])));\n  p.t[3]=ra(ra(ra(p.t[5])));\n  p.t[5]=ra(ra(ra(tmp)));\n  p.t[0]=ra(ra(ra(p.t[0])));\n  p.t[2]=ra(p.t[2]);\n  return p;\n}\n\nchar str[100];\n\nbool input(panel &p){\n  for(int i=0;i<3;i++){\n    scanf(\"%s\",str);\n    if(str[0]=='#')return false;\n    for(int j=0;j<3;j++)p.t[i][j]=str[j];\n  }\n  return true;\n}\n\nbool check(panel &p){\n  for(int i=0;i<3;i++)\n    if(p.t[2][i]=='*')return true;\n  return false;\n}\n\nint main(){\n  die A;\n  while(input(A.t[0])){\n    for(int i=1;i<6;i++)input(A.t[i]);\n    map< die , int > d;\n    queue< die > Q;\n    d[A]=0;\n    Q.push(A);\n    while(!Q.empty()){\n      die s=Q.front();Q.pop();\n      int cost=d[s];\n      if( check(s.t[0]) && check(s.t[2]) ){\n        cout<<cost<<endl;\n        break;\n      }\n      die next=ra(s);\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n\n      next=ra(ra(ra(s)));\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n\n      next=rb(s);\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n      \n      next=rb(rb(rb(s)));\n      if(d.count(next)==0){\n        d[next]=cost+1;\n        Q.push(next);\n      }\n      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<string> >v;\n\n\nclass Cube{\npublic:\n  char field[6][3][3];\n  int cnt;\n  void insert(int from, int to, Cube &tmp){\n    for(int i=0; i<3; i++)\n      for(int j=0; j<3; j++) field[to][i][j] = tmp.field[from][i][j];\n  }\n\n  void copy(Cube &tmp){\n    for(int k=0; k<6; k++)\n      for(int i=0; i<3; i++)\n\tfor(int j=0; j<3; j++) tmp.field[k][i][j] = field[k][i][j];\n  }\n  \n  void rotate90(int num){\n    char field2[3][3];\n\n    for(int i=0; i<3; i++){\n      for(int j=0; j<3; j++){\n\tfield2[i][j] = field[num][3-j-1][i];\n      }\n    }\n\n    for(int i=0; i<3; i++)\n      for(int j=0; j<3; j++) field[num][i][j] = field2[i][j];\n\n  }\n  void front(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(1);\n    for(int i=0; i<3; i++) rotate90(3);\n\n    //top -> front\n    insert(4,0,tmp);\n    //    for(int i=0; i<2; i++) rotate90(0);\n\n    //front->bottom\n    insert(0,5,tmp);\n    //    for(int i=0; i<2; i++) rotate90(5);\n\n    //bottom->back\n    insert(5,2,tmp);\n    //    for(int i=0; i<2; i++) rotate90(2);\n\n    //back->top\n    insert(2,4,tmp);\n    //    for(int i=0; i<2; i++) rotate90(2);\n  }\n\n  void back(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(3);\n    for(int i=0; i<3; i++) rotate90(1);\n\n    //top->back\n    insert(4,2,tmp);\n\n    //back->bottom\n    insert(2,5,tmp);\n\n    //bottom->front\n    insert(5,0,tmp);\n\n    //front->top\n    insert(0,4,tmp);\n\n  }\n\n  void left(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(0);\n    for(int i=0; i<3; i++) rotate90(2);\n\n    //top->left\n    insert(4,3,tmp);\n\n    //left->bottom\n    insert(3,5,tmp);\n\n    //bottom->right\n    insert(5,1,tmp);\n\n    //right->top\n    insert(1,4,tmp);\n\n  }\n\n  void right(){\n    Cube tmp;\n    copy(tmp);\n    rotate90(2);\n    for(int i=0; i<3; i++) rotate90(0);\n\n\n    //top->right\n    insert(4,1,tmp);\n\n    //right->bottom\n    insert(1,5,tmp);\n\n    //bottom->left\n    insert(5,3,tmp);\n\n    //left->top\n    insert(3,4,tmp);\n  }\n\n};\n\nbool check(Cube a){\n  bool front = false;\n  bool back = false;\n\n  for(int i=0; i<3; i++)\n    if(a.field[0][2][i] == '*') front = true;\n\n  for(int i=0; i<3; i++)\n    if(a.field[2][2][i] == '*') back = true;\n\n  return front && back;\n\n}\n\n\nint bfs(Cube a){\n  queue<Cube>que;\n  que.push(a);\n\n  while(!que.empty()){\n    Cube tmp = que.front();\n    que.pop();\n\n    if(check(tmp)) return a.cnt;\n\n    for(int i=0; i<4; i++){\n      Cube t = tmp;\n      if(i == 0) t.front();\n      if(i == 1) t.right();\n      if(i == 2) t.back();\n      if(i == 3) t.left();\n      t.cnt++;\n      que.push(t);\n    }\n  }\n}\n\nint main(){\n  string s;\n  int cnt = 0;\n  Cube c;\n\n  while(cin >> s){\n    if(s == \"#\")break;\n    c.cnt = 0;\n    for(int i=0; i<s.size(); i++)\n      c.field[cnt/3][cnt%3][i] = s[i];\n    cnt++;\n\n\n\n    if(cnt == 18){\n      cout << bfs(c) << endl;\n      cnt = 0;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\nstring dice[6][3];\n\ninline bool ok(char c){\n  return c == '*';\n}\n\nbool check(int f, int x, int y){\n  if (x == -1) {\n    REP(i, 3) if (ok(dice[f][i][y])) return true;\n    return false;\n  }\n  \n  if (y == -1) {\n    REP(i, 3) if (ok(dice[f][x][i])) return true;\n    return false;\n  }\n  assert(false);\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  \n  while (cin >> dice[0][0] && dice[0][0] != \"#\"){\n    cin >> dice[0][1] >> dice[0][2];\n    REP2(i, 1, 6) REP(j, 3){\n      cin >> dice[i][j];\n    }\n\n    int res = 3;\n    \n    if (check(0, 2, -1) && check(2, 2, -1)) res = min(res, 0);\n    if (check(0, -1, 0) && check(2, -1, 0)) res = min(res, 1);\n    if (check(0, -1, 2) && check(2, -1, 2)) res = min(res, 1);\n    if (check(0, 0, -1) && check(2, 0, -1)) res = min(res, 2);\n\n    if (check(4, 0, -1) && check(5, 2, -1)) res = min(res, 1);\n    if (check(5, 0, -1) && check(4, 2, -1)) res = min(res, 1);\n    if (check(4, -1, 0) && check(5, -1, 0)) res = min(res, 2);\n    if (check(4, -1, 2) && check(5, -1, 2)) res = min(res, 2);\n\n    if (check(1, -1, 0) && check(3, -1, 2)) res = min(res, 2);\n    if (check(3, -1, 0) && check(1, -1, 2)) res = min(res, 2);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// z軸を中心に右回転\nint rotateRight[]={0,1,3,5,2,4,6};\n// z軸を中心に左回転\nint rotateLeft[]={0,1,4,2,5,3,6};\n// 回転させてマッチするfaceを探す\n// curFaceに結果を代入\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // 左へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // 前へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)nfield[l][2-k]=field[i-1][j][k][l];\n        // fieldを回転させる\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)field[i][j][k][l]=nfield[l][k];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      int cnt2=0;\n      if(label[front]>=1&&label[front]<=4){\n        if(ang==0||ang==2){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n      }\n      else{\n        if(ang==0||ang==2){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n      }\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // 面を四方向に回転\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // 前\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // 後ろ\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nbool input(vs& v)\n{\n\tv.resize(18);\n\tREP(i, 18)\n\t{\n\t\tcin >> v[i];\n\t\tif (v[i] == \"#\") return false;\n\t}\n\treturn true;\n}\n\nvs to_clock(vs& v)\n{\n\tvs res(3, string(\"@@@\"));\n\tREP(i, 3)REP(j,3)res[i][j] = v[2-j][i];\n\treturn res;\n}\n\nvs to_cclock(vs& v)\n{\n\tvs res = v;\n\tREP(i, 3) res = to_clock(res);\n\treturn res;\n}\n\nvs reverse(vs& v)\n{\n\tvs res = v;\n\tswap(res[0], res[2]);\n\treturn res;\n}\n\nstruct Room\n{\n\tvs front, right, back, left, top, bottom;\n\tRoom(vs v)\n\t{\n\t\tFOR(i, 0, 3) front.push_back(v[i]);\n\t\tFOR(i, 3, 6) right.push_back(v[i]);\n\t\tFOR(i, 6, 9) back.push_back(v[i]);\n\t\tFOR(i, 9, 12) left.push_back(v[i]);\n\t\tFOR(i, 12, 15) top.push_back(v[i]);\n\t\tFOR(i, 15, 18) bottom.push_back(v[i]);\n\t}\n\tvoid to_front()\n\t{\n\t\tvs nfront, nright, nback, nleft, ntop, nbottom;\n\t\tnfront = bottom;\n\t\tntop = front;\n\t\tnback = reverse(top);\n\t\tnbottom = back;\n\t\tnleft = to_cclock(left);\n\t\tnright = to_clock(right);\n\t\tfront = nfront;\n\t\tright = nright;\n\t\tback = nback;\n\t\tleft = nleft;\n\t\ttop = ntop;\n\t\tbottom = nbottom;\n\t}\n\tvoid to_back() \n\t{\n\t\tREP(i, 3) to_front();\n\t}\n\tvoid to_right()\n\t{\n\t\tvs nfront, nright, nback, nleft, ntop, nbottom;\n\t\tntop = to_clock(left);\n\t\tnleft = to_clock(bottom);\n\t\tnbottom = to_clock(right);\n\t\tnright = to_clock(top);\n\t\tnfront = to_clock(front);\n\t\tnback = to_clock(back);\n\t\tfront = nfront;\n\t\tright = nright;\n\t\tback = nback;\n\t\tleft = nleft;\n\t\ttop = ntop;\n\t\tbottom = nbottom;\n\t}\n\tvoid to_left()\n\t{\n\t\tREP(i, 3) to_right();\n\t}\n};\n\nbool check(Room& room)\n{\n\tvs a = room.front, b = room.back;\n\tbool f1 = false, f2 = false;\n\tREP(i, 3)\n\t{\n\t\tif (a[2][i] == '*') f1 = true;\n\t\tif (b[2][i] == '*') f2 = true;\n\t}\n\treturn f1 && f2;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tvs v;\n\twhile (input(v))\n\t{\n\t\tRoom room(v);\n\t\tqueue<pair<Room, int>> que;\n\t\tque.emplace(room, 0);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tRoom tmp = que.front().first; int t = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (check(tmp))\n\t\t\t{\n\t\t\t\tcout << t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRoom nx = tmp;\n\t\t\tnx.to_front();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_back();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_right();\n\t\t\tque.emplace(nx, t + 1);\n\t\t\tnx = tmp;\n\t\t\tnx.to_left();\n\t\t\tque.emplace(nx, t + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int inf = (1<<20);\n\nvoid rotate_ccw(char m[3][3]){\n  int r=3,c=3;\n  static char buf[3][3];\n  rep(i,3)rep(j,3)buf[i][j]=m[i][j];\n  rep(i,c)rep(j,r)m[i][j]=buf[j][c-1-i];\n}\n\nvoid upsideDown(char m[3][3]){\n  rep(j,3)swap(m[0][j],m[2][j]);\n}\n\n#define rotate_swap(p,a,b,c,d) swap(p[a],p[b]);swap(p[b],p[c]);swap(p[c],p[d]);\nenum{FR=0,RI,BA,LE,TO,BO};\nclass Dice{\npublic:\n  int d[6];\n  char m[6][3][3];\n  void rotate_f(){\n    rotate_ccw(m[d[LE]]);\n    rotate_ccw(m[d[RI]]);\n    rotate_swap(d,TO,BA,BO,FR);\n  }\n  void rotate_b(){\n    rep(i,3)rotate_f();\n  }\n  void rotate_l(){\n    rotate_ccw(m[d[FR]]);\n    rotate_ccw(m[d[BA]]);\n    upsideDown(m[d[LE]]);\n    upsideDown(m[d[BO]]);\n    rotate_swap(d,TO,LE,BO,RI);\n  }\n  void rotate_r(){\n    rep(i,3)rotate_l();\n  }\n  bool isok(){\n    if ((m[d[FR]][2][0] =='*' || \n\tm[d[FR]][2][1] =='*' || \t\n\t m[d[FR]][2][2] =='*' )\n      &&\n      (m[d[BA]][0][0] =='*' || \n       m[d[BA]][0][1] =='*' || \t\n       m[d[BA]][0][2] =='*' ))return true;\n    return false;\n  }\n};\n\nint cost[6][6][6];\nint solve(Dice & ini){\n  rep(i,6)rep(j,6)rep(k,6)cost[i][j][k]=inf;\n  queue<Dice> Q;\n  Q.push(ini);\n  cost[ini.d[0]][ini.d[1]][ini.d[2]]=0;\n  while(!Q.empty()){\n    Dice now = Q.front();Q.pop();\n    int nc=cost[now.d[0]][now.d[1]][now.d[2]];\n    if (now.isok())return nc;\n    //front\n    Dice next=now;next.rotate_f();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_b();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_l();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n    next=now;next.rotate_r();\n    if (cost[next.d[0]][next.d[1]][next.d[2]] == inf){\n      cost[next.d[0]][next.d[1]][next.d[2]]=nc+1;\n      Q.push(next);\n    }\n\n  }\n\n  return -1;\n}\n\n\nmain(){\n  while(true){\n    Dice ini;rep(i,6)ini.d[i]=i;\n    rep(i,6){\n      rep(j,3){\n\tstring tmp;cin>>tmp;if (tmp == \"#\")return 0;\n\trep(k,3)ini.m[i][j][k]=tmp[k];\n\tif (i == RI || i == LE){\n\t  rep(k,3)rotate_ccw(ini.m[i]);\n\t}else if (i == BA || i == BO){\n\t  upsideDown(ini.m[i]);\n\t}\n      }\n    }\n    cout << solve(ini) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nstring C[6][3];\n\nint main(){\n    //#define de\n    #ifdef de\n    freopen(\"in.txt\",\"r\",stdin);\n    #endif\n    int a[6][4]={};\n    while(1){\n        int ans=999;\n        for(int i=0; i<6; i++) for(int j=0; j<3; j++){\n            cin>>C[i][j];\n            if(C[i][j]==\"#\") goto end;\n        }\n\n        cout<<ans;\n    }\n    end:\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nchar str[20][5];\nstruct wolf{\n\tchar d[6][3][3];\n};\ninline bool operator<(const wolf&a,const wolf&b){\n\tfor(int i=0;i<6;i++)for(int j=0;j<3;j++)for(int k=0;k<3;k++)\n\t\tif(a.d[i][j][k]!=b.d[i][j][k])return a.d[i][j][k]<b.d[i][j][k];\n\treturn false;\n}\nvoid rN(wolf &a){\n\twolf tmp;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[0][i][j]=a.d[5][i][j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[4][i][j]=a.d[0][i][j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[2][i][j]=a.d[4][2-i][2-j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[5][i][j]=a.d[2][2-i][2-j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[1][i][j]=a.d[1][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[3][i][j]=a.d[3][2-j][i];\n\ta=tmp;\n}\nvoid rS(wolf &a){\n\twolf tmp;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[0][i][j]=a.d[4][i][j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[5][i][j]=a.d[0][i][j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[2][i][j]=a.d[5][2-i][2-j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[4][i][j]=a.d[2][2-i][2-j];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[3][i][j]=a.d[3][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[1][i][j]=a.d[1][2-j][i];\n\ta=tmp;\n}\nvoid rE(wolf &a){\n\twolf tmp;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[1][i][j]=a.d[4][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[5][i][j]=a.d[1][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[3][i][j]=a.d[5][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[4][i][j]=a.d[3][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[0][i][j]=a.d[0][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[2][i][j]=a.d[2][2-j][i];\n\ta=tmp;\n}\nvoid rW(wolf &a){\n\twolf tmp;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[4][i][j]=a.d[1][2-j][i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[1][i][j]=a.d[5][2-j][i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[5][i][j]=a.d[3][2-j][i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[3][i][j]=a.d[4][2-j][i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[2][i][j]=a.d[2][j][2-i];\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)tmp.d[0][i][j]=a.d[0][2-j][i];\n\ta=tmp;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",str[0]);\n\t\tif(str[0][0]=='#')return 0;\n\t\tfor(int i=1;i<18;i++)scanf(\"%s\",str[i]);\n\t\tqueue<pair<wolf,int> >Q;\n\t\tset<wolf>S;\n\t\twolf st;\n\t\tfor(int j=0;j<6;j++){\n\t\t\tfor(int k=0;k<3;k++)for(int l=0;l<3;l++)\n\t\t\t\tst.d[j][k][l]=str[j*3+k][l];\n\t\t}\n\t\tS.insert(st);\n\t\tQ.push(make_pair(st,0));\n\t\t\n\t\twhile(Q.size()){\n\t\t\twolf at=Q.front().first;\n\t\t\tint cost=Q.front().second;\n\t\t\tif((at.d[0][2][0]=='*'||at.d[0][2][1]=='*'||at.d[0][2][2]=='*')&&(at.d[2][2][0]=='*'||at.d[2][2][1]=='*'||at.d[2][2][2]=='*')){\n\t\t\t\tprintf(\"%d\\n\",cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t\trN(at);\n\t\t\tif(!S.count(at)){\n\t\t\t\tS.insert(at);Q.push(make_pair(at,cost+1));\n\t\t\t}\n\t\t\trS(at);\n\t\t\trS(at);\n\t\t\tif(!S.count(at)){\n\t\t\t\tS.insert(at);Q.push(make_pair(at,cost+1));\n\t\t\t}\n\t\t\trN(at);\n\t\t\trE(at);\n\t\t\tif(!S.count(at)){\n\t\t\t\tS.insert(at);Q.push(make_pair(at,cost+1));\n\t\t\t}\n\t\t\trW(at);\n\t\t\trW(at);\n\t\t\tif(!S.count(at)){\n\t\t\t\tS.insert(at);Q.push(make_pair(at,cost+1));\n\t\t\t}\n\t\t\trE(at);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvector<vs>in(6,vs(3));\nint main(){\n\twhile(1){\n\t\tstring t;cin>>t;\n\t\tif(t==\"#\")return 0;\n\t\trep(i,6)rep(j,3){\n\t\t\tif(i+j==0)in[i][j]=t;\n\t\t\telse cin>>in[i][j];\n\t\t}\n\t\trep(i,3){\n\t\t\treverse(all(in[2][i]));\n\t\t\treverse(all(in[3][i]));\n\t\t}\n\t\trep(i,3)\n\t\t\tswap(in[5][i][0],in[5][2-i][2]);\n\n\t\tint out=inf;\n\t\tif((in[0][0][0]=='*'||in[0][0][1]=='*'||in[0][0][2]=='*')&&\n\t\t(in[2][0][0]=='*'||in[2][0][1]=='*'||in[2][0][2]=='*'))out=min(out,2);\n\t\tif((in[0][2][0]=='*'||in[0][2][1]=='*'||in[0][2][2]=='*')&&\n\t\t(in[2][2][0]=='*'||in[2][2][1]=='*'||in[2][2][2]=='*'))out=min(out,0);\n\t\tif((in[0][0][0]=='*'||in[0][1][0]=='*'||in[0][2][0]=='*')&&\n\t\t(in[2][0][0]=='*'||in[2][1][0]=='*'||in[2][2][0]=='*'))out=min(out,1);\n\t\tif((in[0][0][2]=='*'||in[0][1][2]=='*'||in[0][2][2]=='*')&&\n\t\t(in[2][0][2]=='*'||in[2][1][2]=='*'||in[2][2][2]=='*'))out=min(out,1);\n\n\t\tif((in[1][0][0]=='*'||in[1][0][1]=='*'||in[1][0][2]=='*')&&\n\t\t(in[3][0][0]=='*'||in[3][0][1]=='*'||in[3][0][2]=='*'))out=min(out,3);\n\t\tif((in[1][2][0]=='*'||in[1][2][1]=='*'||in[1][2][2]=='*')&&\n\t\t(in[3][2][0]=='*'||in[3][2][1]=='*'||in[3][2][2]=='*'))out=min(out,3);\n\t\tif((in[1][0][0]=='*'||in[1][1][0]=='*'||in[1][2][0]=='*')&&\n\t\t(in[3][0][0]=='*'||in[3][1][0]=='*'||in[3][2][0]=='*'))out=min(out,2);\n\t\tif((in[1][0][2]=='*'||in[1][1][2]=='*'||in[1][2][2]=='*')&&\n\t\t(in[3][0][2]=='*'||in[3][1][2]=='*'||in[3][2][2]=='*'))out=min(out,2);\n\n\t\tif((in[4][0][0]=='*'||in[4][0][1]=='*'||in[4][0][2]=='*')&&\n\t\t(in[5][0][0]=='*'||in[5][0][1]=='*'||in[5][0][2]=='*'))out=min(out,3);\n\t\tif((in[4][2][0]=='*'||in[4][2][1]=='*'||in[4][2][2]=='*')&&\n\t\t(in[5][2][0]=='*'||in[5][2][1]=='*'||in[5][2][2]=='*'))out=min(out,1);\n\t\tif((in[4][0][0]=='*'||in[4][1][0]=='*'||in[4][2][0]=='*')&&\n\t\t(in[5][0][0]=='*'||in[5][1][0]=='*'||in[5][2][0]=='*'))out=min(out,2);\n\t\tif((in[4][0][2]=='*'||in[4][1][2]=='*'||in[4][2][2]=='*')&&\n\t\t(in[5][0][2]=='*'||in[5][1][2]=='*'||in[5][2][2]=='*'))out=min(out,2);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n  テ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツつ津ィツサツ「テ」ツ?古」ツ?療」ツ?ヲBFSテ」ツ?づ・ツ閉湘ゥツ。ツ古」ツ?ッテ」ツつエテ」ツδシテ」ツδォテ・ツ按、テ・ツョツ堙」ツ??\n  テ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツ?ョテ・ツ青妥」ツ?催」ツ?ッテ・ツ?ィテゥツδィテ」ツ?ァ6*4=24テゥツ?堙」ツつ甘」ツ?療」ツ?凝」ツ?ェテ」ツ??」ツ?ョテ」ツ?ァ,\n  テ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツ?ョテ・ツ青?ァツ環カテヲツ?凝」ツ?ォテ」ツ?甘」ツ??」ツ?ヲ,テァツゥツエテ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツつ津ィツェツソテ」ツ?ケテ」ツつ凝・ツソツ?ィツヲツ?」ツ?古」ツ?づ」ツつ?\n  テ・ツ?・テ・ツ環崚」ツ?ョテ」ツつーテ」ツδェテ」ツδε」ツδ嘉、ツクツ甘」ツ?ョテ・ツコツァテヲツィツ凖」ツつ津・ツ?ィテゥツδィテ」ツつステ」ツδシテ」ツつケテ・ツ??」ツ?ォテァツ崢エテヲツ可禿」ツ?。テ」ツ??\n */\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nstruct Dice {\n  int id[6], cnt, label[6];\n  const static int f[3][3];\n \n  Dice() { init(); }\n \n  void init() {\n    for(int i = 0; i < 6; ++i) {\n      id[i] = i;\n    }\n    cnt = 0;\n    label[0] = 1;\n    label[1] = 2;\n    label[2] = 5;\n    label[3] = 6;\n    label[4] = 4;\n    label[5] = 3;\n  }\n \n  void rotate(int type, int dir = 1) {\n    const int *v = f[type];\n    int a,b,c,t; a=v[0]; b=v[1]; c=v[2]; t=id[type];\n    if(dir < 0) swap(a,c);\n    id[type]=id[a]; id[a]=id[b]; id[b]=id[c]; id[c]=t;\n  }\n \n  bool next() {\n    ++cnt;\n    if(cnt == 24) {\n      rotate(0,-1);\n      rotate(1,-1);\n      cnt = 0;\n      return false;\n    }\n    if(cnt == 4*3) {\n      rotate(2,-1);\n      rotate(0,-1);\n    } else if(cnt%4 == 0) {\n      rotate(2);\n    } else {\n      rotate(0);\n    }\n    return true;\n  }\n \n  void roll(int dir) {\n    switch(dir) {\n    case 0: rotate(1,-1); break;\n    case 1: rotate(2, 1); break;\n    case 2: rotate(1, 1); break;\n    case 3: rotate(2,-1); break;\n    }\n  }\n \n  bool operator < (const Dice &d) const {\n    for(int i = 0; i < 3; ++i) {\n      if(id[i] != d.id[i]) return id[i] < d.id[i];\n    }\n    return false;\n  }\n \n  void show() {\n    cout << label[id[4]] << \" / \\\\ \"<< label[id[5]] << endl;\n    cout << \" /   \\\\\" << endl;\n    cout << \"|\\\\ \" << label[id[2]] << \" /|\" << endl;\n    cout << \"|\" << label[id[0]] << \"\\\\ /\" << label[id[1]] << \"|\" << endl;\n    cout << \" \\\\ | /\" << endl;\n    cout << \"  \\\\|/\" << endl;\n    cout << \"   \" << label[id[3]] << endl;\n  }\n \n  int getLabel(int faceNum) {\n    if(faceNum == 0) {\n      return label[id[0]];\n    } else if(faceNum == 1) {\n      return label[id[5]];\n    }\n    return -1;\n  }\n};\nconst int Dice::f[3][3] = {{4,5,1},{3,4,2},{5,3,0}};\n \n#include <vector>\n#include <map>\n#include <queue>\n \nconst int V = 24;\nconst int INF = 1<<28;\nvector<int> E[V];\nvector<pair<int, int> > ps;\nvector<pair<int, int> > A[4];\nvector<int> cost;\nmap<Dice, int> id;\nmap<int, Dice> rid;\n \nchar G[6][3][3];\n \nvoid bfs(int v) {\n  cost = vector<int>(V, INF);\n  cost[v] = 0;\n  queue<int> que;\n  que.push(v);\n  while(!que.empty()) {\n    v = que.front();\n    que.pop();\n    for(int i = 0; i < E[v].size(); ++i) {\n      int to = E[v][i];\n      if(cost[to] != INF) continue;\n      cost[to] = cost[v] + 1;\n      que.push(to);\n    }\n  }\n}\n \nvoid init() {\n  Dice d;\n  do {\n    id[d] = id.size()-1;\n    rid[id[d]] = d;\n  } while(d.next());\n \n  do {\n    for(int i = 0; i < 4; ++i) {\n      Dice t = d;\n      t.roll(i);\n      E[id[d]].push_back(id[t]);\n    }\n  } while(d.next());\n \n  A[0].push_back(make_pair(2,0));\n  A[0].push_back(make_pair(2,1));\n  A[0].push_back(make_pair(2,2));\n \n  A[1].push_back(make_pair(0,0));\n  A[1].push_back(make_pair(1,0));\n  A[1].push_back(make_pair(2,0));\n \n  A[2].push_back(make_pair(0,0));\n  A[2].push_back(make_pair(0,1));\n  A[2].push_back(make_pair(0,2));\n \n  A[3].push_back(make_pair(0,2));\n  A[3].push_back(make_pair(1,2));\n  A[3].push_back(make_pair(2,2));\n \n  ps.push_back(make_pair(0,0));\n  ps.push_back(make_pair(0,0));\n  ps.push_back(make_pair(0,0));\n  ps.push_back(make_pair(0,0));\n \n  ps.push_back(make_pair(3,3));\n  ps.push_back(make_pair(3,1));\n  ps.push_back(make_pair(3,3));\n  ps.push_back(make_pair(1,3));\n \n  ps.push_back(make_pair(1,3));\n  ps.push_back(make_pair(2,0));\n  ps.push_back(make_pair(3,1));\n  ps.push_back(make_pair(0,2));\n \n  ps.push_back(make_pair(2,2));\n  ps.push_back(make_pair(2,2));\n  ps.push_back(make_pair(2,2));\n  ps.push_back(make_pair(2,2));\n \n  ps.push_back(make_pair(2,0));\n  ps.push_back(make_pair(1,3));\n  ps.push_back(make_pair(0,2));\n  ps.push_back(make_pair(3,1));\n \n  ps.push_back(make_pair(3,1));\n  ps.push_back(make_pair(1,1));\n  ps.push_back(make_pair(1,3));\n  ps.push_back(make_pair(1,1));\n \n  bfs(0);\n}\n \nbool isValid(int d) {\n  {\n    int f = rid[d].getLabel(0) - 1;\n    vector<pair<int,int> > &a = A[ps[d].first];\n    int cnt = 0;\n    for(int i = 0; i < a.size(); ++i) {\n      cnt += G[f][a[i].first][a[i].second] == '*';\n    }\n    if(cnt == 0) return false;\n  }\n  {\n    int f = rid[d].getLabel(1) - 1;\n    vector<pair<int,int> > &a = A[ps[d].second];\n    int cnt = 0;\n    for(int i = 0; i < a.size(); ++i) {\n      cnt += G[f][a[i].first][a[i].second] == '*';\n    }\n    if(cnt == 0) return false;\n  }\n  return true;\n}\n \nint main() {\n  init();\n  while(1) {\n    for(int k = 0; k < 6; ++k) {\n      for(int i = 0; i < 3; ++i) {\n        for(int j = 0; j < 3; ++j) {\n          cin >> G[k][i][j];\n          if(G[k][i][j] == '#') return 0;\n        }\n      }\n    }\n \n    int ans = INF;\n    for(int d = 0; d < V; ++d) {\n      if(isValid(d)) {\n        ans = min(ans, cost[d]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <set>\n#define X first\n#define Y second\n#define sqr(x) (x)*(x)\nusing namespace std;\nconst double PI = acos(-1.0);\nmap<int,int>::iterator it;\ntypedef long long LL ;\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\nstruct face\n{\n    int p[3][3];\n    face rotate_left()\n    {\n        face ret;\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                ret.p[2-j][i]=p[i][j];\n            }\n        }\n        return ret;\n    }\n    face rotate_right()\n    {\n        face ret = rotate_left();\n        ret = ret.rotate_left();\n        ret = ret.rotate_left();\n        return ret;\n    }\n    void input()\n    {\n        char s[5][5];\n        for(int i=0;i<3;++i)\n        {\n            scanf(\"%s\",s[i]);\n        }\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                p[i][j]=(s[i][j]=='.')?0:1;\n            }\n        }\n    }\n    void pf()\n    {\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                printf(\"%d\",p[i][j]);\n            }\n            puts(\"\");\n        }\n    }\n};\n\n\n\n\nstruct cube\n{\n    face f[8];\n    int dis;\n    cube left()\n    {\n        cube ret ;\n        ret.f[0] = (*this).f[0].rotate_left();\n        ret.f[1] = (*this).f[5].rotate_right();\n        ret.f[2] = (*this).f[2].rotate_right();\n        ret.f[3] = (*this).f[4].rotate_right();\n        ret.f[4] = (*this).f[1].rotate_right();\n        ret.f[5] = (*this).f[3].rotate_right();\n        return ret;\n    }\n    cube right()\n    {\n        cube ret;\n        ret.f[0] = (*this).f[0].rotate_right();\n        ret.f[1] = (*this).f[4].rotate_left();\n        ret.f[2] = (*this).f[2].rotate_left();\n        ret.f[3] = (*this).f[5].rotate_left();\n        ret.f[4] = (*this).f[1].rotate_left();\n        ret.f[5] = (*this).f[3].rotate_left();\n    }\n    cube forward()\n    {\n        cube ret;\n        ret.f[0] = (*this).f[5];\n        ret.f[1] = (*this).f[1].rotate_right();\n        ret.f[2] = (*this).f[4].rotate_left();\n        ret.f[2] = ret.f[2].rotate_left();\n        ret.f[3] = (*this).f[3].rotate_left();\n        ret.f[4] = (*this).f[0];\n        ret.f[5] = (*this).f[2].rotate_left();\n        ret.f[5] = ret.f[5].rotate_left();\n        return ret;\n    }\n    cube back()\n    {\n        cube ret = (*this).forward();\n        ret = ret.forward();\n        ret = ret.forward();\n        return ret;\n    }\n    bool good()\n    {\n        bool ok1=0,ok2=0;\n        for(int i=0;i<3;++i)\n        {\n            if(f[0].p[2][i]==1)ok1=1;\n            if(f[2].p[2][i]==1)ok2=1;\n        }\n        return ok1&&ok2;\n    }\n};\ncube C;\nint res;\nvoid dfs(cube u,int depth)\n{\n    if(depth>6)return ;\n    if(u.good())\n    {\n        //printf(\"d = %d\\n\",depth);\n        res = min(res,depth);\n    }\n    else\n    {\n        cube v = u.back();\n        dfs(v,depth+1);\n        v = u.forward();\n        dfs(v,depth+1);\n        v = u.left();\n        dfs(v,depth+1);\n        v = u.right();\n        dfs(v,depth+1);\n    }\n}\nint main()\n{\n    char s[8][8];\n    while(~scanf(\"%s\",s[0]))\n    {\n        if(s[0][0]=='#')break;\n        for(int i=1;i<3;++i)scanf(\"%s\",s[i]);\n        for(int i=0;i<3;++i)\n        {\n            for(int j=0;j<3;++j)\n            {\n                C.f[0].p[i][j]=(s[i][j]=='.')?0:1;\n            }\n        }\n        for(int i=1;i<6;++i)C.f[i].input();\n        //puts(\"OK\");\n        res=10000;\n        //C.f[0].pf();\n        //C.f[2].pf();\n        dfs(C,0);\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<utility>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef array<char,9> P;\n\nvoid cw(P &p){\n  P n;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      n[j*3+2-i]=p[i*3+j];\n    }\n  }\n  p=n;\n}\n\nvoid ccw(P &p){\n  cw(p);\n  cw(p);\n  cw(p);\n}\n\nP lr(P p){\n  P n=p;\n  for(int i=0;i<3;i++){\n    swap(n[0+i*3],n[2+i*3]);\n  }\n  return n;\n}\n\nP inv(P p){\n  ccw(p);\n  ccw(p);\n  return p;\n}\n\nP nccw(P p){\n  ccw(p);\n  return p;\n}\n\nstruct Dice{\n  P p[6];\n  Dice(){\n    for(int i=0;i<6;i++){\n      for(int j=0;j<9;j++){\n\tcin>>p[i][j];\n      }\n    }\n    // auto d=Dice(*this).l();\n    // cout<<\"=---\"<<endl;\n    // for(auto e:d.p){\n    //   for(int i=0;i<3;i++){\n    // \tfor(int j=0;j<3;j++){\n    // \t  cout<<e[i*3+j];\n    // \t}\n    // \tcout<<endl;\n    //   }\n    // }\n    // cout<<\"=---\"<<endl;\n  }\n  bool operator<(Dice d)const{\n    return lexicographical_compare(begin(p),end(p),begin(d.p),end(d.p));\n  }\n  Dice &u(){\n    auto t=p[4];\n    p[4]=p[0];\n    p[0]=p[5];\n    p[5]=inv(p[2]);\n    p[2]=inv(t);\n    cw(p[1]);\n    ccw(p[3]);\n    return *this;\n  }\n  Dice &d(){\n    u();\n    u();\n    u();\n    return *this;\n  }\n  Dice &l(){\n    auto t=p[4];\n    p[4]=nccw(p[1]);\n    p[1]=nccw(p[5]);\n    p[5]=nccw(p[3]);\n    p[3]=lr(nccw(t));\n    cw(p[2]);\n    ccw(p[0]);\n    return *this;\n  }\n  Dice &r(){\n    l();\n    l();\n    l();\n    return *this;\n  }\n};\n\nint main(){\n  for(;;){\n    Dice d;\n    if(!cin)break;\n    set<pair<int,Dice> >s{{0,d}};\n    for(auto e:s){\n      auto cd=e.second;\n      if(count(begin(cd.p[0])+6,begin(cd.p[0])+9,'*')&&count(begin(cd.p[2])+6,begin(cd.p[2])+9,'*')){\n\tcout<<e.first<<endl;\n\tgoto next;\n      }\n      s.insert({e.first+1,Dice(cd).u()});\n      s.insert({e.first+1,Dice(cd).r()});\n      s.insert({e.first+1,Dice(cd).d()});\n      s.insert({e.first+1,Dice(cd).l()});\n    }\n  next:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nchar dice[6][4] = {\n\t{5,2,1,4}, {1,1,3,0}, {0,3,2,2},\n\t{2,5,4,1}, {4,4,0,3}, {3,0,5,5}\n};\n\nint conv[6] = {2, 4, 5, 1, 0, 3};\nint mask[3][3] = {\n\t{ 9, 1, 3},\n\t{ 8, 0, 2},\n\t{12, 4, 6}\n};\nint front[3] = {0, 1, 4};\nint back[3]  = {2, 3, 5};\nint up[3][4] = {\n\t{5, 1, 4, 3},\n\t{5, 2, 4, 0},\n\t{2, 1, 0, 3}\n};\n\nint main(){\n\tint step[6][6];\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<pair<int, int>, int> > qu;\n\tqu.push(make_pair(make_pair(0, 2), 0));\n\tqu.push(make_pair(make_pair(0, 5), 0));\n\twhile(!qu.empty()){\n\t\tpair< pair<int,int>, int > p = qu.front(); qu.pop();\n\t\tint a = p.first.first, b = p.first.second, c = p.second;\n\t\tif(step[a][b] != -1) continue;\n\t\tstep[a][b] = c;\n\t\tfor(int i=0;i<4;i++)\n\t\t\tqu.push(make_pair(make_pair(dice[a][i], dice[b][i]), c+1));\n\t}\n\tstring str[6][3];\n\twhile(cin >> str[0][0]){\n\t\tif(str[0][0] == \"#\") break;\n\t\tcin >> str[0][1] >> str[0][2];\n\t\tfor(int i=1;i<6;i++)\n\t\t\tfor(int j=0;j<3;j++) cin >> str[i][i==5 ? 2-j : j];\n\t\tfor(int i=0;i<2;i++)\n\t\t\tfor(int j=0;j<3;j++) reverse(str[i][j].begin(), str[i][j].end());\n\t\tint ans = 1000000000;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint mf = 0, mb = 0;\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(str[front[i]][j][k] == '*') mf |= mask[j][k];\n\t\t\t\t\tif(str[back[i]][j][k]  == '*') mb |= mask[j][k];\n\t\t\t\t}\n\t\t\tint m = (mf&mb);\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(m&(1<<j)){\n\t\t\t\t\tans = min(ans, step[conv[up[i][j]]][conv[front[i]]]);\n\t\t\t\t\tans = min(ans, step[conv[up[i][j]]][conv[back[i]]]);\n\t\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nint Max(int &a,int b){return a=max(a,b);}\nint Min(int &a,int b){return a=min(a,b);}\n\n/*?????¬??????TOP?????????????????¢?????????*/\n/*TOP??¨BOTTOM???FRONT?????????????????¢?????????*/\n/************/\n/*  0       */\n/*  1 3 4 2 */\n/*  5       */\n/************/\nclass Cube{\npublic:\n  struct cdat{char num[3][3];};\n  const int TOP = 0, FRONT = 1, LEFT = 2;\n  const int RIGHT = 3, BACK = 4, BOTTOM = 5;\n  cdat cube[6];\n\n  void rot(string cmd){\n    if(cmd == \"N\") rotN();\n    else if(cmd == \"E\") rotE();\n    else if(cmd == \"S\") rotS();\n    else if(cmd == \"W\") rotW();\n    else if(cmd == \"CW\") rotCW();\n    else if(cmd == \"CCW\") rotCCW();\n    else exit(1);\n  }\n\n  void pr(){\n    map<int,string> M;\n    M[0] = \"TOP\",M[1] = \"FRONT\",M[2] = \"LEFT\";\n    M[3] = \"RIGHT\", M[4] = \"BACK\", M[5] = \"BOTTOM\";\n    for(int i=0;i<6;i++){\n      cout<<M[i]<<endl;\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++)cout<<cube[i].num[j][k];\n        cout<<endl;\n      }\n    }\n  }\n\n  void rot90(cdat &a){\n    cdat b = a;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++) a.num[i][j] = b.num[2-j][i];\n  }\n  void reverseX(cdat &a){for(int i=0;i<3;i++) reverse(a.num[i],a.num[i]+3);}\n  void reverseY(cdat &a){rot90(a),reverseX(a),rot90(a),rot90(a),rot90(a);}\n  \n\n  void rotN(){  //?\\\\?????¢??????\n    swap(cube[TOP],cube[FRONT]);\n    swap(cube[FRONT],cube[BOTTOM]);\n    swap(cube[BOTTOM],cube[BACK]);\n    rot90(cube[TOP]),rot90(cube[TOP]);\n    rot90(cube[BOTTOM]),rot90(cube[BOTTOM]),reverseX(cube[BOTTOM]);\n    rot90(cube[LEFT]),rot90(cube[LEFT]),rot90(cube[LEFT]);\n    rot90(cube[RIGHT]);\n  }\n\n\n  void rotCCW(){  //??????????????????????¨???????????????????\n    swap(cube[FRONT],cube[LEFT]);\n    swap(cube[LEFT],cube[BACK]);\n    swap(cube[BACK],cube[RIGHT]);\n    rot90(cube[TOP]),rot90(cube[TOP]),rot90(cube[TOP]);\n    rot90(cube[BOTTOM]),rot90(cube[BOTTOM]),rot90(cube[BOTTOM]);\n  }\n  \n  void rotE(){rotCCW();rotN();rotCW();}//????????¢??????\n  void rotS(){rotN(),rotN(),rotN();}//???????????¢??????\n  void rotW(){rotE(),rotE(),rotE();}//????????¢??????\n  void rotCW(){rotCCW(),rotCCW(),rotCCW();}//???????????????????¨????????????????\n};\n\nCube C;\nconst int TOP = 0, FRONT = 1, LEFT = 2;\nconst int RIGHT = 3, BACK = 4, BOTTOM = 5;\n\n\nbool check(const Cube &c){\n  bool front=0,back=0;\n  for(int i=0;i<3;i++) front |= c.cube[FRONT].num[2][i] == '*';\n  for(int i=0;i<3;i++) back |= c.cube[BACK].num[2][i] == '*';\n  return front && back;\n}\n\nstring dir[] = {\"N\",\"E\",\"S\",\"W\"};\nint ans;\nvoid dfs(int dep){\n  if(check(C)) ans = dep;\n  if(ans <= dep) return;\n  for(int i=0;i<4;i++){\n    C.rot(dir[i]);\n    dfs(dep+1);\n    C.rot(dir[(i+2)%4]);\n  }\n}\n\nsigned main(){\n  while(1){\n    int ord[]={FRONT,RIGHT,BACK,LEFT,TOP,BOTTOM};\n    for(int i=0;i<6;i++)\n      for(int j=0;j<3;j++)\n        for(int k=0;k<3;k++){\n          char ch;\n          cin>>ch;\n          if(ch == '#') return 0;\n          C.cube[ord[i]].num[j][k] = ch;\n        }\n\n    C.rot90(C.cube[TOP]);\n    C.rot90(C.cube[TOP]);\n    ans = 10;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\nchar a[100010][8][5][5],f,e,t=0,h[100010];\nint ck_goal(int f){\n    if((a[f][1][3][1]==0||a[f][1][3][2]==0||a[f][1][3][3]==0)&&(a[f][3][3][1]==0||a[f][3][3][2]==0||a[f][3][3][3]==0))return 1;return 0;\n}\nvoid ts(int f,int e,int u,int v){\n    int i,j;\n    for(i=1;i<=3;i++)\n        for(j=1;j<=3;j++)\n        a[e][v][i][j]=a[f][u][4-j][i];\n}\nvoid tn(int f,int e,int u,int v){\n    int i,j;\n    for(i=1;i<=3;i++)\n        for(j=1;j<=3;j++)\n        a[e][v][i][j]=a[f][u][j][4-i];\n}\nvoid od(int f,int e,int u,int v){\n    int i,j;\n    for(i=1;i<=3;i++)\n        for(j=1;j<=3;j++)\n        a[e][v][i][j]=a[f][u][i][j];\n}\nvoid add(int f,int e,int i){\n    if(i==1){od(f,e,1,5);od(f,e,5,3);od(f,e,3,6);od(f,e,6,1);ts(f,e,4,4);ts(f,e,2,2);}\n    if(i==2){tn(f,t,5,0);od(t,e,0,2);tn(f,t,2,0);od(t,e,0,6);ts(f,t,6,0);od(t,e,0,4);tn(f,t,4,0);od(t,e,0,5);ts(f,e,1,1);ts(f,e,3,3);}\n    if(i==3){od(f,e,1,6);od(f,e,6,3);od(f,e,3,5);od(f,e,5,1);tn(f,e,4,4);tn(f,e,2,2);}\n    if(i==4){tn(f,t,2,0);od(t,e,0,5);ts(f,t,6,0);od(t,e,0,2);ts(f,t,4,0);od(t,e,0,6);ts(f,t,5,0);od(t,e,0,4);tn(f,e,1,1);tn(f,e,3,3);}\n}\nint ck_re(int f){\n    int i,j,k,l;\n    for(l=1;l<=e;l++){\n        for(i=1;i<=6;i++)\n            for(j=1;j<=3;j++)\n                for(k=1;k<=3;k++)\n                    if(a[f][i][j][k]!=a[l][i][j][k])goto x;\n        return 0;\n        x:;\n    }\n    return 1;\n}\nint main()\n{\n    int i,j,k;\n    char c;\n    //freopen(\"test.txt\",\"r\",stdin);\n    while(scanf(\"%c\",&c)&&c!='#'){\n        memset(a,0,sizeof(a));\n        for(i=1;i<=6;i++)\n            for(j=1;j<=3;j++){\n                for(k=1;k<=3;k++)\n                {if(c=='.')a[1][i][j][k]=1;c=getchar();}\n                c=getchar();\n            }\n        h[1]=0;\n        if(ck_goal(1)){printf(\"%d\",h[1]);goto x2;}\n        f=0;e=1;\n        while(1){\n            f++;\n            for(i=1;i<=4;i++)\n                {\n                    //printf(\"%d\\n\",e+1);\n                    add(f,e+1,i);\n                    //for(l=1;l<=6;l++)for(j=1;j<=3;j++){for(k=1;k<=3;k++)printf(\"%d\",a[e+1][l][j][k]);printf(\"\\n\");}printf(\"\\n\");//e++;\n                    if(ck_re(e+1)){\n                        e++;\n                        h[e]=h[f]+1;\n                        if(ck_goal(e)){printf(\"%d\\n\",h[e]);goto x2;}\n                    }\n                }\n        }\n        x2:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int r=2;\n\nconst int f[r][55]={\n{0,46,47,48,49,50,51,52,53,54,16,13,10,17,14,11,18,15,12,45,44,43,42,41,40,39,38,37,30,33,36,29,32,35,28,31,34,1,2,3,4,5,6,7,8,9,27,26,25,24,23,22,21,20,19},\n//{0,29,29,30,31,32,33,34,35,36,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,39,42,45,38,41,44,37,40,43,52,49,46,53,50,47,54,51,48},\n{0,7,4,1,8,5,2,9,6,3,43,40,37,44,41,38,45,42,39,21,24,27,20,23,26,19,26,27,52,49,46,53,50,47,54,51,48,34,31,28,35,32,29,36,33,30,16,13,10,17,14,11,18,15,12}\n};\n\nlong long x,y;\nint m;\nchar s[10];\nset<long long> S;\nqueue<long long> Q1;\nqueue<long long> Q2;\n\nconst long long p1=(1LL<<7)|(1LL<<8)|(1LL<<9);\nconst long long p2=(1LL<<25)|(1LL<<26)|(1LL<<27);\n\nint main()\n{\n    while(scanf(\"%s\",s)==1&&s[0]!='#')\n    {\n        m=0;\n        x=0;\n        for(int i=0;i<3;i++)\n        {\n            m++;\n            if(s[i]=='*')x|=1LL<<m;\n        }\n        for(int ii=1;ii<18;ii++)\n        {\n            scanf(\"%s\",s);\n            for(int i=0;i<3;i++)\n            {\n                m++;\n                if(s[i]=='*')x|=1LL<<m;\n            }\n        }\n        S.clear();\n        while(!Q1.empty())Q1.pop();\n        while(!Q2.empty())Q2.pop();\n        S.insert(x);\n        Q1.push(x);\n        Q2.push(0);\n        while(!Q1.empty())\n        {\n            x=Q1.front();\n            m=Q2.front();\n            if((x&p1)&&(x&p2))\n            {\n                printf(\"%d\\n\",m);\n                break;\n            }\n            Q1.pop();\n            Q2.pop();\n            for(int i=0;i<r;i++)\n            {\n                y=0;\n                for(int j=1;j<=54;j++)\n                    if(x&(1LL<<j))y|=1LL<<f[i][j];\n                if(S.find(y)==S.end())\n                {\n                    S.insert(y);\n                    Q1.push(y);\n                    Q2.push(m+1);\n                }\n            }\n            for(int i=0;i<r;i++)\n            {\n                y=0;\n                for(int j=1;j<=54;j++)\n                    if(x&(1LL<<f[i][j]))y|=1LL<<j;\n                if(S.find(y)==S.end())\n                {\n                    S.insert(y);\n                    Q1.push(y);\n                    Q2.push(m+1);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\n\n\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「\nint rotateRight[]={0,1,3,5,2,4,6};\n// zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツキツヲテ・ツ崢榲ィツサツ「\nint rotateLeft[]={0,1,4,2,5,3,6};\n// テ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツ?ヲテ」ツδ榲」ツδε」ツδ?」ツ?凖」ツつ鞠aceテ」ツつ津ヲツ篠「テ」ツ??\n// curFaceテ」ツ?ォテァツオツ静ヲツ楪愿」ツつ津、ツサツ」テ・ツ?・\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // テ」ツ?禿」ツ?禿」ツ?ァテ・ツ按、テ・ツョツ?\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // テ・ツキツヲテ」ツ?クテ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツつ津・ツ?津」ツ??\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // テ・ツ可催」ツ?クテ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツつ津・ツ?津」ツ??\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // テ」ツ?禿」ツ?禿」ツ?ァテ・ツ按、テ・ツョツ?\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // zティツサツクテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ渉ウテ・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // テ・ツ崢榲ィツサツ「テァツオツ静ヲツ楪愿」ツつ稚mpFaceテ」ツ?ォテ・ツ渉催ヲツ伉?\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++){\n          for(int l=0;l<3;l++){\n            nfield[l][2-k]=field[i-1][j][k][l];\n          }\n        }\n        // fieldテ」ツつ津・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツつ?\n        for(int k=0;k<3;k++)\n          for(int l=0;l<3;l++)\n            field[i][j][k][l]=nfield[l][k];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    //cout<<\"a\"<<endl;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      //cout<<front<<\" \"<<top<<endl;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n      int cnt2=0;\n      for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // テゥツ敖「テ」ツつ津・ツ崢崚ヲツ鳴ケテ・ツ青妥」ツ?ォテ・ツ崢榲ィツサツ「\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // テ・ツ可?\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // テ・ツセツ古」ツつ?\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n    //cout<<\"end\"<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvector<vs>in(6,vs(3));\nstring q=\"201133221122\";\nint w[]={2,2,1};\nint main(){\n\twhile(1){\n\t\tstring t;cin>>t;\n\t\tif(t==\"#\")return 0;\n\t\trep(i,6)rep(j,3){\n\t\t\tif(i+j==0)in[i][j]=t;\n\t\t\telse cin>>in[i][j];\n\t\t}\n\t\trep(i,3){\n\t\t\treverse(all(in[2][i]));\n\t\t\treverse(all(in[3][i]));\n\t\t}\n\t\trep(i,3)\n\t\t\tswap(in[5][0][i],in[5][2][i]);\n\n\t\tint out=inf;\n\t\trep(E,3)rep(k,2)rep(e,2){\n\t\t\tint j=0,i=E;\n\t\t\tif(e)j=2;\n\t\t\tif(E==2)i=4;\n\t\t\tbool h=true;\n\t\t\tbool H=false;\n\t\t\trep(l,3)if(k&&in[i][l][j]=='*'||!k&&in[i][j][l]=='*')H=true;\n\t\t\tif(!H)h=false;\n\t\t\tH=false;\n\t\t\trep(l,3)if(k&&in[i+w[E]][l][j]=='*'||!k&&in[i+w[E]][j][l]=='*')H=true;\n\t\t\tif(!H)h=false;\n\t\t\tif(h)out=min(out,q[E*4+k*2+e]-'0');\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vl vector<ll>\n#define vs vector<string>\n\n#define vc vector<char>\n#define C vector<vc>\n\nC c;\nmap<C,int> M;\n\nvc r90(vc v){\n\tvc r;\n\trep(i,3)for(int j=2;j>=0;j--)r.pb(v[j*3+i]);\n\treturn r;\n}\n\nvc l90(vc v){\n\tvc r;\n\tfor(int i=2;i>=0;i--)rep(j,3)r.pb(v[j*3+i]);\n\treturn r;\n}\n\nvc r180(vc v){\n\tvc r;\n\tfor(int i=2;i>=0;i--)for(int j=2;j>=0;j--)r.pb(v[i*3+j]);\n\treturn r;\n}\n\nC rotf(C c){\n\tC r;\n\tr.pb(c[5]);\n\tr.pb(r90(c[1]));\n\tr.pb(r180(c[4]));\n\tr.pb(l90(c[3]));\n\tr.pb(c[0]);\n\tr.pb(r180(c[2]));\n\treturn r;\n}\n\nC rotr(C c){\n\tC r;\n\tr.pb(r90(c[0]));\n\tr.pb(r90(c[4]));\n\tr.pb(l90(c[2]));\n\tr.pb(r90(c[5]));\n\tr.pb(r90(c[3]));\n\tr.pb(r90(c[1]));\n\treturn r;\n}\n\nC rotba(C c){\n\tC r;\n\tr.pb(c[4]);\n\tr.pb(l90(c[1]));\n\tr.pb(r180(c[5]));\n\tr.pb(r90(c[3]));\n\tr.pb(r180(c[2]));\n\tr.pb(c[0]);\n\treturn r;\n}\n\nC rotl(C c){\n\tC r;\n\tr.pb(l90(c[0]));\n\tr.pb(l90(c[5]));\n\tr.pb(r90(c[2]));\n\tr.pb(l90(c[4]));\n\tr.pb(l90(c[1]));\n\tr.pb(l90(c[3]));\n\treturn r;\n}\n\nint main(){\n\tc.resize(6);\n\trep(i,6)c[i].resize(9);\n\twhile(cin>>c[0][0]){\n\t\tif(c[0][0]=='#')break;\n\t\trep(i,8)cin>>c[0][i+1];\n\t\trep(i,5)rep(j,9)cin>>c[i+1][j];\n\t\tqueue<C> Q;\n\t\tM[c]=0;\n\t\tQ.push(c);\n\t\twhile(1){\n\t\t\tC c=Q.front();Q.pop();\n\t\t\tint s=M[c];\n\t\t\tif((c[0][6]=='*'||c[0][7]=='*'||c[0][8]=='*')&&(c[2][6]=='*'||c[2][7]=='*'||c[2][8]=='*')){\n\t\t\t\tcout<<s<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tC c0=rotf(c),c1=rotr(c),c2=rotba(c),c3=rotl(c);\n\t\t\tif(M.find(c0)==M.end())M[c0]=s+1,Q.push(c0);\n\t\t\tif(M.find(c1)==M.end())M[c1]=s+1,Q.push(c1);\n\t\t\tif(M.find(c2)==M.end())M[c2]=s+1,Q.push(c2);\n\t\t\tif(M.find(c3)==M.end())M[c3]=s+1,Q.push(c3);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nchar ch[25][10];\nchar s[20];\nvoid done()\n{   for(int i=0;i<3;i++)\n    if(ch[2][i]=='*'&&ch[8][i]=='*') {cout<<\"0\"<<endl;return;}\n     for(int i=0;i<3;i++)\n    if(ch[i][0]=='*'&&ch[i+6][0]=='*'||ch[i][2]=='*'&&ch[i+6][2]=='*') {cout<<\"1\"<<endl;return;}\n\n    for(int i=0;i<3;i++)\n    if(ch[14][i]=='*'&&ch[17][i]=='*'||ch[12][i]=='*'&&ch[15][i]=='*') {cout<<\"1\"<<endl;return;}\n\n    for(int i=0;i<3;i++)\n    if(ch[0][i]=='*'&&ch[6][i]=='*') {cout<<\"2\"<<endl;return;}\n\n\n\n    if(ch[12][0]=='*'&&ch[15][0]=='*'||ch[12][2]=='*'&&ch[15][2]=='*') {cout<<\"2\"<<endl;return;}\n    if(ch[13][0]=='*'&&ch[16][0]=='*'||ch[13][2]=='*'&&ch[16][2]=='*') {cout<<\"2\"<<endl;return;}\n    if(ch[14][0]=='*'&&ch[17][0]=='*'||ch[14][2]=='*'&&ch[17][2]=='*') {cout<<\"2\"<<endl;return;}\n     for(int i=0;i<3;i++)\n    if(ch[i+3][0]=='*'&&ch[i+9][0]=='*'||ch[i+3][2]=='*'&&ch[i+9][2]=='*') {cout<<\"2\"<<endl;return;}\n\n    cout<<\"3\"<<endl;\n    return;\n\n}\nint main()\n{  int k=0;\n//freopen(\"in\",\"r\",stdin);\n    while(scanf(\"%s\",s)>0)\n    { //cout<<s<<endl;\n\n        if(s[0]=='#') break;\n//cout<<s<<endl;\n        for(int i=0;i<5;i++)\n          ch[k][i]=s[i];\n        k++;\n\n\n        if(k==18)\n        {\n        k=0;\n        done();\n        }\n\n\n//cout<<\"k=\"<<k<<endl;\n\n\n\n\n    }\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n#define MAXN 3\n#define MAXM 120000\n#define FI first\n#define SE second\nconst int INF =1000000007;\nmap<int,int> ma;\nchar dice[6][MAXN][MAXN];\nint ans=0,now[6];\nconst int rcmp[6][4]={{0,2,5,2},{0,2,4,0},{1,3,5,2},{1,3,4,0},{4,5,0,2},{4,5,2,0}};\nconst int ccmp[6][4]={{0,2,1,2},{0,2,3,0},{1,3,2,2},{1,3,0,0},{4,5,1,2},{4,5,3,0}};\nconst int from[4][6]={{4,1,5,3,2,0},{0,4,2,5,3,1},{5,1,4,3,0,2},{0,5,2,4,1,3}};\nbool check(int dep)\n{\n    int t=0;\n    for(int i=0;i<6;++i)    t=t*6+now[i];\n    if(ma.find(t)!=ma.end()&&ma[t]<dep) return    false;\n    ma[t]=dep;\n    return true;\n}\nvoid dfs(int dep)\n{\n    if(dep>=ans)    return ;\n    bool flag=false;\n\n    for(int k=0;k<6;++k)\n        if((rcmp[k][0]==now[0]&&rcmp[k][1]==now[2]||rcmp[k][0]==now[2]&&rcmp[k][1]==now[0])&&rcmp[k][2]==now[5])\n        {\n            int a=rcmp[k][0],c=rcmp[k][3];\n            for(int i=0;i<3;++i)\n                flag|=dice[a][c][i]=='*';\n            break;\n        }\n    for(int k=0;k<6;++k)\n        if((ccmp[k][0]==now[0]&&ccmp[k][1]==now[2]||ccmp[k][0]==now[2]&&ccmp[k][1]==now[0])&&ccmp[k][2]==now[5])\n        {\n            int a=ccmp[k][0],c=ccmp[k][3];\n            for(int i=0;i<3;++i)\n                flag|=dice[a][i][c]=='*';\n            break;\n        }\n    if(flag)\n    {\n        ans=min(ans,dep);\n        return ;\n    }\n    int tnow[6];\n    memcpy(tnow,now,sizeof(now));\n    for(int i=0;i<4;++i)\n    {\n        for(int j=0;j<6;++j)    now[j]=tnow[from[i][j]];\n        dfs(dep+1);\n    }\n}\nint main()\n{\n    //freopen(\"J:\\\\Mydocument\\\\Code\\\\input.txt\",\"r\",stdin);\n    char tmp[4];\n    while(1)\n    {\n        for(int i=0;i<6;++i)\n            for(int j=0;j<3;++j)\n            {\n                scanf(\"%s\",tmp);\n                for(int k=0;k<3;++k)    dice[i][j][k]=tmp[k];\n            }\n        if(dice[0][0][0]=='#')   break;\n        ans=10;\n        for(int i=0;i<2;++i)\n            for(int j=0;j<3;++j)\n                for(int k=0;k<3;++k)\n                    dice[i][j][k]=(dice[i][j][k]=='*' ||dice[i+2][j][2-k]=='*')?'*':'.';\n        for(int j=0;j<3;++j)\n            for(int k=0;k<3;++k)\n                dice[4][j][k]=(dice[4][j][k]=='*'||dice[5][2-j][k]=='*')?'*':'.';\n        for(int i=0;i<6;++i)    now[i]=i;\n        dfs(0);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<int, int> state;\n\nchar maz[6][5][5];\nint fac[10];\n//0 - right\n//1 - left\n//2 - front\n//2 - back\nint rotate_id[4][6] = {\n\t{0, 4, 2, 5, 3, 1},\n\t{0, 5, 2, 4, 1, 3},\n\t{4, 1, 5, 3, 2, 0}, \n\t{5, 1, 4, 3, 0, 2}\n};\n\nint rotate_face[4][6] = {\n\t{1, 1, 1, 1, 1, 1}, \n\t{3, 3, 1, 3, 3, 3},\n\t{0, 3, 2, 1, 0, 2},\n\t{0, 1, 2, 3, 2, 0}\n};\n\nint encode(int id[], int face[]) {\n\tint t = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tt += (id[i] * 4 + face[i]) * fac[i];\n\t}\n\treturn t;\n}\n\nvoid decode(int t, int id[], int face[]) {\n\tfor (int i = 5; i >= 0; i--) {\n\t\tint tmp = t / fac[i];\n\t\tid[i] = tmp / 4;\n\t\tface[i] = tmp % 4;\n\t\tt %= fac[i];\n\t}\n}\n\nvoid rotate(int now, int op, int new_id[], int new_face[]) {\n\tint id[6], face[6];\n\tdecode(now, id, face);\n\tfor (int i = 0; i < 6; i++) {\n\t\tnew_id[i] = id[rotate_id[op][i]];\n\t\tnew_face[i] = (face[rotate_id[op][i]] + rotate_face[op][rotate_id[op][i]]) % 4;\n\t}\n}\n\nvoid rotate_maz(int id, int face, char new_maz[3][3]) {\n\tchar tmp[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tnew_maz[i][j] = tmp[i][j] = maz[id][i][j];\n\t\t}\n\t}\n\tfor (int k = 0; k < face; k++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tnew_maz[i][j] = tmp[2 - j][i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\ttmp[i][j] = new_maz[i][j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool check(int t) {\n\tint id[6], face[6];\n\tdecode(t, id, face);\n\tbool f1 = false, f2 = false;\n\tchar new_maz[3][3];\n\trotate_maz(id[0], face[0], new_maz);\n\tfor (int i = 0; i < 3; i++) {\n\t\tf1 |= new_maz[2][i] == '*';\n\t}\n\trotate_maz(id[2], face[2], new_maz);\n\tfor (int i = 0; i < 3; i++) {\n\t\tf2 |= new_maz[2][i] == '*';\n\t}\n\treturn f1 & f2;\n}\n\nint bfs(int init_state) {\n\tstate.clear();\n\tqueue<int> que;\n\tque.push(init_state);\n\tint id[6], face[6];\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\t//cout << now << endl;\n\t\tif (check(now)) return state[now];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\trotate(now, i, id, face);\n\t\t\tint next = encode(id, face);\n\t\t\tif (state.count(next) > 0) continue;\n\t\t\tstate[next] = state[now] + 1;\n\t\t\tque.push(next);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= 6; i++) fac[i] = fac[i - 1] * 24;\n\twhile (~scanf(\"%s\", maz[0][0])) {\n\t\tif (maz[0][0][0] == '#') break;\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tif (i == 0 && j == 0) continue;\n\t\t\t\tscanf(\"%s\", maz[i][j]);\n\t\t\t}\n\t\t}\n\t\tint id[6], face[6];\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tid[i] = i, face[i] = 0;\n\t\t}\n\t\tint init_state = encode(id, face);\n\t\t//cout << init_state << endl;\n\t\tint ans = bfs(init_state);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#ifdef __GNUC__\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T val){\n  val = val - ((val >> 1) & 0x55555555);\n  val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n  val = (val + (val >> 4)) & 0x0f0f0f0f;\n  val += val >> 8;\n  val += val >> 16;\n  return (int)(val & 0x0000003f);\n}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nll getTen(int a){return (a<=0)?1:(getTen(a-1)*10);}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\ntypedef pair<ll,ll> pll;\n\n\nint angs[7][7];\nconst int label[]={0,5,2,1,3,4,6};\n\n\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// z軸を中心に右回転\nint rotateRight[]={0,1,3,5,2,4,6};\n// z軸を中心に左回転\nint rotateLeft[]={0,1,4,2,5,3,6};\n// 回転させてマッチするfaceを探す\n// curFaceに結果を代入\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // 左へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // 前へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\n\n\nchar field[10][10][10][10];\nint main(){\n  angs[3][5]=0;\n  angs[3][2]=1;\n  angs[3][6]=2;\n  angs[3][4]=3;\n  \n  angs[1][5]=0;\n  angs[1][4]=1;\n  angs[1][6]=2;\n  angs[1][2]=3;\n\n  angs[2][5]=0;\n  angs[2][1]=1;\n  angs[2][6]=2;\n  angs[2][3]=3;\n  \n  angs[4][5]=0;\n  angs[4][3]=1;\n  angs[4][6]=2;\n  angs[4][1]=3;\n\n  angs[5][3]=0;\n  angs[5][4]=1;\n  angs[5][1]=2;\n  angs[5][2]=3;\n  \n  angs[6][1]=0;\n  angs[6][4]=1;\n  angs[6][3]=2;\n  angs[6][2]=3;\n\n  while(1){\n    for(int i=1;i<=6;i++){\n      for(int j=0;j<3;j++){\n        for(int k=0;k<3;k++){\n          cin>>field[0][i][j][k];\n          if(field[0][i][j][k]=='#')return 0;\n        }\n      }\n    }\n    for(int i=1;i<4;i++){\n      for(int j=1;j<=6;j++){\n        char nfield[10][10];\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)nfield[l][2-k]=field[i-1][j][k][l];\n        // fieldを回転させる\n        for(int k=0;k<3;k++)for(int l=0;l<3;l++)field[i][j][k][l]=nfield[l][k];\n      }\n    }\n    int cost[10][10];\n    queue<pii> q;\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cost[i][j]=-1;\n    q.push(pii(3,1));\n    cost[3][1]=0;\n    while(q.size()){\n      pii p=q.front();q.pop();\n      int front=p.first;\n      int back=7-p.first;\n      int top=p.second;\n      int ang=angs[label[front]][label[top]];\n      int cnt1=0;\n      int cnt2=0;\n      if(label[front]>=1&&label[front]<=4){\n        if(ang==0||ang==3){\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n        }\n        else{\n          for(int j=0;j<3;j++)cnt1+=(field[ang][label[front]][2][j]=='*');\n          for(int j=0;j<3;j++)cnt2+=(field[(ang+2)%4][label[back]][2][j]=='*');\n        }\n      }\n      else{\n        for(int j=0;j<3;j++)cnt1+=(field[(ang+2)%4][label[front]][2][j]=='*');\n        for(int j=0;j<3;j++)cnt2+=(field[ang][label[back]][2][j]=='*');\n      }\n      if(cnt1>0&&cnt2>0){\n        cout<<cost[front][top]<<endl;\n        break;\n      }\n      // 面を四方向に回転\n      int tmpFaces[10];\n      int nTmpFaces[10];\n      setFace(tmpFaces,front,top);\n      // 前\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // 後ろ\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[backR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // left\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n      // right\n      {\n        for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rightR[l]];\n        int nFront=nTmpFaces[3];\n        int nTop=nTmpFaces[1];\n        if(cost[nFront][nTop]==-1){\n          cost[nFront][nTop]=cost[front][top]+1;\n          q.push(pii(nFront,nTop));\n        }\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Face {\n  char face[3][3];\n  bool operator<(const Face &rhs) const {\n    REP(y, 3) REP(x, 3) {\n      if (face[y][x] != rhs.face[y][x]) {\n        return face[y][x] < rhs.face[y][x];\n      }\n    }\n    return false;\n  }\n  bool operator!=(const Face &rhs) const {\n    return *this < rhs || rhs < *this;\n  }\n};\n\nvoid rotation(Face &f, int x) {\n  if (x == 0) { return; }\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - x][y];\n  }\n  f = ret;\n  rotation(f, x - 1);\n}\n\nvoid reverse(Face &f) {\n  Face ret;\n  REP(y, 3) REP(x, 3) {\n    ret.face[y][x] = f.face[2 - y][x];\n  }\n  f = ret;\n}\n\nstruct Dice {\n  Face face[6];\n  bool operator<(const Dice &rhs) const {\n    REP(i, 6) { if (face[i] != rhs.face[i]) { return face[i] < rhs.face[i]; } }\n    return false;\n  }\n};\n\nDice rotation(const Dice &d, int dir, int x) {\n  if (x == 0) { return d; }\n  Dice ret = d;\n  if (dir >= 2) { return rotation(ret, dir - 2, 4 - x); }\n  if (dir == 0) {\n    ret.face[0] = d.face[5];\n    rotation(ret.face[0], 0);\n    ret.face[1] = d.face[1];\n    rotation(ret.face[1], 1);\n    ret.face[2] = d.face[4];\n    rotation(ret.face[2], 2);\n    ret.face[3] = d.face[3];\n    rotation(ret.face[3], 1);\n    ret.face[4] = d.face[0];\n    rotation(ret.face[4], 0);\n    ret.face[5] = d.face[2];\n    rotation(ret.face[5], 2);\n  } else {\n    ret.face[0] = d.face[0];\n    rotation(ret.face[0], 1);\n    ret.face[1] = d.face[4];\n    rotation(ret.face[1], 3);\n    ret.face[2] = d.face[2];\n    rotation(ret.face[2], 1);\n    ret.face[3] = d.face[5];\n    rotation(ret.face[3], 1);\n    ret.face[4] = d.face[3];\n    rotation(ret.face[4], 3);\n    ret.face[5] = d.face[1];\n    rotation(ret.face[5], 1);\n  }\n  return rotation(ret, dir, x - 1);\n}\n\nbool ok(const Dice &d) {\n  bool ret1 = false;\n  bool ret2 = false;\n  REP(x, 3) {\n    ret1 |= d.face[0].face[2][x] == '*';\n    ret2 |= d.face[2].face[2][x] == '*';\n  }\n  return ret1 && ret2;\n}\n\nvoid print(const Dice &d) {\n  REP(iter, 6) {\n    REP(y, 3) {\n      REP(x, 3) {\n        putchar(d.face[iter].face[y][x]);\n      }\n      puts(\"\");\n    }\n  }\n  puts(\"\");\n}\n\nmap<Dice, int> memo;\n\nint calc(Dice d) {\n  if (memo.count(d)) { return memo[d]; }\n  if (ok(d)) { return 0; }\n  memo[d] = 100;\n  int ret = 100;\n  REP(dir, 4) {\n    Dice nd = rotation(d, dir, 1);\n    ret = min(ret, 1 + calc(nd));\n  }\n  return memo[d] = ret;\n}\n\n\nint main() {\n  while (true) {\n    memo.clear();\n    Dice d;\n    REP(iter, 6) {\n      REP(y, 3) REP(x, 3) {\n        char c;\n        scanf(\" %c \", &c);\n        if (c == '#') { return 0; }\n        d.face[iter].face[y][x] = c;\n      }\n    }\n    printf(\"%d\\n\", calc(d));\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar dice[8][5][5];\nint i,j,res,flag1,flag2;\nint MIN(int x,int y){ return x<y?x:y; }\nint input()\n{\n    for(i=1;i<=6;i++)\n        for(j=2;j>=0;j--)\n        {\n            scanf(\"%s\",dice[i][j]);\n            if(i==1&&j==2&&dice[i][j][0]=='#') return 0;\n        }\n    return 1;\n}\nvoid f1(int a,int b)\n{\n    for(flag1=i=0;i<3;i++) if(dice[a][b][i]=='*') flag1=1;\n}\nvoid f2(int a,int b)\n{\n    for(flag2=i=0;i<3;i++) if(dice[a][b][i]=='*') flag2=1;\n}\nvoid f3(int a,int b)\n{\n    for(flag1=i=0;i<3;i++) if(dice[a][i][b]=='*') flag1=1;\n}\nvoid f4(int a,int b)\n{\n    for(flag2=i=0;i<3;i++) if(dice[a][i][b]=='*') flag2=1;\n}\nvoid C(int x)\n{\n    if(flag1&&flag2) res=MIN(res,x);\n}\nint main()\n{\n    while(input())\n    {\n        res=9;\n\n        f1(1,0),f2(3,0),C(0);\n        f1(1,2),f2(3,2),C(2);\n        f3(1,0),f4(3,2),C(1);\n        f3(1,2),f4(3,0),C(1);\n\n        f1(2,0),f2(4,0),C(3);\n        f1(2,2),f2(4,2),C(3);\n        f3(2,0),f4(4,2),C(2);\n        f3(2,2),f4(4,0),C(2);\n\n        f1(5,0),f2(6,2),C(1);\n        f1(5,2),f2(6,0),C(1);\n        f3(5,0);\n        for(flag2=i=0;i<3;i++) if(dice[6][2-i][0]=='*') flag2=1;\n        C(2);\n        f3(5,2);\n        for(flag2=i=0;i<3;i++) if(dice[6][2-i][2]=='*') flag2=1;\n        C(2);\n\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar s[4], ju[6];\n\nint judge()\n{\n    if (ju[0]&1 && ju[2]&1) return 0;\n    if (ju[0]&2 && ju[2]&8) return 1;\n    if (ju[0]&8 && ju[2]&2) return 1;\n    if (ju[4]&1 && ju[5]&4) return 1;\n    if (ju[4]&4 && ju[5]&1) return 1;\n    if (ju[4]&2 && ju[5]&2) return 2;\n    if (ju[4]&8 && ju[5]&8) return 2;\n    if (ju[0]&4 && ju[2]&4) return 2;\n    if (ju[1]&2 && ju[3]&8) return 2;\n    if (ju[1]&8 && ju[3]&2) return 2;\n    return 3;\n}\n\nint main()\n{\n    char i, j, k;\n    for(;;)\n    {\n        memset(ju, 0, sizeof(ju));\n        for (i = 0; i < 6; i++)\n        {\n            for (j = 0; j < 3; j++)\n            {\n                scanf(\"%s\", s);\n                if (s[0] == '#') return 0;\n                for (k = 0; k < 3; k++)\n                {\n                    if (s[k] == '*')\n                    {\n                        if (j == 0) ju[i] |= 4;\n                        if (j == 2) ju[i] |= 1;\n                        if (k == 0) ju[i] |= 8;\n                        if (k == 2) ju[i] |= 2;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", judge());\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar dice[8][5][5];\nint i,j,res,f[3];\nint MIN(int x,int y){ return x<y?x:y; }\nint input()\n{\n    for(i=1;i<=6;i++)\n        for(j=2;j>=0;j--)\n        {\n            scanf(\"%s\",dice[i][j]);\n            if(i==1&&j==2&&dice[i][j][0]=='#') return 0;\n        }\n    return 1;\n}\nvoid f1(int a,int b,int m)\n{\n    for(f[m]=i=0;i<3;i++) if(dice[a][b][i]=='*') f[m]=1;\n}\nvoid f3(int a,int b,int m)\n{\n    for(f[m]=i=0;i<3;i++) if(dice[a][i][b]=='*') f[m]=1;\n}\nvoid C(int x)\n{\n    if(f[1]&&f[2]) res=MIN(res,x);\n}\nint main()\n{\n    while(input())\n    {\n        res=9;\n\n        f1(1,0,1),f1(3,0,2),C(0);\n        f1(1,2,1),f1(3,2,2),C(2);\n        f3(1,0,1),f3(3,2,2),C(1);\n        f3(1,2,1),f3(3,0,2),C(1);\n\n        f1(2,0,1),f1(4,0,2),C(3);\n        f1(2,2,1),f1(4,2,2),C(3);\n        f3(2,0,1),f3(4,2,2),C(2);\n        f3(2,2,1),f3(4,0,2),C(2);\n\n        f1(5,0,1),f1(6,2,2),C(1);\n        f1(5,2,1),f1(6,0,2),C(1);\n        f3(5,0,1);\n        for(f[2]=i=0;i<3;i++) if(dice[6][2-i][0]=='*') f[2]=1;\n        C(2);\n        f3(5,2,1);\n        for(f[2]=i=0;i<3;i++) if(dice[6][2-i][2]=='*') f[2]=1;\n        C(2);\n\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar dice[8][5][5];\nint i,j,res,f[3];\nint MIN(int x,int y){ return x<y?x:y; }\nint input()\n{\n    for(i=1;i<=6;i++)\n        for(j=2;j>=0;j--)\n        {\n            scanf(\"%s\",dice[i][j]);\n            if(i==1&&j==2&&dice[i][j][0]=='#') return 0;\n        }\n    return 1;\n}\nvoid f1(int a,int b,int m)\n{\n    for(f[m]=i=0;i<3;i++) if(dice[a][b][i]=='*') f[m]=1;\n}\nvoid f2(int a,int b,int m)\n{\n    for(f[m]=i=0;i<3;i++) if(dice[a][b][i]=='*') f[m]=1;\n}\nvoid f3(int a,int b,int m)\n{\n    for(f[m]=i=0;i<3;i++) if(dice[a][i][b]=='*') f[m]=1;\n}\nvoid f4(int a,int b,int m)\n{\n    for(f[m]=i=0;i<3;i++) if(dice[a][i][b]=='*') f[m]=1;\n}\nvoid C(int x)\n{\n    if(f[1]&&f[2]) res=MIN(res,x);\n}\nint main()\n{\n    while(input())\n    {\n        res=9;\n\n        f1(1,0,1),f2(3,0,2),C(0);\n        f1(1,2,1),f2(3,2,2),C(2);\n        f3(1,0,1),f4(3,2,2),C(1);\n        f3(1,2,1),f4(3,0,2),C(1);\n\n        f1(2,0,1),f2(4,0,2),C(3);\n        f1(2,2,1),f2(4,2,2),C(3);\n        f3(2,0,1),f4(4,2,2),C(2);\n        f3(2,2,1),f4(4,0,2),C(2);\n\n        f1(5,0,1),f2(6,2,2),C(1);\n        f1(5,2,1),f2(6,0,2),C(1);\n        f3(5,0,1);\n        for(f[2]=i=0;i<3;i++) if(dice[6][2-i][0]=='*') f[2]=1;\n        C(2);\n        f3(5,2,1);\n        for(f[2]=i=0;i<3;i++) if(dice[6][2-i][2]=='*') f[2]=1;\n        C(2);\n\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar dice[8][5][5];\nint MIN(int x,int y){ return x<y?x:y; }\nint input()\n{\n    int i,j;\n    for(i=1;i<=6;i++)\n    {\n        for(j=2;j>=0;j--)\n        {\n            scanf(\"%s\",dice[i][j]);\n            if(i==1&&j==2&&dice[i][j][0]=='#') return 0;\n        }\n    }\n    return 1;\n}\nint main()\n{\n    int i,res,flag1,flag2;\n\n    while(input())\n    {\n        res=10000;\n\n        for(flag1=i=0;i<3;i++) if(dice[1][0][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[3][0][i]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,0);\n        for(flag1=i=0;i<3;i++) if(dice[1][2][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[3][2][i]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,2);\n        for(flag1=i=0;i<3;i++) if(dice[1][i][0]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[3][i][0]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,1);\n        for(flag1=i=0;i<3;i++) if(dice[1][i][2]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[3][i][2]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,1);\n\n        for(flag1=i=0;i<3;i++) if(dice[2][0][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[4][0][i]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,3);\n        for(flag1=i=0;i<3;i++) if(dice[2][2][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[4][2][i]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,3);\n        for(flag1=i=0;i<3;i++) if(dice[2][i][0]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[4][i][2]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,2);\n        for(flag1=i=0;i<3;i++) if(dice[2][i][2]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[4][i][0]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,2);\n\n        for(flag1=i=0;i<3;i++) if(dice[5][0][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][2][i]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,1);\n        for(flag1=i=0;i<3;i++) if(dice[5][2][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][0][i]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,1);\n        for(flag1=i=0;i<3;i++) if(dice[5][i][0]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][i][0]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,2);\n        for(flag1=i=0;i<3;i++) if(dice[5][i][2]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][i][2]=='*') flag2=1;\n        if(flag1&&flag2) res=MIN(res,2);\n\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar dice[8][5][5];\nint i,j,res,flag1,flag2;\nint MIN(int x,int y){ return x<y?x:y; }\nint input()\n{\n    for(i=1;i<=6;i++)\n    {\n        for(j=2;j>=0;j--)\n        {\n            scanf(\"%s\",dice[i][j]);\n            if(i==1&&j==2&&dice[i][j][0]=='#') return 0;\n        }\n    }\n    return 1;\n}\nvoid f1(int a,int b)\n{\n    for(flag1=i=0;i<3;i++) if(dice[a][b][i]=='*') flag1=1;\n}\nvoid f2(int a,int b)\n{\n    for(flag2=i=0;i<3;i++) if(dice[a][b][i]=='*') flag2=1;\n}\nvoid f3(int a,int b)\n{\n    for(flag1=i=0;i<3;i++) if(dice[a][i][b]=='*') flag1=1;\n}\nvoid f4(int a,int b)\n{\n    for(flag2=i=0;i<3;i++) if(dice[a][i][b]=='*') flag2=1;\n}\nvoid C(int x)\n{\n    if(flag1&&flag2) res=MIN(res,x);\n}\nint main()\n{\n    while(input())\n    {\n        res=10000;\n\n        f1(1,0),f2(3,0),C(0);\n        f1(1,2),f2(3,2),C(2);\n        f3(1,0),f4(3,2),C(1);\n        f3(1,2),f4(3,0),C(1);\n\n        f1(2,0),f2(4,0),C(3);\n        f1(2,2),f2(4,2),C(3);\n        f3(2,0),f4(4,2),C(2);\n        f3(2,2),f4(4,0),C(2);\n\n        for(flag1=i=0;i<3;i++) if(dice[5][0][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][2][i]=='*') flag2=1;\n        C(1);\n        for(flag1=i=0;i<3;i++) if(dice[5][2][i]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][0][i]=='*') flag2=1;\n        C(1);\n        for(flag1=i=0;i<3;i++) if(dice[5][i][0]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][2-i][0]=='*') flag2=1;\n        C(2);\n        for(flag1=i=0;i<3;i++) if(dice[5][i][2]=='*') flag1=1;\n        for(flag2=i=0;i<3;i++) if(dice[6][2-i][2]=='*') flag2=1;\n        C(2);\n\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t// z[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (z[i] == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (z[i] == 1 || z[i] == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][0][j] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][0][j] == '*') {\n\t\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][2][j] == '*') {\n\t\t\t\t\t\t\t// System.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n\t\t\t\t\t\t// System.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tboolean[][][] dice = new boolean[6][3][3];\n\t\n\tint minrote(int n) {\n\t\tif (n == 0) {\n\t\t\tif ((dice[0][2][0] || dice[0][2][1] || dice[0][2][2]) && (dice[2][2][0] || dice[2][2][1] || dice[2][2][2]))\n\t\t\t\treturn 0;\n\t\t\tif ((dice[0][0][2] || dice[0][1][2] || dice[0][2][2]) && (dice[2][0][0] || dice[2][1][0] || dice[2][2][0]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[0][0][0] || dice[0][1][0] || dice[0][2][0]) && (dice[2][0][2] || dice[2][1][2] || dice[2][2][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[0][0][0] || dice[0][0][1] || dice[0][0][2]) && (dice[2][0][0] || dice[2][0][1] || dice[2][0][2]))\n\t\t\t\treturn 2;\n\t\t}\n\t\tif (n == 1) {\n\t\t\tif ((dice[1][0][2] || dice[1][1][2] || dice[1][2][2]) && (dice[3][0][0] || dice[3][1][0] || dice[3][2][0]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[1][0][0] || dice[1][1][0] || dice[1][2][0]) && (dice[3][0][2] || dice[3][1][2] || dice[3][2][2]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[1][2][0] || dice[1][2][1] || dice[1][2][2]) && (dice[3][2][0] || dice[3][2][1] || dice[3][2][2]))\n\t\t\t\treturn 3;\n\t\t\tif ((dice[1][0][0] || dice[1][0][1] || dice[1][0][2]) && (dice[3][0][0] || dice[3][0][1] || dice[3][0][2]))\n\t\t\t\treturn 3;\n\t\t}\n\t\tif (n == 2) {\n\t\t\tif ((dice[4][2][0] || dice[4][2][1] || dice[4][2][2]) && (dice[5][0][0] || dice[5][0][1] || dice[5][0][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[4][0][0] || dice[4][0][1] || dice[4][0][2]) && (dice[5][2][0] || dice[5][2][1] || dice[5][2][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[4][0][2] || dice[4][1][2] || dice[4][2][2]) && (dice[5][0][2] || dice[5][1][2] || dice[5][2][2]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[4][0][0] || dice[4][1][0] || dice[4][2][0]) && (dice[5][0][0] || dice[5][1][0] || dice[5][2][0]))\n\t\t\t\treturn 2;\n\t\t\t\n\t\t}\n\t\treturn 10000;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\t\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tdice[i][j][k] = s.charAt(k) == '*';\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\ts = sc.nextLine();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = 10;\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\tmin = Math.min(min, minrote(i));\n\t\t\t\n\t\t\tout.println(min);\n\t\t\t\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tboolean[][][] dice = new boolean[6][3][3];\n\t\n\tint minrote(int n) {\n\t\tif (n == 0) {\n\t\t\tif ((dice[0][2][0] || dice[0][2][1] || dice[0][2][2]) && (dice[2][2][0] || dice[2][2][1] || dice[2][2][2]))\n\t\t\t\treturn 0;\n\t\t\tif ((dice[0][0][2] || dice[0][1][2] || dice[0][2][2]) && (dice[2][0][0] || dice[2][1][0] || dice[2][2][0]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[0][0][0] || dice[0][1][0] || dice[0][2][0]) && (dice[2][0][2] || dice[2][1][2] || dice[2][2][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[0][0][0] || dice[0][0][1] || dice[0][0][2]) && (dice[2][0][0] || dice[2][0][1] || dice[2][0][2]))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (n == 1) {\n\t\t\tif ((dice[1][0][2] || dice[1][1][2] || dice[1][2][2]) && (dice[3][0][0] || dice[3][1][0] || dice[3][2][0]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[1][0][0] || dice[1][1][0] || dice[1][2][0]) && (dice[3][0][2] || dice[3][1][2] || dice[3][2][2]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[1][2][0] || dice[1][2][1] || dice[1][2][2]) && (dice[3][2][0] || dice[3][2][1] || dice[3][2][2]))\n\t\t\t\treturn 3;\n\t\t\tif ((dice[1][0][0] || dice[1][0][1] || dice[1][0][2]) && (dice[3][0][0] || dice[3][0][1] || dice[3][0][2]))\n\t\t\t\treturn 3;\n\t\t}\n\t\tif (n == 2) {\n\t\t\tif ((dice[4][2][0] || dice[4][2][1] || dice[4][2][2]) && (dice[5][0][0] || dice[5][0][1] || dice[5][0][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[4][0][0] || dice[4][0][1] || dice[4][0][2]) && (dice[5][2][0] || dice[5][2][1] || dice[5][2][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[4][0][2] || dice[4][1][2] || dice[4][2][2]) && (dice[5][0][2] || dice[5][1][2] || dice[5][2][2]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[4][0][0] || dice[4][1][0] || dice[4][2][0]) && (dice[5][0][0] || dice[5][1][0] || dice[5][2][0]))\n\t\t\t\treturn 2;\n\t\t\t\n\t\t}\n\t\treturn 10000;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\t\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tdice[i][j][k] = s.charAt(k) == '*';\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\ts = sc.nextLine();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = 10;\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\tmin = Math.min(min, minrote(i));\n\t\t\t\n\t\t\tout.println(min);\n\t\t\t\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tpublic boolean check(char c1,char c2,char c3,char d1,char d2,char d3){\n\t\treturn (c1=='*' ||c2=='*' || c3=='*') &&  (d1=='*' ||d2=='*' || d3=='*');\n\t}\n\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tchar[][][] dice=new char[6][3][3];\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tdice[i][j]=sc.next().toCharArray();\n\t\t\t\t\tif(dice[i][j][0]=='#')return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(check(dice[0][2][0],dice[0][2][1],dice[0][2][2],\n\t\t\t\t\tdice[2][2][0],dice[2][2][1],dice[2][2][2])){\n\t\t\t\tln(0);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[0][0][0],dice[0][1][0],dice[0][2][0],\n\t\t\t\t\tdice[2][0][2],dice[2][1][2],dice[2][2][2])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\t\t\tif(check(dice[0][0][2],dice[0][1][2],dice[0][2][2],\n\t\t\t\t\tdice[2][0][0],dice[2][1][0],dice[2][2][0])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][2][0],dice[4][2][1],dice[4][2][2],\n\t\t\t\t\tdice[5][0][0],dice[5][0][1],dice[5][0][2])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[0][0][0],dice[0][0][1],dice[0][0][2],\n\t\t\t\t\tdice[2][0][0],dice[2][0][1],dice[2][0][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][0][0],dice[4][1][0],dice[4][2][0],\n\t\t\t\t\tdice[5][0][0],dice[5][1][0],dice[5][2][0])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][0][2],dice[4][1][2],dice[4][2][2],\n\t\t\t\t\tdice[5][0][2],dice[5][1][2],dice[5][2][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][0],dice[1][1][0],dice[1][2][0],\n\t\t\t\t\tdice[3][0][2],dice[3][1][2],dice[3][2][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][2],dice[1][1][2],dice[1][2][2],\n\t\t\t\t\tdice[3][0][0],dice[3][1][0],dice[3][2][0])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[4][0][0],dice[4][0][1],dice[4][0][2],\n\t\t\t\t\tdice[5][2][0],dice[5][2][1],dice[5][2][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][0],dice[1][0][1],dice[1][0][2],\n\t\t\t\t\tdice[3][0][0],dice[3][0][1],dice[3][0][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][2][0],dice[1][2][1],dice[1][2][2],\n\t\t\t\t\tdice[3][2][0],dice[3][2][1],dice[3][2][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic int[] nextIntArray(int n){\n\t\tint[] res=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres[i]=sc.nextInt();\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void pr(Object o) {\n\t\tout.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tout.println(o);\n\t}\n\tpublic static void ln() {\n\t\tout.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t// z[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (i == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (i == 2 || i == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][0][j] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][0][j] == '*') {\n\t\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][2][j] == '*') {\n\t\t\t\t\t\t\t// System.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n\t\t\t\t\t\t// System.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\n\t\t\tfor(int i =0 ; i < 6;i++){\n\t\t\t//\tz[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (i == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (i == 2 || i == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][0][j] == '*') {\n\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][0]) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][0][j] == '*') {\n\t\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][0] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][3]) {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][2][j] == '*') {\n//\t\t\t\t\t\t\tSystem.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][1]) {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][2]) {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tpublic boolean check(char c1,char c2,char c3,char d1,char d2,char d3){\n\t\treturn (c1=='*' ||c2=='*' || c3=='*') &&  (d1=='*' ||d2=='*' || d3=='*');\n\t}\n\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tchar[][][] dice=new char[6][3][3];\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tdice[i][j]=sc.next().toCharArray();\n\t\t\t\t\tif(dice[i][j][0]=='#')return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(check(dice[0][2][0],dice[0][2][1],dice[0][2][2],\n\t\t\t\t\tdice[2][2][0],dice[2][2][1],dice[2][2][2])){\n\t\t\t\tln(0);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[0][0][0],dice[0][1][0],dice[0][2][0],\n\t\t\t\t\tdice[2][0][2],dice[2][1][2],dice[2][2][2])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\t\t\tif(check(dice[0][0][2],dice[0][1][2],dice[0][2][2],\n\t\t\t\t\tdice[2][0][0],dice[2][1][0],dice[2][2][0])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][2][0],dice[4][2][1],dice[4][2][2],\n\t\t\t\t\tdice[5][0][0],dice[5][0][1],dice[5][0][2])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][0][0],dice[4][0][1],dice[4][0][2],\n\t\t\t\t\tdice[5][2][0],dice[5][2][1],dice[5][2][2])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[0][0][0],dice[0][0][1],dice[0][0][2],\n\t\t\t\t\tdice[2][0][0],dice[2][0][1],dice[2][0][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][0][0],dice[4][1][0],dice[4][2][0],\n\t\t\t\t\tdice[5][0][0],dice[5][1][0],dice[5][2][0])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][0][2],dice[4][1][2],dice[4][2][2],\n\t\t\t\t\tdice[5][0][2],dice[5][1][2],dice[5][2][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][0],dice[1][1][0],dice[1][2][0],\n\t\t\t\t\tdice[3][0][2],dice[3][1][2],dice[3][2][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][2],dice[1][1][2],dice[1][2][2],\n\t\t\t\t\tdice[3][0][0],dice[3][1][0],dice[3][2][0])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\n\n\t\t\tif(check(dice[1][0][0],dice[1][0][1],dice[1][0][2],\n\t\t\t\t\tdice[3][0][0],dice[3][0][1],dice[3][0][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][2][0],dice[1][2][1],dice[1][2][2],\n\t\t\t\t\tdice[3][2][0],dice[3][2][1],dice[3][2][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic int[] nextIntArray(int n){\n\t\tint[] res=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres[i]=sc.nextInt();\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void pr(Object o) {\n\t\tout.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tout.println(o);\n\t}\n\tpublic static void ln() {\n\t\tout.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t// z[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (z[i] == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (z[i] == 1 || z[i] == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i + 3][0][j] == '*') {\n\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][2][j] == '*') {\n\t\t\t\t\t\t\t// System.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n\t\t\t\t\t\t// System.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t// z[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (i == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (i == 2 || i == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][0][j] == '*') {\n\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][0]) {\n\t\t\t\t\tok[i][0] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i + 3][0][j] == '*') {\n\t\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][0] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][3]) {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i + 3][2][j] == '*') {\n\t\t\t\t\t\t\t// System.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][1]) {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i + 3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][2]) {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i + 3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n\t\t\t\t\t\t// System.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//package _2245;\n\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] zinv = { 0, 1, 4, 2, 3, 5 };\n\t\t\tint[] z = new int[6];\n\t\t\tfor(int i =0 ; i < 6;i++){\n\t\t\t\tz[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (z[i] == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (z[i] == 1 || z[i] == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][0][j] == '*') {\n\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][0]) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][0][j] == '*') {\n\t\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][0] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][3]) {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][2][j] == '*') {\n//\t\t\t\t\t\t\tSystem.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][1]) {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][2]) {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t// z[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (z[i] == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (i == 2 || i == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i + 3][0][j] == '*') {\n\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][2][j] == '*') {\n\t\t\t\t\t\t\t// System.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tif (dice[i + 3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n\t\t\t\t\t\t// System.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//package _2245.copy;\n\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\t\t//\tint[] z = new int[6];\n\t\t\tfor(int i =0 ; i < 6;i++){\n\t\t\t//\tz[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (z[i] == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (z[i] == 1 || z[i] == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][0][j] == '*') {\n\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][0]) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][0][j] == '*') {\n\t\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][0] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][3]) {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][2][j] == '*') {\n//\t\t\t\t\t\t\tSystem.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][1]) {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][2]) {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString f = sc.next();\n\t\t\tif (f.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar[][][] dice = new char[6][3][];\n\t\t\tdice[0][0] = f.toCharArray();\n\t\t\tdice[0][1] = sc.next().toCharArray();\n\t\t\tdice[0][2] = sc.next().toCharArray();\n\n\t\t\tint[] z = { 0, 1, 3, 4, 2, 5 };\n\n\t\t\tfor(int i =0 ; i < 6;i++){\n\t\t\t//\tz[zinv[i]]= i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (i == 5) {\n\t\t\t\t\t\tdice[z[i]][2 - j] = sc.next().toCharArray();\n\t\t\t\t\t} else if (i == 2 || i == 3) {\n\t\t\t\t\t\tchar temp;\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t\ttemp = dice[z[i]][j][0];\n\t\t\t\t\t\tdice[z[i]][j][0] = dice[z[i]][j][2];\n\t\t\t\t\t\tdice[z[i]][j][2] = temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdice[z[i]][j] = sc.next().toCharArray();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tboolean ok[][] = new boolean[3][4];\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tok[i][0] = false;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][0][j] == '*') {\n\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][0]) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][0][j] == '*') {\n\t\t\t\t\t\t\tok[i][0] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][0] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][2][j] == '*') {\n\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][3]) {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][2][j] == '*') {\n//\t\t\t\t\t\t\tSystem.out.println((i+3)+\" \"+j);\n\t\t\t\t\t\t\tok[i][3] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][3] = false;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][0] == '*') {\n\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][1]) {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][0] == '*') {\n\t\t\t\t\t\t\tok[i][1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][1] = false;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (dice[i][j][2] == '*') {\n\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok[i][2]) {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tif (dice[i+3][j][2] == '*') {\n\t\t\t\t\t\t\tok[i][2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok[i][2] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans[][] = { { 2, 1, 1, 0 }, { 3, 2, 2, 3 }, { 1, 2, 2, 1 } };\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (ok[i][j]) {\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\t\tmin = Math.min(ans[i][j], min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tpublic boolean check(char c1,char c2,char c3,char d1,char d2,char d3){\n\t\treturn (c1=='*' ||c2=='*' || c3=='*') &&  (d1=='*' ||d2=='*' || d3=='*');\n\t}\n\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tchar[][][] dice=new char[6][3][3];\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tdice[i][j]=sc.next().toCharArray();\n\t\t\t\t\tif(dice[i][j][0]=='#')return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(check(dice[0][2][0],dice[0][2][1],dice[0][2][2],\n\t\t\t\t\tdice[2][2][0],dice[2][2][1],dice[2][2][2])){\n\t\t\t\tln(0);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[0][0][0],dice[0][1][0],dice[0][2][0],\n\t\t\t\t\tdice[2][0][0],dice[2][1][0],dice[2][2][0])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\t\t\tif(check(dice[0][0][2],dice[0][1][2],dice[0][2][2],\n\t\t\t\t\tdice[2][0][2],dice[2][1][2],dice[2][2][2])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][2][0],dice[4][2][1],dice[4][2][2],\n\t\t\t\t\tdice[5][2][0],dice[5][2][1],dice[5][2][2])){\n\t\t\t\tln(1);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[0][0][0],dice[0][0][1],dice[0][0][2],\n\t\t\t\t\tdice[2][0][0],dice[2][0][1],dice[2][0][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][0][0],dice[4][1][0],dice[4][2][0],\n\t\t\t\t\tdice[5][0][0],dice[5][1][0],dice[5][2][0])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[4][0][2],dice[4][1][2],dice[4][2][2],\n\t\t\t\t\tdice[5][0][2],dice[5][1][2],dice[5][2][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][0],dice[1][1][0],dice[1][2][0],\n\t\t\t\t\tdice[3][0][0],dice[3][1][0],dice[3][2][0])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][2],dice[1][1][2],dice[1][2][2],\n\t\t\t\t\tdice[3][0][2],dice[3][1][2],dice[3][2][2])){\n\t\t\t\tln(2);continue;\n\t\t\t}\n\n\t\t\tif(check(dice[4][0][0],dice[4][0][1],dice[4][0][2],\n\t\t\t\t\tdice[5][2][0],dice[5][2][1],dice[5][2][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][0][0],dice[1][0][1],dice[1][0][2],\n\t\t\t\t\tdice[3][0][0],dice[3][0][1],dice[3][0][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t\tif(check(dice[1][2][0],dice[1][2][1],dice[1][2][2],\n\t\t\t\t\tdice[3][2][0],dice[3][2][1],dice[3][2][2])){\n\t\t\t\tln(3);continue;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic int[] nextIntArray(int n){\n\t\tint[] res=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres[i]=sc.nextInt();\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void pr(Object o) {\n\t\tout.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tout.println(o);\n\t}\n\tpublic static void ln() {\n\t\tout.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tboolean[][][] dice = new boolean[6][3][3];\n\t\n\tint minrote(int n) {\n\t\tif (n == 0) {\n\t\t\tif ((dice[0][2][0] || dice[0][2][1] || dice[0][2][2]) && (dice[2][2][0] || dice[2][2][1] || dice[2][2][2]))\n\t\t\t\treturn 0;\n\t\t\tif ((dice[0][0][2] || dice[0][1][2] || dice[0][2][2]) && (dice[2][0][0] || dice[2][1][0] || dice[2][2][0]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[0][0][0] || dice[0][1][0] || dice[0][2][0]) && (dice[2][0][2] || dice[2][1][2] || dice[2][2][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[0][0][0] || dice[0][0][1] || dice[0][0][2]) && (dice[2][0][0] || dice[2][0][1] || dice[2][0][2]))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (n == 1) {\n\t\t\tif ((dice[1][2][0] || dice[1][2][1] || dice[1][2][2]) && (dice[3][2][0] || dice[3][2][1] || dice[3][2][2]))\n\t\t\t\treturn 3;\n\t\t\tif ((dice[1][0][2] || dice[1][1][2] || dice[1][2][2]) && (dice[3][0][0] || dice[3][1][0] || dice[3][2][0]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[1][0][0] || dice[1][1][0] || dice[1][2][0]) && (dice[3][0][2] || dice[3][1][2] || dice[3][2][2]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[1][0][0] || dice[1][0][1] || dice[1][0][2]) && (dice[3][0][0] || dice[3][0][1] || dice[3][0][2]))\n\t\t\t\treturn 3;\n\t\t}\n\t\tif (n == 2) {\n\t\t\tif ((dice[4][2][0] || dice[4][2][1] || dice[4][2][2]) && (dice[5][0][0] || dice[5][0][1] || dice[5][0][2]))\n\t\t\t\treturn 1;\n\t\t\tif ((dice[4][0][2] || dice[4][1][2] || dice[4][2][2]) && (dice[5][0][2] || dice[5][1][2] || dice[5][2][2]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[4][0][0] || dice[4][1][0] || dice[4][2][0]) && (dice[5][0][0] || dice[5][1][0] || dice[5][2][0]))\n\t\t\t\treturn 2;\n\t\t\tif ((dice[4][0][0] || dice[4][0][1] || dice[4][0][2]) && (dice[5][2][0] || dice[5][2][1] || dice[5][2][2]))\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 10000;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\t\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\tdice[i][j][k] = s.charAt(k) == '*';\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\ts = sc.nextLine();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = 10;\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\tmin = Math.min(min, minrote(i));\n\t\t\t\n\t\t\tout.println(min);\n\t\t\t\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef main():\n    I = {\n        1: ((6, 0), (2, 1), (5, 2), (4, 3)),\n        2: ((6, 3), (3, 1), (5, 3), (1, 3)),\n        3: ((6, 2), (4, 1), (5, 0), (2, 3)),\n        4: ((6, 1), (1, 1), (5, 1), (3, 3)),\n        5: ((1, 0), (2, 0), (3, 0), (4, 0)),\n        6: ((1, 2), (2, 2), (3, 2), (4, 2)),\n    }\n    J = [[6, 7, 8], [2, 5, 8], [0, 1, 2], [0, 3, 6]]\n    D = [\n        (1, 5, 2, 3, 0, 4), # 'U'\n        (3, 1, 0, 5, 4, 2), # 'R'\n        (4, 0, 2, 3, 5, 1), # 'D'\n        (2, 1, 5, 0, 4, 3), # 'L'\n    ]\n    def rotate_dice(L, k):\n        return tuple(L[e] for e in D[k])\n\n    R = (5, 1, 2, 4, 3, 6)\n    que = deque()\n    dist = {R: 0}\n    que.append(R)\n    while que:\n        s = que.popleft()\n        d = dist[s]\n        for i in range(4):\n            t = rotate_dice(s, i)\n            if t in dist:\n                continue\n            dist[t] = d+1\n            que.append(t)\n\n    C = [None]*6\n    while 1:\n        S = input()\n        if S == '#':\n            break\n        C[0] = \"\".join([S, input(), input()])\n        for i in range(5):\n            C[i+1] = \"\".join([input() for i in range(3)])\n        ans = 10\n        for s, v in dist.items():\n            a = s[0]; b = s[1]\n            for k, (i, e) in enumerate(I[a]):\n                if i == b:\n                    j, f = I[a][k-2]\n                    if any(C[i-1][k1] == '*' for k1 in J[e]) and any(C[j-1][k2] == '*' for k2 in J[f]):\n                        ans = min(ans, v)\n                    break\n        print(ans)\n        input()\nmain()\n"
  }
]