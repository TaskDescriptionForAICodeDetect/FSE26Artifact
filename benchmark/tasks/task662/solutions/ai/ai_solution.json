[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 16\n\nlong long solve(int N, int K, int P) {\n    long long dp[1 << MAX_N][MAX_N];\n    memset(dp, 0, sizeof(dp));\n\n    dp[1][0] = 1;\n\n    for (int mask = 2; mask < (1 << N); mask++) {\n        int last = __builtin_ctz(mask);\n        int prev_mask = mask ^ (1 << last);\n\n        for (int last_vertex = 0; last_vertex < N; last_vertex++) {\n            if (last_vertex == last) continue;\n\n            for (int prev_last = 0; prev_last < N; prev_last++) {\n                if (prev_last == last_vertex || prev_last == last) continue;\n\n                int valid = 1;\n                int in_degree[MAX_N] = {0};\n\n                for (int u = 0; u < N; u++) {\n                    if (!(prev_mask & (1 << u))) continue;\n                    \n                    if (u == prev_last) {\n                        in_degree[last_vertex]++;\n                        in_degree[last]++;\n                    } else if (u == last_vertex) {\n                        in_degree[prev_last]++;\n                        in_degree[last]++;\n                    }\n                }\n\n                for (int u = 0; u < N; u++) {\n                    if (in_degree[u] > K) {\n                        valid = 0;\n                        break;\n                    }\n                }\n\n                if (valid) {\n                    int triangle_check = 0;\n                    for (int a = 0; a < N; a++) {\n                        for (int b = a + 1; b < N; b++) {\n                            for (int c = b + 1; c < N; c++) {\n                                if ((prev_mask & (1 << a)) && \n                                    (prev_mask & (1 << b)) && \n                                    (prev_mask & (1 << c)) &&\n                                    (last == a || last == b || last == c) &&\n                                    (last_vertex == a || last_vertex == b || last_vertex == c)) {\n                                    int deg_a = 0, deg_b = 0, deg_c = 0, deg_d = 0;\n                                    for (int d = 0; d < N; d++) {\n                                        if (d == a || d == b || d == c) continue;\n                                        if ((last == a && last_vertex == b) || \n                                            (last == b && last_vertex == c) || \n                                            (last == c && last_vertex == a)) {\n                                            deg_d++;\n                                        }\n                                    }\n                                    if (deg_d == 2) {\n                                        triangle_check = 1;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (triangle_check) break;\n                        }\n                        if (triangle_check) break;\n                    }\n\n                    if (!triangle_check) {\n                        dp[mask][last_vertex] += dp[prev_mask][prev_last];\n                        dp[mask][last_vertex] %= P;\n                    }\n                }\n            }\n        }\n    }\n\n    long long total = 0;\n    for (int u = 0; u < N; u++) {\n        total += dp[(1 << N) - 1][u];\n        total %= P;\n    }\n\n    return total;\n}\n\nint main() {\n    int N, K, P;\n    scanf(\"%d %d %d\", &N, &K, &P);\n    printf(\"%lld\\n\", solve(N, K, P));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nlong long mod_pow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nlong long inv(long long a, long long mod) {\n    return mod_pow(a, mod - 2, mod);\n}\n\nlong long comb(long long n, long long k, long long mod, long long *fact, long long *inv_fact) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod;\n}\n\nint main() {\n    int N, K, P;\n    scanf(\"%d %d %d\", &N, &K, &P);\n\n    long long *fact = (long long *)malloc((N + 1) * sizeof(long long));\n    long long *inv_fact = (long long *)malloc((N + 1) * sizeof(long long));\n\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fact[i] = fact[i - 1] * i % P;\n    }\n    inv_fact[N] = inv(fact[N], P);\n    for (int i = N - 1; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % P;\n    }\n\n    long long res = 0;\n    for (int t = 0; t <= K; t++) {\n        long long c = comb(N, t, P, fact, inv_fact);\n        long long ways = 1;\n        for (int i = 1; i <= N - t - 1; i++) {\n            ways = ways * mod_pow(2, i, P) % P;\n        }\n        res = (res + c * ways) % P;\n    }\n\n    printf(\"%lld\\n\", res);\n    free(fact);\n    free(inv_fact);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll mod;\n\nll pow_mod(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inv(ll a) {\n    return pow_mod(a, mod - 2);\n}\n\nll comb(ll n, ll k, vector<ll>& fact, vector<ll>& inv_fact) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K >> mod;\n\n    vector<ll> fact(N * N + 1), inv_fact(N * N + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= N * N; ++i) {\n        fact[i] = fact[i - 1] * i % mod;\n    }\n    inv_fact[N * N] = inv(fact[N * N]);\n    for (int i = N * N - 1; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;\n    }\n\n    vector<vector<ll>> dp(N + 1, vector<ll>(K + 1, 0));\n    dp[0][0] = 1;\n    for (int n = 1; n <= N; ++n) {\n        for (int k = 0; k <= K; ++k) {\n            for (int m = 0; m < n; ++m) {\n                int l = n - 1 - m;\n                if (l < 0) continue;\n                for (int s = 0; s <= k; ++s) {\n                    if (dp[m][s] == 0) continue;\n                    int t = k - s;\n                    if (t < 0 || t > l) continue;\n                    ll ways = dp[m][s] * dp[l][t] % mod;\n                    ways = ways * comb(n - 1, m, fact, inv_fact) % mod;\n                    ll edges = m * l + m * (m - 1) / 2;\n                    ways = ways * pow_mod(2, edges) % mod;\n                    dp[n][k] = (dp[n][k] + ways) % mod;\n                }\n            }\n        }\n    }\n\n    ll total = 0;\n    for (int k = 0; k <= K; ++k) {\n        total = (total + dp[N][k]) % mod;\n    }\n\n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:30:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\n\npublic class TournamentGraphs {\n    static int P;\n\n    static int add(int a, int b) {\n        a += b;\n        if (a >= P) a -= P;\n        return a;\n    }\n\n    static int sub(int a, int b) {\n        a -= b;\n        if (a < 0) a += P;\n        return a;\n    }\n\n    static int mul(int a, int b) {\n        return (int)((long)a * b % P);\n    }\n\n    static int modInv(int a, int p) {\n        return BigInteger.valueOf(a).modInverse(BigInteger.valueOf(p)).intValue();\n    }\n\n    static int[] factorial, invFactorial;\n\n    static void precomputeFactorials(int maxN) {\n        factorial = new int[maxN + 1];\n        invFactorial = new int[maxN + 1];\n        factorial[0] = 1;\n        for (int i = 1; i <= maxN; i++) {\n            factorial[i] = mul(factorial[i - 1], i);\n        }\n        invFactorial[maxN] = modInv(factorial[maxN], P);\n        for (int i = maxN - 1; i >= 0; i--) {\n            invFactorial[i] = mul(invFactorial[i + 1], i + 1);\n        }\n    }\n\n    static int comb(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return mul(factorial[n], mul(invFactorial[k], invFactorial[n - k]));\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        P = sc.nextInt();\n\n        precomputeFactorials(N);\n\n        int[] dp = new int[N + 1];\n        dp[0] = 1;\n        for (int n = 1; n <= N; n++) {\n            for (int j = 0; j <= K; j++) {\n                dp[n] = add(dp[n], mul(comb(n - 1, j), dp[n - 1 - j]));\n            }\n        }\n\n        int total = dp[N];\n        if (N >= 4) {\n            int forbidden = 0;\n            for (int j = 0; j <= K - 3; j++) {\n                forbidden = add(forbidden, mul(comb(N - 3, j), dp[N - 3 - j]));\n            }\n            forbidden = mul(forbidden, comb(N, 3));\n            total = sub(total, forbidden);\n        }\n\n        System.out.println(total);\n    }\n}",
    "timestamp": "2025-08-05 22:30:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TournamentGraphCounter {\n    private static final int MOD = 1_000_000_007;\n\n    public static int countTournaments(int N, int K, int P) {\n        long[][][][] dp = new long[1 << N][N][K + 1][N + 1];\n        dp[0][0][0][0] = 1;\n\n        for (int mask = 0; mask < (1 << N); mask++) {\n            for (int last = 0; last < N; last++) {\n                if ((mask & (1 << last)) == 0) continue;\n                \n                for (int deg = 0; deg <= K; deg++) {\n                    for (int cnt = 0; cnt <= N; cnt++) {\n                        if (dp[mask][last][deg][cnt] == 0) continue;\n                        \n                        for (int next = 0; next < N; next++) {\n                            if ((mask & (1 << next)) != 0) continue;\n                            \n                            int newMask = mask | (1 << next);\n                            int newDeg = deg + (cnt > 0 ? 1 : 0);\n                            int newCnt = cnt + 1;\n                            \n                            if (newDeg > K) continue;\n                            \n                            boolean valid = true;\n                            for (int a = 0; a < N && valid; a++) {\n                                if ((mask & (1 << a)) == 0) continue;\n                                for (int b = a + 1; b < N && valid; b++) {\n                                    if ((mask & (1 << b)) == 0) continue;\n                                    for (int c = b + 1; c < N && valid; c++) {\n                                        if ((mask & (1 << c)) == 0) continue;\n                                        \n                                        if (checkForbiddenSubgraph(a, b, c, last, next)) {\n                                            valid = false;\n                                        }\n                                    }\n                                }\n                            }\n                            \n                            if (valid) {\n                                dp[newMask][next][newDeg][newCnt] += dp[mask][last][deg][cnt];\n                                dp[newMask][next][newDeg][newCnt] %= P;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        long result = 0;\n        for (int last = 0; last < N; last++) {\n            for (int deg = 0; deg <= K; deg++) {\n                for (int cnt = 0; cnt <= N; cnt++) {\n                    result += dp[(1 << N) - 1][last][deg][cnt];\n                    result %= P;\n                }\n            }\n        }\n        \n        return (int) result;\n    }\n    \n    private static boolean checkForbiddenSubgraph(int a, int b, int c, int d, int e) {\n        return a != d && a != e && b != d && b != e && c != d && c != e;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int P = scanner.nextInt();\n        System.out.println(countTournaments(N, K, P));\n    }\n}",
    "timestamp": "2025-08-05 22:31:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAXN = 20;\nconst int MAXMASK = (1 << 20);\n\nll dp[MAXN + 1][MAXMASK];\nint n, k, p;\n\nbool is_valid_clique(int mask) {\n    for (int a = 0; a < n; a++) {\n        if (!(mask & (1 << a))) continue;\n        for (int b = a + 1; b < n; b++) {\n            if (!(mask & (1 << b))) continue;\n            for (int c = b + 1; c < n; c++) {\n                if (!(mask & (1 << c))) continue;\n                int cnt = 0;\n                for (int d = 0; d < n; d++) {\n                    if (!(mask & (1 << d)) || d == a || d == b || d == c) continue;\n                    cnt++;\n                }\n                if (cnt > 0) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin >> n >> k >> p;\n    \n    dp[0][0] = 1;\n    \n    for (int i = 0; i < n; i++) {\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (dp[i][mask] == 0) continue;\n            \n            for (int next = 0; next < n; next++) {\n                if (mask & (1 << next)) continue;\n                \n                int new_mask = mask | (1 << next);\n                int in_degree = __builtin_popcount(mask & ((1 << n) - 1));\n                \n                if (in_degree < k) {\n                    dp[i + 1][new_mask] = (dp[i + 1][new_mask] + dp[i][mask]) % p;\n                }\n            }\n        }\n    }\n    \n    ll ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        if (is_valid_clique(mask)) {\n            ans = (ans + dp[n][mask]) % p;\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:31:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_tournaments(N, K, P):\n    def fast_exponentiation(base, exp, mod):\n        result = 1\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp //= 2\n        return result\n    \n    # Precompute factorials and inverse factorials modulo P\n    factorial = [1] * (N + 1)\n    inverse_factorial = [1] * (N + 1)\n    \n    for i in range(2, N + 1):\n        factorial[i] = factorial[i - 1] * i % P\n    \n    inverse_factorial[N] = fast_exponentiation(factorial[N], P - 2, P)\n    \n    for i in range(N - 1, 0, -1):\n        inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % P\n    \n    def binomial(n, k, p):\n        if k > n:\n            return 0\n        if k < 0 or n < 0:\n            return 0\n        return factorial[n] * inverse_factorial[k] % p * inverse_factorial[n - k] % p\n    \n    # Count tournaments with restricted in-degrees\n    count = fast_exponentiation(2, N * (N - 1) // 2, P)\n    \n    for d in range(K + 1, N):\n        count -= binomial(N, d, P) * fast_exponentiation(2, d * (N - d), P)\n        count %= P\n    \n    # Apply condition for any 4 vertices\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                for l in range(k + 1, N):\n                    count -= 1\n                    count %= P\n    \n    return count\n\n# Example usage\nN = 4\nK = 2\nP = 7\nprint(count_tournaments(N, K, P))",
    "timestamp": "2025-08-13 11:00:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DirectedGraphCounter {\n    private static final int MAXN = 50; // assuming a reasonable upper limit for N\n    private static final int[][] C = new int[MAXN][MAXN]; // for binomial coefficients\n    private static final int MODULO = (int) 1e9 + 7; // fallback modulo for operations\n\n    public static int countTournaments(int N, int K, int P) {\n        // Precompute binomial coefficients\n        for (int i = 0; i < MAXN; i++) {\n            C[i][0] = C[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n            }\n        }\n\n        int totalTournaments = (int) ((1L << (N * (N - 1) / 2)) % P); // In all tournaments, pick one direction for each edge\n\n        // Filter tournaments based on in-degree condition\n        int validTournaments = 0;\n        for (int mask = 0; mask < (1 << N); mask++) {\n            if (Integer.bitCount(mask) > K) continue;\n            int count = 1;\n            for (int i = 0; i < N; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    count = (count * (1 << (i - Integer.bitCount(mask & ((1 << i) - 1))))) % P;\n                }\n            }\n            validTournaments = (validTournaments + count) % P;\n        }\n\n        // Filter using the forbidden configuration\n        int forbiddenCount = 0;\n        // Iterate through quadruples a, b, c, d\n        for (int a = 0; a < N; a++) {\n            for (int b = a + 1; b < N; b++) {\n                for (int c = b + 1; c < N; c++) {\n                    for (int d = c + 1; d < N; d++) {\n                        forbiddenCount++;\n                    }\n                }\n            }\n        }\n        forbiddenCount %= P;\n        \n        // Subtract forbidden configurations from valid tournaments\n        int result = validTournaments - forbiddenCount;\n        if (result < 0) {\n            result += P;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int P = sc.nextInt();\n        \n        System.out.println(countTournaments(N, K, P));\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 11:00:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAXN 10\n\nint countTournaments(int N, int K, int P) {\n    int dp[1 << MAXN][MAXN + 1] = {0};\n    int total_count = 0;\n\n    dp[0][0] = 1;\n    \n    for (int mask = 0; mask < (1 << N); ++mask) {\n        for (int in_deg = 0; in_deg <= K; ++in_deg) {\n            if (dp[mask][in_deg] == 0) continue;\n            \n            for (int u = 0; u < N; ++u) {\n                if (!(mask & (1 << u))) {\n                    int new_mask = mask | (1 << u);\n                    for (int ind = 0; ind <= K; ++ind) {\n                        if (ind < K) {\n                            dp[new_mask][ind + 1] = (dp[new_mask][ind + 1] + dp[mask][in_deg]) % P;\n                        }\n                        dp[new_mask][ind] = (dp[new_mask][ind] + dp[mask][in_deg]) % P;\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int in_deg = 0; in_deg <= K; ++in_deg) {\n        total_count = (total_count + dp[(1 << N) - 1][in_deg]) % P;\n    }\n\n    return total_count;\n}\n\nint main() {\n    int N, K, P;\n    printf(\"Enter values for N, K, and P: \");\n    scanf(\"%d %d %d\", &N, &K, &P);\n\n    int result = countTournaments(N, K, P);\n    printf(\"Number of tournaments: %d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:00:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countGraphs(N, K, P) {\n    const MOD = P;\n    const factorial = new Array(N + 1).fill(1);\n    \n    // Compute factorials modulo P\n    for (let i = 2; i <= N; i++) {\n        factorial[i] = factorial[i - 1] * i % MOD;\n    }\n    \n    // Precompute binomial coefficients modulo P using dynamic programming\n    const binom = Array.from({length: N + 1}, () => new Array(N + 1).fill(0));\n    for (let i = 0; i <= N; i++) {\n        binom[i][0] = binom[i][i] = 1;\n        for (let j = 1; j < i; j++) {\n            binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;\n        }\n    }\n\n    // Calculate the number of tournaments\n    let total = factorial[N] >> 1;  // Total number of tournaments (N! / 2)\n    if (N % 2 === 1) {\n        total += factorial[N] >> 1;\n    }\n    total %= MOD;\n\n    // Count graphs with conditions\n    let count = total;\n    for (let i = 0; i < N; i++) {\n        let excess = Math.max(0, i - K);\n        let ways = binom[N - 1][excess];\n        count = (count - ways * factorial[N - excess - 1]) % MOD;\n        if (count < 0) count += MOD;\n    }\n\n    return count;\n}",
    "timestamp": "2025-08-13 11:00:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_tournaments(N, K, P):\n    MOD = P\n    \n    # Precalculate factorial and inverse factorial\n    fact = [1] * (N + 1)\n    inv_fact = [1] * (N + 1)\n    for i in range(1, N + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    inv_fact[N] = pow(fact[N], MOD - 2, MOD)\n    for i in range(N - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i + 1)) % MOD\n    \n    # DP to count valid tournaments\n    dp = [[0] * (1 << N) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for vertices in range(1, N + 1):\n        for mask in range(1 << vertices):\n            if dp[vertices-1][mask] == 0:\n                continue\n            \n            for new_vertex in range(vertices):\n                if mask & (1 << new_vertex):\n                    continue\n                \n                new_mask = mask | (1 << new_vertex)\n                in_degree = [0] * vertices\n                \n                for u in range(vertices):\n                    if mask & (1 << u):\n                        for v in range(vertices):\n                            if mask & (1 << v):\n                                if new_mask & (1 << u) and new_mask & (1 << v):\n                                    if u != v:\n                                        in_degree[v] += 1\n                \n                # Check in-degree constraint\n                if max(in_degree) <= K:\n                    # Check clique constraint\n                    forbidden = False\n                    for a in range(vertices):\n                        if new_mask & (1 << a):\n                            for b in range(a + 1, vertices):\n                                if new_mask & (1 << b):\n                                    for c in range(b + 1, vertices):\n                                        if new_mask & (1 << c):\n                                            for d in range(vertices):\n                                                if d != a and d != b and d != c and new_mask & (1 << d):\n                                                    if (new_mask & (1 << a) and new_mask & (1 << b) and new_mask & (1 << c) and\n                                                        new_mask & (1 << d) and\n                                                        (new_mask & (1 << a) and new_mask & (1 << b)) and\n                                                        (new_mask & (1 << b) and new_mask & (1 << c)) and\n                                                        (new_mask & (1 << c) and new_mask & (1 << a)) and\n                                                        (new_mask & (1 << a) and new_mask & (1 << d)) and\n                                                        (new_mask & (1 << b) and new_mask & (1 << d)) and\n                                                        (new_mask & (1 << c) and new_mask & (1 << d))):\n                                                        forbidden = True\n                                                        break\n                                                if forbidden:\n                                                    break\n                                            if forbidden:\n                                                break\n                                        if forbidden:\n                                            break\n                                    if forbidden:\n                                        break\n                    \n                    if not forbidden:\n                        dp[vertices][new_mask] = (dp[vertices][new_mask] + dp[vertices-1][mask]) % MOD\n    \n    # Sum up tournaments with N vertices\n    result = 0\n    for mask in range(1 << N):\n        if bin(mask).count('1') == N:\n            result = (result + dp[N][mask]) % MOD\n    \n    return result",
    "timestamp": "2025-08-13 11:00:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, K, P) {\n    const MOD = P;\n    const dp = Array(1 << N).fill(0);\n    dp[0] = 1;\n\n    for (let mask = 0; mask < (1 << N); mask++) {\n        const cnt = bitCount(mask);\n        if (cnt >= 4) continue;\n\n        for (let i = 0; i < N; i++) {\n            if (mask & (1 << i)) continue;\n\n            let valid = true;\n            const inDegree = new Array(N).fill(0);\n\n            for (let j = 0; j < N; j++) {\n                if (mask & (1 << j)) {\n                    if (mask & (1 << i)) {\n                        inDegree[j]++;\n                    } else {\n                        inDegree[i]++;\n                    }\n                }\n            }\n\n            for (let j = 0; j < N; j++) {\n                if (j === i) continue;\n                if (inDegree[j] >= K) {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid) {\n                dp[mask | (1 << i)] = (dp[mask | (1 << i)] + dp[mask]) % MOD;\n            }\n        }\n    }\n\n    return dp[(1 << N) - 1];\n}\n\nfunction bitCount(n) {\n    let count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}",
    "timestamp": "2025-08-13 11:00:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N, K, P = map(int, sys.stdin.readline().split())\n    \n    if K >= N - 1:\n        # The condition on in-degree is trivially satisfied; need to count tournaments without the forbidden 4-vertex pattern\n        # The number of such tournaments is known to be equal to the number of transitive tournaments, which is N! mod P\n        res = 1\n        for i in range(1, N+1):\n            res = res * i % P\n        print(res)\n        return\n    \n    # Otherwise, the answer is zero because any tournament has at least one vertex with in-degree >= (N-1)/2\n    # For N >= 2K + 2, there must be a vertex with in-degree >= K+1, violating the condition\n    print(0)\n\nsolve()",
    "timestamp": "2025-08-13 11:00:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, K, P) {\n    // Precompute factorial, inverse factorial, and power tables modulo P\n    const fact = new Array(N * N + 1).fill(1);\n    const invFact = new Array(N * N + 1).fill(1);\n    for (let i = 1; i <= N * N; i++) {\n        fact[i] = (fact[i - 1] * i) % P;\n    }\n    invFact[N * N] = modInverse(fact[N * N], P);\n    for (let i = N * N - 1; i >= 0; i--) {\n        invFact[i] = (invFact[i + 1] * (i + 1)) % P;\n    }\n\n    function comb(n, k) {\n        if (k < 0 || k > n) return 0;\n        return (fact[n] * invFact[k] % P) * invFact[n - k] % P;\n    }\n\n    // DP table: dp[mask][in_degree] = number of ways\n    const dp = new Array(1 << N);\n    for (let i = 0; i < (1 << N); i++) {\n        dp[i] = new Array(K + 1).fill(0);\n    }\n    dp[0][0] = 1;\n\n    for (let mask = 0; mask < (1 << N); mask++) {\n        for (let d = 0; d <= K; d++) {\n            if (dp[mask][d] === 0) continue;\n            const bits = [];\n            for (let i = 0; i < N; i++) {\n                if (!(mask & (1 << i))) bits.push(i);\n            }\n            const m = bits.length;\n            for (let subset = 0; subset < (1 << m); subset++) {\n                let newMask = mask;\n                let newD = d;\n                let cnt = 0;\n                for (let i = 0; i < m; i++) {\n                    if (subset & (1 << i)) {\n                        newMask |= (1 << bits[i]);\n                        cnt++;\n                    }\n                }\n                newD += cnt;\n                if (newD <= K) {\n                    dp[newMask][newD] = (dp[newMask][newD] + dp[mask][d]) % P;\n                }\n            }\n        }\n    }\n\n    // The answer is the sum of dp[(1 << N) - 1][d] for d <= K\n    let res = 0;\n    for (let d = 0; d <= K; d++) {\n        res = (res + dp[(1 << N) - 1][d]) % P;\n    }\n\n    // Subtract the number of graphs that contain the forbidden subgraph\n    // The forbidden subgraph is a directed 3-cycle plus a common out-neighbor\n    // The number of such subgraphs is C(N,4) * 4 * 2^{N-4 choose 2}\n    const C4 = comb(N, 4);\n    const pow2 = (N - 4) * (N - 5) / 2;\n    const forbidden = (C4 * 4 % P) * modPow(2, pow2, P) % P;\n    res = (res - forbidden + P) % P;\n\n    return res;\n}\n\nfunction modPow(a, b, mod) {\n    let res = 1;\n    a = a % mod;\n    while (b > 0) {\n        if (b % 2 === 1) res = (res * a) % mod;\n        a = (a * a) % mod;\n        b = Math.floor(b / 2);\n    }\n    return res;\n}\n\nfunction modInverse(a, mod) {\n    let m0 = mod;\n    let y = 0, x = 1;\n    if (mod === 1) return 0;\n    while (a > 1) {\n        let q = Math.floor(a / mod);\n        let t = mod;\n        mod = a % mod;\n        a = t;\n        t = y;\n        y = x - q * y;\n        x = t;\n    }\n    if (x < 0) x += m0;\n    return x;\n}",
    "timestamp": "2025-08-13 11:01:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 105;\nconst int MOD = 1e9 + 7;\n\nint N, K, P;\nvector<vector<int>> dp(MAXN, vector<int>(MAXN));\n\nint power_mod(int x, int y, int p) {\n    int res = 1;\n    x = x % p;\n    while (y > 0) {\n        if (y & 1)\n            res = (res * x) % p;\n        y = y >> 1;\n        x = (x * x) % p;\n    }\n    return res;\n}\n\nbool violates_condition(int mask) {\n    for (int a = 0; a < 4; ++a) {\n        for (int b = a + 1; b < 4; ++b) {\n            for (int c = b + 1; c < 4; ++c) {\n                for (int d = 0; d < 4; ++d) {\n                    if (d == a || d == b || d == c) continue;\n                    int ab = (mask & (1 << (2 * a))) >> (2 * a);\n                    int bc = (mask & (1 << (2 * b))) >> (2 * b);\n                    int ca = (mask & (1 << (2 * c))) >> (2 * c);\n                    int ad = (mask & (1 << (2 * d))) >> (2 * d);\n                    int bd = (mask & (1 << (2 * b + 1))) >> (2 * b + 1);\n                    int cd = (mask & (1 << (2 * c + 1))) >> (2 * c + 1);\n                    if (ab && bc && ca && ad && bd && cd) return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    cin >> N >> K >> P;\n    \n    dp[0][0] = 1;  // Base case: 0 vertices, 0 in-degree\n    \n    for (int n = 1; n <= N; ++n) {\n        for (int k = 0; k <= K; ++k) {\n            dp[n][k] = 0;\n            for (int new_in_edges = 0; new_in_edges <= min(k, n - 1); ++new_in_edges) {\n                int ways_to_choose_in_edges = power_mod(2, new_in_edges, P);\n                dp[n][k] = (dp[n][k] + ((long long)dp[n - 1][k - new_in_edges] * ways_to_choose_in_edges) % P) % P;\n            }\n        }\n    }\n    \n    int result = dp[N][K] % P;\n    for (int combination = 0; combination < 64; ++combination) {\n        if (violates_condition(combination)) {\n            result = (result - power_mod(2, N - 4, P) + P) % P;\n        }\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:01:52"
  }
]