[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int N=207;\n\nint n, m, k, u, v, x, y, t, a, b, ans, mod;\nint F[N];\nint dp[2][N][N][N];\nint val[N][N][N];\n\ninline void fix(int &x){\n\tif (x>=mod) x-=mod;\n//\tif (x<0) x+=mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tfor (int j=0; j<N; j++) for (int k1=max(j-1, 0); k1<N; k1++) for (int k2=0; k2<N; k2++) dp[0][j][k1][k2]=1;\n\tcin>>n>>k>>mod;\n\t\n\tfor (int i=1; i<N; i++){\n\t\tint cur=(i&1);\n\t\tfor (int j=0; i+j<N; j++) for (int k1=0; k1<i+j; k1++) for (int k2=0; k2<i+j; k2++) dp[cur][j][k1][k2]=0;\n\t\tfor (int k1=0; k1<i; k1++) for (int k2=i-1; k2<i; k2++) dp[cur][0][k1][k2]=1;\n\t\tfor (int j=1; i+j<N; j++){\n\t\t\tfor (int k1=j-1; k1<i+j; k1++) for (int k2=i-1; k2<i+j; k2++){\n\t\t\t\tif (k2) dp[cur][j][k1][k2]+=dp[cur][j-1][min(k1, i+j-2)][k2-1];\n\t\t\t\tif (k1) dp[cur][j][k1][k2]+=dp[cur^1][j][k1-1][min(k2, i+j-2)];\n\t\t\t\tfix(dp[cur][j][k1][k2]);\n\t\t\t}\n\t\t}\n\t\tfor (int j=1; i+j<N; j++) for (int k=max(1, j-1); k<i+j; k++) for (int x=1; x<j && x<=k; x++){\n\t\t\tif (i-1+x<=k) fix(val[j][i][k]+=dp[cur^1][j-x][min(k-1, i+j-x-2)][min(k-x, i+j-x-2)]);\n\t\t}\n\t\t\n//\t\tif (i==1) debug2(cur, dp[cur][2][1][1])\n//\t\tif (i==1) debug2(cur, dp[cur][1][1][1])\n\t\t\n\t\t\n\t}\n\tF[0]=1;\n\tfor (int i=1; i<N; i++) F[i]=F[i-1]*i%mod;\n\t\n\tif (k==n-1){\n//\t\tdebug(\"dag\")\n\t\tans=1;\n\t\tfor (int i=1; i<=n; i++) ans=ans*i%mod;\n\t}\n\t\n\tfor (int t=0; t<=min(k, n-3); t++){\n\t\tfor (int X=1; X<n-t; X++){\n\t\t\tint Y=n-X-t-1;\n\t\t\tll tmp=1;\n\t\t\tfor (int i=1; i<=n; i++) if (i!=n-t) tmp=tmp*i%mod;\n\t\t\ttmp=tmp*val[X+1][Y][min(k-t, X+Y)]%mod;\n//\t\t\tcerr<<t<<\"  \"<<X<<\" \"<<Y<<\"   \"<<tmp<<\"\\n\";\n\t\t\tans=(ans+tmp)%mod;\n\t\t}\n\t}\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<\"\\n\";\n\t\n//\tdebug(val[2][3][2]) // should be 0\n//\tdebug(val[3][1][1]) // should be 0\n//\tdebug(val[3][2][2]) // should be 1\n\t\n\treturn 0;\n}\n/*\n5 2 1000000007\n5 3 1000000007\n5 4 1000000007\n\n*/"
  },
  {
    "language": "C++",
    "code": "//orz myh\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=205;\nint n,k,mod;\nint fac[N],inv[N],f[N][N];\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=1ll*res*b%mod;\n\t\tb=1ll*b*b%mod; n>>=1;\n\t}\n\treturn res;\n} \nint calc(int k,int l,int in){\n\tfor(int i=1;i<=k;++i){\n\t\tint sum=0;\n\t\tfor(int j=l;j>=0;--j){\n\t\t\tsum=(sum+f[i-1][j])%mod;\n\t\t\tif(i==1) sum=1;\n\t\t\tif(i-1+j<=in && k-i+l-j<=in) f[i][j]=sum;\n\t\t\telse f[i][j]=0;\n\t\t}\n\t\tf[1][0]=0;\n\t}\n\treturn f[k][0];\n}\nint solve(int n,int m){\n\tif(n==1) return 1;\n\tint ans=0;\n\tfor(int i=2;i<n;++i)\n\t\tans=(ans+calc(i,n-i,m))%mod;\n\treturn 1ll*ans*fac[n-1]%mod;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;--i)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nsigned main(){\n\tcin>>n>>k>>mod;\n\tinit(n);int ans=0;\n\tfor(int i=0;i<=k;++i) //枚举多少个点度数为0\n\t{\n\t\tans=ans+solve(n-i,k-i)*fac[n]%mod*inv[n-i]%mod;\n\t\tans%=mod;\t\n\t} \n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=207;\nll mod;\n\nint n, k;\n\nll kom[nax][nax];\nll sil[nax];\n\nll wyn;\n\ninline void dod(ll &a, ll b)\n{\n\tif ((a+=b)>=mod)\n\t\ta-=mod;\n}\n\nvoid sdod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nll dp[nax][nax];\n\nint main()\n{\n\tscanf(\"%d%d%lld\", &n, &k, &mod);\n\tsil[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tsil[i]=(sil[i-1]*i)%mod;\n\tfor (int i=0; i<=n; i++)\n\t{\n\t\tkom[i][0]=1;\n\t\tfor (int j=1; j<=i; j++)\n\t\t\tkom[i][j]=(kom[i-1][j-1]+kom[i-1][j])%mod;\n\t}\n\tif (k==n-1)\n\t\twyn=sil[n];\n\tfor (int r=3; r<=n; r++)\n\t{\n\t\tll spo=kom[n][r]*sil[r-1]%mod*sil[n-r]%mod;\n\t\tint naj=k-(n-r);\n\t\tif (naj<=0)\n\t\t\tcontinue;\n\t\t//~ debug() << imie(spo) << imie(naj);\n\t\tfor (int s=2; s<r; s++)\n\t\t{\n\t\t\tint lew=s-1;\n\t\t\tint pra=r-s;\n\t\t\t//~ sdod(wyn, kom[lew+pra+1][lew]*spo);\n\t\t\tif (lew>naj)\n\t\t\t\tcontinue;\n\t\t\t//~ debug() << imie(lew) << imie(pra) << imie(wyn);\n\t\t\t//~ if (!lew)\n\t\t\t//~ {\n\t\t\t\t//~ if (r-2<=naj)\n\t\t\t\t\t//~ dod(wyn, spo);\n\t\t\t\t//~ continue;\n\t\t\t//~ }\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\tdp[1][0]=1;\n\t\t\tfor (int i=1; i<=lew; i++)\n\t\t\t{\n\t\t\t\tfor (int j=0; j<=pra; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!dp[i][j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//~ debug() << i << \" \" << j << \" \" << dp[i][j];\n\t\t\t\t\t//~ if (lew-i+j+1<=naj)\n\t\t\t\t\t\tdod(dp[i+1][j], dp[i][j]);\n\t\t\t\t\tif (pra-(j+1)+i<=naj && lew-i+j+1<=naj)\n\t\t\t\t\t\tdod(dp[i][j+1], dp[i][j]);\n\t\t\t\t\tif (i==lew && j && (j==pra || pra-(j+1)+lew+1<=naj))\n\t\t\t\t\t{\n\t\t\t\t\t\t//~ debug() << \"tak\";\n\t\t\t\t\t\tsdod(wyn, dp[i][j]*spo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//~ for (int i=2; i<=s; i++)\n\t\t\t//~ {\n\t\t\t\t//~ for (int j=s; j<=r; j++)\n\t\t\t\t//~ {\n\t\t\t\t\t//~ if (j<r)\n\t\t\t\t\t\t//~ dod(dp[i][j+1], dp[i][j]);\n\t\t\t\t\t//~ if (i==s-1)\n\t\t\t\t\t//~ {\n\t\t\t\t\t\t\n\t\t\t\t\t//~ }\n\t\t\t\t\t//~ else\n\t\t\t\t\t//~ {\n\t\t\t\t\t\t//~ if (j-i>naj || r-1-(j-i)>naj)\n\t\t\t\t\t\t\t//~ continue;\n\t\t\t\t\t\t//~ dod(dp[i+1][j], dp[i][j]);\n\t\t\t\t\t//~ }\n\t\t\t\t//~ }\n\t\t\t//~ }\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXN = 200;\n\nint mod;\nint choose[MAXN + 1][MAXN + 1];\nint fac[MAXN + 1];\n\nvoid inc(int &a, int b) { if ((a += b) >= mod) a -= mod; }\n\nint dp[MAXN + 1][MAXN + 1]; // dp[i][j] = ways to fill in x[i..na) with values j or greater, such that the constaint is satisfied for a[i..na) and b[j..nb) with the remaining values of x being j or less\n\nint calccyc(int n, int lim) {\n\tint ret = 0;\n\tFORE(na, 1, min(n - 2, lim)) {\n\t\tint nb = n - na - 1;\n\t\tif (nb > lim) continue;\n\t\tfor (int i = na; i >= 0; --i) for (int j = nb; j >= 0; --j) {\n\t\t\tif (i == na && j == nb) { dp[i][j] = 1; continue; }\n\t\t\tdp[i][j] = 0;\n\t\t\tif (i < na && i + nb - j <= lim && (j < nb || i>0)) inc(dp[i][j], dp[i + 1][j]);\n\t\t\tif (j < nb && j + na - (i - 1) <= lim) inc(dp[i][j], dp[i][j + 1]);\n\t\t}\n\t\tint mult = (ll)choose[n - 1][na] * fac[na] % mod*fac[nb] % mod;\n\t\t//printf(\"\\t%d/%d -> %d*%d\\n\", na, nb, mult, dp[0][0]);\n\t\tret = (ret + (ll)mult*dp[0][0]) % mod;\n\t}\n\t//printf(\"calccyc(%d,%d)=%d\\n\", n, lim, ret);\n\treturn ret;\n}\n\nint n, lim;\n\nint solve() {\n\tREPE(i, n) { choose[i][0] = choose[i][i] = 1; FOR(j, 1, i) choose[i][j] = (choose[i - 1][j - 1] + choose[i - 1][j]) % mod; }\n\tfac[0] = 1; FORE(i, 1, n) fac[i] = (ll)fac[i - 1] * i % mod;\n\n\tint ret = 0;\n\tREPE(nsingle, n) {\n\t\tint mult = (ll)choose[n][nsingle] * fac[nsingle] % mod;\n\t\tint rem = n - nsingle;\n\t\tif (rem == 1 || rem == 2) continue;\n\t\tint ways;\n\t\tif (rem == 0) {\n\t\t\tif (lim < nsingle - 1) continue;\n\t\t\tways = 1;\n\t\t} else {\n\t\t\tint remlim = lim - nsingle;\n\t\t\tif (2 * remlim < rem - 1) continue;\n\t\t\tways = calccyc(rem, remlim);\n\t\t}\n\t\tret = (ret + (ll)mult*ways) % mod;\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\", &n, &lim, &mod);\n\tprintf(\"%d\\n\", solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\nint Mod;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Mul(int &a, int b){ a = mul(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\ncs int N = 205;\nint n, K, C[N][N], fc[N];\nvoid fc_init(int n){\n\tfc[0]=fc[1]=1;\n\tfor(int i=2; i<=n; i++)fc[i]=mul(fc[i-1],i);\n\tfor(int i=0; i<=n; i++)C[i][0]=1;\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=i; j++)\n\tC[i][j]=add(C[i-1][j-1],C[i-1][j]);\n}\nint cope(int k, int l, int lm){\n\tstatic int dp[N][N];\n\tfor(int i=0; i<=l; i++)\n\tfor(int j=0; j<=k; j++)dp[i][j]=0;\n\tdp[1][0]=1;\n\tfor(int i=1; i<=l; i++){\n\t\tfor(int j=0; j<=k; j++){\n\t\t\tif(j)Add(dp[i][j],dp[i][j-1]);\n\t\t\tAdd(dp[i][j],dp[i-1][j]);\n\t\t\tif(j&&l-i+j-1>lm)dp[i][j]=0;\n\t\t} for(int j=0; j<=k; j++)\n\t\tif(k-j+i-1>lm)dp[i][j]=0;\n\t} int ans = 0;\n\tfor(int i=1; i<=k; i++)\n\tAdd(ans,dp[l][i]); \n\treturn ans;\n}\nint work(int n, int k){\n\tif(n==0) return 1;\n\tif(n==1) return 0; \n\tif(k<=0) return 0;\n\tint ans = 0;\n\tfor(int i=0,coe; i<=k&&i<n; i++){\n\t\tcoe=mul(C[n-1][i],mul(fc[i],fc[n-i-1]));\n\t\tAdd(ans, mul(coe,cope(i,n-i-1,k-1)));\n\t} return ans;\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d%d%d\",&n,&K,&Mod);\n\tfc_init(n); int ans = 0;\n\tfor(int i=0; i<=K+1; i++){\n\t\tAdd(ans, mul(mul(C[n][i],fc[i]),work(n-i,K-i)));\n\t} cout << ans; return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 207;\nint mo,n,lim;\nint res,fac[N],ifac[N],f[N][N],qz[N];\ninline void add(int &x,int y){x=(x+y)%mo;}\nint power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1ll*res*a%mo;\n\t\ta=1ll*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\ninline void red(int &x){x+=x>>31&mo;}\nint main() {\n\tread(n);read(lim);read(mo);\n\tfac[0]=1;rep(i,1,n)fac[i]=1ll*fac[i-1]*i%mo;\n\trep(i,0,n)ifac[i]=power(fac[i],mo-2);\n\trep(x,0,n)rep(y,1,n-1-x)if(y<=lim-x&&n-1-x-y>=1){\n\t\trep(i,0,y)rep(j,0,n-1-x-y)f[i][j]=0;\n\t\tf[0][0]=1;\n\t\trep(i,1,y){\n\t\t\tqz[0]=f[i-1][0];\n\t\t\trep(j,1,n-1-x-y)qz[j]=qz[j-1]+f[i-1][j]-mo,red(qz[j]);\n\t\t\trep(j,0,n-1-x-y)if(j+y+x-i<=lim&&n+i-j-y-1<=lim){\n\t\t\t\tif(max(n-2+i-lim-y,0)<=j-1)\n\t\t\t\t\tf[i][j]=qz[j-1]-(max(n-2+i-lim-y,0)<0?0:qz[max(n-2+i-lim-y,0)-1]),red(f[i][j]);\n\t\t\t\tadd(f[i][j],f[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tint cur=0;rep(j,1,n-1-x-y)add(cur,f[y][j]);\n\t\tif(cur){\n\t\t\tres=(res+1ll*cur*fac[n]%mo*ifac[n-x]%mo*fac[n-1-x]%mo)%mo;\n\t\t//\tprintf(\"%d %d:%d %d\\n\",x,y,cur,1ll*cur*fac[n]%mo*ifac[n-x]%mo*fac[n-1-x]%mo);\n\t\t}\n\t\t//*ifac[n-1-x-y]%mo*fac[n-1-x-y]\n\t}\n\tif(n-1<=lim)add(res,fac[n]);//suowanle\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\n//const ll mod=1000000007;\nll mod;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=210;\nint dp[N][N],comb[N][N];\nint n,k;\nvoid upd(int &a,int b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\n\nint calc(int n,int m,int a,int b) {\n\tint ans=comb[n+m][n];\n\tPII p(0,0); int sg=0;\n\twhile (1) {\n\t\tif (sg==0) p=mp(p.se-a,p.fi+a);\n\t\telse p=mp(p.se-b,p.fi+b);\n\t\tif (p.fi>n||p.se>m) break;\n\t\tif (sg==0) ans=(ans+mod-comb[n+m][n-p.fi])%mod;\n\t\telse ans=(ans+comb[n+m][n-p.fi])%mod;\n\t\tsg^=1;\n\t}\n\tp=mp(0,0); sg=0;\n\twhile (1) {\n\t\tif (sg==0) p=mp(p.se-b,p.fi+b);\n\t\telse p=mp(p.se-a,p.fi+a);\n\t\tif (p.fi>n||p.se>m) break;\n\t\tif (sg==0) ans=(ans+mod-comb[n+m][n-p.fi])%mod;\n\t\telse ans=(ans+comb[n+m][n-p.fi])%mod;\n\t\tsg^=1;\n\t}\n\treturn ans;\n}\nint solve(int x,int y) {\n\tif (y<0) return 0;\n\tif (y==0) return x<=1;\n\tint ans=0;\n\tfor (int a=2;a<=y+1;a++) {\n\t\tint b=x-a;\n\t\tif (b<1||b>y+1) continue;\n\t\tint t=calc(a-1,b,b-(y+2),(y+2)-a);\n\t\tif (a+b<=y+1) upd(t,mod-1);\n\t\tupd(ans,t);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d%lld\",&n,&k,&mod);\n\tfor (int i=0;i<=2*n;i++) {\n\t\tcomb[i][0]=comb[i][i]=1;\n\t\trep(j,1,i) comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%mod;\n\t}\n\tint ans=0;\n\tfor (int deg=0;deg<=n-2;deg++) {\n\t\tans=(ans+(ll)solve(n-deg,k-deg)*powmod(n-deg,mod-2))%mod;\n\t}\n\tif (k>=n-1) {\n\t\tans=(ans+1)%mod;\n\t}\n\trep(i,1,n+1) ans=(ll)ans*i%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int N=207;\n\nint n, m, k, u, v, x, y, t, a, b, ans, mod;\nint F[N];\nint dp[2][N][N][N];\nint val[N][N][N];\n\ninline void fix(int &x){\n\tif (x>=mod) x-=mod;\n//\tif (x<0) x+=mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tfor (int j=0; j<N; j++) for (int k1=max(j-1, 0); k1<N; k1++) for (int k2=0; k2<N; k2++) dp[0][j][k1][k2]=1;\n\tcin>>n>>k>>mod;\n\t\n\tfor (int i=1; i<N; i++){\n\t\tint cur=(i&1);\n\t\tfor (int j=0; i+j<N; j++) for (int k1=0; k1<i+j; k1++) for (int k2=0; k2<i+j; k2++) dp[cur][j][k1][k2]=0;\n\t\tfor (int k1=0; k1<i; k1++) for (int k2=i-1; k2<i; k2++) dp[cur][0][k1][k2]=1;\n\t\tfor (int j=1; i+j<N; j++){\n\t\t\tfor (int k1=j-1; k1<i+j; k1++) for (int k2=i-1; k2<i+j; k2++){\n\t\t\t\tif (k2) dp[cur][j][k1][k2]+=dp[cur][j-1][min(k1, i+j-2)][k2-1];\n\t\t\t\tif (k1) dp[cur][j][k1][k2]+=dp[cur^1][j][k1-1][min(k2, i+j-2)];\n\t\t\t\tfix(dp[cur][j][k1][k2]);\n\t\t\t}\n\t\t}\n\t\tfor (int j=1; i+j<N; j++) for (int k=max(1, j-1); k<i+j; k++) for (int x=1; x<j && x<=k; x++){\n\t\t\tif (i-1+x<=k) fix(val[j][i][k]+=dp[cur^1][j-x][min(k-1, i+j-x-2)][min(k-x, i+j-x-2)]);\n\t\t}\n\t\t\n//\t\tif (i==1) debug2(cur, dp[cur][2][1][1])\n//\t\tif (i==1) debug2(cur, dp[cur][1][1][1])\n\t\t\n\t\t\n\t}\n\tF[0]=1;\n\tfor (int i=1; i<N; i++) F[i]=F[i-1]*i%mod;\n\t\n\tif (k==n-1){\n//\t\tdebug(\"dag\")\n\t\tans=1;\n\t\tfor (int i=1; i<=n; i++) ans=1ll*ans*i%mod;\n\t}\n\t\n\tfor (int t=0; t<=min(k, n-3); t++){\n\t\tfor (int X=1; X<n-t; X++){\n\t\t\tint Y=n-X-t-1;\n\t\t\tll tmp=1;\n\t\t\tfor (int i=1; i<=n; i++) if (i!=n-t) tmp=tmp*i%mod;\n\t\t\ttmp=tmp*val[X+1][Y][min(k-t, X+Y)]%mod;\n//\t\t\tcerr<<t<<\"  \"<<X<<\" \"<<Y<<\"   \"<<tmp<<\"\\n\";\n\t\t\tans=(ans+tmp)%mod;\n\t\t}\n\t}\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<\"\\n\";\n\t\n//\tdebug(val[2][3][2]) // should be 0\n//\tdebug(val[3][1][1]) // should be 0\n//\tdebug(val[3][2][2]) // should be 1\n\t\n\treturn 0;\n}\n/*\n5 2 1000000007\n5 3 1000000007\n5 4 1000000007\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 205;\n\nint n, k, P, fac[N], inv[N];\n\nint qpow(int a, int b) {\n\tint s = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) {\n\t\t\ts = 1ll * s * a % P;\n\t\t}\n\t\ta = 1ll * a * a % P;\n\t}\n\treturn s;\n}\n\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\t}\n\tinv[n] = qpow(fac[n], P - 2);\n\tfor (int i = n; i; --i) {\n\t\tinv[i - 1] = 1ll * inv[i] * i % P;\n\t}\n}\n\nint f[N][N];\n\nint calc(int k, int l, int m) {\n\tfor (int i = 1; i <= k; ++i) {\n\t\tint sum = 0;\n\t\tfor (int j = l; j >= 0; --j) {\n\t\t\tsum = i > 1 ? (sum + f[i - 1][j]) % P : 1;\n\t\t\tif (i - 1 + j <= m && k - i + l - j <= m) {\n\t\t\t\tf[i][j] = sum;\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tf[1][0] = 0;\n\t}\n\treturn f[k][0];\n}\n\nint solve(int n, int m) {\n\tif (n == 1) {\n\t\treturn 1;\n\t}\n\tint ans = 0;\n\tfor (int i = 2; i < n; ++i) {\n\t\tans = (ans + calc(i, n - i, m)) % P;\n\t}\n\treturn 1ll * ans * fac[n - 1] % P;\n}\n\nint main() {\n\tread(n), read(k), read(P);\n\tinit(n);\n\tint ans = 0;\n\tfor (int i = 0; i <= k; ++i) {\n\t\tans = (ans + 1ll * fac[n] * inv[n - i] % P * solve(n - i, k - i)) % P;\n\t}\n\t// debug(\"%d\\n\", calc(4, 3, 3));\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint MOD;\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\ninline int sub(int a,int b)\n{a-=b;return a<0?a+MOD:a;}\ninline int mul(int a,int b)\n{return 1ll*a*b%MOD;}\nint ksm(int a,int b)\n{\n\tint ans=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1)ans=mul(ans,a);\n\treturn ans;\n}\nconst int Q=55;\nint f[Q][Q];\nint fac[Q+1],ifac[Q+1];\nint G(int n,int m,int k)\n{\n\tif(n>k||m>k)return 0;\n\tmemset(f,0,sizeof(f));\n\tfor(int j=0;j<=min(m-1,k-n);j++)\n\t\tf[1][j]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tif(!f[i][j])continue;\n\t\t\tint r=min(i+k-n,m),l=max(j,m-k+i);\n\t\t\tif(l<=r)f[i+1][l]=add(f[i+1][l],f[i][j]),f[i+1][r+1]=sub(f[i+1][r+1],f[i][j]);\n\t\t}\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tf[i+1][j]=add(f[i+1][j],f[i+1][j-1]);\n\t}\n\tint als=0;\n\tfor(int j=0;j<=m;j++)\n\t\tals=add(als,f[n][j]);\n\treturn mul(als,fac[n+m]);\n}\nint main()\n{\n\tint n,kk;\n\tscanf(\"%d%d%d\",&n,&kk,&MOD);\n\tfac[0]=1;\n\tfor(int i=1;i<=Q;i++)\n\t\tfac[i]=mul(fac[i-1],i);\n\tifac[Q]=ksm(fac[Q],MOD-2);\n\tfor(int i=Q;i;--i)\n\t\tifac[i-1]=mul(ifac[i],i);\n\tint als=mul(kk==n-1,fac[n]);\n\tfor(int d=0;d<kk;d++)\n\t\tfor(int i=1;i<=n-d-2;i++)\n\t\t\tals=add(als,mul(mul(fac[n],ifac[n-d]),G(i,n-d-i-1,kk-d)));\n\tprintf(\"%d\\n\",als);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod;\nconst int N=205;\nint n,k;\nll c[N][N];\nll dp[N];\nint mn[N],mx[N];\nll f[N];\nll pw(ll x,ll y){\n\tif(y==0) return 1;\n\tif(y%2) return x*pw(x,y-1)%mod;\n\tll res=pw(x,y/2);\n\treturn res*res%mod;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> k >> mod;\n\tf[0]=1;\n\tfor(int i=0; i<=n ;i++){\n\t\tif(i>0) f[i]=f[i-1]*i%mod;\n\t\tc[i][0]=0;\n\t\tfor(int j=1; j<=i ;j++){\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t\t}\n\t}\n\tll ans=0;\n\tll arin=1;\n\tfor(int i=0; i<=n-3 ;i++){//number of funny nodes\n\t\tint cn=n-i;\n\t\tint ck=k-i;\n\t\tif(ck*2<cn-1) continue;\n\t\tfor(int p=2; p<cn ;p++){//size of P\n\t\t\tbool ok=true;\n\t\t\tint q=cn-p;\n\t\t\tfor(int j=1; j<=p ;j++){\n\t\t\t\tmn[j]=max(0,q-k+i-1);\n\t\t\t\tmx[j]=q;\n\t\t\t}\n\t\t\tfor(int j=1; j<=q ;j++){\n\t\t\t\tif(p-k+j-2>=p) ok=false;\n\t\t\t\tif(p-k+j-2<=0) continue;\n\t\t\t\tmx[p-k+j-2]=j-1;\n\t\t\t}\n\t\t\t//cout << p << ' ' << q << ' ' << mx[0] << endl;\n\t\t\tmx[1]=min(mx[1],q-1);\n\t\t\tmn[p]=max(mn[p],q);\n\t\t\tfor(int j=1; j<=q ;j++){\n\t\t\t\tif(mn[j]>mx[j]) ok=false;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tdp[0]=1;\n\t\t\tfor(int j=1; j<=p ;j++) dp[j]=0;\n\t\t\tfor(int j=1; j<=p ;j++){\n\t\t\t\tll sum=0;\n\t\t\t\tfor(int y=0; y<=mx[j] ;y++){\n\t\t\t\t\tsum=(sum+dp[y])%mod;\n\t\t\t\t\tif(y<mn[j]) dp[y]=0;\n\t\t\t\t\telse dp[y]=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << cn << ' ' << p << ' ' << q << ' ' << dp[q] << endl;\n\t\t\tans=(ans+dp[q]*f[n-i-1]%mod*arin)%mod;\n\t\t}\n\t\tarin=arin*(n-i)%mod;\n\t}\n\tif(k==n-1) ans=(ans+f[n])%mod;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nint MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T; \n \t/// don't silently convert to T\n\tT v; explicit operator T() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend str ts(mi a) { return ts(a.v); }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: pre-compute factorial mod inverses,\n \t* assumes $MOD$ is prime and $SZ < MOD$.\n * Time: O(SZ)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n */\n\nvi invs, fac, ifac;\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); \n\tinvs[1] = fac[0] = ifac[0] = 1; \n\tFOR(i,2,SZ) invs[i] = MOD-(ll)MOD/i*invs[MOD%i]%MOD;\n\tFOR(i,1,SZ) {\n\t\tfac[i] = (ll)fac[i-1]*i%MOD;\n\t\tifac[i] = (ll)ifac[i-1]*invs[i]%MOD;\n\t}\n}\n/**\nll comb(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn (ll)fac[a]*ifac[b]%MOD*ifac[a-b]%MOD;\n}\n*/\n\nmi dp[205][205];\n\nmi go(int l, int r, int k) {\n\tassert(l && r);\n\tif (l > k || r > k) return 0;\n\t//dbg(\"GO\",l,r,k);\n\tFOR(i,1,l+2) F0R(j,r+1) dp[i][j] = 0;\n\tdp[1][0] = 1;\n\tFOR(i,1,l+2) F0R(j,r+1) {\n\t\tif (j < r && r-j+i-1 <= k) dp[i][j+1] += dp[i][j]; // j+1-st beat everything up to i\n\t\tif (i < l+1 && l-i+j >= 1 && l-i+j <= k) dp[i+1][j] += dp[i][j]; // determine i\n\t}\n\t// j < r and r-j+i-1 <= k\n\tassert(dp[l+1][0] == 0);\n\treturn dp[l+1][r];\n}\n\nmi solve(int n, int k) {\n\tif (n <= 2 || k <= 0) return 0;\n\tmi res = 0;\n\tFOR(beat,1,k+1) if (beat < n-1) {\n\t\tres += go(beat,n-1-beat,k);\n\t\tdbg(n,k,beat,res);\n\t}\n\tres *= fac[n-1];\n\treturn res;\n}\n\nint main() {\n\tint N,K;\n\tsetIO(); re(N,K,MOD); \n\tgenFac(N+1);\n\tmi mul = 1, ans = 0;\n\tF0R(i,N) {\n\t\tans += mul*solve(N-i,K-i);\n\t\tmul *= N-i;\n\t}\n\tif (K == N-1) ans += mul;\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint mod,fac[210],inv[210],f[210];\nint main()\n{\n\tre int n,k,ans=0;\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tfac[0]=1;\n\tfor(re int i=1;i<=n;i++)fac[i]=1ll*i*fac[i-1]%mod;\n\tinv[1]=1;\n\tfor(re int i=2;i<=n;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(re int i=n-k-1;i<n;i++)\n\t{\n\t\tre int k1=k-(n-i-1);\n\t\tfor(re int i1=std::max(1,i-k1);i1<i&&i1<=k1;i1++)\n\t\t{\n\t\t\tre int i2=i-i1;\n\t\t\tmemset(f,0,sizeof(f));\n\t\t\tfor(re int i=0;i<i2;i++)if(i2-i<=k1&&i+i1<=k1)f[i]=1;\n\t\t\tfor(re int i=1;i<i1;i++)\n\t\t\t{\n\t\t\t\tfor(re int j=0;j<=i2;j++)\n\t\t\t\t{\n\t\t\t\t\tf[j+1]=(f[j]+f[j+1])%mod;\n\t\t\t\t\tif(!(i2-j+i<=k1&&j+i1-i<=k1))f[j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(re int j=0;j<=i2;j++)ans=(ans+1ll*inv[i+1]*f[j])%mod;\n\t\t//\tprintf(\"****%d %d %d %lld\\n\",i,i1,i2,1ll*ans*fac[n]%mod);\n\t\t}\n\t}\n\tif(k==n-1)ans++;\n\tans=1ll*ans*fac[n]%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,ll>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=205;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,k,Mod,Fac[MAXN],iFac[MAXN];\ninline void Add(int&x,int y){x+=y,x>=Mod?x-=Mod:0;}\ninline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\ninline void Init(int n){\n\tFac[0]=1;Rep(i,1,n)Fac[i]=1ll*Fac[i-1]*i%Mod;\n\tiFac[n]=Fp(Fac[n],Mod-2);Red(i,n,1)iFac[i-1]=1ll*iFac[i]*i%Mod;\n}\ninline int Solve(int n,int k){\n\tint ans=0;\n\tRep(deg,1,min(k,n-2)){\n\t\tstatic int dp[MAXN][MAXN];\n\t\tif(n-1-deg>k)continue;\n\t\tmemset(dp,0,sizeof(dp)),dp[0][deg]=1,dp[0][deg+1]=Mod-1;\n\t\tRep(i,0,deg-1)Rep(j,deg,n-1){\n\t\t\tAdd(dp[i][j],dp[i][j-1]);\n\t\t\tint tmp=dp[i][j],l=max(max(j,i+2),n+i-k),r=min(n-1,k+(i+1));\n\t\t\tif(l<=r)Add(dp[i+1][l],tmp),Add(dp[i+1][r+1],Mod-tmp);\n\t\t}Rep(i,deg,n-1)Add(dp[deg][i],dp[deg][i-1]),Add(ans,dp[deg][i]);\n\t}return 1ll*ans*Fac[n-1]%Mod;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),k=read(),Mod=read(),Init(n);int ans=(k==n-1)?Fac[n]:0;\n\tRep(i,3,n)ans=(ans+1ll*Fac[n]*iFac[i]%Mod*Solve(i,k-(n-i)))%Mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long Mod, F[1010], InvF[1010];\nlong long Pow(long long a, long long b){\n    long long r=1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long Comb(int a, int b){\n    if(a<b||b<0)return 0ll;\n    return F[a]*InvF[b]%Mod*InvF[a-b]%Mod;\n}\nint D[210][210][210], S[210][210][210];\nlong long CC[210];\nlong long Calc(int n, int K){\n    if(K*2<n-1)return 0ll;\n    int d = 2*K-n+2, i, j, k;\n    for(i=0;i<=n-K-1;i++){\n        for(k=0;k<=i+i;k++){\n            for(j=i;j<=i+d;j++){\n                D[i][k][j]=S[i][j][k]=0;\n            }\n        }\n    }\n    D[0][0][0]=1;\n    for(i=0;i<=n-K-2;i++){\n        for(j=0;j<=i+i;j++){\n            for(k=i;k<=i+d;k++){\n                S[i][j][k]=D[i][j][k];\n                if(k){\n                    S[i][j][k]+=S[i][j][k-1];\n                    if(S[i][j][k]>=Mod)S[i][j][k]-=Mod;\n                }\n            }\n            for(k=i+1;k<=i+d;k++){\n                int tj=j;\n                if(k==i+1)tj++;\n                if(k==i+d)tj++;\n                D[i+1][tj][k]=(D[i+1][tj][k]+S[i][j][k])%Mod;\n             //   printf(\"%d %d %d %d\\n\",i+1,tj,k,S[i][j][k]);\n            }\n        }\n    }\n    for(i=0;i<=n;i++)CC[i]=0;\n    for(i=n-K-1;i<=K;i++){\n        for(j=0;j<=n;j++){\n            CC[j+1]=(CC[j+1]+D[n-K-1][j][i])%Mod;\n        }\n    }\n    long long s=0;\n    for(i=1;i<=n;i++){\n        s=(s+CC[i]*Pow(i,Mod-2))%Mod;\n    }\n    s=s*F[n]%Mod;\n    return s;\n}\nlong long Get(int n, int K){\n    if(K==n-1)return F[n];\n    long long res=0;\n    int i;\n    for(i=0;i<=K;i++){\n        res=(res+Calc(n-i,K-i)*Comb(n,i)%Mod*F[i])%Mod;\n    }\n  //  printf(\"%d %d %lld\\n\",n,K,res);\n    return res;\n}\nint main(){\n    int i;\n    int n, K;\n    scanf(\"%d%d%lld\",&n,&K,&Mod);\n    F[0]=InvF[0]=1;\n    for(i=1;i<=n;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=Pow(F[i],Mod-2);\n    }\n    long long res=0;\n    for(i=K;i>=1;i--){\n        res=(res+Get(n,i))%Mod;\n    }\n    printf(\"%lld\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll dp[202][202];\n\n\nll hoge(int N,int K) {\n\t\n\tif(N==1) return 1;\n\tif(N==2) return 0;\n\t\n\tint x,y,k,l,i;\n\tll ret=0;\n\tfor(k=1;k<=N-2;k++) {\n\t\tl=N-1-k;\n\t\tif(k>K || l>K) continue;\n\t\tZERO(dp);\n\t\tdp[0][0]=1;\n\t\tFOR(y,k+1) FOR(x,l+1) {\n\t\t\tif(y==0&&x==l) dp[y][x]=0;\n\t\t\t//cout<<y<<x<<\" \"<<dp[y][x]<<endl;\n\t\t\tif(x&&y+(l-x)>K) continue;\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\tif(x+k-y<=K) (dp[y][x+1]+=dp[y][x])%=mo;\n\t\t}\n\t\tret+=dp[k][l];\n\t}\n\tfor(i=1;i<=N-1;i++) ret=ret*i%mo;\n\t//cout<<N<<K<<\" \"<<ret<<endl;\n\treturn ret;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tll ret=0;\n\tll fac=1;\n\twhile(2*K>=N-1) {\n\t\tret+=fac*hoge(N,K)%mo;\n\t\tfac=fac*N%mo;\n\t\tN--,K--;\n\t}\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 210;\n\nint N, K;\nll P;\n\nll dp[MAXN][MAXN];\nll choose[MAXN][MAXN];\n\nll res[MAXN];\n\nll rr[MAXN][MAXN];\n\nll gogo (int A, int B)\n{\n    if (B < A / 2) return 0;\n    if (A == 1) return 1;\n    if (B > A - 2) B = A - 2;\n\n    int blo = (A - 1 - B);\n    ll ans = 0;\n    for (int k = blo; k <= B; k++)\n    {\n        for (int i = 0; i <= A + 1; i++)\n            for (int j = 0; j <= A + 1; j++)\n                rr[i][j] = 0;\n\n        rr[0][k] = 1;\n        for (int l = 1; l <= k; l++)\n        {\n            ll cc = rr[l-1][blo];\n            for (int m = blo; m <= min (B, N - l - 1); m++)\n            {\n                cc += rr[l-1][m+1];\n                cc %= P;\n                rr[l][m] = cc;\n            }\n        }\n        for (int l = blo; l <= B; l++)\n        {\n            ans += rr[k][l];\n            ans %= P;\n        }\n    }\n    //cout << A << \" \" << B << \" \" << ans << \"\\n\";\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> K >> P;\n\n    choose[0][0] = 1;\n    for (int i = 1; i < MAXN; i++)\n        for (int j = 0; j <= i; j++)\n        {\n            choose[i][j] = choose[i-1][j];\n            if (j)\n                choose[i][j] = (choose[i][j] + choose[i-1][j-1]) % P;\n        }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; i++)\n    {\n        // bottom cycle size\n        ll v = gogo (i, K - (N - i));\n        for (int j = 1; j <= N; j++)\n            if (j != i)\n                v = (v * j) % P;\n        ans += v;\n    }\n    cout << ans % P << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 210;\nint n,k,mod;\n\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\nint fac[N],ifac[N];\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint f[N][N],g[N];\ninline void upd(int &x,int y){\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int dp(int m,int n,int deg){\n\tFor(i,0,n) For(j,0,m) f[i][j]=0;\n\tFOR(j,0,m) if (!((j&&j-1+n>deg)||m-j>deg)) f[1][j]=1;\n\tFor(i,2,n){\n\t\tint s=0;\n\t\tFOR(j,0,m){\n\t\t\tf[i][j]=s=Mod(s+f[i-1][j]);\n\t\t\tif ((j&&j-1+(n-i+1)>deg)||m-j+i-1>deg) f[i][j]=0;\n\t\t}\n\t}\n\tint ret=0;\n\tFOR(i,1,m) upd(ret,f[n][i]);\n\treturn ret;\n}\ninline int calc(int n,int deg){\n\tif (n==0) return 1;\n\tif (n==1) return 0;\n\tint ret=0;\n\tFor(i,1,min(deg+1,n)) ret=(ret+1ll*C(n-1,i-1)*fac[n-i]%mod*fac[i-1]%mod*dp(i,n-i,deg))%mod;\n\treturn ret;\n}\n\nint main(){\n\tn=read(),k=read(),mod=read();\n\tinit(n);\n\tint ans=0;\n\tFor(i,0,min(n,k+1)) ans=(ans+1ll*C(n,i)*fac[i]%mod*calc(n-i,k-i))%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long Mod, F[1010], InvF[1010];\nlong long Pow(long long a, long long b){\n    long long r=1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long Comb(int a, int b){\n    if(a<b||b<0)return 0ll;\n    return F[a]*InvF[b]%Mod*InvF[a-b]%Mod;\n}\nint D[210][210][210], S[210][210][210];\nlong long CC[210];\nlong long Calc(int n, int K){\n    if(K*2<n-1)return 0ll;\n    int d = 2*K-n+2, i, j, k;\n    for(i=0;i<=n-K-1;i++){\n        for(k=0;k<=i+i;k++){\n            for(j=i;j<=i+d;j++){\n                D[i][k][j]=S[i][j][k]=0;\n            }\n        }\n    }\n    D[0][0][0]=1;\n    for(i=0;i<=n-K-2;i++){\n        for(j=0;j<=i+i;j++){\n            for(k=i;k<=i+d;k++){\n                S[i][j][k]=D[i][j][k];\n                if(k){\n                    S[i][j][k]+=S[i][j][k-1];\n                    if(S[i][j][k]>=Mod)S[i][j][k]-=Mod;\n                }\n            }\n            for(k=i+1;k<=i+d;k++){\n                int tj=j;\n                if(k==i+1)tj++;\n                if(k==i+d)tj++;\n                D[i+1][tj][k]=(D[i+1][tj][k]+S[i][j][k])%Mod;\n             //   printf(\"%d %d %d %d\\n\",i+1,tj,k,S[i][j][k]);\n            }\n        }\n    }\n    for(i=0;i<=n;i++)CC[i]=0;\n    for(i=n-K-1;i<=K;i++){\n        for(j=0;j<=n;j++){\n            CC[j+1]=(CC[j+1]+D[n-K-1][j][i])%Mod;\n        }\n    }\n    long long s=0;\n    for(i=1;i<=n;i++){\n        s=(s+CC[i]*Pow(i,Mod-2))%Mod;\n    }\n    s=s*F[n]%Mod;\n    return s;\n}\nlong long Get(int n, int K){\n    long long res=0;\n    int i;\n    for(i=0;i<=n;i++){\n        res=(res+Calc(n-i,K-i)*Comb(n,i)%Mod*F[i])%Mod;\n    }\n    return res;\n}\nint main(){\n    int i;\n    int n, K;\n    scanf(\"%d%d%lld\",&n,&K,&Mod);\n    F[0]=InvF[0]=1;\n    for(i=1;i<=n;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=Pow(F[i],Mod-2);\n    }\n    long long res=0;\n    for(i=1;i<=K;i++){\n        res=(res+Get(n,i))%Mod;\n    }\n    printf(\"%lld\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 233\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nconst int n=read(),k=read(),mod=read();\nint fac[N],inv[N],C[N][N],ans;\n#define ck(x) (x>=mod?x-mod:x)\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn n;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tinv[n]=qpow(fac[n],mod-2)%mod;\n\tfor(int i=n-1;i>=0;--i){\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%mod;\n\t}\n\tC[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tC[i][j]=ck(C[i-1][j]+C[i-1][j-1]);\n\t\t}\n\t}\n}\nint calc(int X,int Y,int k){\n\tstatic int dp[N][N];\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int j=1;j<=Y;++j){\n\t\tint s=0;\n\t\tfor(int i=0;i<X;++i){\n\t\t\ts=ck(s+dp[i][j-1]);\n\t\t\tif((Y-j+1)+(i-1)<=k&&(X-i)+(j-1)<=k){\n\t\t\t\tdp[i][j]=s;\n\t\t\t}\n\t\t}\n\t}\n\tint tot=0;\n\tfor(int i=1;i<X;++i){\n\t\ttot=ck(tot+dp[i][Y]);\n\t}\n\treturn tot;\n}\nint Solve(int n,int k){\n\tif(n==1)return 1;\n\tint tot=0;\n\tfor(int i=1;i<=k+1;++i){\n\t\ttot=(tot+calc(i,n-i,k))%mod;\n\t}\n\ttot=1LL*tot*fac[n-1]%mod;\n\treturn tot;\n}\nint main(){\n\tinit(n);\n\tfor(int i=0;i<=k;++i){\n\t\tans=(ans+1LL*C[n][i]*fac[i]%mod*Solve(n-i,k-i))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long Mod, F[1010], InvF[1010];\nlong long Pow(long long a, long long b){\n    long long r=1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long Comb(int a, int b){\n    if(a<b||b<0)return 0ll;\n    return F[a]*InvF[b]%Mod*InvF[a-b]%Mod;\n}\nint D[210][210][410], S[210][210][410];\nint DD[210][210][410];\nlong long CC[210];\nvoid Do(int d){\n    int i, j, k;\n    for(i=0;i<=101;i++){\n        for(k=0;k<=i+i;k++){\n            for(j=i;j<=i+d&&k<=200;j++){\n                D[i][k][j]=S[i][j][k]=0;\n            }\n        }\n    }\n    D[0][0][0]=1;\n    for(i=0;i<=100;i++){\n        for(j=0;j<=i+i;j++){\n            for(k=i;k<=i+d&&k<=200;k++){\n                S[i][j][k]=D[i][j][k];\n                if(k){\n                    S[i][j][k]+=S[i][j][k-1];\n                    if(S[i][j][k]>=Mod)S[i][j][k]-=Mod;\n                }\n            }\n            for(k=i+1;k<=i+d&&k<=200;k++){\n                int tj=j;\n                if(k==i+1)tj++;\n                if(k==i+d)tj++;\n                D[i+1][tj][k]=(D[i+1][tj][k]+S[i][j][k])%Mod;\n            }\n        }\n    }\n    for(i=0;i<=101;i++){\n        for(j=0;j<=i+i;j++){\n            long long s=0;\n            for(k=i;k<i+d;k++){\n                s+=D[i][j][k];\n            }\n            DD[d][i][j]=s%Mod;\n        }\n    }\n    \n}\nlong long Calc(int n, int K){\n    if(K*2<n-1)return 0ll;\n    int d = 2*K-n+2, i, j, k;\n    for(i=0;i<=n;i++)CC[i]=0;\n    for(j=0;j<=n;j++){\n        CC[j+1]=(CC[j+1] + DD[d][n-K-1][j])%Mod;\n    }\n    long long s=0;\n    for(i=1;i<=n;i++){\n        s=(s+CC[i]*Pow(i,Mod-2))%Mod;\n    }\n    s=s*F[n]%Mod;\n    return s;\n}\nlong long Get(int n, int K){\n    if(K==n-1)return F[n];\n    long long res=0;\n    int i;\n    for(i=0;i<=K;i++){\n        res=(res+Calc(n-i,K-i)*Comb(n,i)%Mod*F[i])%Mod;\n    }\n    return res;\n}\nint main(){\n    int i;\n    int n, K;\n    scanf(\"%d%d%lld\",&n,&K,&Mod);\n    F[0]=InvF[0]=1;\n    for(i=1;i<=n;i++){\n        F[i]=F[i-1]*i%Mod;\n        InvF[i]=Pow(F[i],Mod-2);\n    }\n    long long res=0;\n/*    for(i=K;i>=1;i--){\n        res=(res+Get(n,i))%Mod;\n    }*/\n    for(i=1;i<=2*K-n+2;i++)Do(i);\n    for(i=K;i>=1;i--){\n        res=(res+Get(n,i))%Mod;\n    }\n    printf(\"%lld\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 205;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, k, P, fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nint solve(int n, int k) {\n\tint ans = 0;\n\tfor (int deg = 1; deg <= k && deg <= n - 2; deg++) {\n\t\tstatic int dp[MAXN][MAXN];\n\t\tif ((n - 1) - deg > k) continue;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][deg] = 1, dp[0][deg + 1] = P - 1;\n\t\tfor (int i = 0; i <= deg - 1; i++)\n\t\tfor (int j = deg; j <= n - 1; j++) {\n\t\t\tupdate(dp[i][j], dp[i][j - 1]);\n\t\t\tint tmp = dp[i][j], l = max(max(j, i + 2), n + i - k), r = min(n - 1, k + (i + 1));\n\t\t\tif (l <= r) update(dp[i + 1][l], tmp), update(dp[i + 1][r + 1], P - tmp);\n\t\t}\n\t\tfor (int i = deg; i <= n - 1; i++) {\n\t\t\tupdate(dp[deg][i], dp[deg][i - 1]);\n\t\t\tupdate(ans, dp[deg][i]);\n\t\t}\n\t}\n\treturn 1ll * ans * fac[n - 1] % P;\n}\nint main() {\n\tread(n), read(k), read(P);\n\tinit(n); int ans = (k == n - 1) ? fac[n] : 0;\n\tfor (int i = 3; i <= n; i++)\n\t\tupdate(ans, 1ll * fac[n] * inv[i] % P * solve(i, k - (n - i)) % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n//extern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\nmodinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=ten(5);\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nconst int nmax=210;\nmint dp[nmax][nmax];\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,k;cin>>n>>k;\n\tcin>>base.mod;\n\t\n\tinitfact();\n\t\n\tmint ans=0;\n\trng(c,3,n+1){\n\t\tint lim=k-(n-c);\n\t\tif(lim<=0)continue;\n\t\trng(w,1,c-1){\n\t\t\tint h=c-w;\n\t\t\tif(h-1>lim||w-1>lim)continue;\n\t\t\tzero(dp);\n\t\t\t\n\t\t\tdp[1][0]=1;\n\t\t\trng(i,1,h+1)rep(j,w+1){\n\t\t\t\tif(i==h&&j==0)dp[i][j]=0;\n\t\t\t\tif(i<h&&h-1-i+j<=lim){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(j<w&&w-1-j+i<=lim){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmint z=dp[h][w];\n\t\t\tans+=fact[n]*finv[c]*fact[c-1]*z;\n\t\t}\n\t}\n\t\n\tif(k==n-1)ans+=fact[n];\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 211;\nint n, k, mod;\n\nint fac[maxn], invf[maxn], c[maxn][maxn];\nint qpow(int x, int y)\n{\n\tint ret = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ret = 1ll * ret * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint calc(int n, int k)\n{\n\tif(k < 0) return 0;\n\tif(n == 0) return 1;\n\tif(n < 3) return 0;\n\t\n\tint ret = 0;\n\tfor(int L=2; L<n; L++)\n\t{\n\t\tint R = n - L;\n\t\tstatic int dp[maxn][maxn];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\tdp[0][0] = 1;\n\t\tfor(int i=0; i<=L; i++) for(int j=0; j<=R; j++)\n\t\t{\n\t\t\tif(j+1 <= R)\n\t\t\t{\n\t\t\t\tint ind = L - i + j;\n\t\t\t\tif(ind > 0 && ind <= k)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j+1] += dp[i][j];\n\t\t\t\t\tif(dp[i][j+1] >= mod) dp[i][j+1] -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i+1 <= L)\n\t\t\t{\n\t\t\t\tint ind = R - j + i;\n\t\t\t\tif(ind > 0 && ind <= k && (i < L - 1 || j == R))\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\tif(dp[i+1][j] >= mod) dp[i+1][j] -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret += dp[L][R];\n\t\tif(ret >= mod) ret -= mod;\n\t}\n\tret = 1ll * ret * fac[n-1] % mod;\n\treturn ret;\n}\n\nint main()\n{\n\tget3(n, k, mod);\n\t\n\tfac[0] = invf[0] = 1;\n\tfor(int i=1; i<maxn; i++)\n\t{\n\t\tfac[i] = 1ll * i * fac[i-1] % mod;\n\t\tinvf[i] = qpow(fac[i], mod - 2);\n\t}\n\tfor(int i=0; i<maxn; i++)\n\t{\n\t\tc[i][0] = 1;\n\t\tfor(int j=1; j<=i; j++)\n\t\t{\n\t\t\tc[i][j] = c[i-1][j] + c[i-1][j-1];\n\t\t\tif(c[i][j] >= mod) c[i][j] -= mod;\n\t\t}\n\t}\n\t\n\tif(k == n - 1) k = n;\n\t\n\tint ans = 0;\n\tfor(int i=0; i<=n; i++) ans = (ans + 1ll * fac[n] * invf[n-i] % mod * calc(n - i, k - i)) % mod;\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nint n,m,k,P;\nint f[201][201],C[201][201],_mul[201],invmul[201];\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\nint calc(int n,int m,int k){\n\tif(n>k+1||m>k)return 0;\n\t--n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=m;j++)\n\t\t\tf[i][j]=-1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=std::max(0,i+m-k);j<=k-n+i&&j<=m;j++){ \n\t\t\tf[i][j]=0;\n\t\t}\n\tfor(int i=0;i<=m;i++)f[0][i]=0;\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++)f[i-1][j]=add(f[i-1][j],f[i-1][j-1]);\n\t\tfor(int j=0;j<=m;j++)\n\t\t\tif(!f[i][j]){\n\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t}\n\t\t\telse f[i][j]=0;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)cnt=add(cnt,f[n][i]);\n//\tprintf(\"%d %d %d %d\\n\",n,m,k,cnt);\n\treturn cnt;\n}\nint g(int n,int k){\n\tint tot=0;\n\tfor(int i=2;i<n;i++)\n\t\ttot=add(tot,mul(mul(mul(C[n-1][i-1],_mul[i-1]),_mul[n-i]),calc(i,n-i,k)));\n//\tprintf(\"g %d %d %d\\n\",n,k,tot);\n\treturn tot;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&P);\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=add(C[i-1][j],C[i-1][j-1]);\n\t}\n\t_mul[0]=_mul[1]=invmul[0]=invmul[1]=1;\n\tfor(int i=2;i<=n;i++)_mul[i]=mul(_mul[i-1],i);\n\tfor(int i=2;i<=n;i++)invmul[i]=mul(P-P/i,invmul[P%i]);\n\tfor(int i=2;i<=n;i++)invmul[i]=mul(invmul[i],invmul[i-1]);\n\tint ans=(k==n-1)?_mul[n]:0;\n\tfor(int i=3;i<=n;i++){\n\t\tans=add(ans,mul(C[n][i],mul(_mul[n-i],g(i,k-n+i))));\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll dp[202][202];\n\n\nll hoge(int N,int K) {\n\t\n\tif(N==1) return 1;\n\tif(N==2) return 0;\n\t\n\tint x,y,k,l,i;\n\tll ret=0;\n\tfor(k=1;k<=N-2;k++) {\n\t\tl=N-1-k;\n\t\tif(k>K || l>K) continue;\n\t\tZERO(dp);\n\t\tdp[0][0]=1;\n\t\tFOR(y,k+1) FOR(x,l+1) {\n\t\t\tif(y==0&&x==l) dp[y][x]=0;\n\t\t\tif(x&&y+(l-x)>K) continue;\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\tif(x+k-y<=K) (dp[y][x+1]+=dp[y][x])%=mo;\n\t\t}\n\t\tret+=dp[k][l];\n\t}\n\tfor(i=1;i<=N-1;i++) ret=ret*i%mo;\n\tcout<<N<<K<<\" \"<<ret<<endl;\n\treturn ret;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tll ret=0;\n\tll fac=1;\n\twhile(2*K>=N-1) {\n\t\tret+=fac*hoge(N,K)%mo;\n\t\tfac=fac*N%mo;\n\t\tN--,K--;\n\t}\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll dp[202][202];\n\n\nll hoge(int N,int K) {\n\t\n\tif(N==1) return 1;\n\tif(N==2) return 0;\n\t\n\tint x,y,k,l,i;\n\tll ret=0;\n\tfor(k=1;k<=N-2;k++) {\n\t\tl=N-1-k;\n\t\tif(k>K || l>K) continue;\n\t\tZERO(dp);\n\t\tdp[0][0]=1;\n\t\tFOR(y,k+1) FOR(x,l+1) {\n\t\t\t//if(y==0&&x==l) dp[y][x]=0;\n\t\t\tif(y+(l-x)>K) continue;\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\tif(x+k-y<=K) (dp[y][x+1]+=dp[y][x])%=mo;\n\t\t}\n\t\tret+=dp[k][l];\n\t}\n\tfor(i=1;i<=N-1;i++) ret=ret*i%mo;\n\t//cout<<N<<K<<\" \"<<ret<<endl;\n\treturn ret;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tll ret=0;\n\tll fac=1;\n\twhile(2*K>=N-1) {\n\t\tret+=fac*hoge(N,K)%mo;\n\t\tfac=fac*N%mo;\n\t\tN--,K--;\n\t}\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "かわらくんはがんばりたい"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 210;\nint n,k,mod;\n\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\nint fac[N],ifac[N];\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint f[N][N];\ninline void upd(int &x,int y){\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\ninline int dp(int m,int n,int deg){\n\tFor(i,0,n) For(j,0,m) f[i][j]=0;\n\tf[1][0]=1;\n\tFor(i,1,n){\n\t\tFOR(j,0,m) if (i!=1||j!=0){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (j) upd(f[i][j],f[i][j-1]);\n\t\t\tif (j&&j-1+(n-i+1)>deg) f[i][j]=0;\n\t\t}\n\t\tFOR(j,0,m) if (m-j+i-1>deg) f[i][j]=0;\n\t}\n\tint ret=0;\n\tFOR(i,1,m) upd(ret,f[n][i]);\n\treturn ret;\n}\ninline int calc(int n,int deg){\n\tif (n==0) return 1;\n\tif (n==1) return 0;\n\tint ret=0;\n\tFor(i,1,min(deg+1,n)) ret=(ret+1ll*C(n-1,i-1)*fac[n-i]%mod*fac[i-1]%mod*dp(i,n-i,deg))%mod;\n\treturn ret;\n}\n\nint main(){\n\tn=read(),k=read(),mod=read();\n\tinit(n);\n\tint ans=0;\n\tFor(i,0,min(n,k+1)) ans=(ans+1ll*C(n,i)*fac[i]%mod*calc(n-i,k-i))%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef local\n#define _assert(expr) assert(expr)\n#else\n#define _assert(expr)\n#endif\n\nint Mod = 998244353;\n\ntypedef long long ll;\n\nvoid exgcd(int a, int b, int& x, int& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\nint inv(int a, int Mod = ::Mod) {\n  int x, y;\n  exgcd(a, Mod, x, y);\n  return (x < 0) ? (x + Mod) : x;\n}\n\nclass Z {\n  public:\n    int v;\n\n    Z() {\t}\n    Z(int v) : v(v) {\n      _assert(v >= 0 && v < Mod);\n    }\n    Z(ll x) : v(x % Mod) {\t}\n\n    friend Z operator + (Z a, Z b) {\n      int x;\n      return Z((x = a.v + b.v) >= Mod ? x - Mod : x); \n    }\n    friend Z operator - (Z a, Z b) {\n      int x;\n      return Z((x = a.v - b.v) < 0 ? x + Mod : x);\n    }\n    friend Z operator * (Z a, Z b) {\n      return 1ll * a.v * b.v;\n    }\n    friend Z operator ~ (Z a) {\n      _assert(a.v);\n      return inv(a.v);\n    }\n    friend Z operator - (Z a) {\n      return Z(0) - a;\n    }\n    Z& operator += (Z b) {\n      return *this = *this + b;\n    }\n    Z& operator -= (Z b) {\n      return *this = *this - b;\n    }\n    Z& operator *= (Z b) {\n      return *this = *this * b;\n    }\n};\n\ntypedef Z Zi;\n\nZi qpow(Zi a, int p) {\n  if (p < 0)\n    p += Mod - 1;\n  Zi rt = 1;\n  for ( ; p; p >>= 1, a *= a) {\n    if (p & 1) {\n      rt *= a;\n    }\n  }\n  return rt;\n}\nZi qpow(Zi a, ll p) {\n  return qpow(a, (int) (p % (Mod - 1)));\n}\n\nconst int N = 405;\n\nint n, K;\n\nvector<Zi> fac, _fac;\n\nvoid init_fac(int n) {\n  fac.resize(n + 1);\n  _fac.resize(n + 1);\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = fac[i - 1] * i;\n  }\n  _fac[n] = ~fac[n];\n  for (int i = n; i; i--) {\n    _fac[i - 1] = _fac[i] * i;\n  }\n}\nZi comb(int n, int m) {\n  return n < m ? 0 : fac[n] * _fac[m] * _fac[n - m];\n}\n\nZi f[205][205];\n\nZi calc(int n, int m, int bu, int bd) {\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      f[i][j] = 0;\n    }\n  }\n  for (int j = 0; j < m; j++) {\n    f[0][j] = (j <= bu && j >= bd);\n  }\n  for (int i = 1; i < n; i++) {\n    Zi sum = 0;\n    for (int j = 0; j < m && j <= bu + i; j++) {\n      sum += f[i - 1][j];\n      if (j >= bd + i) {\n        f[i][j] = sum;\n      }\n    }\n  }\n  Zi sum = 0;\n  for (int j = max(bd + n - 1, 0); j < m && j < bu + n; j++) {\n    sum += f[n - 1][j];\n  }\n  for (int i = 1; i < n; i++) {\n    if (i + bu >= m) {\n      sum += f[i][m - 1];\n    }\n  }\n  return sum;\n}\n\nint main() {\n  scanf(\"%d%d%d\", &n, &K, &Mod);\n  init_fac(405);\n  K = n - 1 - K;\n  Zi ans = !K;\n  for (int sl = max(K, 1); sl < n; sl++) {\n    for (int sr = max(K, 1); sl + sr < n; sr++) {\n      Zi tmp = calc(sr, sl, sl - K, K - sr); \n//      cerr << tmp.v << \" \";\n      tmp = tmp * ~Zi(sl + sr + 1);\n      ans += tmp;\n    }\n  }\n  ans *= fac[n];\n  printf(\"%d\\n\", ans.v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll dp[202][202];\n\n\nll hoge(int N,int K) {\n\t\n\tif(N==1) return 1;\n\tif(N==2) return 0;\n\t\n\tint x,y,k,l,i;\n\tll ret=0;\n\tfor(k=1;k<=N-2;k++) {\n\t\tl=N-1-k;\n\t\tif(k>K || l>K) continue;\n\t\tZERO(dp);\n\t\tdp[0][0]=1;\n\t\tFOR(y,k+1) FOR(x,l+1) {\n\t\t\tif(y==0&&x==l) dp[y][x]=0;\n\t\t\tif(y<k&&y+(l-x)>K) continue;\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\tif(x+k-y<=K) (dp[y][x+1]+=dp[y][x])%=mo;\n\t\t}\n\t\tret+=dp[k][l];\n\t}\n\tfor(i=1;i<=N-1;i++) ret=ret*i%mo;\n\t//cout<<N<<K<<\" \"<<ret<<endl;\n\treturn ret;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tll ret=0;\n\tll fac=1;\n\twhile(2*K>=N-1) {\n\t\tret+=fac*hoge(N,K)%mo;\n\t\tfac=fac*N%mo;\n\t\tN--,K--;\n\t}\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 205;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, k, P, fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nint solve(int n, int k) {\n\tif (n == 3) {\n\t\tif (k >= 1) return 2;\n\t\telse return 0;\n\t}\n\tint ans = 0;\n\tfor (int x = 2; x <= n - 2; x++) {\n\t\tint y = n - x;\n\t\tint coef = 1ll * binom(n, x) * fac[x] % P * fac[y] % P;\n\t\tstatic int dp[MAXN][MAXN];\n\t\tmemset(dp, 0, sizeof(dp)), dp[x][y] = 1;\n\t\tfor (int i = x; i >= 1; i--)\n\t\tfor (int j = y; j >= 0; j--) {\n\t\t\tint tmp = dp[i][j];\n\t\t\tif (i != 1 && j + (x - i) <= k) update(dp[i - 1][j], tmp);\n\t\t\tif (j != 0 && i + (y - j) <= k && !(j == 1 && i == x)) update(dp[i][j - 1], tmp);\n\t\t}\n\t\tupdate(ans, 1ll * coef * dp[1][0] % P);\n\t}\n\treturn 1ll * ans * inv[n - 1] % P * fac[n - 2] % P;\n}\nint main() {\n\tread(n), read(k), read(P);\n\tinit(n); int ans = (k == n - 1) ? fac[n] : 0;\n\tfor (int i = 3; i <= n; i++)\n\t\tupdate(ans, 1ll * fac[n] * inv[i] % P * solve(i, k - (n - i)) % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint N,K,P,fac[210],ifac[210];\nlong long inv(int a,int p=P){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\nint C(int n,int m){return m<0||m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint calc(int a,int b,int k){\n\tif(a>k+1||b>k)return 0;\n\tint x=a>k,s=0;\n\tfor(int i=k+1,j=b;j<=a+b-x;i+=k*2+3-a-b,j+=k*2+3-a-b)s=((s+P-C(a+b-x,i))%P+C(a+b-x,j))%P;\n\tfor(int i=a+b-k-2,j=a+b*2-k*2-3;i>=0;i-=k*2+3-a-b,j-=k*2+3-a-b)s=((s+P-C(a+b-x,i))%P+C(a+b-x,j))%P;\n\tif(a+b-1<=k)s=(s+P-1)%P;\n\tif(a+b<=k)s=(s+P-1)%P;\n\treturn s;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&K,&P);\n\tfor(int i=*fac=1;i<=N;i++)fac[i]=1ll*fac[i-1]*i%P;\n\tifac[N]=inv(fac[N]);\n\tfor(int i=N;i;i--)ifac[i-1]=1ll*ifac[i]*i%P;\n\tint s=K>=N-1?fac[N]:0;\n\tfor(int i=0;i<=N-3&&K-i>=(N-i)/2;i++){\n\t\tint t=K<N-2?0:N-i-2;\n\t\tfor(int j=1;j<=K-i&&j<N-i-1;j++)t=(t+calc(j,N-i-j-1,K-i))%P;\n\t\ts=(s+1ll*fac[N]*ifac[N-i]%P*fac[N-i-1]%P*t)%P;\n\t}\n\tprintf(\"%d\\n\",s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=210;\n\nint n,k,mod,ans,L[N],R[N],fac[N],f[N][N],sum[N][N];\n\nint add(int a,int b) {\n\treturn a+b>=mod?a+b-mod:a+b;\n}\n\nint solve(int n,int k) {\n\tif(n==1) return 1;\n\tint ways=0;\n\tfor(int a=1;a<=n-1;a++) {\n\t\tint b=n-a;\n\t\tfor(int i=1;i<=a;i++) L[i]=0,R[i]=b;\n\t\tL[1]=1;R[a]=0;\n\t\tfor(int i=1;i<=a;i++) R[i]=min(R[i],k-i+1);\n\t\tbool fl=1;\n\t\tfor(int i=1;i<=b;i++) {\n\t\t\tif(k-i+1>=a) continue;\n\t\t\tif(k-i+1<0) { fl=0;break; }\n\t\t\tL[a-k+i-1]=max(L[a-k+i-1],b-i+1);\n\t\t}\n\t\tfor(int i=1;i<=a;i++)\n\t\t\tif(L[i]>R[i]) { fl=0;break; }\n\t\tif(!fl) continue;\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(sum,0,sizeof(sum));\n\t\tf[0][b]=1;\n\t\tfor(int i=b;~i;i--) sum[0][i]=1;\n\t\tfor(int i=1;i<=a;i++) {\n\t\t\tfor(int j=L[i];j<=R[i];j++) f[i][j]=sum[i-1][j];\n\t\t\tfor(int j=b;~j;j--) sum[i][j]=add(sum[i][j+1],f[i][j]);\n\t\t}\n\t\tways=add(ways,f[a][0]);\n\t}\n\treturn 1ll*ways*fac[n-1]%mod;\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>k>>mod;\n\tfac[0]=1;for(int i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tint ans=0,ways=1;\n\tfor(int i=0;i<=n&&i<=k;i++) {\n\t\tans=(ans+1ll*solve(n-i,k-i)*ways)%mod;\n\t\tways=1ll*ways*(n-i)%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:03:25       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nMint Solve(int n, int k) {\n  if (n == 1 && k == 0) {\n    return 1;\n  }\n  if (n < 3) {\n    return 0;\n  }\n  Mint ret = 0;\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(n + 1, 0));\n  for (int me = 1; me <= n - 2 && me <= k; me++) {\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][me] = 1;\n    for (int i = 0; i < me; i++) {\n      for (int j = me; j < n; j++) {\n        Mint ft = dp[i][j];\n        if (ft == 0) {\n          continue;\n        }\n        int upper = min(n, k + i + 2);\n        if ((n + i) - (j + 1) <= k) {\n          for (int t = j; t < upper; t++) {\n            dp[i + 1][t] += ft;\n          }\n        } else {\n          dp[i + 1][j] += ft;\n        }\n      }\n    }\n    for (int j = me + 1; j < n; j++) {\n      bool ok = true;\n      for (int x = j + 1; x < n; x++) {\n        int last = n + me;\n        int deg = last - x;\n        if (deg > k) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        ret += dp[me][j];\n      }\n    }\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    ret *= i;\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k >> md;\n  Mint ans = 0;\n  Mint coeff = 1;\n  while (2 * k >= n - 1) {\n    ans += Solve(n, k) * coeff;\n    coeff *= n;\n    --n;\n    --k;\n  }\n  cout << ans << '\\n';\n  debug(clock());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//orz myh\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=205;\nint n,k,mod;\nint fac[N],inv[N],f[N][N];\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=1ll*res*b%mod;\n\t\tb=1ll*b*b%mod; n>>=1;\n\t}\n\treturn res;\n} \nint calc(int k,int l,int in){\n\tfor(int i=1;i<=k;++i){\n\t\tint sum=0;\n\t\tfor(int j=l;j>=0;--j){\n\t\t\tsum=(sum+f[i-1][j])%mod;\n\t\t\tif(i-1+j<=in && k-i+l-j<=in){\n\t\t\t\tf[i][j]=sum;\n\t\t\t\tif(j==1 || j==0) f[i][j]=1;\n\t\t\t}\n\t\t\telse f[i][j]=0;\n\t\t}\n\t\tif(i==1) f[i][0]=0;\n\t}\n\treturn f[k][0];\n}\nint solve(int n,int m){\n\tif(n==1) return 1;\n\tint ans=0;\n\tfor(int i=2;i<n;++i)\n\t\tans=(ans+calc(i,n-i,m)%mod);\n\treturn 1ll*ans*fac[n-1]%mod;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;--i)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nsigned main(){\n\tcin>>n>>k>>mod;\n\tinit(n);int ans=0;\n\tfor(int i=0;i<=k;++i) //枚举多少个点度数为0\n\t{\n\t\tans=ans+solve(n-i,k-i)*fac[n]%mod*inv[n-i]%mod;\n\t\tans%=mod;\t\n\t} \n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 210;\n\nint N, K;\nll P;\n\nll dp[MAXN][MAXN];\nll choose[MAXN][MAXN];\n\nll res[MAXN];\n\nll rr[MAXN][MAXN];\n\nll gogo (int A, int B)\n{\n    int blo = (A - 1 - B);\n    ll ans = 0;\n    for (int k = blo; k <= B; k++)\n    {\n        for (int i = 0; i <= A + 1; i++)\n            for (int j = 0; j <= A + 1; j++)\n                rr[i][j] = 0;\n\n        rr[0][k] = 1;\n        for (int l = 1; l <= k; l++)\n        {\n            ll cc = rr[l-1][blo];\n            for (int m = blo; m <= min (B, N - l - 1); m++)\n            {\n                cc += rr[l-1][m+1];\n                cc %= P;\n                rr[l][m] = cc;\n            }\n        }\n        for (int l = blo; l <= B; l++)\n            ans += rr[k][l];\n    }\n    //cout << A << \" \" << B << \" \" << ans << \"\\n\";\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> K >> P;\n\n    dp[1][0] = 1;\n    for (int i = 1; i < MAXN; i++)\n        dp[1][i] = 1;\n\n    for (int i = 3; i <= N; i++)\n    {\n        for (int j = i / 2; j < i - 1; j++)\n        {\n            dp[i][j] = gogo (i, j) % P;\n            for (int k = 1; k < i; k++)\n                dp[i][j] = (dp[i][j] * k) % P;\n        }\n        for (int j = 1; j < MAXN; j++)\n            dp[i][j] = (dp[i][j] + dp[i][j-1]) % P;\n    }\n\n    choose[0][0] = 1;\n    for (int i = 1; i < MAXN; i++)\n        for (int j = 0; j <= i; j++)\n        {\n            choose[i][j] = choose[i-1][j];\n            if (j)\n                choose[i][j] = (choose[i][j] + choose[i-1][j-1]) % P;\n        }\n\n    res[0] = 1;\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 1; j <= N - i; j++)\n        {\n            if (K < i) continue;\n            if (j > 1 && j < N - i) continue;\n            ll v = (res[i] * choose[N-i][j]) % P;\n            v = (v * dp[j][K-i]) % P;\n            res[i+j] = (res[i+j] + v) % P;\n        }\n    }\n    cout << res[N] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 201;\ni64 P;\ni64 fact[maxn], tcaf[maxn];\n\ni64 deg(i64 x, i64 d) {\n    if (d < 0) d += P - 1;\n    i64 y = 1;\n    while (d) {\n        if (d & 1) (y *= x) %= P;\n        d /= 2;\n        (x *= x) %= P;\n    }\n    return y;\n}\n\ni64 cnk(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * tcaf[k] % P * tcaf[n - k] % P;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, k;\n    cin >> n >> k >> P;\n\n    fact[0] = 1;\n    for1(i, n) fact[i] = i * fact[i - 1] % P;\n    forn(i, n + 1) tcaf[i] = deg(fact[i], -1);\n\n    i64 ans = 0;\n    for1(sz, n) {\n        i64 V;\n        int D = k - (n - sz);\n        if (D < 0) continue;\n        i64 cnt = cnk(n, sz) * fact[sz - 1] % P * fact[n - sz] % P;\n        if (sz == 1) V = 1;\n        else if (sz == 2) V = 0;\n        else {\n            i64 t = 0;\n            for1(d0, D) {\n                if (d0 >= sz - 1) continue;\n                vi64 dp(sz + 1);\n                dp[d0 + 1] = 1;\n                for1(i, d0 + 1) {\n                    forn(j, sz) {\n                        if (!dp[j]) continue;\n                        int deg1 = j + 1 - i, deg2 = sz + i - j - 2;\n                        if (deg1 < 1 || deg1 > D) continue;\n                        if (deg2 < 1 || deg2 > D) continue;\n                        (dp[j + 1] += dp[j]) %= P;\n                    }\n                    int deg1 = sz - i - 1;\n                    if (deg1 >= 1 && deg1 <= D) (t += dp[sz]) %= P;\n                    forn(j, sz + 1) {\n                        int deg1 = j - i;\n                        int deg2 = sz + i - j - 1;\n                        if (deg1 < 1 || deg1 > D || deg2 < 1 || deg2 > D || j == sz) dp[j] = 0; \n                    }\n                }\n            }\n            V = t;\n        }\n//        cerr << sz << ' ' << D << ' ' << cnt << ' ' << V << '\\n';\n        (ans += V * cnt) %= P;\n    }\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=205; int P;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n, lim, f[N][N], C[N][N], fac[N], ans; \n\nint calc(int k, int l, int lim) {\n\tint ans=0;\n   \tmem(f, 0); \n\tf[0][1] = 1;\n\trep(j, 1, l) {\n\t\trep(i, 0, k-1) {\n\t\t\tf[i][j] = add(f[i][j], add(i?f[i-1][j]:0, f[i][j-1])); \n\t\t\tif (l-j+1+i-1 > lim) f[i][j] = 0; \n\t\t}\n\t\trep(i, 0, k-1) {\n\t\t\tif (k-i+j-1 > lim) f[i][j] = 0; \n\t\t}\n\t}\n\trep(i, 1, k-1) ans = add(ans, f[i][l]); \n\treturn ans; \n}\n\nint solve(int lim, int n) {\n\tif (n == 1) return 0; \n\tif (n == 0) return 1; \n\tif (lim < 0) return 0; \n\tint r = 0; \n\trep(k, 1, min(n,lim+1)) {\n\t\tint t = mul(C[n-1][k-1], mul(fac[n-k], fac[k-1]));\n\t\tr = add(r, mul(t, calc(k, n-k, lim))); \n\t}\n\treturn r;\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\", \"r\", stdin); \n#endif\n\tcin >> n >> lim >> P; \n\tC[0][0] = 1; \n\trep(i, 1, n) {\n\t\tC[i][0] = 1; \n\t\trep(j, 1, i) C[i][j] = add(C[i-1][j], C[i-1][j-1]); \n\t}\n\tfac[0] = 1; \n\trep(i, 1, n) fac[i] = mul(fac[i-1], i); \n\trep(i, 0, lim+1) {\n\t\tans = add(ans, mul(mul(fac[i], C[n][i]), solve(lim - i, n - i))); \n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\nint P;\n\nint mpow(int n,int m){\n\tint ret=1;\n\twhile(m){\n\t\tif(m&1)ret=ret*n%P;\n\t\tn=n*n%P;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\n\ninline void add(int &a,int b){\n\ta+=b;\n\tif(a>=P)a-=P;\n}\n\nconst int SIZE=200;\nint fact[222];\nint finv[222];\n\n/*\nx y t\n\n\nt : mode  (0 or 1)\n0 : y->y+1\n1 : x->x+1\n*/\nint dp[222][222][2];\n\nint solve(int N,int K){\n\tint ret=0;\n\tfor(int X=1;X<=K+1&&N-X>=1;X++){\n\t\tint Y=N-X;\n\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int a=1;a<X;a++){\n\t\t\tif(a+Y<=K+1&&X-a+1<=K+1)dp[a][1][0]=a;\n\t\t}\n\n\t\tfor(int x=1;x<=X;x++){\n\t\t\tfor(int y=1;y<=Y;y++){\n\t\t\t\tif(y+1+(X-x)<=K+1&&y+1<=Y){\n\t\t\t\t\tadd(dp[x][y+1][0],dp[x][y][0]);\n\t\t\t\t\tadd(dp[x][y+1][0],dp[x][y][1]);\n\t\t\t\t}\n\t\t\t\tif(x+1+(Y-y)<=K+1){\n\t\t\t\t\tadd(dp[x+1][y][1],dp[x][y][1]);\n\t\t\t\t\tadd(dp[x+1][y][1],dp[x][y][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tmp=dp[X][Y][1];\n\t\tadd(ret,tmp);\n\t}\n\tret=ret*fact[N-1]%P;\n\treturn ret;\n}\n\nsigned main(){\n\tint N,K;\n\tcin>>N>>K>>P;\n\n\tfact[0]=1;\n\tfor(int i=1;i<=SIZE;i++)fact[i]=fact[i-1]*i%P;\n\tfinv[SIZE]=mpow(fact[SIZE],P-2);\n\tfor(int i=SIZE-1;i>=0;i--)finv[i]=finv[i+1]*(i+1)%P;\n\t\n\tint ans=0;\n\tfor(int i=0;i<=N;i++){\n\t\tint n=N-i;\n\t\tint k=K-i;\n\t\tif(n<3)continue;\n\t\tif((n-1)/2>k)continue;\n\t\tint tmp=solve(n,k);\n\t\ttmp=tmp*fact[N]%P*finv[n]%P;\n\t\tadd(ans,tmp);\n\t}\n\tif(K==N-1)add(ans,fact[N]);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\nint mod;\n\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)c -= mod;\n\treturn c;\n}\n\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)c += mod;\n\treturn c;\n}\n\nint mlt(int a, int b)\n{\n\tlong long c = a * 1LL * b;\n\treturn c % mod;\n}\n\nint bp(int a, int b)\n{\n\tif (b == 0)return 1;\n\tif (b % 2 == 0)\n\t{\n\t\tint val = bp(a, b / 2);\n\t\treturn mlt(val, val);\n\t}\n\tif (b % 2 == 1)\n\t{\n\t\tint val = bp(a, b - 1);\n\t\treturn mlt(val, a);\n\t}\n}\n\nint inv(int a)\n{\n\treturn bp(a, mod - 2);\n}\n\nint ibit(int mask, int i)\n{\n\treturn (mask >> i) % 2;\n}\n\nvoid outp(vector<vector<int>> &v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tfor (int j = 0; j < v[i].size(); j++)cout << v[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nvector<int>fact, ofact;\nint c(int a, int b)\n{\n\tif(b<a) return 0;\n\tif(a<0)return 0;\n\tint val=fact[b];\n\tval=mlt(val, ofact[a]);\n\tval=mlt(val, ofact[b-a]);\n\treturn val;\n}\nint pth(int st, int fn, int len)\n{\n\treturn c((len+fn-st)/2, len);\n}\nint hg(int st, int fn, int len)\n{\n   if(st<0)return 0;\n   if(fn<0)return 0;\n   if((st+fn)%2!=len%2)return 0;\n   return dif(pth(st, fn, len), pth(st, -fn-2, len));\n}\nint f(int st, int fn, int b1, int b2, int len)\n{\n\t//cout<<st<<' '<<fn<<' '<<b1<<' '<<b2<<' '<<len<<endl;\n\tif(b1!=0)\n\t{\n\t\treturn f(st-b1, fn-b1, 0, b2-b1, len);\n\t}\n\tif(st<0)return 0;\n\tif(st>b2)return 0;\n\tif(fn<0)return 0;\n\tif(fn>b2)return 0;\n\tif(b2>2*len)\n\t{\n\t\tint bv=0;\n\t\tif (st > b2 / 2)\n\t\t\t  bv=f(b2 - st, b2 - fn, b1, b2, len);\n\t\t else bv=hg(st, fn, len);\n\t//\tcout<<st<<' '<<fn<<' '<<b1<<' '<<b2<<' '<<len<<' '<<bv<<endl;\n\t\treturn bv;\n\t}\n\tint pq=dif(f(st, fn, -b2-2, b2, len),\n\t           f(st, -fn-2, -b2-2, b2, len));\n//\tcout<<st<<' '<<fn<<' '<<b1<<' '<<b2<<' '<<len<<' '<<pq<<endl;\n\treturn pq;\n\n\n}\nint solve(int n, int k)\n{\n\tif(k<0)return 0;\n\tif(n==1)return 1;\n\tif(n==2)return 0;\n\tint ans=fact[n-1], cr=0;\n\tfor(int mn=0; mn<n-1; mn++)\n\t{\n\t\tint pl=n-1-mn;\n\t\tcr=add(cr, f(pl, mn, max(n-1-k,1), k+1,  n-1));\n\t}\n\t//cout<<n<<' '<<k<<' '<<cr<<endl;\n\treturn mlt(ans,cr);\n}\nint main()\n{\n\tint n, k;\n\tcin>>n>>k>>mod;\n\tfact.resize(300);\n\tofact.resize(300);\n\tfact[0]=1;\n\tofact[0]=1;\n\tfor(int i=1; i<300; i++)\n\t{\n\t\tfact[i]=mlt(fact[i-1], i);\n\t\tofact[i]=inv(fact[i]);\n\t}\n\tint ans=0;\n\tfor(int low=1; low<=n; low++)\n\t{\n\t\tint val=solve(low, k-n+low);\n\t\tval=mlt(val, c(low,n));\n\t\tval=mlt(val, fact[n-low]);\n\t\tans=add(ans, val);\n\t}\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\n//const ll mod=1000000007;\nll mod;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=210;\nint dp[N][N];\nint n,k;\nvoid upd(int &a,int b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\nint solve(int x,int y) {\n\tif (y<0) return 0;\n\tif (y==0) return x<=1;\n\tint ans=0;\n\tfor (int a=2;a<=y+1;a++) {\n\t\tint b=x-a;\n\t\tif (b<1||b>y+1) continue;\n\t\tfor (int i=0;i<a;i++) for (int j=0;j<=b;j++) {\n\t\t\tif (i==0&&j==0) { dp[i][j]=1; continue; }\n\t\t\tdp[i][j]=0;\n\t\t\tif (i==0&&j==b) continue;\n\t\t\tif (b-y-1>j-i||j-i>y+1-a) continue;\n\t\t\tif (i>0) upd(dp[i][j],dp[i-1][j]);\n\t\t\tif (j>0) upd(dp[i][j],dp[i][j-1]);\n\t\t}\n\t\tupd(ans,dp[a-1][b]);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d%lld\",&n,&k,&mod);\n\tint ans=0;\n\tfor (int deg=0;deg<=n-2;deg++) {\n\t\tans=(ans+(ll)solve(n-deg,k-deg)*powmod(n-deg,mod-2))%mod;\n\t}\n\tif (k>=n-1) {\n\t\tans=(ans+1)%mod;\n\t}\n\trep(i,1,n+1) ans=(ll)ans*i%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int N=207;\n\nint n, m, k, u, v, x, y, t, a, b, ans, mod;\nint F[N];\nint dp[2][N][N][N];\nint val[N][N][N];\n\ninline void fix(int &x){\n\tif (x>=mod) x-=mod;\n//\tif (x<0) x+=mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tfor (int j=0; j<N; j++) for (int k1=max(j-1, 0); k1<N; k1++) for (int k2=0; k2<N; k2++) dp[0][j][k1][k2]=1;\n\tcin>>n>>k>>mod;\n\t\n\tfor (int i=1; i<N; i++){\n\t\tint cur=(i&1);\n\t\tfor (int j=0; i+j<N; j++) for (int k1=0; k1<i+j; k1++) for (int k2=0; k2<i+j; k2++) dp[cur][j][k1][k2]=0;\n\t\tfor (int k1=0; k1<i; k1++) dp[cur][0][k1][i-1]=1;\n\t\tfor (int j=1; i+j<N; j++){\n\t\t\tfor (int k1=j-1; k1<i+j; k1++) for (int k2=i-1; k2<i+j; k2++){\n\t\t\t\tif (k2) dp[cur][j][k1][k2]+=dp[cur][j-1][min(k1, i+j-2)][k2-1];\n\t\t\t\tif (k1) dp[cur][j][k1][k2]+=dp[cur^1][j][k1-1][min(k2, i+j-2)];\n\t\t\t\tfix(dp[cur][j][k1][k2]);\n\t\t\t}\n\t\t}\n\t\tfor (int j=1; i+j<N; j++) for (int k=max(1, j-1); k<i+j; k++) for (int x=1; x<=min(j-1, k-i+1); x++){\n\t\t\tfix(val[j][i][k]+=dp[cur^1][j-x][min(k-1, i+j-x-2)][min(k-x, i+j-x-2)]);\n\t\t}\n\t}\n\tF[0]=1;\n\tfor (int i=1; i<N; i++) F[i]=F[i-1]*i%mod;\n\t\n\tif (k==n-1){\n\t\tans=1;\n\t\tfor (int i=1; i<=n; i++) ans=1ll*ans*i%mod;\n\t}\n\t\n\tfor (int t=0; t<=min(k, n-3); t++){\n\t\tfor (int X=1; X<n-t; X++){\n\t\t\tint Y=n-X-t-1;\n\t\t\tll tmp=1;\n\t\t\tfor (int i=1; i<=n; i++) if (i!=n-t) tmp=tmp*i%mod;\n\t\t\ttmp=tmp*val[X+1][Y][min(k-t, X+Y)]%mod;\n\t\t\tans=(ans+tmp)%mod;\n\t\t}\n\t}\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 210;\n\nint N, K;\nll P;\n\nll dp[MAXN][MAXN];\nll choose[MAXN][MAXN];\n\nll res[MAXN];\n\nll rr[MAXN][MAXN];\n\nll gogo (int A, int B)\n{\n    if (B < A / 2) return 0;\n    if (A == 1) return 1;\n    if (B > A - 2) B = A - 2;\n\n    int blo = (A - 1 - B);\n    ll ans = 0;\n    for (int k = blo; k <= B; k++)\n    {\n        for (int i = 0; i <= A + 1; i++)\n            for (int j = 0; j <= A + 1; j++)\n                rr[i][j] = 0;\n\n        rr[0][k] = 1;\n        for (int l = 1; l <= k; l++)\n        {\n            ll cc = rr[l-1][blo];\n            for (int m = blo; m <= min (B, A - l - 1); m++)\n            {\n                cc += rr[l-1][m+1];\n                cc %= P;\n                rr[l][m] = cc;\n            }\n        }\n        for (int l = blo; l <= B; l++)\n        {\n            ans += rr[k][l];\n            ans %= P;\n        }\n    }\n    //cout << A << \" \" << B << \" \" << ans << \"\\n\";\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> K >> P;\n\n    choose[0][0] = 1;\n    for (int i = 1; i < MAXN; i++)\n        for (int j = 0; j <= i; j++)\n        {\n            choose[i][j] = choose[i-1][j];\n            if (j)\n                choose[i][j] = (choose[i][j] + choose[i-1][j-1]) % P;\n        }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; i++)\n    {\n        // bottom cycle size\n        ll v = gogo (i, K - (N - i));\n        for (int j = 1; j <= N; j++)\n            if (j != i)\n                v = (v * j) % P;\n        ans += v;\n    }\n    cout << ans % P << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:03:25       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nMint Solve(int n, int k) {\n  if (n == 1 && k == 0) {\n    return 1;\n  }\n  if (n < 3) {\n    return 0;\n  }\n  Mint ret = 0;\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(n + 1, 0));\n  for (int me = 1; me <= n - 2 && me <= k; me++) {\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][me] = 1;\n    for (int i = 0; i < me; i++) {\n      for (int j = me; j < n; j++) {\n        Mint ft = dp[i][j];\n        if (ft == 0) {\n          continue;\n        }\n        int upper = min(n, k + i + 2);\n        if ((n + i) - (j + 1) <= k) {\n          for (int t = j; t < upper; t++) {\n            dp[i + 1][t] += ft;\n          }\n        } else {\n          dp[i + 1][j] += ft;\n        }\n      }\n    }\n    for (int j = me + 1; j < n; j++) {\n      bool ok = true;\n      for (int x = j + 1; x < n; x++) {\n        int last = n + me;\n        int deg = last - x;\n        if (deg > k) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        ret += dp[me][j];\n      }\n    }\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    ret *= i;\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k >> md;\n  Mint ans = 0;\n  Mint coeff = 1;\n  while (2 * k >= n - 1) {\n    ans += Solve(n, k) * coeff;\n    coeff *= n;\n    --n;\n    --k;\n  }\n  cout << ans << '\\n';\n  debug(clock());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll dp[202][202];\n\n\nll hoge(int N,int K) {\n\t\n\tif(N==1) return 1;\n\tif(N==2) return 0;\n\t\n\tint x,y,k,l,i;\n\tll ret=0;\n\tfor(k=1;k<=N-2;k++) {\n\t\tl=N-1-k;\n\t\tif(k>K || l>K) continue;\n\t\tZERO(dp);\n\t\tdp[0][0]=1;\n\t\tFOR(y,k+1) FOR(x,l+1) {\n\t\t\tif(y==0&&x==l) dp[y][x]=0;\n\t\t\tif(y+(l-x)>K) continue;\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\tif(x+k-y<=K) (dp[y][x+1]+=dp[y][x])%=mo;\n\t\t}\n\t\tret+=dp[k][l];\n\t}\n\tfor(i=1;i<=N-1;i++) ret=ret*i%mo;\n\treturn ret;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tll ret=0;\n\tll fac=1;\n\twhile(2*K>=N-1) {\n\t\tret+=fac*hoge(N,K)%mo;\n\t\tfac=fac*N%mo;\n\t\tN--,K--;\n\t}\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 233\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nconst int n=read(),k=read(),mod=read();\nint fac[N],inv[N],ans;\n#define ck(x) (x>=mod?x-mod:x)\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tinv[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i){\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%mod;\n\t}\n}\nint calc(int X,int Y,int k){\n\tstatic int dp[N][N];\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int j=1;j<=Y;++j){\n\t\tint s=0;\n\t\tfor(int i=0;i<X;++i){\n\t\t\ts=ck(s+dp[i][j-1]);\n\t\t\tif((Y-j+1)+(i-1)<=k&&(X-i)+(j-1)<=k){\n\t\t\t\tdp[i][j]=s;\n\t\t\t}\n\t\t}\n\t}\n\tint tot=0;\n\tfor(int i=1;i<X;++i){\n\t\ttot=ck(tot+dp[i][Y]);\n\t}\n\treturn tot;\n}\nint Solve(int n,int k){\n\tif(n==1)return 1;\n\tint tot=0;\n\tfor(int i=1;i<=k+1;++i){\n\t\ttot=(tot+calc(i,n-i,k))%mod;\n\t}\n\ttot=1LL*tot*fac[n-1]%mod;\n\treturn tot;\n}\nint main(){\n\tinit(n);\n\tfor(int i=0;i<=k;++i){\n\t\tans=(ans+1LL*fac[n]*inv[n-i]%mod*Solve(n-i,k-i))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=205;\nint n,k,p;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%p;\n\t\ta=a*a%p,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nvoid init(int n=200)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%p;\n\tinv[n]=ksm(fac[n],p-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%p;\n\treturn;\n}\nlong long P(int n,int m)\n{\n\tif(m>n) return 0;\n\treturn fac[n]*inv[n-m]%p;\n}\nlong long f[N][N];\nint calc(int n,int m,int k)\n{\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=m;j>=0;j--)\n\t\t{\n\t\t\tf[i][j]=0;\n\t\t\tif(i-1+j<=k&&n-i+m-j<=k)\n\t\t\t{\n\t\t\t\tif(i==1&&j>0) f[i][j]=1;\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tfor(int q=m;q>=j;q--)\n\t\t\t\t\t\tf[i][j]=(f[i][j]+f[i-1][q])%p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn f[n][0];\n}\nlong long solve(int n,int k)\n{\n\tif(n==1) return 1;\n\tlong long res=0;\n\tfor(int deg=2;deg<n;deg++)\n\t\tres=(res+calc(deg,n-deg,k))%p;\n\treturn res*fac[n-1]%p;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&p);\n\tinit();\n\tlong long ans=0;\n\tfor(int i=0;i<=k;i++)\n\t\tans=(ans+P(n,i)*solve(n-i,k-i)%p)%p;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:03:25       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nMint Solve(int n, int k) {\n  if (n == 1 && k == 0) {\n    return 1;\n  }\n  if (n < 3) {\n    return 0;\n  }\n  Mint ret = 0;\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(n + 1, 0));\n  for (int me = 1; me <= n - 2 && me <= k; me++) {\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][me] = 1;\n    for (int i = 0; i < me; i++) {\n      for (int j = me; j < n; j++) {\n        Mint ft = dp[i][j];\n        if (ft == 0) {\n          continue;\n        }\n        int upper = min(n, k + i + 2);\n        if ((n + i) - (j + 1) <= k) {\n          for (int t = j; t < upper; t++) {\n            dp[i + 1][t] += ft;\n          }\n        } else {\n          dp[i + 1][j] += ft;\n        }\n      }\n    }\n    for (int j = me + 1; j < n; j++) {\n      bool ok = true;\n      for (int x = j + 1; x < n; x++) {\n        int last = n + me;\n        int deg = last - x;\n        if (deg > k) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        ret += dp[me][j];\n      }\n    }\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    ret *= i;\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k >> md;\n  Mint ans = 0;\n  Mint coeff = 1;\n  while (2 * k >= n - 1) {\n    ans += Solve(n, k) * coeff;\n    coeff *= n;\n    --n;\n    --k;\n  }\n  cout << ans << '\\n';\n  debug(clock());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntemplate <int& MOD_> struct modnum {\n\tstatic constexpr int& MOD = MOD_;\n\t//static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint N, K; cin >> N >> K;\n\tstatic int MOD_; cin >> MOD_; // static to give it linkae\n\tusing num = modnum<MOD_>;\n\n\tauto solve_connected = [&](int N, int K) -> num {\n\t\tK = min(K, N-2);\n\t\tif (N-1 > 2 * K) return 0;\n\t\tnum ans = 0;\n\t\tvector<num> dp(K+2);\n\t\tfor (int st = N-1-K; st <= K; st++) {\n\t\t\tfill(dp.begin(), dp.end(), 0);\n\t\t\tdp[st]++;\n\t\t\tfor (int i = 1; i <= N-st; i++) {\n\t\t\t\t// shift right\n\t\t\t\tdp[K+2-i] = 0;\n\t\t\t\t// shift down\n\t\t\t\tfor (int j = K+1-i; j > 0 && i+j-1 >= N-1-K; j--) {\n\t\t\t\t\tdp[j-1] += dp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += dp[0];\n\t\t}\n\t\treturn ans;\n\t};\n\tnum ans = 0;\n\tif (K >= N-1) ans++;\n\tfor (int c = 0; c <= N-3; c++) {\n\t\tans += solve_connected(N-c, K-c) / num(N-c);\n\t}\n\tfor (int i = 1; i <= N; i++) ans *= i;\n\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll dp[202][202];\n\n\nll hoge(int N,int K) {\n\t\n\tif(N==1) return 1;\n\tif(N==2) return 0;\n\t\n\tint x,y,k,l,i;\n\tll ret=0;\n\tfor(k=1;k<=N-2;k++) {\n\t\tl=N-1-k;\n\t\tif(k>K || l>K) continue;\n\t\tZERO(dp);\n\t\tdp[0][0]=1;\n\t\tFOR(y,k+1) FOR(x,l+1) {\n\t\t\tif(y==0&&x==l) dp[y][x]=0;\n\t\t\tif(x&&y+(l-x)>K) continue;\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\tif(x+k-y<=K) (dp[y][x+1]+=dp[y][x])%=mo;\n\t\t}\n\t\tret+=dp[k][l];\n\t}\n\tfor(i=1;i<=N-1;i++) ret=ret*i%mo;\n\t//cout<<N<<K<<\" \"<<ret<<endl;\n\treturn ret;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tll ret=0;\n\tll fac=1;\n\twhile(2*K>=N-1) {\n\t\tret+=fac*hoge(N,K)%mo;\n\t\tfac=fac*N%mo;\n\t\tN--,K--;\n\t}\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=205;\nint n,k,p;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%p;\n\t\ta=a*a%p,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nvoid init(int n=200)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%p;\n\tinv[n]=ksm(fac[n],p-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%p;\n\treturn;\n}\nlong long P(int n,int m)\n{\n\tif(m>n) return 0;\n\treturn fac[n]*inv[n-m]%p;\n}\nlong long f[N][N];\nlong long sum[N][N];\nint calc(int n,int m,int k)\n{\n\tf[0][m]=1;\n\tfor(int i=1;i<=m-1;i++)\n\t\tf[0][i]=0;\n\tf[0][0]=-1;\n\tfor(int j=0;j<=m;j++)\n\t{\n\t\tsum[0][j]=j>0?sum[0][j-1]:0;\n\t\tsum[0][j]=(sum[0][j]+f[0][j]+p)%p;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=m;j++)\n\t\t{\n\t\t\tf[i][j]=0;\n\t\t\tif(i-1+j<=k&&n-i+m-j<=k)\n\t\t\t{\n\t\t\t\tf[i][j]=(f[i][j]+(sum[i-1][m]-(j>0?sum[i-1][j-1]:0)+p)%p)%p;\n\t\t\t}\n\t\t\tsum[i][j]=j>0?sum[i][j-1]:0;\n\t\t\tsum[i][j]=(sum[i][j]+f[i][j])%p;\n\t\t}\n\treturn f[n][0];\n}\nlong long solve(int n,int k)\n{\n\tif(n==1) return 1;\n\tlong long res=0;\n\tfor(int deg=2;deg<n;deg++)\n\t\tres=(res+calc(deg,n-deg,k))%p;\n\treturn res*fac[n-1]%p;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&p);\n\tinit();\n\tlong long ans=0;\n\tfor(int i=0;i<=k;i++)\n\t\tans=(ans+P(n,i)*solve(n-i,k-i)%p)%p;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 210;\n\nint fac[maxn], ifac[maxn], dp[maxn][maxn], sum[maxn][maxn];\nint n, K, mod, ans;\n\nint qpow(int x, int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1LL * ret * x % mod;\n\t\tx = 1LL * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\treturn 1LL * fac[x] * ifac[x-y] % mod * ifac[y] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &K, &mod);\n\tfac[0] = 1; for (int i = 1; i <= n; i++) fac[i] = 1LL * fac[i-1] * i % mod;\n\tfor (int i = 0; i <= n; i++) ifac[i] = qpow(fac[i], mod-2);\n\tfor (int T = 0; T <= K; T++) {\n\t\t// max in-deg <= K-T\n\t\t// |V| = n - T\n\t\tint res = 0, c = n - T;\n\t\tif (c == 1) {\n\t\t\tres = 1;\n\t\t} else {\n\t\t\tif (K - T <= 0) continue;\n\t\t\t// min out-deg >= (c-1)-(K-T)\n\t\t\tint m = max(1, c - 1 - (K - T));\n\t\t\tfor (int s = m; s <= c - 2; s++) {\n\t\t\t\tfor (int i = 1; i <= c - 1; i++) dp[1][i] = 0;\n\t\t\t\tdp[1][s] = 1;\n\t\t\t\tfor (int i = 1; i <= c - 1; i++) sum[1][i] = (sum[1][i-1] + dp[1][i]) % mod;\n\t\t\t\tfor (int i = 2; i <= s + 1; i++) {\n\t\t\t\t\tfor (int j = 0; j <= c - 1; j++) dp[i][j] = 0;\n\t\t\t\t\tfor (int j = m; j <= (c - 1 - m); j++) {\n\t\t\t\t\t\tdp[i][j] = sum[i-1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 1; j <= c - 1; j++) sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod;\n\t\t\t\t}\n\t\t\t\tint add = sum[s + 1][c - s - 1];\n\t\t\t\tres = (res + add) % mod;\n\t\t\t}\n\t\t}\n\t\tres = 1LL * res * fac[c - 1] % mod * binom(n, T) % mod * fac[T] % mod; \n\t\tans = (ans + res) % mod;\t\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint mod,fac[110],inv[110],f[110];\nint main()\n{\n\tre int n,k,ans=0;\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tfac[0]=1;\n\tfor(re int i=1;i<=n;i++)fac[i]=1ll*i*fac[i-1]%mod;\n\tinv[1]=1;\n\tfor(re int i=2;i<=n;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(re int i=n-k-1;i<n;i++)\n\t{\n\t\tre int k1=k-(n-i-1);\n\t\tfor(re int i1=std::max(1,i-k1);i1<i&&i1<=k1;i1++)\n\t\t{\n\t\t\tre int i2=i-i1;\n\t\t\tmemset(f,0,sizeof(f));\n\t\t\tfor(re int i=0;i<i2;i++)if(i2-i<=k1&&i+i1<=k1)f[i]=1;\n\t\t\tfor(re int i=1;i<i1;i++)\n\t\t\t{\n\t\t\t\tfor(re int j=0;j<=i2;j++)\n\t\t\t\t{\n\t\t\t\t\tf[j+1]=(f[j]+f[j+1])%mod;\n\t\t\t\t\tif(!(i2-j+i<=k1&&j+i1-i<=k1))f[j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(re int j=0;j<=i2;j++)ans=(ans+1ll*inv[i+1]*f[j])%mod;\n\t\t//\tprintf(\"****%d %d %d %lld\\n\",i,i1,i2,1ll*ans*fac[n]%mod);\n\t\t}\n\t}\n\tif(k==n-1)ans++;\n\tans=1ll*ans*fac[n]%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\n//const ll mod=1000000007;\nll mod;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=210;\nint dp[N][N];\nint n,k;\nvoid upd(int &a,int b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\nint solve(int x,int y) {\n\tif (y<0) return 0;\n\tif (y==0) return x<=1;\n\tint ans=0;\n\tfor (int a=2;a<=y+1;a++) {\n\t\tint b=x-a;\n\t\tif (b<1||b>y+1) continue;\n\t\tfor (int i=0;i<a;i++) for (int j=0;j<=b;j++) {\n\t\t\tif (i==0&&j==0) { dp[i][j]=1; continue; }\n\t\t\tdp[i][j]=0;\n\t\t\tif (i==0&&j==b) continue;\n\t\t\tif (i>0&&b-j+i-1<=y) upd(dp[i][j],dp[i-1][j]);\n\t\t\tif (j>0&&a-i+j-1<=y) upd(dp[i][j],dp[i][j-1]);\n\t\t}\n\t\tupd(ans,dp[a-1][b]);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d%lld\",&n,&k,&mod);\n\tint ans=0;\n\tfor (int deg=0;deg<=n-2;deg++) {\n\t\tans=(ans+(ll)solve(n-deg,k-deg)*powmod(n-deg,mod-2))%mod;\n\t}\n\tif (k>=n-1) {\n\t\tans=(ans+1)%mod;\n\t}\n\trep(i,1,n+1) ans=(ll)ans*i%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lol;\ntypedef unsigned long long ull;\ntypedef __uint128_t bll;\nstruct FastMod {\n\tull b, m;\n\tFastMod(ull b) : b(b), m(ull((bll(1) << 64) / b)) {}\n\tull mod(ull a) {\n\t\tull q = (ull)((bll(m) * a) >> 64);\n\t\tull r = a - q * b; \n\t\treturn r >= b ? r - b : r;\n\t}\n};\nFastMod F(2);\n\nconst int N = 2e2 + 5;\nint _w;\n\nint fac[N] , binom[N][N];\nint n , k , mod;\ninline int pls( int a , int b ) { a += b - mod; return a + ( a >> 31 & mod ); }\ninline int mns( int a , int b ) { a -= b; return a + ( a >> 31 & mod ); }\ninline void inc( int & a , int b ) { a += b - mod; a += a >> 31 & mod; }\ninline void dec( int & a , int b ) { a -= b; a += a >> 31 & mod; }\n\nint _solve( int n , int m , int k ) {\n  static int f[N][N];\n  memset( f , 0 , sizeof f );\n  f[0][0] = 1;\n  for( int i = 1 , s ; i <= m ; ++i ) {\n    s = 0;\n    for( int j = 0 ; j < n ; ++j ) {\n      inc( s , f[j][i - 1] );\n      if( (m-i+1)+(j-1) <= k && (n-j)+(i-1) <= k ) \n        f[j][i] = s;\n      else f[j][i] = 0;\n    }\n  }\n  int res = 0;\n  for( int i = 1 ; i <= n ; ++i )\n    inc( res , f[i][m] );\n  return res;\n}\n\nint solve( int n , int k ) {\n  if( n == 1 ) return 1;\n  int res = 0;\n  for( int i = 1 ; i - 1 <= k && i <= n ; ++i ) \n    inc( res , _solve( i , n - i , k ) );\n  res = F.mod( (ull)res * fac[n - 1] );\n  return res;\n}\n\nint main( void ) {\n  _w = scanf(\"%d%d%d\",&n,&k,&mod);\n  F = FastMod( mod );\n  fac[0] = fac[1] = 1;\n  for( int i = 0 ; i <= n ; ++i ) {\n    binom[i][0] = 1;\n    for( int j = 1 ; j <= i ; ++j )\n      binom[i][j] = pls( binom[i - 1][j] , binom[i - 1][j - 1] );\n  }\n  for( int i = 2 ; i <= n ; ++i )\n    fac[i] = F.mod( (ull)fac[i - 1] * i );\n  int ans = 0;\n  for( int i = 0 ; i <= k ; ++i )\n    ans = F.mod( F.mod( (ull)binom[n][i] * fac[i] ) * solve( n - i , k - i ) + ans );\n  printf(\"%d\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll dp[202][202];\n\n\nll hoge(int N,int K) {\n\t\n\tif(N==1) return 1;\n\tif(N==2) return 0;\n\t\n\tint x,y,k,l,i;\n\tll ret=0;\n\tfor(k=1;k<=N-2;k++) {\n\t\tl=N-1-k;\n\t\tif(k>K || l>K) continue;\n\t\tZERO(dp);\n\t\tdp[0][0]=1;\n\t\tFOR(y,k+1) FOR(x,l+1) {\n\t\t\tif(y==0&&x==l) dp[y][x]=0;\n\t\t\tif(y-1+(l-x)>K) continue;\n\t\t\tif(x+(k-y)>K) continue;\n\t\t\t//cout<<y<<x<<\" \"<<dp[y][x]<<endl;\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\t(dp[y][x+1]+=dp[y][x])%=mo;\n\t\t}\n\t\tret+=dp[k][l];\n\t}\n\t//cout<<N<<K<<\" \"<<ret<<endl;\n\tfor(i=1;i<=N-1;i++) ret=ret*i%mo;\n\t//cout<<N<<K<<\" \"<<ret<<endl;\n\treturn ret;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tll ret=0;\n\tll fac=1;\n\twhile(2*K>=N-1) {\n\t\tret+=fac*hoge(N,K)%mo;\n\t\tfac=fac*N%mo;\n\t\tN--,K--;\n\t}\n\t\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 205;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, k, P, fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nint solve(int n, int k) {\n\tint ans = 0;\n\tfor (int deg = 1; deg <= k && deg <= n - 2; deg++) {\n\t\tstatic int dp[MAXN][MAXN];\n\t\tif ((n - 1) - deg > k) continue;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][deg] = 1, dp[0][deg + 1] = P - 1;\n\t\tfor (int i = 0; i <= deg - 1; i++)\n\t\tfor (int j = deg; j <= n - 1; j++) {\n\t\t\tupdate(dp[i][j], dp[i][j - 1]);\n\t\t\tint tmp = dp[i][j], l = max(max(j, i + 2), n + i - k), r = min(n - 1, k + (i + 1));\n\t\t\tif (l <= r) update(dp[i + 1][l], tmp), update(dp[i + 1][r + 1], P - tmp);\n\t\t}\n\t\tfor (int i = deg; i <= n - 1; i++) {\n\t\t\tupdate(dp[deg][i], dp[deg][i - 1]);\n\t\t\tupdate(ans, dp[deg][i]);\n\t\t}\n\t}\n\treturn 1ll * ans * fac[n - 1] % P;\n}\nint main() {\n\tread(n), read(k), read(P);\n\tinit(n); int ans = (k == n - 1) ? fac[n] : 0;\n\tfor (int i = 3; i <= n; i++)\n\t\tupdate(ans, 1ll * fac[n] * inv[i] % P * solve(i, k - (n - i)) % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200;\n\nint mod;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m;\n\nvoid into(){\n  scanf(\"%d%d%d\",&n,&m,&mod);\n}\n\nint inv[N+9],fac[N+9],ifac[N+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint dp[N+9][N+9];\n\nint Get_dp(int a,int b,int m){\n  for (int i=1;i<=a;++i){\n\tint sum=0;\n\tfor (int j=b;j>=0;--j){\n\t  sum=i>1?add(sum,dp[i-1][j]):1;\n\t  dp[i][j]=i-1+j<=m&&a-i+b-j<=m?sum:0;\n\t}\n\tdp[1][0]=0;\n  }\n  return dp[a][0];\n}\n\nint Get_ans(int n,int m){\n  if (n==1) return 1;\n  int res=0;\n  for (int i=2;i<n;++i) sadd(res,Get_dp(i,n-i,m));\n  return mul(res,fac[n-1]);\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=0;i<=m;++i) sadd(ans,mul(mul(fac[n],ifac[n-i]),Get_ans(n-i,m-i)));\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint MOD;\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\ninline int sub(int a,int b)\n{a-=b;return a<0?a+MOD:a;}\ninline int mul(int a,int b)\n{return 1ll*a*b%MOD;}\nint ksm(int a,int b)\n{\n\tint ans=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1)ans=mul(ans,a);\n\treturn ans;\n}\nconst int Q=255;\nint f[Q][Q];\nint fac[Q+1],ifac[Q+1];\nint G(int n,int m,int k)\n{\n\tif(n>k||m>k)return 0;\n\tmemset(f,0,sizeof(f));\n\tfor(int j=0;j<=min(m-1,k-n);j++)\n\t\tf[1][j]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tif(!f[i][j])continue;\n\t\t\tint r=min(i+k-n,m),l=max(j,m-k+i);\n\t\t\tif(l<=r)f[i+1][l]=add(f[i+1][l],f[i][j]),f[i+1][r+1]=sub(f[i+1][r+1],f[i][j]);\n\t\t}\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tf[i+1][j]=add(f[i+1][j],f[i+1][j-1]);\n\t}\n\tint als=0;\n\tfor(int j=0;j<=m;j++)\n\t\tals=add(als,f[n][j]);\n\treturn mul(als,fac[n+m]);\n}\nint main()\n{\n\tint n,kk;\n\tscanf(\"%d%d%d\",&n,&kk,&MOD);\n\tfac[0]=1;\n\tfor(int i=1;i<=Q;i++)\n\t\tfac[i]=mul(fac[i-1],i);\n\tifac[Q]=ksm(fac[Q],MOD-2);\n\tfor(int i=Q;i;--i)\n\t\tifac[i-1]=mul(ifac[i],i);\n\tint als=mul(kk==n-1,fac[n]);\n\tfor(int d=0;d<kk;d++)\n\t\tfor(int i=1;i<=n-d-2;i++)\n\t\t\tals=add(als,mul(mul(fac[n],ifac[n-d]),G(i,n-d-i-1,kk-d)));\n\tprintf(\"%d\\n\",als);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 210;\nint mod;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\nint n,_lim;\nint binom[N][N],fac[N];\n\nint dp[N][N];\n\ninline int getmat(int k,int l,int lim){\n\tfor(int i=1;i<=l;i++){\n\t\tfor(int j=0;j<k;j++){\n\t\t\tif(i==1&&!j)dp[i][j]=1;\n\t\t\telse dp[i][j]=0;\n\t\t\tif(i)dp[i][j]=add(dp[i][j],dp[i-1][j]);\n\t\t\tif(j)dp[i][j]=add(dp[i][j],dp[i][j-1]);\n\t\t\tif(l-i+1+j-1>lim&&j)dp[i][j]=0;\n\t\t}\n\t\tfor(int j=0;j<k;j++)if(k-j+i-1>lim)dp[i][j]=0;\n//\t\tfor(int j=0;j<k;j++)cout << dp[i][j] << \" \";\n//\t\tputs(\"\");\n\t}\n\tint ans=0;\n\tfor(int j=1;j<k;j++)ans=add(ans, dp[l][j]);\n//\tcerr << k << \":\" << l << \":\" << lim << \":\" << ans << endl;\n\treturn ans;\n}\n\ninline int solve(int lim,int n){\n\tif(n==1)return 0;\n\tif(n==0)return 1;\n\tif(lim<0)return 0;\n\tint ret=0;\n\tfor(int k=1;k-1<=lim&&k<=n;k++){\n\t\tint tmp=mul(binom[n-1][k-1],mul(fac[n-k],fac[k-1]));\n\t\tret=add(ret,mul(tmp, getmat(k,n-k,lim)));\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tcin >> n >> _lim >> mod;\n\tfor(int i=0;i<=n;i++)for(int j=binom[i][0]=1;j<=i;j++)binom[i][j]=add(binom[i-1][j],binom[i-1][j-1]);\n\tfor(int i=fac[0]=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tint ans=0;\n\tfor(int i=0;i<=_lim+1;i++){\n\t\tans=add(ans, mul(mul(fac[i],binom[n][i]),solve(_lim-i, n-i)));\n//\t\tcout << ans << endl;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n//extern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\nmodinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=ten(5);\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nconst int nmax=110;\nmint dp[nmax][nmax];\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,k;cin>>n>>k;\n\tcin>>base.mod;\n\t\n\tinitfact();\n\t\n\tmint ans=0;\n\trng(c,3,n+1){\n\t\tint lim=k-(n-c);\n\t\tif(lim<=0)continue;\n\t\trng(w,1,c-1){\n\t\t\tint h=c-w;\n\t\t\tif(h-1>lim||w-1>lim)continue;\n\t\t\tzero(dp);\n\t\t\t\n\t\t\tdp[1][0]=1;\n\t\t\trng(i,1,h+1)rep(j,w+1){\n\t\t\t\tif(i==h&&j==0)dp[i][j]=0;\n\t\t\t\tif(i<h&&h-1-i+j<=lim){\n\t\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(j<w&&w-1-j+i<=lim){\n\t\t\t\t\tdp[i][j+1]+=dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmint z=dp[h][w];\n\t\t\tans+=fact[n]*finv[c]*fact[c-1]*z;\n\t\t}\n\t}\n\t\n\tif(k==n-1)ans+=fact[n];\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=205;\nint n,K,mo,i,j,k,l,f[N][N],ans,C[N][N],fac[N];\ninline void add(int&a,const int&b){a+=b-mo;a+=a>>31&mo;}\ninline int calc(int x,int y,int lim){\n\tfor(k=0;k<=x;++k)for(l=0;l<=y;++l)f[k][l]=0;\n\tf[x-1][y]=1;\n\tfor(k=x;k>=0;--k)for(l=y;l>=0;--l){\n\t\tif(k==0 && l==y)f[k][l]=0;\n\t\tif(k && k-1+y-l<=lim)add(f[k-1][l],f[k][l]);\n\t\tif(l && l-1+x-k<=lim)add(f[k][l-1],f[k][l]);\n\t}\n\treturn f[0][0];\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&K,&mo);\n\tfor(i=**C=1;i<N;++i)for(j=*C[i]=1;j<=i;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\tfor(i=*fac=1;i<N;++i)fac[i]=1ll*fac[i-1]*i%mo;if(K>=n-1)ans=fac[n];\n\tfor(i=1;i<=n;++i)for(j=1;i+j<=n;++j)if(n-j-1<=K)\n\t\tans=(ans+1ll*C[n][i+j]*C[i-1+j][j]%mo*fac[n-i-j]%mo*fac[i-1]%mo*fac[j]%mo*calc(i,j,K-(n-i-j)))%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nint Mod;\nconst int MN = 205;\n\ninline void Sub(int &x, int y) { x -= y; x += x >> 31 & Mod; }\ninline void Add(int &x, int y) { Sub(x, Mod - y); }\n\nint Inv[MN];\n\nint N, K;\nstd::vector<int> vec[MN];\nint f[MN][MN][MN], tmp[MN][MN];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &K, &Mod);\n\tInv[1] = 1;\n\tfor (int i = 2; i <= N; ++i) Inv[i] = (LL)(Mod - Mod / i) * Inv[Mod % i] % Mod;\n\tfor (int i = 0; i + (N - i) / 2 <= K; ++i) {\n\t\t// 1 <= Q < P\n\t\t// P + Q = N - i\n\t\t// i + P - 1 <= K\n\t\tfor (int P = 0; P < N - i; ++P) {\n\t\t\tint Q = N - i - P;\n\t\t\tif (Q >= P || i + P - 1 > K) continue;\n\t\t\tint dif = P - Q - 1;\n\t\t\tvec[dif].push_back(P);\n\t\t}\n\t}\n\tint Ans = K == N - 1 ? 1 : 0;\n\tfor (int d = 0; d <= N; ++d) if (!vec[d].empty()) {\n\t\tstd::sort(vec[d].begin(), vec[d].end());\n\t\tint lim = vec[d].back();\n\t\tf[1][0][1] = f[1][0][2] = 0;\n\t\tf[1][0][d ? 1 : 2] = 1;\n\t\tfor (int i = 2; i <= lim; ++i) {\n\t\t\t// f[i - 1][x][y] -> f[i][j][y + t] : t = (j == i - 1) + (j == i - d - 1);\n\t\t\tfor (int k = 1; k <= (d ? i : 2 * i); ++k) {\n\t\t\t\ttmp[0][k] = f[i - 1][0][k];\n\t\t\t\tfor (int j = 1; j < i && j <= lim - d - 1; ++j)\n\t\t\t\t\tAdd(tmp[j][k] = tmp[j - 1][k], f[i - 1][j][k]);\n\t\t\t}\n\t\t\tfor (int j = (i < d ? 0 : i - d - 1); j < i && j <= lim - d - 1; ++j) {\n\t\t\t\tint t = (j == i - 1) + (j == i - d - 1);\n\t\t\t\tfor (int k = t; k <= (d ? i : 2 * i); ++k)\n\t\t\t\t\tf[i][j][k] = tmp[j][k - t];\n\t\t\t}\n\t\t}\n\t\tfor (int P : vec[d])\n\t\t\tfor (int k = 1; k <= (d ? P : 2 * P); ++k) if (f[P][P - d - 1][k])\n\t\t\t\tAns = (Ans + (LL)f[P][P - d - 1][k] * Inv[k - 1]) % Mod;\n\t}\n\tfor (int i = 1; i <= N; ++i) Ans = (LL)Ans * i % Mod;\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define inver(a) power(a,mod-2)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=200+5;\nint n,K,mod;\nint fac[maxn],inv[maxn],C[maxn][maxn];\nint dp[maxn][maxn];\ninline int add(int x) {return x>=mod?x-mod:x;}\nll power(ll x,ll y) {\n\tll re=1;\n\twhile(y) {\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\nint sol(int k,int l,int K) {\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int j=1;j<=l;++j) {\n\t\tint sum=0;\n\t\tfor(int i=0;i<k;++i) {\n\t\t\tsum=add(sum+dp[i][j-1]);\n\t\t\tif((l-j+1)+(i-1)<=K&&(k-i)+(j-1)<=K) dp[i][j]=sum;\n\t\t}\n\t}\n\tint an=0;\n\tfor(int i=1;i<k;++i) an=add(an+dp[i][l]);\n\treturn an;\n}\nint sol(int n,int K) {\n\tif(n==1) return 1;\n\tint an=0;\n\tfor(int i=1;i<=K+1;++i) an=add(an+sol(i,n-i,K));\n\tan=(ll)an*fac[n-1]%mod;\n//\tdebug(\"%d %d %d\\n\",n,K,an);\n\treturn an;\n}\nvoid init() {\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=inver(fac[n]);\n\tfor(int i=n;i>=1;--i) inv[i-1]=(ll)inv[i]*i%mod;\n\tfor(int i=0;i<=n;++i) {\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(int j=1;j<i;++j) C[i][j]=add(C[i-1][j-1]+C[i-1][j]); \n\t}\n}\nint main() {\n\trd(n),rd(K),rd(mod);\n\tinit();\n\tint an=0;\n\tfor(int i=0;i<=K;++i) an=(an+(ll)sol(n-i,K-i)*C[n][i]%mod*fac[i])%mod;\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=205; int P;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n, lim, f[N][N], C[N][N], fac[N], ans; \n\nint calc(int k, int l, int lim) {\n\trep(i, 1, l) {\n\t\tlop(j, 0, k) {\n\t\t\tif (i == 1 && !j) f[i][j] = 1; else f[i][j] = 0;\n\t\t\tif (i) f[i][j] = add(f[i][j], f[i-1][j]); \n\t\t\tif (j) f[i][j] = add(f[i][j], f[i][j-1]); \n\t\t\tif (l-i+1+j-1 > lim && j) f[i][j] = 0; \n\t\t}\n\t\tlop(j, 0, k) if (k-j+i-1 > lim) f[i][j] = 0; \n\t}\n\tint ans = 0; \n\tlop(j, 1, k) ans = add(ans, f[l][j]); \n\treturn ans; \n}\n\nint solve(int lim, int n) {\n\tif (n == 1) return 0; \n\tif (n == 0) return 1; \n\tif (lim < 0) return 0; \n\tint r = 0; \n\trep(k, 1, min(n,lim+1)) {\n\t\tint t = mul(C[n-1][k-1], mul(fac[n-k], fac[k-1]));\n\t\tr = add(r, mul(t, calc(k, n-k, lim))); \n\t}\n\treturn r;\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tcin >> n >> lim >> P; \n\tC[0][0] = 1; \n\trep(i, 1, n) {\n\t\tC[i][0] = 1; \n\t\trep(j, 1, i) C[i][j] = add(C[i-1][j], C[i-1][j-1]); \n\t}\n\tfac[0] = 1; \n\trep(i, 1, n) fac[i] = mul(fac[i-1], i); \n\trep(i, 0, lim+1) {\n\t\tans = add(ans, mul(mul(fac[i], C[n][i]), solve(lim - i, n - i))); \n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": " "
  },
  {
    "language": "Python",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:03:25       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nMint Solve(int n, int k) {\n  if (n == 1 && k == 0) {\n    return 1;\n  }\n  if (n < 3) {\n    return 0;\n  }\n  Mint ret = 0;\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(n + 1, 0));\n  for (int me = 1; me <= n - 2 && me <= k; me++) {\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][me] = 1;\n    for (int i = 0; i < me; i++) {\n      for (int j = me; j < n; j++) {\n        Mint ft = dp[i][j];\n        if (ft == 0) {\n          continue;\n        }\n        int upper = min(n, k + i + 2);\n        if ((n + i) - (j + 1) <= k) {\n          for (int t = j; t < upper; t++) {\n            dp[i + 1][t] += ft;\n          }\n        } else {\n          dp[i + 1][j] += ft;\n        }\n      }\n    }\n    for (int j = me + 1; j < n; j++) {\n      bool ok = true;\n      for (int x = j + 1; x < n; x++) {\n        int last = n + me;\n        int deg = last - x;\n        if (deg > k) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        ret += dp[me][j];\n      }\n    }\n  }\n  for (int i = 1; i <= n - 1; i++) {\n    ret *= i;\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k >> md;\n  Mint ans = 0;\n  Mint coeff = 1;\n  while (2 * k >= n - 1) {\n    ans += Solve(n, k) * coeff;\n    coeff *= n;\n    --n;\n    --k;\n  }\n  cout << ans << '\\n';\n  debug(clock());\n  return 0;\n}\n"
  }
]